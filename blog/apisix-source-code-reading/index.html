<!DOCTYPE html>

<html lang="zh-cn"><head>
  <meta charset="utf-8">
  
  <title>云原生网关 APISIX 核心流程源码分析与进化方向思考 | 云原生社区</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文针对云原生网关 APISIX 的核心流程以源码分析的方式剖析其工作原理，并对于网关未来的发展方向进行了思考。">
  
  <meta name="author" content=" 云原生社区">
  <meta name="generator" content="Hugo 0.65.3" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="/plugins/bootstrap/bootstrap.min.css">
  
  <link rel="stylesheet" href="/plugins/slick/slick.css">
  
  <link rel="stylesheet" href="/plugins/fontawesome/all.css">
  
  <link rel="stylesheet" href="/plugins/animate/animate.css">
  
  <link rel="stylesheet" href="/plugins/venobox/venobox.css">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="/scss/style.min.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="/images/favicon.png " type="image/x-icon">
  <link rel="icon" href="/images/favicon.png " type="image/x-icon">
  <meta property="og:image" content="https://cloudnative.to/images/favicon.png">
  <!--Algolia-->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.min.css">
  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="Cloud Native Community|云原生社区" />
  <meta name="twitter:creator" content="@CloudNativeCN" />
  <meta property="og:url" content="https://cloudnative.to/blog/apisix-source-code-reading/" />
  <meta property="og:title" content="云原生网关 APISIX 核心流程源码分析与进化方向思考" />
  <meta property="og:description" content="本文针对云原生网关 APISIX 的核心流程以源码分析的方式剖析其工作原理，并对于网关未来的发展方向进行了思考。" />
  <meta property="og:image" content="https://cloudnative.to/images/blog/apisix-heading.png" />
</head>
<body>
<!-- header -->

<img src="images/logo-square.jpg" width="0" height="0" />
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
     <img src="" width='700'>
</div>
<header>
  

  <!-- navigation -->
  <div class="navigation bg-white position-relative">
    <div class="container">
      <nav class="navbar navbar-expand-lg navbar-light bg-white">
        <a class="navbar-brand" href="/"><img class="img-fluid pb-lg-3" src="/images/logo.png" width="189px" alt="云原生社区"></a>
        <button class="navbar-toggler border-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link" href="/"></a>
            </li>
            
            
            <li class="nav-item">
              <a class="nav-link" href="/blog/">博客</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="/community/sig/">兴趣小组</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="/contribute">投稿</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="/job">招聘</a>
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                aria-expanded="false">
                社区
              </a>
              <div class="dropdown-menu" >
                
                <a class="dropdown-item" href="/team">管理委员会</a>
                
                <a class="dropdown-item" href="/academy/">云原生学院</a>
                
                <a class="dropdown-item" href="/city">城市站</a>
                
                <a class="dropdown-item" href="/community/">社区资料</a>
                
              </div>
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                aria-expanded="false">
                资料
              </a>
              <div class="dropdown-menu" >
                
                <a class="dropdown-item" href="http://landscape.opensourcecloud.cn/">云原生生态图景</a>
                
                <a class="dropdown-item" href="/kubebuilder">Kubebuilder 中文文档</a>
                
                <a class="dropdown-item" href="/envoy">Envoy 中文文档</a>
                
                <a class="dropdown-item" href="https://istio.io/latest/zh/">Istio 中文文档</a>
                
              </div>
            </li>
            
            
          </ul>

          
          

          
          
          <!-- get start btn -->
          <a href="/contact" class="btn btn-primary hover-ripple">加入我们</a>
          
        </div>
      </nav>
    </div>
  </div>
  <!-- /navigation -->
</header>
<!-- /header -->

	<!-- page title -->
<section class="section bg-cover overlay" style="background-image: url('/'),url('/'),url('/images/backgrounds/page-title-5.jpg');">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <h2 class="text-white mb-3">云原生网关 APISIX 核心流程源码分析与进化方向思考</h2>
        <!-- breadcrumb -->
        
        <p class="text-white">本文针对云原生网关 APISIX 的核心流程以源码分析的方式剖析其工作原理，并对于网关未来的发展方向进行了思考。</p>
      </div>
    </div>
  </div>
</section>
<!-- /page title -->

	

<!-- blog details -->
<section class="section">
  <div class="container blog">
    <div class="row">
      <div class="col-lg-8">
        <!-- post thumb -->
        <div class="position-relative mb-5">
          <img src="/"  onerror="this.src='\/images\/blog\/apisix-heading.png'" alt="post thumb" class="img-fluid w-100">
           <div class="card-type"><a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f">云原生</a></div>
        </div>
        <div class="card-meta mb-2">作者  <strong class="text-dark"><a href="https://github.com/mayocream">Mayo Cream</a></strong>
          
            发表于 <strong class="text-dark">2021年10月24日</strong></div>
        <hr>
        <div class="content">
          <p>本文基于 <a href="https://github.com/apache/apisix">APISIX</a> 2.6 版本进行源码分析，源码阅读注释仓库: <a href="https://github.com/mayocream/apisix/tree/review">review</a>，分析主要流程以及核心机制。</p>
<h2 id="1-apisix-概述">1. APISIX 概述</h2>
<p>APISIX 与 Kong 类似，是一个基于 OpenResty 构建的 API 网关，如果你熟悉 OpenResty，你大概能猜到本文会讲述 APISIX 在 OpenResty 的几大生命周期中，
做了什么动作来进行路由匹配、服务发现、负载均衡以及加载插件。
如果你还想了解 Kong 网关是如何运作的，可以查看我的另一篇文章 <a href="https://shoujo.ink/2021/09/kong-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Kong 源码分析</a>。
当然，APISIX 不同于 Kong 的地方，例如 etcd 数据变化监听、强大的缓存机制、以及在性能优化上做的尝试，本文也会一一阐述。</p>
<h3 id="11-项目概述">1.1. 项目概述</h3>
<p>APISIX 是基于 OpenResty 开发的 API 网关，与 OpenResty 的请求生命周期一致，APISIX 利用 Lua Nginx Module 提供的 <code>*_by_lua</code> 添加 Hook。</p>
<p><img src="gateway-traffic.png" alt="API Gateway traffic"></p>
<p>APISIX 抽象了 Route、Service、Upstream、Plugin、Consumer 等数据模型，与 Kong 网关如出一辙。</p>
<p><img src="114740649-a9bf2200-9d67-11eb-8e1d-1409fb5c18c2.png" alt="APISIX">
<img src="Kong-GS-overview.png" alt="Kong"></p>
<p>基本上可以看作 APISIX 是 Kong 网关的重构——运用大量 LuaJIT、OpenResty 技巧优化性能、简化复杂的数据结构、替换储存引擎为 etcd 等。</p>
<p><img src="graph-1.png" alt=""></p>
<p>值得一提的是，在 APISIX 的一个 issue 中，项目开发者说不确定是什么原因，我们看看 Kong 网关是怎么解决的吧。</p>
<blockquote>
<p>&ldquo;How does Kong solve similar problems?&quot;<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
</blockquote>
<h3 id="12-生态概述">1.2. 生态概述</h3>
<p>Kong 网关开源生态有的，APISIX 基本都有或者正在做。包含：Kubernetes Ingress Controller、Mesh、Dashboard。</p>
<p>插件方面比 Kong 开源版本多了 Skywalking APM 数据上报、Traffit 流量拆分、Mirror 流量镜像等功能。</p>
<h2 id="2-基本流程">2. 基本流程</h2>
<p>本节概述 APISIX 的目录结构，以及其启动流程。</p>
<h3 id="21-目录结构">2.1. 目录结构</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tree -L <span style="color:#ae81ff">2</span>
.
├── apisix
│   ├── admin <span style="color:#75715e"># Admin API</span>
│   ├── api_router.lua
│   ├── balancer <span style="color:#75715e"># 负载均衡器</span>
│   ├── balancer.lua
│   ├── cli <span style="color:#75715e"># CLI, Lua 脚本</span>
│   ├── constants.lua <span style="color:#75715e"># 常量</span>
│   ├── consumer.lua
│   ├── control
│   ├── core <span style="color:#75715e"># 主要是封装的公共方法</span>
│   ├── core.lua
│   ├── debug.lua
│   ├── discovery <span style="color:#75715e"># 服务发现, 支持 consul, eruka, dns</span>
│   ├── http
│   ├── init.lua <span style="color:#75715e"># _by_lua 函数入口</span>
│   ├── patch.lua
│   ├── plugin_config.lua
│   ├── plugin.lua <span style="color:#75715e"># 插件</span>
│   ├── plugins
│   ├── router.lua <span style="color:#75715e"># Router</span>
│   ├── schema_def.lua <span style="color:#75715e"># jsonschema 定义</span>
│   ├── script.lua
│   ├── ssl
│   ├── ssl.lua
│   ├── stream
│   ├── timers.lua <span style="color:#75715e"># timer 封装</span>
│   ├── upstream.lua
│   └── utils
├── bin
│   └── apisix <span style="color:#75715e"># apisix CLI, shell 脚本</span>
├── ci <span style="color:#75715e"># CI 脚本</span>
├── conf <span style="color:#75715e"># 默认配置文件</span>
├── deps
├── docs
├── Makefile <span style="color:#75715e"># 快捷指令</span>
├── rockspec <span style="color:#75715e"># luarocks 包管理</span>
├── t <span style="color:#75715e"># Test::Nginx 测试</span>
└── utils <span style="color:#75715e"># Shell 脚本</span>
</code></pre></div><h3 id="22-启动流程">2.2. 启动流程</h3>
<p><img src="graph-2.png" alt=""></p>
<p>CLI 默认会用 LuaJIT 启动，若版本不够便退回到 Lua 5.1 解释器执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 查找 APISIX LUA 包路径</span>
<span style="color:#75715e"># shell -s 判断文件是否存在且 size &gt; 0</span>
<span style="color:#75715e"># ref: https://stackoverflow.com/questions/53319817/what-is-the-meaning-of-n-z-x-l-d-etc-in-shell-script</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -s <span style="color:#e6db74">&#39;./apisix/cli/apisix.lua&#39;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
	...
<span style="color:#66d9ef">fi</span>

<span style="color:#75715e"># shell -e 判断文件是否存在</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> -e $OR_EXEC <span style="color:#f92672">&amp;&amp;</span> <span style="color:#e6db74">&#34;</span>$OR_VER<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">=</span>~ <span style="color:#e6db74">&#34;1.19&#34;</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
    <span style="color:#75715e"># use the luajit of openresty</span>
    echo <span style="color:#e6db74">&#34;</span>$LUAJIT_BIN<span style="color:#e6db74"> </span>$APISIX_LUA<span style="color:#e6db74"> </span>$*<span style="color:#e6db74">&#34;</span>
    exec $LUAJIT_BIN $APISIX_LUA $*
<span style="color:#66d9ef">elif</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$LUA_VERSION<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">=</span>~ <span style="color:#e6db74">&#34;Lua 5.1&#34;</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span>
    <span style="color:#75715e"># OpenResty version is not 1.19, use Lua 5.1 by default</span>
    <span style="color:#75715e"># shell &amp;* 传递所有 args</span>
    <span style="color:#75715e"># ref: https://stackoverflow.com/questions/4824590/propagate-all-arguments-in-a-bash-shell-script</span>
    echo <span style="color:#e6db74">&#34;lua </span>$APISIX_LUA<span style="color:#e6db74"> </span>$*<span style="color:#e6db74">&#34;</span>
    exec lua $APISIX_LUA $*
<span style="color:#66d9ef">fi</span>
</code></pre></div><p>启动过程中：</p>
<ul>
<li>调用 <code>popen</code> 执行 CMD 命令；</li>
<li>使用 <a href="https://github.com/diegonehab/luasocket">luasocket</a> 库发起 HTTP 请求（非 OpenResty 运行时）；</li>
<li>使用 ltn12 <a href="http://lua-users.org/wiki/FiltersSourcesAndSinks">sink</a> 进行流处理；</li>
<li>创建 etcd prefix，value 为 <code>init</code>；</li>
</ul>
<h2 id="3-基本类型操作">3. 基本类型操作</h2>
<p>基本上为了追求极致性能，能用 FFI 调用实现的都用了。</p>
<h3 id="31-字符串">3.1. 字符串</h3>
<p>使用 FFI 调用 libc 函数 <code>memcmp</code> 进行字符串比较内存地址的前 n 长度是否相同。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> ffi         <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;ffi&#34;</span>)
<span style="color:#66d9ef">local</span> C           <span style="color:#f92672">=</span> ffi.C

<span style="color:#75715e">-- ref: https://www.cplusplus.com/reference/cstring/memcmp/</span>
<span style="color:#75715e">-- ref: https://www.tutorialspoint.com/c_standard_library/c_function_memcmp.htm</span>
ffi.cdef<span style="color:#e6db74">[[
</span><span style="color:#e6db74">    int memcmp(const void *s1, const void *s2, size_t n);
</span><span style="color:#e6db74">]]</span>
</code></pre></div><p>接收类型是 <code>const void *</code>，不可变类型可以直接传入 Lua string 类型。</p>
<blockquote>
<p>如果你的 C 函数接受 <code>const char *</code> 或者等价的 <code>const unsigned char/int8_t/... *</code> 这样的参数类型，
可以直接传递 Lua string 进去，而无需另外准备一个 <code>ffi.new</code> 申请的数组。<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
</blockquote>
<p>string 前缀比较，比较 s, prefix 内存地址的前 n (#prefix) 长度是否相同。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- 用 ffi 扩展 string 方法</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">has_prefix</span>(s, prefix)
    <span style="color:#66d9ef">if</span> type(s) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;string&#34;</span> <span style="color:#f92672">or</span> type(prefix) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;string&#34;</span> <span style="color:#66d9ef">then</span>
        error(<span style="color:#e6db74">&#34;unexpected type: s:&#34;</span> <span style="color:#f92672">..</span> type(s) <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;, prefix:&#34;</span> <span style="color:#f92672">..</span> type(prefix))
    <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">#</span>s <span style="color:#f92672">&lt;</span> <span style="color:#f92672">#</span>prefix <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
    <span style="color:#66d9ef">end</span>
    <span style="color:#75715e">-- 比较 s, prefix 内存地址的前 n (#prefix) 长度是否相同</span>
    <span style="color:#66d9ef">local</span> rc <span style="color:#f92672">=</span> C.memcmp(s, prefix, <span style="color:#f92672">#</span>prefix)
    <span style="color:#66d9ef">return</span> rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>同理比较后缀：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">C.memcmp(ffi_cast(<span style="color:#e6db74">&#34;char *&#34;</span>, s) <span style="color:#f92672">+</span> <span style="color:#f92672">#</span>s <span style="color:#f92672">-</span> <span style="color:#f92672">#</span>suffix, suffix, <span style="color:#f92672">#</span>suffix)
</code></pre></div><h3 id="32-table">3.2. Table</h3>
<p>Table 是 Lua 中最常用的类型了，与其他语言比较的话相当于 PHP 的 Array 一样实用。</p>
<p>Lua Table 需要注意的地方其一：</p>
<blockquote>
<p>table.new(narray, nhash)</p>
<p>这个函数，会预先分配好指定的数组和哈希的空间大小，而不是在插入元素时自增长，这也是它的两个参数 narray 和 nhash 的含义。
如果不使用这个函数，自增长是一个代价比较高的操作，会涉及到空间分配、resize 和 rehash 等，我们应该尽量避免。</p>
<p>table.new 的文档并没有出现在 LuaJIT 的官网，而是深藏在 GitHub 项目的 <a href="https://github.com/openresty/luajit2/blob/v2.1-agentzh/doc/extensions.html">扩展文档</a> 里，用谷歌也很难找到，所以很多人并不知道这个函数的存在。</p>
<p>超出预设的空间大小，也可以正常使用，只不过性能会退化，也就失去了使用 table.new 的意义。</p>
<p>需要根据实际场景，来预设好 table.new 中数组和哈希空间的大小，这样才能在性能和内存占用上找到一个平衡点。<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></p>
</blockquote>
<p>Lua Table 需要注意的地方其二：</p>
<blockquote>
<p>table.insert 虽然是一个很常见的操作，但性能并不乐观。
如果不是根据指定下标来插入元素，那么每次都需要调用 LuaJIT 的 lj_tab_len 来获取数组的长度，以便插入队尾。获取 table 长度的时间复杂度为 O(n) 。</p>
</blockquote>
<p>参考 APISIX 作者给 <a href="https://github.com/kubernetes/ingress-nginx">ingress-nginx</a> 项目提的 Table 操作优化 PR：<a href="https://github.com/kubernetes/ingress-nginx/pull/3673">used table functions of LuaJIT for better performance.</a></p>
<p>OpenResty Fork 的 LuaJIT 新增的 table 函数<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>：</p>
<ul>
<li>table.isempty</li>
<li>table.isarray</li>
<li>table.nkeys</li>
<li>table.clone</li>
</ul>
<p>回到 APISIX 封装的 Table 操作符：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- 自行构建 index 插入 table, 比 table.insert 效率高</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">insert_tail</span>(tab, ...)
    <span style="color:#66d9ef">local</span> idx <span style="color:#f92672">=</span> <span style="color:#f92672">#</span>tab
    <span style="color:#75715e">-- 遍历输入的参数</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, select(<span style="color:#e6db74">&#39;#&#39;</span>, ...) <span style="color:#66d9ef">do</span>
        idx <span style="color:#f92672">=</span> idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        tab[idx] <span style="color:#f92672">=</span> select(i, ...)
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> idx
<span style="color:#66d9ef">end</span>
</code></pre></div><p><code>select('#', ...)</code> 获取输入参数的数量，<code>select(i, ...)</code> 获取第 n 个参数，Table 的遍历中大量使用该结构。</p>
<p><code>try_read_attr</code> 实现了 <code>path.node.x</code> 的 table 访问方式，便于读取多层级配置项。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">try_read_attr</span>(tab, ...)
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, select(<span style="color:#e6db74">&#39;#&#39;</span>, ...) <span style="color:#66d9ef">do</span>
        <span style="color:#66d9ef">local</span> attr <span style="color:#f92672">=</span> select(i, ...)
        <span style="color:#66d9ef">if</span> type(tab) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;table&#34;</span> <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
        <span style="color:#66d9ef">end</span>

        tab <span style="color:#f92672">=</span> tab[attr]
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> tab
<span style="color:#66d9ef">end</span>
</code></pre></div><p>使用示例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">    <span style="color:#66d9ef">local</span> size <span style="color:#f92672">=</span> core_tab.try_read_attr(local_conf, <span style="color:#e6db74">&#34;graphql&#34;</span>, <span style="color:#e6db74">&#34;max_size&#34;</span>)
    <span style="color:#66d9ef">if</span> size <span style="color:#66d9ef">then</span>
        max_size <span style="color:#f92672">=</span> size
    <span style="color:#66d9ef">end</span>
</code></pre></div><h2 id="4-工具类">4. 工具类</h2>
<p>APISIX 封装了许多工具类，这些工具共同组成了 APISIX 的 PDK（Plugin Development Kit），利用这些方法，插件开发能够增速许多。</p>
<h3 id="41-json-操作">4.1. JSON 操作</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> delay_tab <span style="color:#f92672">=</span> setmetatable({data <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>, force <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>}, {
    __tostring <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(self)
        <span style="color:#66d9ef">local</span> res, err <span style="color:#f92672">=</span> encode(self.data, self.force)
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> res <span style="color:#66d9ef">then</span>
            ngx.log(ngx.WARN, <span style="color:#e6db74">&#34;failed to encode: &#34;</span>, err,
                    <span style="color:#e6db74">&#34; force: &#34;</span>, self.force)
        <span style="color:#66d9ef">end</span>

        <span style="color:#66d9ef">return</span> res
    <span style="color:#66d9ef">end</span>
})


<span style="color:#75715e">-- this is a non-thread safe implementation</span>
<span style="color:#75715e">-- it works well with log, eg: log.info(..., json.delay_encode({...}))</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">delay_encode</span>(data, force)
    delay_tab.data <span style="color:#f92672">=</span> data
    delay_tab.force <span style="color:#f92672">=</span> force
    <span style="color:#66d9ef">return</span> delay_tab
<span style="color:#66d9ef">end</span>
</code></pre></div><p>设置了元表的 <code>__tostring</code> 方法，在字符串转换时才使用匿名函数调用 <code>json.encode</code>，在日志打印时，被忽略的日志会不执行 JSON 压缩，避免额外的性能损耗。</p>
<h3 id="42-lru-缓存">4.2. LRU 缓存</h3>
<p><a href="https://github.com/openresty/lua-resty-lrucache">lua-resty-lrucache</a> 在写入时会清理 TTL 过期的缓存，读时如果数据过期了，会作为第二个参数返回：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">get</span>(self, key)
    <span style="color:#66d9ef">local</span> hasht <span style="color:#f92672">=</span> self.hasht
    <span style="color:#66d9ef">local</span> val <span style="color:#f92672">=</span> hasht[key]
    <span style="color:#66d9ef">if</span> val <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> node <span style="color:#f92672">=</span> self.key2node[key]

    <span style="color:#75715e">-- print(key, &#34;: moving node &#34;, tostring(node), &#34; to cache queue head&#34;)</span>
    <span style="color:#66d9ef">local</span> cache_queue <span style="color:#f92672">=</span> self.cache_queue
    queue_remove(node)
    queue_insert_head(cache_queue, node)

    <span style="color:#66d9ef">if</span> node.expire <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> node.expire <span style="color:#f92672">&lt;</span> ngx_now() <span style="color:#66d9ef">then</span>
        <span style="color:#75715e">-- print(&#34;expired: &#34;, node.expire, &#34; &gt; &#34;, ngx_now())</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, val, node.user_flags
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> val, <span style="color:#66d9ef">nil</span>, node.user_flags
<span style="color:#66d9ef">end</span>
</code></pre></div><p><img src="graph-3.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fetch_valid_cache</span>(lru_obj, invalid_stale, item_ttl,
                                 item_release, key, version)
    <span style="color:#66d9ef">local</span> obj, stale_obj <span style="color:#f92672">=</span> lru_obj:get(key)
    <span style="color:#66d9ef">if</span> obj <span style="color:#f92672">and</span> obj.ver <span style="color:#f92672">==</span> version <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> obj
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 如果 TTL 到期的数据版本号仍一致, 重新 set 该缓存</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> invalid_stale <span style="color:#f92672">and</span> stale_obj <span style="color:#f92672">and</span> stale_obj.ver <span style="color:#f92672">==</span> version <span style="color:#66d9ef">then</span>
        lru_obj:set(key, stale_obj, item_ttl)
        <span style="color:#66d9ef">return</span> stale_obj
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- release 回调</span>
    <span style="color:#66d9ef">if</span> item_release <span style="color:#f92672">and</span> obj <span style="color:#66d9ef">then</span>
        item_release(obj.val)
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
<span style="color:#66d9ef">end</span>


<span style="color:#75715e">-- 返回创建 LRU 的匿名函数</span>
<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">new_lru_fun</span>(opts)
    <span style="color:#66d9ef">local</span> item_count, item_ttl
    <span style="color:#66d9ef">if</span> opts <span style="color:#f92672">and</span> opts.type <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;plugin&#39;</span> <span style="color:#66d9ef">then</span>
        item_count <span style="color:#f92672">=</span> opts.count <span style="color:#f92672">or</span> PLUGIN_ITEMS_COUNT
        item_ttl <span style="color:#f92672">=</span> opts.ttl <span style="color:#f92672">or</span> PLUGIN_TTL
    <span style="color:#66d9ef">else</span>
        item_count <span style="color:#f92672">=</span> opts <span style="color:#f92672">and</span> opts.count <span style="color:#f92672">or</span> GLOBAL_ITEMS_COUNT
        item_ttl <span style="color:#f92672">=</span> opts <span style="color:#f92672">and</span> opts.ttl <span style="color:#f92672">or</span> GLOBAL_TTL
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> item_release <span style="color:#f92672">=</span> opts <span style="color:#f92672">and</span> opts.release
    <span style="color:#66d9ef">local</span> invalid_stale <span style="color:#f92672">=</span> opts <span style="color:#f92672">and</span> opts.invalid_stale
    <span style="color:#75715e">-- 是否使用并发锁</span>
    <span style="color:#66d9ef">local</span> serial_creating <span style="color:#f92672">=</span> opts <span style="color:#f92672">and</span> opts.serial_creating
    <span style="color:#75715e">-- 参数为 LRU size</span>
    <span style="color:#66d9ef">local</span> lru_obj <span style="color:#f92672">=</span> lru_new(item_count)

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span> (key, version, create_obj_fun, ...)
        <span style="color:#75715e">-- 不支持的 yielding 的 Nginx phase 无法使用 resty.lock</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> serial_creating <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> can_yield_phases[get_phase()] <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">local</span> cache_obj <span style="color:#f92672">=</span> fetch_valid_cache(lru_obj, invalid_stale,
                                item_ttl, item_release, key, version)
            <span style="color:#66d9ef">if</span> cache_obj <span style="color:#66d9ef">then</span>
                <span style="color:#66d9ef">return</span> cache_obj.val
            <span style="color:#66d9ef">end</span>

            <span style="color:#66d9ef">local</span> obj, err <span style="color:#f92672">=</span> create_obj_fun(...)
            <span style="color:#66d9ef">if</span> obj <span style="color:#f92672">~=</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
                lru_obj:set(key, {val <span style="color:#f92672">=</span> obj, ver <span style="color:#f92672">=</span> version}, item_ttl)
            <span style="color:#66d9ef">end</span>

            <span style="color:#66d9ef">return</span> obj, err
        <span style="color:#66d9ef">end</span>

        <span style="color:#66d9ef">local</span> cache_obj <span style="color:#f92672">=</span> fetch_valid_cache(lru_obj, invalid_stale, item_ttl,
                            item_release, key, version)
        <span style="color:#66d9ef">if</span> cache_obj <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span> cache_obj.val
        <span style="color:#66d9ef">end</span>

        <span style="color:#75715e">-- 当缓存失效时获取锁</span>
        <span style="color:#75715e">-- 创建共享内存 lock</span>
        <span style="color:#66d9ef">local</span> lock, err <span style="color:#f92672">=</span> resty_lock:new(lock_shdict_name)
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> lock <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;failed to create lock: &#34;</span> <span style="color:#f92672">..</span> err
        <span style="color:#66d9ef">end</span>

        <span style="color:#66d9ef">local</span> key_s <span style="color:#f92672">=</span> tostring(key)
        log.info(<span style="color:#e6db74">&#34;try to lock with key &#34;</span>, key_s)

        <span style="color:#75715e">-- 获取 lock</span>
        <span style="color:#66d9ef">local</span> elapsed, err <span style="color:#f92672">=</span> lock:lock(key_s)
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> elapsed <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;failed to acquire the lock: &#34;</span> <span style="color:#f92672">..</span> err
        <span style="color:#66d9ef">end</span>

        <span style="color:#75715e">-- 再次获取缓存</span>
        cache_obj <span style="color:#f92672">=</span> fetch_valid_cache(lru_obj, invalid_stale, item_ttl,
                        <span style="color:#66d9ef">nil</span>, key, version)
        <span style="color:#66d9ef">if</span> cache_obj <span style="color:#66d9ef">then</span>
            lock:unlock()
            log.info(<span style="color:#e6db74">&#34;unlock with key &#34;</span>, key_s)
            <span style="color:#66d9ef">return</span> cache_obj.val
        <span style="color:#66d9ef">end</span>

        <span style="color:#66d9ef">local</span> obj, err <span style="color:#f92672">=</span> create_obj_fun(...)
        <span style="color:#66d9ef">if</span> obj <span style="color:#f92672">~=</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
            lru_obj:set(key, {val <span style="color:#f92672">=</span> obj, ver <span style="color:#f92672">=</span> version}, item_ttl)
        <span style="color:#66d9ef">end</span>
        lock:unlock()
        log.info(<span style="color:#e6db74">&#34;unlock with key &#34;</span>, key_s)

        <span style="color:#66d9ef">return</span> obj, err
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>这段代码关联到两个 PR:</p>
<ol>
<li><a href="https://github.com/apache/apisix/pull/1486">bugfix(lrucache): when creating cached objects, use resty-lock to avoid repeated creation.</a></li>
<li><a href="https://github.com/apache/apisix/pull/2575">change: make lrucache lock optional</a></li>
</ol>
<p>使用 <a href="https://github.com/openresty/lua-resty-lock">lua-resty-lock</a> 通过共享内存竞争锁，用在缓存中避免缓存击穿，当该 Lib 出于 Luajit 限制，无法在 <code>init_by_lua</code>, <code>init_worker_by_lua</code>, <code>header_filter_by_lua</code>, <code>body_filter_by_lua</code>, <code>balancer_by_lua</code>, <code>log_by_lua </code> 阶段中使用。</p>
<p>引入的 <code>serial_creating</code> 属性用于判断插件是否需要启用锁。</p>
<blockquote>
<p>Kong 使用的 <a href="https://github.com/thibaultcha/lua-resty-mlcache">lua-resty-mlcache</a> 库内部也使用 resty.lock 防止缓存击穿（可选）。</p>
</blockquote>
<h3 id="43-后台任务">4.3. 后台任务</h3>
<p>两个地方默认初始化了定时器（Nginx Timer）执行后台任务。</p>
<ol>
<li><code>init_by_lua</code> 阶段创建 OpenResty 特权进程，负责执行特定的后台任务，不会干扰其他 Worker 进程，权限相当于 root；</li>
<li><code>init_by_worker</code> 阶段创建 Background Timer，执行并发执行后台任务。</li>
</ol>
<p>OpenResty 特权进程不能处理请求，只能由 Timer 触发，逻辑上编写 <code>if type(ngx.process.type()) == &quot;privileged agent&quot;</code> 只在特权进程中执行操作。<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup></p>
<blockquote>
<p>Enables the privileged agent process in Nginx.</p>
<p>The privileged agent process does not listen on any virtual server ports like those worker processes. And it uses the same system account as the nginx master process, which is usually a privileged account like <code>root</code>.</p>
<p>The <code>init_worker_by_lua*</code> directive handler still runs in the privileged agent process. And one can use the <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/process.md#type">type</a> function provided by this module to check if the current process is a privileged agent.<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- worker 默认后台运行的 timer, 执行各种后台任务 </span>
<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">background_timer</span>()
    <span style="color:#66d9ef">if</span> core.table.nkeys(timers) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> threads <span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">for</span> name, timer <span style="color:#66d9ef">in</span> pairs(timers) <span style="color:#66d9ef">do</span>
        core.log.info(<span style="color:#e6db74">&#34;run timer[&#34;</span>, name, <span style="color:#e6db74">&#34;]&#34;</span>)

        <span style="color:#75715e">-- 开启协程执行</span>
        <span style="color:#66d9ef">local</span> th, err <span style="color:#f92672">=</span> thread_spawn(timer)
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> th <span style="color:#66d9ef">then</span>
            core.log.error(<span style="color:#e6db74">&#34;failed to spawn thread for timer [&#34;</span>, name, <span style="color:#e6db74">&#34;]: &#34;</span>, err)
            <span style="color:#66d9ef">goto</span> continue
        <span style="color:#66d9ef">end</span>

        core.table.insert(threads, th)

::continue::
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> thread_wait(unpack(threads))
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
        core.log.error(<span style="color:#e6db74">&#34;failed to wait threads: &#34;</span>, err)
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">init_worker</span>()
    <span style="color:#66d9ef">local</span> opts <span style="color:#f92672">=</span> {
        each_ttl <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
        sleep_succ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
        check_interval <span style="color:#f92672">=</span> check_interval, <span style="color:#75715e">-- 默认间隔为 1 秒</span>
    }
    <span style="color:#66d9ef">local</span> timer, err <span style="color:#f92672">=</span> core.timer.new(<span style="color:#e6db74">&#34;background&#34;</span>, background_timer, opts)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> timer <span style="color:#66d9ef">then</span>
        core.log.error(<span style="color:#e6db74">&#34;failed to create background timer: &#34;</span>, err)
        <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">end</span>

    core.log.notice(<span style="color:#e6db74">&#34;succeed to create background timer&#34;</span>)
<span style="color:#66d9ef">end</span>
</code></pre></div><p>APISIX 引入特权进程的一个目的在于实现 Log Rotate 插件功能。</p>
<h2 id="5-请求生命周期">5. 请求生命周期</h2>
<h3 id="51-ctx">5.1. ctx</h3>
<blockquote>
<p>Use <code>ngx.ctx</code> wherever you can. <code>ngx.var</code> is much  more expensive and is also limited to string values. The latter should  only be used to exchange data with other nginx C modules.<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup></p>
</blockquote>
<p>APISIX 中使用缓存 <code>ngx.var</code> 获取的结果， 在不同生命周期中传递。使用 <a href="https://github.com/api7/lua-var-nginx-module">lua-var-nginx-module</a> Nginx C 模块和 FFI 获取变量，在没有开启 Nginx C 模块的情况下回退到 <code>ngx.var</code> 方式获取。APISIX 默认没有在构建脚本中加载 C 模块，提交的 PR <a href="https://github.com/api7/apisix-build-tools/pull/44">feat: add lua-var-nginx-module</a> 在编译 OpenResty 时添加了该模块。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">set_vars_meta</span>(ctx)
    <span style="color:#75715e">-- 从 table 池中获取/创建一个 hash 长度为 32 的 table</span>
    <span style="color:#66d9ef">local</span> var <span style="color:#f92672">=</span> tablepool.fetch(<span style="color:#e6db74">&#34;ctx_var&#34;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">32</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> var._cache <span style="color:#66d9ef">then</span>
        var._cache <span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 通过 resty.core.base 获取原始 request C 指针 (?)</span>
    <span style="color:#75715e">-- ref: https://github.com/openresty/lua-resty-core/blob/master/lib/resty/core/base.lua</span>
    var._request <span style="color:#f92672">=</span> get_request()
    <span style="color:#75715e">-- 绑定元表</span>
    setmetatable(var, mt)
    <span style="color:#75715e">-- 缓存到 ngx ctx 中</span>
    ctx.var <span style="color:#f92672">=</span> var
<span style="color:#66d9ef">end</span>
</code></pre></div><p>使用 <a href="https://github.com/openresty/lua-tablepool">tablepool</a> 从 Lua table 池中获取 table，避免频繁分配内存。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">do</span>
    <span style="color:#75715e">-- 获取特殊 var 类型的方法</span>
    <span style="color:#66d9ef">local</span> var_methods <span style="color:#f92672">=</span> {
        method <span style="color:#f92672">=</span> ngx.req.get_method,
        <span style="color:#75715e">-- ref: https://github.com/cloudflare/lua-resty-cookie</span>
        cookie <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () <span style="color:#66d9ef">return</span> ck:new() <span style="color:#66d9ef">end</span>
    }

    <span style="color:#66d9ef">local</span> ngx_var_names <span style="color:#f92672">=</span> {
        upstream_scheme            <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>,
        upstream_host              <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>,
        ...

        var_x_forwarded_proto <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>,
    }

    <span style="color:#66d9ef">local</span> mt <span style="color:#f92672">=</span> {
        <span style="color:#75715e">-- 重载 hash 元方法</span>
        <span style="color:#75715e">-- t 是 self</span>
        __index <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(t, key)

            <span style="color:#75715e">-- 若 cache table 存在直接返回</span>
            <span style="color:#66d9ef">local</span> cached <span style="color:#f92672">=</span> t._cache[key]
            <span style="color:#66d9ef">if</span> cached <span style="color:#f92672">~=</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
                <span style="color:#66d9ef">return</span> cached
            <span style="color:#66d9ef">end</span>

            <span style="color:#66d9ef">if</span> type(key) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;string&#34;</span> <span style="color:#66d9ef">then</span>
                error(<span style="color:#e6db74">&#34;invalid argument, expect string value&#34;</span>, <span style="color:#ae81ff">2</span>)
            <span style="color:#66d9ef">end</span>

            <span style="color:#66d9ef">local</span> val
            <span style="color:#75715e">-- 如果是特殊类型, 使用特定方法获取</span>
            <span style="color:#66d9ef">local</span> method <span style="color:#f92672">=</span> var_methods[key]
            <span style="color:#66d9ef">if</span> method <span style="color:#66d9ef">then</span>
                val <span style="color:#f92672">=</span> method()

            <span style="color:#66d9ef">elseif</span> core_str.has_prefix(key, <span style="color:#e6db74">&#34;cookie_&#34;</span>) <span style="color:#66d9ef">then</span>
                <span style="color:#75715e">-- 通过 var_methods 访问到 resty.cookie</span>
                <span style="color:#66d9ef">local</span> cookie <span style="color:#f92672">=</span> t.cookie
                <span style="color:#66d9ef">if</span> cookie <span style="color:#66d9ef">then</span>
                    <span style="color:#66d9ef">local</span> err
                    val, err <span style="color:#f92672">=</span> cookie:get(sub_str(key, <span style="color:#ae81ff">8</span>))
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> val <span style="color:#66d9ef">then</span>
                        log.warn(<span style="color:#e6db74">&#34;failed to fetch cookie value by key: &#34;</span>,
                                 key, <span style="color:#e6db74">&#34; error: &#34;</span>, err)
                    <span style="color:#66d9ef">end</span>
                <span style="color:#66d9ef">end</span>

            <span style="color:#66d9ef">elseif</span> core_str.has_prefix(key, <span style="color:#e6db74">&#34;http_&#34;</span>) <span style="color:#66d9ef">then</span>
                key <span style="color:#f92672">=</span> key:lower()
                key <span style="color:#f92672">=</span> re_gsub(key, <span style="color:#e6db74">&#34;-&#34;</span>, <span style="color:#e6db74">&#34;_&#34;</span>, <span style="color:#e6db74">&#34;jo&#34;</span>)
                <span style="color:#75715e">-- 最终通过 ngx.var 获取</span>
                val <span style="color:#f92672">=</span> get_var(key, t._request)

            <span style="color:#66d9ef">elseif</span> core_str.has_prefix(key, <span style="color:#e6db74">&#34;graphql_&#34;</span>) <span style="color:#66d9ef">then</span>
                <span style="color:#75715e">-- trim the &#34;graphql_&#34; prefix</span>
                key <span style="color:#f92672">=</span> sub_str(key, <span style="color:#ae81ff">9</span>)
                val <span style="color:#f92672">=</span> get_parsed_graphql(t)[key]

            <span style="color:#66d9ef">elseif</span> key <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;route_id&#34;</span> <span style="color:#66d9ef">then</span>
                val <span style="color:#f92672">=</span> ngx.ctx.api_ctx <span style="color:#f92672">and</span> ngx.ctx.api_ctx.route_id

            <span style="color:#66d9ef">elseif</span> key <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;service_id&#34;</span> <span style="color:#66d9ef">then</span>
                val <span style="color:#f92672">=</span> ngx.ctx.api_ctx <span style="color:#f92672">and</span> ngx.ctx.api_ctx.service_id

            <span style="color:#66d9ef">elseif</span> key <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;consumer_name&#34;</span> <span style="color:#66d9ef">then</span>
                val <span style="color:#f92672">=</span> ngx.ctx.api_ctx <span style="color:#f92672">and</span> ngx.ctx.api_ctx.consumer_name

            <span style="color:#66d9ef">elseif</span> key <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;route_name&#34;</span> <span style="color:#66d9ef">then</span>
                val <span style="color:#f92672">=</span> ngx.ctx.api_ctx <span style="color:#f92672">and</span> ngx.ctx.api_ctx.route_name

            <span style="color:#66d9ef">elseif</span> key <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;service_name&#34;</span> <span style="color:#66d9ef">then</span>
                val <span style="color:#f92672">=</span> ngx.ctx.api_ctx <span style="color:#f92672">and</span> ngx.ctx.api_ctx.service_name

            <span style="color:#66d9ef">elseif</span> key <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;balancer_ip&#34;</span> <span style="color:#66d9ef">then</span>
                val <span style="color:#f92672">=</span> ngx.ctx.api_ctx <span style="color:#f92672">and</span> ngx.ctx.api_ctx.balancer_ip

            <span style="color:#66d9ef">elseif</span> key <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;balancer_port&#34;</span> <span style="color:#66d9ef">then</span>
                val <span style="color:#f92672">=</span> ngx.ctx.api_ctx <span style="color:#f92672">and</span> ngx.ctx.api_ctx.balancer_port

            <span style="color:#66d9ef">else</span>
                val <span style="color:#f92672">=</span> get_var(key, t._request)
            <span style="color:#66d9ef">end</span>

            <span style="color:#66d9ef">if</span> val <span style="color:#f92672">~=</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
                t._cache[key] <span style="color:#f92672">=</span> val
            <span style="color:#66d9ef">end</span>

            <span style="color:#75715e">-- 为空返回 nil</span>
            <span style="color:#66d9ef">return</span> val
        <span style="color:#66d9ef">end</span>,

        __newindex <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(t, key, val)
            <span style="color:#66d9ef">if</span> ngx_var_names[key] <span style="color:#66d9ef">then</span>
                ngx_var[key] <span style="color:#f92672">=</span> val
            <span style="color:#66d9ef">end</span>

            <span style="color:#75715e">-- log.info(&#34;key: &#34;, key, &#34; new val: &#34;, val)</span>
            t._cache[key] <span style="color:#f92672">=</span> val
        <span style="color:#66d9ef">end</span>,
    }
</code></pre></div><p>部分 APISIX 路由匹配的内部参数在其他阶段注入。</p>
<h3 id="52-headers">5.2. headers</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- 用 ngx.ctx table 缓存 headers, 避免再进行一次 ffi 调用</span>
<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_headers</span>(ctx)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ctx <span style="color:#66d9ef">then</span>
        ctx <span style="color:#f92672">=</span> ngx.ctx.api_ctx
    <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">local</span> headers <span style="color:#f92672">=</span> ctx.headers
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> headers <span style="color:#66d9ef">then</span>
        headers <span style="color:#f92672">=</span> get_headers()
        ctx.headers <span style="color:#f92672">=</span> headers
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> headers
<span style="color:#66d9ef">end</span>
</code></pre></div><p>用到了上述的 ctx 库。</p>
<h2 id="6-etcd">6. etcd</h2>
<p>etcd 在 APISIX 中作用相同与 PostgreSQL 之于 Kong，内部使用 <a href="https://github.com/api7/lua-resty-etcd">lua-resty-etcd</a> 作为客户端，使用 timer 定时执行和长轮询获取跟踪 etcd 中数据的变化。</p>
<p>这里的优化点与 Kong 一样，在 <code>init_by_lua</code> 阶段进行数据的 warm up，之后数据会 fork 到其他的进程中。</p>
<blockquote>
<p>It does not really make much sense to use this library in the context of <a href="https://github.com/openresty/lua-nginx-module#lua_shared_dict">init_by_lua</a> because the cache will not get shared by any of the worker processes (unless you just want to &ldquo;warm up&rdquo; the cache with predefined items which will get inherited by the workers via <code>fork()</code>).<sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup></p>
</blockquote>
<h3 id="61-初始化">6.1. 初始化</h3>
<p>读取 etcd 数据到全局单例的 Lua table。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- 初始化 etcd</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">init</span>()
    <span style="color:#66d9ef">local</span> local_conf, err <span style="color:#f92672">=</span> config_local.local_conf()
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> local_conf <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> table.try_read_attr(local_conf, <span style="color:#e6db74">&#34;apisix&#34;</span>, <span style="color:#e6db74">&#34;disable_sync_configuration_during_start&#34;</span>) <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 获取 etcd cli</span>
    <span style="color:#66d9ef">local</span> etcd_cli, err <span style="color:#f92672">=</span> get_etcd()
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> etcd_cli <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;failed to start a etcd instance: &#34;</span> <span style="color:#f92672">..</span> err
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> etcd_conf <span style="color:#f92672">=</span> local_conf.etcd
    <span style="color:#66d9ef">local</span> prefix <span style="color:#f92672">=</span> etcd_conf.prefix
    <span style="color:#75715e">-- 加载 etcd 所有数据到 lua table 中, 单例模式</span>
    <span style="color:#66d9ef">local</span> res, err <span style="color:#f92672">=</span> readdir(etcd_cli, prefix, create_formatter(prefix))
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> res <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>对数据进行格式化，存入 Lua table 中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- 创建格式化 formatter</span>
<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">create_formatter</span>(prefix)
    <span style="color:#75715e">-- 返回闭包函数, 对 etcd 返回的结果进行格式化</span>
    <span style="color:#75715e">-- 格式个毛, 这就是个 hook 函数</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span> (res)
        res.body.nodes <span style="color:#f92672">=</span> {}

        <span style="color:#66d9ef">local</span> dirs
        <span style="color:#66d9ef">if</span> is_http <span style="color:#66d9ef">then</span>
            dirs <span style="color:#f92672">=</span> constants.HTTP_ETCD_DIRECTORY
        <span style="color:#66d9ef">else</span>
            dirs <span style="color:#f92672">=</span> constants.STREAM_ETCD_DIRECTORY
        <span style="color:#66d9ef">end</span>

        <span style="color:#66d9ef">local</span> curr_dir_data
        <span style="color:#66d9ef">local</span> curr_key
        <span style="color:#66d9ef">for</span> _, item <span style="color:#66d9ef">in</span> ipairs(res.body.kvs) <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">if</span> curr_dir_data <span style="color:#66d9ef">then</span>
                <span style="color:#75715e">-- 将匹配的内容插入 table</span>
                <span style="color:#66d9ef">if</span> core_str.has_prefix(item.key, curr_key) <span style="color:#66d9ef">then</span>
                    table.insert(curr_dir_data, etcd_apisix.kvs_to_node(item))
                    <span style="color:#66d9ef">goto</span> CONTINUE
                <span style="color:#66d9ef">end</span>

                curr_dir_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>
            <span style="color:#66d9ef">end</span>

            <span style="color:#75715e">-- 截取 prefix 后的 key</span>
            <span style="color:#66d9ef">local</span> key <span style="color:#f92672">=</span> sub_str(item.key, <span style="color:#f92672">#</span>prefix <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
            <span style="color:#66d9ef">if</span> dirs[key] <span style="color:#66d9ef">then</span>
                <span style="color:#75715e">-- single item</span>
                loaded_configuration[key] <span style="color:#f92672">=</span> {
                    body <span style="color:#f92672">=</span> etcd_apisix.kvs_to_node(item),
                    headers <span style="color:#f92672">=</span> res.headers,
                }
            <span style="color:#66d9ef">else</span>
                <span style="color:#75715e">-- 前缀一致</span>
                <span style="color:#66d9ef">local</span> key <span style="color:#f92672">=</span> sub_str(item.key, <span style="color:#f92672">#</span>prefix <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">#</span>item.key <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">-- 去掉末尾的 /</span>
                <span style="color:#75715e">-- ensure the same key hasn&#39;t been handled as single item</span>
                <span style="color:#66d9ef">if</span> dirs[key] <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> loaded_configuration[key] <span style="color:#66d9ef">then</span>
                    loaded_configuration[key] <span style="color:#f92672">=</span> {
                        body <span style="color:#f92672">=</span> {
                            nodes <span style="color:#f92672">=</span> {},
                        },
                        headers <span style="color:#f92672">=</span> res.headers,
                    }
                    curr_dir_data <span style="color:#f92672">=</span> loaded_configuration[key].body.nodes
                    curr_key <span style="color:#f92672">=</span> item.key
                <span style="color:#66d9ef">end</span>
            <span style="color:#66d9ef">end</span>

            ::CONTINUE::
        <span style="color:#66d9ef">end</span>

        <span style="color:#66d9ef">return</span> res
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>这部分逻辑在 <code>init_by_lua</code> 执行，fork 到其他子进程。</p>
<h3 id="62-数据校验">6.2. 数据校验</h3>
<p><code>schema_def.lua</code> 文件中定义了所有储存数据结构的 schema 校验规则，使用 <a href="https://github.com/api7/jsonschema">jsonschema</a> 库进行数据校验。</p>
<p><code>core/schema.lua</code> 中使用 LRU 缓存校验器。</p>
<p><code>load_full_data</code> 函数加载数据结构所需的 etcd kvs，并进行数据转换、校验、格式化、执行回调。</p>
<p><img src="graph-4.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">load_full_data</span>(self, dir_res, headers)
    <span style="color:#66d9ef">local</span> err
    <span style="color:#66d9ef">local</span> changed <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>

    <span style="color:#66d9ef">if</span> self.single_item <span style="color:#66d9ef">then</span>
        <span style="color:#75715e">-- table size 为 1</span>
        ...
        <span style="color:#75715e">-- 执行逻辑与下面数组格式类似</span>
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> dir_res.nodes <span style="color:#66d9ef">then</span>
            dir_res.nodes <span style="color:#f92672">=</span> {}
        <span style="color:#66d9ef">end</span>

        self.values <span style="color:#f92672">=</span> new_tab(<span style="color:#f92672">#</span>dir_res.nodes, <span style="color:#ae81ff">0</span>)
        self.values_hash <span style="color:#f92672">=</span> new_tab(<span style="color:#ae81ff">0</span>, <span style="color:#f92672">#</span>dir_res.nodes)

        <span style="color:#66d9ef">for</span> _, item <span style="color:#66d9ef">in</span> ipairs(dir_res.nodes) <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">local</span> key <span style="color:#f92672">=</span> short_key(self, item.key)
            <span style="color:#66d9ef">local</span> data_valid <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
            
            <span style="color:#75715e">-- 数据格式校验...</span>

            <span style="color:#75715e">-- schema 校验...</span>

            <span style="color:#75715e">-- 过滤器...</span>

            <span style="color:#66d9ef">if</span> data_valid <span style="color:#66d9ef">then</span>
                changed <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
                insert_tab(self.values, item)
                self.values_hash[key] <span style="color:#f92672">=</span> <span style="color:#f92672">#</span>self.values

                item.value.id <span style="color:#f92672">=</span> key
                item.clean_handlers <span style="color:#f92672">=</span> {}

                <span style="color:#75715e">-- 执行回调</span>
                <span style="color:#66d9ef">if</span> self.filter <span style="color:#66d9ef">then</span>
                    self.filter(item)
                <span style="color:#66d9ef">end</span>
            <span style="color:#66d9ef">end</span>
			<span style="color:#75715e">-- 更新 mvcc 版本</span>
            self:upgrade_version(item.modifiedIndex)
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
	...
    self.need_reload <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="63-后台数据同步">6.3. 后台数据同步</h3>
<p>利用 etcd watch 机制进行数据变更的同步。</p>
<p><img src="graph-5.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- 定时器自动同步 etcd 数据</span>
<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_automatic_fetch</span>(premature, self)
    <span style="color:#66d9ef">if</span> premature <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> exiting() <span style="color:#f92672">and</span> self.running <span style="color:#f92672">and</span> i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">32</span> <span style="color:#66d9ef">do</span>
        i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> xpcall(<span style="color:#66d9ef">function</span>()
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self.etcd_cli <span style="color:#66d9ef">then</span>
                <span style="color:#66d9ef">local</span> etcd_cli, err <span style="color:#f92672">=</span> get_etcd()
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> etcd_cli <span style="color:#66d9ef">then</span>
                    error(<span style="color:#e6db74">&#34;failed to create etcd instance for key [&#34;</span>
                          <span style="color:#f92672">..</span> self.key <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;]: &#34;</span> <span style="color:#f92672">..</span> (err <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;unknown&#34;</span>))
                <span style="color:#66d9ef">end</span>
                self.etcd_cli <span style="color:#f92672">=</span> etcd_cli
            <span style="color:#66d9ef">end</span>

            <span style="color:#75715e">-- 同步数据</span>
            <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> sync_data(self)
            <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
                <span style="color:#66d9ef">if</span> err <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;timeout&#34;</span> <span style="color:#f92672">and</span> err <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;Key not found&#34;</span>
                    <span style="color:#f92672">and</span> self.last_err <span style="color:#f92672">~=</span> err <span style="color:#66d9ef">then</span>
                    log.error(<span style="color:#e6db74">&#34;failed to fetch data from etcd: &#34;</span>, err, <span style="color:#e6db74">&#34;, &#34;</span>,
                              tostring(self))
                <span style="color:#66d9ef">end</span>

                <span style="color:#66d9ef">if</span> err <span style="color:#f92672">~=</span> self.last_err <span style="color:#66d9ef">then</span>
                    self.last_err <span style="color:#f92672">=</span> err
                    self.last_err_time <span style="color:#f92672">=</span> ngx_time()
                <span style="color:#66d9ef">else</span>
                    <span style="color:#66d9ef">if</span> ngx_time() <span style="color:#f92672">-</span> self.last_err_time <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">30</span> <span style="color:#66d9ef">then</span>
                        self.last_err <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>
                    <span style="color:#66d9ef">end</span>
                <span style="color:#66d9ef">end</span>

                ngx_sleep(self.resync_delay <span style="color:#f92672">+</span> rand() <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> self.resync_delay)
            <span style="color:#66d9ef">elseif</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
                <span style="color:#75715e">-- no error. reentry the sync with different state</span>
                ngx_sleep(<span style="color:#ae81ff">0.05</span>)
            <span style="color:#66d9ef">end</span>

        <span style="color:#66d9ef">end</span>, debug.traceback)

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
            log.error(<span style="color:#e6db74">&#34;failed to fetch data from etcd: &#34;</span>, err, <span style="color:#e6db74">&#34;, &#34;</span>,
                      tostring(self))
            ngx_sleep(self.resync_delay <span style="color:#f92672">+</span> rand() <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> self.resync_delay)
            <span style="color:#66d9ef">break</span>
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 进行下一次循环</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> exiting() <span style="color:#f92672">and</span> self.running <span style="color:#66d9ef">then</span>
        ngx_timer_at(<span style="color:#ae81ff">0</span>, _automatic_fetch, self)
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="64-配置同步">6.4. 配置同步</h3>
<p>封装上述的逻辑提供给 <code>routes</code>、<code>plugins</code>、<code>services</code> 等数据结构使用，每个数据结构监听自己的 prefix，同步数据并执行回调，通常在回调逻辑上触发更新，例如重新构建 Router、重新构建 plugins table 等。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- etcd 配置创建</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">new</span>(key, opts)
    <span style="color:#66d9ef">local</span> local_conf, err <span style="color:#f92672">=</span> config_local.local_conf()
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> local_conf <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- etcd 重新同步事件 5 秒, 与 Kong 重新 poll db 数据一致</span>
    <span style="color:#66d9ef">local</span> etcd_conf <span style="color:#f92672">=</span> local_conf.etcd
    <span style="color:#66d9ef">local</span> prefix <span style="color:#f92672">=</span> etcd_conf.prefix
    <span style="color:#66d9ef">local</span> resync_delay <span style="color:#f92672">=</span> etcd_conf.resync_delay
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> resync_delay <span style="color:#f92672">or</span> resync_delay <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
        resync_delay <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> automatic <span style="color:#f92672">=</span> opts <span style="color:#f92672">and</span> opts.automatic
    <span style="color:#66d9ef">local</span> item_schema <span style="color:#f92672">=</span> opts <span style="color:#f92672">and</span> opts.item_schema
    <span style="color:#66d9ef">local</span> filter_fun <span style="color:#f92672">=</span> opts <span style="color:#f92672">and</span> opts.filter
    <span style="color:#66d9ef">local</span> timeout <span style="color:#f92672">=</span> opts <span style="color:#f92672">and</span> opts.timeout
    <span style="color:#66d9ef">local</span> single_item <span style="color:#f92672">=</span> opts <span style="color:#f92672">and</span> opts.single_item
    <span style="color:#66d9ef">local</span> checker <span style="color:#f92672">=</span> opts <span style="color:#f92672">and</span> opts.checker

    <span style="color:#66d9ef">local</span> obj <span style="color:#f92672">=</span> setmetatable({
        etcd_cli <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>,
        key <span style="color:#f92672">=</span> key <span style="color:#f92672">and</span> prefix <span style="color:#f92672">..</span> key,
        automatic <span style="color:#f92672">=</span> automatic,
        item_schema <span style="color:#f92672">=</span> item_schema,
        checker <span style="color:#f92672">=</span> checker,
        sync_times <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
        running <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>,
        conf_version <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
        values <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>,
        need_reload <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>,
        routes_hash <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>,
        prev_index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
        last_err <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>,
        last_err_time <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>,
        resync_delay <span style="color:#f92672">=</span> resync_delay,
        timeout <span style="color:#f92672">=</span> timeout,
        single_item <span style="color:#f92672">=</span> single_item,
        filter <span style="color:#f92672">=</span> filter_fun,
    }, mt)

    <span style="color:#66d9ef">if</span> automatic <span style="color:#66d9ef">then</span>
        <span style="color:#75715e">-- timer 定时获取数据</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> key <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;missing `key` argument&#34;</span>
        <span style="color:#66d9ef">end</span>

        <span style="color:#75715e">-- 从单例 table 获取 etcd 数据, 进行处理</span>
        <span style="color:#66d9ef">if</span> loaded_configuration[key] <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">local</span> res <span style="color:#f92672">=</span> loaded_configuration[key]
            <span style="color:#75715e">-- 清空 table</span>
            loaded_configuration[key] <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span> <span style="color:#75715e">-- tried to load</span>

            log.notice(<span style="color:#e6db74">&#34;use loaded configuration &#34;</span>, key)

            <span style="color:#66d9ef">local</span> dir_res, headers <span style="color:#f92672">=</span> res.body, res.headers
            <span style="color:#75715e">-- 加载数据并校验数据, 过滤数据</span>
            load_full_data(obj, dir_res, headers)
        <span style="color:#66d9ef">end</span>

        <span style="color:#75715e">-- 创建定时器自动同步</span>
        ngx_timer_at(<span style="color:#ae81ff">0</span>, _automatic_fetch, obj)

    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">local</span> etcd_cli, err <span style="color:#f92672">=</span> get_etcd()
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> etcd_cli <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;failed to start a etcd instance: &#34;</span> <span style="color:#f92672">..</span> err
        <span style="color:#66d9ef">end</span>
        obj.etcd_cli <span style="color:#f92672">=</span> etcd_cli
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> key <span style="color:#66d9ef">then</span>
        created_obj[key] <span style="color:#f92672">=</span> obj
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> obj
<span style="color:#66d9ef">end</span>
</code></pre></div><h2 id="7-router">7. Router</h2>
<p>APISIX 的 Router 匹配基于压缩字典树（Radix Tree）实现，主要使用 <a href="https://github.com/api7/lua-resty-radixtree">lua-resty-radixtree</a> 库。内置多种解析模式，这里只关注 HTTP 默认的 <code>radixtree_uri</code> 实现。</p>
<h3 id="71-路由构建">7.1. 路由构建</h3>
<p><code>core.config.new</code> 调用的是 etcd 库（<code>config_etcd.lua</code>）维护的配置同步方法，返回原表，可以访问从 etcd 同步的数据。<code>core.schema.route</code> 包含了 route 这个数据结构的 schema 及校验规则，<code>check_route</code> 内部检查 route 直接绑定 plugin 的数据结构。</p>
<blockquote>
<p>APISIX 引入 route 直接绑定 plugin 的简化配置，不需要额外创建 plugin 对象。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- 初始化 router</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">init_worker</span>(filter)
    <span style="color:#66d9ef">local</span> user_routes, err <span style="color:#f92672">=</span> core.config.new(<span style="color:#e6db74">&#34;/routes&#34;</span>, {
            automatic <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>, <span style="color:#75715e">-- 自动同步</span>
            item_schema <span style="color:#f92672">=</span> core.schema.route,
            checker <span style="color:#f92672">=</span> check_route,
            filter <span style="color:#f92672">=</span> filter,
        })
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> user_routes <span style="color:#66d9ef">then</span>
        error(<span style="color:#e6db74">&#34;failed to create etcd instance for fetching /routes : &#34;</span> <span style="color:#f92672">..</span> err)
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> user_routes
<span style="color:#66d9ef">end</span>
</code></pre></div><p><code>filter</code> 是回调函数，下述的流程中会注入。</p>
<h3 id="72-路由初始化">7.2. 路由初始化</h3>
<p><code>router.http_init_worker</code> 中进行 Router 初始化。</p>
<p><img src="graph-6.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- attach common methods if the router doesn&#39;t provide its custom implementation</span>
<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">attach_http_router_common_methods</span>(http_router)
    ...

    <span style="color:#66d9ef">if</span> http_router.init_worker <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
        http_router.init_worker <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (filter)
            <span style="color:#75715e">-- 添加路由</span>
            http_router.user_routes <span style="color:#f92672">=</span> http_route.init_worker(filter)
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>


<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">http_init_worker</span>()
    <span style="color:#66d9ef">local</span> conf <span style="color:#f92672">=</span> core.config.local_conf()
    <span style="color:#75715e">-- 默认的匹配模式</span>
    <span style="color:#66d9ef">local</span> router_http_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;radixtree_uri&#34;</span>
    <span style="color:#66d9ef">local</span> router_ssl_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;radixtree_sni&#34;</span>

    <span style="color:#66d9ef">if</span> conf <span style="color:#f92672">and</span> conf.apisix <span style="color:#f92672">and</span> conf.apisix.router <span style="color:#66d9ef">then</span>
        router_http_name <span style="color:#f92672">=</span> conf.apisix.router.http <span style="color:#f92672">or</span> router_http_name
        router_ssl_name <span style="color:#f92672">=</span> conf.apisix.router.ssl <span style="color:#f92672">or</span> router_ssl_name
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 创建 router 实例</span>
    <span style="color:#66d9ef">local</span> router_http <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;apisix.http.router.&#34;</span> <span style="color:#f92672">..</span> router_http_name)
    <span style="color:#75715e">-- 修改 router 的 table</span>
    attach_http_router_common_methods(router_http)
    <span style="color:#75715e">-- 初始化路由</span>
    <span style="color:#75715e">-- 调用 apisix.http.route.init_worker 方法</span>
    <span style="color:#75715e">-- 从 etcd 获取数据并执行回调</span>
    <span style="color:#75715e">-- filter 为格式化, 解析 upstream</span>
    router_http.init_worker(filter)
    _M.router_http <span style="color:#f92672">=</span> router_http

    <span style="color:#66d9ef">local</span> router_ssl <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;apisix.ssl.router.&#34;</span> <span style="color:#f92672">..</span> router_ssl_name)
    router_ssl.init_worker()
    _M.router_ssl <span style="color:#f92672">=</span> router_ssl

    _M.api <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;apisix.api_router&#34;</span>)

    ...
<span style="color:#66d9ef">end</span>
</code></pre></div><p><code>http_router.user_routes</code> 储存在 router 的 table 中，会在路由匹配时用到（懒加载）。</p>
<h3 id="73-路由匹配">7.3. 路由匹配</h3>
<p><code>access_by_lua</code> 阶段中进行路由匹配，将匹配结果（route、service）传递到 ctx 中供 balancer 请求上游。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">local</span> uri_routes <span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">local</span> uri_router
    <span style="color:#66d9ef">local</span> match_opts <span style="color:#f92672">=</span> {}
    
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">match</span>(api_ctx)
        <span style="color:#75715e">-- 从 module 的 user_routes 属性获取路由, 在 etcd route 变化时回调添加</span>
        <span style="color:#66d9ef">local</span> user_routes <span style="color:#f92672">=</span> _M.user_routes
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> cached_version <span style="color:#f92672">or</span> cached_version <span style="color:#f92672">~=</span> user_routes.conf_version <span style="color:#66d9ef">then</span>
            uri_router <span style="color:#f92672">=</span> base_router.create_radixtree_uri_router(user_routes.values,
                                                                uri_routes, <span style="color:#66d9ef">false</span>)
            cached_version <span style="color:#f92672">=</span> user_routes.conf_version
        <span style="color:#66d9ef">end</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> uri_router <span style="color:#66d9ef">then</span>
            core.log.error(<span style="color:#e6db74">&#34;failed to fetch valid `uri` router: &#34;</span>)
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
        <span style="color:#66d9ef">end</span>

        <span style="color:#66d9ef">return</span> base_router.match_uri(uri_router, match_opts, api_ctx)
    <span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">end</span>
</code></pre></div><p><code>radixtree</code> 路由匹配库提供了匹配成功回调 handler，匹配成功后传递到 ctx 中。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">core.table.insert(uri_routes, {
                ...
                handler <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (api_ctx, match_opts)
                    api_ctx.matched_params <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>
                    api_ctx.matched_route <span style="color:#f92672">=</span> route
                    api_ctx.curr_req_matched <span style="color:#f92672">=</span> match_opts.matched
                <span style="color:#66d9ef">end</span>
            })
</code></pre></div><h2 id="8-balancer">8. Balancer</h2>
<p>Balancer 部分与 Kong 逻辑一致，甚至代码里函数名都一样，主要逻辑是 Service/Upstream 节点解析、负载均衡策略、健康检查与失败重试。</p>
<p>APISIX 支持的一特性是外部服务发现，Kong 中默认支持通过 DNS 解析 Service host，根据 AAAA、A、SRV 记录添加 IP 与优先级，APISIX 支持了从 consul、eruka 和其他注册中心获取 IP 地址列表，并同步节点数据（长轮询）。</p>
<h3 id="81-服务发现">8.1. 服务发现</h3>
<p>如果 serivce host 是域名, 通过外部注册中心进行服务发现，获取上游 IP 列表。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">set_by_route</span>(route, api_ctx)
   	...
    <span style="color:#75715e">-- 如果 serivce host 是域名, 通过 discovery 发现, dns 解析</span>
    <span style="color:#66d9ef">if</span> up_conf.service_name <span style="color:#66d9ef">then</span>
        ...
        <span style="color:#75715e">-- 外部注册中心</span>
        <span style="color:#66d9ef">local</span> dis <span style="color:#f92672">=</span> discovery[up_conf.discovery_type]
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> dis <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">500</span>, <span style="color:#e6db74">&#34;discovery &#34;</span> <span style="color:#f92672">..</span> up_conf.discovery_type <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34; is uninitialized&#34;</span>
        <span style="color:#66d9ef">end</span>

        <span style="color:#75715e">-- 从注册中心数据源（缓存本地 table）获取 IP</span>
        <span style="color:#66d9ef">local</span> new_nodes, err <span style="color:#f92672">=</span> dis.nodes(up_conf.service_name)
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> new_nodes <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span> HTTP_CODE_UPSTREAM_UNAVAILABLE, <span style="color:#e6db74">&#34;no valid upstream node: &#34;</span> <span style="color:#f92672">..</span> (err <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;nil&#34;</span>)
        <span style="color:#66d9ef">end</span>

        ...
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 将 upstream 节点信息存入 ctx</span>
    set_directly(api_ctx, up_conf.type <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;#upstream_&#34;</span> <span style="color:#f92672">..</span> tostring(up_conf),
                 api_ctx.conf_version, up_conf)

    <span style="color:#66d9ef">local</span> nodes_count <span style="color:#f92672">=</span> up_conf.nodes <span style="color:#f92672">and</span> <span style="color:#f92672">#</span>up_conf.nodes <span style="color:#f92672">or</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">if</span> nodes_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> HTTP_CODE_UPSTREAM_UNAVAILABLE, <span style="color:#e6db74">&#34;no valid upstream node&#34;</span>
    <span style="color:#66d9ef">end</span>
	...

    set_upstream_scheme(api_ctx, up_conf)

    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> fill_node_info(up_conf, api_ctx.upstream_scheme, <span style="color:#66d9ef">false</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">503</span>, err
    <span style="color:#66d9ef">end</span>
    ...

    <span style="color:#66d9ef">local</span> scheme <span style="color:#f92672">=</span> up_conf.scheme
    <span style="color:#66d9ef">if</span> (scheme <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;https&#34;</span> <span style="color:#f92672">or</span> scheme <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;grpcs&#34;</span>) <span style="color:#f92672">and</span> up_conf.tls <span style="color:#66d9ef">then</span>
        ...
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="82-负载均衡">8.2. 负载均衡</h3>
<p>不同于 Kong 使用自己封装的 <a href="https://github.com/Kong/lua-resty-dns-client/tree/master/src/resty/dns/balancer">lua-resty-dns-client/balancer</a> 作为负载均衡器，APISIX 基于 <a href="https://github.com/openresty/lua-resty-balancer">lua-resty-balancer</a> 封装了负载均衡策略，基于 <a href="https://github.com/Kong/lua-resty-healthcheck">lua-resty-healthcheck</a>（fork 版本）实现节点健康检查。</p>
<p>API 网关的负载均衡策略（Kong/APISIX）都是基于 OpenResty <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md#set_current_peer">lua-resty-core/balancer</a> 提供的负载均衡函数实现，<code>set_current_peer</code> 设置当前请求上游地址，<code>set_more_tries</code> 设置请求失败重试次数，<code>get_last_failure</code> 获取上一次请求失败结果判断是否需要继续重试，<code>set_timeouts</code> 设置单个请求超时时间。</p>
<p><img src="graph-7.png" alt=""></p>
<p><code>set_balancer_opts</code> 设置 Nginx Balancer 参数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- set_balancer_opts will be called in balancer phase and before any tries</span>
<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">set_balancer_opts</span>(route, ctx)
    <span style="color:#66d9ef">local</span> up_conf <span style="color:#f92672">=</span> ctx.upstream_conf

    <span style="color:#75715e">-- If the matched route has timeout config, prefer to use the route config.</span>
    <span style="color:#66d9ef">local</span> timeout <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>
    <span style="color:#66d9ef">if</span> route <span style="color:#f92672">and</span> route.value <span style="color:#f92672">and</span> route.value.timeout <span style="color:#66d9ef">then</span>
        timeout <span style="color:#f92672">=</span> route.value.timeout
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">if</span> up_conf.timeout <span style="color:#66d9ef">then</span>
            timeout <span style="color:#f92672">=</span> up_conf.timeout
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
    <span style="color:#75715e">-- 设置 Nginx 请求超时时间</span>
    <span style="color:#66d9ef">if</span> timeout <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> set_timeouts(timeout.connect, timeout.send,
                                     timeout.read)
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
            core.log.error(<span style="color:#e6db74">&#34;could not set upstream timeouts: &#34;</span>, err)
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> retries <span style="color:#f92672">=</span> up_conf.retries
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> retries <span style="color:#f92672">or</span> retries <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
        retries <span style="color:#f92672">=</span> <span style="color:#f92672">#</span>up_conf.nodes <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 设置 Nginx 失败重试次数</span>
    <span style="color:#66d9ef">if</span> retries <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> set_more_tries(retries)
        ...
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>在 <code>access_by_lua</code> 阶段中服务发现，调用 balancer 库获取 peer 节点，<code>balancer_by_lua</code> 中从 ctx 中获取 peer 节点信息，访问后端节点，若失败重试（该阶段再次被调用），重新获取 peer 节点，重新创建请求（<code>recreate_request()</code>）再次访问后端节点。</p>
<h2 id="9-plugin">9. Plugin</h2>
<p>插件机制也与 Kong 类似，插件开发者可以定义 Schema 配置数据结构，以及 Handler 注入 Nginx 请求生命周期，API 网关提供核心的库供开发者使用（SDK）。</p>
<p>APISIX 相比 Kong，开源的插件较多，插件 Schema 便于编写，同时插件只需要单文件，而 Kong 的插件通常是单独一个仓库，不方便维护。但是考虑到插件需要单独的 Test::Nginx 单元测试，单独一个仓库也未尝不可（Kong 还说了以后会把 Github 项目主仓库的插件代码移到单独的仓库）。</p>
<p>具体各个阶段执行逻辑应该与 Kong 相同，即部分阶段插件开协程并发执行，部分阶段避免数据竞争，插件顺序执行。</p>
<p>值得注意的一点是 APISIX 生命周期里没有 <code>rewrite_by_lua</code> 阶段，插件实现的该阶段会在 <code>access_by_lua</code> 中优先于 <code>access_by_lua</code> 插件逻辑执行。</p>
<blockquote>
<p>The apisix run both &ldquo;.access&rdquo; and &ldquo;.rewrite&rdquo; in the &ldquo;access&rdquo; phase.<sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup></p>
</blockquote>
<h3 id="91-插件加载">9.1. 插件加载</h3>
<p>插件列表从本地 yaml 文件获取，同时监听本地文件变化，同步配置；插件配置信息从 etcd 获取。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> init_plugins_syncer
<span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">local</span> plugins_conf

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">init_plugins_syncer</span>()
        <span style="color:#66d9ef">local</span> err
        <span style="color:#75715e">-- 储存插件的配置信息, 一条 kv</span>
        plugins_conf, err <span style="color:#f92672">=</span> core.config.new(<span style="color:#e6db74">&#34;/plugins&#34;</span>, {
            automatic <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>, <span style="color:#75715e">-- 后台创建 timer watch etcd 自动同步配置</span>
            item_schema <span style="color:#f92672">=</span> core.schema.plugins,
            single_item <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>,
            <span style="color:#75715e">-- filter 方法中访问到 etcd kv 的 item, 这里进行插件加载的回调</span>
            <span style="color:#75715e">-- 每次 etcd 插件配置变动, 自动同步</span>
            filter <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(item)
                <span style="color:#75715e">-- we need to pass &#39;item&#39; instead of plugins_conf because</span>
                <span style="color:#75715e">-- the latter one is nil at the first run</span>
                _M.load(item)
            <span style="color:#66d9ef">end</span>,
        })
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> plugins_conf <span style="color:#66d9ef">then</span>
            error(<span style="color:#e6db74">&#34;failed to create etcd instance for fetching /plugins : &#34;</span> <span style="color:#f92672">..</span> err)
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>插件列表会储存到 Lua table 中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- 加载插件</span>
<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">load</span>(plugin_names)
    <span style="color:#66d9ef">local</span> processed <span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">for</span> _, name <span style="color:#66d9ef">in</span> ipairs(plugin_names) <span style="color:#66d9ef">do</span>
        <span style="color:#66d9ef">if</span> processed[name] <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
            processed[name] <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    core.log.warn(<span style="color:#e6db74">&#34;new plugins: &#34;</span>, core.json.delay_encode(processed))

    <span style="color:#75715e">-- 移除已经存在的 module</span>
    <span style="color:#66d9ef">for</span> name <span style="color:#66d9ef">in</span> pairs(local_plugins_hash) <span style="color:#66d9ef">do</span>
        unload_plugin(name)
    <span style="color:#66d9ef">end</span>

    core.table.clear(local_plugins)
    core.table.clear(local_plugins_hash)

    <span style="color:#75715e">-- 加载插件</span>
    <span style="color:#66d9ef">for</span> name <span style="color:#66d9ef">in</span> pairs(processed) <span style="color:#66d9ef">do</span>
        load_plugin(name, local_plugins)
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 插件排序, priority 越高的插件越先执行, 与 Kong 同样</span>
    <span style="color:#75715e">-- sort by plugin&#39;s priority</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">#</span>local_plugins <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">then</span>
        sort_tab(local_plugins, sort_plugin)
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 打印调试日志</span>
    <span style="color:#66d9ef">for</span> i, plugin <span style="color:#66d9ef">in</span> ipairs(local_plugins) <span style="color:#66d9ef">do</span>
        ...
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>插件配置信息 <code>plugin_meta</code> 也加载到 Lua table 中，在插件匹配的时候会获取。</p>
<h3 id="92-插件匹配">9.2. 插件匹配</h3>
<p>插件过滤，遍历插件列表，匹配开启的插件，O(n) 操作 <code>plugin.filter(route)</code> ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- 插件配置绑定</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">filter</span>(user_route, plugins)
    ...

    plugins <span style="color:#f92672">=</span> plugins <span style="color:#f92672">or</span> core.tablepool.fetch(<span style="color:#e6db74">&#34;plugins&#34;</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">0</span>)
    <span style="color:#66d9ef">for</span> _, plugin_obj <span style="color:#66d9ef">in</span> ipairs(local_plugins) <span style="color:#66d9ef">do</span>
        <span style="color:#66d9ef">local</span> name <span style="color:#f92672">=</span> plugin_obj.name
        <span style="color:#66d9ef">local</span> plugin_conf <span style="color:#f92672">=</span> user_plugin_conf[name]

        <span style="color:#75715e">-- 插件和插件配置存入</span>
        <span style="color:#66d9ef">if</span> type(plugin_conf) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;table&#34;</span> <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> plugin_conf.disable <span style="color:#66d9ef">then</span>
            core.table.insert(plugins, plugin_obj)
            core.table.insert(plugins, plugin_conf)
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    trace_plugins_info_for_debug(plugins)

    <span style="color:#66d9ef">return</span> plugins
<span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="93-插件执行">9.3. 插件执行</h3>
<p>这里以 <code>access_by_lua</code> 阶段插件执行逻辑为例，根据 Route、Service 匹配插件，创建临时 Table 储存 plugin 和  plugin_conf，存入 ctx 中。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">        <span style="color:#75715e">-- 插件过滤, 遍历插件列表, 匹配开启的插件, O(n)</span>
        <span style="color:#66d9ef">local</span> plugins <span style="color:#f92672">=</span> plugin.filter(route)
        api_ctx.plugins <span style="color:#f92672">=</span> plugins

        <span style="color:#75715e">-- fake 执行 rewrite 阶段</span>
        plugin.run_plugin(<span style="color:#e6db74">&#34;rewrite&#34;</span>, plugins, api_ctx)
        <span style="color:#66d9ef">if</span> api_ctx.consumer <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">local</span> changed
            route, changed <span style="color:#f92672">=</span> plugin.merge_consumer_route(
                route,
                api_ctx.consumer,
                api_ctx
            )

            core.log.info(<span style="color:#e6db74">&#34;find consumer &#34;</span>, api_ctx.consumer.username,
                          <span style="color:#e6db74">&#34;, config changed: &#34;</span>, changed)

            <span style="color:#66d9ef">if</span> changed <span style="color:#66d9ef">then</span>
                core.table.clear(api_ctx.plugins)
                api_ctx.plugins <span style="color:#f92672">=</span> plugin.filter(route, api_ctx.plugins)
            <span style="color:#66d9ef">end</span>
        <span style="color:#66d9ef">end</span>
        <span style="color:#75715e">-- 执行 access 阶段</span>
        plugin.run_plugin(<span style="color:#e6db74">&#34;access&#34;</span>, plugins, api_ctx)
</code></pre></div><h2 id="10-主流程">10. 主流程</h2>
<p>以 Nginx HTTP Subsystem 为例分析主要执行逻辑，其中一些核心逻辑已在上述小节中流程分析过。</p>
<h3 id="101-init_by_lua">10.1. init_by_lua</h3>
<p><img src="graph-8.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">http_init</span>(args)
    require(<span style="color:#e6db74">&#34;resty.core&#34;</span>)

    <span style="color:#66d9ef">if</span> require(<span style="color:#e6db74">&#34;ffi&#34;</span>).os <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;Linux&#34;</span> <span style="color:#66d9ef">then</span>
        require(<span style="color:#e6db74">&#34;ngx.re&#34;</span>).opt(<span style="color:#e6db74">&#34;jit_stack_size&#34;</span>, <span style="color:#ae81ff">200</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>)
    <span style="color:#66d9ef">end</span>

    require(<span style="color:#e6db74">&#34;jit.opt&#34;</span>).start(<span style="color:#e6db74">&#34;minstitch=2&#34;</span>, <span style="color:#e6db74">&#34;maxtrace=4000&#34;</span>,
                             <span style="color:#e6db74">&#34;maxrecord=8000&#34;</span>, <span style="color:#e6db74">&#34;sizemcode=64&#34;</span>,
                             <span style="color:#e6db74">&#34;maxmcode=4000&#34;</span>, <span style="color:#e6db74">&#34;maxirconst=1000&#34;</span>)

    core.resolver.init_resolver(args)
    <span style="color:#75715e">-- 生成节点 ID</span>
    core.id.init()

    <span style="color:#75715e">-- 启用 openresty 的特权进程</span>
    <span style="color:#66d9ef">local</span> process <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;ngx.process&#34;</span>)
    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> process.enable_privileged_agent()
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
        core.log.error(<span style="color:#e6db74">&#34;failed to enable privileged_agent: &#34;</span>, err)
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 从 etcd / yaml 本地配置文件获取配置, etcd 有 init 函数</span>
    <span style="color:#66d9ef">if</span> core.config.init <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> core.config.init()
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
            core.log.error(<span style="color:#e6db74">&#34;failed to load the configuration: &#34;</span>, err)
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="102-init_worker_by_lua">10.2. init_worker_by_lua</h3>
<p><img src="graph-9.png" alt=""></p>
<p><img src="graph-10.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">http_init_worker</span>()
    <span style="color:#66d9ef">local</span> seed, err <span style="color:#f92672">=</span> core.utils.get_seed_from_urandom()
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> seed <span style="color:#66d9ef">then</span>
        core.log.warn(<span style="color:#e6db74">&#39;failed to get seed from urandom: &#39;</span>, err)
        seed <span style="color:#f92672">=</span> ngx_now() <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000</span> <span style="color:#f92672">+</span> ngx.worker.pid()
    <span style="color:#66d9ef">end</span>
    math.randomseed(seed)
    <span style="color:#75715e">-- for testing only</span>
    core.log.info(<span style="color:#e6db74">&#34;random test in [1, 10000]: &#34;</span>, math.random(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10000</span>))

    <span style="color:#75715e">-- 进程间事件通信</span>
    <span style="color:#66d9ef">local</span> we <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;resty.worker.events&#34;</span>)
    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> we.configure({shm <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;worker-events&#34;</span>, interval <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>})
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
        error(<span style="color:#e6db74">&#34;failed to init worker event: &#34;</span> <span style="color:#f92672">..</span> err)
    <span style="color:#66d9ef">end</span>
    <span style="color:#75715e">-- 服务发现 lib</span>
    <span style="color:#66d9ef">local</span> discovery <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;apisix.discovery.init&#34;</span>).discovery
    <span style="color:#75715e">-- 默认没有开启服务发现</span>
    <span style="color:#66d9ef">if</span> discovery <span style="color:#f92672">and</span> discovery.init_worker <span style="color:#66d9ef">then</span>
        discovery.init_worker()
    <span style="color:#66d9ef">end</span>
    <span style="color:#75715e">-- 初始化负载均衡器, 方法为空</span>
    require(<span style="color:#e6db74">&#34;apisix.balancer&#34;</span>).init_worker()
    <span style="color:#75715e">-- 负载均衡器</span>
    load_balancer <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;apisix.balancer&#34;</span>)
    <span style="color:#75715e">-- TODO admin 流程分析</span>
    require(<span style="color:#e6db74">&#34;apisix.admin.init&#34;</span>).init_worker()
    <span style="color:#75715e">-- 注册全局 timer</span>
    require(<span style="color:#e6db74">&#34;apisix.timers&#34;</span>).init_worker()

    <span style="color:#75715e">-- 加载所有插件并执行插件 init</span>
    plugin.init_worker()
    <span style="color:#75715e">-- 初始化 router, 并加载 routes</span>
    router.http_init_worker()

    <span style="color:#75715e">-- 初始化 services, 加载 services</span>
    require(<span style="color:#e6db74">&#34;apisix.http.service&#34;</span>).init_worker()
    <span style="color:#75715e">-- 加载插件配置</span>
    plugin_config.init_worker()
    <span style="color:#75715e">-- consumer 加载</span>
    require(<span style="color:#e6db74">&#34;apisix.consumer&#34;</span>).init_worker()

    <span style="color:#66d9ef">if</span> core.config <span style="color:#f92672">==</span> require(<span style="color:#e6db74">&#34;apisix.core.config_yaml&#34;</span>) <span style="color:#66d9ef">then</span>
        core.config.init_worker()
    <span style="color:#66d9ef">end</span>

    require(<span style="color:#e6db74">&#34;apisix.debug&#34;</span>).init_worker()
    <span style="color:#75715e">-- upstreams 加载</span>
    apisix_upstream.init_worker()
    require(<span style="color:#e6db74">&#34;apisix.plugins.ext-plugin.init&#34;</span>).init_worker()

    local_conf <span style="color:#f92672">=</span> core.config.local_conf()

    <span style="color:#66d9ef">if</span> local_conf.apisix <span style="color:#f92672">and</span> local_conf.apisix.enable_server_tokens <span style="color:#f92672">==</span> <span style="color:#66d9ef">false</span> <span style="color:#66d9ef">then</span>
        ver_header <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;APISIX&#34;</span>
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="103-access_by_lua">10.3. access_by_lua</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- access_by_lua 阶段, apisix 没有 rewrite_by_lua</span>
<span style="color:#75715e">-- ref: https://github.com/apache/apisix/issues/1120</span>
<span style="color:#75715e">-- ref: https://github.com/apache/apisix/issues/1120#issuecomment-584949073</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">http_access_phase</span>()
    <span style="color:#66d9ef">local</span> ngx_ctx <span style="color:#f92672">=</span> ngx.ctx
	...

    <span style="color:#75715e">-- 从 table 缓存池中获取 table</span>
    <span style="color:#75715e">-- always fetch table from the table pool, we don&#39;t need a reused api_ctx</span>
    <span style="color:#66d9ef">local</span> api_ctx <span style="color:#f92672">=</span> core.tablepool.fetch(<span style="color:#e6db74">&#34;api_ctx&#34;</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">32</span>)
    <span style="color:#75715e">-- 将 table 储存在 ngx.ctx 中, 下一个阶段共享</span>
    ngx_ctx.api_ctx <span style="color:#f92672">=</span> api_ctx

    <span style="color:#75715e">-- 绑定 metatable </span>
    core.ctx.set_vars_meta(api_ctx)
	...

    <span style="color:#75715e">-- router 路由匹配</span>
    router.router_http.match(api_ctx)

    <span style="color:#75715e">-- run global rule</span>
    plugin.run_global_rules(api_ctx, router.global_rules, <span style="color:#66d9ef">nil</span>)

    ...
    <span style="color:#66d9ef">local</span> enable_websocket <span style="color:#f92672">=</span> route.value.enable_websocket

    <span style="color:#75715e">-- route 插件配置绑定</span>
    <span style="color:#66d9ef">if</span> route.value.plugin_config_id <span style="color:#66d9ef">then</span>
       	...
        route <span style="color:#f92672">=</span> plugin_config.merge(route, conf)
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 获取对应的 service</span>
    <span style="color:#66d9ef">if</span> route.value.service_id <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">local</span> service <span style="color:#f92672">=</span> service_fetch(route.value.service_id)
        ...
        <span style="color:#66d9ef">if</span> enable_websocket <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
            enable_websocket <span style="color:#f92672">=</span> service.value.enable_websocket
        <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">else</span>
        ...
    <span style="color:#66d9ef">end</span>
    api_ctx.route_id <span style="color:#f92672">=</span> route.value.id
    api_ctx.route_name <span style="color:#f92672">=</span> route.value.name

    <span style="color:#75715e">-- 执行 script</span>
    <span style="color:#66d9ef">if</span> route.value.script <span style="color:#66d9ef">then</span>
        script.load(route, api_ctx)
        script.run(<span style="color:#e6db74">&#34;access&#34;</span>, api_ctx)
    <span style="color:#66d9ef">else</span>
        <span style="color:#75715e">-- 插件过滤, 遍历插件列表, 匹配开启的插件, O(n)</span>
        <span style="color:#66d9ef">local</span> plugins <span style="color:#f92672">=</span> plugin.filter(route)
        api_ctx.plugins <span style="color:#f92672">=</span> plugins

        <span style="color:#75715e">-- fake 执行 rewrite 阶段</span>
        plugin.run_plugin(<span style="color:#e6db74">&#34;rewrite&#34;</span>, plugins, api_ctx)
        <span style="color:#66d9ef">if</span> api_ctx.consumer <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">local</span> changed
            route, changed <span style="color:#f92672">=</span> plugin.merge_consumer_route(
                route,
                api_ctx.consumer,
                api_ctx
            )

            core.log.info(<span style="color:#e6db74">&#34;find consumer &#34;</span>, api_ctx.consumer.username,
                          <span style="color:#e6db74">&#34;, config changed: &#34;</span>, changed)

            <span style="color:#66d9ef">if</span> changed <span style="color:#66d9ef">then</span>
                core.table.clear(api_ctx.plugins)
                api_ctx.plugins <span style="color:#f92672">=</span> plugin.filter(route, api_ctx.plugins)
            <span style="color:#66d9ef">end</span>
        <span style="color:#66d9ef">end</span>
        <span style="color:#75715e">-- 执行 access 阶段</span>
        plugin.run_plugin(<span style="color:#e6db74">&#34;access&#34;</span>, plugins, api_ctx)
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> up_id <span style="color:#f92672">=</span> route.value.upstream_id

    <span style="color:#75715e">-- used for the traffic-split plugin</span>
    <span style="color:#66d9ef">if</span> api_ctx.upstream_id <span style="color:#66d9ef">then</span>
        up_id <span style="color:#f92672">=</span> api_ctx.upstream_id
    <span style="color:#66d9ef">end</span>
	...

    <span style="color:#75715e">-- websocket 特殊处理</span>
    <span style="color:#66d9ef">if</span> enable_websocket <span style="color:#66d9ef">then</span>
        api_ctx.var.upstream_upgrade    <span style="color:#f92672">=</span> api_ctx.var.http_upgrade
        api_ctx.var.upstream_connection <span style="color:#f92672">=</span> api_ctx.var.http_connection
        core.log.info(<span style="color:#e6db74">&#34;enabled websocket for route: &#34;</span>, route.value.id)
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> route.value.service_protocol <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;grpc&#34;</span> <span style="color:#66d9ef">then</span>
        api_ctx.upstream_scheme <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;grpc&#34;</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 获取 upstream 节点</span>
    <span style="color:#66d9ef">local</span> code, err <span style="color:#f92672">=</span> set_upstream(route, api_ctx)
    <span style="color:#66d9ef">if</span> code <span style="color:#66d9ef">then</span>
        core.log.error(<span style="color:#e6db74">&#34;failed to set upstream: &#34;</span>, err)
        core.response.exit(code)
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 负载均衡</span>
    <span style="color:#66d9ef">local</span> server, err <span style="color:#f92672">=</span> load_balancer.pick_server(route, api_ctx)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> server <span style="color:#66d9ef">then</span>
        core.log.error(<span style="color:#e6db74">&#34;failed to pick server: &#34;</span>, err)
        <span style="color:#66d9ef">return</span> core.response.exit(<span style="color:#ae81ff">502</span>)
    <span style="color:#66d9ef">end</span>

    api_ctx.picked_server <span style="color:#f92672">=</span> server

    set_upstream_headers(api_ctx, server)

    <span style="color:#75715e">-- stash ngx ctx 这部分与 Kong 一致, 怀疑是抄来的（95% 置信区间）</span>
    ngx_var.ctx_ref <span style="color:#f92672">=</span> ctxdump.stash_ngx_ctx()
    <span style="color:#66d9ef">local</span> up_scheme <span style="color:#f92672">=</span> api_ctx.upstream_scheme
    <span style="color:#66d9ef">if</span> up_scheme <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;grpcs&#34;</span> <span style="color:#f92672">or</span> up_scheme <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;grpc&#34;</span> <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> ngx.exec(<span style="color:#e6db74">&#34;@grpc_pass&#34;</span>)
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> api_ctx.dubbo_proxy_enabled <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> ngx.exec(<span style="color:#e6db74">&#34;@dubbo_pass&#34;</span>)
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><h2 id="11-一些思考">11. 一些思考</h2>
<h3 id="111-边缘计算">11.1. 边缘计算</h3>
<blockquote>
<p>对于互联网设备，网络边缘是设备或包含设备的本地网络与互联网通信的位置。边缘是个比较模糊的术语。例如，可以将用户的计算机或 IoT  摄像头内部的处理器视为网络边缘，但也可以将用户的路由器、ISP 或本地边缘服务器视为边缘。重要的是，网络边缘在地理位置上靠近设备，与源站和云服务器不同，后者可能与它们相互通信的设备相距很远。</p>
<p>完全减轻额外硬件需求的一种方法是利用边缘服务器。例如，借助 Cloudflare 分散在全球各地的 194 个边缘服务器网络，Cloudflare 的客户可以使用 <a href="https://www.cloudflare.com/products/cloudflare-workers/">Cloudflare Workers</a> 在全球范围内运行边缘代码。<sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup></p>
</blockquote>
<p>Cloudflare 的边缘计算是基于 Edge Gateway（边缘网关、边缘集群）的 Serverless 代码执行，提供了 JS 代码执行，以及 WASM 二进制。<sup id="fnref:11"><a href="#fn:11" class="footnote-ref" role="doc-noteref">11</a></sup></p>
<p><em>一些相关的 Issue:</em></p>
<ul>
<li>
<p><a href="https://github.com/openresty/openresty/issues/541">Support wasm in openresty?</a></p>
</li>
<li>
<p><a href="https://github.com/apache/apisix/issues/157">feature: support WebAssembly in apisix.</a></p>
</li>
</ul>
<h3 id="112-serverless">11.2. Serverless</h3>
<p>APISIX 的 Serverless 插件功能支持注入任何 Lua 脚本，而 Kong 网关也有类似的插件功能。<sup id="fnref:12"><a href="#fn:12" class="footnote-ref" role="doc-noteref">12</a></sup></p>
<p><img src="image-20210611160354452.png" alt=""></p>
<p>Serverless 插件支持执行简单的函数方法。</p>
<h3 id="113-webassembly">11.3. WebAssembly</h3>
<p>APISIX 自 2019 年发起提案，试图通过 WebAssembly 来扩展 Lua 贫乏的生态。
2021 年，在 WebAssembly 运行时的技术选型上，APISIX 的技术团队更偏向使用由 Fastly 团队
支撑<sup id="fnref:13"><a href="#fn:13" class="footnote-ref" role="doc-noteref">13</a></sup>的 <a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a> 项目。</p>
<p>开源的 WebAssembly 除了 wasmtime 还有<sup id="fnref:14"><a href="#fn:14" class="footnote-ref" role="doc-noteref">14</a></sup>：</p>
<ul>
<li><a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a>（前身 SSVM），由 Second State 开源的 CNCF 沙箱项目。</li>
<li><a href="https://github.com/wasmerio/wasmer">Wasmer</a>，Dart 语言使用的 Wasm 运行时。</li>
<li><a href="https://github.com/bytecodealliance/lucet">Lucet</a>，由 Fastly 开源的 <a href="https://bytecodealliance.org/">Bytecode Alliance</a> 的
项目，将会与 wasmtime 合并。</li>
</ul>
<p>在 Issue <a href="https://github.com/apache/apisix/issues/157">#157</a> 的讨论中，Wasmer 的 CEO 也来插了一嘴，
希望 APISIX 能够选型 Wasmer 运行时，APISIX 成员给了 Wasmer 一个大大的赞，
最终在 <a href="https://github.com/api7/wasm-nginx-module">api7/wasm-nginx-module</a> 插件中，
还是使用 wasmtime 运行时实现了对 WebAssembly 的支持。</p>
<h3 id="114-service-mesh">11.4. Service Mesh</h3>
<p>APISIX 的 Service Mesh 项目 <a href="https://github.com/api7/apisix-mesh-agent">api7/apisix-mesh-agent</a>，将 APISIX Proxy 作为 Sidecar 运作在数据平面。通过实现控制平面的接口，接入类似 <a href="https://github.com/istio/istio">Istio</a> 或 <a href="https://github.com/kumahq/kuma">Kuma</a>（由 Kong 创建捐赠给 CNCF） 的控制平面，形成一套完整的 Service Mesh 方案。
该项目本质上是使用 APISIX 替换了 Istio 中的 Envoy。</p>
<p><img src="apisix-mesh-overview.png" alt=""></p>
<p>值得一提的是 Kong 类似的 Service Mesh 项目，叫做 <a href="https://docs.konghq.com/mesh/">Kong Mesh</a>，目前只提供企业版本。</p>
<p><img src="kong_mesh.png" alt=""></p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>摘自 APISIX <a href="https://github.com/apache/apisix/issues/3207#issuecomment-759269071">#3207</a> Issue <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p><a href="https://segmentfault.com/a/1190000016149595">LuaJIT FFI 介绍，及其在 OpenResty 中的应用（下）</a> <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p><a href="https://yxudong.github.io/%E3%80%8AOpenResty%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E3%80%8B6.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">《OpenResty精华整理》6.性能优化 </a> <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p><a href="https://github.com/openresty/luajit2">openresty/luajit2</a> <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p><a href="https://www.cnblogs.com/liekkas01/p/12764577.html">OpenResty：特权进程和定时任务</a> <a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>OpenResty lua-resty-core 文档 <a href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/process.md#enable_privileged_agent">enable_privileged_agent</a> <a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p>OpenResty Issue <a href="https://github.com/openresty/lua-nginx-module/issues/1482">ngx.var vs ngx.ctx</a> <a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8" role="doc-endnote">
<p><a href="https://github.com/openresty/lua-resty-lrucache#description">openresty/lua-resty-lrucache</a> <a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:9" role="doc-endnote">
<p><a href="https://github.com/apache/apisix/issues/1120#issuecomment-584949073">set variable inoperative!!</a> <a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:10" role="doc-endnote">
<p><a href="https://www.cloudflare.com/zh-cn/learning/serverless/glossary/what-is-edge-computing/">什么是边缘计算？</a> <a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:11" role="doc-endnote">
<p><a href="https://blog.cloudflare.com/webassembly-on-cloudflare-workers/">WebAssembly on Cloudflare Workers</a> <a href="#fnref:11" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:12" role="doc-endnote">
<p><a href="https://github.com/apache/apisix/blob/master/docs/en/latest/plugins/serverless.md">APISIX Serverless Plugin</a> <a href="#fnref:12" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:13" role="doc-endnote">
<p>摘自 <a href="https://bytecodealliance.org/articles/1-year-update">Bytecode Alliance: One year update</a> <a href="#fnref:13" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:14" role="doc-endnote">
<p>摘自 <a href="https://github.com/apache/apisix/issues/5106">Proposal: APISIX JavaScript Plugin Runner</a> <a href="#fnref:14" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

        </div>
        <!-- tags -->
        <div class="mb-3">
          <h5 class="d-inline-block mr-3">Tags:</h5>
          <ul class="list-inline d-inline-block">
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb"> 
            源码阅读</a>
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/%e7%bd%91%e5%85%b3"> , 
            网关</a>
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/apisix"> , 
            Apisix</a>
            
          </ul>
        </div>
        <!-- previous -->
        
<div class="col-12">
<ul class="pager blog-pager">

<li class="previous">
<a href="https://cloudnative.to/blog/chaos-engineering-with-kubernetes/" data-toggle="tooltip" data-placement="top" title="在 Kubernetes 实施混沌工程——Chaos Mesh 原理分析与控制面开发">&larr; 上一篇</a>
</li>
 
<li class="next">
<a href="https://cloudnative.to/blog/istio-zero-trust-source-code-reading/" data-toggle="tooltip" data-placement="top" title="Istio 安全源码分析——认证体系与通信安全">下一篇 &rarr;</a>
</li>

</ul>
</div>


        <!-- previous -->

        <!-- recommend -->
        

<div class="mb-3">
  <h2>文章推荐</h2>
  <ul class="related">
  
    <li><a href="/blog/kong-source-code-reading/">云原生网关 Kong 源码分析</a></li>
  
    <li><a href="/blog/chaos-engineering-with-kubernetes/">在 Kubernetes 实施混沌工程——Chaos Mesh 原理分析与控制面开发</a></li>
  
  </ul>
</div>


        <!-- comments -->

        
        <div id="gitalk-container"></div>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
        <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
        <script>
          window.onload = function() {
              const gitalk = new Gitalk({
              clientID: '0f001988910adcfadfb7',
              clientSecret: '14f7d06ee5e6575c295d18fc11616e8cb60fb84e',
              repo: 'cloudnativeto.github.io',
              owner: 'cloudnativeto',
              admin: ['rootsongjc'],
              id: hex_md5(hex_md5(window.location.pathname + window.location.hash)), 
              distractionFreeMode: false 
            });
            (function() {
              if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
                document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
                return;
              }
              gitalk.render('gitalk-container');
            })();
          }
        </script>
        
      </div>
      <!-- sidebar -->
<aside class="col-lg-4 order-1 order-lg-2">
    <!-- categories -->
<div class="bg-pink px-4 py-5 box-shadow mb-5">
  <h4 class="mb-4">分类</h4>
  <ul class="list-unstyled">
    <li class="border-bottom"><a href="/categories/devops" class="d-block pb-3 mt-3 text-capitalize">Devops</a></li>
    <li class="border-bottom"><a href="/categories/envoy" class="d-block pb-3 mt-3 text-capitalize">Envoy</a></li>
    <li class="border-bottom"><a href="/categories/istio" class="d-block pb-3 mt-3 text-capitalize">Istio</a></li>
    <li class="border-bottom"><a href="/categories/kubernetes" class="d-block pb-3 mt-3 text-capitalize">Kubernetes</a></li>
    <li class="border-bottom"><a href="/categories/serverless" class="d-block pb-3 mt-3 text-capitalize">Serverless</a></li>
    <li class="border-bottom"><a href="/categories/service-mesh" class="d-block pb-3 mt-3 text-capitalize">Service mesh</a></li>
    <li class="border-bottom"><a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="d-block pb-3 mt-3 text-capitalize">云原生</a></li>
    <li class="border-bottom"><a href="/categories/%e5%85%b6%e4%bb%96" class="d-block pb-3 mt-3 text-capitalize">其他</a></li>
    <li class="border-bottom"><a href="/categories/%e5%8f%af%e8%a7%82%e5%af%9f%e6%80%a7" class="d-block pb-3 mt-3 text-capitalize">可观察性</a></li>
    <li class="border-bottom"><a href="/categories/%e5%ae%89%e5%85%a8" class="d-block pb-3 mt-3 text-capitalize">安全</a></li>
    <li class="border-bottom"><a href="/categories/%e5%bc%80%e6%ba%90" class="d-block pb-3 mt-3 text-capitalize">开源</a></li>
    <li class="border-bottom"><a href="/categories/%e5%bc%80%e6%ba%90%e7%a4%be%e5%8c%ba" class="d-block pb-3 mt-3 text-capitalize">开源社区</a></li>
    <li class="border-bottom"><a href="/categories/%e6%8c%81%e7%bb%ad%e4%ba%a4%e4%bb%98" class="d-block pb-3 mt-3 text-capitalize">持续交付</a></li>
    <li class="border-bottom"><a href="/categories/%e7%a8%b3%e5%ae%9a%e6%80%a7" class="d-block pb-3 mt-3 text-capitalize">稳定性</a></li>
    <li class="border-bottom"><a href="/categories/%e8%be%b9%e7%bc%98%e8%ae%a1%e7%ae%97" class="d-block pb-3 mt-3 text-capitalize">边缘计算</a></li>
  </ul>
</div>

  <!-- tags -->
  

  <!-- profile -->
  <div class="bg-pink px-4 py-5 box-shadow mb-5 avatar-content">
    <div class="avatar">
      <div class="mx-auto avatar-wrp">
        <img class="rounded-circle avatar-img" src="https://github.com/mayocream.png">
      </div>
      <p class="avatar-name">
        <strong class="text-dark "><a href="https://github.com/mayocream">Mayo Cream</a></strong> 
      </p>
      <p>Kubernetes Member, CNCF Security TAG Member, OSS Contributor.</p>
    </div>
  </div>
  <!-- toc -->
  
  <div class="bg-white px-4 py-5 box-shadow mb-5 sticky-top">
    <h4 class="mb-4">目录</h4>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-apisix-概述">1. APISIX 概述</a>
      <ul>
        <li><a href="#11-项目概述">1.1. 项目概述</a></li>
        <li><a href="#12-生态概述">1.2. 生态概述</a></li>
      </ul>
    </li>
    <li><a href="#2-基本流程">2. 基本流程</a>
      <ul>
        <li><a href="#21-目录结构">2.1. 目录结构</a></li>
        <li><a href="#22-启动流程">2.2. 启动流程</a></li>
      </ul>
    </li>
    <li><a href="#3-基本类型操作">3. 基本类型操作</a>
      <ul>
        <li><a href="#31-字符串">3.1. 字符串</a></li>
        <li><a href="#32-table">3.2. Table</a></li>
      </ul>
    </li>
    <li><a href="#4-工具类">4. 工具类</a>
      <ul>
        <li><a href="#41-json-操作">4.1. JSON 操作</a></li>
        <li><a href="#42-lru-缓存">4.2. LRU 缓存</a></li>
        <li><a href="#43-后台任务">4.3. 后台任务</a></li>
      </ul>
    </li>
    <li><a href="#5-请求生命周期">5. 请求生命周期</a>
      <ul>
        <li><a href="#51-ctx">5.1. ctx</a></li>
        <li><a href="#52-headers">5.2. headers</a></li>
      </ul>
    </li>
    <li><a href="#6-etcd">6. etcd</a>
      <ul>
        <li><a href="#61-初始化">6.1. 初始化</a></li>
        <li><a href="#62-数据校验">6.2. 数据校验</a></li>
        <li><a href="#63-后台数据同步">6.3. 后台数据同步</a></li>
        <li><a href="#64-配置同步">6.4. 配置同步</a></li>
      </ul>
    </li>
    <li><a href="#7-router">7. Router</a>
      <ul>
        <li><a href="#71-路由构建">7.1. 路由构建</a></li>
        <li><a href="#72-路由初始化">7.2. 路由初始化</a></li>
        <li><a href="#73-路由匹配">7.3. 路由匹配</a></li>
      </ul>
    </li>
    <li><a href="#8-balancer">8. Balancer</a>
      <ul>
        <li><a href="#81-服务发现">8.1. 服务发现</a></li>
        <li><a href="#82-负载均衡">8.2. 负载均衡</a></li>
      </ul>
    </li>
    <li><a href="#9-plugin">9. Plugin</a>
      <ul>
        <li><a href="#91-插件加载">9.1. 插件加载</a></li>
        <li><a href="#92-插件匹配">9.2. 插件匹配</a></li>
        <li><a href="#93-插件执行">9.3. 插件执行</a></li>
      </ul>
    </li>
    <li><a href="#10-主流程">10. 主流程</a>
      <ul>
        <li><a href="#101-init_by_lua">10.1. init_by_lua</a></li>
        <li><a href="#102-init_worker_by_lua">10.2. init_worker_by_lua</a></li>
        <li><a href="#103-access_by_lua">10.3. access_by_lua</a></li>
      </ul>
    </li>
    <li><a href="#11-一些思考">11. 一些思考</a>
      <ul>
        <li><a href="#111-边缘计算">11.1. 边缘计算</a></li>
        <li><a href="#112-serverless">11.2. Serverless</a></li>
        <li><a href="#113-webassembly">11.3. WebAssembly</a></li>
        <li><a href="#114-service-mesh">11.4. Service Mesh</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>

</aside>
<!-- /sidebar -->

    </div>
  </div>
</section>
<!-- /blog details -->



<footer>
  
  <div class="section bg-secondary">
    <div class="container">
      <div class="row justify-content-between">
        
        <div class="col-lg-5 mb-5 mb-lg-0">
          
          <a class="mb-4 d-inline-block" href="/"><img class="img-fluid"
              src="/images/logo-alt.png" alt="云原生社区" width="60%"></a>
          <p class="text-light mb-5">云原生社区是国内最大的独立第三方云原生终端用户和泛开发者社区，由 CNCF 大使、开源意见领袖共同发起成立于 2020 年 5 月 12 日，提供云原生专业资讯，促进云原生产业发展。</p>
          <h4 class="text-white mb-4">关注我们</h4>
          
          <ul class="list-inline social-icon-alt">
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://twitter.com/cloudnativecn"><i class="fab fa-twitter"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://github.com/cloudnativeto"><i class="fab fa-github"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://mp.weixin.qq.com/s/vWlSdzz2MNdXRr0sd2-LFg"><i class="fab fa-weixin"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="mailto:contact@cloudnative.to"><i class="far fa-envelope"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://zhuanlan.zhihu.com/cloud-native"><i class="fab fa-zhihu"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://space.bilibili.com/515485124"><i class="fas fa-play-circle"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://cloudnative.to/blog/index.xml"><i class="fas fa-rss"></i></a>
            </li>
            
          </ul>
        </div>
        <div class="col-lg-5 mb-5 mb-lg-0">
            
            
            
            
            
            <div class="mb-5 address">
              <h4 class="text-white mb-4">联系信息</h4>
              <p class="text-light mb-3"><a href="/city/beijing">北京</a>|<a href="/city/shanghai">上海</a>|<a href="/city/chengdu">成都</a>|<a href="/city/shenzhen">深圳</a>|<a href="/city/hangzhou/">杭州</a>|<a href="/city/guangzhou/">广州</a>|<a href="https://github.com/cloudnativeto/community/issues/55">武汉</a>|<a href="/city/nanjing">南京</a>|<a href="https://github.com/cloudnativeto/community/issues/61">西安</a>|<a href="/city/dalian">大连</a>|<a href="https://github.com/cloudnativeto/community/issues/52">长沙</a>|<a href="https://github.com/cloudnativeto/community/issues/66">苏州</a>|<a href="https://github.com/cloudnativeto/community/issues/67">珠海</a>|<a href="https://github.com/cloudnativeto/community/issues/78">重庆</a>|<a href="https://github.com/cloudnativeto/community/issues/82">济南</a>|<a href="https://github.com/cloudnativeto/community/issues/83">厦门</a>|<a href="https://github.com/cloudnativeto/community/issues/86">无锡</a>|<a href="https://github.com/cloudnativeto/community/issues/91">青岛</a>|<a href="https://github.com/cloudnativeto/community/issues/103">郑州</a>|<a href="https://github.com/cloudnativeto/community/issues/107">合肥</a></p>
              <p class="text-light mb-3"></p>
              <p class="text-light mb-3">关注云原生社区微信公众号，加入社区并获取最新资讯。</p>
              <p class="text-light mb-3"><img src="/images/wechat-qrcode.jpg" width="128px"></p>
            </div>
            
            
        </div>
      </div>
    </div>
  </div>
  
  <div class="bg-secondary-darken py-4">
    <div class="container">
      <div class="row">
        <div class="col-md-6 text-center text-md-left mb-3 mb-md-0">
          <p class="mb-0 text-white">Copyright © 2022 云原生社区</p>
        </div>
        <div class="col-md-6 text-center text-md-right">
          <ul class="list-inline">
            
            <li class="list-inline-item mx-0"><a class="d-inline-block px-3 text-white" href="/policy"
                class="text-white">声明与政策</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>




<!-- JS Plugins -->

<script src="/plugins/jQuery/jquery.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/google-map/gmap.js"></script>

<script src="/plugins/venobox/venobox.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/search/search.js"></script>

<script src="/plugins/bigPicture/bigPicture.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>


<!-- Main Script -->

<script src="/js/script.min.js"></script>

<!-- Algolia -->
<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.min.js"></script>
<script>
  docsearch({
    apiKey: '870a8addaf7a712ecc6e33ce9def93b1',
    indexName: 'DocSearch',
    appId: '2506Q6I4IV',
    inputSelector: '#js-algolia-btn',
    debug: false,
  });
</script>

<!-- baidu tongji-->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f3dc895ea3bd6186cd835841d365c103";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


<!-- google analitycs -->

<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o),
      m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
  ga('create', 'UA-93485976-4', 'auto');
  ga('send', 'pageview');
</script>


</body>

</html>
