<!DOCTYPE html><html lang="zh" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.5.0 for Hugo" />
  

  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
  

  

  
  
  
    
  
  <meta name="description" content="本文介绍了如何在 Docker 中使用 WebAssembly（Wasm）来运行 PHP 应用程序。Wasm 容器比传统容器更小，提供更高级别的沙盒性能，并且具有真正的可移植性。本文还提供了一些示例，演示了如何使用 Wasm 在不同的环境中运行 WordPress。" />

  
  <link rel="alternate" hreflang="zh" href="https://cloudnative.to/blog/docker-without-containers/" />

  
  
  
    <meta name="theme-color" content="#0a55a7" />
  

  
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css" media="print" onload="this.media='all'">

  
  
  
    
    

    
    
    
    
      
      
    
    
    

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      
        
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.008259417e6adf8980695ebbbb46553f.css" />

  



  


  


  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f3dc895ea3bd6186cd835841d365c103";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_hu0802e500a55b0406ddf0453824effa47_6997_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hu0802e500a55b0406ddf0453824effa47_6997_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://cloudnative.to/blog/docker-without-containers/" />

  
  
  
  
  
  
  
  
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary_large_image" />
  
    <meta property="twitter:site" content="@CloudNativeCN" />
    <meta property="twitter:creator" content="@CloudNativeCN" />
  
  <meta property="og:site_name" content="云原生社区（中国）" />
  <meta property="og:url" content="https://cloudnative.to/blog/docker-without-containers/" />
  <meta property="og:title" content="WebAssembly：无需容器就能运行 Docker！ | 云原生社区（中国）" />
  <meta property="og:description" content="本文介绍了如何在 Docker 中使用 WebAssembly（Wasm）来运行 PHP 应用程序。Wasm 容器比传统容器更小，提供更高级别的沙盒性能，并且具有真正的可移植性。本文还提供了一些示例，演示了如何使用 Wasm 在不同的环境中运行 WordPress。" /><meta property="og:image" content="https://cloudnative.to/media/sharing.png" />
    <meta property="twitter:image" content="https://cloudnative.to/media/sharing.png" /><meta property="og:locale" content="zh" />
  
    
      <meta
        property="article:published_time"
        content="2023-04-27T06:27:22&#43;08:00"
      />
    
    <meta property="article:modified_time" content="2024-10-21T09:56:55&#43;08:00">
  

  


    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cloudnative.to/blog/docker-without-containers/"
  },
  "headline": "WebAssembly：无需容器就能运行 Docker！",
  
  "datePublished": "2023-04-27T06:27:22+08:00",
  "dateModified": "2024-10-21T09:56:55+08:00",
  
  "author": {
    "@type": "Person",
    "name": "Asen Alexandrov"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "云原生社区（中国）",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cloudnative.to/media/logo.svg"
    }
  },
  "description": "本文介绍了如何在 Docker 中使用 WebAssembly（Wasm）来运行 PHP 应用程序。Wasm 容器比传统容器更小，提供更高级别的沙盒性能，并且具有真正的可移植性。本文还提供了一些示例，演示了如何使用 Wasm 在不同的环境中运行 WordPress。"
}
</script>

  

  

  

  





  <title>WebAssembly：无需容器就能运行 Docker！ | 云原生社区（中国）</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="b7edbcdc4203e851419f2c5fa58a699f" >
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden="true"></i></button>
  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.62d6f8dfe8493f1c68557dde65bec362.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6 search-title">
          <p>搜索</p>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="关闭"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="搜索..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="搜索...">
        
      </div>

      
      

      
    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

      <div id="search-common-queries">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    











  


<header class="header--fixed">
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区（中国）"
            
            ></a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="切换导航">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区（中国）"
          
          ></a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/community"><span>社区</span></a>
          </li>

          
          

          

          
          
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link  active" href="/blog"><span>博客</span></a>
          </li>

          
          

          
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>小组</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/k8s-gateway-api"><span>Kubernetes Gateway API SIG</span></a>
              
            </div>
          </li>

          
          

          
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>资料</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/envoy/"><span>Envoy 中文文档</span></a>
              
                <a class="dropdown-item" href="/kubebuilder/"><span>Kubebuilder 中文文档</span></a>
              
                <a class="dropdown-item" href="https://lib.jimmysong.io/"><span>云原生资料库</span></a>
              
                <a class="dropdown-item" href="https://istio.io/latest/zh/"><span>Istio 中文文档</span></a>
              
            </div>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/event"><span>活动</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#feed"><span>更新</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#tags"><span>标签</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#about"><span>关于</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        

        
        <li class="nav-item">
            <a class="nav-link" href="/community/join/" data-toggle="tooltip" data-placement="bottom" title="加入社区" aria-label="主站"><i class="fa-brands fa-weixin" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item">
            <a class="nav-link js-search" href="#" data-toggle="tooltip" data-placement="bottom" title="搜索" aria-label="搜索"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item d-none d-lg-inline-flex">
            <a class="nav-link" href="https://github.com/cloudnativeto/cloudnative.to" target="_blank" rel="noopener" data-toggle="tooltip" data-placement="bottom" title="查看源码" aria-label="查看源码" aria-label="GitHub"><i class="fa-brands fa-github" aria-hidden="true"></i></a>
        </li>
        

        
        
        
        <li class="nav-item">
          <a href="#" class="nav-link set-theme">
            <i class="fa fa-sun" aria-hidden="true" id="theme-icon"></i>
          </a>
        </li>
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    <div class="container-xl">
    <div class="post-container">
        












  

  
  
  
<div class="article-container pt-3">
  <h1>WebAssembly：无需容器就能运行 Docker！</h1>

  

  
    


<div class="article-metadata">

  <div>
  
  
  
  
    <i class="fa-solid fa-feather"></i>
    

  <span >
      <a href="/author/asen-alexandrov/">Asen Alexandrov</a></span>
    
    <span class="middot-divider"></span>
    
  
  
  
  
  
  
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/category/webassembly/" class="text-capitalize">WebAssembly</a></span>
  
  </div>

  
  <span class="article-date">
    
    
      
          
          发布于
      
    
    2023-04-27
  </span>
  

  

  
  <span class="middot-divider"></span>
  字数 6543
  <span class="middot-divider"></span>
  <span class="article-reading-time">
      阅读时长 30 分钟
  </span>
  

  
  
  
  

</div>

    




<div class="btn-links mb-2">
  
  








  


















  
  
  
  
  
  
  
    
  
  <a class="btn btn-outline-primary btn-page-header" href="https://wasmlabs.dev/articles/docker-without-containers/" target="_blank" rel="noopener">
    <i class="fa fa-language mr-1"></i>阅读英文版原文</a>


</div>


  
</div>


    </div>
    <div class="border-bottom mb-2"></div>
    <div class="row flex-xl-nowrap">
        <div class="col-3 d-none d-xl-block docs-toc">
            <!-- toc -->
            
<div class="">
    <ul class="nav toc-top">
        <li>
            <a href="#" id="back_to_top" class="docs-toc-title">目录</a>
        </li>
    </ul>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#webassembly---什么为什么">WebAssembly - 什么？为什么？</a>
      <ul>
        <li><a href="#什么是-webassembly">什么是 WebAssembly？</a></li>
        <li><a href="#wasm-在浏览器中是如何工作的">Wasm 在浏览器中是如何工作的？</a></li>
        <li><a href="#wasm-在服务器上是如何工作的">Wasm 在服务器上是如何工作的？</a></li>
        <li><a href="#什么使-wasm-如此出色">什么使 Wasm 如此出色？</a></li>
        <li><a href="#服务器平台演进的下一步">服务器平台演进的下一步？</a></li>
        <li><a href="#wasm-如何与-docker-配合使用">Wasm 如何与 Docker 配合使用？</a></li>
        <li><a href="#什么是-wasmedge">什么是 WasmEdge？</a></li>
        <li><a href="#解释性语言呢">解释性语言呢？</a></li>
      </ul>
    </li>
    <li><a href="#实际演示">实际演示</a></li>
    <li><a href="#先决条件">先决条件</a></li>
    <li><a href="#构建一个-wasm-容器">构建一个 Wasm 容器</a>
      <ul>
        <li><a href="#构建-wasm-二进制文件">构建 WASM 二进制文件</a></li>
        <li><a href="#优化二进制文件">优化二进制文件</a></li>
        <li><a href="#构建-oci-镜像">构建 OCI 镜像</a></li>
      </ul>
    </li>
    <li><a href="#原生-vs-wasm">原生 vs Wasm</a>
      <ul>
        <li><a href="#原生运行-indexphp-的-php">原生运行 index.php 的 PHP</a></li>
        <li><a href="#php-aot-wasm-运行-indexphp">php-aot-wasm 运行 index.php</a></li>
        <li><a href="#容器中运行-indexphp-的-php">容器中运行 index.php 的 PHP</a></li>
        <li><a href="#容器中运行-indexphp-的-php-aot-wasm">容器中运行 index.php 的 php-aot-wasm</a></li>
      </ul>
    </li>
    <li><a href="#传统容器与-wasm-容器">传统容器与 wasm 容器</a>
      <ul>
        <li><a href="#容器统计">容器统计</a></li>
        <li><a href="#镜像大小">镜像大小</a></li>
      </ul>
    </li>
    <li><a href="#wasm-的可移植性">Wasm 的可移植性</a>
      <ul>
        <li><a href="#通过-wasmedge-提供-wordpress">通过 WasmEdge 提供 WordPress</a></li>
        <li><a href="#通过-dockerwasm-提供-wordpress">通过 Docker+Wasm 提供 WordPress</a></li>
        <li><a href="#通过-apache-httpd-中的-mod_wasm-提供-wordpress">通过 Apache HTTPD 中的 mod_wasm 提供 WordPress</a></li>
        <li><a href="#直接在浏览器中提供-wordpress">直接在浏览器中提供 WordPress</a></li>
      </ul>
    </li>
    <li><a href="#结论">结论</a></li>
  </ul>
</nav>
</div>

            <!-- /toc -->
            
            <div class="subscribe-module col-12 mt-1">
    <img src="/img/wechat.jpg" alt="image" title="云原生社区的微信公众号"/>
    <p class="text-center pt-1">关注「云原生社区动态」微信公众号，获取本站更新</p>
</div>

            
        </div>
        <main class="article-body col-9 container docs-content" role="main">
            <article class="article">
                <div class="article-style">
                    
                    <details class="toc-inpage d-print-none d-show-block mb-0">
  <summary class="font-weight-bold">点击查看目录</summary>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#webassembly---什么为什么">WebAssembly - 什么？为什么？</a>
      <ul>
        <li><a href="#什么是-webassembly">什么是 WebAssembly？</a></li>
        <li><a href="#wasm-在浏览器中是如何工作的">Wasm 在浏览器中是如何工作的？</a></li>
        <li><a href="#wasm-在服务器上是如何工作的">Wasm 在服务器上是如何工作的？</a></li>
        <li><a href="#什么使-wasm-如此出色">什么使 Wasm 如此出色？</a></li>
        <li><a href="#服务器平台演进的下一步">服务器平台演进的下一步？</a></li>
        <li><a href="#wasm-如何与-docker-配合使用">Wasm 如何与 Docker 配合使用？</a></li>
        <li><a href="#什么是-wasmedge">什么是 WasmEdge？</a></li>
        <li><a href="#解释性语言呢">解释性语言呢？</a></li>
      </ul>
    </li>
    <li><a href="#实际演示">实际演示</a></li>
    <li><a href="#先决条件">先决条件</a></li>
    <li><a href="#构建一个-wasm-容器">构建一个 Wasm 容器</a>
      <ul>
        <li><a href="#构建-wasm-二进制文件">构建 WASM 二进制文件</a></li>
        <li><a href="#优化二进制文件">优化二进制文件</a></li>
        <li><a href="#构建-oci-镜像">构建 OCI 镜像</a></li>
      </ul>
    </li>
    <li><a href="#原生-vs-wasm">原生 vs Wasm</a>
      <ul>
        <li><a href="#原生运行-indexphp-的-php">原生运行 index.php 的 PHP</a></li>
        <li><a href="#php-aot-wasm-运行-indexphp">php-aot-wasm 运行 index.php</a></li>
        <li><a href="#容器中运行-indexphp-的-php">容器中运行 index.php 的 PHP</a></li>
        <li><a href="#容器中运行-indexphp-的-php-aot-wasm">容器中运行 index.php 的 php-aot-wasm</a></li>
      </ul>
    </li>
    <li><a href="#传统容器与-wasm-容器">传统容器与 wasm 容器</a>
      <ul>
        <li><a href="#容器统计">容器统计</a></li>
        <li><a href="#镜像大小">镜像大小</a></li>
      </ul>
    </li>
    <li><a href="#wasm-的可移植性">Wasm 的可移植性</a>
      <ul>
        <li><a href="#通过-wasmedge-提供-wordpress">通过 WasmEdge 提供 WordPress</a></li>
        <li><a href="#通过-dockerwasm-提供-wordpress">通过 Docker+Wasm 提供 WordPress</a></li>
        <li><a href="#通过-apache-httpd-中的-mod_wasm-提供-wordpress">通过 Apache HTTPD 中的 mod_wasm 提供 WordPress</a></li>
        <li><a href="#直接在浏览器中提供-wordpress">直接在浏览器中提供 WordPress</a></li>
      </ul>
    </li>
    <li><a href="#结论">结论</a></li>
  </ul>
</nav>
</details>

                    
                    <p>最近，Docker 宣布与 WasmEdge 合作，在 Docker 生态系统中支持 <a href="https://docs.docker.com/desktop/wasm/" target="_blank" rel="noopener">WebAssembly</a>。</p>
<p>本文将介绍什么是 WebAssembly，以及为什么它与 Docker 生态系统相关，并提供一些实践示例。我们假设您熟悉 Docker 工具集。我们将使用我们的 <a href="https://wasmlabs.dev/articles/php-wasm32-wasi-port/" target="_blank" rel="noopener">WebAssembly PHP 的端口</a> 来演示如何构建 PHP 解释器，将其打包为 OCI 镜像的一部分，并使用 Docker 运行它。</p>
<p>请注意，本文的重点是获得实践经验，而不是讨论技术细节。您可以复制以下示例，也可以只读到最后，因为我们还将提供输出。</p>
<h2 id="webassembly---什么为什么">WebAssembly - 什么？为什么？</h2>
<p>这是一个非常基本的介绍。如果您已经熟悉该技术，则可以跳到动手环节。</p>
<h3 id="什么是-webassembly">什么是 WebAssembly？</h3>
<p>WebAssembly（或 Wasm）是一个开放标准，定义了一种二进制指令格式，可以从不同的源语言创建可移植的二进制可执行文件。</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/docker-without-containers/1_hu9f2ff678deb0c6bb75e5edef2989001d_8504_7443fbab0b1c3dbf6b3518459e639ea5.webp 400w,
               /blog/docker-without-containers/1_hu9f2ff678deb0c6bb75e5edef2989001d_8504_c3ad77e21a39ed3c4d0c4f35d6a627f0.webp 760w,
               /blog/docker-without-containers/1_hu9f2ff678deb0c6bb75e5edef2989001d_8504_1200x1200_fit_q75_h2_lanczos_2.webp 1200w"
               src="/blog/docker-without-containers/1_hu9f2ff678deb0c6bb75e5edef2989001d_8504_7443fbab0b1c3dbf6b3518459e639ea5.webp"
               width="757"
               height="181"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>这些二进制文件可以在各种环境中运行。它起源于 web，并得到所有主要浏览器的支持。</p>
<h3 id="wasm-在浏览器中是如何工作的">Wasm 在浏览器中是如何工作的？</h3>
<p>浏览器引擎集成了一个 Wasm 虚拟机，通常称为 Wasm 运行时，它可以运行 Wasm 二进制指令。有编译器工具链（如 Emscripten）可以将源代码编译为 Wasm 目标。这允许将传统应用程序移植到浏览器，并直接与在客户端 Web 应用程序中运行的 JS 代码通信。</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/docker-without-containers/2_hufcd9523e703b2890ed50bf80e0b5cf14_11104_f73936d5271f85b379a4f681382ec832.webp 400w,
               /blog/docker-without-containers/2_hufcd9523e703b2890ed50bf80e0b5cf14_11104_d1465a0108af12ea500f4705188478a2.webp 760w,
               /blog/docker-without-containers/2_hufcd9523e703b2890ed50bf80e0b5cf14_11104_1200x1200_fit_q75_h2_lanczos_2.webp 1200w"
               src="/blog/docker-without-containers/2_hufcd9523e703b2890ed50bf80e0b5cf14_11104_f73936d5271f85b379a4f681382ec832.webp"
               width="757"
               height="312"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>这些技术使传统桌面应用程序可以在浏览器中运行。现在它们可以在任何您拥有浏览器的设备上运行。一些著名的例子是 <a href="https://earth.google.com/" target="_blank" rel="noopener">Google Earth</a> 和计算机视觉的 <a href="https://opencv.org/" target="_blank" rel="noopener">Open CV</a> 库。</p>
<h3 id="wasm-在服务器上是如何工作的">Wasm 在服务器上是如何工作的？</h3>
<p>有一些 Wasm 运行时可以在浏览器之外运行，包括传统操作系统，如 Linux、Windows 和 macOS。由于它们不能依赖于 JavaScript 引擎的可用性，它们使用不同的接口（例如 WASI，<a href="https://wasi.dev/" target="_blank" rel="noopener">WebAssembly 系统接口</a>）与外界通信。这些运行时允许 Wasm 应用程序以与 POSIX 类似（但不完全相同）的方式与其主机系统交互。像 WASI SDK 和 wasi-libc 这样的项目可以帮助人们将现有的 POSIX 兼容应用程序编译到 WebAssembly。</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/docker-without-containers/3_hub847a4647ba520c473fa897afead2bca_12792_ef9be3b0ec16df39f23f570fb99a9496.webp 400w,
               /blog/docker-without-containers/3_hub847a4647ba520c473fa897afead2bca_12792_15f421a0d3b29d92aecd27d31b86635c.webp 760w,
               /blog/docker-without-containers/3_hub847a4647ba520c473fa897afead2bca_12792_1200x1200_fit_q75_h2_lanczos_2.webp 1200w"
               src="/blog/docker-without-containers/3_hub847a4647ba520c473fa897afead2bca_12792_ef9be3b0ec16df39f23f570fb99a9496.webp"
               width="757"
               height="306"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>您只需要将应用程序编译为 Wasm 模块一次，然后就可以在任何地方运行完全相同的二进制文件。</p>
<h3 id="什么使-wasm-如此出色">什么使 Wasm 如此出色？</h3>
<p>一些使 Wasm 在浏览器中出色的功能也使其对服务器端开发非常有吸引力：</p>
<p>🌐 开放 - 它是行业广泛采用的标准。与过去的浏览器之争不同，主要公司正在协作标准化 WASI 和 WebAssembly 应用程序。</p>
<p>🚀 快速 - 它可以通过大多数运行时的 JIT/AOT 能力提供类似本机的速度。不像启动 VM 或启动容器那样有冷启动。</p>
<p>🔒 安全 - Wasm 运行时默认情况下是隔离的，并允许安全地访问内存。基于能力的模型确保 Wasm 应用程序仅能访问其明确允许的内容。安全的供应链。</p>
<p>💼 可移植 - 在几个主要运行时中，支持大多数 CPU（x86、ARM、RISC-V）和大多数操作系统，包括 Linux、Windows、macOS、Android、ESXi，甚至非 POSIX 的操作系统。</p>
<p>🔋 高效 - Wasm 应用程序可以通过最小的内存占用和 CPU 要求运行。</p>
<p>🗣️ 多语言支持 - 40 多种语言可以编译为 Wasm，并具有现代的、不断改进的工具链。</p>
<h3 id="服务器平台演进的下一步">服务器平台演进的下一步？</h3>
<p>您可能已经看到过 Docker 的共同创始人之一 Solomon Hykes 的这段 <a href="https://twitter.com/solomonstre/status/1111004913222324225" target="_blank" rel="noopener">引述</a>：</p>
<blockquote>
<p>如果 WASM+WASI 在 2008 年存在，我们就不需要创建 Docker 了。这就是它的重要性。WebAssembly 在服务器上是计算的未来。</p>
</blockquote>
<p>确实，WASM+WASI 似乎是服务器端软件基础架构演进的下一步。</p>
<ul>
<li>在过去，我们有物理硬件可用。我们会在每个盒子上仔细安装操作系统和应用程序，并逐个维护它们。</li>
<li>然后，随着由 VMware 开创的 VM 的采用，事情变得更容易了。人们可以复制、克隆和移动 VM 跨硬件盒。但这仍然需要在 VM 中安装操作系统和应用程序。</li>
<li>然后，容器出现了，由 Docker 推广，它使得在极简的包装上下文中运行应用程序配置变得更加容易，而不会影响主机操作系统上的任何其他应用程序。然而，这仍然需要分发应用程序与其运行时和必要的库捆绑在一起。安全边界由 Linux 内核提供。</li>
<li>我们现在有了 WebAssembly。它的技术特点和可移植性使得分发应用程序变得可能，无需运输 OS 级别的依赖项，并且可以在严格的安全约束下运行。</li>
</ul>
<p>考虑到所有这些，开发人员通常会将 WebAssembly 视为容器的“继承者”和基础架构部署的下一个逻辑步骤。</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/docker-without-containers/4_hu9788ea4c0c901b7b2eb7d58fbe5dad83_10584_f43c822b68d570a7b5779e3c139e0dae.webp 400w,
               /blog/docker-without-containers/4_hu9788ea4c0c901b7b2eb7d58fbe5dad83_10584_4b074fec995ab7c24c2c089476791611.webp 760w,
               /blog/docker-without-containers/4_hu9788ea4c0c901b7b2eb7d58fbe5dad83_10584_1200x1200_fit_q75_h2_lanczos_2.webp 1200w"
               src="/blog/docker-without-containers/4_hu9788ea4c0c901b7b2eb7d58fbe5dad83_10584_f43c822b68d570a7b5779e3c139e0dae.webp"
               width="757"
               height="212"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>然而，另一种看待 WebAssembly 的方式是作为 Docker 工具链的替代“后端”。您可以使用相同的命令行工具和工作流程，但是，而不是使用 Linux 容器，它是使用基于 WebAssembly 的容器等价物实现的。本文的其余部分探讨了这个概念，这就是我们所说的“没有容器的 Docker”标题。</p>
<h3 id="wasm-如何与-docker-配合使用">Wasm 如何与 Docker 配合使用？</h3>
<p>Docker Desktop 现在包括对 WebAssembly 的支持。它是使用一个称为 <a href="https://github.com/WasmEdge/Wasmedge" target="_blank" rel="noopener">WasmEdge</a> 的 Wasm 运行时运行 Wasm 应用程序的 containerd shim 实现的。这意味着，与运行容器镜像中的二进制文件的单独进程不同，您现在可以在 WasmEdge 运行时中运行 Wasm 应用程序，模拟容器。</p>
<p>因此，容器镜像不需要包含正在运行的应用程序的 OS 或运行时上下文——单个 Wasm 二进制文件就足够了。</p>
<p>这在 Docker 的 <a href="https://www.docker.com/blog/docker-wasm-technical-preview/" target="_blank" rel="noopener">Wasm 技术预览文章</a> 中有详细说明。</p>
<h3 id="什么是-wasmedge">什么是 WasmEdge？</h3>
<p><a href="https://github.com/WasmEdge/Wasmedge" target="_blank" rel="noopener">WasmEdge</a> 是一个高性能的 WebAssembly 运行时，具有以下特点：</p>
<ul>
<li>是开源的，是 <a href="https://cncf.io/" target="_blank" rel="noopener">CNCF</a> 的一部分。</li>
<li>支持所有主要的 CPU 架构（x86、ARM、RISC-V）。</li>
<li>支持所有主要的操作系统（Linux、Windows、macOS），以及其他操作系统，如 seL4 RTOS、Android。</li>
<li>为云原生和 Edge 应用程序进行了优化。</li>
<li>是可扩展的，支持标准和新兴技术
<ul>
<li>与 Tensorflow、OpenVINO、PyTorch 一起进行 AI 推理</li>
<li>支持使用 Tokio 进行异步网络。支持微服务、数据库客户端、消息队列等。</li>
<li>与容器生态系统、Docker 和 Kubernetes 完美集成（正如本文所示！）</li>
</ul>
</li>
</ul>
<h3 id="解释性语言呢">解释性语言呢？</h3>
<p>到目前为止，我们只提到了编译语言（如 C 和 Rust）可以针对 WebAssembly。对于解释性语言（如 Python、Ruby 和 PHP），方法是不同的：它们的解释器是用 C 编写的，可以编译为 WebAssembly。然后，这个解释器编译为 Wasm，可以用于执行源代码文件，通常以 .py、.rb、.php 等结尾。一旦编译为 Wasm，任何具有 Wasm 运行时的平台都将能够运行那些解释性语言，即使实际的解释器从未原生地编译为该平台。</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/docker-without-containers/5_hu5a9157eb590a188a516bf31fcc5f6574_17576_7f5852950c743a00a2c16df966ee1ae5.webp 400w,
               /blog/docker-without-containers/5_hu5a9157eb590a188a516bf31fcc5f6574_17576_e9524f19de783d7048ab3fdd930fe98c.webp 760w,
               /blog/docker-without-containers/5_hu5a9157eb590a188a516bf31fcc5f6574_17576_1200x1200_fit_q75_h2_lanczos_2.webp 1200w"
               src="/blog/docker-without-containers/5_hu5a9157eb590a188a516bf31fcc5f6574_17576_7f5852950c743a00a2c16df966ee1ae5.webp"
               width="757"
               height="332"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<h2 id="实际演示">实际演示</h2>
<p>让我们开始吧！在实际演示中，我们将使用编译为 Wasm 的 PHP 解释器。我们将：</p>
<ul>
<li>构建一个 <a href="https://wasmlabs.dev/articles/docker-without-containers/#building-a-wasm-container" target="_blank" rel="noopener">Wasm 容器</a>。</li>
<li>比较 <a href="https://wasmlabs.dev/articles/docker-without-containers/#native-vs-wasm" target="_blank" rel="noopener">Wasm 和本地</a> 二进制文件。</li>
<li>比较 <a href="https://wasmlabs.dev/articles/docker-without-containers/#traditional-vs-wasm-containers" target="_blank" rel="noopener">传统和 Wasm</a> 容器。</li>
<li>展示了 <a href="https://wasmlabs.dev/articles/docker-without-containers/#wasm-portability" target="_blank" rel="noopener">Wasm 的可移植性</a>。</li>
</ul>
<h2 id="先决条件">先决条件</h2>
<p>如果您想在本地复制演示，您需要准备一些或全部以下内容的环境：</p>
<ul>
<li>WASI SDK - 从旧 C 代码构建 WebAssembly 应用程序</li>
<li>PHP - 为了进行本地 PHP 二进制文件比较</li>
<li>WasmEdge 运行时 - 运行 WebAssembly 应用程序</li>
<li>Docker Desktop + Wasm（在撰写本文时，可在 <a href="https://docs.docker.com/desktop/release-notes/#4150" target="_blank" rel="noopener">版本 4.15</a> 中稳定测试版中使用）以能够运行 Wasm 容器</li>
</ul>
<p>我们还利用了<a href="https://github.com/vmware-labs/webassembly-language-runtimes" target="_blank" rel="noopener">“Wasm 语言运行时”</a>存储库，该存储库提供了将 PHP 解释器构建为 WebAssembly 应用程序的方法。</p>
<p>您可以通过以下方式开始检查演示分支：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git clone --depth<span class="o">=</span><span class="m">1</span> -b php-wasmedge-demo <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   &lt;https://github.com/vmware-labs/webassembly-language-runtimes.git&gt; wlr-demo
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> wlr-demo
</span></span></code></pre></div><h2 id="构建一个-wasm-容器">构建一个 Wasm 容器</h2>
<p>首先，我们将展示如何构建一个类似于 PHP 解释器的基于 C 的应用程序。</p>
<p>构建过程使用 WASI-SDK 工具集。它包括一个可以构建为 wasm32-wasi 目标的 clang 编译器，以及实现在 WASI 上的基本 POSIX 系统调用接口的 wasi-libc。使用 WASI SDK，我们可以从 PHP 的 C 代码库构建 Wasm 模块。然后，我们只需要一个基于 scratch 的非常简单的 Dockerfile 就可以制作一个 OCI 镜像，该镜像可以使用 Docker+Wasm 运行。</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/docker-without-containers/6_hu09c3c81615d15c15b2c4990eab505366_7474_a770315ff19ee5fff595df258c944f44.webp 400w,
               /blog/docker-without-containers/6_hu09c3c81615d15c15b2c4990eab505366_7474_31643b73bf31a881706d6cab275b27f8.webp 760w,
               /blog/docker-without-containers/6_hu09c3c81615d15c15b2c4990eab505366_7474_1200x1200_fit_q75_h2_lanczos_2.webp 1200w"
               src="/blog/docker-without-containers/6_hu09c3c81615d15c15b2c4990eab505366_7474_a770315ff19ee5fff595df258c944f44.webp"
               width="757"
               height="212"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<h3 id="构建-wasm-二进制文件">构建 WASM 二进制文件</h3>
<p>假设你在 <code>wlr-demo</code> 文件夹中，你可以运行以下命令来构建 Wasm 二进制文件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">WASI_SDK_ROOT</span><span class="o">=</span>/opt/wasi-sdk/
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">WASMLABS_RUNTIME</span><span class="o">=</span>wasmedge
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">./wl-make.sh php/php-7.4.32/ <span class="o">&amp;&amp;</span> tree build-output/php/php-7.4.32/bin/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">... <span class="o">(</span> a few minutes and hundreds of build log lines<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">build-output/php/php-7.4.32/bin/
</span></span><span class="line"><span class="cl">├── php-cgi-wasmedge
</span></span><span class="line"><span class="cl">└── php-wasmedge
</span></span></code></pre></div><p>PHP 是使用 <em>autoconf</em> 和 <em>make</em> 构建的。因此，如果你查看 <code>scripts/wl-build.sh</code> 脚本，你会注意到我们设置了所有相关变量，如 <code>CC</code>、<code>LD</code>、<code>CXX</code> 等，以使用来自 WASI_SDK 的编译器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">WASI_SYSROOT</span><span class="o">=</span><span class="s2">&#34;</span><span class="si">${</span><span class="nv">WASI_SDK_ROOT</span><span class="si">}</span><span class="s2">/share/wasi-sysroot&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CC</span><span class="o">=</span><span class="si">${</span><span class="nv">WASI_SDK_ROOT</span><span class="si">}</span>/bin/clang
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">LD</span><span class="o">=</span><span class="si">${</span><span class="nv">WASI_SDK_ROOT</span><span class="si">}</span>/bin/wasm-ld
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CXX</span><span class="o">=</span><span class="si">${</span><span class="nv">WASI_SDK_ROOT</span><span class="si">}</span>/bin/clang++
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">NM</span><span class="o">=</span><span class="si">${</span><span class="nv">WASI_SDK_ROOT</span><span class="si">}</span>/bin/llvm-nm
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">AR</span><span class="o">=</span><span class="si">${</span><span class="nv">WASI_SDK_ROOT</span><span class="si">}</span>/bin/llvm-ar
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">RANLIB</span><span class="o">=</span><span class="si">${</span><span class="nv">WASI_SDK_ROOT</span><span class="si">}</span>/bin/llvm-ranlib
</span></span></code></pre></div><p>然后，进一步研究 <code>php/php-7.4.32/wl-build.sh</code>，你可以看到我们像往常一样使用 <em>autoconf</em> 构建过程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">./configure --host<span class="o">=</span>wasm32-wasi <span class="nv">host_alias</span><span class="o">=</span>wasm32-musl-wasi <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   --target<span class="o">=</span>wasm32-wasi <span class="nv">target_alias</span><span class="o">=</span>wasm32-musl-wasi <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   <span class="si">${</span><span class="nv">PHP_CONFIGURE</span><span class="si">}</span> <span class="o">||</span> <span class="nb">exit</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">make -j <span class="si">${</span><span class="nv">MAKE_TARGETS</span><span class="si">}</span> <span class="o">||</span> <span class="nb">exit</span> <span class="m">1</span>
</span></span></code></pre></div><p>WASI 还在不断发展，许多 POSIX 调用仍然无法在其上实现。因此，为了构建 PHP，我们不得不在原始代码库的基础上应用几个补丁。</p>
<p>我们在上面看到了输出二进制文件到 <code>build-output/php/php-7.4.32</code>。在接下来的例子中，我们将使用专门为 WasmEdge 构建的 <code>php-wasmedge</code> 二进制文件，因为它提供了服务器端套接字支持，这还不是 WASI 的一部分。</p>
<h3 id="优化二进制文件">优化二进制文件</h3>
<p>Wasm 是一种虚拟指令集，因此任何运行时的默认行为都是实时解释这些指令。当然，在某些情况下这可能会使事情变慢。因此，为了在 WasmEdge 中获得最佳性能，您可以创建一个 AOT（ahead-of-time）优化二进制文件，该文件在当前机器上本地运行，但仍可以在其他机器上解释。</p>
<p>要创建该优化二进制文件，请运行以下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">wasmedgec --enable-all --optimize <span class="m">3</span> <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   build-output/php/php-7.4.32/bin/php-wasmedge <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   build-output/php/php-7.4.32/bin/php-wasmedge-aot
</span></span></code></pre></div><p>我们将在以下示例中使用此 <code>build-output/php/php-7.4.32/bin/php-wasmedge-aot</code> 二进制文件。要了解有关 WasmEdge AOT 优化二进制文件的更多信息，请查看 <a href="https://wasmlabs.dev/articles/docker-without-containers/build-output/php/php-7.4.32/bin/php-wasmedge-aot" target="_blank" rel="noopener">此处</a>。</p>
<h3 id="构建-oci-镜像">构建 OCI 镜像</h3>
<p>现在我们有了二进制文件，我们可以将其包装在 OCI 镜像中。</p>
<p>让我们来看看 <code>images/php/Dockerfile.cli</code>。我们只需要复制 Wasm 二进制文件并将其设置为 <code>ENTRYPOINT</code> 就可以了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> scratch</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ARG</span> <span class="nv">PHP_TAG</span><span class="o">=</span>php-7.4.32<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ARG</span> <span class="nv">PHP_BINARY</span><span class="o">=</span>php
</span></span><span class="line"><span class="cl"><span class="k">COPY</span> build-output/php/<span class="si">${</span><span class="nv">PHP_TAG</span><span class="si">}</span>/bin/<span class="si">${</span><span class="nv">PHP_BINARY</span><span class="si">}</span> /php.wasm<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENTRYPOINT</span> <span class="p">[</span> <span class="s2">&#34;php.wasm&#34;</span> <span class="p">]</span><span class="err">
</span></span></span></code></pre></div><p>我们还可以向镜像添加更多内容，当 Wasm 二进制文件在 Docker 中运行时，这些内容将可访问。例如，在 <code>images/php/Dockerfile.server</code> 中，我们还添加了一些 docroot 内容，以便在容器启动时由 <code>php.wasm</code> 服务。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> scratch</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ARG</span> <span class="nv">PHP_TAG</span><span class="o">=</span>php-7.4.32<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ARG</span> <span class="nv">PHP_BINARY</span><span class="o">=</span>php
</span></span><span class="line"><span class="cl"><span class="k">COPY</span> build-output/php/<span class="si">${</span><span class="nv">PHP_TAG</span><span class="si">}</span>/bin/<span class="si">${</span><span class="nv">PHP_BINARY</span><span class="si">}</span> /php.wasm<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> images/php/docroot /docroot<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENTRYPOINT</span> <span class="p">[</span> <span class="s2">&#34;php.wasm&#34;</span> <span class="p">,</span> <span class="s2">&#34;-S&#34;</span><span class="p">,</span> <span class="s2">&#34;0.0.0.0:8080&#34;</span><span class="p">,</span> <span class="s2">&#34;-t&#34;</span><span class="p">,</span> <span class="s2">&#34;/docroot&#34;</span><span class="p">]</span><span class="err">
</span></span></span></code></pre></div><p>基于上述文件，我们可以轻松地在本地构建我们的 <code>php-wasm</code> 镜像。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker build --build-arg <span class="nv">PHP_BINARY</span><span class="o">=</span>php-wasmedge-aot -t ghcr.io/vmware-labs/php-wasm:7.4.32-cli-aot -f images/php/Dockerfile.cli .
</span></span><span class="line"><span class="cl">docker build --build-arg <span class="nv">PHP_BINARY</span><span class="o">=</span>php-wasmedge-aot -t ghcr.io/vmware-labs/php-wasm:7.4.32-server-aot -f images/php/Dockerfile.server .
</span></span></code></pre></div><h2 id="原生-vs-wasm">原生 vs Wasm</h2>
<p>现在让我们将原生 PHP 二进制文件与 Wasm 二进制文件进行比较。在本地和 Docker 容器中都使用相同的 <code>index.php</code> 文件运行它，并比较我们运行它时得到的结果：</p>
<ul>
<li><code>php</code>,</li>
<li><code>php-wasmedge-aot</code>,</li>
<li>传统容器中的 <code>php</code>,</li>
<li>Wasm 容器中的 <code>php-wasmedge-aot</code>。</li>
</ul>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/docker-without-containers/7_huf174193c110986bd0ba7a4ddc91dc46e_15602_0537e3890ca0221fc322322dcfdb21fb.webp 400w,
               /blog/docker-without-containers/7_huf174193c110986bd0ba7a4ddc91dc46e_15602_ee61058e8d23d35fa7aa788a8b3d3bc4.webp 760w,
               /blog/docker-without-containers/7_huf174193c110986bd0ba7a4ddc91dc46e_15602_1200x1200_fit_q75_h2_lanczos_2.webp 1200w"
               src="/blog/docker-without-containers/7_huf174193c110986bd0ba7a4ddc91dc46e_15602_0537e3890ca0221fc322322dcfdb21fb.webp"
               width="757"
               height="326"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>在以下所有示例中，我们都使用相同的 <code>images/php/docroot/index.php</code> 文件，因此让我们来看看。简而言之，此脚本将：</p>
<ul>
<li>使用 <code>phpversion</code> 和 <code>php_uname</code> 显示解释器版本和正在运行的平台</li>
<li>打印脚本可以访问的所有环境变量的名称</li>
<li>使用当前时间和日期打印一个 hello 消息</li>
<li>列出根目录 <code>/</code> 的内容</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello from PHP <span class="cp">&lt;?php echo phpversion() ?&gt;</span> running on &#34;<span class="cp">&lt;?php echo php_uname()?&gt;</span>&#34;<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span>List env variable names<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="cp">&lt;?php
</span></span></span><span class="line"><span class="cl"><span class="cp">$php_env_vars_count = count(getenv());
</span></span></span><span class="line"><span class="cl"><span class="cp">echo &#34;Running with $php_env_vars_count environment variables:\\n&#34;;
</span></span></span><span class="line"><span class="cl"><span class="cp">foreach (getenv() as $key =&gt; $value) {
</span></span></span><span class="line"><span class="cl"><span class="cp">    echo  $key . &#34; &#34;;
</span></span></span><span class="line"><span class="cl"><span class="cp">}
</span></span></span><span class="line"><span class="cl"><span class="cp">echo &#34;\\n&#34;;
</span></span></span><span class="line"><span class="cl"><span class="cp">?&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span>Hello<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="cp">&lt;?php
</span></span></span><span class="line"><span class="cl"><span class="cp">$date = getdate();
</span></span></span><span class="line"><span class="cl"><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">$message = &#34;Today, &#34; . $date[&#39;weekday&#39;] . &#34;, &#34; . $date[&#39;year&#39;] . &#34;-&#34; . $date[&#39;mon&#39;] . &#34;-&#34; . $date[&#39;mday&#39;];
</span></span></span><span class="line"><span class="cl"><span class="cp">$message .= &#34;, at &#34; . $date[&#39;hours&#39;] . &#34;:&#34; . $date[&#39;minutes&#39;] . &#34;:&#34; . $date[&#39;seconds&#39;];
</span></span></span><span class="line"><span class="cl"><span class="cp">$message .= &#34; we greet you with this message!\\n&#34;;
</span></span></span><span class="line"><span class="cl"><span class="cp">echo $message;
</span></span></span><span class="line"><span class="cl"><span class="cp">?&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span>Contents of &#39;/&#39;<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="cp">&lt;?php
</span></span></span><span class="line"><span class="cl"><span class="cp">foreach (array_diff(scandir(&#39;/&#39;), array(&#39;.&#39;, &#39;..&#39;)) as $key =&gt; $value) {
</span></span></span><span class="line"><span class="cl"><span class="cp">    echo  $value . &#34; &#34;;
</span></span></span><span class="line"><span class="cl"><span class="cp">}
</span></span></span><span class="line"><span class="cl"><span class="cp">echo &#34;\\n&#34;;
</span></span></span><span class="line"><span class="cl"><span class="cp">?&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</span></span></code></pre></div><h3 id="原生运行-indexphp-的-php">原生运行 index.php 的 PHP</h3>
<p>当我们使用原生的 <code>php</code> 二进制文件时，我们会看到</p>
<ul>
<li>基于 Linux 的平台</li>
<li>脚本可以访问的 58 个环境变量列表（如果需要的话）</li>
<li><code>/</code> 中所有文件和文件夹的列表，这些都是脚本可以访问的</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ php -f images/php/docroot/index.php
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;html&gt;
</span></span><span class="line"><span class="cl">&lt;body&gt;
</span></span><span class="line"><span class="cl">&lt;h1&gt;Hello from PHP 7.4.3 running on <span class="s2">&#34;Linux alexandrov-z01 5.15.79.1-microsoft-standard-WSL2 #1 SMP Wed Nov 23 01:01:46 UTC 2022 x86_64&#34;</span>&lt;/h1&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;h2&gt;List env variable names&lt;/h2&gt;
</span></span><span class="line"><span class="cl">Running with <span class="m">58</span> environment variables:
</span></span><span class="line"><span class="cl">SHELL NVM_INC WSL2_GUI_APPS_ENABLED rvm_prefix WSL_DISTRO_NAME TMUX rvm_stored_umask TMUX_PLUGIN_MANAGER_PATH MY_RUBY_HOME NAME RUBY_VERSION PWD NIX_PROFILES LOGNAME rvm_version rvm_user_install_flag MOTD_SHOWN HOME LANG WSL_INTEROP LS_COLORS WASMTIME_HOME WAYLAND_DISPLAY NIX_SSL_CERT_FILE PROMPT_COMMAND NVM_DIR rvm_bin_path GEM_PATH GEM_HOME LESSCLOSE TERM CPLUS_INCLUDE_PATH LESSOPEN USER TMUX_PANE LIBRARY_PATH rvm_loaded_flag DISPLAY SHLVL NVM_CD_FLAGS LD_LIBRARY_PATH XDG_RUNTIME_DIR PS1 WSLENV XDG_DATA_DIRS PATH DBUS_SESSION_BUS_ADDRESS C_INCLUDE_PATH NVM_BIN HOSTTYPE WASMER_CACHE_DIR IRBRC PULSE_SERVER rvm_path WASMER_DIR OLDPWD BASH_FUNC_cr-open%% _
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;h2&gt;Hello&lt;/h2&gt;
</span></span><span class="line"><span class="cl">Today, Wednesday, 2022-12-14, at 12:0:36 we greet you with this message!
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;h2&gt;Contents of <span class="s1">&#39;/&#39;</span>&lt;/h2&gt;
</span></span><span class="line"><span class="cl">apps bin boot dev docroot etc home init lib lib32 lib64 libx32 lost+found media mnt nix opt path proc root run sbin snap srv sys tmp usr var wsl.localhost
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;/body&gt;
</span></span><span class="line"><span class="cl">&lt;/html&gt;
</span></span></code></pre></div><h3 id="php-aot-wasm-运行-indexphp">php-aot-wasm 运行 index.php</h3>
<p>当我们使用<code>php-aot-wasm</code>与 Wasmedge 结合使用时，我们发现</p>
<ul>
<li>wasi/wasm32平台</li>
<li>没有环境变量，因为没有将任何环境变量显式暴露给 Wasm 应用程序</li>
<li>Wasm 应用程序没有被明确授权访问<code>/</code>，因此尝试列出其内容时会出现错误</li>
</ul>
<p>当然，要使<code>php-wasmedge-aot</code>可以访问读取<code>index.php</code>文件，我们必须明确说明我们想要预先打开<code>images/php/docroot</code>以便 WasmEdge 可以访问它作为 Wasm 应用程序上下文中的<code>/docroot</code>。</p>
<p>这很容易显示了 Wasm 除了可移植性之外的最大优点之一。我们获得了更好的安全性，因为除非明确说明，否则没有任何内容是可访问的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ wasmedge --dir /docroot:<span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/images/php/docroot <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   build-output/php/php-7.4.32/bin/php-wasmedge-aot -f /docroot/index.php
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;html&gt;
</span></span><span class="line"><span class="cl">&lt;body&gt;
</span></span><span class="line"><span class="cl">&lt;h1&gt;Hello from PHP 7.4.32 running on <span class="s2">&#34;wasi (none) 0.0.0 0.0.0 wasm32&#34;</span>&lt;/h1&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;h2&gt;List env variable names&lt;/h2&gt;
</span></span><span class="line"><span class="cl">Running with <span class="m">0</span> environment variables:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;h2&gt;Hello&lt;/h2&gt;
</span></span><span class="line"><span class="cl">Today, Wednesday, 2022-12-14, at 10:8:46 we greet you with this message!
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;h2&gt;Contents of <span class="s1">&#39;/&#39;</span>&lt;/h2&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Warning: scandir<span class="o">(</span>/<span class="o">)</span>: failed to open dir: Capabilities insufficient in /docroot/index.php on line <span class="m">27</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Warning: scandir<span class="o">()</span>: <span class="o">(</span>errno 76<span class="o">)</span>: Capabilities insufficient in /docroot/index.php on line <span class="m">27</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Warning: array_diff<span class="o">()</span>: Expected parameter <span class="m">1</span> to be an array, bool given in /docroot/index.php on line <span class="m">27</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Warning: Invalid argument supplied <span class="k">for</span> foreach<span class="o">()</span> in /docroot/index.php on line <span class="m">27</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;/body&gt;
</span></span><span class="line"><span class="cl">&lt;/html&gt;
</span></span></code></pre></div><h3 id="容器中运行-indexphp-的-php">容器中运行 index.php 的 PHP</h3>
<p>当我们使用传统容器中的“php”时，我们会看到</p>
<ul>
<li>基于 Linux 的平台</li>
<li>脚本具有访问权限的 14 个环境变量列表</li>
<li>带有当前时间和日期的问候消息</li>
<li>根文件夹<code>/</code>的内容列表</li>
</ul>
<p>与在主机上使用“php”的情况相比，这已经有所改善。由于环境变量和<code>/</code>的内容是“虚拟”的，因此仅存在于容器内。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run --rm <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   -v <span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/images/php/docroot:/docroot <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   php:7.4.32-cli <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   php -f /docroot/index.php
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;html&gt;
</span></span><span class="line"><span class="cl">&lt;body&gt;
</span></span><span class="line"><span class="cl">&lt;h1&gt;Hello from PHP 7.4.32 running on <span class="s2">&#34;Linux 227b2bc2f611 5.15.79.1-microsoft-standard-WSL2 #1 SMP Wed Nov 23 01:01:46 UTC 2022 x86_64&#34;</span>&lt;/h1&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;h2&gt;List env variable names&lt;/h2&gt;
</span></span><span class="line"><span class="cl">Running with <span class="m">14</span> environment variables:
</span></span><span class="line"><span class="cl">HOSTNAME PHP_INI_DIR HOME PHP_LDFLAGS PHP_CFLAGS PHP_VERSION GPG_KEYS PHP_CPPFLAGS PHP_ASC_URL PHP_URL PATH PHPIZE_DEPS PWD PHP_SHA256
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;h2&gt;Hello&lt;/h2&gt;
</span></span><span class="line"><span class="cl">Today, Wednesday, 2022-12-14, at 10:15:35 we greet you with this message!
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;h2&gt;Contents of <span class="s1">&#39;/&#39;</span>&lt;/h2&gt;
</span></span><span class="line"><span class="cl">bin boot dev docroot etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;/body&gt;
</span></span><span class="line"><span class="cl">&lt;/html&gt;
</span></span></code></pre></div><h3 id="容器中运行-indexphp-的-php-aot-wasm">容器中运行 index.php 的 php-aot-wasm</h3>
<p>当我们使用<code>php-aot-wasm</code>与 Wasmedge 结合使用时，我们发现</p>
<ul>
<li>wasi / wasm32 平台</li>
<li>只有 2 个基础架构环境变量，使用运行在 containerd 中的 WasmEdge shim 预设</li>
<li>显示了容器中<code>/</code>中的所有文件和文件夹的列表，这是 Wasm 应用程序明确预先打开以便访问的（WasmEdge shim 中的逻辑的一部分）</li>
</ul>
<p>注意：如果您更加细心，您将会看到为了从此镜像运行容器，我们必须：</p>
<ul>
<li>通过<code>runtime=io.containerd.wasmedge.v1</code>明确地指定运行时</li>
<li>直接传递命令行参数到<code>php.wasm</code>，而不包括二进制文件本身。向上滚动并查看传统 PHP 容器，包括<code>php</code>二进制文件（并不是必要的）。</li>
</ul>
<p>最后，即使是在 Docker 中，Wasm 也加强了运行 index.php 的安全性，因为暴露给它的东西要少得多。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run --rm <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   --runtime<span class="o">=</span>io.containerd.wasmedge.v1 <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   -v <span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/images/php/docroot:/docroot <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   ghcr.io/vmware-labs/php-wasm:7.4.32-cli-aot <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   -f /docroot/index.php
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;html&gt;
</span></span><span class="line"><span class="cl">&lt;body&gt;
</span></span><span class="line"><span class="cl">&lt;h1&gt;Hello from PHP 7.4.32 running on <span class="s2">&#34;wasi (none) 0.0.0 0.0.0 wasm32&#34;</span>&lt;/h1&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;h2&gt;List env variable names&lt;/h2&gt;
</span></span><span class="line"><span class="cl">Running with <span class="m">2</span> environment variables:
</span></span><span class="line"><span class="cl">PATH HOSTNAME
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;h2&gt;Hello&lt;/h2&gt;
</span></span><span class="line"><span class="cl">Today, Wednesday, 2022-12-14, at 11:33:10 we greet you with this message!
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;h2&gt;Contents of <span class="s1">&#39;/&#39;</span>&lt;/h2&gt;
</span></span><span class="line"><span class="cl">docroot etc php.wasm
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;/body&gt;
</span></span><span class="line"><span class="cl">&lt;/html&gt;
</span></span></code></pre></div><h2 id="传统容器与-wasm-容器">传统容器与 wasm 容器</h2>
<p>我们成功地构建和运行了一个 Wasm 二进制文件，并将其作为容器运行。我们看到了 Wasm 容器和传统容器之间的输出差异以及 Wasm 带来的高级“沙盒”性能。让我们看看我们可以轻松看到的两种容器类型之间的其他差异。</p>
<p>首先，我们将运行两个守护程序容器，并查看如何解释有关它们的一些统计信息。然后，我们将检查容器镜像中的差异。</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/docker-without-containers/8_hua853562afea5ac88706362ca3bdf32f6_18506_f23dfaa3d922c2d1dab5e70606f287d5.webp 400w,
               /blog/docker-without-containers/8_hua853562afea5ac88706362ca3bdf32f6_18506_98aca8d6a0624071b11809e6800b3ca9.webp 760w,
               /blog/docker-without-containers/8_hua853562afea5ac88706362ca3bdf32f6_18506_1200x1200_fit_q75_h2_lanczos_2.webp 1200w"
               src="/blog/docker-without-containers/8_hua853562afea5ac88706362ca3bdf32f6_18506_f23dfaa3d922c2d1dab5e70606f287d5.webp"
               width="757"
               height="465"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<h3 id="容器统计">容器统计</h3>
<p>我们将运行两个守护程序容器 - 一个来自传统的<code>php</code>镜像，另一个来自<code>php-wasm</code>镜像。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run --rm -d <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   -p 8083:8080 -v <span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/images/php/docroot:/docroot <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   php:7.4.32-cli <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   -S 0.0.0.0:8080 -t /docroot
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run --rm -d <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   --runtime<span class="o">=</span>io.containerd.wasmedge.v1 <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   -p 8082:8080 -v <span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/images/php/docroot:/docroot <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   ghcr.io/vmware-labs/php-wasm:7.4.32-cli-aot
</span></span><span class="line"><span class="cl">   -S 0.0.0.0:8080 -t /docroot
</span></span></code></pre></div><p>但是，如果我们查看<code>docker stats</code>，我们将只看到传统容器的统计信息。由于 Docker+Wasm 是 beta 功能，这可能会发生变化。因此，如果想要查看正在发生的情况，可以监视控制组。每个传统容器都有自己的控制组，如<code>docker/ee44...</code>所示。另一方面，Wasm 容器包含在<code>podruntime/docker</code>控制组中，您可以间接观察它们的 CPU 或内存消耗。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ systemd-cgtop -kP --depth<span class="o">=</span><span class="m">10</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Control Group           Tasks    %CPU     Memory
</span></span><span class="line"><span class="cl">podruntime              <span class="m">145</span>      0.1      636.3M
</span></span><span class="line"><span class="cl">podruntime/docker       <span class="m">145</span>      0.1      636.3M
</span></span><span class="line"><span class="cl">docker                  <span class="m">2</span>        0.0      39.7M
</span></span><span class="line"><span class="cl">docker/ee444b...        <span class="m">1</span>        0.0      6.7M
</span></span></code></pre></div><h3 id="镜像大小">镜像大小</h3>
<p>首先，探索镜像时，我们会发现 Wasm 容器镜像比传统容器镜像小得多。即使是“php”容器的<code>alpine</code>版本也比 Wasm 容器大。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker images
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">REPOSITORY                     TAG                 IMAGE ID       CREATED          SIZE
</span></span><span class="line"><span class="cl">php                            7.4.32-cli          680c4ba36f1b   <span class="m">2</span> hours ago      166MB
</span></span><span class="line"><span class="cl">php                            7.4.32-cli-alpine   a785f7973660   <span class="m">2</span> minutes ago    30.1MB
</span></span><span class="line"><span class="cl">ghcr.io/vmware-labs/php-wasm   7.4.32-cli-aot      63460740f6d5   <span class="m">44</span> minutes ago   5.35MB
</span></span></code></pre></div><p>这是因为使用 Wasm 时，我们只需要将可执行二进制文件放入容器中，而传统容器还需要一些来自操作系统的基本库和文件。</p>
<p>这种大小上的差异对第一次拉取镜像的速度以及镜像在本地仓库中所占用的空间都有很大的益处。</p>
<h2 id="wasm-的可移植性">Wasm 的可移植性</h2>
<p>Wasm 最好的一点就是可移植性。当我们想要一个可移植的应用程序时，Docker 已经成为了传统容器的首选。然而，除了镜像大小之外，传统容器还绑定在它们运行的平台的架构上。我们中的许多人都经历过为支持不同架构构建软件的版本并将其打包到每个架构的不同镜像中的起伏。</p>
<p>WebAssembly 带来了真正的可移植性。您可以编译一次二进制文件并在任何地方运行它。为了证明这种可移植性，我们准备了几个示例，演示了如何通过我们为 WebAssembly 构建的 PHP 解释器运行 WordPress。</p>
<p>当它以独立的 Wasm 应用程序运行时，PHP 将为 WordPress 提供服务。同样地，它也可以在 Docker+Wasm 容器中运行。它还可以在嵌入 Wasm 运行时的任何应用程序中运行。在我们的示例中，这是 apache httpd，它通过 mod_wasm 可以将 Wasm 应用程序用作内容处理程序。最后，PHP.wasm 也可以在浏览器中运行。</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/docker-without-containers/9_huccfef052a73a2282fb41a9c8da0ded43_16880_012759d24c78f85dcb3ca47051f55c95.webp 400w,
               /blog/docker-without-containers/9_huccfef052a73a2282fb41a9c8da0ded43_16880_1118ab866415ad1a44cd869277461e8c.webp 760w,
               /blog/docker-without-containers/9_huccfef052a73a2282fb41a9c8da0ded43_16880_1200x1200_fit_q75_h2_lanczos_2.webp 1200w"
               src="/blog/docker-without-containers/9_huccfef052a73a2282fb41a9c8da0ded43_16880_012759d24c78f85dcb3ca47051f55c95.webp"
               width="757"
               height="308"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<h3 id="通过-wasmedge-提供-wordpress">通过 WasmEdge 提供 WordPress</h3>
<p>我们为此演示准备了一个紧凑的 WordPress+Sqlite 示例。由于它是 <code>ghcr.io/vmware-labs/php-wasm:7.4.32-server-wordpress</code> 容器映像的一部分，因此让我们首先将其下载到本地。</p>
<p>这条命令只会创建一个临时容器（拉取镜像），将 WordPress 文件复制到 <code>/tmp/wp/docroot</code> 中，然后删除容器。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">container_id</span><span class="o">=</span><span class="k">$(</span>docker create ghcr.io/vmware-labs/php-wasm:7.4.32-server-wordpress<span class="k">)</span> <span class="o">&amp;&amp;</span> <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   mkdir /tmp/wp <span class="o">&amp;&amp;</span> <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   docker cp <span class="nv">$container_id</span>:/docroot /tmp/wp/ <span class="o">&amp;&amp;</span> <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   docker rm <span class="nv">$container_id</span>
</span></span></code></pre></div><p>现在我们有了 WordPress，让我们使用以下命令提供服务：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">wasmedge --dir /docroot:/tmp/wp/docroot <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   build-output/php/php-7.4.32/bin/php-wasmedge-aot <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   -S 0.0.0.0:8085 -t /docroot
</span></span></code></pre></div><p>您可以转到 <a href="http://localhost:8085/" target="_blank" rel="noopener">http://localhost:8085</a> 并享受由 PHP Wasm 解释器提供的 WordPress。</p>
<h3 id="通过-dockerwasm-提供-wordpress">通过 Docker+Wasm 提供 WordPress</h3>
<p>当然，使用 Docker，事情要简单得多。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run --rm --runtime<span class="o">=</span>io.containerd.wasmedge.v1 <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   -p 8086:8080 -v /tmp/wp/docroot/:/docroot/ <span class="se">\\</span>
</span></span><span class="line"><span class="cl">   ghcr.io/vmware-labs/php-wasm:7.4.32-cli-aot
</span></span><span class="line"><span class="cl">   -S 0.0.0.0:8080 -t /docroot
</span></span></code></pre></div><p>您可以转到 <a href="http://localhost:8086/" target="_blank" rel="noopener">http://localhost:8086</a> 并享受由 PHP Wasm 解释器提供的 WordPress，这一次它在 Docker 容器中运行。</p>
<h3 id="通过-apache-httpd-中的-mod_wasm-提供-wordpress">通过 Apache HTTPD 中的 mod_wasm 提供 WordPress</h3>
<p>Apache HTTPD 是最广泛使用的 HTTP 服务器之一。现在，通过 mod_wasm，它也可以运行 WebAssembly 应用程序。为了避免在本地安装和配置它，我们准备了一个容器，其中包含 Apache HTTPD、mod_wasm 和 WordPress。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run -p 8087:8080 projects.registry.vmware.com/wasmlabs/containers/php-mod-wasm:wordpress
</span></span></code></pre></div><p>您可以转到 <a href="http://localhost:8087/" target="_blank" rel="noopener">http://localhost:8087</a> 并享受由 Apache HTTPD 中加载的 mod_wasm 提供的 PHP Wasm 解释器提供的 WordPress。</p>
<h3 id="直接在浏览器中提供-wordpress">直接在浏览器中提供 WordPress</h3>
<p>只需转到 [<a href="https://wordpress.wasmlabs.dev/" target="_blank" rel="noopener">https://wordpress.wasmlabs.dev</a>] 查看示例。您将看到一个框架，其中 PHP Wasm 解释器正在现场渲染 WordPress。</p>
<h2 id="结论">结论</h2>
<p>感谢您阅读本文。这是很多内容要消化，但我们希望它有助于了解 WebAssembly 的功能以及它如何与您现有的代码库和工具（包括 Docker）一起使用。期待看到您使用 Wasm 构建的内容！</p>

                </div>
                

<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/webassembly/">WebAssembly</a>
  
  <a class="badge badge-light" href="/tag/docker/">Docker</a>
  
</div>











  
  
    



  
  
  
  
  
  <div class="media author-card content-widget-hr mb-4">
    

    <div class="media-body">
      <p class="card-title"><a href="/author/asen-alexandrov/">Asen Alexandrov</a></p>
      
      
      
    </div>
  </div>


  





<div class="article-widget">
  
<div class="container-xl row post-nav">
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1" href="/blog/osm-deprecated/" rel="next">
    <div class="meta-nav">下一页</div>
    <p>OSM（Open Service Mesh）项目将停止更新，团队将协力 Istio 服务网格开发</p></a>
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1"  href="/blog/observability-summit-2023-recap/" rel="prev">
    <div class="meta-nav">上一页</div>
    <p>可观测性峰会 2023 回顾及 PPT 下载</p></a>
  
</div>

</div>










  

<p class="edit-page">
  <a href="https://github.com/cloudnativeto/cloudnative.to/edit/master/content/blog/docker-without-containers/index.md">
    <i class="fas fa-pen pr-2"></i>编辑本页
  </a>
</p>




  
  
  <div class="article-widget content-widget-hr">
    <p class="related-title">相关推荐</p>
    <ul>
      
      <li><a href="/blog/docker-wasm-quick-intro/">用 Docker 和 WebAssembly 打造容器的新时代！</a></li>
      
      <li><a href="/blog/is-it-too-early-to-leverage-ai-for-webassembly/">将 AI 应用于 WebAssembly 还为时过早吗？</a></li>
      
      <li><a href="/blog/spin-wasm-ga/">初创公司 Fermyon 发布 Spin 1.0 用于 WebAssembly 无服务器应用</a></li>
      
      <li><a href="/blog/wasm-containers/">使用 OCI 容器运行 WebAssembly 工作负载</a></li>
      
      <li><a href="/blog/introducing-wazero-from-tetrate/">Tetrate 开源项目 Wazero 简介</a></li>
      
    </ul>
  </div>
  





  
  
  

  

  
  <section id="comments" class="mb-3 pt-0">
    <script>
  let themeNumber = localStorage.getItem('wcTheme');
  var giscusTheme = "light";
  if (themeNumber == 1){
    giscusTheme = "dark";
  }
  let giscusAttributes = {
    "src": "https://giscus.app/client.js",
    "data-theme": giscusTheme,
    "data-repo":"cloudnativeto\/cloudnative.to",
    "data-repo-id":"MDEwOlJlcG9zaXRvcnkyMzc3NDUxOTA=",
    "data-category":"General",
    "data-category-id":"MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMyMDU5MzUy",
    "data-mapping":"pathname",
    "data-reactions-enabled":"",
    "data-emit-metadata":"0",
    "data-input-position":"top",
    "data-theme":giscusTheme,
    "data-lang":"zh-CN",
    "data-loading":"lazy",
    "crossorigin":"annoymous",
    "origins":"https://cloudnative.to",
    "originsRegex":"http://localhost:[0-9]+",
    "async": "",
  };

  let giscusScript = document.createElement("script");
  Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
  document.querySelector('#comments').appendChild(giscusScript);
</script>

  </section>
  



            </article>
        </main>
    </div>
</div>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">

  



  

  
  <div class="copyright py-4 bg-footer">
      <div class="row justify-content-center">
        <div class="text-center footer-color">
          <p class="mb-0">© 2020-2024 云原生社区保留所有权利</p>
        </div>
    </div>
  </div>

</footer>

    </div>
    
  </div>

  


<script src="/js/vendor-bundle.min.b4708d4364577c16ab7001b265a063a4.js"></script>




  

  
  

  

  
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js" integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin="anonymous"></script>
    
    
  










  
  <script id="search-hit-fuse-template" type="text/x-template">
    <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <div class="article-metadata search-hit-type">{{relpermalink}}</div>
          <a href="{{relpermalink}}">{{title}}</a>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
    </div>
  </script>
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin="anonymous"></script>
  












  
  
  
  
  
  
  







<script id="page-data" type="application/json">{"use_headroom":false}</script>










  
  


<script src="/zh/js/wowchemy.min.86e72873b0cba69f752c6d2cadb023c6.js"></script>







<script>

var mybutton = document.getElementById("backTopBtn");


window.onscroll = function() {scrollFunction()};

function scrollFunction() {
  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    mybutton.style.display = "block";
  } else {
    mybutton.style.display = "none";
  }
}


function topFunction() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
<script>
  anchors.add();
</script>



<script>



(function() {
  'use strict';

  if(!document.queryCommandSupported('copy')) {
    return;
  }

  function flashCopyMessage(el, msg) {
    el.className = "highlight-copy-btn";
    el.textContent = msg;
    setTimeout(function() {
      el.textContent = "";
      el.className = "highlight-copy-btn fa fa-copy";
    }, 1000);
  }

  function selectText(node) {
    var selection = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
    return selection;
  }

  function addCopyButton(containerEl) {
    var copyBtn = document.createElement("button");
    copyBtn.className = "highlight-copy-btn fa fa-copy";
    copyBtn.textContent = "";

    var codeEl = containerEl.firstElementChild;
    copyBtn.addEventListener('click', function() {
      try {
        var selection = selectText(codeEl);
        document.execCommand('copy');
        selection.removeAllRanges();
        
        flashCopyMessage(copyBtn, '已复制')
        
      } catch(e) {
        console && console.log(e);
        flashCopyMessage(copyBtn, 'Failed :\'(')
      }
    });

    containerEl.appendChild(copyBtn);
  }

  
  var highlightBlocks = document.getElementsByClassName('highlight');
  Array.prototype.forEach.call(highlightBlocks, addCopyButton);
})();
</script>



<script>

function Collapse(e){
  var node = document.getElementById(e);
  if (node.className.indexOf('fa-angle-down') > -1){
    node.setAttribute("class", "fa-solid fa-angle-right");
    }else{
    node.setAttribute("class", "fa-solid fa-angle-down");
    }
}
</script>


</body>
</html>
