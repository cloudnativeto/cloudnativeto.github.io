<!DOCTYPE html><html lang="zh" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.5.0 for Hugo" />
  

  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
  

  

  
  
  
    
  
  <meta name="description" content="本文将对 Service Mesh 对外暴露服务的各种方式进行详细介绍和对比分析，并根据分析结果提出一个可用于产品部署的入口网关解决方案。" />

  
  <link rel="alternate" hreflang="zh" href="https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/" />

  
  
  
    <meta name="theme-color" content="#0a55a7" />
  

  
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css" media="print" onload="this.media='all'">

  
  
  
    
    

    
    
    
    
      
      
    
    
    

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      
        
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.008259417e6adf8980695ebbbb46553f.css" />

  



  


  


  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f3dc895ea3bd6186cd835841d365c103";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_hu0802e500a55b0406ddf0453824effa47_6997_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hu0802e500a55b0406ddf0453824effa47_6997_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/" />

  
  
  
  
  
  
  
  
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary_large_image" />
  
    <meta property="twitter:site" content="@CloudNativeCN" />
    <meta property="twitter:creator" content="@CloudNativeCN" />
  
  <meta property="og:site_name" content="云原生社区（中国）" />
  <meta property="og:url" content="https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/" />
  <meta property="og:title" content="如何为服务网格选择入口网关？ | 云原生社区（中国）" />
  <meta property="og:description" content="本文将对 Service Mesh 对外暴露服务的各种方式进行详细介绍和对比分析，并根据分析结果提出一个可用于产品部署的入口网关解决方案。" /><meta property="og:image" content="https://cloudnative.to/media/sharing.png" />
    <meta property="twitter:image" content="https://cloudnative.to/media/sharing.png" /><meta property="og:locale" content="zh" />
  
    
      <meta
        property="article:published_time"
        content="2019-05-15T12:23:01&#43;08:00"
      />
    
    <meta property="article:modified_time" content="2024-08-16T08:31:51&#43;08:00">
  

  


    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/"
  },
  "headline": "如何为服务网格选择入口网关？",
  
  "datePublished": "2019-05-15T12:23:01+08:00",
  "dateModified": "2024-08-16T08:31:51+08:00",
  
  "author": {
    "@type": "Person",
    "name": "赵化冰"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "云原生社区（中国）",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cloudnative.to/media/logo.svg"
    }
  },
  "description": "本文将对 Service Mesh 对外暴露服务的各种方式进行详细介绍和对比分析，并根据分析结果提出一个可用于产品部署的入口网关解决方案。"
}
</script>

  

  

  

  





  <title>如何为服务网格选择入口网关？ | 云原生社区（中国）</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="d13342e1d06e8c7efce8a1e7df9940a5" >
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden="true"></i></button>
  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.62d6f8dfe8493f1c68557dde65bec362.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6 search-title">
          <p>搜索</p>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="关闭"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="搜索..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="搜索...">
        
      </div>

      
      

      
    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

      <div id="search-common-queries">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    











  


<header class="header--fixed">
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区（中国）"
            
            ></a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="切换导航">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区（中国）"
          
          ></a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/community"><span>社区</span></a>
          </li>

          
          

          

          
          
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link  active" href="/blog"><span>博客</span></a>
          </li>

          
          

          
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>小组</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/k8s-gateway-api"><span>Kubernetes Gateway API SIG</span></a>
              
            </div>
          </li>

          
          

          
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>资料</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/envoy/"><span>Envoy 中文文档</span></a>
              
                <a class="dropdown-item" href="/kubebuilder/"><span>Kubebuilder 中文文档</span></a>
              
                <a class="dropdown-item" href="https://lib.jimmysong.io/"><span>云原生资料库</span></a>
              
                <a class="dropdown-item" href="https://istio.io/latest/zh/"><span>Istio 中文文档</span></a>
              
            </div>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/event"><span>活动</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#feed"><span>更新</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#tags"><span>标签</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#about"><span>关于</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        

        
        <li class="nav-item">
            <a class="nav-link" href="/community/join/" data-toggle="tooltip" data-placement="bottom" title="加入社区" aria-label="主站"><i class="fa-brands fa-weixin" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item">
            <a class="nav-link js-search" href="#" data-toggle="tooltip" data-placement="bottom" title="搜索" aria-label="搜索"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item d-none d-lg-inline-flex">
            <a class="nav-link" href="https://github.com/cloudnativeto/cloudnative.to" target="_blank" rel="noopener" data-toggle="tooltip" data-placement="bottom" title="查看源码" aria-label="查看源码" aria-label="GitHub"><i class="fa-brands fa-github" aria-hidden="true"></i></a>
        </li>
        

        
        
        
        <li class="nav-item">
          <a href="#" class="nav-link set-theme">
            <i class="fa fa-sun" aria-hidden="true" id="theme-icon"></i>
          </a>
        </li>
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    <div class="container-xl">
    <div class="post-container">
        












  

  
  
  
<div class="article-container pt-3">
  <h1>如何为服务网格选择入口网关？</h1>

  

  
    


<div class="article-metadata">

  <div>
  
  
  
  
    <i class="fa-solid fa-feather"></i>
    

  <span >
      <a href="/author/%E8%B5%B5%E5%8C%96%E5%86%B0/">赵化冰</a></span>
    
    <span class="middot-divider"></span>
    
  
  
  
  
  
  
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/category/service-mesh/" class="text-capitalize">service mesh</a></span>
  
  </div>

  
  <span class="article-date">
    
    
      
          
          发布于
      
    
    2019-05-15
  </span>
  

  

  
  <span class="middot-divider"></span>
  字数 6614
  <span class="middot-divider"></span>
  <span class="article-reading-time">
      阅读时长 30 分钟
  </span>
  

  
  
  
  

</div>

    





  
</div>


    </div>
    <div class="border-bottom mb-2"></div>
    <div class="row flex-xl-nowrap">
        <div class="col-3 d-none d-xl-block docs-toc">
            <!-- toc -->
            
<div class="">
    <ul class="nav toc-top">
        <li>
            <a href="#" id="back_to_top" class="docs-toc-title">目录</a>
        </li>
    </ul>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#内部服务间的通信">内部服务间的通信</a></li>
    <li><a href="#cluster-ip">Cluster IP</a>
      <ul>
        <li><a href="#userspace-模式">userspace 模式</a></li>
        <li><a href="#iptables-模式">iptables 模式</a></li>
        <li><a href="#ipvs-模式">ipvs 模式</a></li>
      </ul>
    </li>
    <li><a href="#istio-sidecar-proxy">Istio Sidecar Proxy</a></li>
  </ul>

  <ul>
    <li><a href="#nodeport">NodePort</a></li>
    <li><a href="#loadbalancer">LoadBalancer</a></li>
    <li><a href="#ingress">Ingress</a>
      <ul>
        <li><a href="#按-http-请求的-url-进行路由">按 HTTP 请求的 URL 进行路由</a></li>
        <li><a href="#按-http-请求的-host-进行路由">按 HTTP 请求的 Host 进行路由</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#k8s-ingress">K8s Ingress</a></li>
    <li><a href="#istio-gateway">Istio Gateway</a></li>
    <li><a href="#应用对-api-gateway-的需求">应用对 API Gateway 的需求</a></li>
    <li><a href="#采用-api-gateway--sidecar-proxy-作为服务网格的流量入口">采用 API Gateway + Sidecar Proxy 作为服务网格的流量入口</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
</div>

            <!-- /toc -->
            
            <div class="subscribe-module col-12 mt-1">
    <img src="/img/wechat.jpg" alt="image" title="云原生社区的微信公众号"/>
    <p class="text-center pt-1">关注「云原生社区动态」微信公众号，获取本站更新</p>
</div>

            
        </div>
        <main class="article-body col-9 container docs-content" role="main">
            <article class="article">
                <div class="article-style">
                    
                    <details class="toc-inpage d-print-none d-show-block mb-0">
  <summary class="font-weight-bold">点击查看目录</summary>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#内部服务间的通信">内部服务间的通信</a></li>
    <li><a href="#cluster-ip">Cluster IP</a>
      <ul>
        <li><a href="#userspace-模式">userspace 模式</a></li>
        <li><a href="#iptables-模式">iptables 模式</a></li>
        <li><a href="#ipvs-模式">ipvs 模式</a></li>
      </ul>
    </li>
    <li><a href="#istio-sidecar-proxy">Istio Sidecar Proxy</a></li>
  </ul>

  <ul>
    <li><a href="#nodeport">NodePort</a></li>
    <li><a href="#loadbalancer">LoadBalancer</a></li>
    <li><a href="#ingress">Ingress</a>
      <ul>
        <li><a href="#按-http-请求的-url-进行路由">按 HTTP 请求的 URL 进行路由</a></li>
        <li><a href="#按-http-请求的-host-进行路由">按 HTTP 请求的 Host 进行路由</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#k8s-ingress">K8s Ingress</a></li>
    <li><a href="#istio-gateway">Istio Gateway</a></li>
    <li><a href="#应用对-api-gateway-的需求">应用对 API Gateway 的需求</a></li>
    <li><a href="#采用-api-gateway--sidecar-proxy-作为服务网格的流量入口">采用 API Gateway + Sidecar Proxy 作为服务网格的流量入口</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
</details>

                    
                    <p>在启用了 Istio 服务网格的 Kubernetes 集群中，缺省情况下只能在集群内部访问网格中的服务，要如何才能从外部网络访问这些服务呢？Kubernetes 和 Istio 提供了 NodePort，LoadBalancer，Kubernetes Ingress，Istio Gateway 等多种外部流量入口的方式，面对这么多种方式，我们在产品部署中应该如何选择？</p>
<p>本文将对 Kubernetes 和 Istio 对外提供服务的各种方式进行详细介绍和对比分析，并根据分析结果提出一个可用于产品部署的解决方案。</p>
<blockquote>
<p>说明：阅读本文要求读者了解 Kubernetes 和 Istio 的基本概念，包括 Pod、Service、NodePort、LoadBalancer、Ingress、Gateway、VirtualService 等。如对这些概念不熟悉，可以在阅读过程中参考文后的相关链接。</p>
</blockquote>
<h2 id="内部服务间的通信">内部服务间的通信</h2>
<p>首先，我们来回顾一下 Kubernetes 集群内部各个服务之间相互访问的方法。</p>
<h2 id="cluster-ip">Cluster IP</h2>
<p>Kubernetes 以 Pod 作为应用部署的最小单位。Kubernetes 会根据 Pod 的声明对其进行调度，包括创建、销毁、迁移、水平伸缩等，因此 Pod 的 IP 地址不是固定的，不方便直接采用 Pod IP 对服务进行访问。</p>
<p>为解决该问题，Kubernetes 提供了 Service 资源，Service 对提供同一个服务的多个 Pod 进行聚合。一个 Service 提供一个虚拟的 Cluster IP，后端对应一个或者多个提供服务的 Pod。在集群中访问该 Service 时，采用 Cluster IP 即可，Kube-proxy 负责将发送到 Cluster IP 的请求转发到后端的 Pod 上。</p>
<p>Kube-proxy 是一个运行在每个节点上的 go 应用程序，支持三种工作模式：</p>
<h3 id="userspace-模式">userspace 模式</h3>
<p>该模式下 Kube-proxy 会为每一个 Service 创建一个监听端口。发向 Cluster IP 的请求被 Iptables 规则重定向到 Kube-proxy 监听的端口上，Kube-proxy 根据 LB 算法选择一个提供服务的 Pod 并和其建立链接，以将请求转发到 Pod 上。<br>
该模式下，Kube-proxy 充当了一个四层 Load balancer 的角色。由于 Kube-proxy 运行在 userspace 中，在进行转发处理时会增加两次内核和用户空间之间的数据拷贝，效率较另外两种模式低一些；好处是当后端的 Pod 不可用时，Kube-proxy 可以重试其他 Pod。</p>
<p>















<figure  id="figure-kube-proxy-userspace-模式">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="Kube-proxy userspace 模式" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu8dc1e76c9a22d4337a2528c0926b2806_73879_36350caaa74f09b9d3ceba238b362c03.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu8dc1e76c9a22d4337a2528c0926b2806_73879_a715e8bf7cd5cf848bb8906514ddfb53.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu8dc1e76c9a22d4337a2528c0926b2806_73879_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu8dc1e76c9a22d4337a2528c0926b2806_73879_36350caaa74f09b9d3ceba238b362c03.webp"
               width="760"
               height="428"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      Kube-proxy userspace 模式
    </figcaption></figure>
</p>
<p>图片来自：<a href="https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies/" target="_blank" rel="noopener">Kubernetes 官网文档</a></p>
<h3 id="iptables-模式">iptables 模式</h3>
<p>为了避免增加内核和用户空间的数据拷贝操作，提高转发效率，Kube-proxy 提供了 iptables 模式。在该模式下，Kube-proxy 为 service 后端的每个 Pod 创建对应的 iptables 规则，直接将发向 Cluster IP 的请求重定向到一个 Pod IP。<br>
该模式下 Kube-proxy 不承担四层代理的角色，只负责创建 iptables 规则。该模式的优点是较 userspace 模式效率更高，但不能提供灵活的 LB 策略，当后端 Pod 不可用时也无法进行重试。</p>
<p>















<figure  id="figure-kube-proxy-iptables-模式">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="Kube-proxy iptables 模式" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hube2f04acea1f9f0ceec7009c15fc7444_90048_76d2336c2d795a60774cd04eb6818f3b.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hube2f04acea1f9f0ceec7009c15fc7444_90048_a9ee5d1c91418b34a8b04abc5a5c8db7.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hube2f04acea1f9f0ceec7009c15fc7444_90048_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hube2f04acea1f9f0ceec7009c15fc7444_90048_76d2336c2d795a60774cd04eb6818f3b.webp"
               width="760"
               height="526"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      Kube-proxy iptables 模式
    </figcaption></figure>
</p>
<p>图片来自：<a href="https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies/" target="_blank" rel="noopener">Kubernetes 官网文档</a></p>
<h3 id="ipvs-模式">ipvs 模式</h3>
<p>该模式和 iptables 类似，Kube-proxy 监控 Pod 的变化并创建相应的 ipvs rules。ipvs 也是在 kernel 模式下通过 netfilter 实现的，但采用了 hash table 来存储规则，因此在规则较多的情况下，Ipvs 相对 iptables 转发效率更高。除此以外，ipvs 支持更多的 LB 算法。如果要设置 Kube-proxy 为 ipvs 模式，必须在操作系统中安装 IPVS 内核模块。</p>
<p>















<figure  id="figure-kube-proxy-ipvs-模式">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="Kube-proxy ipvs 模式" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hud7ab31c76a7c5554c42e18554b31030e_75992_4c16109750a1df6b227e483ae1942797.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hud7ab31c76a7c5554c42e18554b31030e_75992_b2786ef517e1de8fac5bba4dd98031ce.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hud7ab31c76a7c5554c42e18554b31030e_75992_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hud7ab31c76a7c5554c42e18554b31030e_75992_4c16109750a1df6b227e483ae1942797.webp"
               width="760"
               height="524"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      Kube-proxy ipvs 模式
    </figcaption></figure>
</p>
<p>图片来自：<a href="https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies/" target="_blank" rel="noopener">Kubernetes 官网文档</a></p>
<h2 id="istio-sidecar-proxy">Istio Sidecar Proxy</h2>
<p>Cluster IP 解决了服务之间相互访问的问题，但从上面 Kube-proxy 的三种模式可以看到，Cluster IP 的方式只提供了服务发现和基本的 LB 功能。如果要为服务间的通信应用灵活的路由规则以及提供 Metrics collection，distributed tracing 等服务管控功能，就必须得依靠 Istio 提供的服务网格能力了。</p>
<p>在 Kubernetes 中部署 Istio 后，Istio 通过 iptables 和 Sidecar Proxy 接管服务之间的通信，服务间的相互通信不再通过 Kube-proxy，而是通过 Istio 的 Sidecar Proxy 进行。请求流程是这样的：Client 发起的请求被 iptables 重定向到 Sidecar Proxy，Sidecar Proxy 根据从控制面获取的服务发现信息和路由规则，选择一个后端的 Server Pod 创建连接，代理并转发 Client 的请求。</p>
<p>Istio Sidecar Proxy 和 Kube-proxy 的 userspace 模式的工作机制类似，都是通过在用户空间的一个代理来实现客户端请求的转发和后端多个 Pod 之间的负载均衡。两者的不同点是：Kube-Proxy 工作在四层，而 Sidecar Proxy 则是一个七层代理，可以针对 HTTP，gRPC 等应用层的语义进行处理和转发，因此功能更为强大，可以配合控制面实现更为灵活的路由规则和服务管控功能。</p>
<p>















<figure  id="figure-istio-sidecar-proxy">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="Istio Sidecar Proxy" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hua0177e72aab7bff2a5296e713d92c27c_25406_84cd4f40a35961f6c1c27db3569d4339.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hua0177e72aab7bff2a5296e713d92c27c_25406_119e7aad75a1359b61195eb181adba5b.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hua0177e72aab7bff2a5296e713d92c27c_25406_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hua0177e72aab7bff2a5296e713d92c27c_25406_84cd4f40a35961f6c1c27db3569d4339.webp"
               width="636"
               height="426"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      Istio Sidecar Proxy
    </figcaption></figure>
</p>
<h1 id="如何从外部网络访问">如何从外部网络访问</h1>
<p>Kubernetes 的 Pod IP 和 Cluster IP 都只能在集群内部访问，而我们通常需要从外部网络上访问集群中的某些服务，Kubernetes 提供了下述几种方式来为集群提供外部流量入口。</p>
<h2 id="nodeport">NodePort</h2>
<p>NodePort 在集群中的主机节点上为 Service 提供一个代理端口，以允许从主机网络上对 Service 进行访问。Kubernetes 官网文档只介绍了 NodePort 的功能，并未对其实现原理进行解释。下面我们通过实验来分析 NodePort 的实现机制。</p>
<p><a href="https://www.katacoda.com" target="_blank" rel="noopener">www.katacoda.com</a> 这个网站提供了一个交互式的 Kubernetes playground，注册即可免费实验 Kubernetes 的相关功能，下面我们就使用 Katacoda 来分析 Nodeport 的实现原理。</p>
<p>在浏览器中输入这个网址：https://www.katacoda.com/courses/kubernetes/networking-introduction，打开后会提供了一个实验用的 Kubernetes 集群，并可以通过网元模拟 Terminal 连接到集群的 Master 节点。</p>
<p>执行下面的命令创建一个 nodeport 类型的 service。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">master $ cat nodeport.yaml
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">kind: Service
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">  name: webapp1-nodeport-svc
</span></span><span class="line"><span class="cl">  labels:
</span></span><span class="line"><span class="cl">    app: webapp1-nodeport
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  type: NodePort
</span></span><span class="line"><span class="cl">  ports:
</span></span><span class="line"><span class="cl">  - port: <span class="m">80</span>
</span></span><span class="line"><span class="cl">    nodePort: <span class="m">30080</span>
</span></span><span class="line"><span class="cl">  selector:
</span></span><span class="line"><span class="cl">    app: webapp1-nodeport
</span></span><span class="line"><span class="cl">---
</span></span><span class="line"><span class="cl">apiVersion: extensions/v1beta1
</span></span><span class="line"><span class="cl">kind: Deployment
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">  name: webapp1-nodeport-deployment
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  replicas: <span class="m">2</span>
</span></span><span class="line"><span class="cl">  template:
</span></span><span class="line"><span class="cl">    metadata:
</span></span><span class="line"><span class="cl">      labels:
</span></span><span class="line"><span class="cl">        app: webapp1-nodeport
</span></span><span class="line"><span class="cl">    spec:
</span></span><span class="line"><span class="cl">      containers:
</span></span><span class="line"><span class="cl">      - name: webapp1-nodeport-pod
</span></span><span class="line"><span class="cl">        image: katacoda/docker-http-server:latest
</span></span><span class="line"><span class="cl">        ports:
</span></span><span class="line"><span class="cl">        - containerPort: <span class="m">80</span>
</span></span><span class="line"><span class="cl">---
</span></span><span class="line"><span class="cl">master $ kubectl apply -f nodeport.yaml
</span></span></code></pre></div><p>查看创建的 service，可以看到 Kubernetes 创建了一个名为 webapp-nodeport-svc 的 service，并为该 service 在主机节点上创建了 30080 这个 Nodeport。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">master $ kubectl get svc
</span></span><span class="line"><span class="cl">NAME                   TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>        AGE
</span></span><span class="line"><span class="cl">kubernetes             ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        36m
</span></span><span class="line"><span class="cl">webapp1-nodeport-svc   NodePort    10.103.188.73   &lt;none&gt;        80:30080/TCP   3m
</span></span></code></pre></div><p>webapp-nodeport-svc 后端对应两个 Pod，其 Pod 的 IP 分别为 10.32.0.3 和 10.32.0.5。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">master $ kubectl get pod -o wide
</span></span><span class="line"><span class="cl">NAME                                           READY     STATUS    RESTARTS   AGE       IPNODE      NOMINATED NODE
</span></span><span class="line"><span class="cl">webapp1-nodeport-deployment-785989576b-cjc5b   1/1       Running   <span class="m">0</span>          2m        10.32.0.3
</span></span><span class="line"><span class="cl">webapp1-nodeport-deployment-785989576b-tpfqr   1/1       Running   <span class="m">0</span>          2m        10.32.0.5
</span></span></code></pre></div><p>通过 netstat 命令可以看到 Kube-proxy 在主机网络上创建了 30080 监听端口，用于接收从主机网络进入的外部流量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">master $ netstat -lnp<span class="p">|</span>grep <span class="m">30080</span>
</span></span><span class="line"><span class="cl">tcp6       <span class="m">0</span>      <span class="m">0</span> :::30080                :::*                    LISTEN      7427/Kube-proxy
</span></span></code></pre></div><p>下面是 Kube-proxy 创建的相关 iptables 规则以及对应的说明。可以看到 Kube-proxy 为 Nodeport 创建了相应的 IPtable 规则，将发向 30080 这个主机端口上的流量重定向到了后端的两个 Pod IP 上。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">iptables-save &gt; iptables-dump
</span></span><span class="line"><span class="cl"><span class="c1"># Generated by iptables-save v1.6.0 on Thu Mar 28 07:33:57 2019</span>
</span></span><span class="line"><span class="cl">*nat
</span></span><span class="line"><span class="cl"><span class="c1"># Nodeport规则链</span>
</span></span><span class="line"><span class="cl">:KUBE-NODEPORTS - <span class="o">[</span>0:0<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Service规则链</span>
</span></span><span class="line"><span class="cl">:KUBE-SERVICES - <span class="o">[</span>0:0<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Nodeport和Service共用的规则链</span>
</span></span><span class="line"><span class="cl">:KUBE-SVC-J2DWGRZTH4C2LPA4 - <span class="o">[</span>0:0<span class="o">]</span>
</span></span><span class="line"><span class="cl">:KUBE-SEP-4CGFRVESQ3AECDE7 - <span class="o">[</span>0:0<span class="o">]</span>
</span></span><span class="line"><span class="cl">:KUBE-SEP-YLXG4RMKAICGY2B3 - <span class="o">[</span>0:0<span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 将host上30080端口的外部tcp流量转到KUBE-SVC-J2DWGRZTH4C2LPA4链</span>
</span></span><span class="line"><span class="cl">-A KUBE-NODEPORTS -p tcp -m comment --comment <span class="s2">&#34;default/webapp1-nodeport-svc:&#34;</span> -m tcp --dport <span class="m">30080</span> -j KUBE-SVC-J2DWGRZTH4C2LPA4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#将发送到Cluster IP 10.103.188.73的内部流量转到KUBE-SVC-J2DWGRZTH4C2LPA4链</span>
</span></span><span class="line"><span class="cl">KUBE-SERVICES -d 10.103.188.73/32 -p tcp -m comment --comment <span class="s2">&#34;default/webapp1-nodeport-svc: cluster IP&#34;</span> -m tcp --dport <span class="m">80</span> -j KUBE-SVC-J2DWGRZTH4C2LPA4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#将发送到webapp1-nodeport-svc的流量转交到第一个Pod（10.32.0.3）相关的规则链上，比例为50%</span>
</span></span><span class="line"><span class="cl">-A KUBE-SVC-J2DWGRZTH4C2LPA4 -m comment --comment <span class="s2">&#34;default/webapp1-nodeport-svc:&#34;</span> -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-YLXG4RMKAICGY2B3
</span></span><span class="line"><span class="cl"><span class="c1">#将发送到webapp1-nodeport-svc的流量转交到第二个Pod（10.32.0.5）相关的规则链上</span>
</span></span><span class="line"><span class="cl">-A KUBE-SVC-J2DWGRZTH4C2LPA4 -m comment --comment <span class="s2">&#34;default/webapp1-nodeport-svc:&#34;</span> -j KUBE-SEP-4CGFRVESQ3AECDE7
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#将请求重定向到Pod 10.32.0.3</span>
</span></span><span class="line"><span class="cl">-A KUBE-SEP-YLXG4RMKAICGY2B3 -p tcp -m comment --comment <span class="s2">&#34;default/webapp1-nodeport-svc:&#34;</span> -m tcp -j DNAT --to-destination 10.32.0.3:80
</span></span><span class="line"><span class="cl"><span class="c1">#将请求重定向到Pod 10.32.0.5</span>
</span></span><span class="line"><span class="cl">-A KUBE-SEP-4CGFRVESQ3AECDE7 -p tcp -m comment --comment <span class="s2">&#34;default/webapp1-nodeport-svc:&#34;</span> -m tcp -j DNAT --to-destination 10.32.0.5:80
</span></span></code></pre></div><p>从上面的实验可以看到，通过将一个 Service 定义为 NodePort 类型，Kubernetes 会通过集群中 node 上的 Kube-proxy 为该 Service 在主机网络上创建一个监听端口。Kube-proxy 并不会直接接收该主机端口进入的流量，而是会创建相应的 Iptables 规则，并通过 Iptables 将从该端口收到的流量直接转发到后端的 Pod 中。</p>
<p>NodePort 的流量转发机制和 Cluster IP 的 iptables 模式类似，唯一不同之处是在主机网络上开了一个“NodePort”来接受外部流量。从上面的规则也可以看出，在创建 Nodeport 时，Kube-proxy 也会同时为 Service 创建 Cluster IP 相关的 iptables 规则。</p>
<blockquote>
<p>备注：除采用 iptables 进行流量转发，NodePort 应该也可以提供 userspace 模式以及 ipvs 模式，这里未就这两种模式进行实验验证。</p>
</blockquote>
<p>从分析得知，在 NodePort 模式下，集群内外部的通讯如下图所示：</p>
<p>















<figure  id="figure-nodeport">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="NodePort" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu04c123e54c9dc8cda51f4e2369bcdb29_29977_b1d7ac81a3defd32f42baedca93e78a4.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu04c123e54c9dc8cda51f4e2369bcdb29_29977_69b2af34c630ee464b1712f1d73c2507.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu04c123e54c9dc8cda51f4e2369bcdb29_29977_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu04c123e54c9dc8cda51f4e2369bcdb29_29977_b1d7ac81a3defd32f42baedca93e78a4.webp"
               width="501"
               height="408"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      NodePort
    </figcaption></figure>
</p>
<h2 id="loadbalancer">LoadBalancer</h2>
<p>NodePort 提供了一种从外部网络访问 Kubernetes 集群内部 Service 的方法，但该方法存在下面一些限制，导致这种方式主要适用于程序开发，不适合用于产品部署。</p>
<ul>
<li>Kubernetes cluster host 的 IP 必须是一个 well-known IP，即客户端必须知道该 IP。但 Cluster 中的 host 是被作为资源池看待的，可以增加删除，每个 host 的 IP 一般也是动态分配的，因此并不能认为 host IP 对客户端而言是 well-known IP。</li>
<li>客户端访问某一个固定的 host IP 的方式存在单点故障。假如一台 host 宕机了，Kubernetes cluster 会把应用 reload 到另一节点上，但客户端就无法通过该 host 的 nodeport 访问应用了。</li>
<li>通过一个主机节点作为网络入口，在网络流量较大时存在性能瓶颈。</li>
</ul>
<p>为了解决这些问题，Kubernetes 提供了 LoadBalancer。通过将 Service 定义为 LoadBalancer 类型，Kubernetes 在主机节点的 NodePort 前提供了一个四层的负载均衡器。该四层负载均衡器负责将外部网络流量分发到后面的多个节点的 NodePort 端口上。</p>
<p>下图展示了 Kubernetes 如何通过 LoadBalancer 方式对外提供流量入口，图中 LoadBalancer 后面接入了两个主机节点上的 NodePort，后端部署了三个 Pod 提供服务。根据集群的规模，可以在 LoadBalancer 后面可以接入更多的主机节点，以进行负荷分担。</p>
<p>















<figure  id="figure-nodebalancer">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="NodeBalancer" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_huff36870b62c8daf04a0e8ebdf3890aff_64739_f463990110caac0525dec78da1650f28.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_huff36870b62c8daf04a0e8ebdf3890aff_64739_f510964b6c3d25b685c1882ac5677b15.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_huff36870b62c8daf04a0e8ebdf3890aff_64739_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_huff36870b62c8daf04a0e8ebdf3890aff_64739_f463990110caac0525dec78da1650f28.webp"
               width="760"
               height="497"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      NodeBalancer
    </figcaption></figure>
</p>
<blockquote>
<p>备注：LoadBalancer 类型需要云服务提供商的支持，Service 中的定义只是在 Kubernetes 配置文件中提出了一个要求，即为该 Service 创建 Load Balancer，至于如何创建则是由 Google Cloud 或 Amazon Cloud 等云服务商提供的，创建的 Load Balancer 的过程不在 Kubernetes Cluster 的管理范围中。</p>
<p>目前 AWS、Azure、CloudStack、GCE 和 OpenStack 等主流的公有云和私有云提供商都可以为 Kubernetes 提供 Load Balancer。一般来说，公有云提供商还会为 Load Balancer 提供一个 External IP，以提供 Internet 接入。如果你的产品没有使用云提供商，而是自建 Kubernetes Cluster，则需要自己提供 LoadBalancer。</p>
</blockquote>
<h2 id="ingress">Ingress</h2>
<p>LoadBalancer 类型的 Service 提供的是四层负载均衡器，当只需要向外暴露一个服务的时候，采用这种方式是没有问题的。但当一个应用需要对外提供多个服务时，采用该方式则要求为每一个四层服务（IP+Port）都创建一个外部 Load balancer。</p>
<p>一般来说，同一个应用的多个服务/资源会放在同一个域名下，在这种情况下，创建多个 Load balancer 是完全没有必要的，反而带来了额外的开销和管理成本。另外直接将服务暴露给外部用户也会导致了前端和后端的耦合，影响了后端架构的灵活性，如果以后由于业务需求对服务进行调整会直接影响到客户端。</p>
<p>在这种情况下，我们可以通过使用 Kubernetes Ingress 来统一网络入口。Kubernetes Ingress 声明了一个应用层（OSI 七层）的负载均衡器，可以根据 HTTP 请求的内容将来自同一个 TCP 端口的请求分发到不同的 Kubernetes Service，其功能包括：</p>
<h3 id="按-http-请求的-url-进行路由">按 HTTP 请求的 URL 进行路由</h3>
<p>同一个 TCP 端口进来的流量可以根据 URL 路由到 Cluster 中的不同服务，如下图所示：</p>
<p>















<figure  id="figure-按-http-请求的-ulr-进行路由">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="按 HTTP 请求的 ULR 进行路由" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu3147d627533d5bda2b80afdf39fa9ae2_28424_a6723839f96f34f13dd4bef936cf5fbd.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu3147d627533d5bda2b80afdf39fa9ae2_28424_c2eec0d4b3f8f0d2aea38723ecd9835e.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu3147d627533d5bda2b80afdf39fa9ae2_28424_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu3147d627533d5bda2b80afdf39fa9ae2_28424_a6723839f96f34f13dd4bef936cf5fbd.webp"
               width="575"
               height="421"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      按 HTTP 请求的 ULR 进行路由
    </figcaption></figure>
</p>
<h3 id="按-http-请求的-host-进行路由">按 HTTP 请求的 Host 进行路由</h3>
<p>同一个 IP 进来的流量可以根据 HTTP 请求的 Host 路由到 Cluster 中的不同服务，如下图所示：</p>
<p>















<figure  id="figure-按-http-请求的-host-进行路由">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="按 HTTP 请求的 Host 进行路由" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu454e761a6e4c1335160029fd8786d888_29029_cb27c178916f2a29097f8b16cfbbfc69.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu454e761a6e4c1335160029fd8786d888_29029_a973268580e02c52ef7a1709d33cce6c.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu454e761a6e4c1335160029fd8786d888_29029_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu454e761a6e4c1335160029fd8786d888_29029_cb27c178916f2a29097f8b16cfbbfc69.webp"
               width="572"
               height="442"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      按 HTTP 请求的 Host 进行路由
    </figcaption></figure>
</p>
<p>Ingress 规则定义了对七层网关的要求，包括 URL 分发规则，基于不同域名的虚拟主机，SSL 证书等。Kubernetes 使用 Ingress Controller 来监控 Ingress 规则，并通过一个七层网关来实现这些要求，一般可以使用 Nginx，HAProxy，Envoy 等。</p>
<p>虽然 Ingress Controller 通过七层网关为后端的多个 Service 提供了统一的入口，但由于其部署在集群中，因此并不能直接对外提供服务。实际上 Ingress 需要配合 NodePort 和 LoadBalancer 才能提供对外的流量入口，如下图所示：</p>
<p>















<figure  id="figure-采用-ingress-nodeportal-和-loadbalancer-提供外部流量入口的拓扑结构">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="采用 Ingress, NodePortal 和 LoadBalancer 提供外部流量入口的拓扑结构" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_hua5289e375e3a64565b081d15b34efcb5_52009_d8221722ff067265ad3e7ae4e62d2659.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_hua5289e375e3a64565b081d15b34efcb5_52009_d5f645ed36dae671705061defa063e21.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_hua5289e375e3a64565b081d15b34efcb5_52009_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_hua5289e375e3a64565b081d15b34efcb5_52009_d8221722ff067265ad3e7ae4e62d2659.webp"
               width="760"
               height="580"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      采用 Ingress, NodePortal 和 LoadBalancer 提供外部流量入口的拓扑结构
    </figcaption></figure>
</p>
<p>上图描述了如何采用 Ingress 配合 NodePort 和 Load Balancer 为集群提供外部流量入口，从该拓扑图中可以看到该架构的伸缩性非常好，在 NodePort，Ingress，Pod 等不同的接入层面都可以对系统进行水平扩展，以应对不同的外部流量要求。</p>
<p>上图只展示了逻辑架构，下面的图展示了具体的实现原理：</p>
<p>















<figure  id="figure-采用-ingress-nodeportal-和-loadbalancer-提供外部流量入口的实现原理">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="采用 Ingress, NodePortal 和 LoadBalancer 提供外部流量入口的实现原理" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu32e84355c982e733cb5d1bcc246db47d_56567_56c46da02785546f89532ce2fb0077fc.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu32e84355c982e733cb5d1bcc246db47d_56567_edc218ba3e964a043ee030f0dfd1c367.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu32e84355c982e733cb5d1bcc246db47d_56567_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu32e84355c982e733cb5d1bcc246db47d_56567_56c46da02785546f89532ce2fb0077fc.webp"
               width="518"
               height="760"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      采用 Ingress, NodePortal 和 LoadBalancer 提供外部流量入口的实现原理
    </figcaption></figure>
</p>
<p>流量从外部网络到达 Pod 的完整路径如下：</p>
<ol>
<li>外部请求先通过四层 Load Balancer 进入内部网络</li>
<li>Load Balancer 将流量分发到后端多个主机节点上的 NodePort (userspace 转发)</li>
<li>请求从 NodePort 进入到 Ingress Controller (iptabes 规则，Ingress Controller 本身是一个 NodePort 类型的 Service)</li>
<li>Ingress Controller 根据 Ingress rule 进行七层分发，根据 HTTP 的 URL 和 Host 将请求分发给不同的 Service (userspace 转发)</li>
<li>Service 将请求最终导入到后端提供服务的 Pod 中 (iptabes 规则)</li>
</ol>
<p>从前面的介绍可以看到，K8S Ingress 提供了一个基础的七层网关功能的抽象定义，其作用是对外提供一个七层服务的统一入口，并根据 URL/HOST 将请求路由到集群内部不同的服务上。</p>
<h1 id="如何为服务网格选择入口网关">如何为服务网格选择入口网关？</h1>
<p>在 Istio 服务网格中，通过为每个 Service 部署一个 sidecar 代理，Istio 接管了 Service 之间的请求流量。控制面可以对网格中的所有 sidecar 代理进行统一配置，实现了对网格内部流量的路由控制，从而可以实现灰度发布，流量镜像，故障注入等服务管控功能。但是，Istio 并没有为入口网关提供一个较为完善的解决方案。</p>
<h2 id="k8s-ingress">K8s Ingress</h2>
<p>在 0.8 版本以前，Istio 缺省采用 K8s Ingress 来作为 Service Mesh 的流量入口。K8s Ingress 统一了应用的流量入口，但存在两个问题：</p>
<ul>
<li>K8s Ingress 是独立在 Istio 体系之外的，需要单独采用 Ingress rule 进行配置，导致系统入口和内部存在两套互相独立的路由规则配置，运维和管理较为复杂。</li>
<li>K8s Ingress rule 的功能较弱，不能在入口处实现和网格内部类似的路由规则，也不具备网格 sidecar 的其它能力，导致难以从整体上为应用系统实现灰度发布、分布式跟踪等服务管控功能。</li>
</ul>
<p>















<figure  id="figure-采用-kubernetes-ingress-作为服务网格的流量入口">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="采用 Kubernetes Ingress 作为服务网格的流量入口" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_huc39078939647097827ba507f1ce7dc1d_32214_9bffafa86db417ae79938a6494cbaf86.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_huc39078939647097827ba507f1ce7dc1d_32214_a9f2d787310be1eb2da43a6934ddf8c7.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_huc39078939647097827ba507f1ce7dc1d_32214_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_huc39078939647097827ba507f1ce7dc1d_32214_9bffafa86db417ae79938a6494cbaf86.webp"
               width="760"
               height="346"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      采用 Kubernetes Ingress 作为服务网格的流量入口
    </figcaption></figure>
</p>
<h2 id="istio-gateway">Istio Gateway</h2>
<p>Istio 社区意识到了 Ingress 和 Mesh 内部配置割裂的问题，因此从 0.8 版本开始，社区采用了 Gateway 资源代替 K8s Ingress 来表示流量入口。</p>
<p>Istio Gateway 资源本身只能配置 L4-L6 的功能，例如暴露的端口，TLS 设置等；但 Gateway 可以和绑定一个 VirtualService，在 VirtualService 中可以配置七层路由规则，这些七层路由规则包括根据按照服务版本对请求进行导流，故障注入，HTTP 重定向，HTTP 重写等所有 Mesh 内部支持的路由规则。</p>
<p>Gateway 和 VirtualService 用于表示 Istio Ingress 的配置模型，Istio Ingress 的缺省实现则采用了和 Sidecar 相同的 Envoy proxy。</p>
<p>通过该方式，Istio 控制面用一致的配置模型同时控制了入口网关和内部的 sidecar 代理。这些配置包括路由规则，策略检查、Telementry 收集以及其他服务管控功能。</p>
<p>















<figure  id="figure-采用-istio-ingress-gateway-作为服务网格的流量入口">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="采用 Istio Ingress Gateway 作为服务网格的流量入口" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu60362402b67f17176f971b333f664335_39512_06e9052302feb1fb93c833ff97041682.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu60362402b67f17176f971b333f664335_39512_1aacc030c3bc634e00c71f5b779aedc9.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu60362402b67f17176f971b333f664335_39512_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu60362402b67f17176f971b333f664335_39512_06e9052302feb1fb93c833ff97041682.webp"
               width="737"
               height="443"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      采用 Istio Ingress Gateway 作为服务网格的流量入口
    </figcaption></figure>
</p>
<h2 id="应用对-api-gateway-的需求">应用对 API Gateway 的需求</h2>
<p>采用 Gateway 和 VirtualService 实现的 Istio Ingress Gateway 提供了网络入口处的基础通信功能，包括可靠的通信和灵活的路由规则。但对于一个服务化应用来说，网络入口除了基础的通讯功能之外，还有一些其他的应用层功能需求，例如：</p>
<ul>
<li>第三方系统对 API 的访问控制</li>
<li>用户对系统的访问控制</li>
<li>修改请求/返回数据</li>
<li>服务 API 的生命周期管理</li>
<li>服务访问的 SLA、限流及计费</li>
<li>….</li>
</ul>
<p>















<figure  id="figure-kubernetes-ingress-istio-gateway-and-api-gateway-的功能对比">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="Kubernetes ingress, Istio gateway and API gateway 的功能对比" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu2f742f2693cd823cf33a55fbda1e276a_72425_01074ce9ed424a4d9927bd9095d3bdf2.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu2f742f2693cd823cf33a55fbda1e276a_72425_550218c7fc07e63e3470ffc13129510e.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu2f742f2693cd823cf33a55fbda1e276a_72425_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu2f742f2693cd823cf33a55fbda1e276a_72425_01074ce9ed424a4d9927bd9095d3bdf2.webp"
               width="760"
               height="375"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      Kubernetes ingress, Istio gateway and API gateway 的功能对比
    </figcaption></figure>
</p>
<p>API Gateway 需求中很大一部分需要根据不同的应用系统进行定制，目前看来暂时不大可能被纳入 K8s Ingress 或者 Istio Gateway 的规范之中。为了满足这些需求，涌现出了各类不同的 k8s Ingress Controller 以及 Istio Ingress Gateway 实现，包括 Ambassador、Kong、Traefik、Solo 等。</p>
<p>这些网关产品在实现在提供基础的 K8s Ingress 能力的同时，提供了强大的 API Gateway 功能，但由于缺少统一的标准，这些扩展实现之间相互之间并不兼容。而且遗憾的是，目前这些 Ingress controller 都还没有正式提供和 Istio 控制面集成的能力。</p>
<blockquote>
<p>备注：</p>
<ul>
<li>Ambassador 将对 Istio 路由规则的支持纳入了 Roadmap <a href="https://www.getambassador.io/user-guide/with-istio/" target="_blank" rel="noopener">https://www.getambassador.io/user-guide/with-istio/</a></li>
<li>Istio 声称支持 Istio-Based Route Rule Discovery (尚处于实验阶段) <a href="https://gloo.solo.io/introduction/architecture/" target="_blank" rel="noopener">https://gloo.solo.io/introduction/architecture/</a></li>
</ul>
</blockquote>
<h2 id="采用-api-gateway--sidecar-proxy-作为服务网格的流量入口">采用 API Gateway + Sidecar Proxy 作为服务网格的流量入口</h2>
<p>在目前难以找到一个同时具备 API Gateway 和 Istio Ingress 能力的网关的情况下，一个可行的方案是使用 API Gateway 和 Sidecar Proxy 一起为服务网格提供外部流量入口。</p>
<p>由于 API Gateway 已经具备七层网关的功能，Mesh Ingress 中的 Sidecar 只需要提供 VirtualService 资源的路由能力，并不需要提供 Gateway 资源的网关能力，因此采用 Sidecar Proxy 即可。网络入口处的 Sidecar Proxy 和网格内部应用 Pod 中 Sidecar Proxy 的唯一一点区别是：该 Sidecar 只接管 API Gateway 向 Mesh 内部的流量，并不接管外部流向 API Gateway 的流量；而应用 Pod 中的 Sidecar 需要接管进入应用的所有流量。</p>
<p>















<figure  id="figure-采用-api-gateway--sidecar-proxy-为服务网格提供流量入口">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="采用 API Gateway &#43; Sidecar Proxy 为服务网格提供流量入口" srcset="
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu1d6da553a6f74717a9de587e45f5608a_46240_e77d981143cd30d5529ecce009f1bae0.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu1d6da553a6f74717a9de587e45f5608a_46240_33be91375291142f44d43f80a13865a0.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu1d6da553a6f74717a9de587e45f5608a_46240_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu1d6da553a6f74717a9de587e45f5608a_46240_e77d981143cd30d5529ecce009f1bae0.webp"
               width="760"
               height="383"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      采用 API Gateway &#43; Sidecar Proxy 为服务网格提供流量入口
    </figcaption></figure>
</p>
<blockquote>
<p>备注：在实际部署时，API Gateway 前端需要采用 NodePort 和 LoadBalancer 提供外部流量入口。为了突出主题，对上图进行了简化，没有画出 NodePort 和 LoadBalancer。</p>
</blockquote>
<p>采用 API Gateway 和 Sidecar Proxy 一起作为服务网格的流量入口，既能够通过对网关进行定制开发满足产品对 API 网关的各种需求，又可以在网络入口处利用服务网格提供的灵活的路由能力和分布式跟踪，策略等管控功能，是服务网格产品入口网关的一个理想方案。</p>
<p>性能方面的考虑：从上图可以看到，采用该方案后，外部请求的处理流程在入口处增加了 Sidecar Proxy 这一跳，因此该方式会带来少量的性能损失，但该损失是完全可以接受的。</p>
<p>对于请求时延而言，在服务网格中，一个外部请求本来就要经过较多的代理和应用进程的处理，在 Ingress 处增加一个代理对整体的时延影响基本忽略不计，而且对于绝大多数应用来说，网络转发所占的时间比例本来就很小，99% 的耗时都在业务逻辑。如果系统对于增加的该时延非常敏感，则建议重新考虑该系统是否需要采用微服务架构和服务网格。</p>
<p>对于吞吐量而言，如果入口处的网络吞吐量存在瓶颈，则可以通过对 API Gateway + Sidecar Proxy 组成的 Ingress 整体进行水平扩展，来对入口流量进行负荷分担，以提高网格入口的网络吞吐量。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a id="ref01"><a href="https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies" target="_blank" rel="noopener">Virtual IPs and Service Proxie - kubernetes.io</a></li>
<li><a href="https://zhaohuabing.com/2017/11/28/access-application-from-outside/" target="_blank" rel="noopener">如何从外部访问 Kubernetes 集群中的应用？ - zhaohuabing.com</a></li>
<li><a href="https://zhaohuabing.com/post/2018-12-27-the-obstacles-to-put-istio-into-production/#service-mesh-and-api-gateway" target="_blank" rel="noopener">The obstacles to put Istio into production and how we solve them - kubernetes.io</a></li>
<li><a href="https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0" target="_blank" rel="noopener">Kubernetes NodePort vs LoadBalancer vs Ingress? When should I use what? - medium.com</a></li>
</ul>

                </div>
                

<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/istio/">Istio</a>
  
  <a class="badge badge-light" href="/tag/api-gateway/">api gateway</a>
  
  <a class="badge badge-light" href="/tag/ingress/">Ingress</a>
  
</div>











  
  
    



  
  
  
  
  
  <div class="media author-card content-widget-hr mb-4">
    
      
      <a href="/author/%E8%B5%B5%E5%8C%96%E5%86%B0/"><img class="avatar mr-3 avatar-circle" src="/author/%E8%B5%B5%E5%8C%96%E5%86%B0/avatar_hu584c926f62a0fa050bae237d0ba2c125_11613_270x270_fill_q75_lanczos_center.jpg" alt="赵化冰"></a>
    

    <div class="media-body">
      <p class="card-title"><a href="/author/%E8%B5%B5%E5%8C%96%E5%86%B0/">赵化冰</a></p>
      
      <p class="card-text">Tetrate</p>
      
    </div>
  </div>


  





<div class="article-widget">
  
<div class="container-xl row post-nav">
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1" href="/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/" rel="next">
    <div class="meta-nav">下一页</div>
    <p>Solo.io 打造的 Gloo——Knative 中 Istio 的替代方案</p></a>
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1"  href="/blog/api-gateways-are-going-through-an-identity-crisis/" rel="prev">
    <div class="meta-nav">上一页</div>
    <p>API Gateway 的身份认同危机</p></a>
  
</div>

</div>










  

<p class="edit-page">
  <a href="https://github.com/cloudnativeto/cloudnative.to/edit/master/content/blog/how-to-pick-gateway-for-service-mesh/index.md">
    <i class="fas fa-pen pr-2"></i>编辑本页
  </a>
</p>




  
  
  <div class="article-widget content-widget-hr">
    <p class="related-title">相关推荐</p>
    <ul>
      
      <li><a href="/blog/envoy-gateway-to-the-future/">面向未来的网关：新的 Kubernetes Gateway API 和 Envoy Gateway 0.2 介绍</a></li>
      
      <li><a href="/blog/understanding-istio-and-open-policy-agent-opa/">Istio 中的外部授权过滤器：使用 OPA 实现灵活的授权策略</a></li>
      
      <li><a href="/blog/istio-gateway-api-beta/">Istio 扩展对 Gateway API 的支持</a></li>
      
      <li><a href="/blog/istio-traffic-management-series-service-management-concept-theory/">浅析 Istio——服务治理之概念和原理</a></li>
      
      <li><a href="/blog/istio-traffic-management-series-route-management/">浅析 Istio——流量治理之路由管理</a></li>
      
    </ul>
  </div>
  





  
  
  

  

  
  <section id="comments" class="mb-3 pt-0">
    <script>
  let themeNumber = localStorage.getItem('wcTheme');
  var giscusTheme = "light";
  if (themeNumber == 1){
    giscusTheme = "dark";
  }
  let giscusAttributes = {
    "src": "https://giscus.app/client.js",
    "data-theme": giscusTheme,
    "data-repo":"cloudnativeto\/cloudnative.to",
    "data-repo-id":"MDEwOlJlcG9zaXRvcnkyMzc3NDUxOTA=",
    "data-category":"General",
    "data-category-id":"MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMyMDU5MzUy",
    "data-mapping":"pathname",
    "data-reactions-enabled":"",
    "data-emit-metadata":"0",
    "data-input-position":"top",
    "data-theme":giscusTheme,
    "data-lang":"zh-CN",
    "data-loading":"lazy",
    "crossorigin":"annoymous",
    "origins":"https://cloudnative.to",
    "originsRegex":"http://localhost:[0-9]+",
    "async": "",
  };

  let giscusScript = document.createElement("script");
  Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
  document.querySelector('#comments').appendChild(giscusScript);
</script>

  </section>
  



            </article>
        </main>
    </div>
</div>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">

  



  

  
  <div class="copyright py-4 bg-footer">
      <div class="row justify-content-center">
        <div class="text-center footer-color">
          <p class="mb-0">© 2020-2024 云原生社区保留所有权利</p>
        </div>
    </div>
  </div>

</footer>

    </div>
    
  </div>

  


<script src="/js/vendor-bundle.min.b4708d4364577c16ab7001b265a063a4.js"></script>




  

  
  

  

  
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js" integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin="anonymous"></script>
    
    
  










  
  <script id="search-hit-fuse-template" type="text/x-template">
    <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <div class="article-metadata search-hit-type">{{relpermalink}}</div>
          <a href="{{relpermalink}}">{{title}}</a>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
    </div>
  </script>
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin="anonymous"></script>
  












  
  
  
  
  
  
  







<script id="page-data" type="application/json">{"use_headroom":false}</script>










  
  


<script src="/zh/js/wowchemy.min.86e72873b0cba69f752c6d2cadb023c6.js"></script>







<script>

var mybutton = document.getElementById("backTopBtn");


window.onscroll = function() {scrollFunction()};

function scrollFunction() {
  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    mybutton.style.display = "block";
  } else {
    mybutton.style.display = "none";
  }
}


function topFunction() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
<script>
  anchors.add();
</script>



<script>



(function() {
  'use strict';

  if(!document.queryCommandSupported('copy')) {
    return;
  }

  function flashCopyMessage(el, msg) {
    el.className = "highlight-copy-btn";
    el.textContent = msg;
    setTimeout(function() {
      el.textContent = "";
      el.className = "highlight-copy-btn fa fa-copy";
    }, 1000);
  }

  function selectText(node) {
    var selection = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
    return selection;
  }

  function addCopyButton(containerEl) {
    var copyBtn = document.createElement("button");
    copyBtn.className = "highlight-copy-btn fa fa-copy";
    copyBtn.textContent = "";

    var codeEl = containerEl.firstElementChild;
    copyBtn.addEventListener('click', function() {
      try {
        var selection = selectText(codeEl);
        document.execCommand('copy');
        selection.removeAllRanges();
        
        flashCopyMessage(copyBtn, '已复制')
        
      } catch(e) {
        console && console.log(e);
        flashCopyMessage(copyBtn, 'Failed :\'(')
      }
    });

    containerEl.appendChild(copyBtn);
  }

  
  var highlightBlocks = document.getElementsByClassName('highlight');
  Array.prototype.forEach.call(highlightBlocks, addCopyButton);
})();
</script>



<script>

function Collapse(e){
  var node = document.getElementById(e);
  if (node.className.indexOf('fa-angle-down') > -1){
    node.setAttribute("class", "fa-solid fa-angle-right");
    }else{
    node.setAttribute("class", "fa-solid fa-angle-down");
    }
}
</script>


</body>
</html>
