<!DOCTYPE html><html lang="zh" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.5.0 for Hugo" />
  

  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
  

  

  
  
  
    
  
  <meta name="description" content="微软最近宣布了 Service Mesh Interface 服务网格规范，定义了通用标准，包含基本特性以满足大多数场景下的通用需求。本文将带您深入了解 Service Mesh Interface。" />

  
  <link rel="alternate" hreflang="zh" href="https://cloudnative.to/blog/service-mesh-interface-detail/" />

  
  
  
    <meta name="theme-color" content="#0a55a7" />
  

  
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css" media="print" onload="this.media='all'">

  
  
  
    
    

    
    
    
    
      
      
    
    
    

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      
        
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.008259417e6adf8980695ebbbb46553f.css" />

  



  


  


  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f3dc895ea3bd6186cd835841d365c103";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_hu0802e500a55b0406ddf0453824effa47_6997_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hu0802e500a55b0406ddf0453824effa47_6997_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://cloudnative.to/blog/service-mesh-interface-detail/" />

  
  
  
  
  
  
  
  
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary_large_image" />
  
    <meta property="twitter:site" content="@CloudNativeCN" />
    <meta property="twitter:creator" content="@CloudNativeCN" />
  
  <meta property="og:site_name" content="云原生社区（中国）" />
  <meta property="og:url" content="https://cloudnative.to/blog/service-mesh-interface-detail/" />
  <meta property="og:title" content="Service Mesh Interface 详细介绍 | 云原生社区（中国）" />
  <meta property="og:description" content="微软最近宣布了 Service Mesh Interface 服务网格规范，定义了通用标准，包含基本特性以满足大多数场景下的通用需求。本文将带您深入了解 Service Mesh Interface。" /><meta property="og:image" content="https://cloudnative.to/media/sharing.png" />
    <meta property="twitter:image" content="https://cloudnative.to/media/sharing.png" /><meta property="og:locale" content="zh" />
  
    
      <meta
        property="article:published_time"
        content="2019-06-05T15:54:19&#43;08:00"
      />
    
    <meta property="article:modified_time" content="2023-12-15T09:25:08&#43;08:00">
  

  


    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cloudnative.to/blog/service-mesh-interface-detail/"
  },
  "headline": "Service Mesh Interface 详细介绍",
  
  "datePublished": "2019-06-05T15:54:19+08:00",
  "dateModified": "2023-12-15T09:25:08+08:00",
  
  "author": {
    "@type": "Person",
    "name": "敖小剑"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "云原生社区（中国）",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cloudnative.to/media/logo.svg"
    }
  },
  "description": "微软最近宣布了 Service Mesh Interface 服务网格规范，定义了通用标准，包含基本特性以满足大多数场景下的通用需求。本文将带您深入了解 Service Mesh Interface。"
}
</script>

  

  

  

  





  <title>Service Mesh Interface 详细介绍 | 云原生社区（中国）</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="166e4a32c1efc5b362f37ce33badac7b" >
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden="true"></i></button>
  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.62d6f8dfe8493f1c68557dde65bec362.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6 search-title">
          <p>搜索</p>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="关闭"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="搜索..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="搜索...">
        
      </div>

      
      

      
    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

      <div id="search-common-queries">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    











  


<header class="header--fixed">
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区（中国）"
            
            ></a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="切换导航">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区（中国）"
          
          ></a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/community"><span>社区</span></a>
          </li>

          
          

          

          
          
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link  active" href="/blog"><span>博客</span></a>
          </li>

          
          

          
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>资料</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/envoy/"><span>Envoy 中文文档</span></a>
              
                <a class="dropdown-item" href="/kubebuilder/"><span>Kubebuilder 中文文档</span></a>
              
                <a class="dropdown-item" href="https://lib.jimmysong.io/"><span>云原生资料库</span></a>
              
                <a class="dropdown-item" href="https://istio.io/latest/zh/"><span>Istio 中文文档</span></a>
              
            </div>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/event"><span>活动</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#feed"><span>更新</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#tags"><span>标签</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#about"><span>关于</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        

        
        <li class="nav-item">
            <a class="nav-link" href="/community/join/" data-toggle="tooltip" data-placement="bottom" title="加入社区" aria-label="主站"><i class="fa-brands fa-weixin" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item">
            <a class="nav-link js-search" href="#" data-toggle="tooltip" data-placement="bottom" title="搜索" aria-label="搜索"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item d-none d-lg-inline-flex">
            <a class="nav-link" href="https://github.com/cloudnativeto/cloudnative.to" target="_blank" rel="noopener" data-toggle="tooltip" data-placement="bottom" title="查看源码" aria-label="查看源码" aria-label="GitHub"><i class="fa-brands fa-github" aria-hidden="true"></i></a>
        </li>
        

        
        
        
        <li class="nav-item">
          <a href="#" class="nav-link set-theme">
            <i class="fa fa-sun" aria-hidden="true" id="theme-icon"></i>
          </a>
        </li>
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    <div class="container-xl">
    <div class="post-container">
        












  

  
  
  
<div class="article-container pt-3">
  <h1>Service Mesh Interface 详细介绍</h1>

  

  
    


<div class="article-metadata">

  <div>
  
  
  
  
    <i class="fa-solid fa-feather"></i>
    

  <span >
      <a href="/author/%E6%95%96%E5%B0%8F%E5%89%91/">敖小剑</a></span>
    
    <span class="middot-divider"></span>
    
  
  
  
  
  
  
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/category/service-mesh/" class="text-capitalize">service mesh</a></span>
  
  </div>

  
  <span class="article-date">
    
    
      
          
          发布于
      
    
    2019-06-05
  </span>
  

  

  
  <span class="middot-divider"></span>
  字数 8323
  <span class="middot-divider"></span>
  <span class="article-reading-time">
      阅读时长 38 分钟
  </span>
  

  
  
  
  

</div>

    





  
</div>


    </div>
    <div class="border-bottom mb-2"></div>
    <div class="row flex-xl-nowrap">
        <div class="col-3 d-none d-xl-block docs-toc">
            <!-- toc -->
            
<div class="">
    <ul class="nav toc-top">
        <li>
            <a href="#" id="back_to_top" class="docs-toc-title">目录</a>
        </li>
    </ul>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#smi-介绍">SMI 介绍</a>
      <ul>
        <li><a href="#smi-是什么">SMI 是什么？</a></li>
        <li><a href="#smi-推出的背景">SMI 推出的背景</a></li>
        <li><a href="#和通用数据平面-api-的关系">和通用数据平面 API 的关系</a></li>
        <li><a href="#smi-的目标和愿景">SMI 的目标和愿景</a></li>
        <li><a href="#smi-社区">SMI 社区</a></li>
      </ul>
    </li>
    <li><a href="#smi-规范内容">SMI 规范内容</a>
      <ul>
        <li><a href="#smi-规范介绍">SMI 规范介绍</a></li>
        <li><a href="#traffic-spec">Traffic Spec</a></li>
        <li><a href="#traffic-access-control">Traffic Access Control</a></li>
        <li><a href="#traffic-split">Traffic Split</a></li>
        <li><a href="#traffic-metrics">Traffic Metrics</a></li>
        <li><a href="#smi-规范总结">SMI 规范总结</a></li>
      </ul>
    </li>
    <li><a href="#smi-分析">SMI 分析</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
</div>

            <!-- /toc -->
            
            <div class="subscribe-module col-12 mt-1">
    <img src="/img/wechat.jpg" alt="image" title="云原生社区的微信公众号"/>
    <p class="text-center pt-1">关注「云原生社区动态」微信公众号，获取本站更新</p>
</div>

            
        </div>
        <main class="article-body col-9 container docs-content" role="main">
            <article class="article">
                <div class="article-style">
                    
                    <details class="toc-inpage d-print-none d-show-block mb-0">
  <summary class="font-weight-bold">点击查看目录</summary>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#smi-介绍">SMI 介绍</a>
      <ul>
        <li><a href="#smi-是什么">SMI 是什么？</a></li>
        <li><a href="#smi-推出的背景">SMI 推出的背景</a></li>
        <li><a href="#和通用数据平面-api-的关系">和通用数据平面 API 的关系</a></li>
        <li><a href="#smi-的目标和愿景">SMI 的目标和愿景</a></li>
        <li><a href="#smi-社区">SMI 社区</a></li>
      </ul>
    </li>
    <li><a href="#smi-规范内容">SMI 规范内容</a>
      <ul>
        <li><a href="#smi-规范介绍">SMI 规范介绍</a></li>
        <li><a href="#traffic-spec">Traffic Spec</a></li>
        <li><a href="#traffic-access-control">Traffic Access Control</a></li>
        <li><a href="#traffic-split">Traffic Split</a></li>
        <li><a href="#traffic-metrics">Traffic Metrics</a></li>
        <li><a href="#smi-规范总结">SMI 规范总结</a></li>
      </ul>
    </li>
    <li><a href="#smi-分析">SMI 分析</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
</details>

                    
                    <h2 id="smi-介绍">SMI 介绍</h2>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi-logo_0_hucf02f41cc9df2be031d1e1ef963bcd3e_174168_becf6e837045bd8e725d1bcdba18b365.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-logo_0_hucf02f41cc9df2be031d1e1ef963bcd3e_174168_17403a8066ca1498d2e6d8fad24b0477.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-logo_0_hucf02f41cc9df2be031d1e1ef963bcd3e_174168_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi-logo_0_hucf02f41cc9df2be031d1e1ef963bcd3e_174168_becf6e837045bd8e725d1bcdba18b365.webp"
               width="760"
               height="285"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<h3 id="smi-是什么">SMI 是什么？</h3>
<p>5 月 21 号，在 kubeconf 上，微软联合一众小伙伴，宣布了 Service Mesh Interface，简称 SMI。SMI 是一个服务网格规范，定义了通用标准，包含基本特性以满足大多数场景下的通用需求。</p>
<p>援引来自 SMI 官方网站  <a href="https://smi-spec.io/" target="_blank" rel="noopener">smi-spec.io</a> 的介绍资料，对 Service Mesh Interface 的定位是：</p>
<blockquote>
<p>A standard interface for service meshes on Kubernetes.</p>
<p>Kubernetes 上的 service mesh 的标准接口</p>
</blockquote>
<p>微软的 <a href="https://msft.today/hello-service-mesh-interface-smi-a-specification-for-service-mesh-interoperability/" target="_blank" rel="noopener">官方博客文章</a> 这样介绍 SMI：</p>
<blockquote>
<p>SMI 定义了一组通用可移植的 API，为开发人员提供跨不同服务网格技术的互通性，包括 Istio，Linkerd 和 Consul Connect。</p>
</blockquote>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi_hue067cd03c432825a991fe42f07cb55ae_66488_3452a0e1f6fbfe02de4c61b373b57b22.webp 400w,
               /blog/service-mesh-interface-detail/images/smi_hue067cd03c432825a991fe42f07cb55ae_66488_ff5fe6a5763b84da7c93c27d384660b0.webp 760w,
               /blog/service-mesh-interface-detail/images/smi_hue067cd03c432825a991fe42f07cb55ae_66488_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi_hue067cd03c432825a991fe42f07cb55ae_66488_3452a0e1f6fbfe02de4c61b373b57b22.webp"
               width="760"
               height="407"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>SMI 是希望在各家 Service Mesh 的实现之上建立一个抽象的 API 层，然后通过这个抽象来解耦和屏蔽底层 Service Mesh 实现，让上层的应用、工具、生态系统可以建立在一个业界标准之上，从而实现跨不同实现的可移植性和互通性。</p>
<h3 id="smi-推出的背景">SMI 推出的背景</h3>
<p><a href="https://medium.com/@idit.levine_92620" target="_blank" rel="noopener">Idit Levine</a>，初创公司 solo.io 的创始人兼 CEO，作为 SMI 推出的重要力量之一，撰文描述了 SMI 推出的背景：</p>
<blockquote>
<p>服务网格生态系统正在兴起，众多的网格供应商和不同的用例需要不同的技术。所以问题来了：我们如何实现在不破坏最终用户体验的前提下促进行业创新？通过以一组标准 API 达成一致，我们可以提供互通性，并在不同网格以及为这些网格构建的工具之上维持最终用户体验。</p>
<p>今天发布的 Service Mesh Interface（SMI）是使这一构想走向行业现实的重要一步。</p>
</blockquote>
<p>下面这幅图片可以非常清晰的表述 SMI 的定位，也可以帮助我们一起来解读 SMI 推出的背景：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/SMI-Graphic_huf950c6cd76d5c9b3c4de86291dbc7552_67903_43c079d513d7e6285043bddc4222c480.webp 400w,
               /blog/service-mesh-interface-detail/images/SMI-Graphic_huf950c6cd76d5c9b3c4de86291dbc7552_67903_064b81791e1fec67f6d40eb8735e5937.webp 760w,
               /blog/service-mesh-interface-detail/images/SMI-Graphic_huf950c6cd76d5c9b3c4de86291dbc7552_67903_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/SMI-Graphic_huf950c6cd76d5c9b3c4de86291dbc7552_67903_43c079d513d7e6285043bddc4222c480.webp"
               width="760"
               height="400"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<ol>
<li>
<p>Service Mesh 的价值正在被普遍认可：从最早的 Linkerd，Envoy，到两年前 Google 力推 Istio，以及 Linkerd2 的推出，最近 AWS 推出了 App Mesh，Google 则将 Istio 搬上了 Google Cloud 推出了 Istio 的公有云托管版本 Google Cloud Service Mesh，还推出了单独的控制平面产品 Google Traffic Director。微软也在去年推出了 Azure 完全托管版本的 Service Fabric Mesh（预览版）。云市场三巨头都已经先后出手。</p>
</li>
<li>
<p>市场上出现了众多的 Service Mesh 产品：开源的，闭源的，大公司出的，小公司出的，市场繁荣的同时也带来了市场碎片化的问题。</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi-background_hua010eb3c76f7874df1dec2d38b3aff79_26238_4bf1c5ac67f47cfd1ce2755a814ddf3d.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-background_hua010eb3c76f7874df1dec2d38b3aff79_26238_1994bc4255e5c62f8d2e042c3dcb6b26.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-background_hua010eb3c76f7874df1dec2d38b3aff79_26238_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi-background_hua010eb3c76f7874df1dec2d38b3aff79_26238_4bf1c5ac67f47cfd1ce2755a814ddf3d.webp"
               width="760"
               height="234"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
</li>
<li>
<p>在云原生理念下，我们推崇应用轻量化，只关注业务逻辑。Service Mesh 技术很好的实现了这一战略目标：运行在 service mesh 上的应用可以和底层 service mesh 的具体实现解耦。理论上应用在不同的 service mesh 实现上迁移是可行的，从这一点说，service mesh 在云原生的道路上迈出了重要一步。</p>
</li>
<li>
<p>但是，所有围绕业务应用的外围工作，比如通过 service mesh 对流量进行控制，配置各种安全/监控/策略等行为，以及在这些需求上建立起来的工具和生态系统，却不得不牢牢的绑死在某个具体的 service mesh 实现上，所谓&quot;供应商锁定&quot;。</p>
</li>
<li>
<p>其根本问题在于各家实现不同，又没有统一标准。因此，要想解决上述问题，就必须釜底抽薪：<strong>解决 Service Mesh 的标准化问题</strong>。</p>
</li>
</ol>
<p>微软给出的解决方案就是引入 SMI，作为一个通用的行业规范/标准，如果能让各家 service mesh 提供商都遵循这个标准，则有机会在具体的 service mesh 产品之上，抽象出一个公共层（如定义一组通用可移植的 API），屏蔽掉上层应用/工具/生态系统对具体  service mesh 产品的实现细节。</p>
<p>是不是觉得 SMI 的概念有种熟悉的味道？是的，没错，类似的事情在 k8s 中之前就发生过很多次，比如 CNI、CRI、CSI，还有下图展示的 Ingress：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi-concept_huc5791978df35e412dde1e82e0c68d860_39768_ac22aad3f7c20c51e7047179d69f24e0.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-concept_huc5791978df35e412dde1e82e0c68d860_39768_3739f495ff18bb1224638149e8b0bcff.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-concept_huc5791978df35e412dde1e82e0c68d860_39768_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi-concept_huc5791978df35e412dde1e82e0c68d860_39768_ac22aad3f7c20c51e7047179d69f24e0.webp"
               width="760"
               height="416"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>在 SMI 中，将这个目标称为 &ldquo;<strong>Interoperability</strong>&rdquo; / 互通性。我个人理解，这其实和 google 一直在倡导的 &ldquo;not lock-in&rdquo; 是一个概念：有通用的社区标准/行业标准，在此基础上客户可以在多个实现/多个供应商之间自由选择和迁移，没有被绑定的风险，而且提供给用户的功能以及使用方式也保持一致，也就是 Idit Levine 所强调的 &ldquo;维持最终用户体验&rdquo;。</p>
<p>从这个角度说，我很欣喜的看到 SMI 的推出，虽然这条路可能不是那么容易走，但是，的确，&ldquo;Service Mesh Interface（SMI）是使这一构想走向行业现实的重要一步&rdquo;。</p>
<h3 id="和通用数据平面-api-的关系">和通用数据平面 API 的关系</h3>
<p>在 SMI 提出来之前不久（大概早两个星期），CNCF 也在进行类似的标准化操作：CNCF 正在筹建通用数据平面 API 工作组（Universal Data Plane API Working Group / UDPA-WG)，以制定数据平面的标准 API，为 L4/L7 数据平面配置提供事实上的标准，初始成员将包括 Envoy 和 gRPC 项目的代表。事实上是 Google 在驱动，主要参与的项目是 Istio 和 Envoy。</p>
<p>下面这张图片展示 UDPA 和 SMI 这两个新近推出的 Service Mesh 标准 API 的关系：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/two-api_hu834b9409e5efcfeec3453bd0b86d086d_7459_144d2e2c25709033f598b7be83ccb659.webp 400w,
               /blog/service-mesh-interface-detail/images/two-api_hu834b9409e5efcfeec3453bd0b86d086d_7459_0377338e7124e1eadb4d1308cdbaa252.webp 760w,
               /blog/service-mesh-interface-detail/images/two-api_hu834b9409e5efcfeec3453bd0b86d086d_7459_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/two-api_hu834b9409e5efcfeec3453bd0b86d086d_7459_144d2e2c25709033f598b7be83ccb659.webp"
               width="600"
               height="546"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<ul>
<li>Universal Data Plane API 是数据平面的标准，控制平面通过这个 API 来控制数据平面的行为。工作组的初始成员来自包括 Envoy 和 gRPC 项目的代表，<strong>背后的公司主要是 Google</strong> 。</li>
<li>Service Mesh Interface 是控制平面的标准，上层的应用/工具/生态体系通过 Service Mesh Interface 来实现跨不同的 Service Mesh 实现为最终用户提供一致性的体验。<strong>SMI 由微软牵头</strong>，联合 Linkerd，HashiCorp，Solo，Kinvolk 和 Weaveworks。</li>
</ul>
<h3 id="smi-的目标和愿景">SMI 的目标和愿景</h3>
<p>关于 SMI 的目标和愿景，我援引  Idit Levine 的这段话（这段话也同样出现在 smi-spec 的 github 首页）：</p>
<blockquote>
<p>SMI 是在 Kubernetes 上运行服务网格的规范。它定义了由各种供应商实现的通用标准。这使得最终用户的标准化和服务网格供应商的创新可以两全其美。SMI 实现了灵活性和互通性。</p>
</blockquote>
<p>更详细而明确的目标描述来自 smi-spec 的 github 首页：</p>
<blockquote>
<p>目标</p>
<p>SMI API 的目标是提供一组通用的，可移植的 Service Mesh API，Kubernetes 用户可以以供应商无关的方式使用这些 API。通过这种方式，可以定义使用 Service Mesh 技术的应用程序，而无需紧密绑定到任何特定实现。</p>
</blockquote>
<p>然后还特别强调：</p>
<blockquote>
<p>非目标</p>
<p><strong>SMI 项目本身不实现服务网格</strong>。SMI 只是试图定义通用规范。同样，SMI 不定义服务网格的具体范围，而是一个通用子集。欢迎 SMI 供应商添加超出 SMI 规范的供应商特定扩展和 API。我们希望随着时间的推移，随着更多功能被普遍接受为服务网格的一部分，这些定义将迁移到 SMI 规范中。</p>
</blockquote>
<p>总结：首先非常明确的一点是，SMI 是定义标准 API，而不是标准实现。</p>
<p>而 SMI 的具体目标，在 SMI 的官方网站是这样介绍的：</p>
<ol>
<li>A standard interface for service meshes on Kubernetes: Kubernetes 上的 service mesh 的标准接口</li>
<li>A basic feature set for the most common service mesh use cases：用于最通用的服务网格用例的基本特性</li>
<li>Flexibility to support new service mesh capabilities over time：随着时间的推移灵活地支持新的服务网格能力</li>
<li>Space for the ecosystem to innovate with service mesh technology: 使用服务网格技术实现生态系统创新的空间</li>
</ol>
<h3 id="smi-社区">SMI 社区</h3>
<p>有需求，有市场，有想法，有目标，我们再来看看 SMI 阵营现在都有什么力量。</p>
<p>微软在推出 SMI 时的描述到：SMI 是一个开放项目，由微软，Linkerd，HashiCorp，Solo，Kinvolk 和 Weaveworks 联合启动; 并得到了 Aspen Mesh，Canonical，Docker，Pivotal，Rancher，Red Hat 和 VMware 的支持。</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/partnership_hu8b8e739fb31f702a6167d7b0cb5a0704_89745_ee42d6b46f35fcff5bb5d1dad4796639.webp 400w,
               /blog/service-mesh-interface-detail/images/partnership_hu8b8e739fb31f702a6167d7b0cb5a0704_89745_1c5cf5a3d961998a7237c99c084fbfaa.webp 760w,
               /blog/service-mesh-interface-detail/images/partnership_hu8b8e739fb31f702a6167d7b0cb5a0704_89745_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/partnership_hu8b8e739fb31f702a6167d7b0cb5a0704_89745_ee42d6b46f35fcff5bb5d1dad4796639.webp"
               width="760"
               height="283"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>阵营还是挺强大的：</p>
<ul>
<li>微软：SMI 的带头大哥，云计算的三巨头之一</li>
<li>Buoyant：Service Mesh 技术的拓荒牛 + 布道者，小而弥坚的初创公司，有一个不大但是力量很强又非常有经验还很务实的团队。其旗下的 Linkerd2 已经明确表示将支持 SMI。</li>
<li>HashiCorp：大名鼎鼎的 consul 就出自这里，Consul Connect 也是目前活跃的 service mesh 实现之一，虽然 Consul Connect 在国内知名度和影响力都很小（也就年度总结的时候捎带着看一眼状态的那种）。Consul Connect 目前也表示提供了对 SMI 的支持。</li>
<li>Solo.io：深藏不露的初创型小公司，&ldquo;产品面很广，除了 Service Mesh 方面大有名气的 SuperGloo 和 Service Mesh hub 之外，还有远程调试、混沌工程、unikernels 以及微服务网关等几个产品。&quot;（这段话我从秀龙的文章里面抄过来的，总结的很好）。另外，业界网红 Christian Posta 前段时间加入这家公司。solo 公司旗下的 SuperGloo 是业界第一个 service mesh 编排产品，因此对 SMI 的热爱和支持是无可复加的。SuperGloo 和 Service Mesh Hub 已经实现了对 SMI 的支持。</li>
<li>Mesery 和 Kinvolk：这两家公司最近在 service mesh 社区有点名气，因为他们近期做了 Istio vs Linkerd 的性能测试并给出了报告，闹的满城风雨。而且他们也都喜欢用 solo 出的 SuperGloo（毕竟业界号称 service mesh 编排的也就独此一家）。</li>
<li>Aspen Mesh：F5（没错，就是那个巨贵的 F5）出的的 Istio 商业版本。但是没有看到 Aspen Mesh 给出支持 SMI 的信息，暂时还不知道 Aspen Mesh 和 SMI 的关系。</li>
<li>vmware：vmware 在 2018 年底推出了 VMware NSX Service Mesh，和 Aspen Mesh 一样也是基于 Istio。</li>
</ul>
<p>其他公司就不再一一列出来了，主要是不清楚他们在 SMI 这个事情上扮演什么角色。</p>
<p>而关键点在于，Google（还有同属 Istio 阵营的 IBM / Lyft）不在其列。而 Service Mesh 的其他玩家，几乎都参与了 SMI，甚至包括原本在 Istio 项目上和 google 一直合作的公司，耐人寻味。</p>
<h2 id="smi-规范内容">SMI 规范内容</h2>
<h3 id="smi-规范介绍">SMI 规范介绍</h3>
<p>Service Mesh Interface 规范涵盖最常见服务网格能力：</p>
<ul>
<li>Traffic Policy/流量策略 - 跨服务应用身份和传输加密等策略</li>
<li>Traffic Telemetry/流量遥测 - 捕获关键指标，如错误率和服务间的延迟</li>
<li>Traffic Management/流量管理 - 在不同服务之间转移流量</li>
</ul>
<p>SMI 规范由多个 API 组成：</p>
<ul>
<li>Traffic Access Control/流量访问控制 - 根据客户端的身份配置对特定 pod 和路由的访问，以将应用程序锁定到仅允许的用户和服务。</li>
<li>Traffic Specs/流量规范 - 定义流量的表示方式，基于每个协议的基础。这些资源与访问控制和其他类型的策略协同工作，以在协议级别管理流量。</li>
<li>Traffic Split/流量分割 - 逐步引导各种服务之间的流量百分比，以帮助构建金丝雀推出。</li>
<li>Traffic Metrics/流量指标 - 暴露通用的流量指标，供 dashboard 和 autoscaler 等工具使用。</li>
</ul>
<p>注意：SMI 被指定为 Kubernetes Custom Resource Definitions（CRD）和 Extension API Servers 的集合。这些 API 可以安装到 Kubernetes 集群上，并使用标准工具进行操作。</p>
<p>在设计上，SMI 强调 &ldquo;Provider Agnostic（供应商无关）&quot;：</p>
<blockquote>
<p>SMI API 的目标是提供一组通用的可移植的服务网格 API，Kubernetes 用户可以以供应商无关的方式使用这些 API。通过这种方式，人们可以定义使用服务网格技术的应用程序，而无需紧密绑定到任何特定实现。</p>
</blockquote>
<p>下面我们来详细看一下 SMI 规范的具体 API 定义，其定义来自 <a href="https://github.com/deislabs/smi-spec" target="_blank" rel="noopener">https://github.com/deislabs/smi-spec</a>。</p>
<h3 id="traffic-spec">Traffic Spec</h3>
<p>Traffic Spec 资源用于让用户定义流量。通常与 Access Control（访问控制）和其他策略一起使用，以具体定义需要如何处理流经网格的特定类型流量。</p>
<p>用户往往希望在服务网格内运行许多不同的协议。当然，主要会是 HTTP，但也会有其他协议。Traffic Spec 规范中的每个资源都旨在与特定协议 1:1 匹配。这让用户可以以协议特定的方式来定义流量。</p>
<p><strong>HTTPRouteGroup</strong></p>
<p>HTTPRouteGroup 资源用于描述HTTP/1和HTTP/2流量，它枚举了应用程序可以提供的路由。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">specs.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">HTTPRouteGroup</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">the-routes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">matches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">metrics</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pathRegex</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;/metrics&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">methods</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="l">GET</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">health</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pathRegex</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;/ping&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">methods</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;*&#34;</span><span class="p">]</span><span class="w">
</span></span></span></code></pre></div><p>上面的例子定义两个<code>match</code>，<code>metrics</code>和<code>health</code>。name 字段是 key，所有字段都是必需的。正则表达式用于匹配 URI。HTTP Mesh 可以具体制定如 <code>GET</code> 或用 <code>*</code> 来匹配所有。</p>
<p>HTTPRouteGroup 当前的功能限制（未来会加入，只是当前作为第一个版本内容还比较少）：</p>
<ol>
<li>只支持 HTTP 协议，连 gRPC 都还未支持</li>
<li><code>match</code> 字段当前仅适用于 <code>URI</code>。很明显这是不够的，未来计划扩展以支持 HTTP header，Host 等。</li>
</ol>
<blockquote>
<p>个人看法：目前在只有 HTTP 协议支持，而且 HTTP 路由定义居然不支持 HTTP header 匹配，足够说明目前 SMI 的确是处于项目早期状态。</p>
</blockquote>
<p><strong>TCPRoute</strong></p>
<p>TCPRoute 资源用于描述 L4 TCP 流量。这个路由极其简单（或者叫做简陋），定义应用程序接收到的原始的、无协议特征的流量。</p>
<p>看完下面的 yaml 例子就明白为什么称为极其简单了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">specs.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">TCPRoute</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">tcp-route</span><span class="w">
</span></span></span></code></pre></div><p>上面的路由只做了定义，尚未与任何资源相关联。我们继续看如何使用，比如与 Access Control 配合。</p>
<h3 id="traffic-access-control">Traffic Access Control</h3>
<p>Traffic Access Control 资源用来为应用程序定义访问控制策略：</p>
<ol>
<li>访问控制属于授权（authorization）范畴，默认身份验证（Authentication）已经由底层实现处理</li>
<li>SMI 规范中的访问控制是附加的，默认情况下<strong>拒绝所有流量</strong>。</li>
</ol>
<p><strong>TrafficTarget 规范</strong></p>
<p>TrafficTarget 规范用来定义流量访问控制，而 SMI 中访问控制是基于服务身份（service identity）的，并且目前只支持通过 Kubernetes service account 来指派服务身份（其他身份机制将在稍后支持）。</p>
<p>流量访问控制有三个概念，分别在 TrafficTarget 中以三个字段定义：</p>
<ol>
<li>Source：流量的来源，体现为具体的 Pod 列表，目前支持通过 selector 来实现，暂时不支持以资源的方式选择（如指定 Deployment、指定 Service）</li>
<li>Destination：流量的目标，同样体现为具体的 Pod 列表，也只支持 selector</li>
<li>Route：流量规范，用来区分 Destination 提供的多种不同的流量访问方式，如下图中的 api 访问和获取 metrics 信息</li>
</ol>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu1a80834f3fdabb2007352c0d7fad5c41_126874_ca7b274b929a66b6db3dbaef4b014394.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu1a80834f3fdabb2007352c0d7fad5c41_126874_8d070d07363e74e3b0a8899b97c37710.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu1a80834f3fdabb2007352c0d7fad5c41_126874_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi-traffic-target_hu1a80834f3fdabb2007352c0d7fad5c41_126874_ca7b274b929a66b6db3dbaef4b014394.webp"
               width="760"
               height="350"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>在这个例子中，展示对 api 进行访问和获取 metrics 信息这两个操作的流量访问控制：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># 定义 TrafficSpec</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">specs.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">HTTPRouteGroup</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service-routes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">matches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api </span><span class="w"> </span><span class="c"># api 访问的流量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">pathRegex</span><span class="p">:</span><span class="w"> </span><span class="l">/api</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">methods</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;*&#34;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">metrics</span><span class="w"> </span><span class="c"># 获取 metrics 的流量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">pathRegex</span><span class="p">:</span><span class="w"> </span><span class="l">/metrics</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">methods</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;GET&#34;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">TrafficTarget</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">access.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service-metrics</span><span class="w"> </span><span class="c"># 定义获取 metrics 的 Target</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="l">destination:	# 通过 ServiceAccount 选择 pods</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ServiceAccount</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">specs</span><span class="p">:</span><span class="w"> </span><span class="c"># 引用 traficSec 定义的 route，指定为获取 metrics</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">HTTPRouteGroup</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service-routes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">matches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">metrics</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">sources</span><span class="p">:</span><span class="w"> </span><span class="c"># 通过 ServiceAccount 选择 pods</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ServiceAccount</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">prometheus</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">TrafficTarget</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">access.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service-api</span><span class="w"> </span><span class="c"># 定义访问 api 接口的 Target</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">destination</span><span class="p">:</span><span class="w"> </span><span class="c"># 通过 ServiceAccount 选择 pods</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ServiceAccount</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">specs</span><span class="p">:</span><span class="w"> </span><span class="c"># 引用 traficSec 定义的 route，指定为 api 访问</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">HTTPRouteGroup</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service-routes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">matches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">api</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">sources</span><span class="p">:</span><span class="w"> </span><span class="c"># 通过 ServiceAccount 选择 pods</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ServiceAccount</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">website-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ServiceAccount</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">payments-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span></code></pre></div><p>上述实例定义了两个容许的访问控制：</p>
<ol>
<li>对于以 ServiceAccount 为 api-service 运行的 pods，容许来自以 ServiceAccount 为 prometheus 的 pods 访问 api-service-routes 定义下的 metrics 路由</li>
<li>对于以 ServiceAccount 为 api-service 运行的 pods，容许来自以 ServiceAccount 为 website-service 和 payments-service  的 pods 访问 api-service-routes 定义下的 api 路由</li>
</ol>
<p>其中有部分字段为可选字段：</p>
<ul>
<li>matches 字段：如果省略，则对 TrafficSpec 下定义的所有 Route 都生效</li>
<li>Port 字段：如果省略，则表示所有端口</li>
</ul>
<p>SMI 流量访问控制的规则是默认都不容许访问，只有通过 TrafficTarget 指定的符合条件的流量才容许访问。而访问控制的执行，是明确要求在访问的服务器端（即 Destination）强制执行，而是否在客户端（即 Source）进行访问控制则由 SMI 的具体实现来决定。</p>
<p>注意目前 Traffic Access Control 在定义 Source 和 Destination 时，都是通过 Selector 来定义的，我们细看这张图片：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu1a80834f3fdabb2007352c0d7fad5c41_126874_ca7b274b929a66b6db3dbaef4b014394.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu1a80834f3fdabb2007352c0d7fad5c41_126874_8d070d07363e74e3b0a8899b97c37710.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu1a80834f3fdabb2007352c0d7fad5c41_126874_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi-traffic-target_hu1a80834f3fdabb2007352c0d7fad5c41_126874_ca7b274b929a66b6db3dbaef4b014394.webp"
               width="760"
               height="350"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>从访问控制的业务语义上看，上面两个 TrafficTarget 翻译出来就是：</p>
<ul>
<li>容许以 ServiceAccount prometheus 运行的服务访问以 ServiceAccount api-service 运行的服务的 metrics</li>
<li>容许以 ServiceAccount web-service 和 payment-service 运行的服务访问以 ServiceAccount api-service 运行的服务的 api</li>
</ul>
<p>而不是我们平时熟悉的资源方式如&quot;容许 A 服务访问 B 服务&rdquo;，即访问控制中对服务的标示目前只能通过 ServiceAccount + Selector 来完成，而不是通过简单的服务 Id 或者名称来指定资源。请注意&quot;容许以身份 A 运行的服务访问以身份 B 运行的服务&rdquo; 和 &ldquo;容许 A 服务访问 B 服务&rdquo; 的细微差别。</p>
<p>关于这一点，在 SMI 的文档的&quot;Tradeoffs&quot;中提到：</p>
<blockquote>
<p>Resources vs selectors - it would be possible to reference concrete resources such as a deployment instead of selecting across pods.</p>
<p>资源 vs 选择器 - 可以引用具体资源（如 deployment）而不是 pod 选择。</p>
</blockquote>
<h3 id="traffic-split">Traffic Split</h3>
<p>Traffic Split 资源用来实现流量的百分比拆分，熟悉 Istio 的同学应该非常了解这个功能的强大。</p>
<p>但是 SMI 中 Traffic Split 的配置方式和 Istio 有非常大的不同，比如下面的配置，要对 foobar 服务按照版本进行流量拆分，v1 和 v2 权重分别为 1 和 500m（1=1000m），在 Traffic Split 的配置中会出现多个 service：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">split.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">TrafficSplit</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">foobar-rollout</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">service</span><span class="p">:</span><span class="w"> </span><span class="l">foobar</span><span class="w"> </span><span class="c"># root service，客户端用这个服务名来连接目标应用</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">backends</span><span class="p">:</span><span class="w"> </span><span class="c"># root service 后面的服务，有自己的 selectors, endpoints 和 configuration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">service</span><span class="p">:</span><span class="w"> </span><span class="l">foobar-v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">service</span><span class="p">:</span><span class="w"> </span><span class="l">foobar-v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="l">500m</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>&ldquo;foobar&rdquo;：通过 <code>spec.service</code> 指定，这是 Traffic Split 的 root service，是要配置进行流量拆分的目标服务的 FQDN，客户端用这个 service 进行通信，也就是说这个 root service 是暴露给客户端的。</li>
<li>&ldquo;footer-v1&rdquo; 和 &ldquo;footer-v2&rdquo;：这两个后端服务，是&quot;隐藏&quot;在 root service 后面的，通常是 root service 的子集，典型实现上是 selector 多加一个 version label 限制。</li>
</ul>
<p>这样，如果要对某个服务的两个子集进行流量拆分，典型如版本 v1 和版本 v2，在 SMI 中就会有三个 k8s service 定义：</p>
<table>
<thead>
<tr>
<th>资源</th>
<th>selector（label）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>service foobar</td>
<td><code>app: foobar</code></td>
<td>root service</td>
</tr>
<tr>
<td>service foobar-v1</td>
<td><code>app: foobar</code>, <code>version: v1</code></td>
<td>backend service</td>
</tr>
<tr>
<td>service foobar-v2</td>
<td><code>app: foobar</code>, <code>version: v2</code></td>
<td>backend service</td>
</tr>
</tbody>
</table>
<p>这三个 service 和 pod 的关系如下图所示：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi-traffic-split_hu81b6a5f99669d0f451b9935b19e79e4f_172544_3ced55883d065a1b45f524015fb38f78.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-traffic-split_hu81b6a5f99669d0f451b9935b19e79e4f_172544_e9f5170bc2a4d4ca5fc55d2a5bde82f2.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-traffic-split_hu81b6a5f99669d0f451b9935b19e79e4f_172544_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi-traffic-split_hu81b6a5f99669d0f451b9935b19e79e4f_172544_3ced55883d065a1b45f524015fb38f78.webp"
               width="760"
               height="358"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>我们来对比 Istio 中实现类似功能的方式，Istio 中需要为准备进行流量拆分的服务定义 VirtualService，通过 subset 来区分不同的流量去向：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">networking.istio.io/v1alpha3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">VirtualService</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">foobar-route</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">hosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="l">foobar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">http</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">route</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">destination</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">foobar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">subset</span><span class="p">:</span><span class="w"> </span><span class="l">v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="m">25</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">destination</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">foobar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">subset</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="m">75</span><span class="w">
</span></span></span></code></pre></div><p>subset 在 DestinationRule 中定义，注意这里只涉及到 labels，服务（以 host 标志）并没有多个，还是 foobar：</p>
<pre tabindex="0"><code class="language-yam" data-lang="yam">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: foobar-destination
spec:
  host: foobar
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
</code></pre><p>在 Istio 中，service 和 subset 的关系如下图所示：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/istio-traffic-split_hua9ef5b57ae65512a42ec4750d71d28e0_160644_0e1eafff0b0689869fc5185f099dff0a.webp 400w,
               /blog/service-mesh-interface-detail/images/istio-traffic-split_hua9ef5b57ae65512a42ec4750d71d28e0_160644_371bac623f726a874283345d8cb67c75.webp 760w,
               /blog/service-mesh-interface-detail/images/istio-traffic-split_hua9ef5b57ae65512a42ec4750d71d28e0_160644_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/istio-traffic-split_hua9ef5b57ae65512a42ec4750d71d28e0_160644_0e1eafff0b0689869fc5185f099dff0a.webp"
               width="760"
               height="358"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>可以看到 SMI 中的 backend service 和 Istio 中的 subset 在功能上几乎是对等的。</p>
<p>但是：SMI 和 Istio 的根本差异在于 Istio 中的 subset 是一个虚拟的抽象对象，在 k8s 中并没有实体资源。而在 SMI 中，backend service 是实实在在存在的 k8s service 资源。</p>
<p>这里个人觉得有一个隐忧：在 SMI 中，为了进行流量拆分，就不得不为每个版本建立一个独立的 k8s service，service 数量会比 Istio 方案多很多。</p>
<p>另外就是在权重设置上的细微的差别，SMI 用的是相对 weight（比如可以设置为 1:2），而 Istio 是严格的百分比，而且要求总和为 100。</p>
<h3 id="traffic-metrics">Traffic Metrics</h3>
<p>Traffic Metrics 资源提供通用集成点，工具可以通过访问这些集成点来抓取指标。Traffic Metrics 遵循 <code>metrics.k8s.io</code> 的模式，其即时指标可用于各种 CLI 工具，HPA 伸缩等。</p>
<p>和大多数 Metrics 系统一致，SMI 的 Traffic Metrics 数据包含两个核心对象：</p>
<ol>
<li>Resource：Metrics 和资源绑定，资源可以是 pod 和更高级别的概念如 namespaces, deployments 或者 services。Pod 是 Metrics 可以关联的最细粒度的资源，通过集合可以得到推断出其他。</li>
<li>Edge：表示流量来源或其目的地，描述力量的方向。</li>
</ol>
<p><strong>TrafficMetrics</strong></p>
<p>TrafficMetrics 是核心资源，关联到资源，具有 edge，延迟百分位数和请求量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">metrics.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">TrafficMetrics</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">resource</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">foo-775b9cbd88-ntxsl</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">foobar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">edge</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">direction</span><span class="p">:</span><span class="w"> </span><span class="l">to</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">resource</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">baz-577db7d977-lsk2q</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">foobar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">timestamp</span><span class="p">:</span><span class="w"> </span><span class="ld">2019-04-08T22:25:55Z</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">window</span><span class="p">:</span><span class="w"> </span><span class="l">30s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metrics</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">p99_response_latency</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">unit</span><span class="p">:</span><span class="w"> </span><span class="l">seconds</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="l">10m</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">p90_response_latency</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">unit</span><span class="p">:</span><span class="w"> </span><span class="l">seconds</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="l">10m</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">p50_response_latency</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">unit</span><span class="p">:</span><span class="w"> </span><span class="l">seconds</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="l">10m</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">success_count</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="m">100</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">failure_count</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="m">100</span><span class="w">
</span></span></span></code></pre></div><p>TrafficMetrics 的定义和使用暂时没看到有特殊之处。</p>
<h3 id="smi-规范总结">SMI 规范总结</h3>
<p>从上面我们详细分析的 SMI 主要规范的定义看，Traffic Access Control / Traffic Specs / Traffic Split / Traffic Metrics 这四个目前定义好的规范，无论从功能还是从 API 设计上看，都缺乏亮点，至少与目前大家熟悉的 Istio API 相比，没有明显优势：</p>
<ul>
<li>Traffic Specs 中 HTTPRouteGroup 只支持 HTTP1.1，甚至不支持 header，TCPRoute 更是简陋到极致</li>
<li>Traffic Access Control 只支持 ServiceAccount</li>
<li>Traffic Split：需要为每个需要拆分的流量额外增加 k8s service</li>
<li>TrafficMetrics：平平无奇</li>
</ul>
<p>考虑到目前 SMI 还是第一个版本，处于项目早期阶段，不够成熟情有可原，我们更要关注的是其后续版本的演进，希望未来 SMI 可以成长为一个足够坚实而可用的标准 API。</p>
<h2 id="smi-分析">SMI 分析</h2>
<p>前面我们分析过 SMI 推出的背景，我归结为关键的两点：</p>
<ol>
<li>有利可图：Service Mesh 技术被普遍看好，其长远价值被各大厂商认可</li>
<li>有机可趁：作为市场领头羊的 Google 和 Istio，表现疲软</li>
</ol>
<p>另外 Google 在 Istio 项目上，表现也有些令人费解：</p>
<ol>
<li>迟迟不进 CNCF：早先还有未能发布 1.0 版本不满足 CNCF 要求的借口，而最近则感觉 Google 一直在避免讨论这个话题</li>
<li>Istio 一直没有对 Service Mesh 技术进行标准化：只关注自己的 Istio API，对于标准化和基于标准化构建生态系统完全没兴趣。即便是统一数据平面 API 的标准化动作，也让人觉得是 Envoy 在推动。</li>
<li>宣传和现实的差距：Istio 1.0 的 &ldquo;Product Ready&rdquo;，1.1 版本的&quot;Enterprise Ready&quot;，很让人无语，我很期待 1.2 版本出来时的口号。</li>
<li>架构设计的不务实：Mixer 是被嘲弄的重灾区，躲在 Mixer 身后的 Pilot 其实问题也一堆，而 Mixer v2 的进展则成为衡量 Istio 未来走向的风向标，是要成为工业级可用的坚实产品，还是继续摆弄优雅架构做花瓶？未来一年我们拭目以待。</li>
<li>整个社区对 Istio 的不满情绪一直在酝酿和累积：这次 SMI 推出引发的轰动，很大程度是这种情绪的发泄——除了 Google 之外几乎所有的 Servic Mesh 的玩家都参与进来了，这就足够说明问题了。</li>
</ol>
<p>在过去两年，社区一直在期待 Google 和 Istio，但是，这种期待在持续两年的失望之后，开始转向另外的方向：或许我们要更多的考虑 Istio 之外的选择了。</p>
<p>Service Mesh 的战争，我们原以为会以 Istio 的胜利而迅速结束，但是现在看来，可能这场战争才刚刚开始。</p>
<p>是重新认真审视这张图片的时候了：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/gartner_hue78a99d7c18898fc2b96b9315fa666c5_64903_6b2199005fb2a623362a7e584e13b017.webp 400w,
               /blog/service-mesh-interface-detail/images/gartner_hue78a99d7c18898fc2b96b9315fa666c5_64903_754850765a6852c2dd54304e453d9903.webp 760w,
               /blog/service-mesh-interface-detail/images/gartner_hue78a99d7c18898fc2b96b9315fa666c5_64903_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/gartner_hue78a99d7c18898fc2b96b9315fa666c5_64903_6b2199005fb2a623362a7e584e13b017.webp"
               width="760"
               height="505"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>SMI 的推出，意义并不仅仅在于这个 Service Mesh 标准本身，而是带有另外一种特殊含义，就如陈胜吴广的揭竿而起，传递给四方的消息是：天下苦秦久矣！</p>
<p>文章最后，希望未来有更多的优秀 Service Mesh 产品出现，也希望 Istio 可以知耻而后勇。Service Mesh 技术要想成功普及，一定需要一个或者多个强力产品的出现，而 SMI 的出现则为这场短期不能结束的纷争带来了一个理论可能：无论产品竞争如何激烈，都不影响上层生态，从而避免站队失败的风险和由此带来的犹豫与观望。这才是我个人觉得 SMI 推出的最大意义所在。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://smi-spec.io/" target="_blank" rel="noopener">smi 官方网站</a></li>
<li><a href="https://github.com/deislabs/smi-spec" target="_blank" rel="noopener">smi-spec 项目@github </a></li>
<li><a href="https://www.redhat.com/en/blog/interoperability-new-service-mesh-interface" target="_blank" rel="noopener">Interoperability with the new Service Mesh Interface</a></li>
<li><a href="https://blog.fleeto.us/post/servicemesh-interface/" target="_blank" rel="noopener">意外：Servicemesh Interface（SMI）</a></li>
<li><a href="https://msft.today/hello-service-mesh-interface-smi-a-specification-for-service-mesh-interoperability/" target="_blank" rel="noopener">Hello Service Mesh Interface (SMI): A specification for service mesh interoperability</a>: 来自微软的博客，比较权威，本文很多内容是援引自此文</li>
<li><a href="https://medium.com/solo-io/service-mesh-interface-smi-and-our-vision-for-the-community-and-ecosystem-2edc7b728c43" target="_blank" rel="noopener">Service Mesh Interface (SMI) and our Vision for the Community and Ecosystem</a>：作者 <a href="https://medium.com/@idit.levine_92620" target="_blank" rel="noopener">Idit Levine</a>，是初创公司 solo.io 的创始人兼 CEO，本文同样大量援引此文的内容</li>
<li><a href="https://kccnceu19.sched.com/event/MRz7/sponsored-keynote-democratizing-service-mesh-on-kubernetes-gabe-monroy-lead-product-manager-microsoft-azure-container-compute" target="_blank" rel="noopener">Democratizing Service Mesh on Kubernetes</a>: kubecon 上宣布 SMI 的 keynote，作者 Gabe Monroy，Microsoft Azure Container Compute 的 Lead Product Manager，本文部分图片来自这个演讲的 PPT</li>
<li><a href="https://kinvolk.io/blog/2019/05/how-the-service-mesh-interface-smi-fits-into-the-kubernetes-landscape/" target="_blank" rel="noopener">How the Service Mesh Interface (SMI) fits into the Kubernetes landscape</a>: 介绍 SMI 和其他类似的 kubernetes Interface 如 CNI、CRI、CSI 等。</li>
<li><a href="https://blog.getambassador.io/kubecon-eu-2019-top-10-takeaways-123b5fcb30a8" target="_blank" rel="noopener">KubeCon EU 2019: Top 10 Takeaways</a>: 来自网红 Daniel Bryant 的文章，包含对 SMI 和 Istio 的看法。</li>
<li><a href="https://softwareengineeringdaily.com/2019/05/31/service-mesh-wars-with-william-morgan/" target="_blank" rel="noopener">Service Mesh Wars with William Morgan</a>：这是我见过的抨击 Istio 最为猛烈的一篇文章，极其火爆，又很有道理的样子</li>
<li><a href="https://www.infoworld.com/article/3400116/introducing-the-service-mesh-interface.html" target="_blank" rel="noopener">To Istio and beyond: Azure’s Service Mesh Interface</a>: 有软文嫌疑，但是还是能看出微软推出 SMI 的基本想法</li>
<li><a href="https://www.hashicorp.com/blog/hashicorp-consul-supports-microsoft-s-new-service-mesh-framework" target="_blank" rel="noopener">HashiCorp Consul supports Microsoft’s new Service Mesh Interface</a>: 介绍 Consul Connect 对 SMI 的支持</li>
</ul>

                </div>
                

<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/smi/">SMI</a>
  
  <a class="badge badge-light" href="/tag/service-mesh/">service mesh</a>
  
</div>











  
  
    



  
  
  
  
  
  <div class="media author-card content-widget-hr mb-4">
    
      
      <a href="/author/%E6%95%96%E5%B0%8F%E5%89%91/"><img class="avatar mr-3 avatar-circle" src="/author/%E6%95%96%E5%B0%8F%E5%89%91/avatar_hue38add62c87b7486d80c9f3fda25dfc1_12220_270x270_fill_q75_lanczos_center.jpg" alt="敖小剑"></a>
    

    <div class="media-body">
      <p class="card-title"><a href="/author/%E6%95%96%E5%B0%8F%E5%89%91/">敖小剑</a></p>
      
      <p class="card-text">微软</p>
      
    </div>
  </div>


  





<div class="article-widget">
  
<div class="container-xl row post-nav">
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1" href="/blog/implementing-chatops-with-jenkins-x/" rel="next">
    <div class="meta-nav">下一页</div>
    <p>使用 Jenkins X 实现 ChatOps</p></a>
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1"  href="/blog/containers-microservices-service-meshes/" rel="prev">
    <div class="meta-nav">上一页</div>
    <p>容器、微服务和服务网格简史</p></a>
  
</div>

</div>










  

<p class="edit-page">
  <a href="https://github.com/cloudnativeto/cloudnative.to/edit/master/content/blog/service-mesh-interface-detail/index.md">
    <i class="fas fa-pen pr-2"></i>编辑本页
  </a>
</p>




  
  
  <div class="article-widget content-widget-hr">
    <p class="related-title">相关推荐</p>
    <ul>
      
      <li><a href="/blog/cncf-archives-the-service-mesh-interface-smi-project/">CNCF 将服务网格接口（SMI）项目归档</a></li>
      
      <li><a href="/blog/osm-deprecated/">OSM（Open Service Mesh）项目将停止更新，团队将协力 Istio 服务网格开发</a></li>
      
      <li><a href="/blog/resiliency-app-aware-network/">利用服务网格和智能应用感知网络增强应用弹性</a></li>
      
      <li><a href="/blog/ebpf-wasm-service-mesh/">eBPF 和 Wasm：探索服务网格数据平面的未来</a></li>
      
      <li><a href="/blog/ebpf-solve-service-mesh-sidecar/">告别 Sidecar——使用 eBPF 解锁内核级服务网格</a></li>
      
    </ul>
  </div>
  





  
  
  

  

  
  <section id="comments" class="mb-3 pt-0">
    <script>
  let themeNumber = localStorage.getItem('wcTheme');
  var giscusTheme = "light";
  if (themeNumber == 1){
    giscusTheme = "dark";
  }
  let giscusAttributes = {
    "src": "https://giscus.app/client.js",
    "data-theme": giscusTheme,
    "data-repo":"cloudnativeto\/cloudnative.to",
    "data-repo-id":"MDEwOlJlcG9zaXRvcnkyMzc3NDUxOTA=",
    "data-category":"General",
    "data-category-id":"MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMyMDU5MzUy",
    "data-mapping":"pathname",
    "data-reactions-enabled":"",
    "data-emit-metadata":"0",
    "data-input-position":"top",
    "data-theme":giscusTheme,
    "data-lang":"zh-CN",
    "data-loading":"lazy",
    "crossorigin":"annoymous",
    "origins":"https://cloudnative.to",
    "originsRegex":"http://localhost:[0-9]+",
    "async": "",
  };

  let giscusScript = document.createElement("script");
  Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
  document.querySelector('#comments').appendChild(giscusScript);
</script>

  </section>
  



            </article>
        </main>
    </div>
</div>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">

  



  

  
  <div class="copyright py-4 bg-footer">
      <div class="row justify-content-center">
        <div class="text-center footer-color">
          <p class="mb-0">© 2020-2023 云原生社区保留所有权利</p>
        </div>
    </div>
  </div>

</footer>

    </div>
    
  </div>

  


<script src="/js/vendor-bundle.min.46271ef31da3f018e9cd1b59300aa265.js"></script>




  

  
  

  

  
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js" integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin="anonymous"></script>
    
    
  










  
  <script id="search-hit-fuse-template" type="text/x-template">
    <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <div class="article-metadata search-hit-type">{{relpermalink}}</div>
          <a href="{{relpermalink}}">{{title}}</a>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
    </div>
  </script>
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin="anonymous"></script>
  












  
  
  
  
  
  
  







<script id="page-data" type="application/json">{"use_headroom":false}</script>










  
  


<script src="/zh/js/wowchemy.min.24983018b0e5661cd5fe1822254286ea.js"></script>







<script>

var mybutton = document.getElementById("backTopBtn");


window.onscroll = function() {scrollFunction()};

function scrollFunction() {
  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    mybutton.style.display = "block";
  } else {
    mybutton.style.display = "none";
  }
}


function topFunction() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
<script>
  anchors.add();
</script>



<script>



(function() {
  'use strict';

  if(!document.queryCommandSupported('copy')) {
    return;
  }

  function flashCopyMessage(el, msg) {
    el.className = "highlight-copy-btn";
    el.textContent = msg;
    setTimeout(function() {
      el.textContent = "";
      el.className = "highlight-copy-btn fa fa-copy";
    }, 1000);
  }

  function selectText(node) {
    var selection = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
    return selection;
  }

  function addCopyButton(containerEl) {
    var copyBtn = document.createElement("button");
    copyBtn.className = "highlight-copy-btn fa fa-copy";
    copyBtn.textContent = "";

    var codeEl = containerEl.firstElementChild;
    copyBtn.addEventListener('click', function() {
      try {
        var selection = selectText(codeEl);
        document.execCommand('copy');
        selection.removeAllRanges();
        
        flashCopyMessage(copyBtn, '已复制')
        
      } catch(e) {
        console && console.log(e);
        flashCopyMessage(copyBtn, 'Failed :\'(')
      }
    });

    containerEl.appendChild(copyBtn);
  }

  
  var highlightBlocks = document.getElementsByClassName('highlight');
  Array.prototype.forEach.call(highlightBlocks, addCopyButton);
})();
</script>



<script>

function Collapse(e){
  var node = document.getElementById(e);
  if (node.className.indexOf('fa-angle-down') > -1){
    node.setAttribute("class", "fa-solid fa-angle-right");
    }else{
    node.setAttribute("class", "fa-solid fa-angle-down");
    }
}
</script>


</body>
</html>
