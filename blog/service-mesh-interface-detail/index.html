<!DOCTYPE html><html lang="zh" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.5.0 for Hugo" />
  

  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="云原生社区" />

  
  
  
    
  
  <meta name="description" content="微软最近宣布了 Service Mesh Interface 服务网格规范，定义了通用标准，包含基本特性以满足大多数场景下的通用需求。本文将带您深入了解 Service Mesh Interface。" />

  
  <link rel="alternate" hreflang="zh" href="https://cloudnative.to/blog/service-mesh-interface-detail/" />

  
  
  
    <meta name="theme-color" content="#0a55a7" />
  

  
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css" media="print" onload="this.media='all'">

  
  
  
    
    

    
    
    
    
      
      
    
    
    

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      
        
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.b26eb9b802629dccab300faa82cc98c7.css" />

  



  


  


  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f3dc895ea3bd6186cd835841d365c103";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_hu12a4295615259de83f102fd096a49a31_6281_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hu12a4295615259de83f102fd096a49a31_6281_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://cloudnative.to/blog/service-mesh-interface-detail/" />

  
  
  
  
  
  
  
  
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary_large_image" />
  
    <meta property="twitter:site" content="@CloudNativeCN" />
    <meta property="twitter:creator" content="@CloudNativeCN" />
  
  <meta property="og:site_name" content="云原生社区" />
  <meta property="og:url" content="https://cloudnative.to/blog/service-mesh-interface-detail/" />
  <meta property="og:title" content="Service Mesh Interface详细介绍 | 云原生社区" />
  <meta property="og:description" content="微软最近宣布了 Service Mesh Interface 服务网格规范，定义了通用标准，包含基本特性以满足大多数场景下的通用需求。本文将带您深入了解 Service Mesh Interface。" /><meta property="og:image" content="https://cloudnative.to/media/sharing.png" />
    <meta property="twitter:image" content="https://cloudnative.to/media/sharing.png" /><meta property="og:locale" content="zh" />
  
    
      <meta
        property="article:published_time"
        content="2019-06-05T15:54:19&#43;08:00"
      />
    
    <meta property="article:modified_time" content="2022-07-24T09:07:55&#43;08:00">
  

  


    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cloudnative.to/blog/service-mesh-interface-detail/"
  },
  "headline": "Service Mesh Interface详细介绍",
  
  "datePublished": "2019-06-05T15:54:19+08:00",
  "dateModified": "2022-07-24T09:07:55+08:00",
  
  "author": {
    "@type": "Person",
    "name": "敖小剑"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "云原生社区",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cloudnative.to/media/logo.svg"
    }
  },
  "description": "微软最近宣布了 Service Mesh Interface 服务网格规范，定义了通用标准，包含基本特性以满足大多数场景下的通用需求。本文将带您深入了解 Service Mesh Interface。"
}
</script>

  

  

  

  





  <title>Service Mesh Interface详细介绍 | 云原生社区</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="166e4a32c1efc5b362f37ce33badac7b" >
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden="true"></i></button>
  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.62d6f8dfe8493f1c68557dde65bec362.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6 search-title">
          <p>搜索</p>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="关闭"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="搜索..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="搜索...">
        
      </div>

      
      

      
    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

      <div id="search-common-queries">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    











  


<header class="header--fixed">
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区"
            
            ></a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="切换导航">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区"
          
          ></a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/community"><span>社区</span></a>
          </li>

          
          

          

          
          
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link  active" href="/blog"><span>博客</span></a>
          </li>

          
          

          
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>资料</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/envoy/"><span>Envoy 中文文档</span></a>
              
                <a class="dropdown-item" href="/kubebuilder"><span>Kubebuilder 中文文档</span></a>
              
            </div>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/event"><span>活动</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#feed"><span>更新</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#tags"><span>标签</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#about"><span>关于</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        

        
        <li class="nav-item">
            <a class="nav-link" href="/community/join/" data-toggle="tooltip" data-placement="bottom" title="加入社区" aria-label="主站"><i class="fa-brands fa-weixin" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item">
            <a class="nav-link js-search" href="#" data-toggle="tooltip" data-placement="bottom" title="搜索" aria-label="搜索"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item d-none d-lg-inline-flex">
            <a class="nav-link" href="https://github.com/cloudnativeto/cloudnative.to" target="_blank" rel="noopener" data-toggle="tooltip" data-placement="bottom" title="查看源码" aria-label="查看源码" aria-label="GitHub"><i class="fa-brands fa-github" aria-hidden="true"></i></a>
        </li>
        

        
        
        
        <li class="nav-item">
          <a href="#" class="nav-link set-theme">
            <i class="fa fa-sun" aria-hidden="true" id="theme-icon"></i>
          </a>
        </li>
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    <div class="container-xl">
    <div class="post-container">
        












  

  
  
  
<div class="article-container pt-3">
  <h1>Service Mesh Interface详细介绍</h1>

  

  
    


<div class="article-metadata">

  <div>
  
  
  
  
    <i class="fa-solid fa-feather"></i>
    

  <span >
      <a href="/author/%E6%95%96%E5%B0%8F%E5%89%91/">敖小剑</a></span>
    
    <span class="middot-divider"></span>
    
  
  
  
  
  
  
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/category/service-mesh/" class="text-capitalize">service mesh</a></span>
  
  </div>

  
  <span class="article-date">
    
    
      
          
          发布于
      
    
    2019-06-05
  </span>
  

  

  
  <span class="middot-divider"></span>
  字数 8838
  <span class="middot-divider"></span>
  <span class="article-reading-time">
      阅读时长 40 分钟
  </span>
  

  
  
  
  

</div>

    





  
</div>


    </div>
    <div class="border-bottom mb-2"></div>
    <div class="row flex-xl-nowrap">
        <div class="col-3 d-none d-xl-block docs-toc">
            <!-- toc -->
            
<div class="">
    <ul class="nav toc-top">
        <li>
            <a href="#" id="back_to_top" class="docs-toc-title">目录</a>
        </li>
    </ul>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#smi介绍">SMI介绍</a>
      <ul>
        <li><a href="#smi是什么">SMI是什么？</a></li>
        <li><a href="#smi推出的背景">SMI推出的背景</a></li>
        <li><a href="#和通用数据平面api的关系">和通用数据平面API的关系</a></li>
        <li><a href="#smi的目标和愿景">SMI的目标和愿景</a></li>
        <li><a href="#smi社区">SMI社区</a></li>
      </ul>
    </li>
    <li><a href="#smi规范内容">SMI规范内容</a>
      <ul>
        <li><a href="#smi规范介绍">SMI规范介绍</a></li>
        <li><a href="#traffic-spec">Traffic Spec</a></li>
        <li><a href="#traffic-access-control">Traffic Access Control</a></li>
        <li><a href="#traffic-split">Traffic Split</a></li>
        <li><a href="#traffic-metrics">Traffic Metrics</a></li>
        <li><a href="#smi规范总结">SMI规范总结</a></li>
      </ul>
    </li>
    <li><a href="#smi分析">SMI分析</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
</div>

            <!-- /toc -->
            
            <div class="subscribe-module col-12 mt-1">
    <img src="/img/wechat.jpg" alt="image" title="云原生社区的微信公众号"/>
    <p class="text-center pt-1">关注「云原生社区动态」微信公众号，获取本站更新</p>
</div>

            
        </div>
        <main class="article-body col-9 container docs-content" role="main">
            <article class="article">
                <div class="article-style">
                    
                    <details class="toc-inpage d-print-none d-show-block mb-0">
  <summary class="font-weight-bold">点击查看目录</summary>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#smi介绍">SMI介绍</a>
      <ul>
        <li><a href="#smi是什么">SMI是什么？</a></li>
        <li><a href="#smi推出的背景">SMI推出的背景</a></li>
        <li><a href="#和通用数据平面api的关系">和通用数据平面API的关系</a></li>
        <li><a href="#smi的目标和愿景">SMI的目标和愿景</a></li>
        <li><a href="#smi社区">SMI社区</a></li>
      </ul>
    </li>
    <li><a href="#smi规范内容">SMI规范内容</a>
      <ul>
        <li><a href="#smi规范介绍">SMI规范介绍</a></li>
        <li><a href="#traffic-spec">Traffic Spec</a></li>
        <li><a href="#traffic-access-control">Traffic Access Control</a></li>
        <li><a href="#traffic-split">Traffic Split</a></li>
        <li><a href="#traffic-metrics">Traffic Metrics</a></li>
        <li><a href="#smi规范总结">SMI规范总结</a></li>
      </ul>
    </li>
    <li><a href="#smi分析">SMI分析</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
</details>

                    
                    <h2 id="smi介绍">SMI介绍</h2>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi-logo_0_hu3a87f8245ab3762330380eb775186217_149470_ae832527ed2cf8721411954f22bb0f4d.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-logo_0_hu3a87f8245ab3762330380eb775186217_149470_e0ef87655c068c38a13106f707ec7afa.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-logo_0_hu3a87f8245ab3762330380eb775186217_149470_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi-logo_0_hu3a87f8245ab3762330380eb775186217_149470_ae832527ed2cf8721411954f22bb0f4d.webp"
               width="760"
               height="285"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<h3 id="smi是什么">SMI是什么？</h3>
<p>5月21号，在 kubeconf上，微软联合一众小伙伴，宣布了 Service Mesh Interface，简称SMI。SMI是一个服务网格规范，定义了通用标准，包含基本特性以满足大多数场景下的通用需求。</p>
<p>援引来自SMI官方网站  <a href="https://smi-spec.io/" target="_blank" rel="noopener">smi-spec.io</a> 的介绍资料，对 Service Mesh Interface 的定位是 ：</p>
<blockquote>
<p>A standard interface for service meshes on Kubernetes.</p>
<p>Kubernetes上的 service mesh 的标准接口</p>
</blockquote>
<p>微软的 <a href="https://msft.today/hello-service-mesh-interface-smi-a-specification-for-service-mesh-interoperability/" target="_blank" rel="noopener">官方博客文章</a> 这样介绍SMI：</p>
<blockquote>
<p>SMI定义了一组通用可移植的API，为开发人员提供跨不同服务网格技术的互通性，包括Istio，Linkerd和Consul Connect。</p>
</blockquote>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi_hu4a1aea9de87e1103a949eeacdea70aaa_120175_36f7fe051dbb94e33feea87e92357c54.webp 400w,
               /blog/service-mesh-interface-detail/images/smi_hu4a1aea9de87e1103a949eeacdea70aaa_120175_036e9c061e9585230f1fb7be317f542c.webp 760w,
               /blog/service-mesh-interface-detail/images/smi_hu4a1aea9de87e1103a949eeacdea70aaa_120175_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi_hu4a1aea9de87e1103a949eeacdea70aaa_120175_36f7fe051dbb94e33feea87e92357c54.webp"
               width="760"
               height="408"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>SMI 是希望在各家 Service Mesh 的实现之上建立一个抽象的API层，然后通过这个抽象来解耦和屏蔽底层 Service Mesh 实现，让上层的应用、工具、生态系统可以建立在一个业界标准之上，从而实现跨不同实现的可移植性和互通性。</p>
<h3 id="smi推出的背景">SMI推出的背景</h3>
<p><a href="https://medium.com/@idit.levine_92620" target="_blank" rel="noopener">Idit Levine</a>，初创公司 solo.io 的创始人兼CEO，作为SMI推出的重要力量之一，撰文描述了 SMI 推出的背景：</p>
<blockquote>
<p>服务网格生态系统正在兴起，众多的网格供应商和不同的用例需要不同的技术。所以问题来了：我们如何实现在不破坏最终用户体验的前提下促进行业创新？通过以一组标准API达成一致，我们可以提供互通性，并在不同网格以及为这些网格构建的工具之上维持最终用户体验。</p>
<p>今天发布的 Service Mesh Interface（SMI）是使这一构想走向行业现实的重要一步。</p>
</blockquote>
<p>下面这幅图片可以非常清晰的表述SMI的定位，也可以帮助我们一起来解读SMI推出的背景：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/SMI-Graphic_hu51597e352f0ba4b9470c8f9ea8aaa966_356378_138d91b526114becdd9cbac5d3ae79eb.webp 400w,
               /blog/service-mesh-interface-detail/images/SMI-Graphic_hu51597e352f0ba4b9470c8f9ea8aaa966_356378_841fcf4c69be29a64bef0f6e95ed06f2.webp 760w,
               /blog/service-mesh-interface-detail/images/SMI-Graphic_hu51597e352f0ba4b9470c8f9ea8aaa966_356378_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/SMI-Graphic_hu51597e352f0ba4b9470c8f9ea8aaa966_356378_138d91b526114becdd9cbac5d3ae79eb.webp"
               width="760"
               height="400"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<ol>
<li>
<p>Service Mesh的价值正在被普遍认可：从最早的Linkerd，Envoy，到两年前Google力推Istio，以及 Linkerd2 的推出，最近 AWS 推出了 App Mesh，Google 则将 Istio 搬上了Google Cloud 推出了 Istio 的公有云托管版本 Google Cloud Service Mesh，还推出了单独的控制平面产品 Google Traffic Director。微软也在去年推出了Azure完全托管版本的Service Fabric Mesh （预览版）。云市场三巨头都已经先后出手。</p>
</li>
<li>
<p>市场上出现了众多的Service Mesh产品：开源的，闭源的，大公司出的，小公司出的，市场繁荣的同时也带来了市场碎片化的问题。</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi-background_hu432db2da3bf62d5224437e236f008ab6_35075_786d66aa90f520dbf211ac69fbb787fd.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-background_hu432db2da3bf62d5224437e236f008ab6_35075_5b7658e192eb67f8ed2c89dcb3248f3b.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-background_hu432db2da3bf62d5224437e236f008ab6_35075_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi-background_hu432db2da3bf62d5224437e236f008ab6_35075_786d66aa90f520dbf211ac69fbb787fd.webp"
               width="760"
               height="234"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
</li>
<li>
<p>在云原生理念下，我们推崇应用轻量化，只关注业务逻辑。Service Mesh技术很好的实现了这一战略目标：运行在 service mesh 上的应用可以和底层 service mesh 的具体实现解耦。理论上应用在不同的 service mesh 实现上迁移是可行的，从这一点说，service mesh 在云原生的道路上迈出了重要一步。</p>
</li>
<li>
<p>但是，所有围绕业务应用的外围工作，比如通过 service mesh对流量进行控制，配置各种安全/监控/策略等行为，以及在这些需求上建立起来的工具和生态系统，却不得不牢牢的绑死在某个具体的 service mesh实现上，所谓&quot;供应商锁定&quot;。</p>
</li>
<li>
<p>其根本问题在于各家实现不同，又没有统一标准。因此，要想解决上述问题，就必须釜底抽薪：<strong>解决 Service Mesh 的标准化问题</strong>。</p>
</li>
</ol>
<p>微软给出的解决方案就是引入SMI，作为一个通用的行业规范/标准，如果能让各家 service mesh 提供商都遵循这个标准，则有机会在具体的 service mesh 产品之上，抽象出一个公共层（如定义一组通用可移植的API），屏蔽掉上层应用/工具/生态系统对具体  service mesh 产品的实现细节。</p>
<p>是不是觉得 SMI 的概念有种熟悉的味道？是的，没错，类似的事情在k8s中之前就发生过很多次，比如 CNI、CRI、CSI，还有下图展示的 Ingress：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi-concept_hu6cae474c8c97eee9eeea634195c5ce9c_43127_bd81437358c474bc86b88374111f263d.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-concept_hu6cae474c8c97eee9eeea634195c5ce9c_43127_c5cdb8ee4319493f873cd2f485c44217.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-concept_hu6cae474c8c97eee9eeea634195c5ce9c_43127_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi-concept_hu6cae474c8c97eee9eeea634195c5ce9c_43127_bd81437358c474bc86b88374111f263d.webp"
               width="760"
               height="416"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>在SMI中，将这个目标称为 &ldquo;<strong>Interoperability</strong>&rdquo; / 互通性。我个人理解，这其实和 google 一直在倡导的 &ldquo;not lock-in&rdquo; 是一个概念：有通用的社区标准/行业标准，在此基础上客户可以在多个实现/多个供应商之间自由选择和迁移，没有被绑定的风险，而且提供给用户的功能以及使用方式也保持一致，也就是 Idit Levine 所强调的 &ldquo;维持最终用户体验&rdquo;。</p>
<p>从这个角度说，我很欣喜的看到 SMI 的推出，虽然这条路可能不是那么容易走，但是，的确，&ldquo;Service Mesh Interface（SMI）是使这一构想走向行业现实的重要一步&rdquo;。</p>
<h3 id="和通用数据平面api的关系">和通用数据平面API的关系</h3>
<p>在SMI提出来之前不久（大概早两个星期），CNCF也在进行类似的标准化操作：CNCF正在筹建通用数据平面API工作组（Universal Data Plane API Working Group / UDPA-WG)，以制定数据平面的标准API，为L4/L7数据平面配置提供事实上的标准，初始成员将包括 Envoy 和 gRPC 项目的代表。事实上是 Google 在驱动，主要参与的项目是 Istio 和 Envoy。</p>
<p>下面这张图片展示UDPA 和 SMI 这两个新近推出的 Service Mesh 标准API的关系：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/two-api_hua970b559b9d743d44c34e6fbe181f921_10038_01992c4dcff85bbb7b9839a6bd4f239f.webp 400w,
               /blog/service-mesh-interface-detail/images/two-api_hua970b559b9d743d44c34e6fbe181f921_10038_6e6c3bf8706457392771286ab0ba1cd0.webp 760w,
               /blog/service-mesh-interface-detail/images/two-api_hua970b559b9d743d44c34e6fbe181f921_10038_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/two-api_hua970b559b9d743d44c34e6fbe181f921_10038_01992c4dcff85bbb7b9839a6bd4f239f.webp"
               width="600"
               height="546"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<ul>
<li>Universal Data Plane API 是数据平面的标准，控制平面通过这个API来控制数据平面的行为。工作组的初始成员来自包括 Envoy 和 gRPC 项目的代表，<strong>背后的公司主要是 Google</strong> 。</li>
<li>Service Mesh Interface 是控制平面的标准，上层的应用/工具/生态体系通过 Service Mesh Interface 来实现跨不同的Service Mesh实现为最终用户提供一致性的体验。<strong>SMI由微软牵头</strong>，联合 Linkerd，HashiCorp，Solo，Kinvolk和Weaveworks。</li>
</ul>
<h3 id="smi的目标和愿景">SMI的目标和愿景</h3>
<p>关于 SMI 的目标和愿景，我援引  Idit Levine 的这段话（这段话也同样出现在 smi-spec 的 github 首页）：</p>
<blockquote>
<p>SMI 是在 Kubernetes 上运行服务网格的规范。它定义了由各种供应商实现的通用标准。这使得最终用户的标准化和服务网格供应商的创新可以两全其美。SMI 实现了灵活性和互通性。</p>
</blockquote>
<p>更详细而明确的目标描述来自 smi-spec 的 github 首页：</p>
<blockquote>
<p>目标</p>
<p>SMI API的目标是提供一组通用的，可移植的Service Mesh API，Kubernetes用户可以以供应商无关的方式使用这些API。通过这种方式，可以定义使用Service Mesh技术的应用程序，而无需紧密绑定到任何特定实现。</p>
</blockquote>
<p>然后还特别强调：</p>
<blockquote>
<p>非目标</p>
<p><strong>SMI项目本身不实现服务网格</strong>。SMI只是试图定义通用规范。同样，SMI不定义服务网格的具体范围，而是一个通用子集。 欢迎SMI供应商添加超出SMI规范的供应商特定扩展和API。 我们希望随着时间的推移，随着更多功能被普遍接受为服务网格的一部分，这些定义将迁移到SMI规范中。</p>
</blockquote>
<p>总结：首先非常明确的一点是，SMI是定义标准API，而不是标准实现。</p>
<p>而 SMI 的具体目标，在 SMI 的官方网站是这样介绍的：</p>
<ol>
<li>A standard interface for service meshes on Kubernetes: Kubernetes上的 service mesh 的标准接口</li>
<li>A basic feature set for the most common service mesh use cases：用于最通用的服务网格用例的基本特性</li>
<li>Flexibility to support new service mesh capabilities over time：随着时间的推移灵活地支持新的服务网格能力</li>
<li>Space for the ecosystem to innovate with service mesh technology: 使用服务网格技术实现生态系统创新的空间</li>
</ol>
<h3 id="smi社区">SMI社区</h3>
<p>有需求，有市场，有想法，有目标，我们再来看看 SMI 阵营现在都有什么力量。</p>
<p>微软在推出 SMI 时的描述到：SMI是一个开放项目，由微软，Linkerd，HashiCorp，Solo，Kinvolk和Weaveworks联合启动; 并得到了Aspen Mesh，Canonical，Docker，Pivotal，Rancher，Red Hat和VMware的支持。</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/partnership_hub4457b7f81084c722c08045523aee746_100734_c4a82a503392db58c1f69a3f68452678.webp 400w,
               /blog/service-mesh-interface-detail/images/partnership_hub4457b7f81084c722c08045523aee746_100734_3fa667828132054f393be1ff3ace6d2d.webp 760w,
               /blog/service-mesh-interface-detail/images/partnership_hub4457b7f81084c722c08045523aee746_100734_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/partnership_hub4457b7f81084c722c08045523aee746_100734_c4a82a503392db58c1f69a3f68452678.webp"
               width="760"
               height="284"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>阵营还是挺强大的：</p>
<ul>
<li>微软：SMI的带头大哥，云计算的三巨头之一</li>
<li>Buoyant：Service Mesh 技术的拓荒牛 + 布道者，小而弥坚的初创公司，有一个不大但是力量很强又非常有经验还很务实的团队。其旗下的 Linkerd2 已经明确表示将支持 SMI。</li>
<li>HashiCorp：大名鼎鼎的 consul 就出自这里，Consul Connect 也是目前活跃的 service mesh 实现之一，虽然Consul Connect在国内知名度和影响力都很小（也就年度总结的时候捎带着看一眼状态的那种）。Consul Connect 目前也表示提供了对 SMI 的支持。</li>
<li>Solo.io：深藏不露的初创型小公司，&ldquo;产品面很广，除了 Service Mesh 方面大有名气的 SuperGloo 和 Service Mesh hub 之外，还有远程调试、混沌工程、unikernels 以及微服务网关等几个产品。&quot;（这段话我从秀龙的文章里面抄过来的，总结的很好）。另外，业界网红 Christian Posta 前段时间加入这家公司。solo公司旗下的 SuperGloo 是业界第一个 service mesh 编排产品，因此对 SMI 的热爱和支持是无可复加的。SuperGloo 和 Service Mesh Hub 已经实现了对 SMI 的支持。</li>
<li>Mesery 和 Kinvolk：这两家公司最近在 service mesh社区有点名气，因为他们近期做了 Istio vs Linkerd 的性能测试并给出了报告，闹的满城风雨。而且他们也都喜欢用 solo 出的 SuperGloo（毕竟业界号称 service mesh 编排的也就独此一家）。</li>
<li>Aspen Mesh： F5 （没错，就是那个巨贵的F5）出的的Istio商业版本。但是没有看到 Aspen Mesh 给出支持 SMI 的信息，暂时还不知道 Aspen Mesh 和 SMI 的关系。</li>
<li>vmware：vmware在2018年底推出了 VMware NSX Service Mesh ，和Aspen Mesh一样也是基于 Istio 。</li>
</ul>
<p>其他公司就不再一一列出来了，主要是不清楚他们在 SMI 这个事情上扮演什么角色。</p>
<p>而关键点在于，Google （还有同属Istio阵营的 IBM / Lyft）不在其列。而 Service Mesh 的其他玩家，几乎都参与了 SMI，甚至包括原本在 Istio 项目上和 google 一直合作的公司，耐人寻味。</p>
<h2 id="smi规范内容">SMI规范内容</h2>
<h3 id="smi规范介绍">SMI规范介绍</h3>
<p>Service Mesh Interface 规范涵盖最常见服务网格能力：</p>
<ul>
<li>Traffic Policy/流量策略 - 跨服务应用身份和传输加密等策略</li>
<li>Traffic Telemetry/流量遥测 - 捕获关键指标，如错误率和服务间的延迟</li>
<li>Traffic Management/流量管理 - 在不同服务之间转移流量</li>
</ul>
<p>SMI规范由多个API组成：</p>
<ul>
<li>Traffic Access Control/流量访问控制 - 根据客户端的身份配置对特定pod和路由的访问，以将应用程序锁定到仅允许的用户和服务。</li>
<li>Traffic Specs/流量规范 - 定义流量的表示方式，基于每个协议的基础。 这些资源与访问控制和其他类型的策略协同工作，以在协议级别管理流量。</li>
<li>Traffic Split/流量分割 - 逐步引导各种服务之间的流量百分比，以帮助构建金丝雀推出。</li>
<li>Traffic Metrics/流量指标 - 暴露通用的流量指标，供dashboard和autoscaler等工具使用。</li>
</ul>
<p>注意：SMI 被指定为 Kubernetes Custom Resource Definitions（CRD）和 Extension API Servers 的集合。 这些API可以安装到Kubernetes集群上，并使用标准工具进行操作。</p>
<p>在设计上，SMI 强调 &ldquo;Provider Agnostic（供应商无关）&quot;：</p>
<blockquote>
<p>SMI API的目标是提供一组通用的可移植的服务网格API，Kubernetes用户可以以供应商无关的方式使用这些API。 通过这种方式，人们可以定义使用服务网格技术的应用程序，而无需紧密绑定到任何特定实现。</p>
</blockquote>
<p>下面我们来详细看一下 SMI 规范的具体API定义，其定义来自https://github.com/deislabs/smi-spec 。</p>
<h3 id="traffic-spec">Traffic Spec</h3>
<p>Traffic Spec资源用于让用户定义流量。通常与Access Control（访问控制）和其他策略一起使用，以具体定义需要如何处理流经网格的特定类型流量。</p>
<p>用户往往希望在服务网格内运行许多不同的协议。 当然，主要会是HTTP，但也会有其他协议。 Traffic Spec规范中的每个资源都旨在与特定协议1：1匹配。 这让用户可以以协议特定的方式来定义流量。</p>
<p><strong>HTTPRouteGroup</strong></p>
<p>HTTPRouteGroup 资源用于描述HTTP/1和HTTP/2流量，它枚举了应用程序可以提供的路由。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">specs.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">HTTPRouteGroup</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">the-routes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">matches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">metrics</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pathRegex</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;/metrics&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">methods</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="l">GET</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">health</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">pathRegex</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;/ping&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">methods</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;*&#34;</span><span class="p">]</span><span class="w">
</span></span></span></code></pre></div><p>上面的例子定义两个<code>match</code>，<code>metrics</code>和<code>health</code>。 name 字段是key，所有字段都是必需的。 正则表达式用于匹配URI。 HTTP Mesh可以具体制定如 <code>GET</code> 或用 <code>*</code> 来匹配所有。</p>
<p>HTTPRouteGroup 当前的功能限制（未来会加入，只是当前作为第一个版本内容还比较少）：</p>
<ol>
<li>只支持 HTTP 协议，连 gRPC 都还未支持</li>
<li><code>match</code> 字段当前仅适用于 <code>URI</code>。 很明显这是不够的，未来计划扩展以支持HTTP header，Host等。</li>
</ol>
<blockquote>
<p>个人看法：目前在只有 HTTP 协议支持，而且 HTTP 路由定义居然不支持 HTTP header 匹配，足够说明目前 SMI 的确是处于项目早期状态。</p>
</blockquote>
<p><strong>TCPRoute</strong></p>
<p>TCPRoute资源用于描述 L4 TCP流量。 这个路由极其简单（或者叫做简陋），定义应用程序接收到的原始的、无协议特征的流量。</p>
<p>看完下面的yaml例子就明白为什么称为极其简单了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">specs.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">TCPRoute</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">tcp-route</span><span class="w">
</span></span></span></code></pre></div><p>上面的路由只做了定义，尚未与任何资源相关联。 我们继续看如何使用，比如与Access Control 配合。</p>
<h3 id="traffic-access-control">Traffic Access Control</h3>
<p>Traffic Access Control 资源用来为应用程序定义访问控制策略：</p>
<ol>
<li>访问控制属于授权（authorization）范畴，默认身份验证（Authentication）已经由底层实现处理</li>
<li>SMI规范中的访问控制是附加的，默认情况下<strong>拒绝所有流量</strong>。</li>
</ol>
<p><strong>TrafficTarget 规范</strong></p>
<p>TrafficTarget 规范用来定义流量访问控制，而 SMI 中访问控制是基于服务身份（service identity）的，并且目前只支持通过 Kubernetes service account 来指派服务身份（其他身份机制将在稍后支持）。</p>
<p>流量访问控制有三个概念，分别在 TrafficTarget 中以三个字段定义：</p>
<ol>
<li>Source：流量的来源，体现为具体的 Pod 列表，目前支持通过selector来实现，暂时不支持以资源的方式选择（如指定Deployment、指定Service）</li>
<li>Destination：流量的目标，同样体现为具体的 Pod 列表，也只支持selector</li>
<li>Route：流量规范，用来区分 Destination 提供的多种不同的流量访问方式，如下图中的api访问和获取metrics信息</li>
</ol>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_31ddfafe31a499ef7c9fbdd1a0b07683.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_7f556b78204559e930b76877640d52d8.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_31ddfafe31a499ef7c9fbdd1a0b07683.webp"
               width="760"
               height="350"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>在这个例子中，展示对api进行访问和获取metrics信息这两个操作的流量访问控制：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="c"># 定义TrafficSpec</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">specs.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">HTTPRouteGroup</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service-routes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">matches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api </span><span class="w"> </span><span class="c"># api访问的流量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">pathRegex</span><span class="p">:</span><span class="w"> </span><span class="l">/api</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">methods</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;*&#34;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">metrics</span><span class="w"> </span><span class="c"># 获取metrics的流量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">pathRegex</span><span class="p">:</span><span class="w"> </span><span class="l">/metrics</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">methods</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;GET&#34;</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">TrafficTarget</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">access.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service-metrics</span><span class="w"> </span><span class="c"># 定义获取metrics的Target</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="l">destination:	# 通过 ServiceAccount 选择pods</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ServiceAccount</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">specs</span><span class="p">:</span><span class="w"> </span><span class="c"># 引用traficSec定义的route，指定为获取metrics</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">HTTPRouteGroup</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service-routes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">matches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">metrics</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">sources</span><span class="p">:</span><span class="w"> </span><span class="c"># 通过 ServiceAccount 选择pods</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ServiceAccount</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">prometheus</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">TrafficTarget</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">access.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service-api</span><span class="w"> </span><span class="c"># 定义访问api接口的Target</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">destination</span><span class="p">:</span><span class="w"> </span><span class="c"># 通过 ServiceAccount 选择pods</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ServiceAccount</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">specs</span><span class="p">:</span><span class="w"> </span><span class="c"># 引用traficSec定义的route，指定为api访问</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">HTTPRouteGroup</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">api-service-routes</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">matches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="l">api</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">sources</span><span class="p">:</span><span class="w"> </span><span class="c"># 通过 ServiceAccount 选择pods</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ServiceAccount</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">website-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ServiceAccount</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">payments-service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span></span></span></code></pre></div><p>上述实例定义了两个容许的访问控制：</p>
<ol>
<li>对于以 ServiceAccount 为 api-service 运行的 pods，容许来自以 ServiceAccount 为 prometheus 的 pods 访问 api-service-routes 定义下的 metrics 路由</li>
<li>对于以 ServiceAccount 为 api-service 运行的 pods，容许来自以 ServiceAccount 为 website-service 和 payments-service  的 pods 访问 api-service-routes 定义下的 api 路由</li>
</ol>
<p>其中有部分字段为可选字段：</p>
<ul>
<li>matches 字段：如果省略，则对 TrafficSpec 下定义的所有Route都生效</li>
<li>Port字段：如果省略，则表示所有端口</li>
</ul>
<p>SMI 流量访问控制的规则是默认都不容许访问，只有通过 TrafficTarget 指定的符合条件的流量才容许访问。而访问控制的执行，是明确要求在访问的服务器端（即Destination）强制执行，而是否在客户端（即Source）进行访问控制则由SMI的具体实现来决定。</p>
<p>注意目前 Traffic Access Control 在定义 Source 和 Destination 时，都是通过 Selector 来定义的，我们细看这张图片：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_31ddfafe31a499ef7c9fbdd1a0b07683.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_7f556b78204559e930b76877640d52d8.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_31ddfafe31a499ef7c9fbdd1a0b07683.webp"
               width="760"
               height="350"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>从访问控制的业务语义上看，上面两个 TrafficTarget 翻译出来就是：</p>
<ul>
<li>容许以 ServiceAccount prometheus 运行的服务访问以 ServiceAccount api-service 运行的服务的 metrics</li>
<li>容许以 ServiceAccount web-service 和 payment-service 运行的服务访问以 ServiceAccount api-service 运行的服务的 api</li>
</ul>
<p>而不是我们平时熟悉的资源方式如&quot;容许A服务访问B服务&rdquo;，即访问控制中对服务的标示目前只能通过 ServiceAccount + Selector 来完成，而不是通过简单的服务Id或者名称来指定资源。请注意&quot;容许以身份A运行的服务访问以身份B运行的服务&rdquo; 和 &ldquo;容许A服务访问B服务&rdquo; 的细微差别。</p>
<p>关于这一点，在 SMI 的文档的&quot;Tradeoffs&quot;中提到：</p>
<blockquote>
<p>Resources vs selectors - it would be possible to reference concrete resources such as a deployment instead of selecting across pods.</p>
<p>资源 vs 选择器 - 可以引用具体资源（如deployment）而不是pod选择。</p>
</blockquote>
<h3 id="traffic-split">Traffic Split</h3>
<p>Traffic Split 资源用来实现流量的百分比拆分，熟悉Istio的同学应该非常了解这个功能的强大。</p>
<p>但是 SMI 中 Traffic Split 的配置方式和 Istio 有非常大的不同，比如下面的配置，要对 foobar 服务按照版本进行流量拆分，v1 和 v2 权重分别为 1 和 500m （1=1000m），在 Traffic Split 的配置中会出现多个 service：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">split.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">TrafficSplit</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">foobar-rollout</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">service</span><span class="p">:</span><span class="w"> </span><span class="l">foobar</span><span class="w"> </span><span class="c"># root service，客户端用这个服务名来连接目标应用</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">backends</span><span class="p">:</span><span class="w"> </span><span class="c"># root service 后面的服务，有自己的selectors, endpoints 和 configuration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">service</span><span class="p">:</span><span class="w"> </span><span class="l">foobar-v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">service</span><span class="p">:</span><span class="w"> </span><span class="l">foobar-v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="l">500m</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>&ldquo;foobar&rdquo;：通过 <code>spec.service</code> 指定，这是 Traffic Split 的 root service，是要配置进行流量拆分的目标服务的FQDN，客户端用这个 service 进行通信，也就是说这个 root service 是暴露给客户端的。</li>
<li>&ldquo;footer-v1&rdquo; 和 &ldquo;footer-v2&rdquo;：这两个后端服务，是&quot;隐藏&quot;在 root service 后面的，通常是 root service 的子集，典型实现上是 selector 多加一个 version label 限制。</li>
</ul>
<p>这样，如果要对某个服务的两个子集进行流量拆分，典型如版本v1和版本v2，在 SMI 中就会有三个 k8s service 定义：</p>
<table>
<thead>
<tr>
<th>资源</th>
<th>selector （label）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>service foobar</td>
<td><code>app: foobar</code></td>
<td>root service</td>
</tr>
<tr>
<td>service foobar-v1</td>
<td><code>app: foobar</code>, <code>version: v1</code></td>
<td>backend service</td>
</tr>
<tr>
<td>service foobar-v2</td>
<td><code>app: foobar</code>, <code>version: v2</code></td>
<td>backend service</td>
</tr>
</tbody>
</table>
<p>这三个 service 和 pod 的关系如下图所示：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/smi-traffic-split_huaddcd7e9102718607d20de96a4a4f7e1_80014_3605fd37ca86cf5ae54f05f325f911e8.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-traffic-split_huaddcd7e9102718607d20de96a4a4f7e1_80014_6baa983e9763c970e6d1d57da2d4e0d9.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-traffic-split_huaddcd7e9102718607d20de96a4a4f7e1_80014_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/smi-traffic-split_huaddcd7e9102718607d20de96a4a4f7e1_80014_3605fd37ca86cf5ae54f05f325f911e8.webp"
               width="760"
               height="358"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>我们来对比 Istio 中实现类似功能的方式，Istio中需要为准备进行流量拆分的服务定义 VirtualService，通过 subset 来区分不同的流量去向：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">networking.istio.io/v1alpha3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">VirtualService</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">foobar-route</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">hosts</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="l">foobar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">http</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">route</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">destination</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">foobar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">subset</span><span class="p">:</span><span class="w"> </span><span class="l">v2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="m">25</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span>- <span class="nt">destination</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">foobar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">subset</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">weight</span><span class="p">:</span><span class="w"> </span><span class="m">75</span><span class="w">
</span></span></span></code></pre></div><p>subset 在 DestinationRule 中定义，注意这里只涉及到 labels，服务（以host标志）并没有多个，还是 foobar：</p>
<pre tabindex="0"><code class="language-yam" data-lang="yam">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: foobar-destination
spec:
  host: foobar
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
</code></pre><p>在Istio 中，service 和 subset 的关系如下图所示：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/istio-traffic-split_hu342454daf6550c3d94a7f94651c1b7be_75174_531f5cf244da75a29a82d989d58d4db4.webp 400w,
               /blog/service-mesh-interface-detail/images/istio-traffic-split_hu342454daf6550c3d94a7f94651c1b7be_75174_522632e61718b6bf2899532befd74348.webp 760w,
               /blog/service-mesh-interface-detail/images/istio-traffic-split_hu342454daf6550c3d94a7f94651c1b7be_75174_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/istio-traffic-split_hu342454daf6550c3d94a7f94651c1b7be_75174_531f5cf244da75a29a82d989d58d4db4.webp"
               width="760"
               height="358"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>可以看到 SMI 中的 backend service 和 Istio 中的 subset 在功能上几乎是对等的。</p>
<p>但是：SMI 和 Istio 的根本差异在于 Istio 中的 subset 是一个虚拟的抽象对象，在k8s中并没有实体资源。而在 SMI 中，backend service 是实实在在存在的 k8s service 资源。</p>
<p>这里个人觉得有一个隐忧：在 SMI 中，为了进行流量拆分，就不得不为每个版本建立一个独立的k8s service，service 数量会比 Istio 方案多很多。</p>
<p>另外就是在权重设置上的细微的差别，SMI 用的是相对weight（比如可以设置为1:2），而 Istio 是严格的百分比，而且要求总和为100。</p>
<h3 id="traffic-metrics">Traffic Metrics</h3>
<p>Traffic Metrics 资源提供通用集成点，工具可以通过访问这些集成点来抓取指标。Traffic Metrics 遵循 <code>metrics.k8s.io</code> 的模式，其即时指标可用于各种 CLI工具，HPA伸缩等。</p>
<p>和大多数Metrics系统一致，SMI的Traffic Metrics 数据包含两个核心对象：</p>
<ol>
<li>Resource：Metrics 和资源绑定，资源可以是 pod 和更高级别的概念如 namespaces, deployments 或者 services 。Pod是 Metrics 可以关联的最细粒度的资源，通过集合可以得到推断出其他。</li>
<li>Edge：表示流量来源或其目的地，描述力量的方向。</li>
</ol>
<p><strong>TrafficMetrics</strong></p>
<p>TrafficMetrics是核心资源，关联到资源，具有edge，延迟百分位数和请求量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">metrics.smi-spec.io/v1alpha1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">TrafficMetrics</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">resource</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">foo-775b9cbd88-ntxsl</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">foobar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">edge</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">direction</span><span class="p">:</span><span class="w"> </span><span class="l">to</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">resource</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">baz-577db7d977-lsk2q</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">foobar</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">timestamp</span><span class="p">:</span><span class="w"> </span><span class="ld">2019-04-08T22:25:55Z</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">window</span><span class="p">:</span><span class="w"> </span><span class="l">30s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metrics</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">p99_response_latency</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">unit</span><span class="p">:</span><span class="w"> </span><span class="l">seconds</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="l">10m</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">p90_response_latency</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">unit</span><span class="p">:</span><span class="w"> </span><span class="l">seconds</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="l">10m</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">p50_response_latency</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">unit</span><span class="p">:</span><span class="w"> </span><span class="l">seconds</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="l">10m</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">success_count</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="m">100</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">failure_count</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="m">100</span><span class="w">
</span></span></span></code></pre></div><p>TrafficMetrics 的定义和使用暂时没看到有特殊之处。</p>
<h3 id="smi规范总结">SMI规范总结</h3>
<p>从上面我们详细分析的 SMI 主要规范的定义看，Traffic Access Control / Traffic Specs / Traffic Split / Traffic Metrics 这四个目前定义好的规范，无论从功能还是从API设计上看，都缺乏亮点，至少与目前大家熟悉的 Istio API 相比，没有明显优势：</p>
<ul>
<li>Traffic Specs 中 HTTPRouteGroup 只支持HTTP1.1，甚至不支持header，TCPRoute更是简陋到极致</li>
<li>Traffic Access Control 只支持 ServiceAccount</li>
<li>Traffic Split：需要为每个需要拆分的流量额外增加 k8s service</li>
<li>TrafficMetrics：平平无奇</li>
</ul>
<p>考虑到目前 SMI 还是第一个版本，处于项目早期阶段，不够成熟情有可原，我们更要关注的是其后续版本的演进，希望未来 SMI 可以成长为一个足够坚实而可用的标准API。</p>
<h2 id="smi分析">SMI分析</h2>
<p>前面我们分析过 SMI 推出的背景，我归结为关键的两点：</p>
<ol>
<li>有利可图：Service Mesh技术被普遍看好，其长远价值被各大厂商认可</li>
<li>有机可趁：作为市场领头羊的Google和Istio，表现疲软</li>
</ol>
<p>另外Google在Istio项目上，表现也有些令人费解：</p>
<ol>
<li>迟迟不进CNCF：早先还有未能发布1.0版本不满足CNCF要求的借口，而最近则感觉Google一直在避免讨论这个话题</li>
<li>Istio一直没有对 Service Mesh 技术进行标准化：只关注自己的 Istio API，对于标准化和基于标准化构建生态系统完全没兴趣。即便是统一数据平面API的标准化动作，也让人觉得是 Envoy 在推动。</li>
<li>宣传和现实的差距：Istio 1.0 的 &ldquo;Product Ready&rdquo;，1.1 版本的&quot;Enterprise Ready&quot;，很让人无语，我很期待 1.2 版本出来时的口号。</li>
<li>架构设计的不务实：Mixer 是被嘲弄的重灾区，躲在Mixer身后的Pilot其实问题也一堆，而 Mixer v2 的进展则成为衡量 Istio 未来走向的风向标，是要成为工业级可用的坚实产品，还是继续摆弄优雅架构做花瓶？未来一年我们拭目以待。</li>
<li>整个社区对Istio的不满情绪一直在酝酿和累积：这次 SMI 推出引发的轰动，很大程度是这种情绪的发泄——除了Google之外几乎所有的 Servic Mesh 的玩家都参与进来了，这就足够说明问题了。</li>
</ol>
<p>在过去两年，社区一直在期待Google和Istio，但是，这种期待在持续两年的失望之后，开始转向另外的方向：或许我们要更多的考虑Istio之外的选择了。</p>
<p>Service Mesh 的战争，我们原以为会以Istio的胜利而迅速结束，但是现在看来，可能这场战争才刚刚开始。</p>
<p>是重新认真审视这张图片的时候了：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/service-mesh-interface-detail/images/gartner_hu0cefc59b1305d4b12fbb9ada76f070b9_62500_1fe712495bd7bb723701adbdeaf47c7d.webp 400w,
               /blog/service-mesh-interface-detail/images/gartner_hu0cefc59b1305d4b12fbb9ada76f070b9_62500_ebccc8532a6fce525956e9a12ece7927.webp 760w,
               /blog/service-mesh-interface-detail/images/gartner_hu0cefc59b1305d4b12fbb9ada76f070b9_62500_1200x1200_fit_q75_h2_lanczos.webp 1200w"
               src="/blog/service-mesh-interface-detail/images/gartner_hu0cefc59b1305d4b12fbb9ada76f070b9_62500_1fe712495bd7bb723701adbdeaf47c7d.webp"
               width="760"
               height="505"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>SMI 的推出，意义并不仅仅在于这个 Service Mesh 标准本身，而是带有另外一种特殊含义，就如陈胜吴广的揭竿而起，传递给四方的消息是：天下苦秦久矣！</p>
<p>文章最后，希望未来有更多的优秀 Service Mesh 产品出现，也希望 Istio 可以知耻而后勇。Service Mesh 技术要想成功普及，一定需要一个或者多个强力产品的出现，而 SMI 的出现则为这场短期不能结束的纷争带来了一个理论可能：无论产品竞争如何激烈，都不影响上层生态，从而避免站队失败的风险和由此带来的犹豫与观望。这才是我个人觉得 SMI 推出的最大意义所在。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://smi-spec.io/" target="_blank" rel="noopener">smi官方网站</a></li>
<li><a href="https://github.com/deislabs/smi-spec" target="_blank" rel="noopener">smi-spec项目@github </a></li>
<li><a href="https://www.redhat.com/en/blog/interoperability-new-service-mesh-interface" target="_blank" rel="noopener">Interoperability with the new Service Mesh Interface</a></li>
<li><a href="https://blog.fleeto.us/post/servicemesh-interface/" target="_blank" rel="noopener">意外：Servicemesh Interface（SMI）</a></li>
<li><a href="https://msft.today/hello-service-mesh-interface-smi-a-specification-for-service-mesh-interoperability/" target="_blank" rel="noopener">Hello Service Mesh Interface (SMI): A specification for service mesh interoperability</a>: 来自微软的博客，比较权威，本文很多内容是援引自此文</li>
<li><a href="https://medium.com/solo-io/service-mesh-interface-smi-and-our-vision-for-the-community-and-ecosystem-2edc7b728c43" target="_blank" rel="noopener">Service Mesh Interface (SMI) and our Vision for the Community and Ecosystem</a>：作者 <a href="https://medium.com/@idit.levine_92620" target="_blank" rel="noopener">Idit Levine</a>，是初创公司 solo.io 的创始人兼CEO，本文同样大量援引此文的内容</li>
<li><a href="https://kccnceu19.sched.com/event/MRz7/sponsored-keynote-democratizing-service-mesh-on-kubernetes-gabe-monroy-lead-product-manager-microsoft-azure-container-compute" target="_blank" rel="noopener">Democratizing Service Mesh on Kubernetes</a>: kubecon上宣布SMI的 keynote，作者 Gabe Monroy ，Microsoft Azure Container Compute的 Lead Product Manager，本文部分图片来自这个演讲的PPT</li>
<li><a href="https://kinvolk.io/blog/2019/05/how-the-service-mesh-interface-smi-fits-into-the-kubernetes-landscape/" target="_blank" rel="noopener">How the Service Mesh Interface (SMI) fits into the Kubernetes landscape</a>: 介绍SMI和其他类似的kubernetes Interface 如 CNI、CRI、CSI等。</li>
<li><a href="https://blog.getambassador.io/kubecon-eu-2019-top-10-takeaways-123b5fcb30a8" target="_blank" rel="noopener">KubeCon EU 2019: Top 10 Takeaways</a>: 来自网红 Daniel Bryant 的文章，包含对 SMI 和 Istio 的看法。</li>
<li><a href="https://softwareengineeringdaily.com/2019/05/31/service-mesh-wars-with-william-morgan/" target="_blank" rel="noopener">Service Mesh Wars with William Morgan</a>：这是我见过的抨击Istio最为猛烈的一篇文章，极其火爆，又很有道理的样子</li>
<li><a href="https://www.infoworld.com/article/3400116/introducing-the-service-mesh-interface.html" target="_blank" rel="noopener">To Istio and beyond: Azure’s Service Mesh Interface</a>: 有软文嫌疑，但是还是能看出微软推出SMI的基本想法</li>
<li><a href="https://www.hashicorp.com/blog/hashicorp-consul-supports-microsoft-s-new-service-mesh-framework" target="_blank" rel="noopener">HashiCorp Consul supports Microsoft’s new Service Mesh Interface</a>: 介绍 Consul Connect 对 SMI 的支持</li>
</ul>

                </div>
                

<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/smi/">SMI</a>
  
  <a class="badge badge-light" href="/tag/service-mesh/">service mesh</a>
  
</div>











  
  
    



  
  
  
  
  
  <div class="media author-card content-widget-hr mb-4">
    
      
      <a href="/author/%E6%95%96%E5%B0%8F%E5%89%91/"><img class="avatar mr-3 avatar-circle" src="/author/%E6%95%96%E5%B0%8F%E5%89%91/avatar_hue38add62c87b7486d80c9f3fda25dfc1_12220_270x270_fill_q75_lanczos_center.jpg" alt="敖小剑"></a>
    

    <div class="media-body">
      <p class="card-title"><a href="/author/%E6%95%96%E5%B0%8F%E5%89%91/">敖小剑</a></p>
      
      <p class="card-text">微软</p>
      
    </div>
  </div>


  





<div class="article-widget">
  
<div class="container-xl row post-nav">
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1" href="/blog/implementing-chatops-with-jenkins-x/" rel="next">
    <div class="meta-nav">下一页</div>
    <p>使用Jenkins X实现ChatOps</p></a>
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1"  href="/blog/containers-microservices-service-meshes/" rel="prev">
    <div class="meta-nav">上一页</div>
    <p>容器、微服务和服务网格简史</p></a>
  
</div>

</div>










  

<p class="edit-page">
  <a href="https://github.com/cloudnativeto/cloudnative.to/edit/master/content/blog/service-mesh-interface-detail/index.md">
    <i class="fas fa-pen pr-2"></i>编辑本页
  </a>
</p>




  
  
  <div class="article-widget content-widget-hr">
    <p class="related-title">相关推荐</p>
    <ul>
      
      <li><a href="/blog/resiliency-app-aware-network/">利用服务网格和智能应用感知网络增强应用弹性</a></li>
      
      <li><a href="/blog/ebpf-wasm-service-mesh/">eBPF 和 Wasm：探索服务网格数据平面的未来</a></li>
      
      <li><a href="/blog/ebpf-solve-service-mesh-sidecar/">告别 Sidecar——使用 eBPF 解锁内核级服务网格</a></li>
      
      <li><a href="/blog/jimmy-service-mesh-talk/">都 2021 年了，对于服务网格，社区到底在讨论什么？</a></li>
      
      <li><a href="/blog/how-ebpf-streamlines-the-service-mesh/">eBPF 如何简化服务网格</a></li>
      
    </ul>
  </div>
  





  
  
  

  

  
  <section id="comments" class="mb-3 pt-0">
    <script>
  let themeNumber = localStorage.getItem('wcTheme');
  var giscusTheme = "light";
  if (themeNumber == 1){
    giscusTheme = "dark";
  }
  let giscusAttributes = {
    "src": "https://giscus.app/client.js",
    "data-theme": giscusTheme,
    "data-repo":"cloudnativeto\/cloudnative.to",
    "data-repo-id":"MDEwOlJlcG9zaXRvcnkyMzc3NDUxOTA=",
    "data-category":"General",
    "data-category-id":"MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMyMDU5MzUy",
    "data-mapping":"pathname",
    "data-reactions-enabled":"",
    "data-emit-metadata":"0",
    "data-input-position":"top",
    "data-theme":giscusTheme,
    "data-lang":"zh-CN",
    "data-loading":"lazy",
    "crossorigin":"annoymous",
    "origins":"https://cloudnative.to",
    "originsRegex":"http://localhost:[0-9]+",
    "async": "",
  };

  let giscusScript = document.createElement("script");
  Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
  document.querySelector('#comments').appendChild(giscusScript);
</script>

  </section>
  



            </article>
        </main>
    </div>
</div>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">

  



  

  
  <div class="copyright py-4 bg-footer">
      <div class="row justify-content-center">
        <div class="text-center footer-color">
          <p class="mb-0">© 2020-2022 云原生社区保留所有权利</p>
        </div>
    </div>
  </div>

</footer>

    </div>
    
  </div>

  


<script src="/js/vendor-bundle.min.46271ef31da3f018e9cd1b59300aa265.js"></script>




  

  
  

  

  
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js" integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin="anonymous"></script>
    
    
  










  
  <script id="search-hit-fuse-template" type="text/x-template">
    <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <div class="article-metadata search-hit-type">{{relpermalink}}</div>
          <a href="{{relpermalink}}">{{title}}</a>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
    </div>
  </script>
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin="anonymous"></script>
  












  
  
  
  
  
  
  







<script id="page-data" type="application/json">{"use_headroom":false}</script>










  
  


<script src="/zh/js/wowchemy.min.24983018b0e5661cd5fe1822254286ea.js"></script>







<script>

var mybutton = document.getElementById("backTopBtn");


window.onscroll = function() {scrollFunction()};

function scrollFunction() {
  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    mybutton.style.display = "block";
  } else {
    mybutton.style.display = "none";
  }
}


function topFunction() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
<script>
  anchors.add();
</script>



<script>



(function() {
  'use strict';

  if(!document.queryCommandSupported('copy')) {
    return;
  }

  function flashCopyMessage(el, msg) {
    el.className = "highlight-copy-btn";
    el.textContent = msg;
    setTimeout(function() {
      el.textContent = "";
      el.className = "highlight-copy-btn fa fa-copy";
    }, 1000);
  }

  function selectText(node) {
    var selection = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
    return selection;
  }

  function addCopyButton(containerEl) {
    var copyBtn = document.createElement("button");
    copyBtn.className = "highlight-copy-btn fa fa-copy";
    copyBtn.textContent = "";

    var codeEl = containerEl.firstElementChild;
    copyBtn.addEventListener('click', function() {
      try {
        var selection = selectText(codeEl);
        document.execCommand('copy');
        selection.removeAllRanges();
        
        flashCopyMessage(copyBtn, '已复制')
        
      } catch(e) {
        console && console.log(e);
        flashCopyMessage(copyBtn, 'Failed :\'(')
      }
    });

    containerEl.appendChild(copyBtn);
  }

  
  var highlightBlocks = document.getElementsByClassName('highlight');
  Array.prototype.forEach.call(highlightBlocks, addCopyButton);
})();
</script>



<script>

function Collapse(e){
  var node = document.getElementById(e);
  if (node.className.indexOf('fa-angle-down') > -1){
    node.setAttribute("class", "fa-solid fa-angle-right");
    }else{
    node.setAttribute("class", "fa-solid fa-angle-down");
    }
}
</script>


</body>
</html>
