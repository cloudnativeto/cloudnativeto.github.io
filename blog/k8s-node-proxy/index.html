<!DOCTYPE html>

<html lang="zh-cn"><head>
  <meta charset="utf-8">
  
  <title>深入理解 Kubernetes 网络模型：自己实现 kube-proxy 的功能 | 云原生社区</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="带你一步步理解 kube-proxy。">
  
  <meta name="author" content=" 云原生社区">
  <meta name="generator" content="Hugo 0.65.3" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="/plugins/bootstrap/bootstrap.min.css">
  
  <link rel="stylesheet" href="/plugins/slick/slick.css">
  
  <link rel="stylesheet" href="/plugins/fontawesome/font-awesome.min.css">
  
  <link rel="stylesheet" href="/plugins/animate/animate.css">
  
  <link rel="stylesheet" href="/plugins/venobox/venobox.css">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="/scss/style.min.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="/images/favicon.png " type="image/x-icon">
  <link rel="icon" href="/images/favicon.png " type="image/x-icon">
  <meta property="og:image" content="https://cloudnative.to/images/favicon.png">
  <!--Algolia-->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.min.css">
  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="Cloud Native Community|云原生社区" />
  <meta name="twitter:creator" content="@CloudNativeCN" />
  <meta property="og:url" content="https://cloudnative.to/blog/k8s-node-proxy/" />
  <meta property="og:title" content="深入理解 Kubernetes 网络模型：自己实现 kube-proxy 的功能" />
  <meta property="og:description" content="带你一步步理解 kube-proxy。" />
  <meta property="og:image" content="https://cloudnative.to/images/blog/crack-k8s-node-proxy-banner.jpeg" />
</head>
<body>
<!-- header -->

<img src="images/logo-square.jpg" width="0" height="0" />
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
     <img src="" width='700'>
</div>
<header>
  

  <!-- navigation -->
  <div class="navigation bg-white position-relative">
    <div class="container">
      <nav class="navbar navbar-expand-lg navbar-light bg-white">
        <a class="navbar-brand" href="/"><img class="img-fluid pb-lg-3" src="/images/logo.png" width="189px" alt="云原生社区"></a>
        <button class="navbar-toggler border-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link" href="/"></a>
            </li>
            
            
            <li class="nav-item">
              <a class="nav-link" href="/blog/">博客</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="/community/sig/">兴趣小组</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="/contribute">投稿</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="/job">招聘</a>
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                aria-expanded="false">
                社区
              </a>
              <div class="dropdown-menu" >
                
                <a class="dropdown-item" href="/team">管理委员会</a>
                
                <a class="dropdown-item" href="/academy/">云原生学院</a>
                
                <a class="dropdown-item" href="/city">城市站</a>
                
                <a class="dropdown-item" href="/community/">社区资料</a>
                
              </div>
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                aria-expanded="false">
                资料
              </a>
              <div class="dropdown-menu" >
                
                <a class="dropdown-item" href="http://landscape.opensourcecloud.cn/">云原生生态图景</a>
                
                <a class="dropdown-item" href="/kubebuilder">Kubebuilder 中文文档</a>
                
                <a class="dropdown-item" href="/envoy">Envoy 中文文档</a>
                
                <a class="dropdown-item" href="https://istio.io/latest/zh/">Istio 中文文档</a>
                
              </div>
            </li>
            
            
          </ul>

          
          

          
          <!-- search -->
          <div class="search px-4">
            <button id="searchOpen" class="search-btn"><i class="fa fa-search text-dark"></i></button>
            <div class="search-wrapper">
              <form action="/search">
                <input class="search-box form-control" id="js-algolia-btn" name="s" type="search" placeholder="输入搜索词">
              </form>
              <button id="searchClose" class="search-close"><i class="fa fa-close text-dark"></i></button>
            </div>
          </div>
          
          
          <!-- get start btn -->
          <a href="/contact" class="btn btn-primary hover-ripple">加入我们</a>
          
        </div>
      </nav>
    </div>
  </div>
  <!-- /navigation -->
</header>
<!-- /header -->

	<!-- page title -->
<section class="section bg-cover overlay" style="background-image: url('/'),url('/'),url('/images/backgrounds/page-title-5.jpg');">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <h2 class="text-white mb-3 text-capitalize">深入理解 kubernetes 网络模型：自己实现 kube proxy 的功能</h2>
        <!-- breadcrumb -->
        
        <p class="text-white">带你一步步理解 kube-proxy。</p>
      </div>
    </div>
  </div>
</section>
<!-- /page title -->

	

<!-- blog details -->
<section class="section">
  <div class="container blog">
    <div class="row">
      <div class="col-lg-8">
        <!-- post thumb -->
        <div class="position-relative mb-5">
          <img src="/"  onerror="this.src='\/images\/blog\/crack-k8s-node-proxy-banner.jpeg'" alt="post thumb" class="img-fluid w-100">
           <div class="card-type"><a href="/categories/kubernetes">Kubernetes</a></div>
        </div>
        <div class="card-meta mb-2">作者  <strong class="text-dark"><a href="https://arthurchiao.art/blog/cracking-k8s-node-proxy/">赵亚楠</a></strong>
          
          译者
          <strong class="text-dark">
          <a href="https://team.jiunile.com/">徐鹏</a>
          </strong>
          
            发表于 <strong class="text-dark">2020年10月19日</strong></div>
        <hr>
        <div class="content">
          <p>本文译自 <a href="https://arthurchiao.art/blog/cracking-k8s-node-proxy/">Cracking kubernetes node proxy (aka kube-proxy)</a>。</p>
<p>Kubernetes 中有几种类型的代理。其中有 <strong>node proxier</strong> 或 <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a>，它在每个节点上反映 Kubernetes API 中定义的服务，可以跨一组后端执行简单的 TCP/UDP/SCTP 流转发 [1]。</p>
<p>为了更好地理解节点代理模型，在这篇文章中，我们将用不同的方法设计和实现我们自己版本的 <code>kube-proxy</code>; 尽管这些只是 <code>toy-proxy</code>，但从<strong>透明流量拦截、转发、负载均衡</strong>等方面来说，它们的工作方式与 K8S 集群中运行的普通 <code>kube-proxy</code> 基本相同。</p>
<p>通过我们的 <code>toy-proxy</code> 程序，非 K8S 节点（不在 K8S 集群中）上的应用程序（无论是宿主本地应用程序，还是在 VM/容器中运行的应用程序）也可以通过 <strong>ClusterIP</strong> 访问 K8S 服务 &ndash; <strong>注意，在 kubernetes 的设计中，ClusterIP 只能在 K8S 集群节点中访问（在某种意义上，我们的 <code>toy-proxy</code> 程序将非 K8S 节点变成了 K8S 节点）。</strong></p>
<h2 id="背景知识">背景知识</h2>
<p>了解 Linux 内核中的流量拦截和代理需要具备以下背景知识。</p>
<h3 id="netfilter">Netfilter</h3>
<p>Netfilter 是 Linux 内核内部的<strong>包过滤和处理框架</strong>。如果你不熟悉 Iptables 和 Netfilter 体系结构，请参阅 <a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture">A Deep Dive into Iptables and Netfilter Architecture</a></p>
<p>一些要点：</p>
<ul>
<li>主机上的<strong>所有数据包</strong>都将通过 netfilter 框架</li>
<li>在 netfilter 框架中有 <strong>5 个钩子</strong>点：<code>PRE_ROUTING</code>, <code>INPUT</code>, <code>FORWARD</code>, <code>OUTPUT</code>, <code>POST_ROUTING</code></li>
<li>命令行工具 <code>iptables</code> 可用于<strong>动态地将规则插入到钩子点中</strong></li>
<li>可以通过组合各种 <code>iptables</code> 规则来操作数据包（接受/重定向/删除/修改，等等）</li>
</ul>
<p><img src="proxy_hooks.png" alt="The 5 hook points in netfilter framework">
此外，这 5 个钩子点还可以与内核的其他网络设施，如内核路由子系统进行协同工作。</p>
<p>此外，在每个钩子点中，规则被组织到具有预定义优先级的不同链中。为了按目的管理链，链被进一步组织到表中。现在有 5 个表：</p>
<ul>
<li><code>filter</code>：做正常的过滤，如接受，拒绝/删，跳</li>
<li><code>nat</code>：网络地址转换，包括 SNAT（源 nat) 和 DNAT（目的 nat)</li>
<li><code>mangle</code>：修改包属性，例如 TTL</li>
<li><code>raw</code>：最早的处理点，连接跟踪前的特殊处理 (conntrack 或 CT，也包含在上图中，但这不是链）</li>
<li><code>security</code>：本文未涉及</li>
</ul>
<p>将表/链添加到上图中，我们可以得到更详细的视图：</p>
<p><img src="proxy_hooks-and-tables.png" alt="iptables table/chains inside hook points"></p>
<h3 id="vip-与负载均衡-lb">VIP 与负载均衡 (LB)</h3>
<p>虚拟 IP (IP) 将所有后端 IP 隐藏给客户端/用户，因此客户端/用户总是与 VIP 的后端服务通信，而不需要关心 VIP 后面有多少实例。</p>
<p>VIP 总是伴随着负载均衡，因为它需要在不同的后端之间分配流量。</p>
<p><img src="proxy_vip-and-lb.png" alt="VIP and load balancing"></p>
<h3 id="cross-host-网络模型">Cross-host 网络模型</h3>
<p>主机 A 上的实例（容器、VM 等）如何与主机 B 上的另一个实例通信？有很多解决方案：</p>
<ul>
<li>直接路由：BGP 等</li>
<li>隧道：VxLAN, IPIP, GRE 等</li>
<li>NAT：例如 docker 的桥接网络模式</li>
<li>其它方式</li>
</ul>
<h2 id="节点代理模型">节点代理模型</h2>
<p>在 kubernetes 中，你可以将应用程序定义为 <code>Service</code>。<code>Service</code> 是一种抽象，它定义了一组 pod 的逻辑集和访问它们的策略。</p>
<h3 id="service-类型">Service 类型</h3>
<p>K8S 中定义了 4 种 <code>Service</code> 类型：</p>
<ul>
<li><code>ClusterIP</code>：通过 VIP 访问 Service，但该 VIP 只能在此集群内访问</li>
<li><code>NodePort</code>：通过 NodeIP:NodePort 访问 Service，这意味着该端口将暴露在集群内的所有节点上</li>
<li><code>ExternalIP</code>：与 <code>ClusterIP</code> 相同，但是这个 VIP 可以从这个集群之外访问</li>
<li><code>LoadBalancer</code></li>
</ul>
<p>这篇文章将关注 <code>ClusterIP</code>，但是其他三种类型在流量拦截和转发方面的底层实现非常相似。</p>
<h3 id="节点代理">节点代理</h3>
<p>一个 Service 有一个 VIP（本文中的 <code>ClusterIP</code>）和多个端点（后端 pod）。每个 pod 或节点都可以通过 VIP 直接访问应用程序。要做到这一点，节点代理程序需要在每个节点上运行，它应该能够透明地拦截到任何 <code>ClusterIP:Port</code>[注解 1] 的流量，并将它们重定向到一个或多个后端 pod。</p>
<p><img src="proxy_k8s-proxier-model.png" alt="Kubernetes proxier model"></p>
<blockquote>
<p>注解 1：</p>
<p>对 <code>ClusterIP</code> 的一个常见误解是，<code>ClusterIP</code> 是可访问的——它们不是通过定义访问的。如果 ping 一个 <code>ClusterIP</code>，可能会发现它不可访问。</p>
<p>根据定义，<strong>&lt;Protocol,ClusterIP,Port&gt;</strong> 元组独特地定义了一个服务（因此也定义了一个拦截规则）。例如，如果一个服务被定义为 <code>&lt;tcp,10.7.0.100,80&gt;</code>，那么代理只处理 <code>tcp:10.7.0.100:80</code> 的流量，其他流量，例如。<code>tcp:10.7.0.100:8080</code>, <code>udp:10.7.0.100:80</code> 将不会被代理。因此，也无法访问 ClusterIP（ICMP 流量）。</p>
<p>但是，如果你使用的是带有 IPVS 模式的 <code>kube-proxy</code>，那么确实可以通过 ping 访问 <code>ClusterIP</code>。这是因为 IPVS 模式实现比定义所需要的做得更多。你将在下面几节中看到不同之处。</p>
</blockquote>
<h3 id="节点代理的角色反向代理">节点代理的角色：反向代理</h3>
<p>想想节点代理的作用，在 K8S 网络模型中，它实际上是一个反向代理，也就是说，在每个节点上，它将：</p>
<ul>
<li>将所有后端 pod 隐藏到客户端</li>
<li>过滤所有出口流量（对后端的请求）</li>
</ul>
<p>对于 ingress traffic，它什么也不做。</p>
<h3 id="性能问题">性能问题</h3>
<p>如果我们在主机上有一个应用程序，并且在 K8S 集群中有 1K 个服务，那么我们永远无法猜测该应用程序在下一时刻将访问哪个服务（这里忽略网络策略）。因此，为了让应用程序能够访问所有服务，我们必须为节点上的所有服务应用所有代理规则。将这个想法推广到整个集群，这意味着：</p>
<p><strong>所有服务的代理规则应该应用于整个集群中的所有节点。</strong></p>
<p>在某种意义上，这是一个完全分布式的代理模型，因为任何节点都拥有集群的所有规则。</p>
<p>当集群变大时，这会导致严重的性能问题，因为每个节点上可能有数十万条规则 [6,7]。</p>
<h2 id="测试环境">测试环境</h2>
<h3 id="集群拓扑和测试环境">集群拓扑和测试环境</h3>
<p>我们将使用以下环境进行测试：</p>
<ul>
<li>一个 k8s 集群
<ul>
<li>一个 master 节点</li>
<li>一个 node 节点</li>
<li>网络解决方案：直接路由（PodIP 可直接路由）</li>
</ul>
</li>
<li>一个非 k8s 节点，但是它可以到达工作节点和 Pod（得益于直接路由网络方案）</li>
</ul>
<p><img src="proxy_test-env.png" alt="test env"></p>
<p>我们将在工作节点上部署 pod，并从 test 节点通过 <code>ClusterIP</code> 访问 pod 中的应用程序。</p>
<h3 id="创建一个-service">创建一个 Service</h3>
<p>创建一个简单的 <code>Statefulset</code>，其中包括一个 <code>Service</code>，该 <code>Service</code> 将有一个或多个后端 pod:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># see appendix for webapp.yaml</span>
$ kubectl create -f webapp.yaml

$ kubectl get svc -o wide webapp
NAME     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span style="color:#f92672">(</span>S<span style="color:#f92672">)</span>   AGE     SELECTOR
webapp   ClusterIP   10.7.111.132   &lt;none&gt;        80/TCP    2m11s   app<span style="color:#f92672">=</span>webapp

$ kubectl get pod -o wide | grep webapp
webapp-0    2/2     Running   <span style="color:#ae81ff">0</span>    2m12s 10.5.41.204    node1    &lt;none&gt;  &lt;none&gt;
</code></pre></div><p>应用程序在带有 tcp 协议的 80 端口上运行。</p>
<h3 id="可达性测试">可达性测试</h3>
<p>首先访问 PodIP+Port:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl 10.5.41.204:80
&lt;!DOCTYPE html&gt;
...
&lt;/html&gt;
</code></pre></div><p>成功的！然后用 <code>ClusterIP</code> 替换 PodIP 再试一次：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl 10.7.111.132:80
^C
</code></pre></div><p>正如所料，它是不可访问的！</p>
<p>在下一节中，我们将研究如何使用不同的方法使 <code>ClusterIP</code> 可访问。</p>
<h2 id="实现通过-userspace-socket-实现-proxy">实现：通过 userspace socket 实现 proxy</h2>
<h3 id="中间人模型">中间人模型</h3>
<p>最容易理解的实现是在此主机上的通信路径中插入我们的 <code>toy-proxy</code> 作为中间人：对于从本地客户端到 ClusterIP:Port 的每个连接，<strong>我们拦截该连接并将其分割为两个单独的连接</strong>:</p>
<ul>
<li>本地客户端和 <code>toy-proxy</code> 之间的连接</li>
<li>连接 <code>toy-proxy</code> 和后端 pod</li>
</ul>
<p>实现此目的的最简单方法是在用户空间中实现它：</p>
<ul>
<li><code>监听资源</code>：启动一个守护进程，监听 K8S apiserver、监视服务 (ClusterIP) 和端点 (Pod) 的变化</li>
<li><code>代理通信</code>：对于从本地客户端到服务 (ClusterIP) 的每个连接请求，通过充当中间人来拦截请求</li>
<li><code>动态应用代理规则</code>：对于任何 Service/Endpoint 更新，相应地更改 <code>toy-proxy</code> 连接设置</li>
</ul>
<p>对于我们上面的测试应用 <code>webapp</code>，数据流程如下图：</p>
<p><img src="proxy_userspace-proxier.png" alt="userspace-proxier"></p>
<h3 id="poc-实现">POC 实现</h3>
<p>让我们来看看上图的概念验证实现。</p>
<h4 id="代码">代码</h4>
<p>以下代码省略了一些错误处理代码，便于阅读：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">clusterIP</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;10.7.111.132&#34;</span>
	<span style="color:#a6e22e">podIP</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;10.5.41.204&#34;</span>
	<span style="color:#a6e22e">port</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">80</span>
	<span style="color:#a6e22e">proto</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;tcp&#34;</span>

	<span style="color:#a6e22e">addRedirectRules</span>(<span style="color:#a6e22e">clusterIP</span>, <span style="color:#a6e22e">port</span>, <span style="color:#a6e22e">proto</span>)
	<span style="color:#a6e22e">createProxy</span>(<span style="color:#a6e22e">podIP</span>, <span style="color:#a6e22e">port</span>, <span style="color:#a6e22e">proto</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addRedirectRules</span>(<span style="color:#a6e22e">clusterIP</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">port</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">proto</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Itoa</span>(<span style="color:#a6e22e">port</span>)
	<span style="color:#a6e22e">cmd</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">exec</span>.<span style="color:#a6e22e">Command</span>(<span style="color:#e6db74">&#34;iptables&#34;</span>, <span style="color:#e6db74">&#34;-t&#34;</span>, <span style="color:#e6db74">&#34;nat&#34;</span>, <span style="color:#e6db74">&#34;-A&#34;</span>, <span style="color:#e6db74">&#34;OUTPUT&#34;</span>, <span style="color:#e6db74">&#34;-p&#34;</span>, <span style="color:#e6db74">&#34;tcp&#34;</span>,
		<span style="color:#e6db74">&#34;-d&#34;</span>, <span style="color:#a6e22e">clusterIP</span>, <span style="color:#e6db74">&#34;--dport&#34;</span>, <span style="color:#a6e22e">p</span>, <span style="color:#e6db74">&#34;-j&#34;</span>, <span style="color:#e6db74">&#34;REDIRECT&#34;</span>, <span style="color:#e6db74">&#34;--to-port&#34;</span>, <span style="color:#a6e22e">p</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Run</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createProxy</span>(<span style="color:#a6e22e">podIP</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">port</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">proto</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#a6e22e">host</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;&#34;</span>
	<span style="color:#a6e22e">listener</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Listen</span>(<span style="color:#a6e22e">proto</span>, <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">JoinHostPort</span>(<span style="color:#a6e22e">host</span>, <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Itoa</span>(<span style="color:#a6e22e">port</span>)))

	<span style="color:#66d9ef">for</span> {
		<span style="color:#a6e22e">inConn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">listener</span>.<span style="color:#a6e22e">Accept</span>()
		<span style="color:#a6e22e">outConn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dial</span>(<span style="color:#a6e22e">proto</span>, <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">JoinHostPort</span>(<span style="color:#a6e22e">podIP</span>, <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Itoa</span>(<span style="color:#a6e22e">port</span>)))

		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">in</span>, <span style="color:#a6e22e">out</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">TCPConn</span>) {
			<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Proxying %v &lt;-&gt; %v &lt;-&gt; %v &lt;-&gt; %v\n&#34;</span>,
				<span style="color:#a6e22e">in</span>.<span style="color:#a6e22e">RemoteAddr</span>(), <span style="color:#a6e22e">in</span>.<span style="color:#a6e22e">LocalAddr</span>(), <span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">LocalAddr</span>(), <span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">RemoteAddr</span>())
			<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">copyBytes</span>(<span style="color:#a6e22e">in</span>, <span style="color:#a6e22e">out</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
			<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">copyBytes</span>(<span style="color:#a6e22e">out</span>, <span style="color:#a6e22e">in</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
		}(<span style="color:#a6e22e">inConn</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">TCPConn</span>), <span style="color:#a6e22e">outConn</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">TCPConn</span>))
	}

	<span style="color:#a6e22e">listener</span>.<span style="color:#a6e22e">Close</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">copyBytes</span>(<span style="color:#a6e22e">dst</span>, <span style="color:#a6e22e">src</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">TCPConn</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Copy</span>(<span style="color:#a6e22e">dst</span>, <span style="color:#a6e22e">src</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">HasSuffix</span>(<span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>(), <span style="color:#e6db74">&#34;use of closed network connection&#34;</span>) {
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;io.Copy error: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
		}
	}
	<span style="color:#a6e22e">dst</span>.<span style="color:#a6e22e">Close</span>()
	<span style="color:#a6e22e">src</span>.<span style="color:#a6e22e">Close</span>()
}
</code></pre></div><h4 id="一些解释">一些解释</h4>
<h5 id="traffic-拦截">traffic 拦截</h5>
<p>我们想拦截所有发往 <code>ClusterIP:Port</code> 的流量，但是在这个节点上任何设备都没有配置<code>ClusterIP</code>，因此我们无法执行诸如 listen（ClusterIP，Port）之类的操作，那么我们如何才能拦截呢？答案是：使用<code>iptables/netfilter</code> 提供的 <code>REDIRECT</code> 能力。</p>
<p>以下命令会将所有发往 <code>ClusterIP:Port</code> 的流量定向到 <code>localhost:Port</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo iptables -t nat -A OUTPUT -p tcp -d $CLUSTER_IP --dport $PORT -j REDIRECT --to-port $PORT
</code></pre></div><p>如果你现在不能理解这一点，不要害怕。稍后我们将讨论这个问题。</p>
<p>通过下面命令的输出来验证这一点：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ iptables -t nat -L -n
...
Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source      destination
REDIRECT   tcp  --  0.0.0.0/0   10.7.111.132         tcp dpt:80 redir ports <span style="color:#ae81ff">80</span>
</code></pre></div><p>在代码中，函数 <code>addRedirectRules()</code> 包装了上述过程。</p>
<h5 id="创建-proxy">创建 proxy</h5>
<p>函数 <code>createProxy()</code> 创建用户空间代理，并执行双向转发。</p>
<h4 id="可达性测试-1">可达性测试</h4>
<p>编译代码并执行二进制文件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ go build toy-proxy-userspace.go
$ sudo ./toy-proxy-userspace
</code></pre></div><p>现在测试访问：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl $CLUSTER_IP:$PORT
&lt;!DOCTYPE html&gt;
...
&lt;/html&gt;
</code></pre></div><p>成功！我们的代理传达的信息是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo ./toy-proxy-userspace
Creating proxy between &lt;host ip&gt;:53912 &lt;-&gt; 127.0.0.1:80 &lt;-&gt; &lt;host ip&gt;:40194 &lt;-&gt; 10.5.41.204:80
</code></pre></div><p>表示，对于原 <code>&lt;host ip&gt;:53912 &lt;-&gt; 10.7.111.132:80</code> 的连接请求，将其拆分为两个连接：</p>
<ol>
<li><code>&lt;host ip&gt;:53912 &lt;-&gt; 127.0.0.1:80</code></li>
<li><code>&lt;host ip&gt;:40194 &lt;-&gt; 10.5.41.204:80</code></li>
</ol>
<p>删除这条规则：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ iptables -t nat -L -n --line-numbers
...
Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
num  target     prot opt source               destination
<span style="color:#ae81ff">2</span>    REDIRECT   tcp  --  0.0.0.0/0   10.7.111.132         tcp dpt:80 redir ports <span style="color:#ae81ff">80</span>

<span style="color:#75715e"># iptables -t nat -D OUTPUT &lt;num&gt;</span>
$ iptables -t nat -D OUTPUT <span style="color:#ae81ff">2</span>
</code></pre></div><p>或者删除（刷新）所有规则，如果你把 iptabels 弄的一团糟的情况下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ iptables -t nat -F <span style="color:#75715e"># delete all rules</span>
$ iptables -t nat -X <span style="color:#75715e"># delete all custom chains</span>
</code></pre></div><h4 id="改进">改进</h4>
<p>在这个 <code>toy-proxy</code> 实现中，我们拦截了 <code>ClusterIP:80</code> 到 <code>localhost:80</code>，但是如果该主机上的本机应用程序也想使用 <code>localhost:80</code> 怎么办？此外，如果多个服务都公开 80 端口会怎样？显然，我们需要区分这些应用程序或服务。解决这个问题的正确方法是：为每个代理分配一个未使用的临时端口 TmpPort，拦截 <code>ClusterIP:Port</code> 到 <code>local:TmpPort</code>。例如，app1 使用 10001, app2 使用 10002。</p>
<p>其次，上面的代码只处理一个后端，如果有多个后端 pod 怎么办？因此，我们需要通过负载均衡算法将请求分发到不同的后端 pod。</p>
<p><img src="proxy_userspace-proxier-2.png" alt="userspace-proxier-2"></p>
<h4 id="优缺点">优缺点</h4>
<p>这种方法非常容易理解和实现，但是，它的性能会很差，因为它必须在两端以及内核和用户空间内存之间复制字节。</p>
<p>我们没有在这上面花太多时间，如果你感兴趣，可以在这里查看用户空间 <code>kube-proxy</code> 的简单实现。</p>
<p>接下来，让我们看看实现这个任务的另一种方法。</p>
<h2 id="实现通过-iptables-实现-proxy">实现：通过 iptables 实现 proxy</h2>
<p>用户空间代理程序的主要瓶颈来自内核-用户空间切换和数据复制。<strong>如果我们可以完全在内核空间中实现代理</strong>，它将在性能上大大提高，从而击败用户空间的代理。<code>iptables</code> 可用于实现这一目标。</p>
<p>在开始之前，让我们首先弄清楚在执行 <code>curl ClusterIP:Port</code> 时的流量路径，然后研究如何使用 <code>iptables</code> 规则使其可访问。</p>
<h3 id="host---clusterip单一后端">Host -&gt; ClusterIP（单一后端）</h3>
<p><code>ClusterIP</code> 不存在于任何网络设备上，所以为了让我们的数据包最终到达后端 Pod，我们需要将 <code>ClusterIP</code> 转换为 PodIP（可路由），即：</p>
<ul>
<li>条件：匹配 <code>dst=ClusterIP,proto=tcp,dport=80</code> 的数据包</li>
<li>操作：将数据包的 IP 报头中的 <code>dst=ClusterIP</code> 替换为 <code>dst=PodIP</code></li>
</ul>
<p>用网络术语来说，这是一个网络地址转换 (NAT) 过程。</p>
<h4 id="在哪里做-dnat">在哪里做 DNAT</h4>
<p>通过 curl 查看出口数据包路径（下图展示了数据流向过程）：</p>
<p><img src="proxy_host-to-clusterip-dnat.png" alt="host-to-clusterip-dnat"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">&lt;curl process&gt; -&gt; raw -&gt; CT -&gt; mangle -&gt; dnat -&gt; filter -&gt; security -&gt; snat -&gt; &lt;ROUTING&gt; -&gt; mangle -&gt; snat -&gt; NIC
</code></pre></div><p>很明显，在 OUTPUT 钩中只有一个 dnat（链），我们可以在其中进行 DNAT。</p>
<p>让我们看看我们将如何进行黑客入侵。</p>
<h4 id="检查当前的-nat-规则">检查当前的 NAT 规则</h4>
<p><code>NAT</code> 规则被组织到 <code>nat</code> 表中。检查 <code>nat</code> 表中的当前规则：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># -t &lt;table&gt;</span>
<span style="color:#75715e"># -L list rules</span>
<span style="color:#75715e"># -n numeric output</span>
$ iptables -t nat -L -n
Chain PREROUTING <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>

Chain INPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>

Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
DOCKER     all  --  0.0.0.0/0    !127.0.0.0/8   ADDRTYPE match dst-type LOCAL

Chain POSTROUTING <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
</code></pre></div><p>输出显示除了与 DOCKER 相关的规则外，没有其他规则。这些 DOCKER 规则是 DOCKER 在安装时插入的，但它们不会影响我们在这篇文章中的实验。所以我们忽略它们。</p>
<h4 id="增加-dnat-规则">增加 DNAT 规则</h4>
<p>为了便于查看，我们不会用 go 代码包装 <code>iptables</code> 命令，而是直接显示命令本身。</p>
<blockquote>
<p>注意：在继续之前，请确保删除了在上一节中添加的所有规则。</p>
</blockquote>
<p>确认目前无法访问 ClusterIP：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl $CLUSTER_IP:$PORT
^C
</code></pre></div><p>现在添加我们的出口 NAT 规则：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat ENV
CLUSTER_IP<span style="color:#f92672">=</span>10.7.111.132
POD_IP<span style="color:#f92672">=</span>10.5.41.204
PORT<span style="color:#f92672">=</span><span style="color:#ae81ff">80</span>
PROTO<span style="color:#f92672">=</span>tcp

<span style="color:#75715e"># -p               &lt;protocol&gt;</span>
<span style="color:#75715e"># -A               add rule</span>
<span style="color:#75715e"># --dport          &lt;dst port&gt;</span>
<span style="color:#75715e"># -d               &lt;dst ip&gt;</span>
<span style="color:#75715e"># -j               jump to</span>
<span style="color:#75715e"># --to-destination &lt;ip&gt;:&lt;port&gt;</span>
$ iptables -t nat -A OUTPUT -p $PROTO --dport $PORT -d $CLUSTER_IP -j DNAT --to-destination $POD_IP:$PORT
</code></pre></div><p>再次检查规则表：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ iptables -t nat -L -n

Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source      destination
DNAT       tcp  --  0.0.0.0/0   10.7.111.132   tcp dpt:80 to:10.5.41.204:80
</code></pre></div><p>我们可以看到规则已经被添加。</p>
<h4 id="测试可达性">测试可达性</h4>
<p>现在再一次访问：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl $CLUSTER_IP:$PORT
&lt;!DOCTYPE html&gt;
...
&lt;/html&gt;
</code></pre></div><p>就是这样！访问成功。</p>
<p>但是等等！我们期望出口的交通应该是正确的，但我们没有添加任何 NAT 规则的入口路径，怎么可能交通是正常的两个方向？事实证明，当你为一个方向添加一个 NAT 规则时，Linux 内核会自动为另一个方向添加保留规则！这与 conntrack (CT，连接跟踪）模块协同工作。</p>
<p><img src="proxy_host-to-clusterip-dnat-ct.png" alt="host-to-clusterip-dnat-ct"></p>
<h4 id="清理">清理</h4>
<p>删除这些规则：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ iptables -t nat -L -n --line-numbers
...
Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
num  target     prot opt source               destination
<span style="color:#ae81ff">2</span>    DNAT       tcp  --  0.0.0.0/0   10.7.111.132   tcp dpt:80 to:10.5.41.204:80

<span style="color:#75715e"># iptables -t &lt;table&gt; -D &lt;chain&gt; &lt;num&gt;</span>
$ iptables -t nat -D OUTPUT <span style="color:#ae81ff">2</span>
</code></pre></div><h3 id="host---clusterip-多个后端">Host -&gt; ClusterIP （多个后端）</h3>
<p>在上一节中，我们展示了如何使用一个后端 Pod 执行 NAT。现在让我们看看多后端情况。</p>
<blockquote>
<p>注意：在继续之前，请确保删除了在上一节中添加的所有规则。</p>
</blockquote>
<h4 id="伸缩-webapp">伸缩 webapp</h4>
<p>首先扩大我们的服务到 2 个后端 pod:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ kubectl scale sts webapp --replicas<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>
statefulset.apps/webapp scaled

$ kubectl get pod -o wide | grep webapp
webapp-0   2/2     Running   <span style="color:#ae81ff">0</span>   1h24m   10.5.41.204    node1    &lt;none&gt; &lt;none&gt;
webapp-1   2/2     Running   <span style="color:#ae81ff">0</span>   11s     10.5.41.5      node1    &lt;none&gt; &lt;none&gt;
</code></pre></div><h4 id="通过负载平衡添加-dnat-规则">通过负载平衡添加 DNAT 规则</h4>
<p>我们需要 <code>iptables</code> 中的 <code>statistic</code> 模块以概率的方式将请求分发到后端 pod，这样才能达到负载均衡的效果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># -m &lt;module&gt;</span>
$ iptables -t nat -A OUTPUT -p $PROTO --dport $PORT -d $CLUSTER_IP <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -m statistic --mode random --probability 0.5  <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -j DNAT --to-destination $POD1_IP:$PORT
$ iptables -t nat -A OUTPUT -p $PROTO --dport $PORT -d $CLUSTER_IP <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -m statistic --mode random --probability 1.0  <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    -j DNAT --to-destination $POD2_IP:$PORT
</code></pre></div><p>上面的命令指定在两个 pod 之间随机分配请求，每个都有 50% 的概率。</p>
<p>现在检查这些规则：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ iptables -t nat -L -n
...
Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target  prot opt source      destination
DNAT    tcp  --  0.0.0.0/0   10.7.111.132  tcp dpt:80 statistic mode random probability 0.50000000000 to:10.5.41.204:80
DNAT    tcp  --  0.0.0.0/0   10.7.111.132  tcp dpt:80 statistic mode random probability 1.00000000000 to:10.5.41.5:80
</code></pre></div><p><img src="proxy_host-to-clusterip-lb-ct.png" alt="host-to-clusterip-lb-ct"></p>
<h4 id="验证">验证</h4>
<p>现在，我们来验证下负载均衡是否生效。我们发出 8 个 请求，并捕获到这个主机通信的真实 PodIPs:</p>
<p>在测试节点上打开一个 shell:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ <span style="color:#66d9ef">for</span> i in <span style="color:#f92672">{</span>1..8<span style="color:#f92672">}</span>; <span style="color:#66d9ef">do</span> curl $CLUSTER_IP:$PORT 2&gt;&amp;<span style="color:#ae81ff">1</span> &gt;/dev/null; sleep 1; <span style="color:#66d9ef">done</span>
</code></pre></div><p>测试节点上的另一个 shell 窗口：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ tcpdump -nn -i eth0 port $PORT | grep <span style="color:#e6db74">&#34;GET /&#34;</span>
10.21.0.7.48306 &gt; 10.5.41.5.80:   ... HTTP: GET / HTTP/1.1
10.21.0.7.48308 &gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
10.21.0.7.48310 &gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
10.21.0.7.48312 &gt; 10.5.41.5.80:   ... HTTP: GET / HTTP/1.1
10.21.0.7.48314 &gt; 10.5.41.5.80:   ... HTTP: GET / HTTP/1.1
10.21.0.7.48316 &gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
10.21.0.7.48318 &gt; 10.5.41.5.80:   ... HTTP: GET / HTTP/1.1
10.21.0.7.48320 &gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
</code></pre></div><p>在 Pod1 中有 4 次，在 Pod2 中有 4 次，每个 pod 有 50%，这正是我们所期望的。</p>
<h4 id="清理-1">清理</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ iptables -t nat -L -n --line-numbers
...
Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
num  target     prot opt source               destination
<span style="color:#ae81ff">2</span>    DNAT    tcp  --  0.0.0.0/0   10.7.111.132  tcp dpt:80 statistic mode random probability 0.50000000000 to:10.5.41.204:80
<span style="color:#ae81ff">3</span>    DNAT    tcp  --  0.0.0.0/0   10.7.111.132  tcp dpt:80 statistic mode random probability 1.00000000000 to:10.5.41.5:80

$ iptables -t nat -D OUTPUT <span style="color:#ae81ff">2</span>
$ iptables -t nat -D OUTPUT <span style="color:#ae81ff">3</span>
</code></pre></div><h3 id="pod-app-a---clusterip-app-b">Pod (app A) -&gt; ClusterIP (app B)</h3>
<p>如果想通过 hostA 上的 <code>Pod A</code> 通过 <code>ClusterIP</code> 访问 <code>Pod B</code>，B 的 Pod 驻留在 hostB 上，我们应该做什么？</p>
<p>实际上，这与 <code>Host -&gt; ClusterIP</code> 情况非常相似，但是有一点需要注意：在执行 NAT 之后，源节点 (hostA) 需要将包发送到目的地 Pod 所在的正确目的地节点 (hostB)。根据不同的跨主机网络解决方案，这有很大不同：</p>
<ol>
<li>对于直接路由的情况下，主机只是发送数据包。对应的有这些解决方案：
<ul>
<li>calico + bird</li>
<li>cilium + kube-router（Cilium BGP 的默认解决方案）</li>
<li>cilium + bird（实际上这只是我们的测试环境网络解决方案）</li>
</ul>
</li>
<li>对于隧道的情况，每个主机上必须有一个代理，它在 DNAT 之后执行 encap，在 SNAT 之前执行 decap。这些解决方案包括：
<ul>
<li>calico + VxLAN 模式</li>
<li>flannel + IPIP 模式</li>
<li>flannel + VxLAN 模式</li>
<li>cilium + VxLAN 模式</li>
</ul>
</li>
<li>像 aws 的 ENI 模式：类似于直接路由，但不需要 BGP 代理
<ul>
<li>cilium + ENI 模式</li>
</ul>
</li>
</ol>
<p>下图展示了隧道的情况：</p>
<p><img src="proxy_tunneling.png" alt="tunneling"></p>
<p>代理与隧道相关的职责包括：</p>
<ul>
<li><strong>同步所有节点之间的隧道信息</strong>，例如描述哪个实例在哪个节点上的信息</li>
<li><strong>在 DNAT 之后对 pod 流量执行封装</strong>：对于所有的出口流量，例如来自 hostA 的 <code>dst=&lt;PodIP&gt;</code>，其中 PodIP 在 hostB 上，通过添加另一个头来封装数据包，例如 VxLAN 头，其中封装头有 <code>src=hostA_IP,dst=hostB_IP</code></li>
<li><strong>在 SNAT 之前对 Pod 流量执行解封装</strong>：解封装每个入口封装的数据包：删除外层（例如 VxLAN 标头）</li>
</ul>
<p>同时，主机需要决定：</p>
<ul>
<li>哪些数据包应该交给解码器（pod 流量），哪些不应该（例如主机流量）</li>
<li>哪些包应该封装（pod 流量），哪些不应该（例如主机流量）</li>
</ul>
<h3 id="重新构造-iptables-规则">重新构造 iptables 规则</h3>
<blockquote>
<p>注意：在继续之前，请确保删除了在上一节中添加的所有规则。</p>
</blockquote>
<p>当你有大量的 Service 时，每个节点上的 iptables 规则将相当复杂，因此你需要进行一些结构化工作来组织这些规则。</p>
<p>在本节中，我们将在 nat 表中创建几个专用的 iptables 链，具体如下：</p>
<ul>
<li>链 <code>KUBE-SERVICES</code>：拦截 nat 表的输出链中所有到此链的出口流量，如果它们被指定为 ClusterIP，则执行 DNAT</li>
<li>链 <code>KUBE-SVC-WEBAPP</code>：如果 <code>dst</code>、<code>proto</code> 和 <code>port</code> 匹配，则拦截该链 <code>KUBE-SERVICES</code> 中的所有流量</li>
<li>链 <code>KUBE-SEP-WEBAPP1</code>：拦截 50% 的流量在 <code>KUBE-SVC-WEBAPP</code> 到这里</li>
<li>链 <code>KUBE-SEP-WEBAPP2</code>：拦截 50% 的流量在 <code>KUBE-SVC-WEBAPP</code> 到这里</li>
</ul>
<p>DNAT 路径现在为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">OUTPUT -&gt; KUBE-SERVICES -&gt; KUBE-SVC-WEBAPP --&gt; KUBE-SEP-WEBAPP1
                                         <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>                                          <span style="color:#ae81ff">\-</span>-&gt; KUBE-SEP-WEBAPP2
</code></pre></div><p>如果你有多个 Service，DNAT 路径如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">OUTPUT -&gt; KUBE-SERVICES -&gt; KUBE-SVC-A --&gt; KUBE-SEP-A1
                      |              <span style="color:#ae81ff">\-</span>-&gt; KUBE-SEP-A2
                      |
                      |--&gt; KUBE-SVC-B --&gt; KUBE-SEP-B1
                      |              <span style="color:#ae81ff">\-</span>-&gt; KUBE-SEP-B2
                      |
                      |--&gt; KUBE-SVC-C --&gt; KUBE-SEP-C1
                                     <span style="color:#ae81ff">\-</span>-&gt; KUBE-SEP-C2
</code></pre></div><p>iptables 命令：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat add-dnat-structured.sh
source ../ENV

set -x

KUBE_SVCS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;KUBE-SERVICES&#34;</span>        <span style="color:#75715e"># chain that serves as kubernetes service portal</span>
SVC_WEBAPP<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;KUBE-SVC-WEBAPP&#34;</span>     <span style="color:#75715e"># chain that serves as DNAT entrypoint for webapp</span>
WEBAPP_EP1<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;KUBE-SEP-WEBAPP1&#34;</span>    <span style="color:#75715e"># chain that performs dnat to pod1</span>
WEBAPP_EP2<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;KUBE-SEP-WEBAPP2&#34;</span>    <span style="color:#75715e"># chain that performs dnat to pod2</span>

<span style="color:#75715e"># OUTPUT -&gt; KUBE-SERVICES</span>
sudo iptables -t nat -N $KUBE_SVCS
sudo iptables -t nat -A OUTPUT -p all -s 0.0.0.0/0 -d 0.0.0.0/0 -j $KUBE_SVCS

<span style="color:#75715e"># KUBE-SERVICES -&gt; KUBE-SVC-WEBAPP</span>
sudo iptables -t nat -N $SVC_WEBAPP
sudo iptables -t nat -A $KUBE_SVCS -p $PROTO -s 0.0.0.0/0 -d $CLUSTER_IP --dport $PORT -j $SVC_WEBAPP

<span style="color:#75715e"># KUBE-SVC-WEBAPP -&gt; KUBE-SEP-WEBAPP*</span>
sudo iptables -t nat -N $WEBAPP_EP1
sudo iptables -t nat -N $WEBAPP_EP2
sudo iptables -t nat -A $WEBAPP_EP1 -p $PROTO -s 0.0.0.0/0 -d 0.0.0.0/0 --dport $PORT -j DNAT --to-destination $POD1_IP:$PORT
sudo iptables -t nat -A $WEBAPP_EP2 -p $PROTO -s 0.0.0.0/0 -d 0.0.0.0/0 --dport $PORT -j DNAT --to-destination $POD2_IP:$PORT
sudo iptables -t nat -A $SVC_WEBAPP -p $PROTO -s 0.0.0.0/0 -d 0.0.0.0/0 -m statistic --mode random --probability 0.5  -j $WEBAPP_EP1
sudo iptables -t nat -A $SVC_WEBAPP -p $PROTO -s 0.0.0.0/0 -d 0.0.0.0/0 -m statistic --mode random --probability 1.0  -j $WEBAPP_EP2
</code></pre></div><p>现在测试我们设计：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./add-dnat-structured.sh
++ KUBE_SVCS<span style="color:#f92672">=</span>KUBE-SERVICES
++ SVC_WEBAPP<span style="color:#f92672">=</span>KUBE-SVC-WEBAPP
++ WEBAPP_EP1<span style="color:#f92672">=</span>KUBE-SEP-WEBAPP1
++ WEBAPP_EP2<span style="color:#f92672">=</span>KUBE-SEP-WEBAPP2
++ sudo iptables -t nat -N KUBE-SERVICES
++ sudo iptables -t nat -A OUTPUT -p all -s 0.0.0.0/0 -d 0.0.0.0/0 -j KUBE-SERVICES
++ sudo iptables -t nat -N KUBE-SVC-WEBAPP
++ sudo iptables -t nat -A KUBE-SERVICES -p tcp -s 0.0.0.0/0 -d 10.7.111.132 --dport <span style="color:#ae81ff">80</span> -j KUBE-SVC-WEBAPP
++ sudo iptables -t nat -N KUBE-SEP-WEBAPP1
++ sudo iptables -t nat -N KUBE-SEP-WEBAPP2
++ sudo iptables -t nat -A KUBE-SEP-WEBAPP1 -p tcp -s 0.0.0.0/0 -d 0.0.0.0/0 --dport <span style="color:#ae81ff">80</span> -j DNAT --to-destination 10.5.41.204:80
++ sudo iptables -t nat -A KUBE-SEP-WEBAPP2 -p tcp -s 0.0.0.0/0 -d 0.0.0.0/0 --dport <span style="color:#ae81ff">80</span> -j DNAT --to-destination 10.5.41.5:80
++ sudo iptables -t nat -A KUBE-SVC-WEBAPP -p tcp -s 0.0.0.0/0 -d 0.0.0.0/0 -m statistic --mode random --probability 0.5 -j KUBE-SEP-WEBAPP1
++ sudo iptables -t nat -A KUBE-SVC-WEBAPP -p tcp -s 0.0.0.0/0 -d 0.0.0.0/0 -m statistic --mode random --probability 1.0 -j KUBE-SEP-WEBAPP2
</code></pre></div><p>检查这些规则：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo iptables -t nat -L -n
...
Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target     prot opt source               destination
KUBE-SERVICES  all  --  0.0.0.0/0            0.0.0.0/0

Chain KUBE-SEP-WEBAPP1 <span style="color:#f92672">(</span><span style="color:#ae81ff">1</span> references<span style="color:#f92672">)</span>
target     prot opt source               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:10.5.41.204:80

Chain KUBE-SEP-WEBAPP2 <span style="color:#f92672">(</span><span style="color:#ae81ff">1</span> references<span style="color:#f92672">)</span>
target     prot opt source               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:10.5.41.5:80

Chain KUBE-SERVICES <span style="color:#f92672">(</span><span style="color:#ae81ff">1</span> references<span style="color:#f92672">)</span>
target     prot opt source               destination
KUBE-SVC-WEBAPP  tcp  --  0.0.0.0/0            10.7.111.132         tcp dpt:80

Chain KUBE-SVC-WEBAPP <span style="color:#f92672">(</span><span style="color:#ae81ff">1</span> references<span style="color:#f92672">)</span>
target     prot opt source               destination
KUBE-SEP-WEBAPP1  tcp  --  0.0.0.0/0            0.0.0.0/0            statistic mode random probability 0.50000000000
KUBE-SEP-WEBAPP2  tcp  --  0.0.0.0/0            0.0.0.0/0            statistic mode random probability 1.00000000000
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl $CLUSTER_IP:$PORT
&lt;!DOCTYPE html&gt;
...
&lt;/html&gt;
</code></pre></div><p>成功！</p>
<p>如果你将上面的输出与普通的 <code>kube-proxy</code> 规则进行比较，这两个规则是非常相似的，下面是从启用 <code>kube-proxy</code> 的节点提取的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Chain OUTPUT <span style="color:#f92672">(</span>policy ACCEPT<span style="color:#f92672">)</span>
target         prot opt source               destination
KUBE-SERVICES  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */

Chain KUBE-SERVICES <span style="color:#f92672">(</span><span style="color:#ae81ff">2</span> references<span style="color:#f92672">)</span>
target                     prot opt source               destination
KUBE-SVC-YK2SNH4V42VSDWIJ  tcp  --  0.0.0.0/0            10.7.22.18           /* default/nginx:web cluster IP */ tcp dpt:80

Chain KUBE-SVC-YK2SNH4V42VSDWIJ <span style="color:#f92672">(</span><span style="color:#ae81ff">1</span> references<span style="color:#f92672">)</span>
target                     prot opt source               destination
KUBE-SEP-GL2BLSI2B4ICU6WH  all  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx:web */ statistic mode random probability 0.33332999982
KUBE-SEP-AIRRSG3CIF42U3PX  all  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx:web */

Chain KUBE-SEP-GL2BLSI2B4ICU6WH <span style="color:#f92672">(</span><span style="color:#ae81ff">1</span> references<span style="color:#f92672">)</span>
target          prot opt source               destination
DNAT            tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx:web */ tcp to:10.244.3.181:80

Chain KUBE-SEP-AIRRSG3CIF42U3PX <span style="color:#f92672">(</span><span style="color:#ae81ff">1</span> references<span style="color:#f92672">)</span>
target          prot opt source               destination
DNAT            tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx:web */ tcp to:10.244.3.182:80
</code></pre></div><h3 id="进一步重新构造-iptables-规则">进一步重新构造 iptables 规则</h3>
<p>TODO：为来自集群外部的流量添加规则。</p>
<h2 id="实现通过-ipvs-实现-proxy">实现：通过 ipvs 实现 proxy</h2>
<p>虽然基于 iptables 的代理在性能上优于基于用户空间的代理，但在集群服务过多的情况下也会导致性能严重下降 [6,7]。</p>
<p>本质上，这是因为 iptables 判决是基于链的，它是一个复杂度为 O(n) 的线性算法。iptables 的一个好的替代方案是 IPVS——内核中的 L4 负载均衡器，它在底层使用 ipset（哈希实现），因此复杂度为 O(1)。</p>
<p>让我们看看如何使用 ipvs 实现相同的目标。</p>
<blockquote>
<p>注意：在继续之前，请确保删除了在上一节中添加的所有规则。</p>
</blockquote>
<h3 id="安装-ipvs">安装 IPVS</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ yum install -y ipvsadm

<span style="color:#75715e"># -l  list load balancing status</span>
<span style="color:#75715e"># -n  numeric output</span>
$ ipvsadm -ln
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
</code></pre></div><p>默认无规则</p>
<h4 id="增加虚拟真正的-services">增加虚拟/真正的 services</h4>
<p>使用 ipvs 实现负载均衡：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># -A/--add-service           add service</span>
<span style="color:#75715e"># -t/--tcp-service &lt;address&gt; VIP + Port</span>
<span style="color:#75715e"># -s &lt;method&gt;                scheduling-method</span>
<span style="color:#75715e"># -r/--real-server &lt;address&gt; real backend IP + Port</span>
<span style="color:#75715e"># -m                         masquerading (NAT)</span>
$ ipvsadm -A -t $CLUSTER_IP:$PORT -s rr
$ ipvsadm -a -t $CLUSTER_IP:$PORT -r $POD1_IP -m
$ ipvsadm -a -t $CLUSTER_IP:$PORT -r $POD2_IP -m
</code></pre></div><p>或者使用我的脚本：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./ipvs-add-server.sh
Adding virtual server CLUSTER_IP:PORT<span style="color:#f92672">=</span>10.7.111.132:80 ...
Adding real servers ...
10.7.111.132:80 -&gt; 10.5.41.204
10.7.111.132:80 -&gt; 10.5.41.5
Done
</code></pre></div><p>再次检查状态：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ipvsadm -ln
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.7.111.132:80 rr
  -&gt; 10.5.41.5:80                 Masq    <span style="color:#ae81ff">1</span>      <span style="color:#ae81ff">0</span>          <span style="color:#ae81ff">0</span>
  -&gt; 10.5.41.204:80               Masq    <span style="color:#ae81ff">1</span>      <span style="color:#ae81ff">0</span>          <span style="color:#ae81ff">0</span>
</code></pre></div><p>一些解释：</p>
<ul>
<li>对于所有发往 <code>10.7.111.132:80</code> 的流量，将负载均衡到 <code>10.5.41.5:80</code> 和 <code>10.5.41.204:80</code></li>
<li>使用轮询 (rr) 算法实现负载均衡</li>
<li>两个后端，每个后端的权重为 1（各 50％）</li>
<li>使用 MASQ（增强型 SNAT）在 VIP 和 RealIP 之间进行流量转发</li>
</ul>
<h3 id="验证-1">验证</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ <span style="color:#66d9ef">for</span> i in <span style="color:#f92672">{</span>1..8<span style="color:#f92672">}</span>; <span style="color:#66d9ef">do</span> curl $CLUSTER_IP:$PORT 2&gt;&amp;<span style="color:#ae81ff">1</span> &gt;/dev/null; sleep 1; <span style="color:#66d9ef">done</span>

$ tcpdump -nn -i eth0 port $PORT | grep <span style="color:#e6db74">&#34;HTTP: GET&#34;</span>
IP 10.21.0.7.49556 &gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49558 &gt; 10.5.41.5.80  : ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49560 &gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49562 &gt; 10.5.41.5.80  : ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49566 &gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49568 &gt; 10.5.41.5.80  : ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49570 &gt; 10.5.41.204.80: ... HTTP: GET / HTTP/1.1
IP 10.21.0.7.49572 &gt; 10.5.41.5.80  : ... HTTP: GET / HTTP/1.1
</code></pre></div><p>完美！</p>
<h3 id="清理-2">清理</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./ipvs-del-server.sh
Deleting real servers ...
10.7.111.132:80 -&gt; 10.5.41.204
10.7.111.132:80 -&gt; 10.5.41.5
Deleting virtual server CLUSTER_IP:PORT<span style="color:#f92672">=</span>10.7.111.132:80 ...
Done
</code></pre></div><h2 id="实现通过-bpf-实现-proxy">实现：通过 bpf 实现 proxy</h2>
<p>这也是一个 <code>O(1)</code> 代理，但是与 IPVS 相比具有更高的性能。</p>
<p>让我们看看如何在不到 100 行 C 代码中使用 eBPF 实现代理功能。</p>
<h3 id="先决条件">先决条件</h3>
<p>如果你有足够的时间和兴趣来阅读 eBPF/BPF，可以考虑阅读 <a href="https://docs.cilium.io/en/v1.6/bpf/">Cilium: BPF and XDP Reference Guide</a>，它对开发人员来说是一个完美的 BPF 文档。</p>
<h3 id="实现">实现</h3>
<p>让我们看看出口部分的基本概念：</p>
<ol>
<li>对于所有流量，匹配 <code>dst=CLUSTER_IP &amp;&amp; proto==TCP &amp;&amp; dport==80</code></li>
<li>更改目标 IP：<code>CLUSTER_IP -&gt; POD_IP</code></li>
<li>更新 IP 和 TCP 报头中的校验和文件（否则我们的数据包将被丢弃）</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__section(<span style="color:#e6db74">&#34;egress&#34;</span>)
<span style="color:#66d9ef">int</span> tc_egress(<span style="color:#66d9ef">struct</span> __sk_buff <span style="color:#f92672">*</span>skb)
{
    <span style="color:#66d9ef">const</span> __be32 cluster_ip <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x846F070A</span>; <span style="color:#75715e">// 10.7.111.132
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> __be32 pod_ip <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0529050A</span>;     <span style="color:#75715e">// 10.5.41.5
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> l3_off <span style="color:#f92672">=</span> ETH_HLEN;    <span style="color:#75715e">// IP header offset
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> l4_off <span style="color:#f92672">=</span> l3_off <span style="color:#f92672">+</span> <span style="color:#ae81ff">20</span>; <span style="color:#75715e">// TCP header offset: l3_off + sizeof(struct iphdr)
</span><span style="color:#75715e"></span>    __be32 sum;                     <span style="color:#75715e">// IP checksum
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)(<span style="color:#66d9ef">long</span>)skb<span style="color:#f92672">-&gt;</span>data;
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data_end <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)(<span style="color:#66d9ef">long</span>)skb<span style="color:#f92672">-&gt;</span>data_end;
    <span style="color:#66d9ef">if</span> (data_end <span style="color:#f92672">&lt;</span> data <span style="color:#f92672">+</span> l4_off) { <span style="color:#75715e">// not our packet
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> TC_ACT_OK;
    }

    <span style="color:#66d9ef">struct</span> iphdr <span style="color:#f92672">*</span>ip4 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> iphdr <span style="color:#f92672">*</span>)(data <span style="color:#f92672">+</span> l3_off);
    <span style="color:#66d9ef">if</span> (ip4<span style="color:#f92672">-&gt;</span>daddr <span style="color:#f92672">!=</span> cluster_ip <span style="color:#f92672">||</span> ip4<span style="color:#f92672">-&gt;</span>protocol <span style="color:#f92672">!=</span> IPPROTO_TCP <span style="color:#75715e">/* || tcp-&gt;dport == 80 */</span>) {
        <span style="color:#66d9ef">return</span> TC_ACT_OK;
    }

    <span style="color:#75715e">// DNAT: cluster_ip -&gt; pod_ip, then update L3 and L4 checksum
</span><span style="color:#75715e"></span>    sum <span style="color:#f92672">=</span> csum_diff((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>ip4<span style="color:#f92672">-&gt;</span>daddr, <span style="color:#ae81ff">4</span>, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>pod_ip, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>);
    skb_store_bytes(skb, l3_off <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> iphdr, daddr), (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>pod_ip, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>);
    l3_csum_replace(skb, l3_off <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> iphdr, check), <span style="color:#ae81ff">0</span>, sum, <span style="color:#ae81ff">0</span>);
	l4_csum_replace(skb, l4_off <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> tcphdr, check), <span style="color:#ae81ff">0</span>, sum, BPF_F_PSEUDO_HDR);

    <span style="color:#66d9ef">return</span> TC_ACT_OK;
}
</code></pre></div><p>对于入口部分，非常类似于出口代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">__section(<span style="color:#e6db74">&#34;ingress&#34;</span>)
<span style="color:#66d9ef">int</span> tc_ingress(<span style="color:#66d9ef">struct</span> __sk_buff <span style="color:#f92672">*</span>skb)
{
    <span style="color:#66d9ef">const</span> __be32 cluster_ip <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x846F070A</span>; <span style="color:#75715e">// 10.7.111.132
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> __be32 pod_ip <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0529050A</span>;     <span style="color:#75715e">// 10.5.41.5
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> l3_off <span style="color:#f92672">=</span> ETH_HLEN;    <span style="color:#75715e">// IP header offset
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> l4_off <span style="color:#f92672">=</span> l3_off <span style="color:#f92672">+</span> <span style="color:#ae81ff">20</span>; <span style="color:#75715e">// TCP header offset: l3_off + sizeof(struct iphdr)
</span><span style="color:#75715e"></span>    __be32 sum;                     <span style="color:#75715e">// IP checksum
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)(<span style="color:#66d9ef">long</span>)skb<span style="color:#f92672">-&gt;</span>data;
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data_end <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)(<span style="color:#66d9ef">long</span>)skb<span style="color:#f92672">-&gt;</span>data_end;
    <span style="color:#66d9ef">if</span> (data_end <span style="color:#f92672">&lt;</span> data <span style="color:#f92672">+</span> l4_off) { <span style="color:#75715e">// not our packet
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> TC_ACT_OK;
    }

    <span style="color:#66d9ef">struct</span> iphdr <span style="color:#f92672">*</span>ip4 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> iphdr <span style="color:#f92672">*</span>)(data <span style="color:#f92672">+</span> l3_off);
    <span style="color:#66d9ef">if</span> (ip4<span style="color:#f92672">-&gt;</span>saddr <span style="color:#f92672">!=</span> pod_ip <span style="color:#f92672">||</span> ip4<span style="color:#f92672">-&gt;</span>protocol <span style="color:#f92672">!=</span> IPPROTO_TCP <span style="color:#75715e">/* || tcp-&gt;dport == 80 */</span>) {
        <span style="color:#66d9ef">return</span> TC_ACT_OK;
    }

    <span style="color:#75715e">// SNAT: pod_ip -&gt; cluster_ip, then update L3 and L4 header
</span><span style="color:#75715e"></span>    sum <span style="color:#f92672">=</span> csum_diff((<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>ip4<span style="color:#f92672">-&gt;</span>saddr, <span style="color:#ae81ff">4</span>, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>cluster_ip, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>);
    skb_store_bytes(skb, l3_off <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> iphdr, saddr), (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>cluster_ip, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>);
    l3_csum_replace(skb, l3_off <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> iphdr, check), <span style="color:#ae81ff">0</span>, sum, <span style="color:#ae81ff">0</span>);
	l4_csum_replace(skb, l4_off <span style="color:#f92672">+</span> offsetof(<span style="color:#66d9ef">struct</span> tcphdr, check), <span style="color:#ae81ff">0</span>, sum, BPF_F_PSEUDO_HDR);

    <span style="color:#66d9ef">return</span> TC_ACT_OK;
}

<span style="color:#66d9ef">char</span> __license[] __section(<span style="color:#e6db74">&#34;license&#34;</span>) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;GPL&#34;</span>;
</code></pre></div><h3 id="编译并加载到内核中">编译并加载到内核中</h3>
<p>现在使用我的小脚本编译和加载到内核：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ./compile-and-load.sh
...
++ sudo tc filter show dev eth0 egress
filter protocol all pref <span style="color:#ae81ff">49152</span> bpf chain <span style="color:#ae81ff">0</span>
filter protocol all pref <span style="color:#ae81ff">49152</span> bpf chain <span style="color:#ae81ff">0</span> handle 0x1 toy-proxy-bpf.o:<span style="color:#f92672">[</span>egress<span style="color:#f92672">]</span> direct-action not_in_hw id <span style="color:#ae81ff">18</span> tag f5f39a21730006aa jited

++ sudo tc filter show dev eth0 ingress
filter protocol all pref <span style="color:#ae81ff">49152</span> bpf chain <span style="color:#ae81ff">0</span>
filter protocol all pref <span style="color:#ae81ff">49152</span> bpf chain <span style="color:#ae81ff">0</span> handle 0x1 toy-proxy-bpf.o:<span style="color:#f92672">[</span>ingress<span style="color:#f92672">]</span> direct-action not_in_hw id <span style="color:#ae81ff">19</span> tag b41159c5873bcbc9 jited
</code></pre></div><p>脚本是这样的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ cat compile-and-load.sh
set -x

NIC<span style="color:#f92672">=</span>eth0

<span style="color:#75715e"># compile c code into bpf code</span>
clang -O2 -Wall -c toy-proxy-bpf.c -target bpf -o toy-proxy-bpf.o

<span style="color:#75715e"># add tc queuing discipline (egress and ingress buffer)</span>
sudo tc qdisc del dev $NIC clsact 2&gt;&amp;<span style="color:#ae81ff">1</span> &gt;/dev/null
sudo tc qdisc add dev $NIC clsact

<span style="color:#75715e"># load bpf code into the tc egress and ingress hook respectively</span>
sudo tc filter add dev $NIC egress bpf da obj toy-proxy-bpf.o sec egress
sudo tc filter add dev $NIC ingress bpf da obj toy-proxy-bpf.o sec ingress

<span style="color:#75715e"># show info</span>
sudo tc filter show dev $NIC egress
sudo tc filter show dev $NIC ingress
</code></pre></div><h3 id="验证-2">验证</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl $CLUSTER_IP:$PORT
&lt;!DOCTYPE html&gt;
...
&lt;/html&gt;
</code></pre></div><p>完美！</p>
<h3 id="清理-3">清理</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sudo tc qdisc del dev $NIC clsact 2&gt;&amp;<span style="color:#ae81ff">1</span> &gt;/dev/null
</code></pre></div><h2 id="总结">总结</h2>
<p>在这篇文章中，我们用不同的方法手工实现了 <code>kube-proxy</code> 的核心功能。希望你现在对 kubernetes 节点代理有了更好的理解，以及关于网络的其他一些配置。</p>
<p>在这篇文章中使用的代码和脚本：<a href="https://github.com/icyxp/icyxp.github.io/tree/mastercode">这里</a>。</p>
<h3 id="参考文献">参考文献</h3>
<ol>
<li><a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/">Kubernetes Doc: CLI - kube-proxy</a></li>
<li><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/0011-ipvs-proxier.md">kubernetes/enhancements: enhancements/0011-ipvs-proxier.md</a></li>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types">Kubernetes Doc: Service types</a></li>
<li><a href="https://kubernetes.io/docs/concepts/cluster-administration/proxies/">Proxies in Kubernetes - Kubernetes</a></li>
<li><a href="https://medium.com/@benmeier_/a-quick-minimal-ipvs-load-balancer-demo-d5cc42d0deb4">A minimal IPVS Load Balancer demo</a></li>
<li><a href="https://docs.google.com/presentation/d/1BaIAywY2qqeHtyGZtlyAp89JIZs59MZLKcFLxKE6LyM/edit#slide=id.p3">Scaling Kubernetes to Support 50,000 Services</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37230013">华为云在 K8S 大规模场景下的 Service 性能优化实践</a></li>
</ol>
<h2 id="附录">附录</h2>
<p>webapp.yaml:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">apiVersion</span>: v1
<span style="color:#66d9ef">kind</span>: Service
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: webapp
  <span style="color:#66d9ef">labels</span>:
    <span style="color:#66d9ef">app</span>: webapp
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">ports</span>:
  - <span style="color:#66d9ef">port</span>: <span style="color:#ae81ff">80</span>
    <span style="color:#66d9ef">name</span>: web
  <span style="color:#66d9ef">selector</span>:
    <span style="color:#66d9ef">app</span>: webapp
---
<span style="color:#66d9ef">apiVersion</span>: apps/v1
<span style="color:#66d9ef">kind</span>: StatefulSet
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: webapp
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">serviceName</span>: <span style="color:#e6db74">&#34;webapp&#34;</span>
  <span style="color:#66d9ef">replicas</span>: <span style="color:#ae81ff">1</span>
  <span style="color:#66d9ef">selector</span>:
    <span style="color:#66d9ef">matchLabels</span>:
      <span style="color:#66d9ef">app</span>: webapp
  <span style="color:#66d9ef">template</span>:
    <span style="color:#66d9ef">metadata</span>:
      <span style="color:#66d9ef">labels</span>:
        <span style="color:#66d9ef">app</span>: webapp
    <span style="color:#66d9ef">spec</span>:
      <span style="color:#75715e"># affinity:</span>
      <span style="color:#75715e">#   nodeAffinity:</span>
      <span style="color:#75715e">#     requiredDuringSchedulingIgnoredDuringExecution:</span>
      <span style="color:#75715e">#       nodeSelectorTerms:</span>
      <span style="color:#75715e">#       - matchExpressions:</span>
      <span style="color:#75715e">#         - key: kubernetes.io/hostname</span>
      <span style="color:#75715e">#           operator: In</span>
      <span style="color:#75715e">#           values:</span>
      <span style="color:#75715e">#           - node1</span>
      <span style="color:#66d9ef">tolerations</span>:
      - <span style="color:#66d9ef">effect</span>: NoSchedule
        <span style="color:#66d9ef">key</span>: smoke
        <span style="color:#66d9ef">operator</span>: Equal
        <span style="color:#66d9ef">value</span>: test
      <span style="color:#66d9ef">containers</span>:
      - <span style="color:#66d9ef">name</span>: webapp
        <span style="color:#66d9ef">image</span>: nginx-slim:<span style="color:#ae81ff">0.8</span>
        <span style="color:#66d9ef">ports</span>:
        - <span style="color:#66d9ef">containerPort</span>: <span style="color:#ae81ff">80</span>
          <span style="color:#66d9ef">name</span>: web
</code></pre></div>
        </div>
        <!-- tags -->
        <div class="mb-3">
          <h5 class="d-inline-block mr-3">Tags:</h5>
          <ul class="list-inline d-inline-block">
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/iptables"> 
            Iptables</a>
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/ipvs"> , 
            Ipvs</a>
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/bpf"> , 
            Bpf</a>
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/netfilter"> , 
            Netfilter</a>
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/kube-proxy"> , 
            Kube-Proxy</a>
            
          </ul>
        </div>
        <!-- previous -->
        
<div class="col-12">
<ul class="pager blog-pager">

<li class="previous">
<a href="https://cloudnative.to/blog/zero-trust-service-mesh/" data-toggle="tooltip" data-placement="top" title="服务网格的零信任安全">&larr; 上一篇</a>
</li>
 
<li class="next">
<a href="https://cloudnative.to/blog/academy-6/" data-toggle="tooltip" data-placement="top" title="基于 Red Hat OpenShift 4 构建 Paas、DevOps 平台">下一篇 &rarr;</a>
</li>

</ul>
</div>


        <!-- previous -->

        <!-- recommend -->
        

<div class="mb-3">
  <h2>文章推荐</h2>
  <ul class="related">
  
    <li><a href="/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/">理解 Istio Service Mesh 中 Envoy 代理 Sidecar 注入及流量劫持</a></li>
  
    <li><a href="/blog/how-cilium-enhances-istio-with-socket-aware-bpf-programs/">使用Cilium增强Istio—通过Socket感知BPF程序</a></li>
  
  </ul>
</div>


        <!-- comments -->

        
        <div id="gitalk-container"></div>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
        <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
        <script>
          window.onload = function() {
              const gitalk = new Gitalk({
              clientID: '0f001988910adcfadfb7',
              clientSecret: '14f7d06ee5e6575c295d18fc11616e8cb60fb84e',
              repo: 'cloudnativeto.github.io',
              owner: 'cloudnativeto',
              admin: ['rootsongjc'],
              id: hex_md5(hex_md5(window.location.pathname + window.location.hash)), 
              distractionFreeMode: false 
            });
            (function() {
              if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
                document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
                return;
              }
              gitalk.render('gitalk-container');
            })();
          }
        </script>
        
      </div>
      <!-- sidebar -->
<aside class="col-lg-4 order-1 order-lg-2">
    <!-- categories -->
<div class="bg-pink px-4 py-5 box-shadow mb-5">
  <h4 class="mb-4">分类</h4>
  <ul class="list-unstyled">
    <li class="border-bottom"><a href="/categories/devops" class="d-block pb-3 mt-3 text-capitalize">Devops</a></li>
    <li class="border-bottom"><a href="/categories/devsecops" class="d-block pb-3 mt-3 text-capitalize">Devsecops</a></li>
    <li class="border-bottom"><a href="/categories/envoy" class="d-block pb-3 mt-3 text-capitalize">Envoy</a></li>
    <li class="border-bottom"><a href="/categories/istio" class="d-block pb-3 mt-3 text-capitalize">Istio</a></li>
    <li class="border-bottom"><a href="/categories/kubernetes" class="d-block pb-3 mt-3 text-capitalize">Kubernetes</a></li>
    <li class="border-bottom"><a href="/categories/serverless" class="d-block pb-3 mt-3 text-capitalize">Serverless</a></li>
    <li class="border-bottom"><a href="/categories/service-mesh" class="d-block pb-3 mt-3 text-capitalize">Service mesh</a></li>
    <li class="border-bottom"><a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="d-block pb-3 mt-3 text-capitalize">云原生</a></li>
    <li class="border-bottom"><a href="/categories/%e5%85%b6%e4%bb%96" class="d-block pb-3 mt-3 text-capitalize">其他</a></li>
    <li class="border-bottom"><a href="/categories/%e5%8f%af%e8%a7%82%e5%af%9f%e6%80%a7" class="d-block pb-3 mt-3 text-capitalize">可观察性</a></li>
    <li class="border-bottom"><a href="/categories/%e5%ae%89%e5%85%a8" class="d-block pb-3 mt-3 text-capitalize">安全</a></li>
    <li class="border-bottom"><a href="/categories/%e5%bc%80%e6%ba%90" class="d-block pb-3 mt-3 text-capitalize">开源</a></li>
    <li class="border-bottom"><a href="/categories/%e5%bc%80%e6%ba%90%e7%a4%be%e5%8c%ba" class="d-block pb-3 mt-3 text-capitalize">开源社区</a></li>
    <li class="border-bottom"><a href="/categories/%e6%8c%81%e7%bb%ad%e4%ba%a4%e4%bb%98" class="d-block pb-3 mt-3 text-capitalize">持续交付</a></li>
    <li class="border-bottom"><a href="/categories/%e7%a8%b3%e5%ae%9a%e6%80%a7" class="d-block pb-3 mt-3 text-capitalize">稳定性</a></li>
    <li class="border-bottom"><a href="/categories/%e8%be%b9%e7%bc%98%e8%ae%a1%e7%ae%97" class="d-block pb-3 mt-3 text-capitalize">边缘计算</a></li>
  </ul>
</div>

  <!-- tags -->
  

  <!-- profile -->
  <div class="bg-pink px-4 py-5 box-shadow mb-5 avatar-content">
    <div class="avatar">
      <div class="mx-auto avatar-wrp">
        <img class="rounded-circle avatar-img" src="/images/profile/Yanan-Zhao.jpeg">
      </div>
      <p class="avatar-name">
        <strong class="text-dark "><a href="https://arthurchiao.art/blog/cracking-k8s-node-proxy/">赵亚楠</a></strong> 
      </p>
      <p>大型互联网公司高级软件工程师，专注于网络 SDN，云原生，虚拟化，分布式存储，以及底层技术等。</p>
    </div>
  </div>
  <!-- toc -->
  
  <div class="bg-white px-4 py-5 box-shadow mb-5 sticky-top">
    <h4 class="mb-4">目录</h4>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#背景知识">背景知识</a>
      <ul>
        <li><a href="#netfilter">Netfilter</a></li>
        <li><a href="#vip-与负载均衡-lb">VIP 与负载均衡 (LB)</a></li>
        <li><a href="#cross-host-网络模型">Cross-host 网络模型</a></li>
      </ul>
    </li>
    <li><a href="#节点代理模型">节点代理模型</a>
      <ul>
        <li><a href="#service-类型">Service 类型</a></li>
        <li><a href="#节点代理">节点代理</a></li>
        <li><a href="#节点代理的角色反向代理">节点代理的角色：反向代理</a></li>
        <li><a href="#性能问题">性能问题</a></li>
      </ul>
    </li>
    <li><a href="#测试环境">测试环境</a>
      <ul>
        <li><a href="#集群拓扑和测试环境">集群拓扑和测试环境</a></li>
        <li><a href="#创建一个-service">创建一个 Service</a></li>
        <li><a href="#可达性测试">可达性测试</a></li>
      </ul>
    </li>
    <li><a href="#实现通过-userspace-socket-实现-proxy">实现：通过 userspace socket 实现 proxy</a>
      <ul>
        <li><a href="#中间人模型">中间人模型</a></li>
        <li><a href="#poc-实现">POC 实现</a></li>
      </ul>
    </li>
    <li><a href="#实现通过-iptables-实现-proxy">实现：通过 iptables 实现 proxy</a>
      <ul>
        <li><a href="#host---clusterip单一后端">Host -&gt; ClusterIP（单一后端）</a></li>
        <li><a href="#host---clusterip-多个后端">Host -&gt; ClusterIP （多个后端）</a></li>
        <li><a href="#pod-app-a---clusterip-app-b">Pod (app A) -&gt; ClusterIP (app B)</a></li>
        <li><a href="#重新构造-iptables-规则">重新构造 iptables 规则</a></li>
        <li><a href="#进一步重新构造-iptables-规则">进一步重新构造 iptables 规则</a></li>
      </ul>
    </li>
    <li><a href="#实现通过-ipvs-实现-proxy">实现：通过 ipvs 实现 proxy</a>
      <ul>
        <li><a href="#安装-ipvs">安装 IPVS</a></li>
        <li><a href="#验证-1">验证</a></li>
        <li><a href="#清理-2">清理</a></li>
      </ul>
    </li>
    <li><a href="#实现通过-bpf-实现-proxy">实现：通过 bpf 实现 proxy</a>
      <ul>
        <li><a href="#先决条件">先决条件</a></li>
        <li><a href="#实现">实现</a></li>
        <li><a href="#编译并加载到内核中">编译并加载到内核中</a></li>
        <li><a href="#验证-2">验证</a></li>
        <li><a href="#清理-3">清理</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a>
      <ul>
        <li><a href="#参考文献">参考文献</a></li>
      </ul>
    </li>
    <li><a href="#附录">附录</a></li>
  </ul>
</nav>
  </div>

</aside>
<!-- /sidebar -->

    </div>
  </div>
</section>
<!-- /blog details -->



<footer>
  
  <div class="section bg-secondary">
    <div class="container">
      <div class="row justify-content-between">
        
        <div class="col-lg-5 mb-5 mb-lg-0">
          
          <a class="mb-4 d-inline-block" href="/"><img class="img-fluid"
              src="/images/logo-alt.png" alt="云原生社区" width="60%"></a>
          <p class="text-light mb-5">云原生社区是国内最大的独立第三方云原生终端用户和泛开发者社区，由 CNCF 大使、开源意见领袖共同发起成立于 2020 年 5 月 12 日，提供云原生专业资讯，促进云原生产业发展。</p>
          <h4 class="text-white mb-4">关注我们</h4>
          
          <ul class="list-inline social-icon-alt">
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://twitter.com/cloudnativecn"><i class="fa fa-twitter"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://github.com/cloudnativeto"><i class="fa fa-github"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://mp.weixin.qq.com/s/vWlSdzz2MNdXRr0sd2-LFg"><i class="fa fa-wechat"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="mailto:contact@cloudnative.to"><i class="fa fa-envelope"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://cloudnative.to/blog/index.xml"><i class="fa fa-rss"></i></a>
            </li>
            
          </ul>
        </div>
        <div class="col-lg-5 mb-5 mb-lg-0">
            
            
            
            
            
            <div class="mb-5 address">
              <h4 class="text-white mb-4">联系信息</h4>
              <p class="text-light mb-3"><a href="/city/beijing">北京</a>|<a href="/city/shanghai">上海</a>|<a href="/city/chengdu">成都</a>|<a href="/city/shenzhen">深圳</a>|<a href="/city/hangzhou/">杭州</a>|<a href="/city/guangzhou/">广州</a>|<a href="https://github.com/cloudnativeto/community/issues/55">武汉</a>|<a href="/city/nanjing">南京</a>|<a href="https://github.com/cloudnativeto/community/issues/61">西安</a>|<a href="/city/dalian">大连</a>|<a href="https://github.com/cloudnativeto/community/issues/52">长沙</a>|<a href="https://github.com/cloudnativeto/community/issues/66">苏州</a>|<a href="https://github.com/cloudnativeto/community/issues/67">珠海</a>|<a href="https://github.com/cloudnativeto/community/issues/78">重庆</a>|<a href="https://github.com/cloudnativeto/community/issues/82">济南</a>|<a href="https://github.com/cloudnativeto/community/issues/83">厦门</a>|<a href="https://github.com/cloudnativeto/community/issues/86">无锡</a>|<a href="https://github.com/cloudnativeto/community/issues/91">青岛</a>|<a href="https://github.com/cloudnativeto/community/issues/103">郑州</a>|<a href="https://github.com/cloudnativeto/community/issues/107">合肥</a></p>
              <p class="text-light mb-3"></p>
              <p class="text-light mb-3">关注云原生社区微信公众号，加入社区并获取最新资讯。</p>
              <p class="text-light mb-3"><img src="/images/wechat-qrcode.png" width="128px"></p>
            </div>
            
            
        </div>
      </div>
    </div>
  </div>
  
  <div class="bg-secondary-darken py-4">
    <div class="container">
      <div class="row">
        <div class="col-md-6 text-center text-md-left mb-3 mb-md-0">
          <p class="mb-0 text-white">Copyright © 2021 云原生社区</p>
        </div>
        <div class="col-md-6 text-center text-md-right">
          <ul class="list-inline">
            
            <li class="list-inline-item mx-0"><a class="d-inline-block px-3 text-white" href="/policy"
                class="text-white">声明与政策</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>



<script>
  var indexURL = "/index.json"
</script>


<!-- JS Plugins -->

<script src="/plugins/jQuery/jquery.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/google-map/gmap.js"></script>

<script src="/plugins/venobox/venobox.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/search/search.js"></script>

<script src="/plugins/bigPicture/bigPicture.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>


<!-- Main Script -->

<script src="/js/script.min.js"></script>

<!-- Algolia -->
<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.min.js"></script>
<script>
  docsearch({
    apiKey: '870a8addaf7a712ecc6e33ce9def93b1',
    indexName: 'DocSearch',
    appId: '2506Q6I4IV',
    inputSelector: '#js-algolia-btn',
    debug: false,
  });
</script>

<!-- baidu tongji-->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f3dc895ea3bd6186cd835841d365c103";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


<!-- google analitycs -->

<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o),
      m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
  ga('create', 'UA-93485976-4', 'auto');
  ga('send', 'pageview');
</script>


</body>

</html>
