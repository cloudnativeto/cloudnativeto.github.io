<!DOCTYPE html><html lang="zh" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.5.0 for Hugo" />
  

  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
  

  

  
  
  
    
  
  <meta name="description" content="本文将介绍如何通过 Istio 和 Envoy 实现客户端无感知的 Redis Cluster 数据分片，并实现读写分离、流量镜像等高级流量管理功能。" />

  
  <link rel="alternate" hreflang="zh" href="https://cloudnative.to/blog/redis-cluster-with-istio/" />

  
  
  
    <meta name="theme-color" content="#0a55a7" />
  

  
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css" media="print" onload="this.media='all'">

  
  
  
    
    

    
    
    
    
      
      
    
    
    

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      
        
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.008259417e6adf8980695ebbbb46553f.css" />

  



  


  


  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f3dc895ea3bd6186cd835841d365c103";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_hu0802e500a55b0406ddf0453824effa47_6997_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hu0802e500a55b0406ddf0453824effa47_6997_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://cloudnative.to/blog/redis-cluster-with-istio/" />

  
  
  
  
  
  
  
  
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary_large_image" />
  
    <meta property="twitter:site" content="@CloudNativeCN" />
    <meta property="twitter:creator" content="@CloudNativeCN" />
  
  <meta property="og:site_name" content="云原生社区（中国）" />
  <meta property="og:url" content="https://cloudnative.to/blog/redis-cluster-with-istio/" />
  <meta property="og:title" content="在 Istio 中实现 Redis 集群的数据分片、读写分离和流量镜像 | 云原生社区（中国）" />
  <meta property="og:description" content="本文将介绍如何通过 Istio 和 Envoy 实现客户端无感知的 Redis Cluster 数据分片，并实现读写分离、流量镜像等高级流量管理功能。" /><meta property="og:image" content="https://cloudnative.to/media/sharing.png" />
    <meta property="twitter:image" content="https://cloudnative.to/media/sharing.png" /><meta property="og:locale" content="zh" />
  
    
      <meta
        property="article:published_time"
        content="2020-10-26T11:00:00&#43;08:00"
      />
    
    <meta property="article:modified_time" content="2024-02-29T20:20:20&#43;08:00">
  

  


    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cloudnative.to/blog/redis-cluster-with-istio/"
  },
  "headline": "在 Istio 中实现 Redis 集群的数据分片、读写分离和流量镜像",
  
  "datePublished": "2020-10-26T11:00:00+08:00",
  "dateModified": "2024-02-29T20:20:20+08:00",
  
  "author": {
    "@type": "Person",
    "name": "赵化冰"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "云原生社区（中国）",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cloudnative.to/media/logo.svg"
    }
  },
  "description": "本文将介绍如何通过 Istio 和 Envoy 实现客户端无感知的 Redis Cluster 数据分片，并实现读写分离、流量镜像等高级流量管理功能。"
}
</script>

  

  

  

  





  <title>在 Istio 中实现 Redis 集群的数据分片、读写分离和流量镜像 | 云原生社区（中国）</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="964d83bdc654f99b7a006e00b40a728a" >
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden="true"></i></button>
  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.62d6f8dfe8493f1c68557dde65bec362.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6 search-title">
          <p>搜索</p>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="关闭"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="搜索..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="搜索...">
        
      </div>

      
      

      
    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

      <div id="search-common-queries">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    











  


<header class="header--fixed">
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区（中国）"
            
            ></a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="切换导航">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区（中国）"
          
          ></a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/community"><span>社区</span></a>
          </li>

          
          

          

          
          
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link  active" href="/blog"><span>博客</span></a>
          </li>

          
          

          
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>小组</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/k8s-gateway-api"><span>Kubernetes Gateway API SIG</span></a>
              
            </div>
          </li>

          
          

          
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>资料</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/envoy/"><span>Envoy 中文文档</span></a>
              
                <a class="dropdown-item" href="/kubebuilder/"><span>Kubebuilder 中文文档</span></a>
              
                <a class="dropdown-item" href="https://lib.jimmysong.io/"><span>云原生资料库</span></a>
              
                <a class="dropdown-item" href="https://istio.io/latest/zh/"><span>Istio 中文文档</span></a>
              
            </div>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/event"><span>活动</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#feed"><span>更新</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#tags"><span>标签</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#about"><span>关于</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        

        
        <li class="nav-item">
            <a class="nav-link" href="/community/join/" data-toggle="tooltip" data-placement="bottom" title="加入社区" aria-label="主站"><i class="fa-brands fa-weixin" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item">
            <a class="nav-link js-search" href="#" data-toggle="tooltip" data-placement="bottom" title="搜索" aria-label="搜索"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item d-none d-lg-inline-flex">
            <a class="nav-link" href="https://github.com/cloudnativeto/cloudnative.to" target="_blank" rel="noopener" data-toggle="tooltip" data-placement="bottom" title="查看源码" aria-label="查看源码" aria-label="GitHub"><i class="fa-brands fa-github" aria-hidden="true"></i></a>
        </li>
        

        
        
        
        <li class="nav-item">
          <a href="#" class="nav-link set-theme">
            <i class="fa fa-sun" aria-hidden="true" id="theme-icon"></i>
          </a>
        </li>
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    <div class="container-xl">
    <div class="post-container">
        












  

  
  
  
<div class="article-container pt-3">
  <h1>在 Istio 中实现 Redis 集群的数据分片、读写分离和流量镜像</h1>

  

  
    


<div class="article-metadata">

  <div>
  
  
  
  
    <i class="fa-solid fa-feather"></i>
    

  <span >
      <a href="/author/%E8%B5%B5%E5%8C%96%E5%86%B0/">赵化冰</a></span>
    
    <span class="middot-divider"></span>
    
  
  
  
  
  
  
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/category/service-mesh/" class="text-capitalize">service mesh</a></span>
  
  </div>

  
  <span class="article-date">
    
    
      
          
          发布于
      
    
    2020-10-26
  </span>
  

  

  
  <span class="middot-divider"></span>
  字数 5021
  <span class="middot-divider"></span>
  <span class="article-reading-time">
      阅读时长 23 分钟
  </span>
  

  
  
  
  

</div>

    





  
</div>


    </div>
    <div class="border-bottom mb-2"></div>
    <div class="row flex-xl-nowrap">
        <div class="col-3 d-none d-xl-block docs-toc">
            <!-- toc -->
            
<div class="">
    <ul class="nav toc-top">
        <li>
            <a href="#" id="back_to_top" class="docs-toc-title">目录</a>
        </li>
    </ul>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#redis-cluster">Redis Cluster</a></li>
    <li><a href="#部署-istio">部署 Istio</a></li>
    <li><a href="#部署-redis-cluster">部署 Redis Cluster</a>
      <ul>
        <li><a href="#验证-redis-部署">验证 Redis 部署</a></li>
        <li><a href="#创建-redis-cluster">创建 Redis Cluster</a></li>
        <li><a href="#验证-redis-cluster">验证 Redis Cluster</a></li>
        <li><a href="#部署测试用客户端">部署测试用客户端</a></li>
      </ul>
    </li>
    <li><a href="#通过-istio-下发-redis-cluster-相关的-envoy-配置">通过 Istio 下发 Redis Cluster 相关的 Envoy 配置</a>
      <ul>
        <li><a href="#创建-envoy-redis-cluster">创建 Envoy Redis Cluster</a></li>
        <li><a href="#创建-envoy-redis-proxy">创建 Envoy Redis Proxy</a></li>
      </ul>
    </li>
    <li><a href="#验证-redis-cluster-功能">验证 Redis Cluster 功能</a>
      <ul>
        <li><a href="#redis-数据分片">Redis 数据分片</a></li>
        <li><a href="#redis-读写分离">Redis 读写分离</a></li>
        <li><a href="#redis-流量镜像">Redis 流量镜像</a></li>
      </ul>
    </li>
    <li><a href="#实现原理">实现原理</a></li>
    <li><a href="#小结">小结</a></li>
    <li><a href="#参考文档">参考文档</a></li>
  </ul>
</nav>
</div>

            <!-- /toc -->
            
            <div class="subscribe-module col-12 mt-1">
    <img src="/img/wechat.jpg" alt="image" title="云原生社区的微信公众号"/>
    <p class="text-center pt-1">关注「云原生社区动态」微信公众号，获取本站更新</p>
</div>

            
        </div>
        <main class="article-body col-9 container docs-content" role="main">
            <article class="article">
                <div class="article-style">
                    
                    <details class="toc-inpage d-print-none d-show-block mb-0">
  <summary class="font-weight-bold">点击查看目录</summary>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#redis-cluster">Redis Cluster</a></li>
    <li><a href="#部署-istio">部署 Istio</a></li>
    <li><a href="#部署-redis-cluster">部署 Redis Cluster</a>
      <ul>
        <li><a href="#验证-redis-部署">验证 Redis 部署</a></li>
        <li><a href="#创建-redis-cluster">创建 Redis Cluster</a></li>
        <li><a href="#验证-redis-cluster">验证 Redis Cluster</a></li>
        <li><a href="#部署测试用客户端">部署测试用客户端</a></li>
      </ul>
    </li>
    <li><a href="#通过-istio-下发-redis-cluster-相关的-envoy-配置">通过 Istio 下发 Redis Cluster 相关的 Envoy 配置</a>
      <ul>
        <li><a href="#创建-envoy-redis-cluster">创建 Envoy Redis Cluster</a></li>
        <li><a href="#创建-envoy-redis-proxy">创建 Envoy Redis Proxy</a></li>
      </ul>
    </li>
    <li><a href="#验证-redis-cluster-功能">验证 Redis Cluster 功能</a>
      <ul>
        <li><a href="#redis-数据分片">Redis 数据分片</a></li>
        <li><a href="#redis-读写分离">Redis 读写分离</a></li>
        <li><a href="#redis-流量镜像">Redis 流量镜像</a></li>
      </ul>
    </li>
    <li><a href="#实现原理">实现原理</a></li>
    <li><a href="#小结">小结</a></li>
    <li><a href="#参考文档">参考文档</a></li>
  </ul>
</nav>
</details>

                    
                    <p>Redis 是一个高性能的 key-value 存储系统，被广泛用于微服务架构中。如果我们想要使用 Redis 集群模式提供的高级特性，则需要对客户端代码进行改动，这带来了应用升级和维护的一些困难。利用 Istio 和 Envoy，我们可以在不修改客户端代码的前提下实现客户端无感知的 Redis Cluster 数据分片，并提供读写分离、流量镜像等高级流量管理功能。</p>
<h2 id="redis-cluster">Redis Cluster</h2>
<p>Redis 的一个常见用途是用作数据高速缓存。通过在应用服务器和数据库服务器之间加入一个 Redis 缓存层，可以减少应用服务器对数据库的大量读操作，避免数据库服务器在大压力下响应缓慢甚至宕机的风险，显著加强整个系统的健壮性。Redis 作为数据缓存的原理如图所示：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/redis-cluster-with-istio/images/redis-as-cache_hu3d9207b6334bba1f01f3327c446d9094_32114_b3dde88ba07705a383d844c4bcd3e8a8.webp 400w,
               /blog/redis-cluster-with-istio/images/redis-as-cache_hu3d9207b6334bba1f01f3327c446d9094_32114_8523ad33872dc825c2cccc4044d69a3f.webp 760w,
               /blog/redis-cluster-with-istio/images/redis-as-cache_hu3d9207b6334bba1f01f3327c446d9094_32114_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/redis-cluster-with-istio/images/redis-as-cache_hu3d9207b6334bba1f01f3327c446d9094_32114_b3dde88ba07705a383d844c4bcd3e8a8.webp"
               width="491"
               height="225"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>在一个小规模的系统中，上图所示的单个 Redis 就可以很好地实现缓存层的功能。当系统中需要缓存的数据量较大时，一个 Redis 服务器无法承担所有应用服务器的缓存需求；同时单个 Redis 实例失效时也会导致大量读请求被直接发送到后端的数据库服务器上，导致数据库服务器瞬时压力超标，影响系统的稳定性。我们可以采用 <a href="https://redis.io/topics/cluster-spec" target="_blank" rel="noopener">Redis Cluster</a> 来对缓存数据进行分片，将不同的数据放到不同的 Redis 分片中，以提高 Redis 缓存层的容量能力。在每个 Redis 分片中，还可以采用多个 replica 节点对缓存的读请求进行负载分担，并实现 Redis 的高可用。采用了 Redis Cluster 的系统如下图所示：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/redis-cluster-with-istio/images/redis-cluster-no-proxy_huba836917efa84911435a9b0e8a37f54a_77682_f5d1b291eee788894e881ec1ddd0c044.webp 400w,
               /blog/redis-cluster-with-istio/images/redis-cluster-no-proxy_huba836917efa84911435a9b0e8a37f54a_77682_7ad40ecd53c53b56872c5c5bee62d69d.webp 760w,
               /blog/redis-cluster-with-istio/images/redis-cluster-no-proxy_huba836917efa84911435a9b0e8a37f54a_77682_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/redis-cluster-with-istio/images/redis-cluster-no-proxy_huba836917efa84911435a9b0e8a37f54a_77682_f5d1b291eee788894e881ec1ddd0c044.webp"
               width="760"
               height="384"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>从图中可以看到，在 Redis Cluster 模式下，客户端需要根据集群的分片规则将不同 key 的读写操作发送到集群中不同的 Redis 节点上，因此客户端需要了解 Redis Cluster 的拓扑结构，这导致我们无法在不修改客户端的情况下将一个使用 Redis 独立节点模式的应用平滑迁移到 Redis Cluster 上。另外，由于客户端需要了解 Redis Cluster 的内部拓扑，也将导致客户端代码和 Redis Cluster 运维上的耦合，例如要实现读写分离或者流量镜像的话，就需要修改每个客户端的代码并重新部署。</p>
<p>这种场景下，我们可以在应用服务器和 Redis Cluster 之间放置一个 Envoy 代理服务器，由 Envoy 来负责将应用发出的缓存读写请求路由到正确的 Redis 节点上。一个微服务系统中存在大量需要访问缓存服务器的应用进程，为了避免单点故障和性能瓶颈，我们以 Sidecar 的形式为每个应用进程部署一个 Envoy 代理。同时，为了简化对这些代理的管理工作，我们可以采用 Istio 作为控制面来统一对所有 Envoy 代理进行配置，如下图所示：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/redis-cluster-with-istio/images/redis-cluster-with-proxy_hucbdfe8712407070907d2a3e51e04c9b0_89297_b95df2fcd74e781a48ae16435e0df947.webp 400w,
               /blog/redis-cluster-with-istio/images/redis-cluster-with-proxy_hucbdfe8712407070907d2a3e51e04c9b0_89297_a7fbcb40ba7fd18120e0b9879b86d1d0.webp 760w,
               /blog/redis-cluster-with-istio/images/redis-cluster-with-proxy_hucbdfe8712407070907d2a3e51e04c9b0_89297_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/redis-cluster-with-istio/images/redis-cluster-with-proxy_hucbdfe8712407070907d2a3e51e04c9b0_89297_b95df2fcd74e781a48ae16435e0df947.webp"
               width="760"
               height="361"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>在本文的后续部分，我们将介绍如何通过 Istio 和 Envoy 来管理 Redis Cluster，实现客户端无感知的数据分区，以及读写分离、流量镜像等高级路由策略。</p>
<h2 id="部署-istio">部署 Istio</h2>
<p>Pilot 中已经支持了 Redis 协议，但功能较弱，只能为 Redis 代理配置一个缺省路由，而且不支持 Redis Cluster 模式，无法实现 Redis filter 的数据分片、读写分离、流量镜像等高级流量管理功能。为了让 Istio 可以将 Redis Cluster 相关的配置下发到 Envoy Sidecar 上，我们修改了 EnvoyFilter 配置相关代码，以支持 EnvoyFilter 的 &ldquo;REPLCAE&rdquo; 操作。该修改的 PR <a href="https://github.com/istio/istio/pull/27426/" target="_blank" rel="noopener">Implement REPLACE operation for EnvoyFilter patch</a> 已经提交到 Istio 社区，并合入到了主分支中，将在 Istio 后续的版本中发布。</p>
<p>在撰写本文的时候，最新的 Istio 发布版本 1.7.3 中尚未合入该 PR。因此我构建了一个 Pilot 镜像，以启用 EnvoyFilter 的 &ldquo;REPLACE&rdquo; 操作。在安装 Istio 时，我们需要在 istioctl 命令中指定采用该 Pilot 镜像，如下面的命令行所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nb">cd</span> istio-1.7.3/bin
</span></span><span class="line"><span class="cl">$ ./istioctl install --set components.pilot.hub<span class="o">=</span>zhaohuabing --set components.pilot.tag<span class="o">=</span>1.7.3-enable-ef-replace
</span></span></code></pre></div><p>备注：如果你采用的 Istio 版本新于 1.7.3，并且已经合入了该 PR，则可以直接采用 Istio 版本中缺省的 Pilot 镜像。</p>
<h2 id="部署-redis-cluster">部署 Redis Cluster</h2>
<p>请从 <a href="https://github.com/zhaohuabing/istio-redis-culster" target="_blank" rel="noopener">https://github.com/zhaohuabing/istio-redis-culster</a> 下载下面示例中需要用到的相关代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ git clone https://github.com/zhaohuabing/istio-redis-culster.git
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> istio-redis-culster
</span></span></code></pre></div><p>我们创建一个 &ldquo;redis&rdquo; namespace 来部署本例中的 Redis Cluster。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl create ns redis
</span></span><span class="line"><span class="cl">namespace/redis created
</span></span></code></pre></div><p>部署 Redis 服务器的 Statefulset 和 Configmap。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl apply -f k8s/redis-cluster.yaml -n redis
</span></span><span class="line"><span class="cl">configmap/redis-cluster created
</span></span><span class="line"><span class="cl">statefulset.apps/redis-cluster created
</span></span><span class="line"><span class="cl">service/redis-cluster created
</span></span></code></pre></div><h3 id="验证-redis-部署">验证 Redis 部署</h3>
<p>确认 Redis 节点已经启动并正常运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl get pod -n redis
</span></span><span class="line"><span class="cl">NAME              READY   STATUS    RESTARTS   AGE
</span></span><span class="line"><span class="cl">redis-cluster-0   2/2     Running   <span class="m">0</span>          4m25s
</span></span><span class="line"><span class="cl">redis-cluster-1   2/2     Running   <span class="m">0</span>          3m56s
</span></span><span class="line"><span class="cl">redis-cluster-2   2/2     Running   <span class="m">0</span>          3m28s
</span></span><span class="line"><span class="cl">redis-cluster-3   2/2     Running   <span class="m">0</span>          2m58s
</span></span><span class="line"><span class="cl">redis-cluster-4   2/2     Running   <span class="m">0</span>          2m27s
</span></span><span class="line"><span class="cl">redis-cluster-5   2/2     Running   <span class="m">0</span>          117s
</span></span></code></pre></div><h3 id="创建-redis-cluster">创建 Redis Cluster</h3>
<p>在上面的步骤中，我们采用 Statefulset 部署了 6 个 Redis 节点，但目前这 6 个节点还是相互独立的，并未形成一个集群。下面我们采用 Redis 的 <code>cluster create</code> 命令将这些节点组成一个 Redis Cluster。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> -it redis-cluster-0 -n redis -- redis-cli --cluster create --cluster-replicas <span class="m">1</span> <span class="k">$(</span>kubectl get pods -l <span class="nv">app</span><span class="o">=</span>redis-cluster -o <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">&#39;{range.items[*]}{.status.podIP}:6379 &#39;</span> -n redis<span class="k">)</span>
</span></span><span class="line"><span class="cl">Defaulting container name to redis.
</span></span><span class="line"><span class="cl">Use <span class="s1">&#39;kubectl describe pod/redis-cluster-0 -n redis&#39;</span> to see all of the containers in this pod.
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; Performing <span class="nb">hash</span> slots allocation on <span class="m">6</span> nodes...
</span></span><span class="line"><span class="cl">Master<span class="o">[</span>0<span class="o">]</span> -&gt; Slots <span class="m">0</span> - <span class="m">5460</span>
</span></span><span class="line"><span class="cl">Master<span class="o">[</span>1<span class="o">]</span> -&gt; Slots <span class="m">5461</span> - <span class="m">10922</span>
</span></span><span class="line"><span class="cl">Master<span class="o">[</span>2<span class="o">]</span> -&gt; Slots <span class="m">10923</span> - <span class="m">16383</span>
</span></span><span class="line"><span class="cl">Adding replica 172.16.0.72:6379 to 172.16.0.138:6379
</span></span><span class="line"><span class="cl">Adding replica 172.16.0.201:6379 to 172.16.1.52:6379
</span></span><span class="line"><span class="cl">Adding replica 172.16.0.139:6379 to 172.16.1.53:6379
</span></span><span class="line"><span class="cl">M: 8fdc7aa28a6217b049a2265b87bff9723f202af0 172.16.0.138:6379
</span></span><span class="line"><span class="cl">   slots:<span class="o">[</span>0-5460<span class="o">]</span> <span class="o">(</span><span class="m">5461</span> slots<span class="o">)</span> master
</span></span><span class="line"><span class="cl">M: 4dd6c1fecbbe4527e7d0de61b655e8b74b411e4c 172.16.1.52:6379
</span></span><span class="line"><span class="cl">   slots:<span class="o">[</span>5461-10922<span class="o">]</span> <span class="o">(</span><span class="m">5462</span> slots<span class="o">)</span> master
</span></span><span class="line"><span class="cl">M: 0b86a0fbe76cdd4b48434b616b759936ca99d71c 172.16.1.53:6379
</span></span><span class="line"><span class="cl">   slots:<span class="o">[</span>10923-16383<span class="o">]</span> <span class="o">(</span><span class="m">5461</span> slots<span class="o">)</span> master
</span></span><span class="line"><span class="cl">S: 94b139d247e9274b553c82fbbc6897bfd6d7f693 172.16.0.139:6379
</span></span><span class="line"><span class="cl">   replicates 0b86a0fbe76cdd4b48434b616b759936ca99d71c
</span></span><span class="line"><span class="cl">S: e293d25881c3cf6db86034cd9c26a1af29bc585a 172.16.0.72:6379
</span></span><span class="line"><span class="cl">   replicates 8fdc7aa28a6217b049a2265b87bff9723f202af0
</span></span><span class="line"><span class="cl">S: ab897de0eca1376558e006c5b0a49f5004252eb6 172.16.0.201:6379
</span></span><span class="line"><span class="cl">   replicates 4dd6c1fecbbe4527e7d0de61b655e8b74b411e4c
</span></span><span class="line"><span class="cl">Can I <span class="nb">set</span> the above configuration? <span class="o">(</span><span class="nb">type</span> <span class="s1">&#39;yes&#39;</span> to accept<span class="o">)</span>: yes
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; Nodes configuration updated
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; Assign a different config epoch to each node
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster
</span></span><span class="line"><span class="cl">Waiting <span class="k">for</span> the cluster to join
</span></span><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; Performing Cluster Check <span class="o">(</span>using node 172.16.0.138:6379<span class="o">)</span>
</span></span><span class="line"><span class="cl">M: 8fdc7aa28a6217b049a2265b87bff9723f202af0 172.16.0.138:6379
</span></span><span class="line"><span class="cl">   slots:<span class="o">[</span>0-5460<span class="o">]</span> <span class="o">(</span><span class="m">5461</span> slots<span class="o">)</span> master
</span></span><span class="line"><span class="cl">   <span class="m">1</span> additional replica<span class="o">(</span>s<span class="o">)</span>
</span></span><span class="line"><span class="cl">M: 4dd6c1fecbbe4527e7d0de61b655e8b74b411e4c 172.16.1.52:6379
</span></span><span class="line"><span class="cl">   slots:<span class="o">[</span>5461-10922<span class="o">]</span> <span class="o">(</span><span class="m">5462</span> slots<span class="o">)</span> master
</span></span><span class="line"><span class="cl">   <span class="m">1</span> additional replica<span class="o">(</span>s<span class="o">)</span>
</span></span><span class="line"><span class="cl">S: 94b139d247e9274b553c82fbbc6897bfd6d7f693 172.16.0.139:6379
</span></span><span class="line"><span class="cl">   slots: <span class="o">(</span><span class="m">0</span> slots<span class="o">)</span> slave
</span></span><span class="line"><span class="cl">   replicates 0b86a0fbe76cdd4b48434b616b759936ca99d71c
</span></span><span class="line"><span class="cl">M: 0b86a0fbe76cdd4b48434b616b759936ca99d71c 172.16.1.53:6379
</span></span><span class="line"><span class="cl">   slots:<span class="o">[</span>10923-16383<span class="o">]</span> <span class="o">(</span><span class="m">5461</span> slots<span class="o">)</span> master
</span></span><span class="line"><span class="cl">   <span class="m">1</span> additional replica<span class="o">(</span>s<span class="o">)</span>
</span></span><span class="line"><span class="cl">S: ab897de0eca1376558e006c5b0a49f5004252eb6 172.16.0.201:6379
</span></span><span class="line"><span class="cl">   slots: <span class="o">(</span><span class="m">0</span> slots<span class="o">)</span> slave
</span></span><span class="line"><span class="cl">   replicates 4dd6c1fecbbe4527e7d0de61b655e8b74b411e4c
</span></span><span class="line"><span class="cl">S: e293d25881c3cf6db86034cd9c26a1af29bc585a 172.16.0.72:6379
</span></span><span class="line"><span class="cl">   slots: <span class="o">(</span><span class="m">0</span> slots<span class="o">)</span> slave
</span></span><span class="line"><span class="cl">   replicates 8fdc7aa28a6217b049a2265b87bff9723f202af0
</span></span><span class="line"><span class="cl"><span class="o">[</span>OK<span class="o">]</span> All nodes agree about slots configuration.
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; Check <span class="k">for</span> open slots...
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; Check slots coverage...
</span></span><span class="line"><span class="cl"><span class="o">[</span>OK<span class="o">]</span> All <span class="m">16384</span> slots covered.
</span></span></code></pre></div><h3 id="验证-redis-cluster">验证 Redis Cluster</h3>
<p>我们可以采用 <code>cluster info</code> 命令查看 Redis Cluster 的配置信息和 Cluster 中的成员节点，以验证集群是否创建成功。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> -it redis-cluster-0 -c redis -n redis -- redis-cli cluster info 
</span></span><span class="line"><span class="cl">cluster_state:ok
</span></span><span class="line"><span class="cl">cluster_slots_assigned:16384
</span></span><span class="line"><span class="cl">cluster_slots_ok:16384
</span></span><span class="line"><span class="cl">cluster_slots_pfail:0
</span></span><span class="line"><span class="cl">cluster_slots_fail:0
</span></span><span class="line"><span class="cl">cluster_known_nodes:6
</span></span><span class="line"><span class="cl">cluster_size:3
</span></span><span class="line"><span class="cl">cluster_current_epoch:6
</span></span><span class="line"><span class="cl">cluster_my_epoch:1
</span></span><span class="line"><span class="cl">cluster_stats_messages_ping_sent:206
</span></span><span class="line"><span class="cl">cluster_stats_messages_pong_sent:210
</span></span><span class="line"><span class="cl">cluster_stats_messages_sent:416
</span></span><span class="line"><span class="cl">cluster_stats_messages_ping_received:205
</span></span><span class="line"><span class="cl">cluster_stats_messages_pong_received:206
</span></span><span class="line"><span class="cl">cluster_stats_messages_meet_received:5
</span></span><span class="line"><span class="cl">cluster_stats_messages_received:416
</span></span></code></pre></div><h3 id="部署测试用客户端">部署测试用客户端</h3>
<p>我们部署一个客户端，以用于发送测试命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl apply -f k8s/redis-client.yaml -n redis
</span></span><span class="line"><span class="cl">deployment.apps/redis-client created
</span></span></code></pre></div><h2 id="通过-istio-下发-redis-cluster-相关的-envoy-配置">通过 Istio 下发 Redis Cluster 相关的 Envoy 配置</h2>
<p>在下面的步骤中，我们将通过 Istio 向 Envoy Sidecar 下发 Redis Cluster 相关配置，以在无需改动客户端的情况下启用 Redis Cluster 的高级功能，包括数据分片、读写分离和流量镜像。</p>
<h3 id="创建-envoy-redis-cluster">创建 Envoy Redis Cluster</h3>
<p>Envoy 提供了 &ldquo;envoy.clusters.redis&rdquo; 类型的 Envoy Cluster 来连接后端的 Redis Cluster，Envoy 会通过该 Cluster 获取后端 Redis Cluster 的拓扑结构，包括有多少个分片（shard），每个分片负责哪些 slot，以及分片中包含哪些节点，以将来自客户端的请求分发到正确的 Redis 节点上。</p>
<p>采用 EnvoyFilter 来创建所需的 Envoy Redis Cluster：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl apply -f istio/envoyfilter-custom-redis-cluster.yaml
</span></span><span class="line"><span class="cl">envoyfilter.networking.istio.io/custom-redis-cluster created
</span></span></code></pre></div><h3 id="创建-envoy-redis-proxy">创建 Envoy Redis Proxy</h3>
<p>Istio 缺省下发的 LDS 中配置的是 TCP proxy filter，我们需要将其替换为 Redis Proxy filter。</p>
<p>由于 1.7.3 中尚不支持 EnvoyFilter 的 &ldquo;REPLACE&rdquo; 操作，我们首先需要更新 EnvoyFilter 的 CRD 定义，然后才能创建该 EnvoyFilter：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl apply -f istio/envoyfilter-crd.yaml 
</span></span><span class="line"><span class="cl">customresourcedefinition.apiextensions.k8s.io/envoyfilters.networking.istio.io configured
</span></span></code></pre></div><p>采用 EnvoyFilter 来将 TCP proxy filter 替换为 Redis Proxy filter，以使 Envoy 可以代理来自客户端的 Redis 操作请求：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ sed -i .bak <span class="s2">&#34;s/\${REDIS_VIP}/`kubectl get svc redis-cluster -n redis -o=jsonpath=&#39;{.spec.clusterIP}&#39;`/&#34;</span> istio/envoyfilter-redis-proxy.yaml
</span></span><span class="line"><span class="cl">$ kubectl apply -f istio/envoyfilter-redis-proxy.yaml
</span></span><span class="line"><span class="cl">envoyfilter.networking.istio.io/add-redis-proxy created
</span></span></code></pre></div><h2 id="验证-redis-cluster-功能">验证 Redis Cluster 功能</h2>
<p>现在一切就绪，下面我们来验证 Redis Cluster 的各项功能。</p>
<h3 id="redis-数据分片">Redis 数据分片</h3>
<p>我们通过 Istio 将 EnvoyFilter 中定义的配置下发到 Envoy 后，Envoy 就能够自动发现后端 Redis Cluster 的拓扑结构，并根据客户端请求中的 key 将请求自动分发到 Redis Cluster 中正确的节点上。</p>
<p>根据前面创建 Redis Cluster 步骤中的命令行输出，我们可以看出该 Redis Cluster 的拓扑结构：Cluster 中有三个分片，每个分片中有一个 Master 节点，一个 Slave(Replica) 节点。客户端通过和其部署在同一个 Pod 中的 Envoy Proxy 访问 Redis Cluster，如下图所示：</p>
<p>















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/redis-cluster-with-istio/images/redis-cluster_hu574d5d43183bde6e78ff5d137e785540_148320_ebe9711fa14bcb54b89180256ae838cd.webp 400w,
               /blog/redis-cluster-with-istio/images/redis-cluster_hu574d5d43183bde6e78ff5d137e785540_148320_eb8a470b50dd6283f177ee3ac311ea69.webp 760w,
               /blog/redis-cluster-with-istio/images/redis-cluster_hu574d5d43183bde6e78ff5d137e785540_148320_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/redis-cluster-with-istio/images/redis-cluster_hu574d5d43183bde6e78ff5d137e785540_148320_ebe9711fa14bcb54b89180256ae838cd.webp"
               width="760"
               height="321"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<p>Redis Cluster 中各个分片的 Master 和 Slave 节点地址：</p>
<pre tabindex="0"><code>Shard[0] Master[0]  redis-cluster-0 172.16.0.138:6379   replica  redis-cluster-4 172.16.0.72:6379  -&gt; Slots 0 - 5460 
Shard[1] Master[1]  redis-cluster-1 172.16.1.52:6379    replica  redis-cluster-5 172.16.0.201:6379 -&gt; Slots 5461 - 10922
Shard[2] Master[2]  redis-cluster-2 172.16.1.53:6379    replica  redis-cluster-3 172.16.0.139:6379 -&gt; Slots 10923 - 16383
</code></pre><p>备注：如果你在自己的 K8s cluster 中部署该示例，那么 Redis Cluster 中各个节点的 IP 地址和拓扑结构可能稍有不同，但基本结构应该是类似的。</p>
<p>我们尝试从客户端向 Rdeis Cluster 发送一些不同 key 的 <code>set</code> 请求：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> -it <span class="sb">`</span>kubectl get pod -l <span class="nv">app</span><span class="o">=</span>redis-client -n redis -o <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">&#34;{.items[0].metadata.name}&#34;</span><span class="sb">`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; <span class="nb">set</span> a a
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; <span class="nb">set</span> b b
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; <span class="nb">set</span> c c
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; <span class="nb">set</span> d d
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; <span class="nb">set</span> e e
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; <span class="nb">set</span> f f
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; <span class="nb">set</span> g g
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; <span class="nb">set</span> h h
</span></span><span class="line"><span class="cl">OK
</span></span></code></pre></div><p>从客户端来看，所有的请求都成功了，我们可以使用 <code>scan</code> 命令在服务器端查看各个节点中的数据：</p>
<p>查看分片 Shard[0] 中的数据，master 节点是 redis-cluster-0 slave 节点是 redis-cluster-4。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> redis-cluster-0 -c redis -n redis -- redis-cli --scan
</span></span><span class="line"><span class="cl">b
</span></span><span class="line"><span class="cl">f
</span></span><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> redis-cluster-4 -c redis -n redis -- redis-cli --scan
</span></span><span class="line"><span class="cl">f
</span></span><span class="line"><span class="cl">b
</span></span></code></pre></div><p>查看分片 Shard[1] 中的数据，master 节点是 redis-cluster-1 slave 节点是 redis-cluster-5。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> redis-cluster-1 -c redis -n redis -- redis-cli --scan
</span></span><span class="line"><span class="cl">c
</span></span><span class="line"><span class="cl">g
</span></span><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> redis-cluster-5 -c redis -n redis -- redis-cli --scan
</span></span><span class="line"><span class="cl">g
</span></span><span class="line"><span class="cl">c
</span></span></code></pre></div><p>查看分片 Shard[2] 中的数据，master 节点是 redis-cluster-2 slave 节点是 redis-cluster-3。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> redis-cluster-2 -c redis -n redis -- redis-cli --scan
</span></span><span class="line"><span class="cl">a
</span></span><span class="line"><span class="cl">e
</span></span><span class="line"><span class="cl">d
</span></span><span class="line"><span class="cl">h
</span></span><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> redis-cluster-3 -c redis -n redis -- redis-cli --scan
</span></span><span class="line"><span class="cl">h
</span></span><span class="line"><span class="cl">e
</span></span><span class="line"><span class="cl">d
</span></span><span class="line"><span class="cl">a
</span></span></code></pre></div><p>从上面的验证结果中可以看到，客户端设置的数据被分发到了 Redis Cluster 中的三个分片中。该数据分发过程是由 Envoy Redis Proxy 自动实现的，客户端并不感知后端的 Redis Cluster，对客户端而言，和该 Redis Cluster 的交互与和一个单一 Redis 节点的交互是相同的。</p>
<p>采用该方法，我们可以在应用业务规模逐渐扩张，单一 Redis 节点压力过大时，将系统中的 Redis 从单节点无缝迁移到集群模式。在集群模式下，不同 key 的数据被缓存在不同的数据分片中，我们可以增加分片中 Replica 节点的数量来对一个分片进行扩容，也可以增加分片个数来对整个集群进行扩展，以应对由于业务不断扩展而增加的数据压力。由于 Envoy 可以感知 Redis Cluster 集群拓扑，数据的分发由 Envoy 完成，整个迁移和扩容过程无需客户端，不会影响到线上业务的正常运行。</p>
<h3 id="redis-读写分离">Redis 读写分离</h3>
<p>在一个 Redis 分片中，通常有一个 Master 节点，一到多个 Slave（Replica）节点，Master 节点负责写操作，并将数据变化同步到 Slave 节点。当来自应用的读操作压力较大时，我们可以在分片中增加更多的 Replica，以对读操作进行负载分担。Envoy Redis Rroxy 支持设置不同的读策略：</p>
<ul>
<li><strong>MASTER：</strong>        只从 Master 节点读取数据，当客户端要求数据强一致性时需要采用该模式。该模式对 Master 压力较大，在同一个分片内无法采用多个节点对读操作进行负载分担。</li>
<li><strong>PREFER_MASTER：</strong>   优先从 Master 节点读取数据，当 Master 节点不可用时，从 Replica 节点读取。</li>
<li><strong>REPLICA：</strong>         只从 Replica 节点读取数据，由于 Master 到 Replica 的数据复制过程是异步执行的，采用该方式有可能读取到过期的数据，因此适用于客户端对数据一致性要求不高的场景。该模式下可以采用多个 Replica 节点来分担来自客户端的读负载。</li>
<li><strong>PREFER_REPLICA：</strong>  优先从 Replica 节点读取数据，当 Replica 节点不可用时，从 Master 节点读取。</li>
<li><strong>ANY：</strong>             从任意节点读取数据。</li>
</ul>
<p>在前面下发的 EnvoyFilter 中，我们将 Envoy Redis Proxy 的读策略设置为了 &ldquo;REPLICA&rdquo;，因此客户端的读操作应该只会被发送到 Replica 节点。让我们使用下面的命令来验证读写分离的策略：</p>
<p>通过客户端发起一系列 key 为 &ldquo;b&rdquo; 的 <code>get</code> 和 <code>set</code> 操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> -it <span class="sb">`</span>kubectl get pod -l <span class="nv">app</span><span class="o">=</span>redis-client -n redis -o <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">&#34;{.items[0].metadata.name}&#34;</span><span class="sb">`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; get b
</span></span><span class="line"><span class="cl"><span class="s2">&#34;b&#34;</span>
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; get b
</span></span><span class="line"><span class="cl"><span class="s2">&#34;b&#34;</span>
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; get b
</span></span><span class="line"><span class="cl"><span class="s2">&#34;b&#34;</span>
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; <span class="nb">set</span> b bb
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; get b
</span></span><span class="line"><span class="cl"><span class="s2">&#34;bb&#34;</span>
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; 
</span></span></code></pre></div><p>在前面的 Redis Cluster 拓扑中，我们已经得知 key &ldquo;b&rdquo; 属于 Shard[0] 这个分片。我们可以通过命令 <code>redis-cli monitor</code> 查看该分片中 Master 和 Replica 节点中收到的命令。</p>
<p>Master 节点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> redis-cluster-0 -c redis -n redis -- redis-cli monitor
</span></span></code></pre></div><p>Slave 节点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> redis-cluster-4 -c redis -n redis -- redis-cli monitor
</span></span></code></pre></div><p>从下图中可以看到，所有 <code>get</code> 请求都被 Envoy 发送到了 Replica 节点上。
















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/redis-cluster-with-istio/images/redis-cluster-read-policy_hu013a6684a049a4c9a45bb95ef422917b_336243_e1bc14f652a7dd6618f4c6f9b22fc631.webp 400w,
               /blog/redis-cluster-with-istio/images/redis-cluster-read-policy_hu013a6684a049a4c9a45bb95ef422917b_336243_8e96f2eac8175a255ac76ed1ef5b9c2a.webp 760w,
               /blog/redis-cluster-with-istio/images/redis-cluster-read-policy_hu013a6684a049a4c9a45bb95ef422917b_336243_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/redis-cluster-with-istio/images/redis-cluster-read-policy_hu013a6684a049a4c9a45bb95ef422917b_336243_e1bc14f652a7dd6618f4c6f9b22fc631.webp"
               width="760"
               height="455"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<h3 id="redis-流量镜像">Redis 流量镜像</h3>
<p>Envoy Redis Proxy 支持流量镜像，即将客户端发送的请求同时发送到一个镜像 Redis 服务器/集群上。流量镜像是一个非常有用的功能，我们可以使用流量镜像将生产环境中的线上数据导入到测试环境中，以使用线上数据对应用进行尽可能真实的模拟测试，同时又不会影响到线上用户的正常使用。</p>
<p>我们创建一个单节点的 Redis 节点，用做镜像服务器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl apply -f k8s/redis-mirror.yaml -n redis 
</span></span><span class="line"><span class="cl">deployment.apps/redis-mirror created
</span></span><span class="line"><span class="cl">service/redis-mirror created
</span></span></code></pre></div><p>采用 EnvoFilter 来启用镜像策略：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ sed -i .bak <span class="s2">&#34;s/\${REDIS_VIP}/`kubectl get svc redis-cluster -n redis -o=jsonpath=&#39;{.spec.clusterIP}&#39;`/&#34;</span> istio/envoyfilter-redis-proxy-with-mirror.yaml
</span></span><span class="line"><span class="cl">$ kubectl apply -f istio/envoyfilter-redis-proxy-with-mirror.yaml
</span></span><span class="line"><span class="cl">envoyfilter.networking.istio.io/add-redis-proxy configured
</span></span></code></pre></div><p>通过客户端发起一系列 key 为 &ldquo;b&rdquo; 的 <code>get</code> 和 <code>set</code> 操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> -it <span class="sb">`</span>kubectl get pod -l <span class="nv">app</span><span class="o">=</span>redis-client -n redis -o <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">&#34;{.items[0].metadata.name}&#34;</span><span class="sb">`</span> -c redis-client -n redis -- redis-cli -h redis-cluster
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; get b
</span></span><span class="line"><span class="cl"><span class="s2">&#34;b&#34;</span>
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; get b
</span></span><span class="line"><span class="cl"><span class="s2">&#34;b&#34;</span>
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; get b
</span></span><span class="line"><span class="cl"><span class="s2">&#34;b&#34;</span>
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; <span class="nb">set</span> b bb
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; get b
</span></span><span class="line"><span class="cl"><span class="s2">&#34;bb&#34;</span>
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; <span class="nb">set</span> b bbb
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; get b
</span></span><span class="line"><span class="cl"><span class="s2">&#34;bbb&#34;</span>
</span></span><span class="line"><span class="cl">redis-cluster:6379&gt; get b
</span></span><span class="line"><span class="cl"><span class="s2">&#34;bbb&#34;</span>
</span></span></code></pre></div><p>可以通过命令 <code>redis-cli monitor</code> 分别查看 Master、Replica 和镜像节点中收到的命令。</p>
<p>Master 节点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> redis-cluster-0 -c redis -n redis -- redis-cli monitor
</span></span></code></pre></div><p>Slave 节点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> redis-cluster-4 -c redis -n redis -- redis-cli monitor
</span></span></code></pre></div><p>镜像节点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ kubectl <span class="nb">exec</span> -it <span class="sb">`</span>kubectl get pod -l <span class="nv">app</span><span class="o">=</span>redis-mirror -n redis -o <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">&#34;{.items[0].metadata.name}&#34;</span><span class="sb">`</span> -c redis-mirror -n redis -- redis-cli monitor
</span></span></code></pre></div><p>从下图中可以看到，所有 <code>set</code> 请求都被 Envoy 发送到了一份镜像节点上。
















<figure  >
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="" srcset="
               /blog/redis-cluster-with-istio/images/redis-cluster-mirror-policy_huf7ae1a63d4a796cfdefa85a80ff75cfa_531950_e09e9c64fc3ef8d2055aec3aa361ddd4.webp 400w,
               /blog/redis-cluster-with-istio/images/redis-cluster-mirror-policy_huf7ae1a63d4a796cfdefa85a80ff75cfa_531950_c0ade408dc6a7a753bbf75542e9c8aa3.webp 760w,
               /blog/redis-cluster-with-istio/images/redis-cluster-mirror-policy_huf7ae1a63d4a796cfdefa85a80ff75cfa_531950_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/redis-cluster-with-istio/images/redis-cluster-mirror-policy_huf7ae1a63d4a796cfdefa85a80ff75cfa_531950_e09e9c64fc3ef8d2055aec3aa361ddd4.webp"
               width="760"
               height="361"
               loading="lazy" data-zoomable /></div>
  </div></figure>
</p>
<h2 id="实现原理">实现原理</h2>
<p>在上面的步骤中，我们在 Istio 中创建了两个 EnvoyFilter 配置对象。这两个 EnvoyFilter 修改了 Envoy 代理的配置，主要包括两部分内容：Redis Proxy Network Filter 配置和 Redis Cluster 配置。</p>
<p>下面的 EnvoyFilter 替换了 Pilot 为 Redis Service 创建的 Listener 中的 TCP Proxy Network Filter，将其替换为一个 &ldquo;type.googleapis.com/envoy.config.filter.network.redis_proxy.v2.RedisProxy&rdquo; 类型的 Network Filter。该 Redis Proxy 的缺省路由指向 &ldquo;custom-redis-cluster&rdquo;，并且配置了读写分离策略和流量镜像策略。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">networking.istio.io/v1alpha3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">EnvoyFilter</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">add-redis-proxy</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">istio-system</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">configPatches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">applyTo</span><span class="p">:</span><span class="w"> </span><span class="l">NETWORK_FILTER</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">match</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">listener</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">${REDIS_VIP}_6379            </span><span class="w"> </span><span class="c"># Replace REDIS_VIP with the cluster IP of &#34;redis-cluster service</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">filterChain</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">filter</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;envoy.filters.network.tcp_proxy&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">patch</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">operation</span><span class="p">:</span><span class="w"> </span><span class="l">REPLACE</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">value</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">envoy.redis_proxy</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">typed_config</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">&#34;@type&#34;: </span><span class="l">type.googleapis.com/envoy.config.filter.network.redis_proxy.v2.RedisProxy</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">stat_prefix</span><span class="p">:</span><span class="w"> </span><span class="l">redis_stats</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">prefix_routes</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">catch_all_route</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">request_mirror_policy</span><span class="p">:</span><span class="w">            </span><span class="c"># Send requests to the mirror cluster</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span>- <span class="nt">cluster</span><span class="p">:</span><span class="w"> </span><span class="l">outbound|6379||redis-mirror.redis.svc.cluster.local</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">exclude_read_commands</span><span class="p">:</span><span class="w"> </span><span class="nt">True     # Mirror write commands only</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">cluster</span><span class="p">:</span><span class="w"> </span><span class="l">custom-redis-cluster</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">settings</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">op_timeout</span><span class="p">:</span><span class="w"> </span><span class="l">5s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">enable_redirection</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">enable_command_stats</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">read_policy</span><span class="p">:</span><span class="w"> </span><span class="l">REPLICA              </span><span class="w"> </span><span class="c"># Send read requests to replica</span><span class="w">
</span></span></span></code></pre></div><p>下面的 EnvoyFilter 在 Pilot 下发的 CDS 中创建了一个 &ldquo;envoy.clusters.redis&rdquo; 类型的 Cluster： &ldquo;custom-redis-cluster&rdquo;，该 Cluster 会采用 <a href="https://redis.io/commands/cluster-slots" target="_blank" rel="noopener">CLUSTER SLOTS 命令</a> 向 Redis 集群中的一个随机节点查询集群的拓扑结构，并在本地保存该拓扑结构，以将来自客户端的请求分发到集群中正确的 Redis 节点上。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">networking.istio.io/v1alpha3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">EnvoyFilter</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">custom-redis-cluster</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">istio-system</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">configPatches</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span>- <span class="nt">applyTo</span><span class="p">:</span><span class="w"> </span><span class="l">CLUSTER</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">patch</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">operation</span><span class="p">:</span><span class="w"> </span><span class="l">INSERT_FIRST</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nt">value</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;custom-redis-cluster&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">connect_timeout</span><span class="p">:</span><span class="w"> </span><span class="m">0.</span><span class="l">5s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">lb_policy</span><span class="p">:</span><span class="w"> </span><span class="l">CLUSTER_PROVIDED</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">load_assignment</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">cluster_name</span><span class="p">:</span><span class="w"> </span><span class="l">custom-redis-cluster</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">endpoints</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span>- <span class="nt">lb_endpoints</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span>- <span class="nt">endpoint</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">address</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="nt">socket_address</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nt">address</span><span class="p">:</span><span class="w"> </span><span class="l">redis-cluster-0.redis-cluster.redis.svc.cluster.local</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nt">port_value</span><span class="p">:</span><span class="w"> </span><span class="m">6379</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span>- <span class="nt">endpoint</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">address</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="nt">socket_address</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nt">address</span><span class="p">:</span><span class="w"> </span><span class="l">redis-cluster-1.redis-cluster.redis.svc.cluster.local</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nt">port_value</span><span class="p">:</span><span class="w"> </span><span class="m">6379</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span>- <span class="nt">endpoint</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">address</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="nt">socket_address</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nt">address</span><span class="p">:</span><span class="w"> </span><span class="l">redis-cluster-2.redis-cluster.redis.svc.cluster.local</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nt">port_value</span><span class="p">:</span><span class="w"> </span><span class="m">6379</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span>- <span class="nt">endpoint</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">address</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="nt">socket_address</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nt">address</span><span class="p">:</span><span class="w"> </span><span class="l">redis-cluster-3.redis-cluster.redis.svc.cluster.local</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nt">port_value</span><span class="p">:</span><span class="w"> </span><span class="m">6379</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span>- <span class="nt">endpoint</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">address</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="nt">socket_address</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nt">address</span><span class="p">:</span><span class="w"> </span><span class="l">redis-cluster-4.redis-cluster.redis.svc.cluster.local</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nt">port_value</span><span class="p">:</span><span class="w"> </span><span class="m">6379</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span>- <span class="nt">endpoint</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nt">address</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  </span><span class="nt">socket_address</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nt">address</span><span class="p">:</span><span class="w"> </span><span class="l">redis-cluster-5.redis-cluster.redis.svc.cluster.local</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="nt">port_value</span><span class="p">:</span><span class="w"> </span><span class="m">6379</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nt">cluster_type</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">envoy.clusters.redis</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="nt">typed_config</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">&#34;@type&#34;: </span><span class="l">type.googleapis.com/google.protobuf.Struct</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nt">value</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">cluster_refresh_rate</span><span class="p">:</span><span class="w"> </span><span class="l">5s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">cluster_refresh_timeout</span><span class="p">:</span><span class="w"> </span><span class="l">3s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">redirect_refresh_interval</span><span class="p">:</span><span class="w"> </span><span class="l">5s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              </span><span class="nt">redirect_refresh_threshold</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span></span></span></code></pre></div><h2 id="小结">小结</h2>
<p>本文介绍了如何使用 Envoy 为微服务应用提供客户端无感知的 Redis 数据分片，以及如何通过 Istio 来统一管理系统中多个 Envoy 代理的 Redis Cluster 配置。我们可以看到，采用 Istio 和 Envoy 可以大大简化客户端使用 Redis Cluster 的编码和配置工作，并且可以在线修改 Redis Cluster 的运维策略，实现读写分离、流量镜像等高级流量管理。当然，引入 Istio 和 Envoy 并未减少整个系统的复杂度，而是将 Redis Cluster 维护的工作从各个分散的应用代码中集中到了服务网格基础设施层。对应广大应用开放者来说，其业务价值主要来自于应用代码，将大量精力投入此类基础设施是不太划算的。建议直接采用腾讯云上的云原生 Service Mesh 服务 TCM（Tencent Cloud Mesh），为微服务应用快速引入 Service Mesh 的流量管理和服务治理能力，而无需再关注 Service Mesh 基础设施自身的安装、维护、升级等事项。</p>
<h2 id="参考文档">参考文档</h2>
<ul>
<li><a href="https://rancher.com/blog/2019/deploying-redis-cluster" target="_blank" rel="noopener">Deploying Redis Cluster on Top of Kubernetes</a></li>
<li><a href="https://medium.com/@fr33m0nk/migrating-to-redis-cluster-using-envoy-93a87ae79dc3" target="_blank" rel="noopener">Migrating to Redis cluster using envoy proxy</a></li>
<li><a href="https://github.com/istio/istio/pull/27426/" target="_blank" rel="noopener">Implement REPLACE operation for EnvoyFilter patch</a></li>
</ul>

                </div>
                

<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/service-mesh/">service mesh</a>
  
  <a class="badge badge-light" href="/tag/istio/">Istio</a>
  
  <a class="badge badge-light" href="/tag/envoy/">envoy</a>
  
  <a class="badge badge-light" href="/tag/redis/">Redis</a>
  
</div>











  
  
    



  
  
  
  
  
  <div class="media author-card content-widget-hr mb-4">
    
      
      <a href="/author/%E8%B5%B5%E5%8C%96%E5%86%B0/"><img class="avatar mr-3 avatar-circle" src="/author/%E8%B5%B5%E5%8C%96%E5%86%B0/avatar_hu584c926f62a0fa050bae237d0ba2c125_11613_270x270_fill_q75_lanczos_center.jpg" alt="赵化冰"></a>
    

    <div class="media-body">
      <p class="card-title"><a href="/author/%E8%B5%B5%E5%8C%96%E5%86%B0/">赵化冰</a></p>
      
      <p class="card-text">腾讯</p>
      
    </div>
  </div>


  





<div class="article-widget">
  
<div class="container-xl row post-nav">
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1" href="/blog/envoy-ama/" rel="next">
    <div class="meta-nav">下一页</div>
    <p>Envoy 调试流量的常用技巧直播分享及问答整理</p></a>
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1"  href="/blog/must-read-for-cloud-native-beginner/" rel="prev">
    <div class="meta-nav">上一页</div>
    <p>云原生初学者入门必读</p></a>
  
</div>

</div>










  

<p class="edit-page">
  <a href="https://github.com/cloudnativeto/cloudnative.to/edit/master/content/blog/redis-cluster-with-istio/index.md">
    <i class="fas fa-pen pr-2"></i>编辑本页
  </a>
</p>




  
  
  <div class="article-widget content-widget-hr">
    <p class="related-title">相关推荐</p>
    <ul>
      
      <li><a href="/blog/istiocon-layer7-traffic/">使用 Aeraki 在 Isito 中支持 Dubbo、Thrift、Redis，以及任何七层协议</a></li>
      
      <li><a href="/blog/service-mesh-the-microservices-in-post-kubernetes-era/">Service Mesh——后 Kubernetes 时代的微服务</a></li>
      
      <li><a href="/blog/service-mesh-in-cookpad/">服务网格在 Cookpad 网站中的实践</a></li>
      
      <li><a href="/blog/validating-a-request-payload-with-wasm/">使用 WebAssembly 验证请求负载</a></li>
      
      <li><a href="/blog/resiliency-app-aware-network/">利用服务网格和智能应用感知网络增强应用弹性</a></li>
      
    </ul>
  </div>
  





  
  
  

  

  
  <section id="comments" class="mb-3 pt-0">
    <script>
  let themeNumber = localStorage.getItem('wcTheme');
  var giscusTheme = "light";
  if (themeNumber == 1){
    giscusTheme = "dark";
  }
  let giscusAttributes = {
    "src": "https://giscus.app/client.js",
    "data-theme": giscusTheme,
    "data-repo":"cloudnativeto\/cloudnative.to",
    "data-repo-id":"MDEwOlJlcG9zaXRvcnkyMzc3NDUxOTA=",
    "data-category":"General",
    "data-category-id":"MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMyMDU5MzUy",
    "data-mapping":"pathname",
    "data-reactions-enabled":"",
    "data-emit-metadata":"0",
    "data-input-position":"top",
    "data-theme":giscusTheme,
    "data-lang":"zh-CN",
    "data-loading":"lazy",
    "crossorigin":"annoymous",
    "origins":"https://cloudnative.to",
    "originsRegex":"http://localhost:[0-9]+",
    "async": "",
  };

  let giscusScript = document.createElement("script");
  Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
  document.querySelector('#comments').appendChild(giscusScript);
</script>

  </section>
  



            </article>
        </main>
    </div>
</div>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">

  



  

  
  <div class="copyright py-4 bg-footer">
      <div class="row justify-content-center">
        <div class="text-center footer-color">
          <p class="mb-0">© 2020-2024 云原生社区保留所有权利</p>
        </div>
    </div>
  </div>

</footer>

    </div>
    
  </div>

  


<script src="/js/vendor-bundle.min.b4708d4364577c16ab7001b265a063a4.js"></script>




  

  
  

  

  
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js" integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin="anonymous"></script>
    
    
  










  
  <script id="search-hit-fuse-template" type="text/x-template">
    <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <div class="article-metadata search-hit-type">{{relpermalink}}</div>
          <a href="{{relpermalink}}">{{title}}</a>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
    </div>
  </script>
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin="anonymous"></script>
  












  
  
  
  
  
  
  







<script id="page-data" type="application/json">{"use_headroom":false}</script>










  
  


<script src="/zh/js/wowchemy.min.27bfa4a749fe1d78b45ea21d607b67f4.js"></script>







<script>

var mybutton = document.getElementById("backTopBtn");


window.onscroll = function() {scrollFunction()};

function scrollFunction() {
  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    mybutton.style.display = "block";
  } else {
    mybutton.style.display = "none";
  }
}


function topFunction() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
<script>
  anchors.add();
</script>



<script>



(function() {
  'use strict';

  if(!document.queryCommandSupported('copy')) {
    return;
  }

  function flashCopyMessage(el, msg) {
    el.className = "highlight-copy-btn";
    el.textContent = msg;
    setTimeout(function() {
      el.textContent = "";
      el.className = "highlight-copy-btn fa fa-copy";
    }, 1000);
  }

  function selectText(node) {
    var selection = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
    return selection;
  }

  function addCopyButton(containerEl) {
    var copyBtn = document.createElement("button");
    copyBtn.className = "highlight-copy-btn fa fa-copy";
    copyBtn.textContent = "";

    var codeEl = containerEl.firstElementChild;
    copyBtn.addEventListener('click', function() {
      try {
        var selection = selectText(codeEl);
        document.execCommand('copy');
        selection.removeAllRanges();
        
        flashCopyMessage(copyBtn, '已复制')
        
      } catch(e) {
        console && console.log(e);
        flashCopyMessage(copyBtn, 'Failed :\'(')
      }
    });

    containerEl.appendChild(copyBtn);
  }

  
  var highlightBlocks = document.getElementsByClassName('highlight');
  Array.prototype.forEach.call(highlightBlocks, addCopyButton);
})();
</script>



<script>

function Collapse(e){
  var node = document.getElementById(e);
  if (node.className.indexOf('fa-angle-down') > -1){
    node.setAttribute("class", "fa-solid fa-angle-right");
    }else{
    node.setAttribute("class", "fa-solid fa-angle-down");
    }
}
</script>


</body>
</html>
