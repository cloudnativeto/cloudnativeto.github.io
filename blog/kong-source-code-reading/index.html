<!DOCTYPE html>

<html lang="zh-cn"><head>
  <meta charset="utf-8">
  
  <title>云原生网关 Kong 源码分析 | 云原生社区</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文分析了 Kong 的启动流程、插件机制、缓存机制和请求的生命周期。">
  
  <meta name="author" content=" 云原生社区">
  <meta name="generator" content="Hugo 0.65.3" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="/plugins/bootstrap/bootstrap.min.css">
  
  <link rel="stylesheet" href="/plugins/slick/slick.css">
  
  <link rel="stylesheet" href="/plugins/fontawesome/all.css">
  
  <link rel="stylesheet" href="/plugins/animate/animate.css">
  
  <link rel="stylesheet" href="/plugins/venobox/venobox.css">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="/scss/style.min.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="/images/favicon.png " type="image/x-icon">
  <link rel="icon" href="/images/favicon.png " type="image/x-icon">
  <meta property="og:image" content="https://cloudnative.to/images/favicon.png">
  <!--Algolia-->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.min.css">
  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="Cloud Native Community|云原生社区" />
  <meta name="twitter:creator" content="@CloudNativeCN" />
  <meta property="og:url" content="https://cloudnative.to/blog/kong-source-code-reading/" />
  <meta property="og:title" content="云原生网关 Kong 源码分析" />
  <meta property="og:description" content="本文分析了 Kong 的启动流程、插件机制、缓存机制和请求的生命周期。" />
  <meta property="og:image" content="https://cloudnative.to/images/blog/kong-gateway.png" />
</head>
<body>
<!-- header -->

<img src="images/logo-square.jpg" width="0" height="0" />
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
     <img src="" width='700'>
</div>
<header>
  

  <!-- navigation -->
  <div class="navigation bg-white position-relative">
    <div class="container">
      <nav class="navbar navbar-expand-lg navbar-light bg-white">
        <a class="navbar-brand" href="/"><img class="img-fluid pb-lg-3" src="/images/logo.png" width="189px" alt="云原生社区"></a>
        <button class="navbar-toggler border-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link" href="/"></a>
            </li>
            
            
            <li class="nav-item">
              <a class="nav-link" href="/blog/">博客</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="/community/sig/">兴趣小组</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="/contribute">投稿</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="/job">招聘</a>
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                aria-expanded="false">
                社区
              </a>
              <div class="dropdown-menu" >
                
                <a class="dropdown-item" href="/team">管理委员会</a>
                
                <a class="dropdown-item" href="/academy/">云原生学院</a>
                
                <a class="dropdown-item" href="/city">城市站</a>
                
                <a class="dropdown-item" href="/community/">社区资料</a>
                
              </div>
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                aria-expanded="false">
                资料
              </a>
              <div class="dropdown-menu" >
                
                <a class="dropdown-item" href="http://landscape.opensourcecloud.cn/">云原生生态图景</a>
                
                <a class="dropdown-item" href="/kubebuilder">Kubebuilder 中文文档</a>
                
                <a class="dropdown-item" href="/envoy">Envoy 中文文档</a>
                
                <a class="dropdown-item" href="https://istio.io/latest/zh/">Istio 中文文档</a>
                
              </div>
            </li>
            
            
          </ul>

          
          

          
          
          <!-- get start btn -->
          <a href="/contact" class="btn btn-primary hover-ripple">加入我们</a>
          
        </div>
      </nav>
    </div>
  </div>
  <!-- /navigation -->
</header>
<!-- /header -->

	<!-- page title -->
<section class="section bg-cover overlay" style="background-image: url('/'),url('/'),url('/images/backgrounds/page-title-5.jpg');">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <h2 class="text-white mb-3">云原生网关 Kong 源码分析</h2>
        <!-- breadcrumb -->
        
        <p class="text-white">本文分析了 Kong 的启动流程、插件机制、缓存机制和请求的生命周期。</p>
      </div>
    </div>
  </div>
</section>
<!-- /page title -->

	

<!-- blog details -->
<section class="section">
  <div class="container blog">
    <div class="row">
      <div class="col-lg-8">
        <!-- post thumb -->
        <div class="position-relative mb-5">
          <img src="/"  onerror="this.src='\/images\/blog\/kong-gateway.png'" alt="post thumb" class="img-fluid w-100">
           <div class="card-type"><a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f">云原生</a></div>
        </div>
        <div class="card-meta mb-2">作者  <strong class="text-dark"><a href="https://github.com/mayocream">Mayo Cream</a></strong>
          
            发表于 <strong class="text-dark">2021年10月21日</strong></div>
        <hr>
        <div class="content">
          <p>本文针对 Kong 的启动流程、插件机制、缓存机制和请求的生命周期做了详细的阐述。</p>
<h2 id="1-概述">1. 概述</h2>
<p>本文针对的是 Kong 2.1 版本（Stable）。</p>
<p>我阅读并作出中文注释的 Commits 可以在这里看到： <br>
<a href="https://github.com/mayocream/kong/commits?author=huanghan39">https://github.com/mayocream/kong/commits?author=mayocream</a></p>
<p><strong>Kong（OpenResty）的执行阶段</strong>：</p>
<p><img src="openresty_phases.png" alt=""></p>
<p>Kong 的插件机制也是基于 OpenResty 的生命周期，只不过是其在上层做了些许封装。</p>
<p><strong>Kong 的数据库关联关系</strong>：</p>
<p><img src="kong_db.png" alt=""></p>
<p><a href="https://github.com/Kong/kong">Kong</a> 虽然介绍中说是 Cloud Native 项目，也上榜了 CNCF <a href="https://landscape.cncf.io/">全景图</a>，但是它还依赖于传统的数据库 PostgreSQL，并且还自定义了许多 Function，相比于 APISIX 的分布式储存 Etcd 显得较为弱势。比起 Etcd 客户端能建立 HTTP 长连接 Watch 数据变化，Kong 只能依赖定时的轮询从数据库更新状态，数据库高可用也相比搭建 Etcd 集群要复杂得多。</p>
<h2 id="2-配置文件">2. 配置文件</h2>
<p>Kong 在启动阶段会解析 <a href="https://github.com/kong/kong/tree/master/kong/templates"><code>kong/templates</code></a> 目录下的 <code>.lua</code> 模板文件，注入环境变量和 <code>kong.conf</code> 覆盖配置，生成 Nginx 启动的配置文件 <code>nginx.conf</code>。</p>
<p>结构如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">pid pids/nginx.pid;
error_log logs/error.log notice;

<span style="color:#75715e"># injected nginx_main_* directives</span>

env SKYWALKING_URL;

events {
    <span style="color:#75715e"># injected nginx_events_* directives</span>
    multi_accept on;
    worker_connections <span style="color:#ae81ff">16384</span>;
}

http {
    lua_package_path       <span style="color:#e6db74">&#39;./?.lua;./?/init.lua;;;;&#39;</span>;
    lua_package_cpath      <span style="color:#e6db74">&#39;;;;&#39;</span>;

    lua_shared_dict kong                        5m;
    lua_shared_dict kong_locks                  8m;
	...

    <span style="color:#75715e"># injected nginx_http_* directives</span>
    client_body_buffer_size 8k;

    init_by_lua_block {
        Kong = require <span style="color:#e6db74">&#39;kong&#39;</span>
        Kong.init()
    }

    init_worker_by_lua_block {
        Kong.init_worker()
    }

    upstream kong_upstream {
        server <span style="color:#ae81ff">0.0.0.1</span>;

        <span style="color:#75715e"># injected nginx_upstream_* directives</span>
        
        balancer_by_lua_block {
            Kong.balancer()
        }
    }

	<span style="color:#75715e"># Kong Proxy</span>
    server {
        server_name kong;
		...
    }

	<span style="color:#75715e"># Kong Admin API</span>
    server {
        server_name kong_admin;
        ...
    }


}
</code></pre></div><p>Kong 定义了 <code>NGINX_MAIN_XXX</code>，诸如此类的环境变量，在解析配置阶段会加载到 <code>nginx.conf</code> 的指定位置，能够避免直接修改模板文件。</p>
<p>例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 在 main 块里定义 env 变量</span>
$ export NGINX_MAIN_ENV SKYWALKING_URL;
<span style="color:#75715e"># 创建新的 lua shared dict</span>
$ export NGINX_HTTP_Lua_SHARED_DICT tracing_buffer 128m;
</code></pre></div><p>Kong <a href="https://docs.konghq.com/2.1.x/configuration/">官方的配置文档</a>已经非常详尽，解释了各个参数代表的含义。</p>
<p>这里补充一点，通常我们需要定义多个 Shared dict，配置写法需要改成这种形式：</p>
<pre><code>nginx_http_lua_shared_dict = cache_buffer_one 128m; lua_shared_dict cache_buffer_two 128m
</code></pre><h2 id="3-初始化">3. 初始化</h2>
<h3 id="31-数据库初始化">3.1. 数据库初始化</h3>
<p><code>Kong.init()</code> 方法中初始化数据库相关：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#75715e">-- 数据库连接相关</span>
  <span style="color:#66d9ef">local</span> db <span style="color:#f92672">=</span> assert(DB.new(config))
  assert(db:init_connector())
  kong.db <span style="color:#f92672">=</span> db
</code></pre></div><p><code>DB.new()</code> 方法中依次调用了 <code>Schema.new()</code>、<code>Entity.new()</code>、<code>DAO.new()</code> 方法，下面一个个来说明。</p>
<h4 id="311-schema">3.1.1. Schema</h4>
<p>Kong 的 Schema 数据结构体位于 <code>db/schema/entities</code> 下，就 <code>routes.lua</code> 为例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> typedefs <span style="color:#f92672">=</span> require <span style="color:#e6db74">&#34;kong.db.schema.typedefs&#34;</span>


<span style="color:#66d9ef">return</span> {
  name         <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;routes&#34;</span>,
  primary_key  <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#34;id&#34;</span> },
  endpoint_key <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;name&#34;</span>,
  workspaceable <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>,
  subschema_key <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;protocols&#34;</span>,

  fields <span style="color:#f92672">=</span> {
    { id             <span style="color:#f92672">=</span> typedefs.uuid, },
    { created_at     <span style="color:#f92672">=</span> typedefs.auto_timestamp_s },
    { updated_at     <span style="color:#f92672">=</span> typedefs.auto_timestamp_s },
    { name           <span style="color:#f92672">=</span> typedefs.name },
    { protocols      <span style="color:#f92672">=</span> { type     <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;set&#34;</span>,
                         len_min  <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
                         required <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>,
                         elements <span style="color:#f92672">=</span> typedefs.protocol,
                         mutually_exclusive_subsets <span style="color:#f92672">=</span> {
                           { <span style="color:#e6db74">&#34;http&#34;</span>, <span style="color:#e6db74">&#34;https&#34;</span> },
                           { <span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#e6db74">&#34;tls&#34;</span> },
                           { <span style="color:#e6db74">&#34;grpc&#34;</span>, <span style="color:#e6db74">&#34;grpcs&#34;</span> },
                         },
                         default <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#34;http&#34;</span>, <span style="color:#e6db74">&#34;https&#34;</span> }, <span style="color:#75715e">-- TODO: different default depending on service&#39;s scheme</span>
                       }, },
    { methods        <span style="color:#f92672">=</span> typedefs.methods },
    { hosts          <span style="color:#f92672">=</span> typedefs.hosts },
    { paths          <span style="color:#f92672">=</span> typedefs.paths },
    { headers        <span style="color:#f92672">=</span> typedefs.headers },
    { https_redirect_status_code <span style="color:#f92672">=</span> { type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;integer&#34;</span>,
                                     one_of <span style="color:#f92672">=</span> { <span style="color:#ae81ff">426</span>, <span style="color:#ae81ff">301</span>, <span style="color:#ae81ff">302</span>, <span style="color:#ae81ff">307</span>, <span style="color:#ae81ff">308</span> },
                                     default <span style="color:#f92672">=</span> <span style="color:#ae81ff">426</span>, required <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>,
                                   }, },
    { regex_priority <span style="color:#f92672">=</span> { type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;integer&#34;</span>, default <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> }, },
    { strip_path     <span style="color:#f92672">=</span> { type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;boolean&#34;</span>, default <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span> }, },
    { path_handling  <span style="color:#f92672">=</span> { type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;string&#34;</span>, default <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;v0&#34;</span>, one_of <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#34;v0&#34;</span>, <span style="color:#e6db74">&#34;v1&#34;</span> }, }, },
    { preserve_host  <span style="color:#f92672">=</span> { type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;boolean&#34;</span>, default <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span> }, },
    { snis <span style="color:#f92672">=</span> { type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;set&#34;</span>,
               elements <span style="color:#f92672">=</span> typedefs.sni }, },
    { sources <span style="color:#f92672">=</span> typedefs.sources },
    { destinations <span style="color:#f92672">=</span> typedefs.destinations },
    { tags             <span style="color:#f92672">=</span> typedefs.tags },
    { service <span style="color:#f92672">=</span> { type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;foreign&#34;</span>, reference <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;services&#34;</span> }, },
  },

  entity_checks <span style="color:#f92672">=</span> {
    { conditional <span style="color:#f92672">=</span> { if_field <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;protocols&#34;</span>,
                      if_match <span style="color:#f92672">=</span> { elements <span style="color:#f92672">=</span> { type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;string&#34;</span>, not_one_of <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#34;grpcs&#34;</span>, <span style="color:#e6db74">&#34;https&#34;</span>, <span style="color:#e6db74">&#34;tls&#34;</span> }}},
                      then_field <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;snis&#34;</span>,
                      then_match <span style="color:#f92672">=</span> { len_eq <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> },
                      then_err <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#39;snis&#39; can only be set when &#39;protocols&#39; is &#39;grpcs&#39;, &#39;https&#39; or &#39;tls&#39;&#34;</span>,
                    }},
                  }
}

</code></pre></div><p><code>primary_key</code> 是在数据库中主键也是当 <code>cache_key</code> 未定义时的默认 <code>cache_key</code>。</p>
<p>有 <code>type=foreign</code> 的情况，entity 加载时会当作 subschema 加载进来。</p>
<p>插件不同于其他 entity，有特定 cache_key。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;plugins&#34;</span>,
  primary_key <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#34;id&#34;</span> },
  cache_key <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#e6db74">&#34;route&#34;</span>, <span style="color:#e6db74">&#34;service&#34;</span>, <span style="color:#e6db74">&#34;consumer&#34;</span> },
</code></pre></div><p>Cache 相关操作中调用 <code>Entity.cache_key()</code> 获取。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">    <span style="color:#66d9ef">local</span> cache_key <span style="color:#f92672">=</span> dao:cache_key(entity)
    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> cache:safe_set(cache_key, entity)
</code></pre></div><p>具体生成 <code>cache_key</code> 的方法，返回一个字符串作为缓存 key。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">DAO</span>:<span style="color:#a6e22e">cache_key</span>(key, arg2, arg3, arg4, arg5, ws_id)

  <span style="color:#66d9ef">if</span> self.schema.workspaceable <span style="color:#66d9ef">then</span>
    ws_id <span style="color:#f92672">=</span> ws_id <span style="color:#f92672">or</span> workspaces.get_workspace_id()
  <span style="color:#66d9ef">end</span>

  <span style="color:#75715e">-- Fast path: passing the cache_key/primary_key entries in</span>
  <span style="color:#75715e">-- order as arguments, this produces the same result as</span>
  <span style="color:#75715e">-- the generic code below, but building the cache key</span>
  <span style="color:#75715e">-- becomes a single string.format operation</span>
  <span style="color:#66d9ef">if</span> type(key) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;string&#34;</span> <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> fmt(<span style="color:#e6db74">&#34;%s:%s:%s:%s:%s:%s:%s&#34;</span>, self.schema.name,
               key <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">and</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">or</span> key,
               arg2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">and</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">or</span> arg2,
               arg3 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">and</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">or</span> arg3,
               arg4 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">and</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">or</span> arg4,
               arg5 <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">and</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">or</span> arg5,
               ws_id <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">and</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">or</span> ws_id)
  <span style="color:#66d9ef">end</span>

  <span style="color:#75715e">-- Generic path: build the cache key from the fields</span>
  <span style="color:#75715e">-- listed in cache_key or primary_key</span>

  <span style="color:#66d9ef">if</span> type(key) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;table&#34;</span> <span style="color:#66d9ef">then</span>
    error(<span style="color:#e6db74">&#34;key must be a string or an entity table&#34;</span>, <span style="color:#ae81ff">2</span>)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> key.ws_id <span style="color:#66d9ef">then</span>
    ws_id <span style="color:#f92672">=</span> key.ws_id
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> values <span style="color:#f92672">=</span> new_tab(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0</span>)
  values[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> self.schema.name
  <span style="color:#66d9ef">local</span> source <span style="color:#f92672">=</span> self.schema.cache_key <span style="color:#f92672">or</span> self.schema.primary_key

  <span style="color:#66d9ef">local</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
  <span style="color:#66d9ef">for</span> _, name <span style="color:#66d9ef">in</span> ipairs(source) <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">local</span> field <span style="color:#f92672">=</span> self.schema.fields[name]
    <span style="color:#66d9ef">local</span> value <span style="color:#f92672">=</span> key[name]
    <span style="color:#66d9ef">if</span> value <span style="color:#f92672">==</span> null <span style="color:#f92672">or</span> value <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
      value <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
    <span style="color:#66d9ef">elseif</span> field.type <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;foreign&#34;</span> <span style="color:#66d9ef">then</span>
      <span style="color:#75715e">-- FIXME extract foreign key, do not assume `id`</span>
      value <span style="color:#f92672">=</span> value.id
    <span style="color:#66d9ef">end</span>
    values[i] <span style="color:#f92672">=</span> tostring(value)
    i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
  <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">for</span> n <span style="color:#f92672">=</span> i, <span style="color:#ae81ff">6</span> <span style="color:#66d9ef">do</span>
    values[n] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
  <span style="color:#66d9ef">end</span>

  values[<span style="color:#ae81ff">7</span>] <span style="color:#f92672">=</span> ws_id <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;&#34;</span>

  <span style="color:#66d9ef">return</span> concat(values, <span style="color:#e6db74">&#34;:&#34;</span>)
<span style="color:#66d9ef">end</span>
</code></pre></div><p><code>schema/init.lua</code> 中定义了 schema 相关操作的基本方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- each_field() 用于遍历 schema 的 fields</span>
<span style="color:#75715e">-- 是 schema 相关操作最频繁的</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Schema</span>:<span style="color:#a6e22e">each_field</span>(values)
  <span style="color:#66d9ef">local</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

  <span style="color:#66d9ef">local</span> subschema
  <span style="color:#66d9ef">if</span> values <span style="color:#66d9ef">then</span>
    subschema <span style="color:#f92672">=</span> get_subschema(self, values)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span>()
    <span style="color:#66d9ef">local</span> item <span style="color:#f92672">=</span> self.fields[i]
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> item <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
    <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">local</span> key <span style="color:#f92672">=</span> next(item)
    <span style="color:#66d9ef">local</span> field <span style="color:#f92672">=</span> resolve_field(self, key, item[key], subschema)
    i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">return</span> key, field
  <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p><code>Schema.new()</code> 方法中通过元组设置 <code>__index</code> 让结构体继承 Schema 下定义的一系列操作方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Schema</span>.<span style="color:#a6e22e">new</span>(definition, is_subschema)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> definition <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, validation_errors.SCHEMA_NO_DEFINITION
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> definition.fields <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, validation_errors.SCHEMA_NO_FIELDS
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> self <span style="color:#f92672">=</span> copy(definition)

  <span style="color:#75715e">-- 继承 Schema 下定义的一系列操作方法</span>
  setmetatable(self, Schema)

  <span style="color:#75715e">-- entity 缓存的 cache_key，</span>
  <span style="color:#75715e">-- 如果没有这个字段，则默认使用 schema 定义的</span>
  <span style="color:#75715e">-- primary_key 来作为 cache_key</span>
  <span style="color:#75715e">-- cache_key 是个数组，</span>
  <span style="color:#75715e">-- 这里只是分开储存</span>
  <span style="color:#66d9ef">if</span> self.cache_key <span style="color:#66d9ef">then</span>
    self.cache_key_set <span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">for</span> _, name <span style="color:#66d9ef">in</span> ipairs(self.cache_key) <span style="color:#66d9ef">do</span>
      self.cache_key_set[name] <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>


  <span style="color:#75715e">-- 通过元组 __index 方法调用 Schema:each_field() 方法</span>
  <span style="color:#75715e">-- 遍历 schema 的 fields table</span>
  <span style="color:#66d9ef">for</span> key, field <span style="color:#66d9ef">in</span> self:each_field() <span style="color:#66d9ef">do</span>
    <span style="color:#75715e">-- Also give access to fields by name</span>
    self.fields[key] <span style="color:#f92672">=</span> field
    <span style="color:#66d9ef">if</span> field.type <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;record&#34;</span> <span style="color:#f92672">and</span> field.fields <span style="color:#66d9ef">then</span>
      allow_record_fields_by_name(field)
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 如果有外键</span>
    <span style="color:#75715e">-- 则加载外键关联的 schema 进来</span>
    <span style="color:#66d9ef">if</span> field.type <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;foreign&#34;</span> <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">local</span> err
      field.schema, err <span style="color:#f92672">=</span> get_foreign_schema_for_field(field)
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> field.schema <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
      <span style="color:#66d9ef">end</span>

      <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_subschema <span style="color:#66d9ef">then</span>
        <span style="color:#75715e">-- Store the inverse relation for implementing constraints</span>
        <span style="color:#66d9ef">local</span> constraints <span style="color:#f92672">=</span> assert(_cache[field.reference]).constraints
        table.insert(constraints, {
          schema     <span style="color:#f92672">=</span> self,
          field_name <span style="color:#f92672">=</span> key,
          on_delete  <span style="color:#f92672">=</span> field.on_delete,
        })
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> self.workspaceable <span style="color:#f92672">and</span> self.name <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> _workspaceable[self.name] <span style="color:#66d9ef">then</span>
      _workspaceable[self.name] <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
      table.insert(_workspaceable, { schema <span style="color:#f92672">=</span> self })
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> self.name <span style="color:#66d9ef">then</span>
    <span style="color:#75715e">-- do not reset the constraints list if a schema in reloaded</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> _cache[self.name] <span style="color:#66d9ef">then</span>
      _cache[self.name] <span style="color:#f92672">=</span> {
        constraints <span style="color:#f92672">=</span> {},
      }
    <span style="color:#66d9ef">end</span>
    <span style="color:#75715e">-- but always update the schema object in cache</span>
    _cache[self.name].schema <span style="color:#f92672">=</span> self
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> self
<span style="color:#66d9ef">end</span>
</code></pre></div><p>用于下级继承的元组。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> Schema       <span style="color:#f92672">=</span> {}
Schema.__index     <span style="color:#f92672">=</span> Schema
</code></pre></div><h4 id="312-entity">3.1.2. Entity</h4>
<p>Entity 只是简单对 Schema 进行一层封装。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- definition 是 schema 结构体</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Entity</span>.<span style="color:#a6e22e">new</span>(definition)

  <span style="color:#75715e">-- 初始化 Schema 对象</span>
  <span style="color:#66d9ef">local</span> self, err <span style="color:#f92672">=</span> Schema.new(definition)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
  <span style="color:#66d9ef">end</span>

  <span style="color:#75715e">-- 遍历 schema fields</span>
  <span style="color:#66d9ef">for</span> name, field <span style="color:#66d9ef">in</span> self:each_field() <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">if</span> field.nilable <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, entity_errors.NO_NILABLE:format(name)
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> field.abstract <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">goto</span> continue
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> field.type <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;map&#34;</span> <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">if</span> field.keys.type <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;string&#34;</span> <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, entity_errors.MAP_KEY_STRINGS_ONLY:format(name)
      <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">elseif</span> field.type <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;record&#34;</span> <span style="color:#66d9ef">then</span>
      make_records_required(field)

    <span style="color:#66d9ef">elseif</span> field.type <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;function&#34;</span> <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, entity_errors.NO_FUNCTIONS:format(name)
    <span style="color:#66d9ef">end</span>

    ::continue::
  <span style="color:#66d9ef">end</span>

  self.new_subschema <span style="color:#f92672">=</span> Entity.new_subschema

  <span style="color:#66d9ef">return</span> self
<span style="color:#66d9ef">end</span>

</code></pre></div><p>Entity 对象随后被加载到 <code>DB.new()</code> 函数中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> schemas <span style="color:#f92672">=</span> {}

<span style="color:#66d9ef">do</span>
  <span style="color:#75715e">-- load schemas</span>
  <span style="color:#75715e">-- core entities are for now the only source of schemas.</span>
  <span style="color:#75715e">-- TODO: support schemas from plugins entities as well.</span>

  <span style="color:#75715e">-- 载入核心 entity，为什么是核心 entity</span>
  <span style="color:#75715e">-- 因为还有 plugin 自定义的 entity</span>
  <span style="color:#75715e">-- 这些 entity 是 Kong 自身的</span>
  <span style="color:#66d9ef">for</span> _, entity_name <span style="color:#66d9ef">in</span> ipairs(constants.CORE_ENTITIES) <span style="color:#66d9ef">do</span>

    <span style="color:#75715e">-- 加载 schema（数据结构体）</span>
    <span style="color:#66d9ef">local</span> entity_schema <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;kong.db.schema.entities.&#34;</span> <span style="color:#f92672">..</span> entity_name)

    <span style="color:#75715e">-- validate core entities schema via metaschema</span>
    <span style="color:#66d9ef">local</span> ok, err_t <span style="color:#f92672">=</span> MetaSchema:validate(entity_schema)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, fmt(<span style="color:#e6db74">&#34;schema of entity &#39;%s&#39; is invalid: %s&#34;</span>, entity_name,
                      tostring(errors:schema_violation(err_t)))
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 加载 entity 对象</span>
    <span style="color:#66d9ef">local</span> entity, err <span style="color:#f92672">=</span> Entity.new(entity_schema)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> entity <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, fmt(<span style="color:#e6db74">&#34;schema of entity &#39;%s&#39; is invalid: %s&#34;</span>, entity_name,
                      err)
    <span style="color:#66d9ef">end</span>
    schemas[entity_name] <span style="color:#f92672">=</span> entity

    <span style="color:#75715e">-- load core entities subschemas</span>
    <span style="color:#66d9ef">local</span> subschemas
    ok, subschemas <span style="color:#f92672">=</span> utils.load_module_if_exists(<span style="color:#e6db74">&#34;kong.db.schema.entities.&#34;</span> <span style="color:#f92672">..</span> entity_name <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;_subschemas&#34;</span>)
    <span style="color:#66d9ef">if</span> ok <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">for</span> name, subschema <span style="color:#66d9ef">in</span> pairs(subschemas) <span style="color:#66d9ef">do</span>
        <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> entity:new_subschema(name, subschema)
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
          <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, (<span style="color:#e6db74">&#34;error initializing schema for %s: %s&#34;</span>):format(entity_name, err)
        <span style="color:#66d9ef">end</span>
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><h4 id="313-dao">3.1.3. DAO</h4>
<p><code>db/dao/init.lua</code> 中定义了一系列对数据库操作的方法，例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">DAO</span>:<span style="color:#a6e22e">select</span>(primary_key, options)
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">DAO</span>:<span style="color:#a6e22e">page</span>(size, offset, options)
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">DAO</span>:<span style="color:#a6e22e">each</span>(size, options)
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">DAO</span>:<span style="color:#a6e22e">insert</span>(entity, options)
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">DAO</span>:<span style="color:#a6e22e">update</span>(primary_key, entity, options)
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">DAO</span>:<span style="color:#a6e22e">delete</span>(primary_key, options)
...
</code></pre></div><p><code>DAO.new()</code> 会创建一个包含 db 连接信息，entity 的 table。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- schema 参数是 Entity 对象</span>
<span style="color:#75715e">--  DB 结构体：  local self   = {</span>
  <span style="color:#75715e">--    daos       = daos,       -- each of those has the connector singleton</span>
  <span style="color:#75715e">--    strategies = strategies,</span>
  <span style="color:#75715e">--    connector  = connector,</span>
  <span style="color:#75715e">--    strategy   = strategy,</span>
  <span style="color:#75715e">--    errors     = errors,</span>
  <span style="color:#75715e">--    infos      = connector:infos(),</span>
  <span style="color:#75715e">--    kong_config = kong_config,</span>
  <span style="color:#75715e">--  }</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">new</span>(db, schema, strategy, errors)
  <span style="color:#66d9ef">local</span> fk_methods <span style="color:#f92672">=</span> generate_foreign_key_methods(schema)
  <span style="color:#75715e">-- 继承 DAO 基础方法</span>
  <span style="color:#66d9ef">local</span> super      <span style="color:#f92672">=</span> setmetatable(fk_methods, DAO)

  <span style="color:#66d9ef">local</span> self <span style="color:#f92672">=</span> {
    db         <span style="color:#f92672">=</span> db,
    schema     <span style="color:#f92672">=</span> schema,
    strategy   <span style="color:#f92672">=</span> strategy,
    errors     <span style="color:#f92672">=</span> errors,
    pagination <span style="color:#f92672">=</span> utils.shallow_copy(defaults.pagination),
    super      <span style="color:#f92672">=</span> super,
  }

  <span style="color:#66d9ef">if</span> schema.dao <span style="color:#66d9ef">then</span>
    <span style="color:#75715e">-- 插件自定义的 dao</span>
    <span style="color:#66d9ef">local</span> custom_dao <span style="color:#f92672">=</span> require(schema.dao)
    <span style="color:#66d9ef">for</span> name, method <span style="color:#66d9ef">in</span> pairs(custom_dao) <span style="color:#66d9ef">do</span>
      self[name] <span style="color:#f92672">=</span> method
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> setmetatable(self, { __index <span style="color:#f92672">=</span> super })
<span style="color:#66d9ef">end</span>
</code></pre></div><p>在 <code>db\init.lua</code> 中加载所有 DAO 对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#66d9ef">do</span>
    <span style="color:#75715e">-- load DAOs</span>

    <span style="color:#66d9ef">for</span> _, schema <span style="color:#66d9ef">in</span> pairs(schemas) <span style="color:#66d9ef">do</span>
      <span style="color:#66d9ef">local</span> strategy <span style="color:#f92672">=</span> strategies[schema.name]
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> strategy <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, fmt(<span style="color:#e6db74">&#34;no strategy found for schema &#39;%s&#39;&#34;</span>, schema.name)
      <span style="color:#66d9ef">end</span>

      <span style="color:#75715e">-- 储存 daos</span>
      daos[schema.name] <span style="color:#f92672">=</span> DAO.new(self, schema, strategy, errors)
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>
</code></pre></div><p>和上面结构一样，<code>DB.new()</code> 中最后为 table 设置元组 __index 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#75715e">-- 设置元组 __index 方法</span>
  <span style="color:#75715e">-- 访问不存在的对象则先</span>
  <span style="color:#75715e">-- DB.xxx 再访问 DB.daos.xxx</span>
  <span style="color:#66d9ef">return</span> setmetatable(self, DB)
  
  
<span style="color:#66d9ef">local</span> DB <span style="color:#f92672">=</span> {}
DB.__index <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(self, k)
  <span style="color:#75715e">-- rawget 为不调用元组 __index 方法，直接获取原数据</span>
  <span style="color:#66d9ef">return</span> DB[k] <span style="color:#f92672">or</span> rawget(self, <span style="color:#e6db74">&#34;daos&#34;</span>)[k]
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Kong 中其他地方调用数据库方法，操作符为 <code>kong.db.services:each_fields()</code>，即实际调用 <code>daos.services</code>、<code>entity:each_fields()</code>（实际是 <code>Schema:each_fields()</code>）。</p>
<p>DAO 下面还有封装的数据库操作层，例如 PostgreSQL 生成 SQL 语句的方法，这里就不赘述了。</p>
<h3 id="32-缓存构建">3.2. 缓存构建</h3>
<p><code>init_by_lua</code>  阶段初始化 Master 进程，进行解析配置文件、连接数据库、清空共享内存、构建路由缓存等操作。</p>
<p><code>reset_kong_shm</code> 代码块里清理共享内存。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">    <span style="color:#66d9ef">local</span> shms <span style="color:#f92672">=</span> {
      <span style="color:#e6db74">&#34;kong&#34;</span>,
      <span style="color:#e6db74">&#34;kong_locks&#34;</span>,
      <span style="color:#e6db74">&#34;kong_healthchecks&#34;</span>,
      <span style="color:#e6db74">&#34;kong_process_events&#34;</span>,
      <span style="color:#e6db74">&#34;kong_cluster_events&#34;</span>,
      <span style="color:#e6db74">&#34;kong_rate_limiting_counters&#34;</span>,
      <span style="color:#e6db74">&#34;kong_core_db_cache&#34;</span> <span style="color:#f92672">..</span> suffix,
      <span style="color:#e6db74">&#34;kong_core_db_cache_miss&#34;</span> <span style="color:#f92672">..</span> suffix,
      <span style="color:#e6db74">&#34;kong_db_cache&#34;</span> <span style="color:#f92672">..</span> suffix,
      <span style="color:#e6db74">&#34;kong_db_cache_miss&#34;</span> <span style="color:#f92672">..</span> suffix,
      <span style="color:#e6db74">&#34;kong_clustering&#34;</span>,
    }

    <span style="color:#66d9ef">for</span> _, shm <span style="color:#66d9ef">in</span> ipairs(shms) <span style="color:#66d9ef">do</span>
      <span style="color:#66d9ef">local</span> dict <span style="color:#f92672">=</span> ngx.shared[shm]
      <span style="color:#75715e">-- 清空共享内存</span>
      <span style="color:#66d9ef">if</span> dict <span style="color:#66d9ef">then</span>
        dict:flush_all()
        dict:flush_expired(<span style="color:#ae81ff">0</span>)
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
</code></pre></div><h4 id="321-路由缓存">3.2.1. 路由缓存</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#66d9ef">else</span>
    <span style="color:#75715e">-- DB 模式</span>
    <span style="color:#66d9ef">local</span> default_ws <span style="color:#f92672">=</span> db.workspaces:select_by_name(<span style="color:#e6db74">&#34;default&#34;</span>)
    kong.default_workspace <span style="color:#f92672">=</span> default_ws <span style="color:#f92672">and</span> default_ws.id

    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> runloop.build_plugins_iterator(<span style="color:#e6db74">&#34;init&#34;</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      error(<span style="color:#e6db74">&#34;error building initial plugins: &#34;</span> <span style="color:#f92672">..</span> tostring(err))
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 初始化路由</span>
    <span style="color:#75715e">-- 构建路由缓存</span>
    assert(runloop.build_router(<span style="color:#e6db74">&#34;init&#34;</span>))
  <span style="color:#66d9ef">end</span>

  db:close()
<span style="color:#66d9ef">end</span>
</code></pre></div><p>DB 模式下最后一步会调用 <code>runloop.build_router(&quot;init&quot;)</code> 构建路由缓存。</p>
<p>构建路由缓存过程中，判断 Kong 是否已经初始化过 Cache 组件，<code>init</code> 阶段没有完成初始化 Cache，则创建一个 Lua table 缓存路由信息。<code>build_services_init_cache()</code> 方法会分页加载所有 Service 到 table 中，对取出来的 Services，判断当前使用的 Nginx 模式（http/stream）是否对应路由指定的协议，对应则取出 Service 对象，与 Route 进行关联。最后传递给 <code>Router.new()</code> 方法通过算法建立树形结构建立路由索引。</p>
<p>Kong 基于 Nginx Subsystem 支持的协议对应关系：</p>
<ul>
<li>http/https -&gt; http</li>
<li>grpc/grpcs -&gt; http</li>
<li>tcp/tls -&gt; stream</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  build_router <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(version)
    <span style="color:#66d9ef">local</span> db <span style="color:#f92672">=</span> kong.db
    <span style="color:#75715e">-- table 储存所有的 route-service 数据</span>
    <span style="color:#66d9ef">local</span> routes, i <span style="color:#f92672">=</span> {}, <span style="color:#ae81ff">0</span>

    <span style="color:#66d9ef">local</span> err
    <span style="color:#75715e">-- The router is initially created on init phase, where kong.core_cache is</span>
    <span style="color:#75715e">-- still not ready. For those cases, use a plain Lua table as a cache</span>
    <span style="color:#75715e">-- instead</span>
    <span style="color:#75715e">-- init 阶段 core_cache 还没有初始化完成</span>
    <span style="color:#75715e">-- 这里使用 table 储存</span>
    <span style="color:#66d9ef">local</span> services_init_cache <span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> kong.core_cache <span style="color:#f92672">and</span> db.strategy <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;off&#34;</span> <span style="color:#66d9ef">then</span>
      <span style="color:#75715e">-- 获取所有的 services，使用默认的分页参数</span>
      services_init_cache, err <span style="color:#f92672">=</span> build_services_init_cache(db)
      <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
        services_init_cache <span style="color:#f92672">=</span> {}
        log(WARN, <span style="color:#e6db74">&#34;could not build services init cache: &#34;</span>, err)
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">local</span> page_size <span style="color:#f92672">=</span> db.routes.pagination.page_size
    <span style="color:#66d9ef">for</span> route, err <span style="color:#66d9ef">in</span> db.routes:each(<span style="color:#66d9ef">nil</span>, GLOBAL_QUERY_OPTS) <span style="color:#66d9ef">do</span>
      <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;could not load routes: &#34;</span> <span style="color:#f92672">..</span> err
      <span style="color:#66d9ef">end</span>

      <span style="color:#75715e">-- 检查 router 数据是否已经变化</span>
      <span style="color:#75715e">-- 通过检查 router hash 是否一致判断</span>
      <span style="color:#75715e">-- 如果已经变化则退出函数</span>
      <span style="color:#66d9ef">if</span> db.strategy <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;off&#34;</span> <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">if</span> kong.core_cache <span style="color:#f92672">and</span> counter <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> counter <span style="color:#f92672">%</span> page_size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
          <span style="color:#66d9ef">local</span> new_version, err <span style="color:#f92672">=</span> get_router_version()
          <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;failed to retrieve router version: &#34;</span> <span style="color:#f92672">..</span> err
          <span style="color:#66d9ef">end</span>

          <span style="color:#66d9ef">if</span> new_version <span style="color:#f92672">~=</span> version <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;router was changed while rebuilding it&#34;</span>
          <span style="color:#66d9ef">end</span>
        <span style="color:#66d9ef">end</span>
      <span style="color:#66d9ef">end</span>

      <span style="color:#75715e">-- subsystem 是否支持当前路由的协议</span>
      <span style="color:#66d9ef">if</span> should_process_route(route) <span style="color:#66d9ef">then</span>
        <span style="color:#75715e">-- 获取 route 的 service</span>
        <span style="color:#66d9ef">local</span> service, err <span style="color:#f92672">=</span> get_service_for_route(db, route, services_init_cache)
        <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
          <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
        <span style="color:#66d9ef">end</span>

        <span style="color:#66d9ef">local</span> r <span style="color:#f92672">=</span> {
          route   <span style="color:#f92672">=</span> route,
          service <span style="color:#f92672">=</span> service,
        }

        i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        <span style="color:#75715e">-- 储存所有的 route-service</span>
        routes[i] <span style="color:#f92672">=</span> r
      <span style="color:#66d9ef">end</span>

      counter <span style="color:#f92672">=</span> counter <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> new_router, err <span style="color:#f92672">=</span> Router.new(routes)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> new_router <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;could not create router: &#34;</span> <span style="color:#f92672">..</span> err
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- router 实例</span>
    router <span style="color:#f92672">=</span> new_router

    <span style="color:#66d9ef">if</span> version <span style="color:#66d9ef">then</span>
      router_version <span style="color:#f92672">=</span> version
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- LEGACY - singletons module is deprecated</span>
    singletons.router <span style="color:#f92672">=</span> router
    <span style="color:#75715e">-- /LEGACY</span>

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">end</span>
</code></pre></div><p>构建路由缓存过程中，判断 Kong 是否已经初始化过 Cache 组件，<code>init</code> 阶段没有完成初始化 Cache，则创建一个 Lua table 缓存 services。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#75715e">-- 以 [service.id] = service</span>
  <span style="color:#75715e">-- 结构储存到 table 中</span>
  <span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">build_services_init_cache</span>(db)
    <span style="color:#66d9ef">local</span> services_init_cache <span style="color:#f92672">=</span> {}

    <span style="color:#66d9ef">for</span> service, err <span style="color:#66d9ef">in</span> db.services:each(<span style="color:#66d9ef">nil</span>, GLOBAL_QUERY_OPTS) <span style="color:#66d9ef">do</span>
      <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
      <span style="color:#66d9ef">end</span>

      services_init_cache[service.id] <span style="color:#f92672">=</span> service
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> services_init_cache
  <span style="color:#66d9ef">end</span>
</code></pre></div><p><code>build_services_init_cache(db)</code> 方法，调用 <code>DAO:each()</code> 函数，使用默认分页参数 <code>page_size=1000</code>，进行分页获取，再返回可迭代的单条记录。这里因为 <code>init_by_lua</code> 阶段没有初始化缓存（<code>kong.core_cache</code> ），所以使用 Lua table 储存缓存数据。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">DAO</span>:<span style="color:#a6e22e">each</span>(size, options)
  <span style="color:#66d9ef">if</span> size <span style="color:#f92672">~=</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
    validate_size_type(size)
  <span style="color:#66d9ef">end</span>

  <span style="color:#75715e">-- 获取分页条件，有默认值</span>
  options <span style="color:#f92672">=</span> get_pagination_options(self, options)

  <span style="color:#66d9ef">if</span> size <span style="color:#f92672">~=</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> validate_size_value(size, options.pagination.max_page_size)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">local</span> err_t <span style="color:#f92672">=</span> self.errors:invalid_size(err)
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, tostring(err_t), err_t
    <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">else</span>
    size <span style="color:#f92672">=</span> options.pagination.page_size
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> ok, errors <span style="color:#f92672">=</span> validate_options_value(self, options)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">local</span> err_t <span style="color:#f92672">=</span> self.errors:invalid_options(errors)
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, tostring(err_t), err_t
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> pager <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(size, offset, options)
    <span style="color:#66d9ef">return</span> self.strategy:page(size, offset, options)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> iteration.by_row(self, pager, size, options)
<span style="color:#66d9ef">end</span>
</code></pre></div><p>默认分页参数在 <code>db/strategies/connector.lua</code> 文件中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> Connector <span style="color:#f92672">=</span> {
  defaults <span style="color:#f92672">=</span> {
    <span style="color:#75715e">-- 默认分页条件</span>
    pagination <span style="color:#f92672">=</span> {
      page_size     <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>,
      max_page_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">50000</span>,
    },
  },
}
</code></pre></div><p>接下来会遍历所有的 Routes，逐个调用 <code>should_process_route()</code> 和 <code>get_service_for_route()</code> 方法，前者会判断 Nginx Subsystem 是否和 Route 协议一致，后者先在缓存中查找 Service，如果缓存中不存在则从数据库中获取。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">get_service_for_route</span>(db, route, services_init_cache)
    <span style="color:#75715e">-- route 关联的 service 外键</span>
    <span style="color:#66d9ef">local</span> service_pk <span style="color:#f92672">=</span> route.service
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> service_pk <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 查找缓存 table 里的 service</span>
    <span style="color:#66d9ef">local</span> id <span style="color:#f92672">=</span> service_pk.id
    <span style="color:#66d9ef">local</span> service <span style="color:#f92672">=</span> services_init_cache[id]
    <span style="color:#66d9ef">if</span> service <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> service
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> err

    <span style="color:#75715e">-- kong.core_cache is available, not in init phase</span>
    <span style="color:#66d9ef">if</span> kong.core_cache <span style="color:#66d9ef">then</span>
      <span style="color:#75715e">-- 通过 mlcache 查询 service</span>
      <span style="color:#66d9ef">local</span> cache_key <span style="color:#f92672">=</span> db.services:cache_key(service_pk.id, <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>,
                                              route.ws_id)
      <span style="color:#75715e">-- 查询 cache 获取，没有获取到则调用 load_service_from_db 获取</span>
      service, err <span style="color:#f92672">=</span> kong.core_cache:get(cache_key, TTL_ZERO,
                                    load_service_from_db, service_pk)

    <span style="color:#66d9ef">else</span> <span style="color:#75715e">-- init phase, kong.core_cache not available</span>

      <span style="color:#75715e">-- A new service/route has been inserted while the initial route</span>
      <span style="color:#75715e">-- was being created, on init (perhaps by a different Kong node).</span>
      <span style="color:#75715e">-- Load the service individually and update services_init_cache with it</span>
      <span style="color:#75715e">-- 直接查询数据库获取 service</span>
      service, err <span style="color:#f92672">=</span> load_service_from_db(service_pk)
      services_init_cache[id] <span style="color:#f92672">=</span> service
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;error raised while finding service for route (&#34;</span> <span style="color:#f92672">..</span> route.id <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;): &#34;</span> <span style="color:#f92672">..</span>
                  err

    <span style="color:#66d9ef">elseif</span> <span style="color:#f92672">not</span> service <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;could not find service for route (&#34;</span> <span style="color:#f92672">..</span> route.id <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;)&#34;</span>
    <span style="color:#66d9ef">end</span>


    <span style="color:#75715e">-- TODO: this should not be needed as the schema should check it already</span>
    <span style="color:#66d9ef">if</span> SUBSYSTEMS[service.protocol] <span style="color:#f92672">~=</span> subsystem <span style="color:#66d9ef">then</span>
      log(WARN, <span style="color:#e6db74">&#34;service with protocol &#39;&#34;</span>, service.protocol,
                <span style="color:#e6db74">&#34;&#39; cannot be used with &#39;&#34;</span>, subsystem, <span style="color:#e6db74">&#34;&#39; subsystem&#34;</span>)

      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> service
  <span style="color:#66d9ef">end</span>

</code></pre></div><p><code>load_service_from_db()</code> 方法中只是简单调用 <code>DAO:select()</code> 方法，取出 Service 同时缓存到 <code>services_init_cache</code> table 中，不更新 <code>Kong.core_cache</code> 组件。</p>
<p>对数据库实体对象的处理中，只有<code>create</code> 、<code>update</code>、<code>delete</code> 会通过事件广播到其他 Worker 同步，后面事件的一节我们会详细阐述。</p>
<p>接下来将 <code>{router, service}</code> 数组传入 <code>router.iua</code> 中 <code>Router.new()</code> 函数处理。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> new_router, err <span style="color:#f92672">=</span> Router.new(routes)
<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> new_router <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;could not create router: &#34;</span> <span style="color:#f92672">..</span> err
<span style="color:#66d9ef">end</span>

<span style="color:#75715e">-- 绑定 router 实例</span>
router <span style="color:#f92672">=</span> new_router
</code></pre></div><p>具体构建路由索引的过程在 <code>router.lua</code> 中的 <code>_M.new(routes)</code> 函数，使用 <strong><a href="https://github.com/openresty/lua-resty-lrucache">lua-resty-lrucache</a></strong> 包缓存，对路由和 Service 组合通过算法进行排序，构建索引，将诸如 <code>{cache_key: {route, service}}</code> 结构存入缓存中，返回 Router 实例。</p>
<p>路由索引 Key 的构建方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">    <span style="color:#66d9ef">local</span> cache_key <span style="color:#f92672">=</span> req_method <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> req_uri <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> req_host <span style="color:#f92672">..</span>
                      <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> ctx.src_ip <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> ctx.src_port <span style="color:#f92672">..</span>
                      <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> ctx.dst_ip <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> ctx.dst_port <span style="color:#f92672">..</span>
                      <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> ctx.sni
</code></pre></div><p>Router 实例由 Master 进程构建，并 fork 到各个 Worker 进程使用。</p>
<p>Worker 执行完共享内存的构建后，注册定时任务，定时重建缓存。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">      <span style="color:#75715e">-- 定时重建路由缓存</span>
      <span style="color:#66d9ef">if</span> kong.db.strategy <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;off&#34;</span> <span style="color:#66d9ef">then</span>
        timer_every(worker_state_update_frequency, <span style="color:#66d9ef">function</span>(premature)
          <span style="color:#66d9ef">if</span> premature <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span>
          <span style="color:#66d9ef">end</span>

          <span style="color:#75715e">-- Don&#39;t wait for the semaphore (timeout = 0) when updating via the</span>
          <span style="color:#75715e">-- timer.</span>
          <span style="color:#75715e">-- If the semaphore is locked, that means that the rebuild is</span>
          <span style="color:#75715e">-- already ongoing.</span>
          <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> rebuild_router(ROUTER_ASYNC_OPTS)
          <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
            log(ERR, <span style="color:#e6db74">&#34;could not rebuild router via timer: &#34;</span>, err)
          <span style="color:#66d9ef">end</span>
        <span style="color:#66d9ef">end</span>)

        timer_every(worker_state_update_frequency, <span style="color:#66d9ef">function</span>(premature)
          <span style="color:#66d9ef">if</span> premature <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span>
          <span style="color:#66d9ef">end</span>

          <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> rebuild_plugins_iterator(PLUGINS_ITERATOR_ASYNC_OPTS)
          <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
            log(ERR, <span style="color:#e6db74">&#34;could not rebuild plugins iterator via timer: &#34;</span>, err)
          <span style="color:#66d9ef">end</span>
        <span style="color:#66d9ef">end</span>)
      <span style="color:#66d9ef">end</span>
</code></pre></div><h4 id="322-entity-缓存">3.2.2. Entity 缓存</h4>
<p>这里首先介绍一下 <strong><a href="https://github.com/thibaultcha/lua-resty-mlcache">lua-resty-mlcache</a></strong> 这个缓存库，该库基于 <a href="https://github.com/openresty/lua-nginx-module#lua_shared_dict">lua_shared_dict</a> 和 <a href="https://github.com/openresty/lua-resty-lrucache">lua-resty-lrucache</a> 做了两层缓存，Worker 会有自己的进程级别的 LRU 缓存，首先会在这一层进行查询，其次使用共享内存进行缓存，最后提供 callback 从数据库查询，使用 <a href="https://github.com/openresty/lua-resty-lock">lua-resty-lock</a> 库创建锁只允许单个进程执行 callback。</p>
<p>mlcache 架构图：</p>
<pre><code>┌─────────────────────────────────────────────────┐
│ Nginx                                           │
│       ┌───────────┐ ┌───────────┐ ┌───────────┐ │
│       │worker     │ │worker     │ │worker     │ │
│ L1    │           │ │           │ │           │ │
│       │ Lua cache │ │ Lua cache │ │ Lua cache │ │
│       └───────────┘ └───────────┘ └───────────┘ │
│             │             │             │       │
│             ▼             ▼             ▼       │
│       ┌───────────────────────────────────────┐ │
│       │                                       │ │
│ L2    │           lua_shared_dict             │ │
│       │                                       │ │
│       └───────────────────────────────────────┘ │
│                           │ mutex               │
│                           ▼                     │
│                  ┌──────────────────┐           │
│                  │     callback     │           │
│                  └────────┬─────────┘           │
└───────────────────────────┼─────────────────────┘
                            │
  L3                        │   I/O fetch
                            ▼

                   Database, API, DNS, Disk, any I/O...
</code></pre><p><code>Kong.init_worker()</code> 中进行初始化缓存：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#75715e">-- 初始化基于共享内存的 cache</span>
  <span style="color:#66d9ef">local</span> cache, err <span style="color:#f92672">=</span> kong_global.init_cache(kong.configuration, cluster_events, worker_events)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> cache <span style="color:#66d9ef">then</span>
    stash_init_worker_error(<span style="color:#e6db74">&#34;failed to instantiate &#39;kong.cache&#39; module: &#34;</span> <span style="color:#f92672">..</span>
                            err)
    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>
  kong.cache <span style="color:#f92672">=</span> cache

  <span style="color:#66d9ef">local</span> core_cache, err <span style="color:#f92672">=</span> kong_global.init_core_cache(kong.configuration, cluster_events, worker_events)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> core_cache <span style="color:#66d9ef">then</span>
    stash_init_worker_error(<span style="color:#e6db74">&#34;failed to instantiate &#39;kong.core_cache&#39; module: &#34;</span> <span style="color:#f92672">..</span>
                            err)
    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>
  kong.core_cache <span style="color:#f92672">=</span> core_cache

  ok, err <span style="color:#f92672">=</span> runloop.set_init_versions_in_cache()
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
    stash_init_worker_error(err) <span style="color:#75715e">-- &#39;err&#39; fully formatted</span>
    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>
</code></pre></div><p><code>global.init_cache()</code> 结构如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_GLOBAL</span>.<span style="color:#a6e22e">init_cache</span>(kong_config, cluster_events, worker_events)
  <span style="color:#66d9ef">local</span> db_cache_ttl <span style="color:#f92672">=</span> kong_config.db_cache_ttl
  <span style="color:#66d9ef">local</span> db_cache_neg_ttl <span style="color:#f92672">=</span> kong_config.db_cache_neg_ttl
  <span style="color:#66d9ef">local</span> cache_pages <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
  <span style="color:#66d9ef">if</span> kong_config.database <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;off&#34;</span> <span style="color:#66d9ef">then</span>
    db_cache_ttl <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    db_cache_neg_ttl <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    cache_pages <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> kong_cache.new {
    shm_name          <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;kong_db_cache&#34;</span>,
    cluster_events    <span style="color:#f92672">=</span> cluster_events,
    worker_events     <span style="color:#f92672">=</span> worker_events,
    ttl               <span style="color:#f92672">=</span> db_cache_ttl,
    neg_ttl           <span style="color:#f92672">=</span> db_cache_neg_ttl <span style="color:#f92672">or</span> db_cache_ttl,
    resurrect_ttl     <span style="color:#f92672">=</span> kong_config.resurrect_ttl,
    cache_pages       <span style="color:#f92672">=</span> cache_pages,
    resty_lock_opts   <span style="color:#f92672">=</span> {
      exptime <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>,
      timeout <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>,
    },
  }
<span style="color:#66d9ef">end</span>
</code></pre></div><p>最终会调用 <code>cache.lua</code> 中 <code>_M.new()</code> 进行必要参数的验证，检测共享内存块是否可以访问，关联集群事件和 Worker 事件，定义序列化和反序列化的方法，对 mlcache 进行一层封装。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>.<span style="color:#a6e22e">new</span>(opts)
  <span style="color:#75715e">-- opts validation</span>

  opts <span style="color:#f92672">=</span> opts <span style="color:#f92672">or</span> {}

  <span style="color:#66d9ef">local</span> mlcaches <span style="color:#f92672">=</span> {}
  <span style="color:#66d9ef">local</span> shm_names <span style="color:#f92672">=</span> {}

  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, opts.cache_pages <span style="color:#f92672">or</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">local</span> channel_name  <span style="color:#f92672">=</span> (i <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">and</span> <span style="color:#e6db74">&#34;mlcache&#34;</span>                 <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;mlcache_2&#34;</span>
    <span style="color:#66d9ef">local</span> shm_name      <span style="color:#f92672">=</span> (i <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">and</span> opts.shm_name             <span style="color:#f92672">or</span> opts.shm_name <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;_2&#34;</span>
    <span style="color:#66d9ef">local</span> shm_miss_name <span style="color:#f92672">=</span> (i <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">and</span> opts.shm_name <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;_miss&#34;</span>  <span style="color:#f92672">or</span> opts.shm_name <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;_miss_2&#34;</span>

    <span style="color:#66d9ef">if</span> ngx.shared[shm_name] <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">local</span> mlcache, err <span style="color:#f92672">=</span> resty_mlcache.new(shm_name, shm_name, {
        shm_miss         <span style="color:#f92672">=</span> shm_miss_name,
        shm_locks        <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;kong_locks&#34;</span>,
        shm_set_retries  <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>,
        lru_size         <span style="color:#f92672">=</span> LRU_SIZE,
        ttl              <span style="color:#f92672">=</span> max(opts.ttl     <span style="color:#f92672">or</span> <span style="color:#ae81ff">3600</span>, <span style="color:#ae81ff">0</span>),
        neg_ttl          <span style="color:#f92672">=</span> max(opts.neg_ttl <span style="color:#f92672">or</span> <span style="color:#ae81ff">300</span>,  <span style="color:#ae81ff">0</span>),
        resurrect_ttl    <span style="color:#f92672">=</span> opts.resurrect_ttl <span style="color:#f92672">or</span> <span style="color:#ae81ff">30</span>,
        resty_lock_opts  <span style="color:#f92672">=</span> opts.resty_lock_opts,
        ipc <span style="color:#f92672">=</span> { <span style="color:#75715e">-- 进程间通信的函数绑定</span>
          register_listeners <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(events)
            <span style="color:#66d9ef">for</span> _, event_t <span style="color:#66d9ef">in</span> pairs(events) <span style="color:#66d9ef">do</span>
              opts.worker_events.register(<span style="color:#66d9ef">function</span>(data)
                event_t.handler(data)
              <span style="color:#66d9ef">end</span>, channel_name, event_t.channel)
            <span style="color:#66d9ef">end</span>
          <span style="color:#66d9ef">end</span>,
          broadcast <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(channel, data)
            <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> opts.worker_events.post(channel_name, channel, data)
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
              log(ERR, <span style="color:#e6db74">&#34;failed to post event &#39;&#34;</span>, channel_name, <span style="color:#e6db74">&#34;&#39;, &#39;&#34;</span>,
                       channel, <span style="color:#e6db74">&#34;&#39;: &#34;</span>, err)
            <span style="color:#66d9ef">end</span>
          <span style="color:#66d9ef">end</span>
        }
      })
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> mlcache <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;failed to instantiate mlcache: &#34;</span> <span style="color:#f92672">..</span> err
      <span style="color:#66d9ef">end</span>
      mlcaches[i] <span style="color:#f92672">=</span> mlcache
      shm_names[i] <span style="color:#f92672">=</span> shm_name
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> curr_mlcache <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

  <span style="color:#66d9ef">if</span> opts.cache_pages <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">then</span>
    curr_mlcache <span style="color:#f92672">=</span> ngx.shared.kong:get(<span style="color:#e6db74">&#34;kong:cache:&#34;</span> <span style="color:#f92672">..</span> opts.shm_name <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;:curr_mlcache&#34;</span>) <span style="color:#f92672">or</span> <span style="color:#ae81ff">1</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> self          <span style="color:#f92672">=</span> {
    cluster_events    <span style="color:#f92672">=</span> opts.cluster_events,
    mlcache           <span style="color:#f92672">=</span> mlcaches[curr_mlcache],
    mlcaches          <span style="color:#f92672">=</span> mlcaches,
    shm_names         <span style="color:#f92672">=</span> shm_names,
    curr_mlcache      <span style="color:#f92672">=</span> curr_mlcache,
  }

  <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> self.cluster_events:subscribe(<span style="color:#e6db74">&#34;invalidations&#34;</span>, <span style="color:#66d9ef">function</span>(key)
    log(DEBUG, <span style="color:#e6db74">&#34;received invalidate event from cluster for key: &#39;&#34;</span>, key, <span style="color:#e6db74">&#34;&#39;&#34;</span>)
    self:invalidate_local(key)
  <span style="color:#66d9ef">end</span>)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;failed to subscribe to invalidations cluster events &#34;</span> <span style="color:#f92672">..</span>
                <span style="color:#e6db74">&#34;channel: &#34;</span> <span style="color:#f92672">..</span> err
  <span style="color:#66d9ef">end</span>

  _init[opts.shm_name] <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>

  <span style="color:#66d9ef">return</span> setmetatable(self, mt)
<span style="color:#66d9ef">end</span>
</code></pre></div><p>初始化完缓存模块后，Worker 会根据配置文件中的 <code>db_cache_warmup_entities</code> 加载指定的数据库资源到内存进行缓存，默认配置会缓存 <code>services, plugins</code>。</p>
<p><code>LRU_SIZE</code> 值为 500,000，单位是 item，设置最大能储存的 item 数量，这个值表示单个 Worker LRU Cache 最大占用 500M 内存。</p>
<p>Worker 会根据配置项加载数据库实体到共享内存缓存。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">execute_cache_warmup</span>(kong_config)
  <span style="color:#66d9ef">if</span> kong_config.database <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;off&#34;</span> <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#75715e">-- 只在一个 worker 上执行操作</span>
  <span style="color:#75715e">-- 加载数据库实体到共享内存缓存</span>
  <span style="color:#66d9ef">if</span> ngx.worker.id() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> cache_warmup.execute(kong_config.db_cache_warmup_entities)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>这里只在一个 Worker 进程上加载数据库数据，随后同步到其他的 Worker 上。</p>
<p><code>cache_warmup.execute()</code> 里做基本信息的检测，随后调用 <code>cache_warmup_single_entity(dao)</code> 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- 加载数据库实体到缓存，以实现更快的访问速度</span>
<span style="color:#75715e">-- 在 Worker 初始化阶段运行</span>
<span style="color:#75715e">-- 默认加载 service, plugins</span>
<span style="color:#75715e">-- 大小受配置 mem_cache_size 影响</span>
<span style="color:#75715e">-- Loads entities from the database into the cache, for rapid subsequent</span>
<span style="color:#75715e">-- access. This function is intented to be used during worker initialization.</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">cache_warmup</span>.<span style="color:#a6e22e">execute</span>(entities)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> kong.cache <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> kong.core_cache <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">for</span> _, entity_name <span style="color:#66d9ef">in</span> ipairs(entities) <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">if</span> entity_name <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;routes&#34;</span> <span style="color:#66d9ef">then</span>
      <span style="color:#75715e">-- do not spend shm memory by caching individual Routes entries</span>
      <span style="color:#75715e">-- because the routes are kept in-memory by building the router object</span>
      kong.log.notice(<span style="color:#e6db74">&#34;the &#39;routes&#39; entry is ignored in the list of &#34;</span>,
                      <span style="color:#e6db74">&#34;&#39;db_cache_warmup_entities&#39; because Kong &#34;</span>,
                      <span style="color:#e6db74">&#34;caches routes in memory separately&#34;</span>)
      <span style="color:#66d9ef">goto</span> continue
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> dao <span style="color:#f92672">=</span> kong.db[entity_name]
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> (type(dao) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;table&#34;</span> <span style="color:#f92672">and</span> dao.schema) <span style="color:#66d9ef">then</span>
      kong.log.warn(entity_name, <span style="color:#e6db74">&#34; is not a valid entity name, please check &#34;</span>,
                    <span style="color:#e6db74">&#34;the value of &#39;db_cache_warmup_entities&#39;&#34;</span>)
      <span style="color:#66d9ef">goto</span> continue
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> cache_warmup_single_entity(dao)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">if</span> err <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;no memory&#34;</span> <span style="color:#66d9ef">then</span>
        kong.log.warn(<span style="color:#e6db74">&#34;cache warmup has been stopped because cache &#34;</span>,
                      <span style="color:#e6db74">&#34;memory is exhausted, please consider increasing &#34;</span>,
                      <span style="color:#e6db74">&#34;the value of &#39;mem_cache_size&#39; (currently at &#34;</span>,
                      kong.configuration.mem_cache_size, <span style="color:#e6db74">&#34;)&#34;</span>)

        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
      <span style="color:#66d9ef">end</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
    <span style="color:#66d9ef">end</span>

    ::continue::
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>不缓存 Routes，因为 Route 已经在上一节中构建为路由索引树，通过 fork 到所有的 Worker 内存里了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">cache_warmup_single_entity</span>(dao)
  <span style="color:#66d9ef">local</span> entity_name <span style="color:#f92672">=</span> dao.schema.name

  <span style="color:#75715e">-- 选定储存地方 cache/core_cache</span>
  <span style="color:#66d9ef">local</span> cache_store <span style="color:#f92672">=</span> constants.ENTITY_CACHE_STORE[entity_name]
  <span style="color:#75715e">-- cache 全局对象</span>
  <span style="color:#66d9ef">local</span> cache <span style="color:#f92672">=</span> kong[cache_store]

  ngx.log(ngx.NOTICE, <span style="color:#e6db74">&#34;Preloading &#39;&#34;</span>, entity_name, <span style="color:#e6db74">&#34;&#39; into the &#34;</span>, cache_store, <span style="color:#e6db74">&#34;...&#34;</span>)

  <span style="color:#66d9ef">local</span> start <span style="color:#f92672">=</span> ngx.now()

  <span style="color:#66d9ef">local</span> hosts_array, hosts_set, host_count
  <span style="color:#66d9ef">if</span> entity_name <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;services&#34;</span> <span style="color:#66d9ef">then</span>
    hosts_array <span style="color:#f92672">=</span> {}
    hosts_set <span style="color:#f92672">=</span> {}
    host_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">for</span> entity, err <span style="color:#66d9ef">in</span> dao:each(<span style="color:#66d9ef">nil</span>, GLOBAL_QUERY_OPTS) <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> entity_name <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;services&#34;</span> <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">if</span> utils.hostname_type(entity.host) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;name&#34;</span>
         <span style="color:#f92672">and</span> hosts_set[entity.host] <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
        host_count <span style="color:#f92672">=</span> host_count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        hosts_array[host_count] <span style="color:#f92672">=</span> entity.host
        hosts_set[entity.host] <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 获取 cache_key</span>
    <span style="color:#66d9ef">local</span> cache_key <span style="color:#f92672">=</span> dao:cache_key(entity)

    <span style="color:#75715e">-- 调用 mlcache 的 safe_set 方法，</span>
    <span style="color:#75715e">-- 内存不足会报错</span>
    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> cache:safe_set(cache_key, entity)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> entity_name <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;services&#34;</span> <span style="color:#f92672">and</span> host_count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
    ngx.timer.at(<span style="color:#ae81ff">0</span>, warmup_dns, hosts_array, host_count)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> elapsed <span style="color:#f92672">=</span> math.floor((ngx.now() <span style="color:#f92672">-</span> start) <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000</span>)

  ngx.log(ngx.NOTICE, <span style="color:#e6db74">&#34;finished preloading &#39;&#34;</span>, entity_name,
                      <span style="color:#e6db74">&#34;&#39; into the &#34;</span>, cache_store, <span style="color:#e6db74">&#34; (in &#34;</span>, tostring(elapsed), <span style="color:#e6db74">&#34;ms)&#34;</span>)
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p><code>cache_warmup_single_entity()</code> 会加载该 dao 所有的数据到内存中，<code>set</code> 方法会分发事件同步数据到其他的 Worker 上，最终每个 Worker 都会缓存一份。</p>
<h3 id="33-事件订阅">3.3. 事件订阅</h3>
<p><code>Kong.init_worker()</code> 中初始化 Worker 事件和集群事件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#66d9ef">local</span> worker_events, err <span style="color:#f92672">=</span> kong_global.init_worker_events()
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> worker_events <span style="color:#66d9ef">then</span>
    stash_init_worker_error(<span style="color:#e6db74">&#34;failed to instantiate &#39;kong.worker_events&#39; &#34;</span> <span style="color:#f92672">..</span>
                            <span style="color:#e6db74">&#34;module: &#34;</span> <span style="color:#f92672">..</span> err)
    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>
  kong.worker_events <span style="color:#f92672">=</span> worker_events

  <span style="color:#66d9ef">local</span> cluster_events, err <span style="color:#f92672">=</span> kong_global.init_cluster_events(kong.configuration, kong.db)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> cluster_events <span style="color:#66d9ef">then</span>
    stash_init_worker_error(<span style="color:#e6db74">&#34;failed to instantiate &#39;kong.cluster_events&#39; &#34;</span> <span style="color:#f92672">..</span>
                            <span style="color:#e6db74">&#34;module: &#34;</span> <span style="color:#f92672">..</span> err)
    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>
  kong.cluster_events <span style="color:#f92672">=</span> cluster_events
</code></pre></div><p>Worker 事件内部是使用 <strong><a href="https://github.com/Kong/lua-resty-worker-events">lua-resty-worker-events</a></strong> 库实现的进程间事件处理，原理是通过共享内存储存事件，每秒拉取共享内存中的事件，进行处理。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_GLOBAL</span>.<span style="color:#a6e22e">init_worker_events</span>()
  <span style="color:#75715e">-- Note: worker_events will not work correctly if required at the top of the file.</span>
  <span style="color:#75715e">--       It must be required right here, inside the init function</span>
  <span style="color:#66d9ef">local</span> worker_events <span style="color:#f92672">=</span> require <span style="color:#e6db74">&#34;resty.worker.events&#34;</span>

  <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> worker_events.configure {
    shm <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;kong_process_events&#34;</span>, <span style="color:#75715e">-- defined by &#34;lua_shared_dict&#34;</span>
    timeout <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>,            <span style="color:#75715e">-- life time of event data in shm</span>
    interval <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,           <span style="color:#75715e">-- poll interval (seconds)</span>

    wait_interval <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.010</span>,  <span style="color:#75715e">-- wait before retry fetching event data</span>
    wait_max <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span>,         <span style="color:#75715e">-- max wait time before discarding event</span>
  }
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> worker_events
<span style="color:#66d9ef">end</span>
</code></pre></div><p>集群事件（多个 Kong 之间的通信）是通过将事件储存在数据库中，定时轮询数据库查询事件，进行处理。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_GLOBAL</span>.<span style="color:#a6e22e">init_cluster_events</span>(kong_config, db)
  <span style="color:#66d9ef">return</span> kong_cluster_events.new({
    db            <span style="color:#f92672">=</span> db,
    poll_interval <span style="color:#f92672">=</span> kong_config.db_update_frequency,
    poll_offset   <span style="color:#f92672">=</span> kong_config.db_update_propagation,
    poll_delay    <span style="color:#f92672">=</span> kong_config.db_update_propagation,
  })
<span style="color:#66d9ef">end</span>
</code></pre></div><p>从这里可以看到集群事件是通过数据库表实现的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>:<span style="color:#a6e22e">broadcast</span>(channel, data, delay)
  <span style="color:#66d9ef">if</span> type(channel) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;string&#34;</span> <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;channel must be a string&#34;</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> type(data) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;string&#34;</span> <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;data must be a string&#34;</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> delay <span style="color:#f92672">and</span> type(delay) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;number&#34;</span> <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;delay must be a number&#34;</span>

  <span style="color:#66d9ef">elseif</span> self.poll_delay <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
    delay <span style="color:#f92672">=</span> self.poll_delay
  <span style="color:#66d9ef">end</span>

  <span style="color:#75715e">-- insert event row</span>

  <span style="color:#75715e">--log(DEBUG, &#34;broadcasting on channel: &#39;&#34;, channel, &#34;&#39; data: &#34;, data,</span>
  <span style="color:#75715e">--           &#34; with delay: &#34;, delay and delay or &#34;none&#34;)</span>

  <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> self.strategy:insert(self.node_id, channel, <span style="color:#66d9ef">nil</span>, data, delay)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">end</span>


<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>:<span style="color:#a6e22e">subscribe</span>(channel, cb, start_polling)
  <span style="color:#66d9ef">if</span> type(channel) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;string&#34;</span> <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> error(<span style="color:#e6db74">&#34;channel must be a string&#34;</span>)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> type(cb) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;function&#34;</span> <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> error(<span style="color:#e6db74">&#34;callback must be a function&#34;</span>)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self.callbacks[channel] <span style="color:#66d9ef">then</span>
    self.callbacks[channel] <span style="color:#f92672">=</span> { cb }

    insert(self.channels, channel)

  <span style="color:#66d9ef">else</span>
    insert(self.callbacks[channel], cb)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> start_polling <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
    start_polling <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self.polling <span style="color:#f92672">and</span> start_polling <span style="color:#f92672">and</span> self.use_polling <span style="color:#66d9ef">then</span>
    <span style="color:#75715e">-- start recurring polling timer</span>

    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> timer_at(self.poll_interval, poll_handler, self)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;failed to start polling timer: &#34;</span> <span style="color:#f92672">..</span> err
    <span style="color:#66d9ef">end</span>

    self.polling <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>在 <code>cache.lua</code> 中集群事件订阅 cache 失效事件，内部调用 mlcache 的 delete 方法，同步到所有的 Worker 上。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> self.cluster_events:subscribe(<span style="color:#e6db74">&#34;invalidations&#34;</span>, <span style="color:#66d9ef">function</span>(key)
    log(DEBUG, <span style="color:#e6db74">&#34;received invalidate event from cluster for key: &#39;&#34;</span>, key, <span style="color:#e6db74">&#34;&#39;&#34;</span>)
    self:invalidate_local(key)
  <span style="color:#66d9ef">end</span>)


<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>:<span style="color:#a6e22e">invalidate_local</span>(key, shadow)
  <span style="color:#66d9ef">if</span> type(key) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;string&#34;</span> <span style="color:#66d9ef">then</span>
    error(<span style="color:#e6db74">&#34;key must be a string&#34;</span>, <span style="color:#ae81ff">2</span>)
  <span style="color:#66d9ef">end</span>

  log(DEBUG, <span style="color:#e6db74">&#34;invalidating (local): &#39;&#34;</span>, key, <span style="color:#e6db74">&#34;&#39;&#34;</span>)

  <span style="color:#66d9ef">local</span> current_page <span style="color:#f92672">=</span> self.curr_mlcache <span style="color:#f92672">or</span> <span style="color:#ae81ff">1</span>
  <span style="color:#66d9ef">local</span> delete_page
  <span style="color:#66d9ef">if</span> shadow <span style="color:#f92672">and</span> <span style="color:#f92672">#</span>self.mlcaches <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">then</span>
    delete_page <span style="color:#f92672">=</span> current_page <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">or</span> <span style="color:#ae81ff">1</span>
  <span style="color:#66d9ef">else</span>
    delete_page <span style="color:#f92672">=</span> current_page
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> self.mlcaches[delete_page]:delete(key)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
    log(ERR, <span style="color:#e6db74">&#34;failed to delete entity from node cache: &#34;</span>, err)
  <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>这部分主要描述 Kong 初始化过程中的事件相关操作，主要是初始化事件订阅，关联到 mlcache 的 IPC 进程间通信，订阅 cache 的失效事件，并关联 DAO 的事件发布。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">DB</span>:<span style="color:#a6e22e">set_events_handler</span>(events)
  <span style="color:#66d9ef">for</span> _, dao <span style="color:#66d9ef">in</span> pairs(self.daos) <span style="color:#66d9ef">do</span>
    dao.events <span style="color:#f92672">=</span> events
  <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><h2 id="4-事件分发">4. 事件分发</h2>
<p>Kong 中众多部分通过非阻塞的 <code>ngx.timer.at()</code> 和 <code>ngx.timer.every()</code> 函数执行定时任务。这一部分较为分散，主要叙述 Kong 执行非阻塞一次性事件处理，和典型的定时任务。</p>
<h3 id="41-单次任务">4.1. 单次任务</h3>
<h4 id="411-dns-解析">4.1.1. DNS 解析</h4>
<p>在 <code>cache_warmup.lua</code> 中缓存 services 对象时，Kong 会非阻塞地获取 services 中 host 对应的 IP。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#66d9ef">if</span> entity_name <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;services&#34;</span> <span style="color:#f92672">and</span> host_count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
    ngx.timer.at(<span style="color:#ae81ff">0</span>, warmup_dns, hosts_array, host_count)
  <span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">warmup_dns</span>(premature, hosts, count)
  <span style="color:#66d9ef">if</span> premature <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>

  ngx.log(ngx.NOTICE, <span style="color:#e6db74">&#34;warming up DNS entries ...&#34;</span>)

  <span style="color:#66d9ef">local</span> start <span style="color:#f92672">=</span> ngx.now()

  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, count <span style="color:#66d9ef">do</span>
    kong.dns.toip(hosts[i])
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> elapsed <span style="color:#f92672">=</span> math.floor((ngx.now() <span style="color:#f92672">-</span> start) <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000</span>)

  ngx.log(ngx.NOTICE, <span style="color:#e6db74">&#34;finished warming up DNS entries&#34;</span>,
                      <span style="color:#e6db74">&#34;&#39; into the cache (in &#34;</span>, tostring(elapsed), <span style="color:#e6db74">&#34;ms)&#34;</span>)
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Kong 内部 dns 模块使用 <strong><a href="https://github.com/Kong/lua-resty-dns-client">lua-resty-dns-client</a></strong>，这个库也是由 Kong 开源的，<code>toip</code> 函数会根据 DNS 返回 ip 的权重配置加权轮询的权重，储存 DNS 查询的结果在内存中。</p>
<p><code>warmup_dns()</code> 内调用 <code>kong.dns.toip()</code> 方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">warmup_dns</span>(premature, hosts, count)
  <span style="color:#66d9ef">if</span> premature <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>

  ngx.log(ngx.NOTICE, <span style="color:#e6db74">&#34;warming up DNS entries ...&#34;</span>)

  <span style="color:#66d9ef">local</span> start <span style="color:#f92672">=</span> ngx.now()

  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, count <span style="color:#66d9ef">do</span>
    kong.dns.toip(hosts[i])
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> elapsed <span style="color:#f92672">=</span> math.floor((ngx.now() <span style="color:#f92672">-</span> start) <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000</span>)

  ngx.log(ngx.NOTICE, <span style="color:#e6db74">&#34;finished warming up DNS entries&#34;</span>,
                      <span style="color:#e6db74">&#34;&#39; into the cache (in &#34;</span>, tostring(elapsed), <span style="color:#e6db74">&#34;ms)&#34;</span>)
<span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="42-定时任务">4.2. 定时任务</h3>
<h4 id="421-集群任务">4.2.1. 集群任务</h4>
<p><code>cluster_events/init.lua</code> 中集群事情订阅函数里启用定时器轮询数据库集群事件表。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_M</span>:<span style="color:#a6e22e">subscribe</span>(channel, cb, start_polling)
  <span style="color:#66d9ef">if</span> type(channel) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;string&#34;</span> <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> error(<span style="color:#e6db74">&#34;channel must be a string&#34;</span>)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> type(cb) <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;function&#34;</span> <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> error(<span style="color:#e6db74">&#34;callback must be a function&#34;</span>)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self.callbacks[channel] <span style="color:#66d9ef">then</span>
    self.callbacks[channel] <span style="color:#f92672">=</span> { cb }

    insert(self.channels, channel)

  <span style="color:#66d9ef">else</span>
    insert(self.callbacks[channel], cb)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> start_polling <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
    start_polling <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self.polling <span style="color:#f92672">and</span> start_polling <span style="color:#f92672">and</span> self.use_polling <span style="color:#66d9ef">then</span>
    <span style="color:#75715e">-- start recurring polling timer</span>

    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> timer_at(self.poll_interval, poll_handler, self)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;failed to start polling timer: &#34;</span> <span style="color:#f92672">..</span> err
    <span style="color:#66d9ef">end</span>

    self.polling <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>这里因为要在每次循环调用时进行锁的判断，所以没有使用 <code>ngx.timer.every()</code> 函数，而是循环调用 <code>ngx.timer.at()</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">poll_handler <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(premature, self)
  <span style="color:#66d9ef">if</span> premature <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> self.polling <span style="color:#66d9ef">then</span>
    <span style="color:#75715e">-- set self.polling to false to stop a polling loop</span>
    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> get_lock(self) <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> timer_at(self.poll_interval, poll_handler, self)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      log(CRIT, <span style="color:#e6db74">&#34;failed to start recurring polling timer: &#34;</span>, err)
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#75715e">-- single worker</span>

  <span style="color:#66d9ef">local</span> pok, perr, err <span style="color:#f92672">=</span> pcall(poll, self)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> pok <span style="color:#66d9ef">then</span>
    log(ERR, <span style="color:#e6db74">&#34;poll() threw an error: &#34;</span>, perr)

  <span style="color:#66d9ef">elseif</span> <span style="color:#f92672">not</span> perr <span style="color:#66d9ef">then</span>
    log(ERR, <span style="color:#e6db74">&#34;failed to poll: &#34;</span>, err)
  <span style="color:#66d9ef">end</span>

  <span style="color:#75715e">-- unlock</span>

  self.shm:delete(POLL_RUNNING_LOCK_KEY)

  <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> timer_at(self.poll_interval, poll_handler, self)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
    log(CRIT, <span style="color:#e6db74">&#34;failed to start recurring polling timer: &#34;</span>, err)
  <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>锁通过共享内存事件，保证只有一个 Worker 执行单次任务。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">get_lock</span>(self)
  <span style="color:#75715e">-- check if a poll is not currently running, to ensure we don&#39;t start</span>
  <span style="color:#75715e">-- another poll while a worker is still stuck in its own polling (in</span>
  <span style="color:#75715e">-- case it is being slow)</span>
  <span style="color:#75715e">-- we still add an exptime to this lock in case something goes horribly</span>
  <span style="color:#75715e">-- wrong, to ensure other workers can poll new events</span>
  <span style="color:#75715e">-- a poll cannot take more than max(poll_interval * 5, 10) -- 10s min</span>
  <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> self.shm:safe_add(POLL_RUNNING_LOCK_KEY, <span style="color:#66d9ef">true</span>,
                                    max(self.poll_interval <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">10</span>))
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">if</span> err <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;exists&#34;</span> <span style="color:#66d9ef">then</span>
      log(ERR, <span style="color:#e6db74">&#34;failed to acquire poll_running lock: &#34;</span>, err)
    <span style="color:#66d9ef">end</span>
    <span style="color:#75715e">-- else</span>
    <span style="color:#75715e">--   log(DEBUG, &#34;failed to acquire poll_running lock: &#34;,</span>
    <span style="color:#75715e">--              &#34;a worker still holds the lock&#34;)</span>

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> self.poll_interval <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.001</span> <span style="color:#66d9ef">then</span>
    <span style="color:#75715e">-- check if interval of `poll_interval` has elapsed already, to ensure</span>
    <span style="color:#75715e">-- we do not run the poll when a previous poll was quickly executed, but</span>
    <span style="color:#75715e">-- another worker got the timer trigger a bit too late.</span>
    ok, err <span style="color:#f92672">=</span> self.shm:safe_add(POLL_INTERVAL_LOCK_KEY, <span style="color:#66d9ef">true</span>,
                                self.poll_interval <span style="color:#f92672">-</span> <span style="color:#ae81ff">0.001</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">if</span> err <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;exists&#34;</span> <span style="color:#66d9ef">then</span>
        log(ERR, <span style="color:#e6db74">&#34;failed to acquire poll_interval lock: &#34;</span>, err)
      <span style="color:#66d9ef">end</span>
      <span style="color:#75715e">-- else</span>
      <span style="color:#75715e">--   log(DEBUG, &#34;failed to acquire poll_interval lock: &#34;,</span>
      <span style="color:#75715e">--              &#34;not enough time elapsed since last poll&#34;)</span>

      self.shm:delete(POLL_RUNNING_LOCK_KEY)

      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><h4 id="422-数据库-ttl">4.2.2. 数据库 TTL</h4>
<p>为给 PostgreSQL 加上 TTL，Kong 在 <code>init_worker</code> 阶段调用数据库层 <code>db/strategies/postgres/connector.lua</code> 中 <code>init_worker()</code> 函数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- 以下省略部分内容，只展示关键部分</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_mt</span>:<span style="color:#a6e22e">init_worker</span>(strategies)
  <span style="color:#66d9ef">if</span> ngx.worker.id() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>

      cleanup_statements[i] <span style="color:#f92672">=</span> concat {
        <span style="color:#e6db74">&#34;  DELETE FROM &#34;</span>,
        self:escape_identifier(table_name),
        <span style="color:#e6db74">&#34; WHERE &#34;</span>,
        column_name,
        <span style="color:#e6db74">&#34; &lt; CURRENT_TIMESTAMP AT TIME ZONE &#39;UTC&#39;;&#34;</span>
      }

    <span style="color:#66d9ef">local</span> cleanup_statement <span style="color:#f92672">=</span> concat(cleanup_statements, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)

    <span style="color:#66d9ef">return</span> timer_every(<span style="color:#ae81ff">60</span>, <span style="color:#66d9ef">function</span>(premature)

      <span style="color:#66d9ef">local</span> ok, err, _, num_queries <span style="color:#f92672">=</span> self:query(cleanup_statement)
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">if</span> num_queries <span style="color:#66d9ef">then</span>
          <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> num_queries <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, cleanup_statements_count <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">local</span> statement <span style="color:#f92672">=</span> cleanup_statements[i]
            <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> self:query(statement)
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
              <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
                log(WARN, <span style="color:#e6db74">&#34;unable to clean expired rows from table &#39;&#34;</span>,
                          sorted_strategies[i], <span style="color:#e6db74">&#34;&#39; on PostgreSQL database (&#34;</span>,
                          err, <span style="color:#e6db74">&#34;)&#34;</span>)
              <span style="color:#66d9ef">else</span>
                log(WARN, <span style="color:#e6db74">&#34;unable to clean expired rows from table &#39;&#34;</span>,
                          sorted_strategies[i], <span style="color:#e6db74">&#34;&#39; on PostgreSQL database&#34;</span>)
              <span style="color:#66d9ef">end</span>
            <span style="color:#66d9ef">end</span>
          <span style="color:#66d9ef">end</span>

        <span style="color:#66d9ef">else</span>
          log(ERR, <span style="color:#e6db74">&#34;unable to clean expired rows from PostgreSQL database (&#34;</span>, err, <span style="color:#e6db74">&#34;)&#34;</span>)
        <span style="color:#66d9ef">end</span>
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>数据库初始化时新增一个 <code>timer</code>，在协程中调用回调函数，删除 TTL 过期的 rows。</p>
<h4 id="423-更新路由索引">4.2.3. 更新路由索引</h4>
<p><code>kong.init_worker()</code> 会添加定时任务，定时更新缓存。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">      <span style="color:#75715e">-- 定时重建路由缓存</span>
      <span style="color:#66d9ef">if</span> kong.db.strategy <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;off&#34;</span> <span style="color:#66d9ef">then</span>
        timer_every(worker_state_update_frequency, <span style="color:#66d9ef">function</span>(premature)
          <span style="color:#66d9ef">if</span> premature <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span>
          <span style="color:#66d9ef">end</span>

          <span style="color:#75715e">-- Don&#39;t wait for the semaphore (timeout = 0) when updating via the</span>
          <span style="color:#75715e">-- timer.</span>
          <span style="color:#75715e">-- If the semaphore is locked, that means that the rebuild is</span>
          <span style="color:#75715e">-- already ongoing.</span>
          <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> rebuild_router(ROUTER_ASYNC_OPTS)
          <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
            log(ERR, <span style="color:#e6db74">&#34;could not rebuild router via timer: &#34;</span>, err)
          <span style="color:#66d9ef">end</span>
        <span style="color:#66d9ef">end</span>)

        timer_every(worker_state_update_frequency, <span style="color:#66d9ef">function</span>(premature)
          <span style="color:#66d9ef">if</span> premature <span style="color:#66d9ef">then</span>
            <span style="color:#66d9ef">return</span>
          <span style="color:#66d9ef">end</span>

          <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> rebuild_plugins_iterator(PLUGINS_ITERATOR_ASYNC_OPTS)
          <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
            log(ERR, <span style="color:#e6db74">&#34;could not rebuild plugins iterator via timer: &#34;</span>, err)
          <span style="color:#66d9ef">end</span>
        <span style="color:#66d9ef">end</span>)
      <span style="color:#66d9ef">end</span>
</code></pre></div><p>实际调用顺序是开一个 cosocket 协程，判断 routes 是否有变化，变化则重构路由缓存。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  rebuild_router <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(opts)
    <span style="color:#66d9ef">return</span> rebuild(<span style="color:#e6db74">&#34;router&#34;</span>, update_router, router_version, opts)
  <span style="color:#66d9ef">end</span>

<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">rebuild</span>(name, callback, version, opts)
  <span style="color:#66d9ef">local</span> current_version, err <span style="color:#f92672">=</span> kong.core_cache:get(name <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;:version&#34;</span>, TTL_ZERO,
                                                   utils.uuid)
  <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;failed to retrieve &#34;</span> <span style="color:#f92672">..</span> name <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34; version: &#34;</span> <span style="color:#f92672">..</span> err
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> current_version <span style="color:#f92672">==</span> version <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">end</span>
	
  <span style="color:#75715e">-- 开一个 cosocket 协程调用 callback</span>
  <span style="color:#66d9ef">return</span> concurrency.with_coroutine_mutex(opts, callback)
<span style="color:#66d9ef">end</span>

  update_router <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>()
    <span style="color:#75715e">-- we might not need to rebuild the router (if we were not</span>
    <span style="color:#75715e">-- the first request in this process to enter this code path)</span>
    <span style="color:#75715e">-- check again and rebuild only if necessary</span>
    <span style="color:#66d9ef">local</span> version, err <span style="color:#f92672">=</span> get_router_version()
    <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;failed to retrieve router version: &#34;</span> <span style="color:#f92672">..</span> err
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> version <span style="color:#f92672">==</span> router_version <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> build_router(version)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#75715e">--[[ &#39;err&#39; fully formatted ]]</span> err
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">end</span>
</code></pre></div><p>最终还会调用到 <code>build_router()</code> 方法，我们已经在 1.2.1 中描述过。</p>
<h2 id="5-事件处理">5. 事件处理</h2>
<p>Worker 间的事件处理使用 <code>lua-resty-worker-events</code> 库。</p>
<p>事件订阅函数：<code>events.register(callback, source, event1, event2, ...)</code>，callback 方法 <code>callback = function(data, event, source, pid)</code>。</p>
<p>事件发布函数：<code>success, err = events.post(source, event, data, unique)</code></p>
<h3 id="51-数据库事件">5.1. 数据库事件</h3>
<p><code>db/dao/init.lua</code> 中定义了 DAO 相关的操作方法，我已经在 1.1.3 中简单阐述过了。</p>
<p>数据库相关实体的 CRUD 事件最后会调用 <code>DAO:post_crud_event()</code> 方法广播事件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">DAO</span>:<span style="color:#a6e22e">post_crud_event</span>(operation, entity, old_entity, options)
  <span style="color:#66d9ef">if</span> options <span style="color:#f92672">and</span> options.no_broadcast_crud_event <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> self.events <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">local</span> entity_without_nulls
    <span style="color:#66d9ef">if</span> entity <span style="color:#66d9ef">then</span>
      entity_without_nulls <span style="color:#f92672">=</span> remove_nulls(utils.deep_copy(entity, <span style="color:#66d9ef">false</span>))
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> old_entity_without_nulls
    <span style="color:#66d9ef">if</span> old_entity <span style="color:#66d9ef">then</span>
      old_entity_without_nulls <span style="color:#f92672">=</span> remove_nulls(utils.deep_copy(old_entity, <span style="color:#66d9ef">false</span>))
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> self.events.post_local(<span style="color:#e6db74">&#34;dao:crud&#34;</span>, operation, {
      operation  <span style="color:#f92672">=</span> operation,
      schema     <span style="color:#f92672">=</span> self.schema,
      entity     <span style="color:#f92672">=</span> entity_without_nulls,
      old_entity <span style="color:#f92672">=</span> old_entity_without_nulls,
    })
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      log(ERR, <span style="color:#e6db74">&#34;[db] failed to propagate CRUD operation: &#34;</span>, err)
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>在 <code>dao:crud</code> 通道发布了一个事件，operation 类型有 create、update、delete。</p>
<p><code>runloop/handler.lua</code> 中 <code>register_events()</code> 会在 <code>kong.init_worker()</code> 中被调用，此时会订阅数据库相关事件，添加处理函数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  worker_events.register(<span style="color:#66d9ef">function</span>(data)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> data.schema <span style="color:#66d9ef">then</span>
      log(ERR, <span style="color:#e6db74">&#34;[events] missing schema in crud subscriber&#34;</span>)
      <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> data.entity <span style="color:#66d9ef">then</span>
      log(ERR, <span style="color:#e6db74">&#34;[events] missing entity in crud subscriber&#34;</span>)
      <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- invalidate this entity anywhere it is cached if it has a</span>
    <span style="color:#75715e">-- caching key</span>
    <span style="color:#75715e">-- 如果 entity 有 cache_key 则让它失效</span>
    <span style="color:#75715e">-- 基本上也只有 entity schema 定义出错的情况下才不会有 cache_key</span>

    <span style="color:#66d9ef">local</span> cache_key <span style="color:#f92672">=</span> db[data.schema.name]:cache_key(data.entity)
    <span style="color:#66d9ef">local</span> cache_obj <span style="color:#f92672">=</span> kong[constants.ENTITY_CACHE_STORE[data.schema.name]]

    <span style="color:#66d9ef">if</span> cache_key <span style="color:#66d9ef">then</span>
      cache_obj:invalidate(cache_key)
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- if we had an update, but the cache key was part of what was updated,</span>
    <span style="color:#75715e">-- we need to invalidate the previous entity as well</span>

    <span style="color:#66d9ef">if</span> data.old_entity <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">local</span> old_cache_key <span style="color:#f92672">=</span> db[data.schema.name]:cache_key(data.old_entity)
      <span style="color:#66d9ef">if</span> old_cache_key <span style="color:#f92672">and</span> cache_key <span style="color:#f92672">~=</span> old_cache_key <span style="color:#66d9ef">then</span>
        cache_obj:invalidate(old_cache_key)
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> data.operation <span style="color:#66d9ef">then</span>
      log(ERR, <span style="color:#e6db74">&#34;[events] missing operation in crud subscriber&#34;</span>)
      <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- public worker events propagation</span>

    <span style="color:#75715e">-- 获取 schema 名字</span>
    <span style="color:#66d9ef">local</span> entity_channel           <span style="color:#f92672">=</span> data.schema.table <span style="color:#f92672">or</span> data.schema.name
    <span style="color:#66d9ef">local</span> entity_operation_channel <span style="color:#f92672">=</span> fmt(<span style="color:#e6db74">&#34;%s:%s&#34;</span>, entity_channel,
      data.operation)

    <span style="color:#75715e">-- crud:routes</span>
    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> worker_events.post_local(<span style="color:#e6db74">&#34;crud&#34;</span>, entity_channel, data)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      log(ERR, <span style="color:#e6db74">&#34;[events] could not broadcast crud event: &#34;</span>, err)
      <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- crud:routes:create</span>
    ok, err <span style="color:#f92672">=</span> worker_events.post_local(<span style="color:#e6db74">&#34;crud&#34;</span>, entity_operation_channel, data)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      log(ERR, <span style="color:#e6db74">&#34;[events] could not broadcast crud event: &#34;</span>, err)
      <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>, <span style="color:#e6db74">&#34;dao:crud&#34;</span>)
</code></pre></div><p>CRUD 事件处理流程：调用 <code>cache:invalidate()</code> 方法，方法内部发布了一个 worker 级事件，通知 worker 进程删除该数据，还会发布一个集群事件，在集群间同步删除数据。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#75715e">-- 修改了 Routes 后会清空 router:version 缓存，</span>
  <span style="color:#75715e">-- 会导致重新构建路由表，详情查看 2.2.3</span>
  worker_events.register(<span style="color:#66d9ef">function</span>()
    log(DEBUG, <span style="color:#e6db74">&#34;[events] Route updated, invalidating router&#34;</span>)
    core_cache:invalidate(<span style="color:#e6db74">&#34;router:version&#34;</span>)
  <span style="color:#66d9ef">end</span>, <span style="color:#e6db74">&#34;crud&#34;</span>, <span style="color:#e6db74">&#34;routes&#34;</span>)

...<span style="color:#960050;background-color:#1e0010">其他对象同理</span>
</code></pre></div><h2 id="6-插件加载">6. 插件加载</h2>
<h3 id="61-插件读取">6.1. 插件读取</h3>
<p><code>init</code> 阶段会加载配置文件中 <code>plugins=bundled,skywalking-intergrator</code> 的插件列表，调用 Lua <code>require</code> 加载对应的包。（所有的插件包都要求在 <code>kong.plugins</code> 下）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Plugins</span>:<span style="color:#a6e22e">load_plugin_schemas</span>(plugin_set)
  self.handlers <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>

  <span style="color:#66d9ef">local</span> go_plugins_cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
  <span style="color:#66d9ef">local</span> handlers <span style="color:#f92672">=</span> {}
  <span style="color:#66d9ef">local</span> errs

  <span style="color:#75715e">-- load installed plugins</span>
  <span style="color:#66d9ef">for</span> plugin <span style="color:#66d9ef">in</span> pairs(plugin_set) <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">local</span> handler, err <span style="color:#f92672">=</span> load_plugin(self, plugin)

    <span style="color:#66d9ef">if</span> handler <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">if</span> type(handler.is) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;function&#34;</span> <span style="color:#f92672">and</span> handler:is(BasePlugin) <span style="color:#66d9ef">then</span>
        <span style="color:#75715e">-- Backwards-compatibility for 0.x and 1.x plugins inheriting from the</span>
        <span style="color:#75715e">-- BasePlugin class.</span>
        <span style="color:#75715e">-- TODO: deprecate &amp; remove</span>
        handler <span style="color:#f92672">=</span> handler()
      <span style="color:#66d9ef">end</span>

      <span style="color:#66d9ef">if</span> handler._go <span style="color:#66d9ef">then</span>
        go_plugins_cnt <span style="color:#f92672">=</span> go_plugins_cnt <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
      <span style="color:#66d9ef">end</span>

      handlers[plugin] <span style="color:#f92672">=</span> handler

    <span style="color:#66d9ef">else</span>
      errs <span style="color:#f92672">=</span> errs <span style="color:#f92672">or</span> {}
      table.insert(errs, <span style="color:#e6db74">&#34;on plugin &#39;&#34;</span> <span style="color:#f92672">..</span> plugin <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;&#39;: &#34;</span> <span style="color:#f92672">..</span> tostring(err))
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> errs <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;error loading plugin schemas: &#34;</span> <span style="color:#f92672">..</span> table.concat(errs, <span style="color:#e6db74">&#34;; &#34;</span>)
  <span style="color:#66d9ef">end</span>

  reports.add_immutable_value(<span style="color:#e6db74">&#34;go_plugins_cnt&#34;</span>, go_plugins_cnt)

  self.handlers <span style="color:#f92672">=</span> handlers

  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>所有插件的 Handler 函数会被储存在 <code>kong.db.plugins.handlers</code>，数据格式为 <code>{plugin_name: handler}</code>。</p>
<p>所有的插件会储存到 Worker 进程上，周期性进行同步更新。</p>
<p>我整理了插件表加载到 Lua table 的结构，输出成 YAML，方便理解：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">map</span>:
  <span style="color:#66d9ef">plugin_name</span>: <span style="color:#66d9ef">true</span>

<span style="color:#66d9ef">combos</span>:
  <span style="color:#66d9ef">plugin_name</span>:
    <span style="color:#75715e"># both: {}</span>
    <span style="color:#66d9ef">both</span>: 
      <span style="color:#66d9ef">route_id</span>: service_id
    <span style="color:#75715e"># routes: {}</span>
    <span style="color:#66d9ef">routes</span>:
      <span style="color:#66d9ef">route_id</span>: <span style="color:#66d9ef">true</span>
    <span style="color:#75715e"># services: {}</span>
    <span style="color:#66d9ef">services</span>:
      <span style="color:#66d9ef">service_id</span>: <span style="color:#66d9ef">true</span>
    <span style="color:#66d9ef">0</span>: <span style="color:#66d9ef">true</span> <span style="color:#75715e"># 全局插件</span>
    <span style="color:#66d9ef">1</span>: <span style="color:#66d9ef">true</span> <span style="color:#75715e"># 路由插件</span>
    <span style="color:#66d9ef">2</span>: <span style="color:#66d9ef">true</span> <span style="color:#75715e"># Service 插件</span>
    <span style="color:#66d9ef">3</span>: <span style="color:#66d9ef">true</span> <span style="color:#75715e"># 路由+Service</span>
    <span style="color:#66d9ef">4</span>: <span style="color:#66d9ef">true</span> <span style="color:#75715e"># Consumer 插件</span>
    <span style="color:#66d9ef">5</span>: <span style="color:#66d9ef">true</span> <span style="color:#75715e"># 路由+Consumer 插件</span>
    <span style="color:#66d9ef">6</span>: <span style="color:#66d9ef">true</span> <span style="color:#75715e"># 路由+Service+Consumer 插件</span>

<span style="color:#66d9ef">loaded</span>:
  <span style="color:#66d9ef">plugin_name</span>:
    <span style="color:#66d9ef">handler</span>:
      <span style="color:#66d9ef">phase_name</span>: func()
</code></pre></div><h3 id="62-插件调用">6.2. 插件调用</h3>
<p>插件不直接和路由进行绑定，插件有自己的生命周期，和 Kong 的生命周期基本相同。在 Kong 生命周期的各个阶段会调用插件的对应方法。</p>
<p>插件只在调用阶段进行判断，是否关联当前 Route、Service、和 Consumer，有则从数据库读取插件关联的配置项（插件 Entity），并使用 <code>kong.core_cache</code> 进行缓存。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">load_configuration_through_combos</span>(ctx, combos, plugin)
  <span style="color:#66d9ef">local</span> plugin_configuration
  <span style="color:#66d9ef">local</span> name <span style="color:#f92672">=</span> plugin.name

  <span style="color:#66d9ef">local</span> route    <span style="color:#f92672">=</span> ctx.route
  <span style="color:#66d9ef">local</span> service  <span style="color:#f92672">=</span> ctx.service
  <span style="color:#66d9ef">local</span> consumer <span style="color:#f92672">=</span> ctx.authenticated_consumer

  <span style="color:#66d9ef">if</span> route <span style="color:#f92672">and</span> plugin.no_route <span style="color:#66d9ef">then</span>
    route <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>
  <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">if</span> service <span style="color:#f92672">and</span> plugin.no_service <span style="color:#66d9ef">then</span>
    service <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>
  <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">if</span> consumer <span style="color:#f92672">and</span> plugin.no_consumer <span style="color:#66d9ef">then</span>
    consumer <span style="color:#f92672">=</span> <span style="color:#66d9ef">nil</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span>    route_id <span style="color:#f92672">=</span> route    <span style="color:#f92672">and</span>    route.id <span style="color:#f92672">or</span> <span style="color:#66d9ef">nil</span>
  <span style="color:#66d9ef">local</span>  service_id <span style="color:#f92672">=</span> service  <span style="color:#f92672">and</span>  service.id <span style="color:#f92672">or</span> <span style="color:#66d9ef">nil</span>
  <span style="color:#66d9ef">local</span> consumer_id <span style="color:#f92672">=</span> consumer <span style="color:#f92672">and</span> consumer.id <span style="color:#f92672">or</span> <span style="color:#66d9ef">nil</span>

  <span style="color:#66d9ef">if</span> kong.db.strategy <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;off&#34;</span> <span style="color:#66d9ef">then</span>
	...
  <span style="color:#66d9ef">else</span>
    <span style="color:#66d9ef">if</span> route_id <span style="color:#f92672">and</span> service_id <span style="color:#f92672">and</span> consumer_id <span style="color:#f92672">and</span> combos[COMBO_RSC]
      <span style="color:#f92672">and</span> combos.both[route_id] <span style="color:#f92672">==</span> service_id
    <span style="color:#66d9ef">then</span>
      plugin_configuration <span style="color:#f92672">=</span> load_configuration(ctx, name, route_id, service_id,
                                                consumer_id)
      <span style="color:#66d9ef">if</span> plugin_configuration <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> plugin_configuration
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> consumer_id <span style="color:#f92672">and</span> combos[COMBO_C] <span style="color:#66d9ef">then</span>
      plugin_configuration <span style="color:#f92672">=</span> load_configuration(ctx, name, <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, consumer_id)
      <span style="color:#66d9ef">if</span> plugin_configuration <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> plugin_configuration
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> route_id <span style="color:#f92672">and</span> combos[COMBO_R] <span style="color:#f92672">and</span> combos.routes[route_id] <span style="color:#66d9ef">then</span>
      plugin_configuration <span style="color:#f92672">=</span> load_configuration(ctx, name, route_id)
      <span style="color:#66d9ef">if</span> plugin_configuration <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> plugin_configuration
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
	
    ...

    <span style="color:#66d9ef">if</span> combos[COMBO_GLOBAL] <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> load_configuration(ctx, name)
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>这里会查询当前 Service、Route 和 Consumer 是否与某个插件配对，成功则加载对应的配置项：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">--- Load the configuration for a plugin entry.</span>
<span style="color:#75715e">-- Given a Route, Service, Consumer and a plugin name, retrieve the plugin&#39;s</span>
<span style="color:#75715e">-- configuration if it exists. Results are cached in ngx.dict</span>
<span style="color:#75715e">-- @param[type=string] name Name of the plugin being tested for configuration.</span>
<span style="color:#75715e">-- @param[type=string] route_id Id of the route being proxied.</span>
<span style="color:#75715e">-- @param[type=string] service_id Id of the service being proxied.</span>
<span style="color:#75715e">-- @param[type=string] consumer_id Id of the donsumer making the request (if any).</span>
<span style="color:#75715e">-- @treturn table Plugin configuration, if retrieved.</span>
<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">load_configuration</span>(ctx,
                                  name,
                                  route_id,
                                  service_id,
                                  consumer_id)
  <span style="color:#66d9ef">local</span> ws_id <span style="color:#f92672">=</span> workspaces.get_workspace_id() <span style="color:#f92672">or</span> kong.default_workspace
  <span style="color:#66d9ef">local</span> key <span style="color:#f92672">=</span> kong.db.plugins:cache_key(name,
                                        route_id,
                                        service_id,
                                        consumer_id,
                                        <span style="color:#66d9ef">nil</span>,
                                        ws_id)
  <span style="color:#66d9ef">local</span> plugin, err <span style="color:#f92672">=</span> kong.core_cache:get(key,
                                          <span style="color:#66d9ef">nil</span>,
                                          load_plugin_from_db,
                                          key)
  <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
    ctx.delay_response <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
    ngx.log(ngx.ERR, tostring(err))
    <span style="color:#66d9ef">return</span> ngx.exit(ngx.ERROR)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> plugin <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> plugin.enabled <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> cfg <span style="color:#f92672">=</span> plugin.config <span style="color:#f92672">or</span> {}

  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> cfg.__key__ <span style="color:#66d9ef">then</span>
    cfg.__key__ <span style="color:#f92672">=</span> key
    cfg.__seq__ <span style="color:#f92672">=</span> next_seq
    next_seq <span style="color:#f92672">=</span> next_seq <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
  <span style="color:#66d9ef">end</span>

  cfg.route_id    <span style="color:#f92672">=</span> plugin.route <span style="color:#f92672">and</span> plugin.route.id
  cfg.service_id  <span style="color:#f92672">=</span> plugin.service <span style="color:#f92672">and</span> plugin.service.id
  cfg.consumer_id <span style="color:#f92672">=</span> plugin.consumer <span style="color:#f92672">and</span> plugin.consumer.id

  <span style="color:#66d9ef">return</span> cfg
<span style="color:#66d9ef">end</span>
</code></pre></div><p>插件的调用有两种方式：</p>
<ol>
<li>同步调用</li>
<li>异步调用</li>
</ol>
<p>除了 <code>access_by_lua</code> 阶段，都是使用同步调用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">execute_plugins_iterator</span>(plugins_iterator, phase, ctx)
  <span style="color:#66d9ef">local</span> old_ws <span style="color:#f92672">=</span> ctx <span style="color:#f92672">and</span> ctx.workspace
  <span style="color:#66d9ef">for</span> plugin, configuration <span style="color:#66d9ef">in</span> plugins_iterator:iterate(phase, ctx) <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">if</span> ctx <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">if</span> plugin.handler._go <span style="color:#66d9ef">then</span>
        ctx.ran_go_plugin <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
      <span style="color:#66d9ef">end</span>

      kong_global.set_named_ctx(kong, <span style="color:#e6db74">&#34;plugin&#34;</span>, plugin.handler)
    <span style="color:#66d9ef">end</span>

    kong_global.set_namespaced_log(kong, plugin.name)
    <span style="color:#75715e">-- 这里是同步调用</span>
    plugin.handler[phase](plugin.handler, configuration)
    kong_global.reset_log(kong)

    <span style="color:#66d9ef">if</span> ctx <span style="color:#66d9ef">then</span>
      ctx.workspace <span style="color:#f92672">=</span> old_ws
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>而在 <code>access_by_lua</code> 阶段，使用协程异步调用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#66d9ef">for</span> plugin, plugin_conf <span style="color:#66d9ef">in</span> plugins_iterator:iterate(<span style="color:#e6db74">&#34;access&#34;</span>, ctx) <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">if</span> plugin.handler._go <span style="color:#66d9ef">then</span>
      ctx.ran_go_plugin <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ctx.delayed_response <span style="color:#66d9ef">then</span>
      kong_global.set_named_ctx(kong, <span style="color:#e6db74">&#34;plugin&#34;</span>, plugin.handler)
      kong_global.set_namespaced_log(kong, plugin.name)

      <span style="color:#75715e">-- 使用 Lua coroutine 开启协程异步调用插件函数</span>
      <span style="color:#66d9ef">local</span> err <span style="color:#f92672">=</span> coroutine.wrap(plugin.handler.access)(plugin.handler, plugin_conf)
      <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
        kong.log.err(err)
        ctx.delayed_response <span style="color:#f92672">=</span> {
          status_code <span style="color:#f92672">=</span> <span style="color:#ae81ff">500</span>,
          content     <span style="color:#f92672">=</span> { message  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;An unexpected error occurred&#34;</span> },
        }
      <span style="color:#66d9ef">end</span>

      kong_global.reset_log(kong)
    <span style="color:#66d9ef">end</span>
    ctx.workspace <span style="color:#f92672">=</span> old_ws
  <span style="color:#66d9ef">end</span>
</code></pre></div><h2 id="7-缓存机制">7. 缓存机制</h2>
<p>本节根据我对 Kong 源码的分析，做一个缓存机制的小回顾。</p>
<p>Kong 针对缓存有这些操作：</p>
<ul>
<li>初始化缓存块</li>
<li>预载加载数据库内容到缓存</li>
<li>访问时才加载的数据内容添加到缓存</li>
<li>timer 定时更新缓存</li>
<li>数据库 CRUD 操作删除缓存</li>
<li>集群/Worker 间同步缓存</li>
</ul>
<p>缓存加载内容：</p>
<p>默认配置下，Kong 将路由表和 Routes 全量加载到每个 Worker 的内存，Services 和 Plugins 全量加载到每个 Worker 的内存和共享内存中。Upstreams 和 Targets 根据负载均衡器的解析及时从数据库获取，加载到内存和共享内存中。</p>
<p>上述 Entity 加载在由 mlcache 库创建的 L1+L2 两级缓存 <code>core_cache</code> 中。</p>
<p>而 consumers 加载到同为 mlcache 创建的不同名的 <code>cache</code> 中。</p>
<h2 id="8-请求生命周期">8. 请求生命周期</h2>
<p>本节讲述一个请求经过 Kong 处理的流程。</p>
<h3 id="81-ssl_certificate_by_lua-阶段">8.1. ssl_certificate_by_lua 阶段</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">execute</span>()
  <span style="color:#66d9ef">local</span> sn, err <span style="color:#f92672">=</span> server_name()
  <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
    log(ERR, <span style="color:#e6db74">&#34;could not retrieve SNI: &#34;</span>, err)
    <span style="color:#66d9ef">return</span> ngx.exit(ngx.ERROR)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> cert_and_key, err <span style="color:#f92672">=</span> find_certificate(sn)
  <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
    log(ERR, err)
    <span style="color:#66d9ef">return</span> ngx.exit(ngx.ERROR)
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> cert_and_key <span style="color:#f92672">==</span> default_cert_and_key <span style="color:#66d9ef">then</span>
    <span style="color:#75715e">-- use (already set) fallback certificate</span>
    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#75715e">-- set the certificate for this connection</span>

  <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> clear_certs()
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
    log(ERR, <span style="color:#e6db74">&#34;could not clear existing (default) certificates: &#34;</span>, err)
    <span style="color:#66d9ef">return</span> ngx.exit(ngx.ERROR)
  <span style="color:#66d9ef">end</span>

  ok, err <span style="color:#f92672">=</span> set_cert(cert_and_key.cert)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
    log(ERR, <span style="color:#e6db74">&#34;could not set configured certificate: &#34;</span>, err)
    <span style="color:#66d9ef">return</span> ngx.exit(ngx.ERROR)
  <span style="color:#66d9ef">end</span>

  ok, err <span style="color:#f92672">=</span> set_priv_key(cert_and_key.key)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
    log(ERR, <span style="color:#e6db74">&#34;could not set configured private key: &#34;</span>, err)
    <span style="color:#66d9ef">return</span> ngx.exit(ngx.ERROR)
  <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>根据 Server Name 查找对应 SSL 证书 Cert 和私钥并设置在 Nginx 上。</p>
<h3 id="82-rewrite_by_lua-阶段">8.2. rewrite_by_lua 阶段</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#66d9ef">local</span> ctx <span style="color:#f92672">=</span> ngx.ctx
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ctx.KONG_PROCESSING_START <span style="color:#66d9ef">then</span>
    ctx.KONG_PROCESSING_START <span style="color:#f92672">=</span> ngx.req.start_time() <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ctx.KONG_REWRITE_START <span style="color:#66d9ef">then</span>
    ctx.KONG_REWRITE_START <span style="color:#f92672">=</span> get_now_ms()
  <span style="color:#66d9ef">end</span>

  kong_global.set_phase(kong, PHASES.rewrite)
  kong_resty_ctx.stash_ref()

  <span style="color:#66d9ef">local</span> is_https <span style="color:#f92672">=</span> var.https <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;on&#34;</span>
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_https <span style="color:#66d9ef">then</span>
    log_init_worker_errors(ctx)
  <span style="color:#66d9ef">end</span>

  runloop.rewrite.before(ctx)

...

  rewrite <span style="color:#f92672">=</span> {
    before <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(ctx)
      ctx.host_port <span style="color:#f92672">=</span> HOST_PORTS[var.server_port] <span style="color:#f92672">or</span> var.server_port

      <span style="color:#75715e">-- special handling for proxy-authorization and te headers in case</span>
      <span style="color:#75715e">-- the plugin(s) want to specify them (store the original)</span>
      ctx.http_proxy_authorization <span style="color:#f92672">=</span> var.http_proxy_authorization
      ctx.http_te                  <span style="color:#f92672">=</span> var.http_te
    <span style="color:#66d9ef">end</span>,
  },
</code></pre></div><p>初始化 <code>kong.ctx</code> 生命周期 Context，为 Context 添加请求信息。</p>
<h3 id="83-access_by_lua-阶段">8.3. access_by_lua 阶段</h3>
<h4 id="831-路由匹配">8.3.1. 路由匹配</h4>
<p><code>runloop.access.before</code> 会进行调用 <code>Router</code> 实例进行路由匹配。首先会调用 <code>get_updated_router()</code> 判断是否有路由更新，没有则返回当前 <code>Router</code> 实例。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">      <span style="color:#75715e">-- routing request</span>
      <span style="color:#66d9ef">local</span> router <span style="color:#f92672">=</span> get_updated_router()
	  <span style="color:#75715e">-- 调用 Router.exec() 查找匹配的路由</span>
      <span style="color:#66d9ef">local</span> match_t <span style="color:#f92672">=</span> router.exec()
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> match_t <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> kong.response.exit(<span style="color:#ae81ff">404</span>, { message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;no Route matched with those values&#34;</span> })
      <span style="color:#66d9ef">end</span>
</code></pre></div><p><code>Router.exec()</code> 方法最终会调用 <code>Router.find_route()</code> 方法，该方法接收请求头字段，并生成路由 Cache Key，查找对应的项目。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">find_route</span>(req_method, req_uri, req_host, req_scheme,
                            src_ip, src_port,
                            dst_ip, dst_port,
                            sni, req_headers)
    
    req_method <span style="color:#f92672">=</span> req_method <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;&#34;</span>
    req_uri <span style="color:#f92672">=</span> req_uri <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;&#34;</span>
    req_host <span style="color:#f92672">=</span> req_host <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;&#34;</span>
    req_headers <span style="color:#f92672">=</span> req_headers <span style="color:#f92672">or</span> EMPTY_T

    ctx.req_method     <span style="color:#f92672">=</span> req_method
    ctx.req_uri        <span style="color:#f92672">=</span> req_uri
    ctx.req_host       <span style="color:#f92672">=</span> req_host
    ctx.req_headers    <span style="color:#f92672">=</span> req_headers
    ctx.src_ip         <span style="color:#f92672">=</span> src_ip <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;&#34;</span>
    ctx.src_port       <span style="color:#f92672">=</span> src_port <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;&#34;</span>
    ctx.dst_ip         <span style="color:#f92672">=</span> dst_ip <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;&#34;</span>
    ctx.dst_port       <span style="color:#f92672">=</span> dst_port <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;&#34;</span>
    ctx.sni            <span style="color:#f92672">=</span> sni <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;&#34;</span>
    
    <span style="color:#66d9ef">local</span> cache_key <span style="color:#f92672">=</span> req_method <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> req_uri <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> req_host <span style="color:#f92672">..</span>
                      <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> ctx.src_ip <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> ctx.src_port <span style="color:#f92672">..</span>
                      <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> ctx.dst_ip <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> ctx.dst_port <span style="color:#f92672">..</span>
                      <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">..</span> ctx.sni

    <span style="color:#66d9ef">do</span>
      <span style="color:#66d9ef">local</span> match_t <span style="color:#f92672">=</span> cache:get(cache_key)
      <span style="color:#66d9ef">if</span> match_t <span style="color:#f92672">and</span> hits.header_name <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> match_t
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
</code></pre></div><p>如果 LRU 缓存中有匹配路由，则直接返回。</p>
<p>否则继续匹配路由，生成匹配项目，并存入缓存中。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">              ...
              <span style="color:#66d9ef">local</span> match_t     <span style="color:#f92672">=</span> {
                  route           <span style="color:#f92672">=</span> matched_route.route,
                  service         <span style="color:#f92672">=</span> matched_route.service,
                  headers         <span style="color:#f92672">=</span> matched_route.headers,
                  upstream_url_t  <span style="color:#f92672">=</span> upstream_url_t,
                  upstream_scheme <span style="color:#f92672">=</span> upstream_url_t.scheme,
                  upstream_uri    <span style="color:#f92672">=</span> upstream_uri,
                  upstream_host   <span style="color:#f92672">=</span> upstream_host,
                  prefix          <span style="color:#f92672">=</span> request_prefix,
                  matches         <span style="color:#f92672">=</span> {
                    uri_captures  <span style="color:#f92672">=</span> matches.uri_captures,
                    uri           <span style="color:#f92672">=</span> matches.uri,
                    host          <span style="color:#f92672">=</span> matches.host,
                    headers       <span style="color:#f92672">=</span> matches.headers,
                    method        <span style="color:#f92672">=</span> matches.method,
                    src_ip        <span style="color:#f92672">=</span> matches.src_ip,
                    src_port      <span style="color:#f92672">=</span> matches.src_port,
                    dst_ip        <span style="color:#f92672">=</span> matches.dst_ip,
                    dst_port      <span style="color:#f92672">=</span> matches.dst_port,
                    sni           <span style="color:#f92672">=</span> matches.sni,
                  }
                }

                <span style="color:#66d9ef">if</span> band(matched_route.match_rules, MATCH_RULES.HEADER) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
                  cache:set(cache_key, match_t)
                <span style="color:#66d9ef">end</span>
                ...
</code></pre></div><p>匹配成功后会将关联的 Route 和 Service 写入 <code>ngx.ctx</code> ，在接下来的生命周期中共享。</p>
<h4 id="832-请求调度">8.3.2. 请求调度</h4>
<p><code>runloop.access.after</code> 中根据 Route、Service 等条件解析出后端要请求的 IP、Port、Schema 等参数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#75715e">-- looks up a balancer for the target.</span>
<span style="color:#75715e">-- @param target the table with the target details</span>
<span style="color:#75715e">-- @param no_create (optional) if true, do not attempt to create</span>
<span style="color:#75715e">-- (for thorough testing purposes)</span>
<span style="color:#75715e">-- @return balancer if found, `false` if not found, or nil+error on error</span>
<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">get_balancer</span>(target, no_create)
  <span style="color:#75715e">-- NOTE: only called upon first lookup, so `cache_only` limitations</span>
  <span style="color:#75715e">-- do not apply here</span>
  <span style="color:#66d9ef">local</span> hostname <span style="color:#f92672">=</span> target.host


  <span style="color:#75715e">-- first go and find the upstream object, from cache or the db</span>
  <span style="color:#66d9ef">local</span> upstream, err <span style="color:#f92672">=</span> get_upstream_by_name(hostname)
  <span style="color:#66d9ef">if</span> upstream <span style="color:#f92672">==</span> <span style="color:#66d9ef">false</span> <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span> <span style="color:#75715e">-- no upstream by this name</span>
  <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">if</span> err <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, err <span style="color:#75715e">-- there was an error</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> balancer <span style="color:#f92672">=</span> balancers[upstream.id]
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> balancer <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">if</span> no_create <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;balancer not found&#34;</span>
    <span style="color:#66d9ef">else</span>
      log(ERR, <span style="color:#e6db74">&#34;balancer not found for &#34;</span>, upstream.name, <span style="color:#e6db74">&#34;, will create it&#34;</span>)
      <span style="color:#66d9ef">return</span> create_balancer(upstream), upstream
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> balancer, upstream
<span style="color:#66d9ef">end</span>
</code></pre></div><p><code>get_balancer()</code> 根据 Service 的 Host 返回最终请求的 Target，和负载均衡器。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#66d9ef">local</span> ip, port, hostname, handle
  <span style="color:#66d9ef">if</span> balancer <span style="color:#66d9ef">then</span>
    <span style="color:#75715e">-- have to invoke the ring-balancer</span>
    <span style="color:#66d9ef">local</span> hstate <span style="color:#f92672">=</span> run_hook(<span style="color:#e6db74">&#34;balancer:get_peer:pre&#34;</span>, target.host)
    ip, port, hostname, handle <span style="color:#f92672">=</span> balancer:getPeer(dns_cache_only,
                                          target.balancer_handle,
                                          hash_value)
    run_hook(<span style="color:#e6db74">&#34;balancer:get_peer:post&#34;</span>, hstate)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ip <span style="color:#f92672">and</span>
      (port <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;No peers are available&#34;</span> <span style="color:#f92672">or</span> port <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;Balancer is unhealthy&#34;</span>) <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;failure to get a peer from the ring-balancer&#34;</span>, <span style="color:#ae81ff">503</span>
    <span style="color:#66d9ef">end</span>
    hostname <span style="color:#f92672">=</span> hostname <span style="color:#f92672">or</span> ip
    target.hash_value <span style="color:#f92672">=</span> hash_value
    target.balancer_handle <span style="color:#f92672">=</span> handle

  <span style="color:#66d9ef">else</span>
    <span style="color:#75715e">-- have to do a regular DNS lookup</span>
    <span style="color:#66d9ef">local</span> try_list
    <span style="color:#66d9ef">local</span> hstate <span style="color:#f92672">=</span> run_hook(<span style="color:#e6db74">&#34;balancer:to_ip:pre&#34;</span>, target.host)
    ip, port, try_list <span style="color:#f92672">=</span> toip(target.host, target.port, dns_cache_only)
    run_hook(<span style="color:#e6db74">&#34;balancer:to_ip:post&#34;</span>, hstate)
    hostname <span style="color:#f92672">=</span> target.host
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ip <span style="color:#66d9ef">then</span>
      log(ERR, <span style="color:#e6db74">&#34;DNS resolution failed: &#34;</span>, port, <span style="color:#e6db74">&#34;. Tried: &#34;</span>, tostring(try_list))
      <span style="color:#66d9ef">if</span> port <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;dns server error: 3 name error&#34;</span> <span style="color:#f92672">or</span>
         port <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;dns client error: 101 empty record received&#34;</span> <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#e6db74">&#34;name resolution failed&#34;</span>, <span style="color:#ae81ff">503</span>
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>
</code></pre></div><p>调用负载均衡器的策略获取 Target 的 IP，或者直接使用 DNS 查询获取 IP 地址，这一步在 2.1.1 中已经提前进行了 DNS 预缓存，这里可以从缓存中读取。</p>
<p>如果 Service Host 直接是 IP 地址，则不执行负载均衡策略。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#75715e">-- ip 则直接返回</span>
  <span style="color:#66d9ef">if</span> target.type <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;name&#34;</span> <span style="color:#66d9ef">then</span>
    <span style="color:#75715e">-- it&#39;s an ip address (v4 or v6), so nothing we can do...</span>
    target.ip <span style="color:#f92672">=</span> target.host
    target.port <span style="color:#f92672">=</span> target.port <span style="color:#f92672">or</span> <span style="color:#ae81ff">80</span> <span style="color:#75715e">-- TODO: remove this fallback value</span>
    target.hostname <span style="color:#f92672">=</span> target.host
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="84-balancer_by_lua-阶段">8.4. balancer_by_lua 阶段</h3>
<p>使用 <code>ngx.balancer.set_more_tries()</code> 设置错误重试次数，使用 <code>ngx.balancer.get_last_failure()</code> 获取上一次请求错误详情，在错误处理中进行对上游节点进行被动健康检查。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#66d9ef">if</span> balancer_data.try_count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">then</span>
    <span style="color:#75715e">-- only call balancer on retry, first one is done in `runloop.access.after`</span>
    <span style="color:#75715e">-- which runs in the ACCESS context and hence has less limitations than</span>
    <span style="color:#75715e">-- this BALANCER context where the retries are executed</span>

    <span style="color:#75715e">-- record failure data</span>
    <span style="color:#66d9ef">local</span> previous_try <span style="color:#f92672">=</span> tries[balancer_data.try_count <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]
    previous_try.state, previous_try.code <span style="color:#f92672">=</span> get_last_failure()

    <span style="color:#75715e">-- Report HTTP status for health checks</span>
    <span style="color:#66d9ef">local</span> balancer <span style="color:#f92672">=</span> balancer_data.balancer
    <span style="color:#66d9ef">if</span> balancer <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">if</span> previous_try.state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;failed&#34;</span> <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">if</span> previous_try.code <span style="color:#f92672">==</span> <span style="color:#ae81ff">504</span> <span style="color:#66d9ef">then</span>
          balancer.report_timeout(balancer_data.balancer_handle)
        <span style="color:#66d9ef">else</span>
          balancer.report_tcp_failure(balancer_data.balancer_handle)
        <span style="color:#66d9ef">end</span>

      <span style="color:#66d9ef">else</span>
        balancer.report_http_status(balancer_data.balancer_handle,
                                    previous_try.code)
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">local</span> ok, err, errcode <span style="color:#f92672">=</span> balancer_execute(balancer_data)
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
      ngx_log(ngx_ERR, <span style="color:#e6db74">&#34;failed to retry the dns/balancer resolver for &#34;</span>,
              tostring(balancer_data.host), <span style="color:#e6db74">&#34;&#39; with: &#34;</span>, tostring(err))

      ctx.KONG_BALANCER_ENDED_AT <span style="color:#f92672">=</span> get_now_ms()
      ctx.KONG_BALANCER_TIME <span style="color:#f92672">=</span> ctx.KONG_BALANCER_ENDED_AT <span style="color:#f92672">-</span> ctx.KONG_BALANCER_START
      ctx.KONG_PROXY_LATENCY <span style="color:#f92672">=</span> ctx.KONG_BALANCER_ENDED_AT <span style="color:#f92672">-</span> ctx.KONG_PROCESSING_START

      <span style="color:#66d9ef">return</span> ngx.exit(errcode)
    <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">else</span>
    <span style="color:#75715e">-- first try, so set the max number of retries</span>
    <span style="color:#66d9ef">local</span> retries <span style="color:#f92672">=</span> balancer_data.retries
    <span style="color:#66d9ef">if</span> retries <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
      set_more_tries(retries)
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>
</code></pre></div><p>请求到最终解析的后端服务，使用 <code>ngx.balancer.set_current_peer()</code> 方法设置访问的地址。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#75715e">-- set the targets as resolved</span>
  ngx_log(ngx_DEBUG, <span style="color:#e6db74">&#34;setting address (try &#34;</span>, balancer_data.try_count, <span style="color:#e6db74">&#34;): &#34;</span>,
                     balancer_data.ip, <span style="color:#e6db74">&#34;:&#34;</span>, balancer_data.port)
  <span style="color:#75715e">-- 最终调度的地址</span>
  <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> set_current_peer(balancer_data.ip, balancer_data.port, pool_opts)
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
    ngx_log(ngx_ERR, <span style="color:#e6db74">&#34;failed to set the current peer (address: &#34;</span>,
            tostring(balancer_data.ip), <span style="color:#e6db74">&#34; port: &#34;</span>, tostring(balancer_data.port),
            <span style="color:#e6db74">&#34;): &#34;</span>, tostring(err))

    ctx.KONG_BALANCER_ENDED_AT <span style="color:#f92672">=</span> get_now_ms()
    ctx.KONG_BALANCER_TIME <span style="color:#f92672">=</span> ctx.KONG_BALANCER_ENDED_AT <span style="color:#f92672">-</span> ctx.KONG_BALANCER_START
    ctx.KONG_PROXY_LATENCY <span style="color:#f92672">=</span> ctx.KONG_BALANCER_ENDED_AT <span style="color:#f92672">-</span> ctx.KONG_PROCESSING_START

    <span style="color:#66d9ef">return</span> ngx.exit(<span style="color:#ae81ff">500</span>)
  <span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="85-header_filter_by_lua-阶段">8.5. header_filter_by_lua 阶段</h3>
<p>此阶段在 Kong 接收完上游服务返回的 Header 字段后执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">      <span style="color:#66d9ef">local</span> upstream_status_header <span style="color:#f92672">=</span> constants.HEADERS.UPSTREAM_STATUS
      <span style="color:#66d9ef">if</span> singletons.configuration.enabled_headers[upstream_status_header] <span style="color:#66d9ef">then</span>
        header[upstream_status_header] <span style="color:#f92672">=</span> tonumber(sub(var.upstream_status <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>))
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> header[upstream_status_header] <span style="color:#66d9ef">then</span>
          log(ERR, <span style="color:#e6db74">&#34;failed to set &#34;</span>, upstream_status_header, <span style="color:#e6db74">&#34; header&#34;</span>)
        <span style="color:#66d9ef">end</span>
      <span style="color:#66d9ef">end</span>

      <span style="color:#66d9ef">local</span> hash_cookie <span style="color:#f92672">=</span> ctx.balancer_data.hash_cookie
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> hash_cookie <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span>
      <span style="color:#66d9ef">end</span>

      <span style="color:#66d9ef">local</span> cookie <span style="color:#f92672">=</span> ck:new()
      <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> cookie:set(hash_cookie)
</code></pre></div><p><code>runloop.header_filter.before</code> 中在返回结果的 header 里加入节点状态，以及判断是否需要加入负载均衡器一致性策略的 Cookie。</p>
<h3 id="86-body_filter_by_lua-阶段">8.6. body_filter_by_lua 阶段</h3>
<p>此阶段在接收上游服务返回的 Body 数据时执行，根据数据大小划分 chunks，此阶段会被执行多次。</p>
<p>在 OpenResty 的生命周期里，<code>body_filter_by_lua</code> 中使用 <code>ngx.arg[1]</code> 读取 chunk，使用 <code>ngx.arg[2]</code> 标记 EOF。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">  <span style="color:#75715e">-- 获取到了所有的 body</span>
  <span style="color:#66d9ef">if</span> kong.ctx.core.response_body <span style="color:#66d9ef">then</span>
    arg[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> kong.ctx.core.response_body
    arg[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> arg[<span style="color:#ae81ff">2</span>] <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">return</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#75715e">-- 获取到所有的 body 后</span>
  <span style="color:#75715e">-- 再统计执行时间</span>
  ctx.KONG_BODY_FILTER_ENDED_AT <span style="color:#f92672">=</span> get_now_ms()
  ctx.KONG_BODY_FILTER_TIME <span style="color:#f92672">=</span> ctx.KONG_BODY_FILTER_ENDED_AT <span style="color:#f92672">-</span> ctx.KONG_BODY_FILTER_START

  <span style="color:#66d9ef">if</span> ctx.KONG_PROXIED <span style="color:#66d9ef">then</span>
    <span style="color:#75715e">-- time spent receiving the response (header_filter + body_filter)</span>
    <span style="color:#75715e">-- we could use $upstream_response_time but we need to distinguish the waiting time</span>
    <span style="color:#75715e">-- from the receiving time in our logging plugins (especially ALF serializer).</span>
    ctx.KONG_RECEIVE_TIME <span style="color:#f92672">=</span> ctx.KONG_BODY_FILTER_ENDED_AT <span style="color:#f92672">-</span> (ctx.KONG_HEADER_FILTER_START <span style="color:#f92672">or</span>
                                                             ctx.KONG_BALANCER_ENDED_AT <span style="color:#f92672">or</span>
                                                             ctx.KONG_BALANCER_START <span style="color:#f92672">or</span>
                                                             ctx.KONG_ACCESS_ENDED_AT)
</code></pre></div><h3 id="87-log_by_lua-阶段">8.7. log_by_lua 阶段</h3>
<p>调用 Lua 的垃圾回收器统计 Kong 占用内存情况：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> update_lua_mem
<span style="color:#66d9ef">do</span>
  <span style="color:#66d9ef">local</span> pid <span style="color:#f92672">=</span> ngx.worker.pid
  <span style="color:#66d9ef">local</span> kong_shm <span style="color:#f92672">=</span> ngx.shared.kong

  <span style="color:#66d9ef">local</span> Lua_MEM_SAMPLE_RATE <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span> <span style="color:#75715e">-- seconds</span>
  <span style="color:#66d9ef">local</span> last <span style="color:#f92672">=</span> ngx.time()

  <span style="color:#66d9ef">local</span> collectgarbage <span style="color:#f92672">=</span> collectgarbage

  update_lua_mem <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(force)
    <span style="color:#66d9ef">local</span> time <span style="color:#f92672">=</span> ngx.time()

    <span style="color:#66d9ef">if</span> force <span style="color:#f92672">or</span> time <span style="color:#f92672">-</span> last <span style="color:#f92672">&gt;=</span> Lua_MEM_SAMPLE_RATE <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">local</span> count <span style="color:#f92672">=</span> collectgarbage(<span style="color:#e6db74">&#34;count&#34;</span>)

      <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> kong_shm:safe_set(<span style="color:#e6db74">&#34;kong:mem:&#34;</span> <span style="color:#f92672">..</span> pid(), count)
      <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
        log(ERR, <span style="color:#e6db74">&#34;could not record Lua VM allocated memory: &#34;</span>, err)
      <span style="color:#66d9ef">end</span>

      last <span style="color:#f92672">=</span> ngx.time()
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>根据响应结果调用负载均衡器调整上游节点的权重：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">      <span style="color:#75715e">-- If response was produced by an upstream (ie, not by a Kong plugin)</span>
      <span style="color:#75715e">-- Report HTTP status for health checks</span>
      <span style="color:#66d9ef">local</span> balancer_data <span style="color:#f92672">=</span> ctx.balancer_data
      <span style="color:#66d9ef">if</span> balancer_data <span style="color:#f92672">and</span> balancer_data.balancer_handle <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">local</span> status <span style="color:#f92672">=</span> ngx.status
        <span style="color:#66d9ef">if</span> status <span style="color:#f92672">==</span> <span style="color:#ae81ff">504</span> <span style="color:#66d9ef">then</span>
          balancer_data.balancer.report_timeout(balancer_data.balancer_handle)
        <span style="color:#66d9ef">else</span>
          balancer_data.balancer.report_http_status(
            balancer_data.balancer_handle, status)
        <span style="color:#66d9ef">end</span>
        <span style="color:#75715e">-- release the handle, so the balancer can update its statistics</span>
        balancer_data.balancer_handle:release()
      <span style="color:#66d9ef">end</span>
</code></pre></div><h2 id="9-admin-api">9. Admin API</h2>
<p>Kong Admin API 入口：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Kong</span>.<span style="color:#a6e22e">admin_content</span>(options)
  <span style="color:#66d9ef">local</span> ctx <span style="color:#f92672">=</span> ngx.ctx
  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ctx.workspace <span style="color:#66d9ef">then</span>
    ctx.workspace <span style="color:#f92672">=</span> kong.default_workspace
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> serve_content(<span style="color:#e6db74">&#34;kong.api&#34;</span>, options)
<span style="color:#66d9ef">end</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">serve_content</span>(module, options)

  <span style="color:#75715e">-- CORS 跨域相关</span>
  header[<span style="color:#e6db74">&#34;Access-Control-Allow-Origin&#34;</span>] <span style="color:#f92672">=</span> options.allow_origin <span style="color:#f92672">or</span> <span style="color:#e6db74">&#34;*&#34;</span>

  <span style="color:#75715e">-- 启动 lapis</span>
  lapis.serve(module)
<span style="color:#66d9ef">end</span>
</code></pre></div><p>关于 <a href="https://leafo.net/lapis/">Lapis</a>：</p>
<blockquote>
<p>Lapis is a framework for building web applications using <a href="https://moonscript.org">MoonScript</a> or <a href="https://lua.org">Lua</a> that runs inside of a customized version of <a href="https://nginx.org">Nginx</a> called <a href="https://openresty.org">OpenResty</a>.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#f92672">#</span> api<span style="color:#f92672">/</span>init.lua
<span style="color:#75715e">-- 加载固定路由</span>
<span style="color:#75715e">-- Load core routes</span>
<span style="color:#66d9ef">for</span> _, v <span style="color:#66d9ef">in</span> ipairs({<span style="color:#e6db74">&#34;kong&#34;</span>, <span style="color:#e6db74">&#34;health&#34;</span>, <span style="color:#e6db74">&#34;cache&#34;</span>, <span style="color:#e6db74">&#34;config&#34;</span>, <span style="color:#e6db74">&#34;clustering&#34;</span>}) <span style="color:#66d9ef">do</span>
  <span style="color:#66d9ef">local</span> routes <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;kong.api.routes.&#34;</span> <span style="color:#f92672">..</span> v)
  api_helpers.attach_routes(app, routes)
<span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">local</span> routes <span style="color:#f92672">=</span> {}

  <span style="color:#75715e">-- DAO Routes</span>
  <span style="color:#66d9ef">for</span> _, dao <span style="color:#66d9ef">in</span> pairs(singletons.db.daos) <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">if</span> dao.schema.generate_admin_api <span style="color:#f92672">~=</span> <span style="color:#66d9ef">false</span> <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> dao.schema.legacy <span style="color:#66d9ef">then</span>
      routes <span style="color:#f92672">=</span> Endpoints.new(dao.schema, routes)
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>
</code></pre></div><p>初始化构建路由：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#f92672">#</span> api<span style="color:#f92672">/</span>endpoints.lua
<span style="color:#75715e">-- 创建基础路由</span>
<span style="color:#75715e">-- Generates admin api endpoint functions</span>
<span style="color:#75715e">--</span>
<span style="color:#75715e">-- Examples:</span>
<span style="color:#75715e">--</span>
<span style="color:#75715e">-- /routes</span>
<span style="color:#75715e">-- /routes/:routes</span>
<span style="color:#75715e">-- /routes/:routes/service</span>
<span style="color:#75715e">-- /services/:services/routes</span>
<span style="color:#75715e">--</span>
<span style="color:#75715e">-- and</span>
<span style="color:#75715e">--</span>
<span style="color:#75715e">-- /services</span>
<span style="color:#75715e">-- /services/:services</span>
<span style="color:#75715e">-- /services/:services/routes/:routes</span>
<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">generate_endpoints</span>(schema, endpoints)
  <span style="color:#75715e">-- list 路由</span>
  <span style="color:#75715e">-- e.g. /routes</span>
  generate_collection_endpoints(endpoints, schema)

  <span style="color:#75715e">-- 单体路由</span>
  <span style="color:#75715e">-- e.g. /routes/:routes</span>
  generate_entity_endpoints(endpoints, schema)

  <span style="color:#75715e">-- 判断是否有关联对象</span>
  <span style="color:#75715e">-- 例如 route 关联 services</span>
  <span style="color:#66d9ef">for</span> foreign_field_name, foreign_field <span style="color:#66d9ef">in</span> schema:each_field() <span style="color:#66d9ef">do</span>
    <span style="color:#75715e">-- 外键</span>
    <span style="color:#66d9ef">if</span> foreign_field.type <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;foreign&#34;</span> <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> foreign_field.schema.legacy <span style="color:#66d9ef">then</span>
      <span style="color:#75715e">-- e.g. /routes/:routes/service</span>
      generate_entity_endpoints(endpoints, schema, foreign_field.schema, foreign_field_name, <span style="color:#66d9ef">true</span>)

      <span style="color:#75715e">-- e.g. /services/:services/routes</span>
      generate_collection_endpoints(endpoints, schema, foreign_field.schema, foreign_field_name)

      <span style="color:#75715e">-- e.g. /services/:services/routes/:routes</span>
      generate_entity_endpoints(endpoints, foreign_field.schema, schema, foreign_field_name)
    <span style="color:#66d9ef">end</span>
  <span style="color:#66d9ef">end</span>

  <span style="color:#66d9ef">return</span> endpoints
<span style="color:#66d9ef">end</span>

<span style="color:#75715e">-- Generates admin api collection endpoint functions</span>
<span style="color:#75715e">--</span>
<span style="color:#75715e">-- Examples:</span>
<span style="color:#75715e">--</span>
<span style="color:#75715e">-- /routes</span>
<span style="color:#75715e">-- /services/:services/routes</span>
<span style="color:#75715e">--</span>
<span style="color:#75715e">-- and</span>
<span style="color:#75715e">--</span>
<span style="color:#75715e">-- /services</span>
<span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">generate_collection_endpoints</span>(endpoints, schema, foreign_schema, foreign_field_name)
  <span style="color:#66d9ef">local</span> collection_path

  <span style="color:#75715e">-- 外键关联</span>
  <span style="color:#66d9ef">if</span> foreign_schema <span style="color:#66d9ef">then</span>
    collection_path <span style="color:#f92672">=</span> fmt(<span style="color:#e6db74">&#34;/%s/:%s/%s&#34;</span>, foreign_schema.admin_api_name <span style="color:#f92672">or</span>
                                        foreign_schema.name,
                                        foreign_schema.name,
                                        schema.admin_api_nested_name <span style="color:#f92672">or</span>
                                        schema.admin_api_name <span style="color:#f92672">or</span>
                                        schema.name)

  <span style="color:#66d9ef">else</span>
    <span style="color:#75715e">-- 没有外键关联</span>
    collection_path <span style="color:#f92672">=</span> fmt(<span style="color:#e6db74">&#34;/%s&#34;</span>, schema.admin_api_name <span style="color:#f92672">or</span>
                                 schema.name)
  <span style="color:#66d9ef">end</span>

  endpoints[collection_path] <span style="color:#f92672">=</span> {
    schema  <span style="color:#f92672">=</span> schema,
    methods <span style="color:#f92672">=</span> {
      <span style="color:#75715e">--OPTIONS = method_not_allowed,</span>
      <span style="color:#75715e">--HEAD    = method_not_allowed,</span>
      GET     <span style="color:#f92672">=</span> get_collection_endpoint(schema, foreign_schema, foreign_field_name),
      POST    <span style="color:#f92672">=</span> post_collection_endpoint(schema, foreign_schema, foreign_field_name),
      <span style="color:#75715e">--PUT     = method_not_allowed,</span>
      <span style="color:#75715e">--PATCH   = method_not_allowed,</span>
      <span style="color:#75715e">--DELETE  = method_not_allowed,</span>
    },
  }
<span style="color:#66d9ef">end</span>
</code></pre></div><p>只关注 POST 请求处理的部分：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">post_collection_endpoint</span>(schema, foreign_schema, foreign_field_name, method)
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span>(self, db, helpers, post_process)
    <span style="color:#66d9ef">if</span> foreign_schema <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">local</span> foreign_entity, _, err_t <span style="color:#f92672">=</span> select_entity(self, db, foreign_schema)
      <span style="color:#66d9ef">if</span> err_t <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> handle_error(err_t)
      <span style="color:#66d9ef">end</span>

      <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> foreign_entity <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> not_found()
      <span style="color:#66d9ef">end</span>

      self.args.post[foreign_field_name] <span style="color:#f92672">=</span> foreign_schema:extract_pk_values(foreign_entity)
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">-- 处理请求，参数校验，插入数据    </span>
    <span style="color:#66d9ef">local</span> entity, _, err_t <span style="color:#f92672">=</span> insert_entity(self, db, schema, method)
    <span style="color:#66d9ef">if</span> err_t <span style="color:#66d9ef">then</span>
      <span style="color:#66d9ef">return</span> handle_error(err_t)
    <span style="color:#66d9ef">end</span>
    
    <span style="color:#75715e">-- 回调函数</span>
    <span style="color:#66d9ef">if</span> post_process <span style="color:#66d9ef">then</span>
      entity, _, err_t <span style="color:#f92672">=</span> post_process(entity)
      <span style="color:#66d9ef">if</span> err_t <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">return</span> handle_error(err_t)
      <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> created(entity)
  <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Admin API 仅仅是一层 API 封装，不负责背后的事件处理和数据同步，背后的事件处理在文章事件处理部分阐述过了。</p>
<h2 id="10-插件开发">10. 插件开发</h2>
<p>简单介绍一下插件开发能用上的一些小 Trick。</p>
<h3 id="101-多层-schema-嵌套">10.1. 多层 Schema 嵌套</h3>
<p>Schema 多层嵌套示例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> schema <span style="color:#f92672">=</span> {
    name <span style="color:#f92672">=</span> plugin_name,
    fields <span style="color:#f92672">=</span> {
        { consumer <span style="color:#f92672">=</span> typedefs.no_consumer },
        { protocols <span style="color:#f92672">=</span> typedefs.protocols_http },
        { config <span style="color:#f92672">=</span> {
          type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;record&#34;</span>,
          fields <span style="color:#f92672">=</span> { {
            rules <span style="color:#f92672">=</span> {
              type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;array&#34;</span>,
              elements <span style="color:#f92672">=</span> {
                type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;record&#34;</span>,
                fields <span style="color:#f92672">=</span> { {
                  match <span style="color:#f92672">=</span> {
                    type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;array&#34;</span>,
                    elements <span style="color:#f92672">=</span> {
                      type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;record&#34;</span>,
                      fields <span style="color:#f92672">=</span> {
                        { vars <span style="color:#f92672">=</span> { type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;array&#34;</span>, elements <span style="color:#f92672">=</span> { 
                            type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;array&#34;</span>,
                            elements <span style="color:#f92672">=</span> { type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;string&#34;</span> }
                        } } }
                      }
                    }
                  }
                } }
              }
            }
          } },
        } }
    }
}
</code></pre></div><h3 id="102-自定义-schema-校验器">10.2. 自定义 Schema 校验器</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> expr <span style="color:#f92672">=</span> require(<span style="color:#e6db74">&#34;resty.expr.v1&#34;</span>)

<span style="color:#66d9ef">local</span> schema_validator <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(conf)
    <span style="color:#66d9ef">if</span> conf.rules <span style="color:#66d9ef">then</span>
        <span style="color:#66d9ef">for</span> _, rule <span style="color:#66d9ef">in</span> ipairs(conf.rules) <span style="color:#66d9ef">do</span>
            <span style="color:#66d9ef">if</span> rule.match <span style="color:#f92672">and</span> type(rule.match) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;table&#34;</span> <span style="color:#66d9ef">then</span>
                <span style="color:#66d9ef">for</span> _, m <span style="color:#66d9ef">in</span> pairs(rule.match) <span style="color:#66d9ef">do</span>
                    <span style="color:#66d9ef">local</span> ok, err <span style="color:#f92672">=</span> expr.new(m.vars)
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ok <span style="color:#66d9ef">then</span>
                        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#e6db74">&#34;failed to validate the &#39;vars&#39; expression: &#34;</span> <span style="color:#f92672">..</span> err
                    <span style="color:#66d9ef">end</span>
                <span style="color:#66d9ef">end</span>
            <span style="color:#66d9ef">end</span>
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><h3 id="103-日志打印-table">10.3. 日志打印 Table</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua">kong.log.inspect.on()
kong.log.debug(<span style="color:#e6db74">&#34;Lua table: &#34;</span>, t)
</code></pre></div><h3 id="104-自定义日志输出">10.4. 自定义日志输出</h3>
<p>2.3.0 版本以上可用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> entry <span style="color:#f92672">=</span> {
    entries <span style="color:#f92672">=</span> ctx.log_entries,
    id <span style="color:#f92672">=</span> self.transaction_id,
    action <span style="color:#f92672">=</span> action_name,
}

kong.log.set_serialize_value(<span style="color:#e6db74">&#34;waf&#34;</span>, entry)
</code></pre></div>
        </div>
        <!-- tags -->
        <div class="mb-3">
          <h5 class="d-inline-block mr-3">Tags:</h5>
          <ul class="list-inline d-inline-block">
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/%e7%bd%91%e5%85%b3"> 
            网关</a>
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/kong"> , 
            Kong</a>
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/%e6%ba%90%e7%a0%81%e9%98%85%e8%af%bb"> , 
            源码阅读</a>
            
          </ul>
        </div>
        <!-- previous -->
        
<div class="col-12">
<ul class="pager blog-pager">

<li class="previous">
<a href="https://cloudnative.to/blog/can-ztna-replace-vpn/" data-toggle="tooltip" data-placement="top" title="ZTNA能取代VPN吗？——三种远程访问方法对比">&larr; 上一篇</a>
</li>
 
<li class="next">
<a href="https://cloudnative.to/blog/chaos-engineering-with-kubernetes/" data-toggle="tooltip" data-placement="top" title="在 Kubernetes 实施混沌工程——Chaos Mesh 原理分析与控制面开发">下一篇 &rarr;</a>
</li>

</ul>
</div>


        <!-- previous -->

        <!-- recommend -->
        


        <!-- comments -->

        
        <div id="gitalk-container"></div>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
        <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
        <script>
          window.onload = function() {
              const gitalk = new Gitalk({
              clientID: '0f001988910adcfadfb7',
              clientSecret: '14f7d06ee5e6575c295d18fc11616e8cb60fb84e',
              repo: 'cloudnativeto.github.io',
              owner: 'cloudnativeto',
              admin: ['rootsongjc'],
              id: hex_md5(hex_md5(window.location.pathname + window.location.hash)), 
              distractionFreeMode: false 
            });
            (function() {
              if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
                document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
                return;
              }
              gitalk.render('gitalk-container');
            })();
          }
        </script>
        
      </div>
      <!-- sidebar -->
<aside class="col-lg-4 order-1 order-lg-2">
    <!-- categories -->
<div class="bg-pink px-4 py-5 box-shadow mb-5">
  <h4 class="mb-4">分类</h4>
  <ul class="list-unstyled">
    <li class="border-bottom"><a href="/categories/devops" class="d-block pb-3 mt-3 text-capitalize">Devops</a></li>
    <li class="border-bottom"><a href="/categories/envoy" class="d-block pb-3 mt-3 text-capitalize">Envoy</a></li>
    <li class="border-bottom"><a href="/categories/istio" class="d-block pb-3 mt-3 text-capitalize">Istio</a></li>
    <li class="border-bottom"><a href="/categories/kubernetes" class="d-block pb-3 mt-3 text-capitalize">Kubernetes</a></li>
    <li class="border-bottom"><a href="/categories/serverless" class="d-block pb-3 mt-3 text-capitalize">Serverless</a></li>
    <li class="border-bottom"><a href="/categories/service-mesh" class="d-block pb-3 mt-3 text-capitalize">Service mesh</a></li>
    <li class="border-bottom"><a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="d-block pb-3 mt-3 text-capitalize">云原生</a></li>
    <li class="border-bottom"><a href="/categories/%e5%85%b6%e4%bb%96" class="d-block pb-3 mt-3 text-capitalize">其他</a></li>
    <li class="border-bottom"><a href="/categories/%e5%8f%af%e8%a7%82%e5%af%9f%e6%80%a7" class="d-block pb-3 mt-3 text-capitalize">可观察性</a></li>
    <li class="border-bottom"><a href="/categories/%e5%ae%89%e5%85%a8" class="d-block pb-3 mt-3 text-capitalize">安全</a></li>
    <li class="border-bottom"><a href="/categories/%e5%bc%80%e6%ba%90" class="d-block pb-3 mt-3 text-capitalize">开源</a></li>
    <li class="border-bottom"><a href="/categories/%e5%bc%80%e6%ba%90%e7%a4%be%e5%8c%ba" class="d-block pb-3 mt-3 text-capitalize">开源社区</a></li>
    <li class="border-bottom"><a href="/categories/%e6%8c%81%e7%bb%ad%e4%ba%a4%e4%bb%98" class="d-block pb-3 mt-3 text-capitalize">持续交付</a></li>
    <li class="border-bottom"><a href="/categories/%e7%a8%b3%e5%ae%9a%e6%80%a7" class="d-block pb-3 mt-3 text-capitalize">稳定性</a></li>
    <li class="border-bottom"><a href="/categories/%e8%be%b9%e7%bc%98%e8%ae%a1%e7%ae%97" class="d-block pb-3 mt-3 text-capitalize">边缘计算</a></li>
  </ul>
</div>

  <!-- tags -->
  

  <!-- profile -->
  <div class="bg-pink px-4 py-5 box-shadow mb-5 avatar-content">
    <div class="avatar">
      <div class="mx-auto avatar-wrp">
        <img class="rounded-circle avatar-img" src="https://github.com/mayocream.png">
      </div>
      <p class="avatar-name">
        <strong class="text-dark "><a href="https://github.com/mayocream">Mayo Cream</a></strong> 
      </p>
      <p>Kubernetes Member, CNCF Security TAG Member, OSS Contributor.</p>
    </div>
  </div>
  <!-- toc -->
  
  <div class="bg-white px-4 py-5 box-shadow mb-5 sticky-top">
    <h4 class="mb-4">目录</h4>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-概述">1. 概述</a></li>
    <li><a href="#2-配置文件">2. 配置文件</a></li>
    <li><a href="#3-初始化">3. 初始化</a>
      <ul>
        <li><a href="#31-数据库初始化">3.1. 数据库初始化</a></li>
        <li><a href="#32-缓存构建">3.2. 缓存构建</a></li>
        <li><a href="#33-事件订阅">3.3. 事件订阅</a></li>
      </ul>
    </li>
    <li><a href="#4-事件分发">4. 事件分发</a>
      <ul>
        <li><a href="#41-单次任务">4.1. 单次任务</a></li>
        <li><a href="#42-定时任务">4.2. 定时任务</a></li>
      </ul>
    </li>
    <li><a href="#5-事件处理">5. 事件处理</a>
      <ul>
        <li><a href="#51-数据库事件">5.1. 数据库事件</a></li>
      </ul>
    </li>
    <li><a href="#6-插件加载">6. 插件加载</a>
      <ul>
        <li><a href="#61-插件读取">6.1. 插件读取</a></li>
        <li><a href="#62-插件调用">6.2. 插件调用</a></li>
      </ul>
    </li>
    <li><a href="#7-缓存机制">7. 缓存机制</a></li>
    <li><a href="#8-请求生命周期">8. 请求生命周期</a>
      <ul>
        <li><a href="#81-ssl_certificate_by_lua-阶段">8.1. ssl_certificate_by_lua 阶段</a></li>
        <li><a href="#82-rewrite_by_lua-阶段">8.2. rewrite_by_lua 阶段</a></li>
        <li><a href="#83-access_by_lua-阶段">8.3. access_by_lua 阶段</a></li>
        <li><a href="#84-balancer_by_lua-阶段">8.4. balancer_by_lua 阶段</a></li>
        <li><a href="#85-header_filter_by_lua-阶段">8.5. header_filter_by_lua 阶段</a></li>
        <li><a href="#86-body_filter_by_lua-阶段">8.6. body_filter_by_lua 阶段</a></li>
        <li><a href="#87-log_by_lua-阶段">8.7. log_by_lua 阶段</a></li>
      </ul>
    </li>
    <li><a href="#9-admin-api">9. Admin API</a></li>
    <li><a href="#10-插件开发">10. 插件开发</a>
      <ul>
        <li><a href="#101-多层-schema-嵌套">10.1. 多层 Schema 嵌套</a></li>
        <li><a href="#102-自定义-schema-校验器">10.2. 自定义 Schema 校验器</a></li>
        <li><a href="#103-日志打印-table">10.3. 日志打印 Table</a></li>
        <li><a href="#104-自定义日志输出">10.4. 自定义日志输出</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>

</aside>
<!-- /sidebar -->

    </div>
  </div>
</section>
<!-- /blog details -->



<footer>
  
  <div class="section bg-secondary">
    <div class="container">
      <div class="row justify-content-between">
        
        <div class="col-lg-5 mb-5 mb-lg-0">
          
          <a class="mb-4 d-inline-block" href="/"><img class="img-fluid"
              src="/images/logo-alt.png" alt="云原生社区" width="60%"></a>
          <p class="text-light mb-5">云原生社区是国内最大的独立第三方云原生终端用户和泛开发者社区，由 CNCF 大使、开源意见领袖共同发起成立于 2020 年 5 月 12 日，提供云原生专业资讯，促进云原生产业发展。</p>
          <h4 class="text-white mb-4">关注我们</h4>
          
          <ul class="list-inline social-icon-alt">
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://twitter.com/cloudnativecn"><i class="fab fa-twitter"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://github.com/cloudnativeto"><i class="fab fa-github"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://mp.weixin.qq.com/s/vWlSdzz2MNdXRr0sd2-LFg"><i class="fab fa-weixin"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="mailto:contact@cloudnative.to"><i class="far fa-envelope"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://zhuanlan.zhihu.com/cloud-native"><i class="fab fa-zhihu"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://space.bilibili.com/515485124"><i class="fas fa-play-circle"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://cloudnative.to/blog/index.xml"><i class="fas fa-rss"></i></a>
            </li>
            
          </ul>
        </div>
        <div class="col-lg-5 mb-5 mb-lg-0">
            
            
            
            
            
            <div class="mb-5 address">
              <h4 class="text-white mb-4">联系信息</h4>
              <p class="text-light mb-3"><a href="/city/beijing">北京</a>|<a href="/city/shanghai">上海</a>|<a href="/city/chengdu">成都</a>|<a href="/city/shenzhen">深圳</a>|<a href="/city/hangzhou/">杭州</a>|<a href="/city/guangzhou/">广州</a>|<a href="https://github.com/cloudnativeto/community/issues/55">武汉</a>|<a href="/city/nanjing">南京</a>|<a href="https://github.com/cloudnativeto/community/issues/61">西安</a>|<a href="/city/dalian">大连</a>|<a href="https://github.com/cloudnativeto/community/issues/52">长沙</a>|<a href="https://github.com/cloudnativeto/community/issues/66">苏州</a>|<a href="https://github.com/cloudnativeto/community/issues/67">珠海</a>|<a href="https://github.com/cloudnativeto/community/issues/78">重庆</a>|<a href="https://github.com/cloudnativeto/community/issues/82">济南</a>|<a href="https://github.com/cloudnativeto/community/issues/83">厦门</a>|<a href="https://github.com/cloudnativeto/community/issues/86">无锡</a>|<a href="https://github.com/cloudnativeto/community/issues/91">青岛</a>|<a href="https://github.com/cloudnativeto/community/issues/103">郑州</a>|<a href="https://github.com/cloudnativeto/community/issues/107">合肥</a></p>
              <p class="text-light mb-3"></p>
              <p class="text-light mb-3">关注云原生社区微信公众号，加入社区并获取最新资讯。</p>
              <p class="text-light mb-3"><img src="/images/wechat-qrcode.png" width="128px"></p>
            </div>
            
            
        </div>
      </div>
    </div>
  </div>
  
  <div class="bg-secondary-darken py-4">
    <div class="container">
      <div class="row">
        <div class="col-md-6 text-center text-md-left mb-3 mb-md-0">
          <p class="mb-0 text-white">Copyright © 2021 云原生社区</p>
        </div>
        <div class="col-md-6 text-center text-md-right">
          <ul class="list-inline">
            
            <li class="list-inline-item mx-0"><a class="d-inline-block px-3 text-white" href="/policy"
                class="text-white">声明与政策</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>




<!-- JS Plugins -->

<script src="/plugins/jQuery/jquery.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/google-map/gmap.js"></script>

<script src="/plugins/venobox/venobox.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/search/search.js"></script>

<script src="/plugins/bigPicture/bigPicture.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>


<!-- Main Script -->

<script src="/js/script.min.js"></script>

<!-- Algolia -->
<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.min.js"></script>
<script>
  docsearch({
    apiKey: '870a8addaf7a712ecc6e33ce9def93b1',
    indexName: 'DocSearch',
    appId: '2506Q6I4IV',
    inputSelector: '#js-algolia-btn',
    debug: false,
  });
</script>

<!-- baidu tongji-->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f3dc895ea3bd6186cd835841d365c103";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


<!-- google analitycs -->

<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o),
      m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
  ga('create', 'UA-93485976-4', 'auto');
  ga('send', 'pageview');
</script>


</body>

</html>
