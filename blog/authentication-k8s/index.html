<!DOCTYPE html><html lang="zh" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.5.0 for Hugo" />
  

  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="云原生社区" />

  
  
  
    
  
  <meta name="description" content="本文从边缘设备管理和云边自定义消息传递两个方面，来介绍KubeEdge的云边协同机制。" />

  
  <link rel="alternate" hreflang="zh" href="https://cloudnative.to/blog/authentication-k8s/" />

  
  
  
    <meta name="theme-color" content="#0a55a7" />
  

  
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css" media="print" onload="this.media='all'">

  
  
  
    
    

    
    
    
    
      
      
    
    
    

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      
        
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.2f500d272ea4379dca952215a5d02351.css" />

  



  


  


  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f3dc895ea3bd6186cd835841d365c103";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_hu12a4295615259de83f102fd096a49a31_6281_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hu12a4295615259de83f102fd096a49a31_6281_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://cloudnative.to/blog/authentication-k8s/" />

  
  
  
  
  
  
  
  
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary_large_image" />
  
    <meta property="twitter:site" content="@CloudNativeCN" />
    <meta property="twitter:creator" content="@CloudNativeCN" />
  
  <meta property="og:site_name" content="云原生社区（中国）" />
  <meta property="og:url" content="https://cloudnative.to/blog/authentication-k8s/" />
  <meta property="og:title" content="彻底搞懂 Kubernetes 中的认证 | 云原生社区（中国）" />
  <meta property="og:description" content="本文从边缘设备管理和云边自定义消息传递两个方面，来介绍KubeEdge的云边协同机制。" /><meta property="og:image" content="https://cloudnative.to/media/sharing.png" />
    <meta property="twitter:image" content="https://cloudnative.to/media/sharing.png" /><meta property="og:locale" content="zh" />
  
    
      <meta
        property="article:published_time"
        content="2022-09-15T12:00:00&#43;08:00"
      />
    
    <meta property="article:modified_time" content="2023-01-10T09:42:01&#43;08:00">
  

  


    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cloudnative.to/blog/authentication-k8s/"
  },
  "headline": "彻底搞懂 Kubernetes 中的认证",
  
  "datePublished": "2022-09-15T12:00:00+08:00",
  "dateModified": "2023-01-10T09:42:01+08:00",
  
  "author": {
    "@type": "Person",
    "name": "陈亦帅"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "云原生社区（中国）",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cloudnative.to/media/logo.svg"
    }
  },
  "description": "本文从边缘设备管理和云边自定义消息传递两个方面，来介绍KubeEdge的云边协同机制。"
}
</script>

  

  

  

  





  <title>彻底搞懂 Kubernetes 中的认证 | 云原生社区（中国）</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="67f835c9f938c220a458af19aa8a32e4" >
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden="true"></i></button>
  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.62d6f8dfe8493f1c68557dde65bec362.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6 search-title">
          <p>搜索</p>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="关闭"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="搜索..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="搜索...">
        
      </div>

      
      

      
    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

      <div id="search-common-queries">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    











  


<header class="header--fixed">
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区（中国）"
            
            ></a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="切换导航">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区（中国）"
          
          ></a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/community"><span>社区</span></a>
          </li>

          
          

          

          
          
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link  active" href="/blog"><span>博客</span></a>
          </li>

          
          

          
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>资料</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/envoy/"><span>Envoy 中文文档</span></a>
              
                <a class="dropdown-item" href="/kubebuilder/"><span>Kubebuilder 中文文档</span></a>
              
                <a class="dropdown-item" href="https://lib.jimmysong.io/"><span>云原生资料库</span></a>
              
                <a class="dropdown-item" href="https://istio.io/latest/zh/"><span>Istio 中文文档</span></a>
              
            </div>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/event"><span>活动</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#feed"><span>更新</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#tags"><span>标签</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#about"><span>关于</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        

        
        <li class="nav-item">
            <a class="nav-link" href="/community/join/" data-toggle="tooltip" data-placement="bottom" title="加入社区" aria-label="主站"><i class="fa-brands fa-weixin" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item">
            <a class="nav-link js-search" href="#" data-toggle="tooltip" data-placement="bottom" title="搜索" aria-label="搜索"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item d-none d-lg-inline-flex">
            <a class="nav-link" href="https://github.com/cloudnativeto/cloudnative.to" target="_blank" rel="noopener" data-toggle="tooltip" data-placement="bottom" title="查看源码" aria-label="查看源码" aria-label="GitHub"><i class="fa-brands fa-github" aria-hidden="true"></i></a>
        </li>
        

        
        
        
        <li class="nav-item">
          <a href="#" class="nav-link set-theme">
            <i class="fa fa-sun" aria-hidden="true" id="theme-icon"></i>
          </a>
        </li>
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    <div class="container-xl">
    <div class="post-container">
        












  

  
  
  
<div class="article-container pt-3">
  <h1>彻底搞懂 Kubernetes 中的认证</h1>

  

  
    


<div class="article-metadata">

  <div>
  
  
  
  
    <i class="fa-solid fa-feather"></i>
    

  <span >
      <a href="/author/%E9%99%88%E4%BA%A6%E5%B8%85/">陈亦帅</a></span>
    
    <span class="middot-divider"></span>
    
  
  
  
  
  
  
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/category/kubernetes/" class="text-capitalize">kubernetes</a></span>
  
  </div>

  
  <span class="article-date">
    
    
      
          
          发布于
      
    
    2022-09-15
  </span>
  

  

  
  <span class="middot-divider"></span>
  字数 6313
  <span class="middot-divider"></span>
  <span class="article-reading-time">
      阅读时长 29 分钟
  </span>
  

  
  
  
  

</div>

    





  
</div>


    </div>
    <div class="border-bottom mb-2"></div>
    <div class="row flex-xl-nowrap">
        <div class="col-3 d-none d-xl-block docs-toc">
            <!-- toc -->
            
<div class="">
    <ul class="nav toc-top">
        <li>
            <a href="#" id="back_to_top" class="docs-toc-title">目录</a>
        </li>
    </ul>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#k8s-api请求访问控制的过程">K8s API请求访问控制的过程</a></li>
    <li><a href="#k8s的用户模型">K8s的用户模型</a></li>
    <li><a href="#basic认证">Basic认证</a></li>
    <li><a href="#x509证书认证">X509证书认证</a></li>
    <li><a href="#service-account-token认证">Service Account token认证</a></li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
</div>

            <!-- /toc -->
            
            <div class="subscribe-module col-12 mt-1">
    <img src="/img/wechat.jpg" alt="image" title="云原生社区的微信公众号"/>
    <p class="text-center pt-1">关注「云原生社区动态」微信公众号，获取本站更新</p>
</div>

            
        </div>
        <main class="article-body col-9 container docs-content" role="main">
            <article class="article">
                <div class="article-style">
                    
                    <details class="toc-inpage d-print-none d-show-block mb-0">
  <summary class="font-weight-bold">点击查看目录</summary>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#k8s-api请求访问控制的过程">K8s API请求访问控制的过程</a></li>
    <li><a href="#k8s的用户模型">K8s的用户模型</a></li>
    <li><a href="#basic认证">Basic认证</a></li>
    <li><a href="#x509证书认证">X509证书认证</a></li>
    <li><a href="#service-account-token认证">Service Account token认证</a></li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
</details>

                    
                    <h2 id="前言">前言</h2>
<p>本文首先介绍了K8s的访问控制过程，并对K8s认证的用户模型进行讲解。最后对认证过程中的用户证书认证以及Service Account Token认证进行举例剖析。</p>
<h2 id="k8s-api请求访问控制的过程">K8s API请求访问控制的过程</h2>
<p>我们知道，不论是通过kubectl客户端还是REST请求访问K8s集群，最终都需要经过API Server来进行资源的操作，生效结果会被持久化至etcd中，etcd中的数据安全就变得十分重要。为了保证etcd的安全性，K8s只允许API Server 去访问操作etcd，此时API Server就担负起了整个etcd的安全。那么K8s是如何管控和保障API Server访问过程的安全的呢？</p>
<p>如下图1所示，整个过程可以分为4个阶段</p>
<p>















<figure  id="figure-图1-k8s-api请求访问过程">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图1 K8s API请求访问过程" srcset="
               /blog/authentication-k8s/1_hubfe8124ee1b92cd0e4130484e1055112_24777_ae69c7ac0c615578415c6430d38fd838.webp 400w,
               /blog/authentication-k8s/1_hubfe8124ee1b92cd0e4130484e1055112_24777_ac1b8faa0e776a2ea938ba260fc61d86.webp 760w,
               /blog/authentication-k8s/1_hubfe8124ee1b92cd0e4130484e1055112_24777_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/1_hubfe8124ee1b92cd0e4130484e1055112_24777_ae69c7ac0c615578415c6430d38fd838.webp"
               width="525"
               height="295"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图1 K8s API请求访问过程
    </figcaption></figure>
</p>
<p>整体过程简述：请求发起方进行K8s API请求，经过Authentication（认证）、Authorization（鉴权）、AdmissionControl（准入控制）三个阶段的校验，最后把请求转化为对K8s对象的变更操作持久化至etcd中。</p>
<p><strong>认证阶段</strong>。当请求发起方建立与API Server的安全连接后，进入请求的认证阶段（图中步骤1）。认证的方式主要有：客户端证书、密码、普通token、bootstrap token和JWT认证(主要用于Service Account)。认证模块会检查请求头或者客户端证书的内容，我们可以同时配置一种或几种方式对请求进行认证。多种认证方式会被依次执行，只要一种方式通过，请求便得到合法认证。当所有方式都未通过时，会返回401状态码并中断请求。认证解决的问题是校验访问方是否合法并识别其身份。</p>
<p><strong>鉴权阶段</strong>。K8s API访问请求必须包括请求者的用户名、请求的操作以及操作对象，该阶段就是对用户的操作合法性进行校验。如果现有策略声明用户具有完成请求操作的权限，则对请求进行授权。K8s支持ABAC模式、RBAC模式、Webhook模式等多种授权模块。同样的，当多个授权模块被配置时，请求只要满足其中任意一种授权规则便会被放行，反之，API Server会返回403状态码并终止该请求。鉴权是为了判别用户的操作权限范围。</p>
<p><strong>准入控制阶段</strong>。准入控制是请求操作被持久化到etcd之前的“拦截器”。准入控制模块由多个“准入控制器”构成，“准入控制器”就是一段自定义代码，它们能够在请求对K8s创建、修改、删除或者连接一个K8s对象时生效。官方自带了30多个准入控制器可供使用，同时支持用户扩展。准入控制器的作用往往是检查请求的规范性或者赋予一些默认信息。例如，我们在创建一个pod时，准入控制器会检查提交的信息是否符合pod资源的规范，并对请求中没有明确规定的字段，设置对应的默认值填充到请求中。与前两个阶段不同的是，只要有一个“准入校验”逻辑未通过，那么请求就会被拒绝。若请求仅仅是读取一个对象，“准入控制器”将不会生效。准入控制作用于K8s中的对象，通过校验规范和默认值的设置，能够保证系统的安全可靠。</p>
<p><strong>持久化阶段</strong>。当我们的请求通过了前面三个阶段的校验，它会被转换为一个 K8s 对象相应的变更请求，最终持久化到etcd中。</p>
<p>需要注意的是，认证授权过程只存在HTTPS形式的API中。即是说，客户端使用HTTP连接到API Server，是不会进行认证授权的。但API Server的非安全认证端口 8080 已经在v1.12中废弃了，全面使用了HTTPS。接下来让我们来详细了解下K8s的认证。</p>
<h2 id="k8s的用户模型">K8s的用户模型</h2>
<p>从图1中我们可以看出，K8s的用户主要分为两类：通过客户端进行连接的人类操作者和K8s内诸如进程、控制器等非人类操作的客户端。我们称前者为Normal Users（常规用户），后者为Service Account（服务账户）。因为K8s内没有为Normal Users定义存储对象，我们无法像操作pod一样在K8s内部管理这类用户，它们通常是由外部服务进行管理，借由证书凭证或者静态配置文件进行认证。而Service Account可由K8s API直接进行管理。</p>
<p>下表给出了其主要区别:</p>
<table>
<thead>
<tr>
<th>类目</th>
<th>Normal Users</th>
<th>Service Account</th>
</tr>
</thead>
<tbody>
<tr>
<td>针对对象</td>
<td>人类用户</td>
<td>进程</td>
</tr>
<tr>
<td>范围</td>
<td>全cluster唯一</td>
<td>namespace</td>
</tr>
<tr>
<td>设计目的</td>
<td>与企业数据库同步，在用户级别进行操作权限的控制</td>
<td>更轻量化，在任务进程级别进行管控</td>
</tr>
<tr>
<td>主要认证方法</td>
<td>Basic认证、X509证书认证</td>
<td>Service Account token认证</td>
</tr>
<tr>
<td>例子</td>
<td>我们使用kubectl操作客户端，K8s是把我们映射成kubectl所使用客户端证书中CN字段所对应的信息，而不是真正你身份证上的信息</td>
<td>Pod等通过API Server从etcd中检索和更新自身状态时，API Server对其进行身份认证，只有通过校验的pod才能获取信息</td>
</tr>
</tbody>
</table>
<p>我们可以一次性启用多种认证方式，但通常应该至少包含以下两方面：</p>
<ol>
<li>针对于Service Account的token方式；</li>
<li>至少一种用于Normal Users身份验证的其他方式。
通过认证的用户会被包含在名为system：authenticated的group中。</li>
</ol>
<h2 id="basic认证">Basic认证</h2>
<p>认证方法是管理员将password、user、uid、group信息加入到csv格式的静态文件中，并在API Server启动时使用参数&ndash;Basic-authfile={文件路径}，指定使用的凭证文件。之后，认证凭证就将一直有效，只有在重启API Server时才能修改密码。凭证文件中的数据示例如下：</p>
<pre tabindex="0"><code>password,user,uid,&#34;group1,group2,group3&#34;
</code></pre><p>其中，当一个user对应多个组，多个group之间需要用逗号分隔并且使用双引号。</p>
<p>客户端请求时，需要在头部加入Basic BASE64ENCODED(USER:PASSWORD)，服务端会校验用户名和密码。该方式使用简单，但是因为用户名和密码使用明文，用户名和密码修改必须重启服务，十分不灵活，一般只用于测试场景。</p>
<h2 id="x509证书认证">X509证书认证</h2>
<p>本文我们假设读者已经了解数字证书和 CA 的基本原理，若不了解可以先阅读下这篇文章<a href="https://www.zhaohuabing.com/post/2020-03-19-pki/" target="_blank" rel="noopener">《数字证书原理》</a>。</p>
<p>K8s中组件之间通信，证书的验证是在协议层通过TLS完成的，TLS验证分为2种：</p>
<ul>
<li>服务器单向认证：服务器端持有证书证明自己身份，用于服务端不关心客户端身份而客户端需要确认服务器身份的场景。例如火车票购票网站，我们必须保证其是官方而非恶意服务器，但网站允许任何客户端进行连接访问；</li>
<li>双向TLS认证：双方都要持有证书，并验证对方证书确认身份。一般用于服务端持有信息比较敏感，只有特定客户端才能访问的场景。例如：K8s内组件提供的接口往往包含集群内部信息，若被非法访问会影响整体安全，所以K8s内部组件之间都是双向TLS认证。</li>
</ul>
<p>双向认证的简化过程如下图2所示</p>
<p>















<figure  id="figure-图2-双向tls过程">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图2 双向TLS过程" srcset="
               /blog/authentication-k8s/2_hu0fb8997a8d2b30285500fae6fea37a06_41825_93c13a024038ef1c136267b29d6cc424.webp 400w,
               /blog/authentication-k8s/2_hu0fb8997a8d2b30285500fae6fea37a06_41825_fec882c9093e583e95bde7bfd9e8dc4c.webp 760w,
               /blog/authentication-k8s/2_hu0fb8997a8d2b30285500fae6fea37a06_41825_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/2_hu0fb8997a8d2b30285500fae6fea37a06_41825_93c13a024038ef1c136267b29d6cc424.webp"
               width="760"
               height="309"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图2 双向TLS过程
    </figcaption></figure>
</p>
<p>当两个组件进行双向TLS认证时，会涉及到下表中的相关文件：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务端证书</td>
<td>包含服务端公钥和服务端身份信息</td>
<td>通过根证书手动或者kubeadm自动生成的API Server服务端证书文件apiserver.crt</td>
</tr>
<tr>
<td>服务器私钥</td>
<td>主要用于TLS认证时进行数字签名，证明自己是服务端证书的拥有者</td>
<td>通过根证书手动或者kubeadm生成的API Server服务端私钥文件apiserver.key</td>
</tr>
<tr>
<td>客户端证书</td>
<td>包含客户端公钥和客户端身份信息</td>
<td>由同一个CA根证书签发的.crt文件</td>
</tr>
<tr>
<td>客户端私钥</td>
<td>主要用于TLS认证时进行数字签名，证明自己是客户端证书的拥有者</td>
<td>由同一个CA根证书签发的.key文件</td>
</tr>
<tr>
<td>服务端CA根证书</td>
<td>签发服务端证书的 CA 根证书</td>
<td>通过openssl等工具生成的ca.crt文件,并在服务端启动时进行指定</td>
</tr>
<tr>
<td>客户端CA根证书</td>
<td>签发客户端证书的 CA 根证书</td>
<td>通过openssl等工具生成的ca.crt文件,并在客户端启动时进行指定(一般与服务端使用一个)</td>
</tr>
</tbody>
</table>
<p>下面我们用一个例子来演示证书签发并进行客户端配置的过程, 演示的K8s环境已经存在CA根证书文件以及API Server文件，文件和目录情况如图3所示：</p>
<p>















<figure  id="figure-图3-文件和目录情况图">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图3 文件和目录情况图" srcset="
               /blog/authentication-k8s/3_hue3781dad79719ec85ec6a02f6cf3aeb7_246740_a3371881a89a5753a3dd450f4cd0d878.webp 400w,
               /blog/authentication-k8s/3_hue3781dad79719ec85ec6a02f6cf3aeb7_246740_0fb33d50af7048046693427827d56ddc.webp 760w,
               /blog/authentication-k8s/3_hue3781dad79719ec85ec6a02f6cf3aeb7_246740_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/3_hue3781dad79719ec85ec6a02f6cf3aeb7_246740_a3371881a89a5753a3dd450f4cd0d878.webp"
               width="760"
               height="56"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图3 文件和目录情况图
    </figcaption></figure>
</p>
<p>其中ca.crt是我们使用的CA根证书，apiserver.crt是我们K8s API Server的服务端证书文件，它由ca.crt根证书进行签发和配置，例子中API Server的启动参数如图4所示:</p>
<p>















<figure  id="figure-图4-api-server的启动配置">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图4 API Server的启动配置" srcset="
               /blog/authentication-k8s/4_huf8b0e0b27451f6612c835ece317b0408_1459877_a3e6f0ffe3f5e753b9a7a2ee7ee8a161.webp 400w,
               /blog/authentication-k8s/4_huf8b0e0b27451f6612c835ece317b0408_1459877_c2c66428e0ad5e13956395107f0c0daf.webp 760w,
               /blog/authentication-k8s/4_huf8b0e0b27451f6612c835ece317b0408_1459877_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/4_huf8b0e0b27451f6612c835ece317b0408_1459877_a3e6f0ffe3f5e753b9a7a2ee7ee8a161.webp"
               width="760"
               height="752"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图4 API Server的启动配置
    </figcaption></figure>
</p>
<p>红框部分信息分别指明了API Server所使用的CA根证书、服务端证书和服务端私钥的路径。签发用户证书步骤如下(以openssl工具为例):</p>
<ol>
<li>生成私钥</li>
</ol>
<p>















<figure  id="figure-图5-生成用户私钥">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图5 生成用户私钥" srcset="
               /blog/authentication-k8s/5_hu66e6f1580a4b0a8a01a3c5d187dda74a_496542_0e0750c0d4323130396230f967847e21.webp 400w,
               /blog/authentication-k8s/5_hu66e6f1580a4b0a8a01a3c5d187dda74a_496542_2cfe4625957237e896a814bc8eb91298.webp 760w,
               /blog/authentication-k8s/5_hu66e6f1580a4b0a8a01a3c5d187dda74a_496542_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/5_hu66e6f1580a4b0a8a01a3c5d187dda74a_496542_0e0750c0d4323130396230f967847e21.webp"
               width="760"
               height="122"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图5 生成用户私钥
    </figcaption></figure>
</p>
<ol start="2">
<li>使用私钥为用户生成签署请求文件</li>
</ol>
<p>















<figure  id="figure-图6-生成签署请求文件">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图6 生成签署请求文件" srcset="
               /blog/authentication-k8s/6_hua9216d3ded00945c2cd71104f5d437b5_249475_49eec9cc278e8adbbf817f4c45e64611.webp 400w,
               /blog/authentication-k8s/6_hua9216d3ded00945c2cd71104f5d437b5_249475_cea52ee404b39522914fb501c3d9734d.webp 760w,
               /blog/authentication-k8s/6_hua9216d3ded00945c2cd71104f5d437b5_249475_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/6_hua9216d3ded00945c2cd71104f5d437b5_249475_49eec9cc278e8adbbf817f4c45e64611.webp"
               width="760"
               height="57"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图6 生成签署请求文件
    </figcaption></figure>
</p>
<p>命令中指定的CN是Common Name的缩写，代表最终生成客户端证书认证通过后在K8s内被识别的用户名，O是Organization的缩写，代表被识别用户所属的组。</p>
<ol start="3">
<li>使用服务端信任的CA其签署证书</li>
</ol>
<p>















<figure  id="figure-图7-签署证书">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图7 签署证书" srcset="
               /blog/authentication-k8s/7_hu39d51431bc0094910805a656e13260b5_254109_bd6c09d2132fccd9eea56047bc105f5e.webp 400w,
               /blog/authentication-k8s/7_hu39d51431bc0094910805a656e13260b5_254109_34273aed3f7c92512fe50a16dc36d89a.webp 760w,
               /blog/authentication-k8s/7_hu39d51431bc0094910805a656e13260b5_254109_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/7_hu39d51431bc0094910805a656e13260b5_254109_bd6c09d2132fccd9eea56047bc105f5e.webp"
               width="760"
               height="90"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图7 签署证书
    </figcaption></figure>
</p>
<p>至此，一个客户端证书便签发完毕了。我们可以查看其中的内容：</p>
<p>















<figure  id="figure-图8-my-usercrt">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图8 my-user.crt" srcset="
               /blog/authentication-k8s/8_hudbee336d575ad782182e972f0f347830_661048_d5ec8663215a5161628e936236685ce1.webp 400w,
               /blog/authentication-k8s/8_hudbee336d575ad782182e972f0f347830_661048_501bbc4a12e899f2bca1fb59a427dc49.webp 760w,
               /blog/authentication-k8s/8_hudbee336d575ad782182e972f0f347830_661048_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/8_hudbee336d575ad782182e972f0f347830_661048_d5ec8663215a5161628e936236685ce1.webp"
               width="760"
               height="335"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图8 my-user.crt
    </figcaption></figure>
</p>
<p>其中CN和O的信息即来自步骤2所输入，K8s通过这两个信息确定访问用户的信息，示意图如9所示：</p>
<p>















<figure  id="figure-图9-用户信息认证示意图">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图9 用户信息认证示意图" srcset="
               /blog/authentication-k8s/9_hu1f455efa49ea7895988b97e48d1278b7_21417_8c0a1f6bae18f66305421ad96aff226e.webp 400w,
               /blog/authentication-k8s/9_hu1f455efa49ea7895988b97e48d1278b7_21417_2af929705660201f95c28e1c8c1e6800.webp 760w,
               /blog/authentication-k8s/9_hu1f455efa49ea7895988b97e48d1278b7_21417_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/9_hu1f455efa49ea7895988b97e48d1278b7_21417_8c0a1f6bae18f66305421ad96aff226e.webp"
               width="653"
               height="263"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图9 用户信息认证示意图
    </figcaption></figure>
</p>
<p>那么如何配置客户端才能使用这个证书呢？K8s的每个客户端（例如：kubectl）都有一个配置文件用来记录客户端证书验证相关信息，我们称为kubeconfig。K8s中的每个组件都有一个这样的配置文件来关联集群、用户以及证书的情况，我们以kubectl为例，来说明如何使用kubeconfig：</p>
<ol>
<li>查看当前kubectl的配置文件内容。</li>
</ol>
<p>默认情况下，kubectl命令从$HOME/.kube目录下查找一个名字叫做config的文件作为kubeconfig，我们也可以用命令<code>kubectl config view</code>来列出相关配置内容，结果如图10所示：</p>
<p>















<figure  id="figure-图10-kubectl-config-view结果图">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图10 kubectl config view结果图" srcset="
               /blog/authentication-k8s/10_huf1b919d22dcb342a96cb22ac13f59775_1098266_3a7d7d68fbff6af59049941a4a1a5cbd.webp 400w,
               /blog/authentication-k8s/10_huf1b919d22dcb342a96cb22ac13f59775_1098266_e00920a1d15394fd9d4c6e07b24e04a8.webp 760w,
               /blog/authentication-k8s/10_huf1b919d22dcb342a96cb22ac13f59775_1098266_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/10_huf1b919d22dcb342a96cb22ac13f59775_1098266_3a7d7d68fbff6af59049941a4a1a5cbd.webp"
               width="578"
               height="760"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图10 kubectl config view结果图
    </figcaption></figure>
</p>
<ul>
<li>clusters: 集群列表。包含访问 API Server的URL、认证信息、名称等；</li>
<li>contexts: kubectl 的可用上下文列表，标明了用户和集群的使用映射关系；</li>
<li>users: 用户列表，包含访问 API Server 时的客户端证书信息、私钥以及名称；</li>
<li>current-context: kubectl当前使用的上下文名称，即上下文列表中的某个特定项名称。</li>
</ul>
<p>Kubectl配置kubeconfig后与集群进行交互时的整体结构如图11所示</p>
<p>















<figure  id="figure-图11-kubectl交互整体结构图">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图11 kubectl交互整体结构图" srcset="
               /blog/authentication-k8s/11_hu5509616b3e33c28cc5b144511ab0f6c7_18737_2b9c1e87691f821adce62f8639d81c4d.webp 400w,
               /blog/authentication-k8s/11_hu5509616b3e33c28cc5b144511ab0f6c7_18737_191d1f751858c0cd2104c5b125e6cd6e.webp 760w,
               /blog/authentication-k8s/11_hu5509616b3e33c28cc5b144511ab0f6c7_18737_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/11_hu5509616b3e33c28cc5b144511ab0f6c7_18737_2b9c1e87691f821adce62f8639d81c4d.webp"
               width="721"
               height="501"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图11 kubectl交互整体结构图
    </figcaption></figure>
</p>
<ol start="2">
<li>建立用户和证书的关系</li>
</ol>
<p>















<figure  id="figure-图12-建立用户证书关系">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图12 建立用户证书关系" srcset="
               /blog/authentication-k8s/12_hu0b1d2a6e5eea00bd092ec65dd08324c4_487277_7d3b545937455c3a6125f9b840a4c030.webp 400w,
               /blog/authentication-k8s/12_hu0b1d2a6e5eea00bd092ec65dd08324c4_487277_d8ec831a1140ef50bcbaf8b48fc9c4bf.webp 760w,
               /blog/authentication-k8s/12_hu0b1d2a6e5eea00bd092ec65dd08324c4_487277_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/12_hu0b1d2a6e5eea00bd092ec65dd08324c4_487277_7d3b545937455c3a6125f9b840a4c030.webp"
               width="760"
               height="88"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图12 建立用户证书关系
    </figcaption></figure>
</p>
<p>再次使用<code>kubectl config view</code>查看配置可以发现多了一个user的配置项</p>
<p>















<figure  id="figure-图13-新增的用户配置">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图13 新增的用户配置" srcset="
               /blog/authentication-k8s/13_hue4ebf15a86d418d9afb4788e12753679_394210_cbd58d1f3c0e7ca7aea7ddb265c6eac2.webp 400w,
               /blog/authentication-k8s/13_hue4ebf15a86d418d9afb4788e12753679_394210_34838b390f116e73120b8adad6004e8e.webp 760w,
               /blog/authentication-k8s/13_hue4ebf15a86d418d9afb4788e12753679_394210_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/13_hue4ebf15a86d418d9afb4788e12753679_394210_cbd58d1f3c0e7ca7aea7ddb265c6eac2.webp"
               width="706"
               height="540"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图13 新增的用户配置
    </figcaption></figure>
</p>
<ol start="3">
<li>把集群信息和用户信息进行关联</li>
</ol>
<p>















<figure  id="figure-图14-关联集群和用户信息">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图14 关联集群和用户信息" srcset="
               /blog/authentication-k8s/14_hu38f7b8881eb51f60bf574bee04b4bb22_341144_fedb280997ec3d8a2f1319b469a40ea4.webp 400w,
               /blog/authentication-k8s/14_hu38f7b8881eb51f60bf574bee04b4bb22_341144_b838c949f91b66adcc7d5b0a4234d49c.webp 760w,
               /blog/authentication-k8s/14_hu38f7b8881eb51f60bf574bee04b4bb22_341144_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/14_hu38f7b8881eb51f60bf574bee04b4bb22_341144_fedb280997ec3d8a2f1319b469a40ea4.webp"
               width="760"
               height="172"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图14 关联集群和用户信息
    </figcaption></figure>
</p>
<p>图15演示首先由默认的context中管理员权限的证书查看pods的情况，接着切换到我们新添加的chris用户再查看default空间下pods的情况对比：</p>
<p>















<figure  id="figure-图15-上下文切换使用对比">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图15 上下文切换使用对比" srcset="
               /blog/authentication-k8s/15_huaec4a6291423eb5f89f6f5c3976c30f2_952885_35814e47068faf4b458706018d975976.webp 400w,
               /blog/authentication-k8s/15_huaec4a6291423eb5f89f6f5c3976c30f2_952885_902ccfb9b04621661f8b225ad33d0687.webp 760w,
               /blog/authentication-k8s/15_huaec4a6291423eb5f89f6f5c3976c30f2_952885_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/15_huaec4a6291423eb5f89f6f5c3976c30f2_952885_35814e47068faf4b458706018d975976.webp"
               width="760"
               height="328"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图15 上下文切换使用对比
    </figcaption></figure>
</p>
<p>我们发现，开始我们使用Kubernetes-admin99用户能够正常查询defaut下的pod信息，但切换到上下文chris@cluster99后，访问被阻止了，但是用户没有认证失败，chris用户被正确识别了。这是因为我们虽然通过了认证阶段，但是在第二阶段（鉴权阶段），我们并没有为chris用户添加相应的操作权限导致（权限控制部分我们讲解），至此对于用户的认证已经生效。</p>
<p>使用x509证书认证相对Basic认证来说显然会更安全，只要证书不泄露，便可认为是安全的。但目前却没有便捷的方案注销证书，若使用证书轮转，则需要重新办法所有证书。所以使用x509证书认证适用于Kubernetes内部组件之间认证，普通用户认证并不推荐通过证书的形式进行认证。</p>
<p>图16列出了K8s中各个主要组件证书的使用情况</p>
<p>















<figure  id="figure-图16-k8s主要组件证书使用情况">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图16 K8s主要组件证书使用情况" srcset="
               /blog/authentication-k8s/16_hu1b015a9e5097a8ec9f762e27de1b2c6b_16345_3e294c1fb02c05431d769c97b4135e0c.webp 400w,
               /blog/authentication-k8s/16_hu1b015a9e5097a8ec9f762e27de1b2c6b_16345_43dc1022746f223045874db1b7ebc25f.webp 760w,
               /blog/authentication-k8s/16_hu1b015a9e5097a8ec9f762e27de1b2c6b_16345_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/16_hu1b015a9e5097a8ec9f762e27de1b2c6b_16345_3e294c1fb02c05431d769c97b4135e0c.webp"
               width="658"
               height="391"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图16 K8s主要组件证书使用情况
    </figcaption></figure>
</p>
<p>其中kubelet即作为服务端为API Server提供主机运行情况，同时又作为客户端从API Server中获取信息所以既存在客户端证书又存在服务端证书，API Server同理，其他组件只作为客户端从API Server中获取信息，所以拥有客户端证书即可。</p>
<h2 id="service-account-token认证">Service Account token认证</h2>
<p>Service Account是K8s中唯一能够通过API自己管理的实体账号。它主要用于Pod访问API Server。每个namespace创建的时候，K8s会自动在这个namespace下面创建一个默认的Service Account和对应的secret实例，该Service Account只能访问这个namespace的资源。</p>
<p>















<figure  id="figure-图17-default空间下的service-account和其对应的secret">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图17 default空间下的Service Account和其对应的secret" srcset="
               /blog/authentication-k8s/17_hue86652601d60b95cc5c11042cbbe3885_391958_84dd149e366a902d3ddd2a05ef7cb3fe.webp 400w,
               /blog/authentication-k8s/17_hue86652601d60b95cc5c11042cbbe3885_391958_24b9532b7f05de43ab6a66314484b6b4.webp 760w,
               /blog/authentication-k8s/17_hue86652601d60b95cc5c11042cbbe3885_391958_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/17_hue86652601d60b95cc5c11042cbbe3885_391958_84dd149e366a902d3ddd2a05ef7cb3fe.webp"
               width="760"
               height="292"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图17 default空间下的Service Account和其对应的secret
    </figcaption></figure>
</p>
<p>Service Account包含了namespace、token 和 ca三部分内容，通过base64编码保存于对应的 secret 中。namespace 指定了Pod所属的namespace，ca用于生成和验证 token，token用作身份验证。三者都通过mount的方式挂载在pod文件系统的目录 /var/run/secrets/kubernetes.io/serviceaccount/下。若创建的pod未自己指定Service Account，K8s会为其绑定默认的Service Account。图18、图19和图20展示了上述内容。</p>
<p>















<figure  id="figure-图18-service-account对应secret内容">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图18 Service Account对应secret内容" srcset="
               /blog/authentication-k8s/18_huad0b2497c175de7a826016100ad82a7c_1295371_97b9d3c7cec8bdf8fb53fdb29262222e.webp 400w,
               /blog/authentication-k8s/18_huad0b2497c175de7a826016100ad82a7c_1295371_109b5e5f5245c28b7963821e6b2f1816.webp 760w,
               /blog/authentication-k8s/18_huad0b2497c175de7a826016100ad82a7c_1295371_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/18_huad0b2497c175de7a826016100ad82a7c_1295371_97b9d3c7cec8bdf8fb53fdb29262222e.webp"
               width="760"
               height="212"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图18 Service Account对应secret内容
    </figcaption></figure>
</p>
<p>















<figure  id="figure-图19-default空间下的pod绑定默认service-account">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图19 default空间下的pod绑定默认Service Account" srcset="
               /blog/authentication-k8s/19_hu69149bf896849991b14b5e9525d572ae_1391655_e773f3e8f38676c255fc03bb5ee34029.webp 400w,
               /blog/authentication-k8s/19_hu69149bf896849991b14b5e9525d572ae_1391655_9b62f3e6ad0fb24bbf70157bd3887c58.webp 760w,
               /blog/authentication-k8s/19_hu69149bf896849991b14b5e9525d572ae_1391655_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/19_hu69149bf896849991b14b5e9525d572ae_1391655_e773f3e8f38676c255fc03bb5ee34029.webp"
               width="760"
               height="523"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图19 default空间下的pod绑定默认Service Account
    </figcaption></figure>
</p>
<p>















<figure  id="figure-图20-挂载目录下的内容">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图20 挂载目录下的内容" srcset="
               /blog/authentication-k8s/20_hu409ed341600c71c004f6267688e18362_138200_e5b1406fa31486ce5f19c47d5dbd0475.webp 400w,
               /blog/authentication-k8s/20_hu409ed341600c71c004f6267688e18362_138200_999113175203063b39544dcabddaf415.webp 760w,
               /blog/authentication-k8s/20_hu409ed341600c71c004f6267688e18362_138200_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/20_hu409ed341600c71c004f6267688e18362_138200_e5b1406fa31486ce5f19c47d5dbd0475.webp"
               width="760"
               height="165"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图20 挂载目录下的内容
    </figcaption></figure>
</p>
<p>当为一个Pod指定了Service Account后，K8s会为这个Service Account生成一个JWT（JSON Web Token），并使用secret将该token加载到pod上。JWT认证机制的原理也是通过CA根证书进行签名和公私钥校验token。其中公钥和私钥分别被配置到了API Server和Controller-Manager的命令行参数中。如图21和图22所示。</p>
<p>















<figure  id="figure-图21-部分api-server启动参数">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图21 部分API Server启动参数）" srcset="
               /blog/authentication-k8s/21_hu0975a78e4f0e8f8c39a26c0ae5e5f0b7_59985_d017f0350363a026c30b45ea4a2a46a2.webp 400w,
               /blog/authentication-k8s/21_hu0975a78e4f0e8f8c39a26c0ae5e5f0b7_59985_9abb5979e26d074cc4945090621bfbc0.webp 760w,
               /blog/authentication-k8s/21_hu0975a78e4f0e8f8c39a26c0ae5e5f0b7_59985_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/21_hu0975a78e4f0e8f8c39a26c0ae5e5f0b7_59985_d017f0350363a026c30b45ea4a2a46a2.webp"
               width="749"
               height="84"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图21 部分API Server启动参数）
    </figcaption></figure>
</p>
<p>















<figure  id="figure-图22-部分controller-manager启动参数">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图22 部分Controller-Manager启动参数" srcset="
               /blog/authentication-k8s/22_hu356c7e7eceb563101040ddd2d4067b1b_57631_07530e853011c5fe02e96e4152b362dd.webp 400w,
               /blog/authentication-k8s/22_hu356c7e7eceb563101040ddd2d4067b1b_57631_9e4bf88fe9cbc82e90cfee1af64ea184.webp 760w,
               /blog/authentication-k8s/22_hu356c7e7eceb563101040ddd2d4067b1b_57631_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/22_hu356c7e7eceb563101040ddd2d4067b1b_57631_07530e853011c5fe02e96e4152b362dd.webp"
               width="760"
               height="55"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图22 部分Controller-Manager启动参数
    </figcaption></figure>
</p>
<p>之后Pod便可使用token来访问API Server了。API Server再验证对应token信息，就能知道这个token是对应Service Account，最后识别到对应Service Account的权限。图23展示了K8s使用和验证Service Account Token的过程。图片来源于文章：https://cloudnative.to/blog/k8s-certificate/#kube-apiserver-%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE</p>
<p>















<figure  id="figure-图23-service-accounttoken的使用和验证过程">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图23 Service AccountToken的使用和验证过程" srcset="
               /blog/authentication-k8s/23_hue896d8f3f666cceb652b6782801f7485_39591_2404c3a95f5532d120bafac6be7dc1fd.webp 400w,
               /blog/authentication-k8s/23_hue896d8f3f666cceb652b6782801f7485_39591_b1745334529ccdb5568b129dbdc9893f.webp 760w,
               /blog/authentication-k8s/23_hue896d8f3f666cceb652b6782801f7485_39591_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/23_hue896d8f3f666cceb652b6782801f7485_39591_2404c3a95f5532d120bafac6be7dc1fd.webp"
               width="760"
               height="462"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图23 Service AccountToken的使用和验证过程
    </figcaption></figure>
</p>
<p>与创建namespace创建defalut类似，若我们通过K8s API的方式创建Service Account，它一样会创建对应的secret。当Pod使用该Service Account的token去API Server认证，API Server一样可以识别Token对应的Service Account从而通过认证（与证书认证相同的是若没有进行授权，一样无法通过鉴权阶段）。如图24和图25所示。</p>
<p>















<figure  id="figure-图24-手动创建service-account">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图24 手动创建Service Account" srcset="
               /blog/authentication-k8s/24_hu62e735b989478ab3224825a6598a80ef_909832_74e5e93bf1a59ce2706c7431bf2c4c1c.webp 400w,
               /blog/authentication-k8s/24_hu62e735b989478ab3224825a6598a80ef_909832_1b582383ed62c0b97013f9450c2182ac.webp 760w,
               /blog/authentication-k8s/24_hu62e735b989478ab3224825a6598a80ef_909832_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/24_hu62e735b989478ab3224825a6598a80ef_909832_74e5e93bf1a59ce2706c7431bf2c4c1c.webp"
               width="760"
               height="527"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图24 手动创建Service Account
    </figcaption></figure>
</p>
<p>















<figure  id="figure-图25-查看验证创建service-account对应secret">
  <div class="d-flex justify-content-center">
    <div class="w-100" ><img alt="图25 查看验证创建Service Account对应secret" srcset="
               /blog/authentication-k8s/25_hu570d8e29b95c165452c670bcb60e2b3c_1875620_19167a605fb80bbefcbb96c236b39fb8.webp 400w,
               /blog/authentication-k8s/25_hu570d8e29b95c165452c670bcb60e2b3c_1875620_3fb0c165ec689716aeb9fab7d777983f.webp 760w,
               /blog/authentication-k8s/25_hu570d8e29b95c165452c670bcb60e2b3c_1875620_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
               src="/blog/authentication-k8s/25_hu570d8e29b95c165452c670bcb60e2b3c_1875620_19167a605fb80bbefcbb96c236b39fb8.webp"
               width="760"
               height="314"
               loading="lazy" data-zoomable /></div>
  </div><figcaption>
      图25 查看验证创建Service Account对应secret
    </figcaption></figure>
</p>
<h2 id="总结">总结</h2>
<ul>
<li>K8s的访问控制有4个阶段，其中认证阶段的主要对象为Normal Users和Service Account，单单通过认证并不能访问API Server；</li>
<li>X509证书认证是K8s中针对用户的常用认证方式，其组件间只用了双向TLS的认证方式，若客户端需要访问API Server 除了生成客户端证书同时还要配置对应的kubeconfig；</li>
<li>Service Account Token是K8s针对Service Account的主要认证方式，其认证原理是基于JWT，其中的证书只用于验证token，最后API Service对于Service Account的识别是基于传递给API Service的token；</li>
<li>Service Account主要设计用于K8s内部，Pod等进程是主要使用者，它是K8s唯一自主管理的认证标识，创建Service Account后会生成对应的secret。</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/2016079" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/2016079</a></li>
<li><a href="http://www.javashuo.com/article/p-gocttrgh-ny.html" target="_blank" rel="noopener">http://www.javashuo.com/article/p-gocttrgh-ny.html</a></li>
<li><a href="https://cloudnative.to/blog/k8s-certificate/#kube-apiserver-%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">https://cloudnative.to/blog/k8s-certificate/#kube-apiserver-%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/468010077" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/468010077</a></li>
<li><a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/access-authn-authz/authentication/</a></li>
</ul>

                </div>
                

<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/kubernetes/">kubernetes</a>
  
  <a class="badge badge-light" href="/tag/%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/">安全认证</a>
  
</div>











  
  
    



  
  
  
  
  
  <div class="media author-card content-widget-hr mb-4">
    
      
      <a href="/author/%E9%99%88%E4%BA%A6%E5%B8%85/"><img class="avatar mr-3 avatar-circle" src="/author/%E9%99%88%E4%BA%A6%E5%B8%85/avatar_hu5cac0e12d1a110c102159eb24fc6c63c_82579_270x270_fill_q75_lanczos_center.jpg" alt="陈亦帅"></a>
    

    <div class="media-body">
      <p class="card-title"><a href="/author/%E9%99%88%E4%BA%A6%E5%B8%85/">陈亦帅</a></p>
      <p class="card-subtitle">中国移动云能力中心软件研发工程师</p>
      <p class="card-text">专注于云原生、微服务、算力网络等领域。</p>
      
    </div>
  </div>


  





<div class="article-widget">
  
<div class="container-xl row post-nav">
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1" href="/blog/retrospect-service-mesh-summit/" rel="next">
    <div class="meta-nav">下一页</div>
    <p>服务网格峰会回顾：服务网格的发展趋势</p></a>
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1"  href="/blog/envoy-stateful-session-hold-mechanism-design-and-implementation/" rel="prev">
    <div class="meta-nav">上一页</div>
    <p>Envoy 有状态会话保持机制设计与实现</p></a>
  
</div>

</div>










  

<p class="edit-page">
  <a href="https://github.com/cloudnativeto/cloudnative.to/edit/master/content/blog/authentication-k8s/index.md">
    <i class="fas fa-pen pr-2"></i>编辑本页
  </a>
</p>




  
  
  <div class="article-widget content-widget-hr">
    <p class="related-title">相关推荐</p>
    <ul>
      
      <li><a href="/blog/egress-for-k8s/">是时候思考 Kubernetes 出向流量安全了</a></li>
      
      <li><a href="/blog/does-kubernetes-really-give-you-multicloud-portability/">Kubernetes 真的能提供多云可移植性吗？</a></li>
      
      <li><a href="/blog/container-insights-2022/">2022 年容器生态系统的 9 大趋势洞察</a></li>
      
      <li><a href="/blog/apiserver-handler-register/">Kubernetes API Server handler 注册过程分析</a></li>
      
      <li><a href="/blog/develop-a-csi-driver/">CSI 驱动开发指南</a></li>
      
    </ul>
  </div>
  





  
  
  

  

  
  <section id="comments" class="mb-3 pt-0">
    <script>
  let themeNumber = localStorage.getItem('wcTheme');
  var giscusTheme = "light";
  if (themeNumber == 1){
    giscusTheme = "dark";
  }
  let giscusAttributes = {
    "src": "https://giscus.app/client.js",
    "data-theme": giscusTheme,
    "data-repo":"cloudnativeto\/cloudnative.to",
    "data-repo-id":"MDEwOlJlcG9zaXRvcnkyMzc3NDUxOTA=",
    "data-category":"General",
    "data-category-id":"MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMyMDU5MzUy",
    "data-mapping":"pathname",
    "data-reactions-enabled":"",
    "data-emit-metadata":"0",
    "data-input-position":"top",
    "data-theme":giscusTheme,
    "data-lang":"zh-CN",
    "data-loading":"lazy",
    "crossorigin":"annoymous",
    "origins":"https://cloudnative.to",
    "originsRegex":"http://localhost:[0-9]+",
    "async": "",
  };

  let giscusScript = document.createElement("script");
  Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
  document.querySelector('#comments').appendChild(giscusScript);
</script>

  </section>
  



            </article>
        </main>
    </div>
</div>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">

  



  

  
  <div class="copyright py-4 bg-footer">
      <div class="row justify-content-center">
        <div class="text-center footer-color">
          <p class="mb-0">© 2020-2023 云原生社区保留所有权利</p>
        </div>
    </div>
  </div>

</footer>

    </div>
    
  </div>

  


<script src="/js/vendor-bundle.min.46271ef31da3f018e9cd1b59300aa265.js"></script>




  

  
  

  

  
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js" integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin="anonymous"></script>
    
    
  










  
  <script id="search-hit-fuse-template" type="text/x-template">
    <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <div class="article-metadata search-hit-type">{{relpermalink}}</div>
          <a href="{{relpermalink}}">{{title}}</a>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
    </div>
  </script>
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin="anonymous"></script>
  












  
  
  
  
  
  
  







<script id="page-data" type="application/json">{"use_headroom":false}</script>










  
  


<script src="/zh/js/wowchemy.min.24983018b0e5661cd5fe1822254286ea.js"></script>







<script>

var mybutton = document.getElementById("backTopBtn");


window.onscroll = function() {scrollFunction()};

function scrollFunction() {
  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    mybutton.style.display = "block";
  } else {
    mybutton.style.display = "none";
  }
}


function topFunction() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
<script>
  anchors.add();
</script>



<script>



(function() {
  'use strict';

  if(!document.queryCommandSupported('copy')) {
    return;
  }

  function flashCopyMessage(el, msg) {
    el.className = "highlight-copy-btn";
    el.textContent = msg;
    setTimeout(function() {
      el.textContent = "";
      el.className = "highlight-copy-btn fa fa-copy";
    }, 1000);
  }

  function selectText(node) {
    var selection = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
    return selection;
  }

  function addCopyButton(containerEl) {
    var copyBtn = document.createElement("button");
    copyBtn.className = "highlight-copy-btn fa fa-copy";
    copyBtn.textContent = "";

    var codeEl = containerEl.firstElementChild;
    copyBtn.addEventListener('click', function() {
      try {
        var selection = selectText(codeEl);
        document.execCommand('copy');
        selection.removeAllRanges();
        
        flashCopyMessage(copyBtn, '已复制')
        
      } catch(e) {
        console && console.log(e);
        flashCopyMessage(copyBtn, 'Failed :\'(')
      }
    });

    containerEl.appendChild(copyBtn);
  }

  
  var highlightBlocks = document.getElementsByClassName('highlight');
  Array.prototype.forEach.call(highlightBlocks, addCopyButton);
})();
</script>



<script>

function Collapse(e){
  var node = document.getElementById(e);
  if (node.className.indexOf('fa-angle-down') > -1){
    node.setAttribute("class", "fa-solid fa-angle-right");
    }else{
    node.setAttribute("class", "fa-solid fa-angle-down");
    }
}
</script>


</body>
</html>
