<!DOCTYPE html>

<html lang="zh-cn"><head>
  <meta charset="utf-8">
  
  <title>Envoy WASM 源码抽丝剥茧 | 云原生社区</title>
  

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文旨在从源码角度解析 Envoy 和 WASM 沙箱是如何桥接的。希望读者通过阅读本文，能够对 Envoy WASM 的接入有一定的了解。在实践的过程之中，能够帮助读者在繁杂的类型关系和调用链路中理清思路。本文默认读者具备一定的 Envoy 知识基础并且对 Envoy Filter 机制具备一定的了解。如果仅仅是希望使用 WASM 而不需要深入了解或者二次开发 Envoy WASM，那么可以阅读 SDK 文档即可。">
  
  <meta name="author" content=" 云原生社区">
  <meta name="generator" content="Hugo 0.65.3" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="/plugins/bootstrap/bootstrap.min.css">
  
  <link rel="stylesheet" href="/plugins/slick/slick.css">
  
  <link rel="stylesheet" href="/plugins/fontawesome/font-awesome.min.css">
  
  <link rel="stylesheet" href="/plugins/animate/animate.css">
  
  <link rel="stylesheet" href="/plugins/venobox/venobox.css">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="/scss/style.min.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="/images/favicon.png " type="image/x-icon">
  <link rel="icon" href="/images/favicon.png " type="image/x-icon">
  <meta property="og:image" content="https://cloudnative.to/images/favicon.png">
  <!--Algolia-->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.min.css">
  <!--Twitter card-->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="Cloud Native Community|云原生社区" />
  <meta name="twitter:creator" content="@CloudNativeCN" />
  <meta property="og:url" content="https://cloudnative.to/blog/envoy-wasm-source-deep-dive/" />
  <meta property="og:title" content="Envoy WASM 源码抽丝剥茧" />
  <meta property="og:description" content="本文旨在从源码角度解析 Envoy 和 WASM 沙箱是如何桥接的。希望读者通过阅读本文，能够对 Envoy WASM 的接入有一定的了解。在实践的过程之中，能够帮助读者在繁杂的类型关系和调用链路中理清思路。本文默认读者具备一定的 Envoy 知识基础并且对 Envoy Filter 机制具备一定的了解。如果仅仅是希望使用 WASM 而不需要深入了解或者二次开发 Envoy WASM，那么可以阅读 SDK 文档即可。" />
  <meta property="og:image" content="https://cloudnative.to/images/blog/envoy-wasm.jpg" />
</head>
<body>
<!-- header -->

<img src="images/logo-square.jpg" width="0" height="0" />
<div style='margin:0 auto;width:0px;height:0px;overflow:hidden;'>
     <img src="" width='700'>
</div>
<header>
  

  <!-- navigation -->
  <div class="navigation bg-white position-relative">
    <div class="container">
      <nav class="navbar navbar-expand-lg navbar-light bg-white">
        <a class="navbar-brand" href="/"><img class="img-fluid pb-lg-3" src="/images/logo.png" width="189px" alt="云原生社区"></a>
        <button class="navbar-toggler border-0" type="button" data-toggle="collapse" data-target="#navigation"
          aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navigation">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link" href="/"></a>
            </li>
            
            
            <li class="nav-item">
              <a class="nav-link" href="/blog/">博客</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="/community/sig/">兴趣小组</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="/contribute">投稿</a>
            </li>
            
            
            
            <li class="nav-item">
              <a class="nav-link" href="/job">招聘</a>
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                aria-expanded="false">
                社区
              </a>
              <div class="dropdown-menu" >
                
                <a class="dropdown-item" href="/team">管理委员会</a>
                
                <a class="dropdown-item" href="/academy/">云原生学院</a>
                
                <a class="dropdown-item" href="/city">城市站</a>
                
                <a class="dropdown-item" href="/community/">社区资料</a>
                
              </div>
            </li>
            
            
            
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true"
                aria-expanded="false">
                资料
              </a>
              <div class="dropdown-menu" >
                
                <a class="dropdown-item" href="http://landscape.opensourcecloud.cn/">云原生生态图景</a>
                
                <a class="dropdown-item" href="/kubebuilder">Kubebuilder 中文文档</a>
                
                <a class="dropdown-item" href="/envoy">Envoy 中文文档</a>
                
                <a class="dropdown-item" href="https://istio.io/latest/zh/">Istio 中文文档</a>
                
              </div>
            </li>
            
            
          </ul>

          
          

          
          <!-- search -->
          <div class="search px-4">
            <button id="searchOpen" class="search-btn"><i class="fa fa-search text-dark"></i></button>
            <div class="search-wrapper">
              <form action="/search">
                <input class="search-box form-control" id="js-algolia-btn" name="s" type="search" placeholder="输入搜索词">
              </form>
              <button id="searchClose" class="search-close"><i class="fa fa-close text-dark"></i></button>
            </div>
          </div>
          
          
          <!-- get start btn -->
          <a href="/contact" class="btn btn-primary hover-ripple">加入我们</a>
          
        </div>
      </nav>
    </div>
  </div>
  <!-- /navigation -->
</header>
<!-- /header -->

	<!-- page title -->
<section class="section bg-cover overlay" style="background-image: url('/'),url('/'),url('/images/backgrounds/page-title-5.jpg');">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <h2 class="text-white mb-3 text-capitalize">Envoy w a s m 源码抽丝剥茧</h2>
        <!-- breadcrumb -->
        
        <p class="text-white">本文旨在从源码角度解析 Envoy 和 WASM 沙箱是如何桥接的。希望读者通过阅读本文，能够对 Envoy WASM 的接入有一定的了解。在实践的过程之中，能够帮助读者在繁杂的类型关系和调用链路中理清思路。本文默认读者具备一定的 Envoy 知识基础并且对 Envoy Filter 机制具备一定的了解。如果仅仅是希望使用 WASM 而不需要深入了解或者二次开发 Envoy WASM，那么可以阅读 SDK 文档即可。</p>
      </div>
    </div>
  </div>
</section>
<!-- /page title -->

	

<!-- blog details -->
<section class="section">
  <div class="container blog">
    <div class="row">
      <div class="col-lg-8">
        <!-- post thumb -->
        <div class="position-relative mb-5">
          <img src="/"  onerror="this.src='\/images\/blog\/envoy-wasm.jpg'" alt="post thumb" class="img-fluid w-100">
           <div class="card-type"><a href="/categories/service-mesh">Service Mesh</a></div>
        </div>
        <div class="card-meta mb-2">作者  <strong class="text-dark"><a href="https://github.com/wbpcode">王佰平</a></strong>
          
            发表于 <strong class="text-dark">2020年12月23日</strong></div>
        <hr>
        <div class="content">
          <p>在 Envoy 网关和 Service Mesh 服务网格落地过程中，大部分组织和公司几乎不可避免的需要对 Envoy 做一些二次开发和功能增强，以应对自身的个性化需求，只是或多或少的问题。虽然 Envoy 本身基于 L4/L7 Filter 提供了非常灵活可扩展性，可以让开发者在各个层级对 Envoy 进行扩展。然而以现有的 Filter 开发流程太过繁琐沉重。一个简单的功能扩展都需要重新构建整个 Envoy，升级和部署也涉及到服务重启等问题。</p>
<p>为此，Envoy 社区在 Envoy 中嵌入了 WASM 虚拟机以获得一个安全的沙箱环境，用于动态加载和运行可拔插的扩展代码（被编译为 WASM 字节码），简化 Envoy 二次开发和功能增强的复杂度。实际上，在 Envoy 社区将该特性合入主干之前，Istio 社区就已经在力推该特性，并基于该特性重写了部分的功能扩展。</p>
<p>网易数帆旗下轻舟云原生团队也一直在关注社区的进展和动态。轻舟微服务在各个业务方落地的过程中，业务方的定制化需求往往难以避免，而随着业务方的不断增多，如何管理这些不断横向膨胀的定制化需求，避免它们成为轻舟微服务产品本身演进的负累是一个关键问题。而 WASM 则是一个可能的答案。此外，轻舟团队自研的类 OpenResty Lua 框架也是一个解决方案，其原理本质上也和 WASM 类似，利用 Envoy 中嵌入的 LuaJIT 来运行动态 Lua 脚本，不过这不是本文的讨论范畴。</p>
<p>说回到 WASM。WASM 本身是源自前端的技术，是为了解决日益复杂的前端 Web 应用以及有限的 JS 脚本解释性能而诞生的技术（有别于 JIT 的另一条路线）。WASM 并不是一种语言，而是字节码标准。理论上任何一种语言，都可以被编译成 WASM 字节码，然后在WASM虚拟机中执行。其原理如下图所示：</p>
<p><img src="envoy-wasm-filters.png" alt=""></p>
<p>本文旨在从源码角度解析 Envoy 和 WASM 沙箱是如何桥接的。希望读者通过阅读本文，能够对 Envoy WASM 的接入有一定的了解。在实践的过程之中，能够帮助读者在繁杂的类型关系和调用链路中理清思路。本文默认读者具备一定的 Envoy 知识基础并且对 Envoy Filter 机制具备一定的了解。如果仅仅是希望使用 WASM 而不需要深入了解或者二次开发 Envoy WASM，那么可以阅读 SDK 文档即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">commit: f6cc741026445382d5869e97cf7c9c36a44b57a9
</code></pre></div><h2 id="1-从-envoy-开始">1. 从 Envoy 开始</h2>
<p>Envoy 支持使用使用 WASM 来扩展七层 HTTP Filter 或者四层 Network Filter。但是无论是七层 HTTP Filter 还是四层 Network Filter，其本质都是类似的。Envoy 内置了一个原生 C++ HTTP Filter 和一个原生 C++ Network Filter 用于封装 WASM API，管理 WASM Sandbox，载入 WASM 字节码并且对 Envoy 暴露标准的 HTTP Filter 和 Network Filter 接口。它们是 WASM 字节码管理者，也是 WASM 沙箱和 Envoy 主干交互的桥梁。</p>
<p>此处使用接口相对更加复杂的 HTTP Filter 作为示例来作为源码阅读的起点。（在具体的实践当中，一个功能完备的 Network Filter 往往会比 HTTP Filter 复杂不少，但是这种复杂性主要在 Filter 实现内部。就暴露的接口来说，反而是 HTTP Filter 具备更多的接口和相对复杂的处理。）</p>
<p>一般来说，对于一个普通的 C++ HTTP Filter，在配置的初始化阶段，Envoy 会完成 Proto 配置（通过静态文件或者 xDS 协议获取）的加载和初始化。<strong>而在请求阶段，对于每个 HTTP 请求，Envoy 会根据 HCM（HTTP Connection Manager，用于处理 HTTP 协议的四层 Network Filter） 的配置创建一个 HTTP Filter 链。并且将每个 HTTP Filter 的配置注入到对应的 Filter 实例中。</strong></p>
<p>所以了解 WASM 扩展的第一步，就是看 Envoy 是如何创建一个 HTTP WASM Filter 的。前面提到过，WASM 扩展会经过内置 C++ 插件的包装，所以在 Envoy 主体看来，创建 WASM 扩展的过程其实就是创建一个普通的 C++ Filter 的过程，只不过该 Filter 使用 WASM 字节码作为它的输入配置（本质上就是 Lua Filter 和 Lua 脚本的关系）。</p>
<p>其源码如下所示。<code>createFilterFactoryFromProtoTyped</code> 只会在配置初始化阶段执行一次。之后，每当请求到来，其返回的闭包函数就会被执行，用于创建 WASM HTTP Filter 实例来请求处理。</p>
<p>从代码不难看出 <code>FilterConfig</code> 是一个关键类型。因为最终的 Filter 实例是调用 <code>FilterConfig</code> 的 <code>createFilter</code> 接口创建出来的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// source/extensions/filters/http/wasm/config.cc
</span><span style="color:#75715e"></span>
Http<span style="color:#f92672">::</span>FilterFactoryCb WasmFilterConfig<span style="color:#f92672">::</span>createFilterFactoryFromProtoTyped(
    <span style="color:#66d9ef">const</span> envoy<span style="color:#f92672">::</span>extensions<span style="color:#f92672">::</span>filters<span style="color:#f92672">::</span>http<span style="color:#f92672">::</span>wasm<span style="color:#f92672">::</span>v3<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">&amp;</span> proto_config, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span>,
    Server<span style="color:#f92672">::</span>Configuration<span style="color:#f92672">::</span>FactoryContext<span style="color:#f92672">&amp;</span> context) {
  <span style="color:#75715e">// 根据 Proto 配置初始化 filter_config
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> filter_config <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>FilterConfig<span style="color:#f92672">&gt;</span>(proto_config, context);
  <span style="color:#66d9ef">return</span> [filter_config](Http<span style="color:#f92672">::</span>FilterChainFactoryCallbacks<span style="color:#f92672">&amp;</span> callbacks) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span> {
    <span style="color:#75715e">// 创建 WASM HTTP Filter 实例
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> filter <span style="color:#f92672">=</span> filter_config<span style="color:#f92672">-&gt;</span>createFilter();
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>filter) { <span style="color:#75715e">// Fail open
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span>;
    }
    callbacks.addStreamFilter(filter);
    callbacks.addAccessLogHandler(filter);
  };
}
</code></pre></div><p><strong>小结：Envoy 通过一个内置的七层 HTTP Filter 和一个内置的四层 Network Filter 充当包装器，管理 WASM runtime 并与 WASM Sandbox 交互以实现 HTTP Filter 或者 Network Filter 的相关功能。</strong></p>
<h2 id="2-创建一个沙箱">2. 创建一个沙箱</h2>
<p><code>FilterConfig</code> 只提供了一个 <code>createFilter</code> 接口。其核心的内容都在构造函数当中。其构造函数源码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// source/extensions/filters/http/wasm/wasm_filter.cc
</span><span style="color:#75715e"></span>
FilterConfig<span style="color:#f92672">::</span>FilterConfig(<span style="color:#66d9ef">const</span> envoy<span style="color:#f92672">::</span>extensions<span style="color:#f92672">::</span>filters<span style="color:#f92672">::</span>http<span style="color:#f92672">::</span>wasm<span style="color:#f92672">::</span>v3<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">&amp;</span> config,
                           Server<span style="color:#f92672">::</span>Configuration<span style="color:#f92672">::</span>FactoryContext<span style="color:#f92672">&amp;</span> context)
    <span style="color:#f92672">:</span> tls_slot_(
          ThreadLocal<span style="color:#f92672">::</span>TypedSlot<span style="color:#f92672">&lt;</span>Common<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">::</span>PluginHandle<span style="color:#f92672">&gt;::</span>makeUnique(context.threadLocal())) {
  plugin_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>Common<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">::</span>Plugin<span style="color:#f92672">&gt;</span>(
      config.config().name(), config.config().root_id(), config.config().vm_config().vm_id(),
      config.config().vm_config().runtime(),
      Common<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">::</span>anyToBytes(config.config().configuration()), config.config().fail_open(),
      context.direction(), context.localInfo(), <span style="color:#f92672">&amp;</span>context.listenerMetadata());

  <span style="color:#66d9ef">auto</span> plugin <span style="color:#f92672">=</span> plugin_;<span style="color:#960050;background-color:#1e0010">、</span>
  <span style="color:#75715e">// 回调函数，当成功创建 WASM 虚拟机之后执行，用于在每个 Worker 线程之中都拷贝创建一个 WASM 虚拟机
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> callback <span style="color:#f92672">=</span> [plugin, <span style="color:#66d9ef">this</span>](<span style="color:#66d9ef">const</span> Common<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">::</span>WasmHandleSharedPtr<span style="color:#f92672">&amp;</span> base_wasm) {
    <span style="color:#75715e">// NB: the Slot set() call doesn&#39;t complete inline, so all arguments must outlive this call.
</span><span style="color:#75715e"></span>    tls_slot_<span style="color:#f92672">-&gt;</span>set([base_wasm, plugin](Event<span style="color:#f92672">::</span>Dispatcher<span style="color:#f92672">&amp;</span> dispatcher) {
      <span style="color:#66d9ef">return</span> Common<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">::</span>getOrCreateThreadLocalPlugin(base_wasm, plugin, dispatcher);
    });
  };
	<span style="color:#75715e">// 根据配置创建 WASM 虚拟机
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>Common<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">::</span>createWasm(
          config.config().vm_config(), plugin_, context.scope().createScope(<span style="color:#e6db74">&#34;&#34;</span>),
          context.clusterManager(), context.initManager(), context.dispatcher(), context.api(),
          context.lifecycleNotifier(), remote_data_provider_, std<span style="color:#f92672">::</span>move(callback))) {
    <span style="color:#66d9ef">throw</span> Common<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">::</span>WasmException(
        fmt<span style="color:#f92672">::</span>format(<span style="color:#e6db74">&#34;Unable to create Wasm HTTP filter {}&#34;</span>, plugin<span style="color:#f92672">-&gt;</span>name_));
  }
}
</code></pre></div><p><code>Common::Wasm::Plugin</code> 此处略去对它的介绍。读者只需要知道它是对 <strong>WASM 字节码、字节码插件本身配置</strong>以及一些 Filter 状态的封装和集合即可。</p>
<p>在 <code>FilterConfig</code> 的构造函数当中，有一个关键函数，<code>Common::Wasm::createWasm</code>。它用于创建一个 WASM 虚拟机。该函数相对复杂，故而此处只粘贴出关键内容。其主要工作如下：</p>
<ul>
<li>根据配置中 WASM 字节码位置（本地或者远程），读取字节码</li>
<li>创建 WASM 虚拟机</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// source/extensions/common/wasm/wasm.cc
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">createWasmInternal</span>(<span style="color:#66d9ef">const</span> VmConfig<span style="color:#f92672">&amp;</span> vm_config, <span style="color:#66d9ef">const</span> PluginSharedPtr<span style="color:#f92672">&amp;</span> plugin,
                               <span style="color:#66d9ef">const</span> Stats<span style="color:#f92672">::</span>ScopeSharedPtr<span style="color:#f92672">&amp;</span> scope,
                               Upstream<span style="color:#f92672">::</span>ClusterManager<span style="color:#f92672">&amp;</span> cluster_manager,
                               Init<span style="color:#f92672">::</span>Manager<span style="color:#f92672">&amp;</span> init_manager, Event<span style="color:#f92672">::</span>Dispatcher<span style="color:#f92672">&amp;</span> dispatcher,
                               Api<span style="color:#f92672">::</span>Api<span style="color:#f92672">&amp;</span> api, Server<span style="color:#f92672">::</span>ServerLifecycleNotifier<span style="color:#f92672">&amp;</span> lifecycle_notifier,
                               Config<span style="color:#f92672">::</span>DataSource<span style="color:#f92672">::</span>RemoteAsyncDataProviderPtr<span style="color:#f92672">&amp;</span> remote_data_provider,
                               CreateWasmCallback<span style="color:#f92672">&amp;&amp;</span> cb,
                               CreateContextFn create_root_context_for_testing <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>) {
  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// 该闭包函数接受字节码 code 为参数，并捕获了相关的配置以及关键上下文
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> complete_cb <span style="color:#f92672">=</span> [cb, vm_config, plugin, scope, <span style="color:#f92672">&amp;</span>cluster_manager, <span style="color:#f92672">&amp;</span>dispatcher,
                      <span style="color:#f92672">&amp;</span>lifecycle_notifier, create_root_context_for_testing,
                      wasm_extension](std<span style="color:#f92672">::</span>string code) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> {
    <span style="color:#66d9ef">if</span> (code.empty()) {
      cb(<span style="color:#66d9ef">nullptr</span>);
      <span style="color:#66d9ef">return</span> false;
    }
    <span style="color:#75715e">// proxy_wasm 是一个关键外部依赖，是对 WASM 虚拟机环境的封装
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> vm_key <span style="color:#f92672">=</span>
        proxy_wasm<span style="color:#f92672">::</span>makeVmKey(vm_config.vm_id(), anyToBytes(vm_config.configuration()), code);
    <span style="color:#66d9ef">auto</span> wasm_factory <span style="color:#f92672">=</span> wasm_extension<span style="color:#f92672">-&gt;</span>wasmFactory();
    proxy_wasm<span style="color:#f92672">::</span>WasmHandleFactory proxy_wasm_factory <span style="color:#f92672">=</span>
        [<span style="color:#f92672">&amp;</span>vm_config, scope, <span style="color:#f92672">&amp;</span>cluster_manager, <span style="color:#f92672">&amp;</span>dispatcher, <span style="color:#f92672">&amp;</span>lifecycle_notifier,
         wasm_factory](absl<span style="color:#f92672">::</span>string_view vm_key) <span style="color:#f92672">-&gt;</span> WasmHandleBaseSharedPtr {
      <span style="color:#66d9ef">return</span> wasm_factory(vm_config, scope, cluster_manager, dispatcher, lifecycle_notifier,
                          vm_key);
    };
    <span style="color:#75715e">// 调用 proxy_wasm 中 createWasm 函数创建 WASM 沙箱
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> wasm <span style="color:#f92672">=</span> proxy_wasm<span style="color:#f92672">::</span>createWasm(
        vm_key, code, plugin, proxy_wasm_factory,
        getCloneFactory(wasm_extension, dispatcher, create_root_context_for_testing),
        vm_config.allow_precompiled());
    Stats<span style="color:#f92672">::</span>ScopeSharedPtr create_wasm_stats_scope <span style="color:#f92672">=</span>
        wasm_extension<span style="color:#f92672">-&gt;</span>lockAndCreateStats(scope, plugin);
    wasm_extension<span style="color:#f92672">-&gt;</span>onEvent(toWasmEvent(wasm), plugin);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>wasm <span style="color:#f92672">||</span> wasm<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>isFailed()) {
      ENVOY_LOG_TO_LOGGER(Envoy<span style="color:#f92672">::</span>Logger<span style="color:#f92672">::</span>Registry<span style="color:#f92672">::</span>getLog(Envoy<span style="color:#f92672">::</span>Logger<span style="color:#f92672">::</span>Id<span style="color:#f92672">::</span>wasm), trace,
                          <span style="color:#e6db74">&#34;Unable to create Wasm&#34;</span>);
      cb(<span style="color:#66d9ef">nullptr</span>);
      <span style="color:#66d9ef">return</span> false;
    }
    <span style="color:#75715e">// 执行 FilterConfig 中的回调函数，在各个 Worker 中创建 WASM 沙箱
</span><span style="color:#75715e"></span>    cb(std<span style="color:#f92672">::</span>static_pointer_cast<span style="color:#f92672">&lt;</span>WasmHandle<span style="color:#f92672">&gt;</span>(wasm));
    <span style="color:#66d9ef">return</span> true;
  };

  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>}
</code></pre></div><p>此处出现了一个全新的名称空间，<code>proxy_wasm</code>。<code>prxoy_wasm</code> 由一个关键的外部依赖提供，由 Envoy 社区和 Istio 社区等共同维护。它包含了对 WASM 虚拟机的封装。</p>
<p>其工程路径为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">[https:<span style="color:#75715e">//github.com/proxy-wasm/proxy-wasm-cpp-host](https://github.com/proxy-wasm/proxy-wasm-cpp-host)
</span><span style="color:#75715e"></span>commit: cce535101c3b1cab61fb6bf83a61b0e9834bd957
</code></pre></div><p><strong>小结：FilterConfig 是 Envoy HTTP WASM Filter 机制的核心。它会在构造过程中根据配置以及字节码创建 WASM Sandbox。而 WASM Sandbox 创建需要外部依赖 proxy_wasm 的介入。</strong></p>
<h2 id="3-创建一个沙箱-续">3. 创建一个沙箱-续</h2>
<p>从前文的代码不难发现，WASM 沙箱的创建需要 <code>proxy_wasm</code> 的介入。 现在开始进入 <code>proxy_wasm</code> 的世界。在前文源码中，主要包含 <code>proxy_wasm</code> 中两个函数。其中 <code>proxy_wasm::makeVmKey</code> 相对简单，主要作用是根据 WASM 字节码、WASM 沙箱配置（是沙箱本身配置而非运行在沙箱中的字节码插件配置）计算出一个 WASM 虚拟机 ID。该 ID 将唯一标识同一线程中的一个沙箱。</p>
<p>关键是第二个函数 <code>proxy_wasm::createWasm</code>。其中有四个重要的参数：</p>
<ul>
<li>vm_key：沙箱唯一标识</li>
<li>code：字节码</li>
<li>plugin：FilterConfig 构造函数中创建的 <code>Common::Wasm::Plugin</code> 对象实例</li>
<li>proxy_wasm_factory：创建 WASM 虚拟机环境的工厂闭包函数</li>
</ul>
<p>接下来，看看 <code>proxy_wasm::createWasm</code> 函数的源码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>WasmHandleBase<span style="color:#f92672">&gt;</span> createWasm(std<span style="color:#f92672">::</span>string vm_key, std<span style="color:#f92672">::</span>string code,
                                           std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>PluginBase<span style="color:#f92672">&gt;</span> plugin,
                                           WasmHandleFactory factory,
                                           WasmHandleCloneFactory clone_factory,
                                           <span style="color:#66d9ef">bool</span> allow_precompiled) {
  std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>WasmHandleBase<span style="color:#f92672">&gt;</span> wasm_handle;
  {
    std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> guard(base_wasms_mutex);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>base_wasms) {
      base_wasms <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> std<span style="color:#f92672">::</span>remove_reference<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(<span style="color:#f92672">*</span>base_wasms)<span style="color:#f92672">&gt;::</span>type;
    }
    <span style="color:#75715e">// base_wasms 管理 vm_key 到已有 WASM 虚拟机的映射。如果 vm_key 已经存在一个对应的 WASM 虚拟机
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 则可以直接复用。否者就调用传入的工厂闭包函数创建一个新的虚拟机。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> base_wasms<span style="color:#f92672">-&gt;</span>find(vm_key);
    <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> base_wasms<span style="color:#f92672">-&gt;</span>end()) {
      wasm_handle <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second.lock();
      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>wasm_handle) {
        base_wasms<span style="color:#f92672">-&gt;</span>erase(it);
      }
    }
    <span style="color:#66d9ef">if</span> (wasm_handle) {
      <span style="color:#66d9ef">return</span> wasm_handle;
    }
    wasm_handle <span style="color:#f92672">=</span> factory(vm_key);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>wasm_handle) {
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
    }
    (<span style="color:#f92672">*</span>base_wasms)[vm_key] <span style="color:#f92672">=</span> wasm_handle;
  }

  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>wasm_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>initialize(code, allow_precompiled)) {
    wasm_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>fail(FailState<span style="color:#f92672">::</span>UnableToInitializeCode, <span style="color:#e6db74">&#34;Failed to initialize Wasm code&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
  }
  <span style="color:#66d9ef">auto</span> configuration_canary_handle <span style="color:#f92672">=</span> clone_factory(wasm_handle);
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>configuration_canary_handle) {
    wasm_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>fail(FailState<span style="color:#f92672">::</span>UnableToCloneVM, <span style="color:#e6db74">&#34;Failed to clone Base Wasm&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
  }
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>configuration_canary_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>initialize(code, allow_precompiled)) {
    wasm_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>fail(FailState<span style="color:#f92672">::</span>UnableToInitializeCode, <span style="color:#e6db74">&#34;Failed to initialize Wasm code&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
  }
  <span style="color:#66d9ef">auto</span> root_context <span style="color:#f92672">=</span> configuration_canary_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>start(plugin);
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>root_context) {
    configuration_canary_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>fail(FailState<span style="color:#f92672">::</span>StartFailed, <span style="color:#e6db74">&#34;Failed to start base Wasm&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
  }
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>configuration_canary_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>configure(root_context, plugin)) {
    configuration_canary_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>fail(FailState<span style="color:#f92672">::</span>ConfigureFailed,
                                              <span style="color:#e6db74">&#34;Failed to configure base Wasm plugin&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
  }
  configuration_canary_handle<span style="color:#f92672">-&gt;</span>kill();
  <span style="color:#66d9ef">return</span> wasm_handle;
};
</code></pre></div><hr>
<p>可以从源码中看到，在 Envoy 主干函数代码中传入的工厂闭包函数在此（可能）会被调用，用于创建一个 WASM 虚拟机环境。</p>
<p>所以，此处需要回到 Envoy 中查看其该闭包工厂函数是如何实现的。经过几次请求的转发，该工厂函数最终会创建一个 <code>Wasm::Wasm</code> 实例，并封装在一个  <code>WasmHandle</code> 实例中（继承自 <code>proxy_wasm::WasmHandleBase</code>）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// source/extensions/common/wasm/wasm_extension.cc
</span><span style="color:#75715e"></span>
WasmHandleExtensionFactory EnvoyWasm<span style="color:#f92672">::</span>wasmFactory() {
  <span style="color:#66d9ef">return</span> [](<span style="color:#66d9ef">const</span> VmConfig vm_config, <span style="color:#66d9ef">const</span> Stats<span style="color:#f92672">::</span>ScopeSharedPtr<span style="color:#f92672">&amp;</span> scope,
            Upstream<span style="color:#f92672">::</span>ClusterManager<span style="color:#f92672">&amp;</span> cluster_manager, Event<span style="color:#f92672">::</span>Dispatcher<span style="color:#f92672">&amp;</span> dispatcher,
            Server<span style="color:#f92672">::</span>ServerLifecycleNotifier<span style="color:#f92672">&amp;</span> lifecycle_notifier,
            absl<span style="color:#f92672">::</span>string_view vm_key) <span style="color:#f92672">-&gt;</span> WasmHandleBaseSharedPtr {
    <span style="color:#66d9ef">auto</span> wasm <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>Wasm<span style="color:#f92672">&gt;</span>(vm_config.runtime(), vm_config.vm_id(),
                                       anyToBytes(vm_config.configuration()), vm_key, scope,
                                       cluster_manager, dispatcher);
    wasm<span style="color:#f92672">-&gt;</span>initializeLifecycle(lifecycle_notifier);
    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>static_pointer_cast<span style="color:#f92672">&lt;</span>WasmHandleBase<span style="color:#f92672">&gt;</span>(std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>WasmHandle<span style="color:#f92672">&gt;</span>(std<span style="color:#f92672">::</span>move(wasm)));
  };
}
</code></pre></div><p>而 <code>Wasm::Wasm</code> 则继承了 <code>proxy_wasm::WasmBase</code>。<code>proxy_wasm::WasmBase</code> 是对 <code>proxy_wasm</code> 中管理 WASM 虚拟机以及Envoy 和 Sandbox 交互 API 的的一个基础类型：（不得不吐槽一句，封装的真的好好好好复杂，此处的绕了一层一层又一层）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// source/extensions/common/wasm/wasm.cc
</span><span style="color:#75715e"></span>
Wasm<span style="color:#f92672">::</span>Wasm(absl<span style="color:#f92672">::</span>string_view runtime, absl<span style="color:#f92672">::</span>string_view vm_id, absl<span style="color:#f92672">::</span>string_view vm_configuration,
           absl<span style="color:#f92672">::</span>string_view vm_key, <span style="color:#66d9ef">const</span> Stats<span style="color:#f92672">::</span>ScopeSharedPtr<span style="color:#f92672">&amp;</span> scope,
           Upstream<span style="color:#f92672">::</span>ClusterManager<span style="color:#f92672">&amp;</span> cluster_manager, Event<span style="color:#f92672">::</span>Dispatcher<span style="color:#f92672">&amp;</span> dispatcher)
    <span style="color:#f92672">:</span> WasmBase(createWasmVm(runtime, scope), vm_id, vm_configuration, vm_key), scope_(scope),
      cluster_manager_(cluster_manager), dispatcher_(dispatcher),
      time_source_(dispatcher.timeSource()),
      wasm_stats_(WasmStats{
          ALL_WASM_STATS(POOL_COUNTER_PREFIX(<span style="color:#f92672">*</span>scope_, absl<span style="color:#f92672">::</span>StrCat(<span style="color:#e6db74">&#34;wasm.&#34;</span>, runtime, <span style="color:#e6db74">&#34;.&#34;</span>)),
                         POOL_GAUGE_PREFIX(<span style="color:#f92672">*</span>scope_, absl<span style="color:#f92672">::</span>StrCat(<span style="color:#e6db74">&#34;wasm.&#34;</span>, runtime, <span style="color:#e6db74">&#34;.&#34;</span>)))}) {
  initializeStats();
  ENVOY_LOG(debug, <span style="color:#e6db74">&#34;Base Wasm created {} now active&#34;</span>, active_wasms);
}
</code></pre></div><p>此处的关键是 createWasmVm 函数。该函数会根据 runtime 类型创建某一种的 WASM 运行时环境。目前支持：null、v8、wasmtime、wavm 四种不同的 runtime。你可以在以下目录找到它们的相关工厂类：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// source/extensions/wasm_runtime
</span></code></pre></div><p>Envoy 中封装的工厂类本质上又仅仅是对 <code>proxy_wasm</code> 中对应 runtime 的函数的封装，以 V8 为例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// source/extensions/wasm_runtime/v8/config.cc
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">V8RuntimeFactory</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> WasmRuntimeFactory {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  WasmVmPtr createWasmVm() <span style="color:#66d9ef">override</span> { <span style="color:#66d9ef">return</span> proxy_wasm<span style="color:#f92672">::</span>createV8Vm(); }
  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>};
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// proxy_wasm src/v8/v8.cc
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// proxy_wasm::WasmVm
</span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>WasmVm<span style="color:#f92672">&gt;</span> createV8Vm() { <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>V8<span style="color:#f92672">&gt;</span>(); }
</code></pre></div><p>其中 <code>proxy_wasm::WasmVm</code> 类型是对各种不同 WASM runtime 的一个统一封装。</p>
<hr>
<p>小结：<strong>在配置初始化阶段，Envoy 会创建 WASM 虚拟机运行环境，最终调用 <code>proxy_wasm::createWasm</code> 函数。 <code>proxy_wasm::createWasm</code> 最终会反向调用 Envoy 中一个工厂函数用于创建 <code>Wasm::Wasm</code> 实例以及包装该实例的 <code>WasmHandle</code> 实例（<code>proxy::WasmHandleBase</code>）。</strong></p>
<p><strong>该过程中涉及到的相关类型以及关系则是：<code>Wasm::Wasm</code> 是 Envoy 中对 WASM runtime 的抽象和封装，它直接继承自 <code>proxy_wasm::WasmBase</code>。<code>proxy_wasm::WasmBase</code> 会组合（包含）一个 WASM 虚拟机实例 <code>proxy_wasm::WasmVm</code>，同时负责沙箱的 API 暴露（后文详述）。而 <code>proxy_wasm::WasmVm</code> 则封装了 V8/WAVM 等 WASM runtime 的一些通用功能。</strong></p>
<h2 id="4-沙箱初始化">4. 沙箱初始化</h2>
<p>现在回到 <code>proxy_wasm::createWasm</code> 函数。在创建 <code>Wasm::Wasm</code> 实例（在 proxy_wasm 中也即是 <code>proxy_wasm::WasmBase</code> 实例）之后，会调用其 <code>initialize</code> 方法。该方法会向其管理的内部 WASM 沙箱注册相关的接口函数，同时也会把 WASM 沙箱暴露的函数绑定到 <code>proxy_wasm::WasmBase</code> 实例中。</p>
<p><code>initialize</code> 方法是整个过程中最为核心的内容。也是 Envoy 与 WASM 沙箱实现交互的关键。注意到，<code>proxy_wasm::WasmBase</code> 实例包含的沙箱 runtime 根据配置的不同也可能会有不同，所以此处仍旧以 V8 runtime 为例。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> WasmBase<span style="color:#f92672">::</span>initialize(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;</span>code, <span style="color:#66d9ef">bool</span> allow_precompiled) {
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>wasm_vm_) {
    <span style="color:#66d9ef">return</span> false;
  }

  <span style="color:#66d9ef">if</span> (started_from_ <span style="color:#f92672">==</span> Cloneable<span style="color:#f92672">::</span>NotCloneable) {
    <span style="color:#75715e">// 载入字节码至虚拟机之中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> ok <span style="color:#f92672">=</span> wasm_vm_<span style="color:#f92672">-&gt;</span>load(code, allow_precompiled);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ok) {
      fail(FailState<span style="color:#f92672">::</span>UnableToInitializeCode, <span style="color:#e6db74">&#34;Failed to load Wasm code&#34;</span>);
      <span style="color:#66d9ef">return</span> false;
    }
    code_ <span style="color:#f92672">=</span> code;
    allow_precompiled_ <span style="color:#f92672">=</span> allow_precompiled;
  }

  abi_version_ <span style="color:#f92672">=</span> wasm_vm_<span style="color:#f92672">-&gt;</span>getAbiVersion();
  <span style="color:#66d9ef">if</span> (abi_version_ <span style="color:#f92672">==</span> AbiVersion<span style="color:#f92672">::</span>Unknown) {
    fail(FailState<span style="color:#f92672">::</span>UnableToInitializeCode, <span style="color:#e6db74">&#34;Missing or unknown Proxy-Wasm ABI version&#34;</span>);
    <span style="color:#66d9ef">return</span> false;
  }

  <span style="color:#66d9ef">if</span> (started_from_ <span style="color:#f92672">!=</span> Cloneable<span style="color:#f92672">::</span>InstantiatedModule) {
		<span style="color:#75715e">// 向 WASM runtime 注册 API
</span><span style="color:#75715e"></span>    registerCallbacks();
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>wasm_vm_<span style="color:#f92672">-&gt;</span>link(vm_id_)) {
      <span style="color:#66d9ef">return</span> false;
    }
  }

  vm_context_.reset(createVmContext());
  <span style="color:#75715e">// 获取 WASM runtime 对外暴露 API
</span><span style="color:#75715e"></span>  getFunctions();

  <span style="color:#66d9ef">if</span> (started_from_ <span style="color:#f92672">!=</span> Cloneable<span style="color:#f92672">::</span>InstantiatedModule) {
    <span style="color:#75715e">// Base VM was already started, so don&#39;t try to start cloned VMs again.
</span><span style="color:#75715e"></span>    startVm(vm_context_.get());
  }

  <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>isFailed();
}
</code></pre></div><p>其中需要关注的有三个函数（Envoy WASM 已经相当复杂了，所以切忌过多的关注细节，不然会陷入到无穷的细节之中，耗时长久，反而一无所获）：</p>
<ul>
<li>registerCallbacks</li>
<li>link（<code>proxy_wasm::WasmVm</code>）</li>
<li>getFunctions</li>
</ul>
<p><code>registerCallbacks</code> 会向 WASM runtime 注册相关的 API，由于 API 数量很多，所以此处同样省去大部分代码，只截取部分：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// proxy_wasm src/wasm.cc
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> WasmBase<span style="color:#f92672">::</span>registerCallbacks() {
  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// Calls with the &#34;proxy_&#34; prefix.
</span><span style="color:#75715e"></span><span style="color:#75715e">#define _REGISTER_PROXY(_fn)                                                                       \
</span><span style="color:#75715e">  wasm_vm_-&gt;registerCallback(                                                                      \
</span><span style="color:#75715e">      &#34;env&#34;, &#34;proxy_&#34; #_fn, &amp;exports::_fn,                                                         \
</span><span style="color:#75715e">      &amp;ConvertFunctionWordToUint32&lt;decltype(exports::_fn),                                         \
</span><span style="color:#75715e">                                   exports::_fn&gt;::convertFunctionWordToUint32);
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>
  _REGISTER_PROXY(get_header_map_value);
  _REGISTER_PROXY(add_header_map_value);
  _REGISTER_PROXY(replace_header_map_value);
  _REGISTER_PROXY(remove_header_map_value);

  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span><span style="color:#75715e">#undef _REGISTER_PROXY
</span><span style="color:#75715e"></span>}
</code></pre></div><p>由上述的代码可知，<code>registerCallbacks</code> 会将 <code>proxy_wasm::exports</code> 中相关函数通过 WASM runtime 提供的 <code>registerCallback</code> 注册到 WASM runtime 中去。WASM 沙箱中的相关代码就可以执行对应的函数了。此处只需要了解 <code>proxy_wasm::exports</code> 中是一个个注册到沙箱并允许沙箱内调用的 API，并且使用 <code>proxy_wasm::ContextBase</code> 指针作为第一个参数。后文在讲到 Context 时会有更详细的示例说明 API 的调用过程。</p>
<p>下面以 V8 runtime 为例，查看 <code>registerCallback</code>  的具体实现。其中 <code>wasm::</code> 名称空间下的相关类型和相关函数是 V8 runtime 本身提供的的 C++ API，用于外部代码和 Sandbox 内代码交互。可以看到，<code>registerCallback</code>  将原本的函数包装之后添加到 <code>host_functions_</code> 中。包装后的函数将会使用 <code>current_context_</code> 作为实际注入函数的第一个参数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// proxy_wasm src/v8/v8.cc
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> R, <span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> V8<span style="color:#f92672">::</span>registerHostFunctionImpl(std<span style="color:#f92672">::</span>string_view module_name, std<span style="color:#f92672">::</span>string_view function_name,
                                  R (<span style="color:#f92672">*</span>function)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>, Args...)) {
  <span style="color:#66d9ef">auto</span> data <span style="color:#f92672">=</span>
      std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>FuncData<span style="color:#f92672">&gt;</span>(std<span style="color:#f92672">::</span>string(module_name) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>string(function_name));
  <span style="color:#66d9ef">auto</span> type <span style="color:#f92672">=</span> wasm<span style="color:#f92672">::</span>FuncType<span style="color:#f92672">::</span>make(convertArgsTupleToValTypes<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple<span style="color:#f92672">&lt;</span>Args...<span style="color:#f92672">&gt;&gt;</span>(),
                                   convertArgsTupleToValTypes<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;&gt;</span>());
  <span style="color:#66d9ef">auto</span> func <span style="color:#f92672">=</span> wasm<span style="color:#f92672">::</span>Func<span style="color:#f92672">::</span>make(
      store_.get(), type.get(),
      [](<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data, <span style="color:#66d9ef">const</span> wasm<span style="color:#f92672">::</span>Val params[], wasm<span style="color:#f92672">::</span>Val results[]) <span style="color:#f92672">-&gt;</span> wasm<span style="color:#f92672">::</span>own<span style="color:#f92672">&lt;</span>wasm<span style="color:#f92672">::</span>Trap<span style="color:#f92672">&gt;</span> {
        <span style="color:#66d9ef">auto</span> func_data <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>FuncData <span style="color:#f92672">*&gt;</span>(data);
        <span style="color:#66d9ef">auto</span> args_tuple <span style="color:#f92672">=</span> convertValTypesToArgsTuple<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple<span style="color:#f92672">&lt;</span>Args...<span style="color:#f92672">&gt;&gt;</span>(params);
        <span style="color:#66d9ef">auto</span> args <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>tuple_cat(std<span style="color:#f92672">::</span>make_tuple(current_context_), args_tuple);
        <span style="color:#66d9ef">auto</span> function <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>R (<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>, Args...)<span style="color:#f92672">&gt;</span>(func_data<span style="color:#f92672">-&gt;</span>raw_func_);
        R rvalue <span style="color:#f92672">=</span> absl<span style="color:#f92672">::</span>apply(function, args);
        results[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> makeVal(rvalue);
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
      },
      data.get());
  data<span style="color:#f92672">-&gt;</span>callback_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(func);
  data<span style="color:#f92672">-&gt;</span>raw_func_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*&gt;</span>(function);
  host_functions_.insert_or_assign(std<span style="color:#f92672">::</span>string(module_name) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>string(function_name),
                                   std<span style="color:#f92672">::</span>move(data));
}
</code></pre></div><p><code>current_context_</code> 是一个 thread_local 的全局变量。每当 Envoy 从外部调用 WASM 沙箱内 API 时，将会设置该 context（后文也会讲到）。当 WASM 沙箱中代码调用 Envoy API 时，就可以获得正确的 context。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// proxy_wasm include/proxy-wasm/wasm_vm.h
</span><span style="color:#75715e"></span>
<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">*/</span><span style="color:#f92672">/</span> Thread local state set during a call into a WASM VM so that calls coming out of the
<span style="color:#75715e">// VM can be attributed correctly to calling Filter. We use thread_local instead of ThreadLocal
</span><span style="color:#75715e">// because this state is live only during the calls and does not need to be initialized consistently
</span><span style="color:#75715e">// over all workers as with ThreadLocal data.**
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">thread_local</span> ContextBase <span style="color:#f92672">*</span>current_context_;
</code></pre></div><p>通过以上的方法，就可以实现沙箱外的代码/API（<code>proxy_wasm</code> 中代码仍旧是沙箱外代码）向沙箱内的注册（目前仍旧没有注册，只是通过 runtime API 完成了函数类型的封装）。（实际上，更底层的函数注册过程、类型的转换过程等实际上就是 WASM C++ API 的工作，就超出本文的范畴了）</p>
<p>在 <code>initialize</code> 中，完成 <code>registerCallbacks</code> 之后，就可以开始进一步的操作，<code>link</code>。link 主要完成两个操作：第一，将 <code>registerCallbacks</code> 所封装好的 API 注册绑定到 WASM 沙箱中去；将 WASM 沙箱中暴露的 API 导出到 <code>proxy_wasm</code> 中来。仍旧以 V8 为例，其 <code>link</code> 方法源码如下（略出了部分代码）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> V8<span style="color:#f92672">::</span>link(std<span style="color:#f92672">::</span>string_view debug_name) {
  assert(module_ <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>);

  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> import_types <span style="color:#f92672">=</span> module_.get()<span style="color:#f92672">-&gt;</span>imports();
  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> wasm<span style="color:#f92672">::</span>Extern <span style="color:#f92672">*&gt;</span> imports;

  <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> import_types.size(); i<span style="color:#f92672">++</span>) {
    std<span style="color:#f92672">::</span>string_view module(import_types[i]<span style="color:#f92672">-&gt;</span>module().get(), import_types[i]<span style="color:#f92672">-&gt;</span>module().size());
    std<span style="color:#f92672">::</span>string_view name(import_types[i]<span style="color:#f92672">-&gt;</span>name().get(), import_types[i]<span style="color:#f92672">-&gt;</span>name().size());
    <span style="color:#66d9ef">auto</span> import_type <span style="color:#f92672">=</span> import_types[i]<span style="color:#f92672">-&gt;</span>type();

    <span style="color:#66d9ef">switch</span> (import_type<span style="color:#f92672">-&gt;</span>kind()) {
    <span style="color:#66d9ef">case</span> wasm<span style="color:#f92672">::</span>EXTERN_FUNC: {
      <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> host_functions_.find(std<span style="color:#f92672">::</span>string(module) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>string(name));
      <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">auto</span> func <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second.get()<span style="color:#f92672">-&gt;</span>callback_.get();
      <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>      imports.push_back(func);
    } <span style="color:#66d9ef">break</span>;
    <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>    }
  }

  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> export_types <span style="color:#f92672">=</span> module_.get()<span style="color:#f92672">-&gt;</span>exports();
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> exports <span style="color:#f92672">=</span> instance_.get()<span style="color:#f92672">-&gt;</span>exports();
  assert(export_types.size() <span style="color:#f92672">==</span> exports.size());

  <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> export_types.size(); i<span style="color:#f92672">++</span>) {
    std<span style="color:#f92672">::</span>string_view name(export_types[i]<span style="color:#f92672">-&gt;</span>name().get(), export_types[i]<span style="color:#f92672">-&gt;</span>name().size());
    <span style="color:#66d9ef">auto</span> export_type <span style="color:#f92672">=</span> export_types[i]<span style="color:#f92672">-&gt;</span>type();
    <span style="color:#66d9ef">auto</span> export_item <span style="color:#f92672">=</span> exports[i].get();
    assert(export_type<span style="color:#f92672">-&gt;</span>kind() <span style="color:#f92672">==</span> export_item<span style="color:#f92672">-&gt;</span>kind());

    <span style="color:#66d9ef">switch</span> (export_type<span style="color:#f92672">-&gt;</span>kind()) {

    <span style="color:#66d9ef">case</span> wasm<span style="color:#f92672">::</span>EXTERN_FUNC: {
      assert(export_item<span style="color:#f92672">-&gt;</span>func() <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>);
      module_functions_.insert_or_assign(name, export_item<span style="color:#f92672">-&gt;</span>func()<span style="color:#f92672">-&gt;</span>copy());
    } <span style="color:#66d9ef">break</span>;
    <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>    }
  }
  <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>isFailed();
}
</code></pre></div><p>此处的代码虽然仍旧是 WASM 沙箱之外，但是已经开始大量使用 WASM runtime 提供的和沙箱交互的类型和 API 了。再次强调，忽略细节，关注核心。载入字节码之后，可以获取导入符号表和导出符号表。imports 是在沙箱中需要使用但未在沙箱中实现或者创建的函数 API、内存块等（需要从外部引入）。此时可以看到 <code>link</code> 根据 imports 中名称从  <code>host_functions_</code> 搜索函数并注入到 WASM Module 中供 Sandbox 调用。而反向的，link 也会将 WASM 沙箱本身对外暴露的 API  添加到 <code>module_functions_</code> 中。</p>
<p>具体到 Envoy HTTP Filter 当中，WASM 沙箱需要从外部引入的 Envoy API 以及自身对外暴露的 Filter API 都有哪些在后续介绍到 SDK 后，各位读者就会有更明确的认知。</p>
<p>回到当前，在 <code>link</code> 方法执行完成之后，就会执行 <code>getFunctions</code> 方法。该方法会将从 WASM 沙箱中导出的函数（存储在 <code>module_functions_</code> 中）绑定到 <code>proxy_wasm::WasmBase</code> 的成员当中，以供后续调用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> WasmBase<span style="color:#f92672">::</span>getFunctions() {
  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span><span style="color:#75715e">#define _GET_PROXY(_fn) wasm_vm_-&gt;getFunction(&#34;proxy_&#34; #_fn, &amp;_fn##_);
</span><span style="color:#75715e">#define _GET_PROXY_ABI(_fn, _abi) wasm_vm_-&gt;getFunction(&#34;proxy_&#34; #_fn, &amp;_fn##_abi##_);
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>
  _GET_PROXY(on_request_body);
  _GET_PROXY(on_request_trailers);
  _GET_PROXY(on_request_metadata);
  _GET_PROXY(on_response_body);
  _GET_PROXY(on_response_trailers);

  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (abiVersion() <span style="color:#f92672">==</span> AbiVersion<span style="color:#f92672">::</span>ProxyWasm_0_1_0) {
    _GET_PROXY_ABI(on_request_headers, _abi_01);
    _GET_PROXY_ABI(on_response_headers, _abi_01);
  } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (abiVersion() <span style="color:#f92672">==</span> AbiVersion<span style="color:#f92672">::</span>ProxyWasm_0_2_0 <span style="color:#f92672">||</span>
             abiVersion() <span style="color:#f92672">==</span> AbiVersion<span style="color:#f92672">::</span>ProxyWasm_0_2_1) {
    _GET_PROXY_ABI(on_request_headers, _abi_02);
    _GET_PROXY_ABI(on_response_headers, _abi_02);
    _GET_PROXY(on_foreign_function);
  }
<span style="color:#75715e">#undef _GET_PROXY_ABI
</span><span style="color:#75715e">#undef _GET_PROXY
</span><span style="color:#75715e"></span>}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> V8<span style="color:#f92672">::</span>getModuleFunctionImpl(std<span style="color:#f92672">::</span>string_view function_name,
                               std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>(ContextBase <span style="color:#f92672">*</span>, Args...)<span style="color:#f92672">&gt;</span> <span style="color:#f92672">*</span>function) {
  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>  <span style="color:#f92672">*</span>function <span style="color:#f92672">=</span> [func, function_name, <span style="color:#66d9ef">this</span>](ContextBase <span style="color:#f92672">*</span>context, Args... args) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">void</span> {
    wasm<span style="color:#f92672">::</span>Val params[] <span style="color:#f92672">=</span> {makeVal(args)...};
    <span style="color:#75715e">// 将 API 分装为一个闭包函数。且在执行 API 之前，会通过 SaveRestoreContext 的构造和析构来设置
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// current_context_
</span><span style="color:#75715e"></span>    SaveRestoreContext <span style="color:#a6e22e">saved_context</span>(context);
    <span style="color:#66d9ef">auto</span> trap <span style="color:#f92672">=</span> func<span style="color:#f92672">-&gt;</span>call(params, <span style="color:#66d9ef">nullptr</span>);
    <span style="color:#66d9ef">if</span> (trap) {
      fail(FailState<span style="color:#f92672">::</span>RuntimeError, <span style="color:#e6db74">&#34;Function: &#34;</span> <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>string(function_name) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; failed: &#34;</span> <span style="color:#f92672">+</span>
                                        std<span style="color:#f92672">::</span>string(trap<span style="color:#f92672">-&gt;</span>message().get(), trap<span style="color:#f92672">-&gt;</span>message().size()));
    }
  };
}
</code></pre></div><p>在 <code>getFunctions</code> 中需要注意的一个细节是，将 WASM 沙箱暴露的 API 绑定到 <code>proxy_wasm::WasmBase</code> 成员时，会将 API 再次包装，并在 API 调用前后，通过 <code>SaveRestoreContext</code> 的构造和析构来完成 <code>current_context_</code> 的设置和重置。</p>
<p>再次回到 <code>proxy_wasm::createWasm</code> 函数，它还没有结束。可以从代码看到，在完成WASM 沙箱的 <code>initialize</code> 之后，函数立刻克隆了一个新的沙箱并且调用其 start 以及 configure 等方法，校验字节码以及字节码配置。最后，一开始创建的 WASM 沙箱被包装在 <code>WasmHandleBase</code> 中被返回。</p>
<p>另外，要注意到，在 <code>proxy_wasm::createWasm</code> 创建并初始化完成的 WASM 沙箱或者说虚拟机会以参数中的 vm_key 为 key 存储在 <code>base_wasms</code> 中。</p>
<p><strong>小结：<code>initialize</code> 是在创建 WASM 虚拟机过程中最为关键的一个函数。它完成的 Envoy 主进程和 Sandbox 的对接和交互。通过 <code>registerCallbacks</code> 将 Envoy 需要暴露的 API 封装为沙箱可以执行的函数类型（WASM runtime 提供 C++ API 实现）。<code>link</code> 将封装好的 Envoy API 根据名称注册到沙箱中，并从 WASM 沙箱 中导出 Envoy 主进程所需要的 API。最后，<code>getFunctions</code> 将沙箱导出的 API 绑定到 <code>proxy_wasm::WasmBase</code> 上，供后续 Envoy 调用。</strong></p>
<h2 id="5-只有-worker-工作">5. 只有 Worker 工作</h2>
<p>注意到，上述创建的 WASM 沙箱只在主线程当中。但是实际上 HTTP 请求都是在工作线程中的。所以还有一步工作要做。</p>
<p>回到最最开始的 <code>FilterConfig</code> 构造函数，其中有一个回调函数。在 WASM Sandbox 完成创建之后，在 Envoy 的 createWasmInternal 函数中，该回调函数会被执行：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// source/extensions/filters/http/wasm/wasm_filter.cc
</span><span style="color:#75715e"></span>
FilterConfig<span style="color:#f92672">::</span>FilterConfig(<span style="color:#66d9ef">const</span> envoy<span style="color:#f92672">::</span>extensions<span style="color:#f92672">::</span>filters<span style="color:#f92672">::</span>http<span style="color:#f92672">::</span>wasm<span style="color:#f92672">::</span>v3<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">&amp;</span> config,
                           Server<span style="color:#f92672">::</span>Configuration<span style="color:#f92672">::</span>FactoryContext<span style="color:#f92672">&amp;</span> context)
    <span style="color:#f92672">:</span> tls_slot_(
          ThreadLocal<span style="color:#f92672">::</span>TypedSlot<span style="color:#f92672">&lt;</span>Common<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">::</span>PluginHandle<span style="color:#f92672">&gt;::</span>makeUnique(context.threadLocal())) {
  <span style="color:#75715e">// .......
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">auto</span> plugin <span style="color:#f92672">=</span> plugin_;<span style="color:#960050;background-color:#1e0010">、</span>
  <span style="color:#75715e">// 回调函数，当成功创建 WASM 虚拟机之后执行，用于在每个 Worker 线程之中都拷贝创建一个 WASM 虚拟机
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> callback <span style="color:#f92672">=</span> [plugin, <span style="color:#66d9ef">this</span>](<span style="color:#66d9ef">const</span> Common<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">::</span>WasmHandleSharedPtr<span style="color:#f92672">&amp;</span> base_wasm) {
    <span style="color:#75715e">// NB: the Slot set() call doesn&#39;t complete inline, so all arguments must outlive this call.
</span><span style="color:#75715e"></span>    tls_slot_<span style="color:#f92672">-&gt;</span>set([base_wasm, plugin](Event<span style="color:#f92672">::</span>Dispatcher<span style="color:#f92672">&amp;</span> dispatcher) {
      <span style="color:#66d9ef">return</span> Common<span style="color:#f92672">::</span>Wasm<span style="color:#f92672">::</span>getOrCreateThreadLocalPlugin(base_wasm, plugin, dispatcher);
    });
  };
  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>}
</code></pre></div><p>该 Callback 会在每个线程（包括主线程）中，调用 <code>Common::Wasm::getOrCreateThreadLocalPlugin</code> 方法，并最终调用 <code>proxy_wasm::proxy_wasm::getOrCreateThreadLocalPlugin</code> 方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// proxy_wasm src/wasm.cc
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>WasmHandleBase<span style="color:#f92672">&gt;</span>
getOrCreateThreadLocalWasm(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>WasmHandleBase<span style="color:#f92672">&gt;</span> base_handle,
                           WasmHandleCloneFactory clone_factory) {
  std<span style="color:#f92672">::</span>string vm_key(base_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>vm_key());
  <span style="color:#75715e">// Get existing thread-local WasmVM.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> local_wasms.find(vm_key);
  <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> local_wasms.end()) {
    <span style="color:#66d9ef">auto</span> wasm_handle <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second.lock();
    <span style="color:#66d9ef">if</span> (wasm_handle) {
      <span style="color:#66d9ef">return</span> wasm_handle;
    }
    <span style="color:#75715e">// Remove stale entry.
</span><span style="color:#75715e"></span>    local_wasms.erase(vm_key);
  }
  <span style="color:#75715e">// Create and initialize new thread-local WasmVM.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> wasm_handle <span style="color:#f92672">=</span> clone_factory(base_handle);
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>wasm_handle) {
    base_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>fail(FailState<span style="color:#f92672">::</span>UnableToCloneVM, <span style="color:#e6db74">&#34;Failed to clone Base Wasm&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
  }
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>wasm_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>initialize(base_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>code(),
                                       base_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>allow_precompiled())) {
    base_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>fail(FailState<span style="color:#f92672">::</span>UnableToInitializeCode, <span style="color:#e6db74">&#34;Failed to initialize Wasm code&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
  }
  local_wasms[vm_key] <span style="color:#f92672">=</span> wasm_handle;
  <span style="color:#66d9ef">return</span> wasm_handle;
}

std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>PluginHandleBase<span style="color:#f92672">&gt;</span> getOrCreateThreadLocalPlugin(
    std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>WasmHandleBase<span style="color:#f92672">&gt;</span> base_handle, std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>PluginBase<span style="color:#f92672">&gt;</span> plugin,
    WasmHandleCloneFactory clone_factory, PluginHandleFactory plugin_factory) {
  std<span style="color:#f92672">::</span>string key(std<span style="color:#f92672">::</span>string(base_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>vm_key()) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;||&#34;</span> <span style="color:#f92672">+</span> plugin<span style="color:#f92672">-&gt;</span>key());
  <span style="color:#75715e">// Get existing thread-local Plugin handle.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> local_plugins.find(key);
  <span style="color:#66d9ef">if</span> (it <span style="color:#f92672">!=</span> local_plugins.end()) {
    <span style="color:#66d9ef">auto</span> plugin_handle <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>second.lock();
    <span style="color:#66d9ef">if</span> (plugin_handle) {
      <span style="color:#66d9ef">return</span> plugin_handle;
    }
    <span style="color:#75715e">// Remove stale entry.
</span><span style="color:#75715e"></span>    local_plugins.erase(key);
  }
  <span style="color:#75715e">// Get thread-local WasmVM.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> wasm_handle <span style="color:#f92672">=</span> getOrCreateThreadLocalWasm(base_handle, clone_factory);
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>wasm_handle) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
  }
  <span style="color:#75715e">// Create and initialize new thread-local Plugin.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> plugin_context <span style="color:#f92672">=</span> wasm_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>start(plugin);
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>plugin_context) {
    base_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>fail(FailState<span style="color:#f92672">::</span>StartFailed, <span style="color:#e6db74">&#34;Failed to start thread-local Wasm&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
  }
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>wasm_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>configure(plugin_context, plugin)) {
    base_handle<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>fail(FailState<span style="color:#f92672">::</span>ConfigureFailed,
                              <span style="color:#e6db74">&#34;Failed to configure thread-local Wasm plugin&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
  }
  <span style="color:#66d9ef">auto</span> plugin_handle <span style="color:#f92672">=</span> plugin_factory(wasm_handle, plugin<span style="color:#f92672">-&gt;</span>key());
  local_plugins[key] <span style="color:#f92672">=</span> plugin_handle;
  <span style="color:#66d9ef">return</span> plugin_handle;
}
</code></pre></div><p>该方法首先会在 <code>local_plugins</code> 中尝试搜索，确认是否已经存在所需要的 Plugin（vm key 与 plugin key 共同确定唯一的一个 plugin）。如果不存在，则再次尝试再 <code>local_wasms</code> 中搜索是否存在对应的 WASM 沙箱。如果 local_wasms 中不存在对应的沙箱，则会按前所述的方法，从刚刚主线程所创建的基础沙箱中拷贝一份并完成初始化。</p>
<p><code>local_plugins</code> 和 <code>local_wasms</code> 是 threadlocal 类型，用于存储特定线程中的 WASM 沙箱以及 Plugin。</p>
<p>在创建完成 ThreadLocal 的 WASM Sandbox 之后，会进一步执行该沙箱的 start 和 configure 方法以实现字节码 Filter 的配置初始化。</p>
<p>最后，<code>getOrCreateThreadLocalPlugin</code> 会调用 Envoy 传入的一个闭包工厂函数来创建对应一个 <code>proxy_wasm::PluginHandleBase</code>（<code>Wasm::PluginHandle</code>）实例。<code>PluginHandleBase</code> 是对 WASM 沙箱的一个简单包装，目前只是包含指向沙箱的指针以及一个 Plugin Key，所以此处不再多做赘述。</p>
<p>在完成了以上的步骤之后，FilterConfig 的构造才算真正完成。Envoy WASM HTTP Filter 的配置才刚刚初始化好，接下来，就可以开始服务 HTTP 请求了。</p>
<p><strong>小结：为了保证线程安全，也为了更好的性能，在每个线程之上，都至少有一个独立的 WASM 沙箱（Sandbox 的个数与 vm_key 有关，不同的 vm_key 标识唯一一个 沙箱）。</strong></p>
<h2 id="6-一个-http-请求">6. 一个 HTTP 请求</h2>
<p>当请求到来时，FilterConfig 的 createFilter 方法会被调用，创建一个 HTTP Filter。它首先会从通过 Envoy 的 TLS 机制获取配置初始化阶段最后创建的 PluginHandle 并获取对应的 WASM 沙箱。然后基于该沙箱创建一个 <code>Wasm::Context</code> 实例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// source/extensions/filters/http/wasm/wasm_filter.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Context<span style="color:#f92672">&gt;</span> createFilter() {
    Wasm<span style="color:#f92672">*</span> wasm <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    <span style="color:#66d9ef">auto</span> handle <span style="color:#f92672">=</span> tls_slot_<span style="color:#f92672">-&gt;</span>get();
    <span style="color:#66d9ef">if</span> (handle.has_value()) {
      wasm <span style="color:#f92672">=</span> handle<span style="color:#f92672">-&gt;</span>wasm().get();
    }
    <span style="color:#66d9ef">if</span> (plugin_<span style="color:#f92672">-&gt;</span>fail_open_ <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">!</span>wasm <span style="color:#f92672">||</span> wasm<span style="color:#f92672">-&gt;</span>isFailed())) {
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
    }
    <span style="color:#66d9ef">if</span> (wasm <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>root_context_id_) {
      root_context_id_ <span style="color:#f92672">=</span> wasm<span style="color:#f92672">-&gt;</span>getRootContext(plugin_, false)<span style="color:#f92672">-&gt;</span>id();
    }
    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span>Context<span style="color:#f92672">&gt;</span>(wasm, root_context_id_, plugin_);
  }
<span style="color:#75715e">// ......
</span></code></pre></div><p><code>Wasm::Context</code> 是 Envoy WASM 中第二个核心类型。<code>FilterConfig</code> 负责了 WASM 沙箱的创建和管理。而 <code>Wasm::Context</code> 则负责了 Envoy API 的实现以及 Filter 的包装。</p>
<p><code>Wasm::Context</code> 实现了 HTTP Filter/Network Filter 的的接口，同时继承了 <code>proxy_wasm::ContextBase</code> 类型。几乎 Envoy 所有对 WASM 沙箱暴露的 API 都由 <code>Wasm::Context</code> 实际实现。</p>
<p><code>Wasm::Context</code> 虽然源码量大，但是反而没有特别复杂的地方。接下来，将通过一次 HTTP Filter 的请求调用来带领读者快速了解 <code>Wasm::Context</code> 是如何工作并与 WASM 沙箱交互的。</p>
<p>当 Envoy 中 HCM 调用 <code>Wasm::Context</code> 的 <code>decodeTrailers</code> 方法时。将会调用到基类 <code>proxy_wasm::ContextBase</code> 的 <code>onRequestTrailers</code> 方法，并最终调用沙箱对外暴露的相关 API。（绑定在 <code>proxy::WasmBase</code> 中）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// source/extensions/filters/common/context.cc
</span><span style="color:#75715e"></span>
Http<span style="color:#f92672">::</span>FilterTrailersStatus Context<span style="color:#f92672">::</span>decodeTrailers(Http<span style="color:#f92672">::</span>RequestTrailerMap<span style="color:#f92672">&amp;</span> trailers) {
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>http_request_started_) {
    <span style="color:#66d9ef">return</span> Http<span style="color:#f92672">::</span>FilterTrailersStatus<span style="color:#f92672">::</span>Continue;
  }
  request_trailers_ <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>trailers;
  <span style="color:#66d9ef">auto</span> result <span style="color:#f92672">=</span> convertFilterTrailersStatus(onRequestTrailers(headerSize(<span style="color:#f92672">&amp;</span>trailers)));
  <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">==</span> Http<span style="color:#f92672">::</span>FilterTrailersStatus<span style="color:#f92672">::</span>Continue) {
    request_trailers_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
  }
  <span style="color:#66d9ef">return</span> result;
}

<span style="color:#75715e">// proxy_wasm src/context.cc
</span><span style="color:#75715e"></span>
FilterTrailersStatus ContextBase<span style="color:#f92672">::</span>onRequestTrailers(<span style="color:#66d9ef">uint32_t</span> trailers) {
  CHECK_HTTP(on_request_trailers_, FilterTrailersStatus<span style="color:#f92672">::</span>Continue,
             FilterTrailersStatus<span style="color:#f92672">::</span>StopIteration);
  DeferAfterCallActions <span style="color:#a6e22e">actions</span>(<span style="color:#66d9ef">this</span>);
  <span style="color:#75715e">// 前文中 link 处将 Sandbox API 导出，getFunctions 完成 API 绑定
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">convertVmCallResultToFilterTrailersStatus</span>(
      wasm_<span style="color:#f92672">-&gt;</span>on_request_trailers_(<span style="color:#66d9ef">this</span>, id_, trailers).u64_);
}
</code></pre></div><p>而在 WASM 沙箱内部，当对应的 API 被调用，在代码的执行过程当中同样可能会调用外部主进程向沙箱注册的一些 API（前文中提到的 <code>proxy_wasm::exports</code> 名称空间下的相关函数）。举例来说，当在沙箱中调用 API 来获取 HTTP request 中 Headers 时，将会调用 <code>proxy_wasm::exports</code> 中 <code>get_header_map_value</code> 函数。</p>
<p>其中第一个参数为一个 void 类型指针，用于传递请求上下文。由前文的 <code>registerCallbacks</code> 相关内容可知，<code>current_context_</code> 将被作为实参传入。也即是说，最终，context 本身的 <code>getHeaderMapValue</code> 方法会被调用。如此就完成了 Envoy 调用沙箱 API，沙箱内调用 Envoy API 的完整交互过程了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// proxy_wasm src/exports.cc
</span><span style="color:#75715e"></span>
Word <span style="color:#a6e22e">get_header_map_value</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>raw_context, Word type, Word key_ptr, Word key_size,
                          Word value_ptr_ptr, Word value_size_ptr) {
  <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint64_t</span><span style="color:#f92672">&gt;</span>(WasmHeaderMapType<span style="color:#f92672">::</span>MAX)) {
    <span style="color:#66d9ef">return</span> WasmResult<span style="color:#f92672">::</span>BadArgument;
  }
	<span style="color:#75715e">// 将 raw_context 转换为 ContextBase 类型。ContextBase 会对请求上下文的封装，后文将会详细介绍
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> context <span style="color:#f92672">=</span> WASM_CONTEXT(raw_context);
  <span style="color:#66d9ef">auto</span> key <span style="color:#f92672">=</span> context<span style="color:#f92672">-&gt;</span>wasmVm()<span style="color:#f92672">-&gt;</span>getMemory(key_ptr, key_size);
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>key) {
    <span style="color:#66d9ef">return</span> WasmResult<span style="color:#f92672">::</span>InvalidMemoryAccess;
  }
  std<span style="color:#f92672">::</span>string_view value;
  <span style="color:#66d9ef">auto</span> result <span style="color:#f92672">=</span>
      context<span style="color:#f92672">-&gt;</span>getHeaderMapValue(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>WasmHeaderMapType<span style="color:#f92672">&gt;</span>(type.u64_), key.value(), <span style="color:#f92672">&amp;</span>value);
  <span style="color:#66d9ef">if</span> (result <span style="color:#f92672">!=</span> WasmResult<span style="color:#f92672">::</span>Ok) {
    <span style="color:#66d9ef">return</span> result;
  }
  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>context<span style="color:#f92672">-&gt;</span>wasm()<span style="color:#f92672">-&gt;</span>copyToPointerSize(value, value_ptr_ptr, value_size_ptr)) {
    <span style="color:#66d9ef">return</span> WasmResult<span style="color:#f92672">::</span>InvalidMemoryAccess;
  }
  <span style="color:#66d9ef">return</span> WasmResult<span style="color:#f92672">::</span>Ok;
}
</code></pre></div><p><strong>小结：在 Envoy 请求处理过程中，当插件链执行到 WASM Filter 时，作为 HTTP Filter 和 Network Filter 包装器的 Wasm::Context 的相应接口会被调用，并且最终会调用沙箱 API。而沙箱在执行过程中，也会通过调用 Envoy API （<code>proxy_wasm::exports</code> 中的各个函数）获取或者修改请求状态。Envoy API 的最终也会调用 <code>Wasm::Context</code> 中的某个成员方法如 <code>getHeaderMapValue</code> 来实现对特定请求的处理。</strong></p>
<h2 id="7-走在沙箱之内">7. 走在沙箱之内</h2>
<p>如果细细看完了前文，那么相信对于 Envoy 与 WASM 沙箱的交互已经有所了解。但是，还会有一个小小的问题。如何保证沙箱 API 与 proxy::WasmBase 中待绑定的成员一一对应？（沙箱 API 最终都会在包装之后绑定到 proxy::WasmBase 的成员中待调用，前文已经多次说明了）如何保证 Envoy API 与沙箱需要引用的外部 API 一一对应？（沙箱可以调用的外部方法都在 <code>proxy_wasm::exports</code> 中，必须保证沙箱只引入这一部分 API。）</p>
<p>要理解这一部分内容，就必须阅读 SDK 代码。此处，以 C++ SDK 为例。其工程路径如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">https:<span style="color:#75715e">//github.com/proxy-wasm/proxy-wasm-cpp-sdk
</span><span style="color:#75715e"></span>commit: <span style="color:#ae81ff">956f</span><span style="color:#ae81ff">0</span>d500c380cc1656a2d861b7ee12c2515a664
</code></pre></div><p>前文中 Envoy 主干代码以及 <code>proxy_wasm</code> 中代码，本质上都是在主进程中执行。而 SDK 则进入了 WASM 沙箱的世界。SDK 主要的责任在于两点：</p>
<ul>
<li><strong>对 Envoy 主进程：暴露特定的沙箱 API 同时声明对 Envoy API 的引用；</strong></li>
<li><strong>对 WASM Filter：通过良好的封装隐藏 Envoy API 的细节；通过继承关系和接口的约束，保证暴露的沙箱 API 具备相应的实现。</strong></li>
</ul>
<p>如果由 Lua C API 开发经验，相信大家很容易就能够理解，因为本质都是大同小异。</p>
<p>下面是SDK 中沙箱 API 和 Envoy API 的相关声明。可以注意到，沙箱 API 声明和 <code>proxy_wasm::WasmBase</code> 中待绑定 API 的数据成员具备对应关系。而 Envoy API 声明则和 <code>proxy_wasm::exports</code> 中函数具备对应关系。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// C++ SDK proxy_wasm_externs.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Sandbox API 声明
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> FilterTrailersStatus proxy_on_request_trailers(<span style="color:#66d9ef">uint32_t</span> context_id, <span style="color:#66d9ef">uint32_t</span> trailers);
<span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> FilterMetadataStatus proxy_on_request_metadata(<span style="color:#66d9ef">uint32_t</span> context_id, <span style="color:#66d9ef">uint32_t</span> nelements);

<span style="color:#75715e">// Envoy API 声明
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> WasmResult proxy_add_header_map_value(WasmHeaderMapType type, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>key_ptr,
                                                 size_t key_size, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>value_ptr,
                                                 size_t value_size);
<span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> WasmResult proxy_get_header_map_value(WasmHeaderMapType type, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>key_ptr,
                                                 size_t key_size, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>value_ptr,
                                                 size_t <span style="color:#f92672">*</span>value_size);

<span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>
</code></pre></div><p>下面一段源码则是沙箱 API 的实现（Envoy API 在 SDK 内没有实现只能加载后绑定 Envoy 主进程提供的实现）。可以看到，沙箱 API 最终会通过 context_id 找到和 Envoy 主进程中 <code>Wasm::Context</code>（<code>proxy_wasm::ContextBase</code>）实例对应的一个 WASM 沙箱内 SDK Context 实例，并调用其对应的接口实现。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// C++ SDK proxy_wasm_intrinsics.cc
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Sandbox API 实现
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> PROXY_WASM_KEEPALIVE FilterMetadataStatus proxy_on_request_metadata(<span style="color:#66d9ef">uint32_t</span> context_id,
                                                                               <span style="color:#66d9ef">uint32_t</span> elements) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">getContext</span>(context_id)<span style="color:#f92672">-&gt;</span>onRequestMetadata(elements);
}

<span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> PROXY_WASM_KEEPALIVE FilterTrailersStatus proxy_on_request_trailers(<span style="color:#66d9ef">uint32_t</span> context_id,
                                                                               <span style="color:#66d9ef">uint32_t</span> trailers) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">getContext</span>(context_id)<span style="color:#f92672">-&gt;</span>onRequestTrailers(trailers);
}

<span style="color:#75715e">// ......
</span></code></pre></div><p>SDK Context 的部分定义如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// Context for a stream. The distinguished context id == 0 is used for
</span><span style="color:#75715e">// non-stream calls.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Context</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> ContextBase {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> FilterHeadersStatus onRequestHeaders(<span style="color:#66d9ef">uint32_t</span>, <span style="color:#66d9ef">bool</span>) {
    <span style="color:#66d9ef">return</span> FilterHeadersStatus<span style="color:#f92672">::</span>Continue;
  }
  <span style="color:#66d9ef">virtual</span> FilterMetadataStatus <span style="color:#a6e22e">onRequestMetadata</span>(<span style="color:#66d9ef">uint32_t</span>) {
    <span style="color:#66d9ef">return</span> FilterMetadataStatus<span style="color:#f92672">::</span>Continue;
  }
  <span style="color:#66d9ef">virtual</span> FilterDataStatus <span style="color:#a6e22e">onRequestBody</span>(size_t <span style="color:#75715e">/* body_buffer_length */</span>,
                                         <span style="color:#66d9ef">bool</span> <span style="color:#75715e">/* end_of_stream */</span>) {
    <span style="color:#66d9ef">return</span> FilterDataStatus<span style="color:#f92672">::</span>Continue;
  }
  <span style="color:#66d9ef">virtual</span> FilterTrailersStatus <span style="color:#a6e22e">onRequestTrailers</span>(<span style="color:#66d9ef">uint32_t</span>) {
    <span style="color:#66d9ef">return</span> FilterTrailersStatus<span style="color:#f92672">::</span>Continue;
  }
  <span style="color:#66d9ef">virtual</span> FilterHeadersStatus <span style="color:#a6e22e">onResponseHeaders</span>(<span style="color:#66d9ef">uint32_t</span>, <span style="color:#66d9ef">bool</span>) {
    <span style="color:#66d9ef">return</span> FilterHeadersStatus<span style="color:#f92672">::</span>Continue;
  }
  <span style="color:#75715e">// ......
</span><span style="color:#75715e"></span>};
</code></pre></div><p><strong>小结：见本小节加粗内容。</strong></p>
<h2 id="8-精简版总结">8. 精简版总结</h2>
<p><img src="envoy_wasm.png" alt=""></p>
<ul>
<li><code>Wasm::Context</code>：封装 HTTP/Network Filter 接口使得 Envoy 上层可以将其嵌入到插件链中。同时提供了对 Envoy API 的具体实现。封装了请求上下文。继承自 <code>proxy_wasm::ContextBase</code>。</li>
<li><code>proxy_wasm::ContextBase</code>：封装 <code>proxy_wasm::WasmBase</code> 中绑定的 WASM 沙箱 API。</li>
<li><code>Wasm::Wasm</code>：对 WASM 沙箱的上层封装，继承自 <code>proxy_wasm::WasmBase</code>。相比于其基类，增加了 Envoy 相关的一些状态，如 stats 指标监控，日志以及一些全局的 API 如 Cluster Manager 等。</li>
<li><code>proxy_wasm::WasmBase</code>：proxy_wasm 中对 WASM 沙箱的封装。通过组合管理 <code>proxy_wasm::WasmVM</code>。绑定 WASM 沙箱 API 以提供给 <code>proxy_wasm::ContextBase</code> 调用。</li>
<li><code>proxy_wasm::WasmVM</code>：对不同类型 WSAM runtime 的封装，暴露处统一的对外接口，如注册 API，获取 API 等。</li>
<li><code>proxy_wasm::exports</code>：名称空间。其中包含所有 Envoy 提供给 WASM 沙箱的 Envoy API 函数。</li>
</ul>
<p><strong>作者简介</strong></p>
<p>王佰平，网易数帆资深工程师，负责轻舟Envoy网关与轻舟Service Mesh数据面开发、功能增强、性能优化等工作。对于Envoy数据面开发、增强、落地具有较为丰富的经验。</p>

        </div>
        <!-- tags -->
        <div class="mb-3">
          <h5 class="d-inline-block mr-3">Tags:</h5>
          <ul class="list-inline d-inline-block">
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/service-mesh"> 
            Service Mesh</a>
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/envoy"> , 
            Envoy</a>
            <a>
            <li class="list-inline-item"><a class="text-color" href="/tags/wasm"> , 
            WASM</a>
            
          </ul>
        </div>
        <!-- previous -->
        
<div class="col-12">
<ul class="pager blog-pager">

<li class="previous">
<a href="https://cloudnative.to/blog/cloud-security-policy/" data-toggle="tooltip" data-placement="top" title="云安全策略的创建">&larr; 上一篇</a>
</li>
 
<li class="next">
<a href="https://cloudnative.to/blog/problem-with-rbac/" data-toggle="tooltip" data-placement="top" title="基于角色的访问控制（RBAC）存在的问题">下一篇 &rarr;</a>
</li>

</ul>
</div>


        <!-- previous -->

        <!-- recommend -->
        

<div class="mb-3">
  <h2>文章推荐</h2>
  <ul class="related">
  
    <li><a href="/blog/redis-cluster-with-istio/">在 Istio 中实现 Redis 集群的数据分片、读写分离和流量镜像</a></li>
  
    <li><a href="/blog/envoy-wasm/">Istio 进阶学习系列 - 基于 WebAssembly 实现 Envoy 与 Istio 的功能扩展</a></li>
  
    <li><a href="/blog/what-is-envoy/">Envoy 是什么？</a></li>
  
    <li><a href="/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/">如何为 Envoy 构建一个控制面来管理集群网络流量</a></li>
  
    <li><a href="/blog/zero-trust-service-mesh/">服务网格的零信任安全</a></li>
  
  </ul>
</div>


        <!-- comments -->

        
        <div id="gitalk-container"></div>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
        <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
        <script>
          window.onload = function() {
              const gitalk = new Gitalk({
              clientID: '0f001988910adcfadfb7',
              clientSecret: '14f7d06ee5e6575c295d18fc11616e8cb60fb84e',
              repo: 'cloudnativeto.github.io',
              owner: 'cloudnativeto',
              admin: ['rootsongjc'],
              id: hex_md5(hex_md5(window.location.pathname + window.location.hash)), 
              distractionFreeMode: false 
            });
            (function() {
              if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
                document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
                return;
              }
              gitalk.render('gitalk-container');
            })();
          }
        </script>
        
      </div>
      <!-- sidebar -->
<aside class="col-lg-4 order-1 order-lg-2">
    <!-- categories -->
<div class="bg-pink px-4 py-5 box-shadow mb-5">
  <h4 class="mb-4">分类</h4>
  <ul class="list-unstyled">
    <li class="border-bottom"><a href="/categories/devops" class="d-block pb-3 mt-3 text-capitalize">Devops</a></li>
    <li class="border-bottom"><a href="/categories/devsecops" class="d-block pb-3 mt-3 text-capitalize">Devsecops</a></li>
    <li class="border-bottom"><a href="/categories/envoy" class="d-block pb-3 mt-3 text-capitalize">Envoy</a></li>
    <li class="border-bottom"><a href="/categories/istio" class="d-block pb-3 mt-3 text-capitalize">Istio</a></li>
    <li class="border-bottom"><a href="/categories/kubernetes" class="d-block pb-3 mt-3 text-capitalize">Kubernetes</a></li>
    <li class="border-bottom"><a href="/categories/serverless" class="d-block pb-3 mt-3 text-capitalize">Serverless</a></li>
    <li class="border-bottom"><a href="/categories/service-mesh" class="d-block pb-3 mt-3 text-capitalize">Service mesh</a></li>
    <li class="border-bottom"><a href="/categories/%e4%ba%91%e5%8e%9f%e7%94%9f" class="d-block pb-3 mt-3 text-capitalize">云原生</a></li>
    <li class="border-bottom"><a href="/categories/%e5%85%b6%e4%bb%96" class="d-block pb-3 mt-3 text-capitalize">其他</a></li>
    <li class="border-bottom"><a href="/categories/%e5%8f%af%e8%a7%82%e5%af%9f%e6%80%a7" class="d-block pb-3 mt-3 text-capitalize">可观察性</a></li>
    <li class="border-bottom"><a href="/categories/%e5%ae%89%e5%85%a8" class="d-block pb-3 mt-3 text-capitalize">安全</a></li>
    <li class="border-bottom"><a href="/categories/%e5%bc%80%e6%ba%90" class="d-block pb-3 mt-3 text-capitalize">开源</a></li>
    <li class="border-bottom"><a href="/categories/%e5%bc%80%e6%ba%90%e7%a4%be%e5%8c%ba" class="d-block pb-3 mt-3 text-capitalize">开源社区</a></li>
    <li class="border-bottom"><a href="/categories/%e6%8c%81%e7%bb%ad%e4%ba%a4%e4%bb%98" class="d-block pb-3 mt-3 text-capitalize">持续交付</a></li>
    <li class="border-bottom"><a href="/categories/%e7%a8%b3%e5%ae%9a%e6%80%a7" class="d-block pb-3 mt-3 text-capitalize">稳定性</a></li>
    <li class="border-bottom"><a href="/categories/%e8%be%b9%e7%bc%98%e8%ae%a1%e7%ae%97" class="d-block pb-3 mt-3 text-capitalize">边缘计算</a></li>
  </ul>
</div>

  <!-- tags -->
  

  <!-- profile -->
  <div class="bg-pink px-4 py-5 box-shadow mb-5 avatar-content">
    <div class="avatar">
      <div class="mx-auto avatar-wrp">
        <img class="rounded-circle avatar-img" src="/images/profile/wangbaiping.jpg">
      </div>
      <p class="avatar-name">
        <strong class="text-dark "><a href="https://github.com/wbpcode">王佰平</a></strong> 
      </p>
      <p>网易数帆资深工程师，负责轻舟Envoy网关与轻舟Service Mesh数据面开发、功能增强、性能优化等工作。对于Envoy数据面开发、增强、落地具有较为丰富的经验。</p>
    </div>
  </div>
  <!-- toc -->
  
  <div class="bg-white px-4 py-5 box-shadow mb-5 sticky-top">
    <h4 class="mb-4">目录</h4>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-从-envoy-开始">1. 从 Envoy 开始</a></li>
    <li><a href="#2-创建一个沙箱">2. 创建一个沙箱</a></li>
    <li><a href="#3-创建一个沙箱-续">3. 创建一个沙箱-续</a></li>
    <li><a href="#4-沙箱初始化">4. 沙箱初始化</a></li>
    <li><a href="#5-只有-worker-工作">5. 只有 Worker 工作</a></li>
    <li><a href="#6-一个-http-请求">6. 一个 HTTP 请求</a></li>
    <li><a href="#7-走在沙箱之内">7. 走在沙箱之内</a></li>
    <li><a href="#8-精简版总结">8. 精简版总结</a></li>
  </ul>
</nav>
  </div>

</aside>
<!-- /sidebar -->

    </div>
  </div>
</section>
<!-- /blog details -->



<footer>
  
  <div class="section bg-secondary">
    <div class="container">
      <div class="row justify-content-between">
        
        <div class="col-lg-5 mb-5 mb-lg-0">
          
          <a class="mb-4 d-inline-block" href="/"><img class="img-fluid"
              src="/images/logo-alt.png" alt="云原生社区" width="60%"></a>
          <p class="text-light mb-5">云原生社区是国内最大的独立第三方云原生终端用户和泛开发者社区，由 CNCF 大使、开源意见领袖共同发起成立于 2020 年 5 月 12 日，提供云原生专业资讯，促进云原生产业发展。</p>
          <h4 class="text-white mb-4">关注我们</h4>
          
          <ul class="list-inline social-icon-alt">
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://twitter.com/cloudnativecn"><i class="fa fa-twitter"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://github.com/cloudnativeto"><i class="fa fa-github"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://mp.weixin.qq.com/s/vWlSdzz2MNdXRr0sd2-LFg"><i class="fa fa-wechat"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="mailto:contact@cloudnative.to"><i class="fa fa-envelope"></i></a>
            </li>
            
            <li class="list-inline-item">
              <a class="hover-ripple" href="https://cloudnative.to/blog/index.xml"><i class="fa fa-rss"></i></a>
            </li>
            
          </ul>
        </div>
        <div class="col-lg-5 mb-5 mb-lg-0">
            
            
            
            
            
            <div class="mb-5 address">
              <h4 class="text-white mb-4">联系信息</h4>
              <p class="text-light mb-3"><a href="/city/beijing">北京</a>|<a href="/city/shanghai">上海</a>|<a href="/city/chengdu">成都</a>|<a href="/city/shenzhen">深圳</a>|<a href="/city/hangzhou/">杭州</a>|<a href="/city/guangzhou/">广州</a>|<a href="https://github.com/cloudnativeto/community/issues/55">武汉</a>|<a href="/city/nanjing">南京</a>|<a href="https://github.com/cloudnativeto/community/issues/61">西安</a>|<a href="/city/dalian">大连</a>|<a href="https://github.com/cloudnativeto/community/issues/52">长沙</a>|<a href="https://github.com/cloudnativeto/community/issues/66">苏州</a>|<a href="https://github.com/cloudnativeto/community/issues/67">珠海</a>|<a href="https://github.com/cloudnativeto/community/issues/78">重庆</a>|<a href="https://github.com/cloudnativeto/community/issues/82">济南</a>|<a href="https://github.com/cloudnativeto/community/issues/83">厦门</a>|<a href="https://github.com/cloudnativeto/community/issues/86">无锡</a>|<a href="https://github.com/cloudnativeto/community/issues/91">青岛</a>|<a href="https://github.com/cloudnativeto/community/issues/103">郑州</a>|<a href="https://github.com/cloudnativeto/community/issues/107">合肥</a></p>
              <p class="text-light mb-3"></p>
              <p class="text-light mb-3">关注云原生社区微信公众号，加入社区并获取最新资讯。</p>
              <p class="text-light mb-3"><img src="/images/wechat-qrcode.png" width="128px"></p>
            </div>
            
            
        </div>
      </div>
    </div>
  </div>
  
  <div class="bg-secondary-darken py-4">
    <div class="container">
      <div class="row">
        <div class="col-md-6 text-center text-md-left mb-3 mb-md-0">
          <p class="mb-0 text-white">Copyright © 2021 云原生社区</p>
        </div>
        <div class="col-md-6 text-center text-md-right">
          <ul class="list-inline">
            
            <li class="list-inline-item mx-0"><a class="d-inline-block px-3 text-white" href="/policy"
                class="text-white">声明与政策</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</footer>



<script>
  var indexURL = "/index.json"
</script>


<!-- JS Plugins -->

<script src="/plugins/jQuery/jquery.min.js"></script>

<script src="/plugins/bootstrap/bootstrap.min.js"></script>

<script src="/plugins/slick/slick.min.js"></script>

<script src="/plugins/google-map/gmap.js"></script>

<script src="/plugins/venobox/venobox.min.js"></script>

<script src="/plugins/filterizr/jquery.filterizr.min.js"></script>

<script src="/plugins/search/fuse.min.js"></script>

<script src="/plugins/search/mark.js"></script>

<script src="/plugins/search/search.js"></script>

<script src="/plugins/bigPicture/bigPicture.js"></script>

<script src="/plugins/hex_md5/hex_md5.js"></script>


<!-- Main Script -->

<script src="/js/script.min.js"></script>

<!-- Algolia -->
<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.min.js"></script>
<script>
  docsearch({
    apiKey: '870a8addaf7a712ecc6e33ce9def93b1',
    indexName: 'DocSearch',
    appId: '2506Q6I4IV',
    inputSelector: '#js-algolia-btn',
    debug: false,
  });
</script>

<!-- baidu tongji-->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f3dc895ea3bd6186cd835841d365c103";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


<!-- google analitycs -->

<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o),
      m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
  ga('create', 'UA-93485976-4', 'auto');
  ga('send', 'pageview');
</script>


</body>

</html>
