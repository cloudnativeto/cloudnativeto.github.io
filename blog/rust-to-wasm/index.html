<!DOCTYPE html><html lang="zh" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.5.0 for Hugo" />
  

  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
  

  

  
  
  
    
  
  <meta name="description" content="关于将 Rust 编译为 WebAssembly 的所有知识。" />

  
  <link rel="alternate" hreflang="zh" href="https://cloudnative.to/blog/rust-to-wasm/" />

  
  
  
    <meta name="theme-color" content="#0a55a7" />
  

  
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css" media="print" onload="this.media='all'">

  
  
  
    
    

    
    
    
    
      
      
    
    
    

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/github.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
        
      
    

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      
        
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.008259417e6adf8980695ebbbb46553f.css" />

  



  


  


  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f3dc895ea3bd6186cd835841d365c103";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_hu0802e500a55b0406ddf0453824effa47_6997_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_hu0802e500a55b0406ddf0453824effa47_6997_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://cloudnative.to/blog/rust-to-wasm/" />

  
  
  
  
  
  
  
  
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary_large_image" />
  
    <meta property="twitter:site" content="@CloudNativeCN" />
    <meta property="twitter:creator" content="@CloudNativeCN" />
  
  <meta property="og:site_name" content="云原生社区（中国）" />
  <meta property="og:url" content="https://cloudnative.to/blog/rust-to-wasm/" />
  <meta property="og:title" content="Rust 编译 WebAssembly 指南 | 云原生社区（中国）" />
  <meta property="og:description" content="关于将 Rust 编译为 WebAssembly 的所有知识。" /><meta property="og:image" content="https://cloudnative.to/media/sharing.png" />
    <meta property="twitter:image" content="https://cloudnative.to/media/sharing.png" /><meta property="og:locale" content="zh" />
  
    
      <meta
        property="article:published_time"
        content="2023-02-24T11:00:00&#43;08:00"
      />
    
    <meta property="article:modified_time" content="2024-01-29T21:00:05&#43;08:00">
  

  


    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cloudnative.to/blog/rust-to-wasm/"
  },
  "headline": "Rust 编译 WebAssembly 指南",
  
  "datePublished": "2023-02-24T11:00:00+08:00",
  "dateModified": "2024-01-29T21:00:05+08:00",
  
  "author": {
    "@type": "Person",
    "name": "Surma"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "云原生社区（中国）",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cloudnative.to/media/logo.svg"
    }
  },
  "description": "关于将 Rust 编译为 WebAssembly 的所有知识。"
}
</script>

  

  

  

  





  <title>Rust 编译 WebAssembly 指南 | 云原生社区（中国）</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="345544479c0522496af7d862b03faebc" >
  <button onclick="topFunction()" id="backTopBtn" title="Go to top"><i class="fa-solid fa-circle-up" aria-hidden="true"></i></button>
  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.62d6f8dfe8493f1c68557dde65bec362.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6 search-title">
          <p>搜索</p>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="关闭"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="搜索..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="搜索...">
        
      </div>

      
      

      
    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

      <div id="search-common-queries">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    











  


<header class="header--fixed">
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区（中国）"
            
            ></a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="切换导航">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/"><img src="/media/logo.svg" alt="云原生社区（中国）"
          
          ></a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/community"><span>社区</span></a>
          </li>

          
          

          

          
          
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link  active" href="/blog"><span>博客</span></a>
          </li>

          
          

          
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>小组</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/k8s-gateway-api"><span>Kubernetes Gateway API SIG</span></a>
              
            </div>
          </li>

          
          

          
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true"><span>资料</span><span class="caret"></span>
            </a>
            <div class="dropdown-menu">
              
                <a class="dropdown-item" href="/envoy/"><span>Envoy 中文文档</span></a>
              
                <a class="dropdown-item" href="/kubebuilder/"><span>Kubebuilder 中文文档</span></a>
              
                <a class="dropdown-item" href="https://lib.jimmysong.io/"><span>云原生资料库</span></a>
              
                <a class="dropdown-item" href="https://istio.io/latest/zh/"><span>Istio 中文文档</span></a>
              
            </div>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/event"><span>活动</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#feed"><span>更新</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#tags"><span>标签</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
              
              
              
                
              
              
            
          

          <li class="nav-item">
            <a class="nav-link " href="/#about"><span>关于</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        

        
        <li class="nav-item">
            <a class="nav-link" href="/community/join/" data-toggle="tooltip" data-placement="bottom" title="加入社区" aria-label="主站"><i class="fa-brands fa-weixin" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item">
            <a class="nav-link js-search" href="#" data-toggle="tooltip" data-placement="bottom" title="搜索" aria-label="搜索"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        <li class="nav-item d-none d-lg-inline-flex">
            <a class="nav-link" href="https://github.com/cloudnativeto/cloudnative.to" target="_blank" rel="noopener" data-toggle="tooltip" data-placement="bottom" title="查看源码" aria-label="查看源码" aria-label="GitHub"><i class="fa-brands fa-github" aria-hidden="true"></i></a>
        </li>
        

        
        
        
        <li class="nav-item">
          <a href="#" class="nav-link set-theme">
            <i class="fa fa-sun" aria-hidden="true" id="theme-icon"></i>
          </a>
        </li>
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    <div class="container-xl">
    <div class="post-container">
        












  

  
  
  
<div class="article-container pt-3">
  <h1>Rust 编译 WebAssembly 指南</h1>

  

  
    


<div class="article-metadata">

  <div>
  
  
  
  
    <i class="fa-solid fa-feather"></i>
    

  <span >
      <a href="/author/surma/">Surma</a></span>
    
    <span class="middot-divider"></span>
    
  
  
  
  
  
  
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/category/webassembly/" class="text-capitalize">WebAssembly</a></span>
  
  </div>

  
  <span class="article-date">
    
    
      
          
          发布于
      
    
    2023-02-24
  </span>
  

  

  
  <span class="middot-divider"></span>
  字数 10332
  <span class="middot-divider"></span>
  <span class="article-reading-time">
      阅读时长 47 分钟
  </span>
  

  
  
  
  

</div>

    




<div class="btn-links mb-2">
  
  








  


















  
  
  
  
  
  
  
    
  
  <a class="btn btn-outline-primary btn-page-header" href="https://surma.dev/things/rust-to-webassembly/" target="_blank" rel="noopener">
    <i class="fa fa-globe mr-1"></i>原文</a>


</div>


  
</div>


    </div>
    <div class="border-bottom mb-2"></div>
    <div class="row flex-xl-nowrap">
        <div class="col-3 d-none d-xl-block docs-toc">
            <!-- toc -->
            
<div class="">
    <ul class="nav toc-top">
        <li>
            <a href="#" id="back_to_top" class="docs-toc-title">目录</a>
        </li>
    </ul>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#rust-编译-webassembly-入门">Rust 编译 WebAssembly 入门</a>
      <ul>
        <li><a href="#可执行文件与库">可执行文件与库</a></li>
        <li><a href="#导出">导出</a></li>
        <li><a href="#abi">ABI</a></li>
        <li><a href="#导入">导入</a></li>
        <li><a href="#高级类型">高级类型</a></li>
      </ul>
    </li>
    <li><a href="#模块大小">模块大小</a>
      <ul>
        <li><a href="#自定义部分">自定义部分</a></li>
        <li><a href="#偷偷摸摸的膨胀">偷偷摸摸的膨胀</a></li>
        <li><a href="#恐慌">恐慌</a></li>
        <li><a href="#lto">LTO</a></li>
        <li><a href="#wasm-opt">wasm-opt</a></li>
      </ul>
    </li>
    <li><a href="#非标准">非标准</a>
      <ul>
        <li><a href="#向无操作系统设备学习">向无操作系统设备学习</a></li>
      </ul>
    </li>
    <li><a href="#内存管理">内存管理</a>
      <ul>
        <li><a href="#wee_alloc">wee_alloc</a></li>
      </ul>
    </li>
    <li><a href="#wasm-bindgen">wasm-bindgen</a></li>
    <li><a href="#wasm-pack">wasm-pack</a></li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
</div>

            <!-- /toc -->
            
            <div class="subscribe-module col-12 mt-1">
    <img src="/img/wechat.jpg" alt="image" title="云原生社区的微信公众号"/>
    <p class="text-center pt-1">关注「云原生社区动态」微信公众号，获取本站更新</p>
</div>

            
        </div>
        <main class="article-body col-9 container docs-content" role="main">
            <article class="article">
                <div class="article-style">
                    
                    <details class="toc-inpage d-print-none d-show-block mb-0">
  <summary class="font-weight-bold">点击查看目录</summary>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#rust-编译-webassembly-入门">Rust 编译 WebAssembly 入门</a>
      <ul>
        <li><a href="#可执行文件与库">可执行文件与库</a></li>
        <li><a href="#导出">导出</a></li>
        <li><a href="#abi">ABI</a></li>
        <li><a href="#导入">导入</a></li>
        <li><a href="#高级类型">高级类型</a></li>
      </ul>
    </li>
    <li><a href="#模块大小">模块大小</a>
      <ul>
        <li><a href="#自定义部分">自定义部分</a></li>
        <li><a href="#偷偷摸摸的膨胀">偷偷摸摸的膨胀</a></li>
        <li><a href="#恐慌">恐慌</a></li>
        <li><a href="#lto">LTO</a></li>
        <li><a href="#wasm-opt">wasm-opt</a></li>
      </ul>
    </li>
    <li><a href="#非标准">非标准</a>
      <ul>
        <li><a href="#向无操作系统设备学习">向无操作系统设备学习</a></li>
      </ul>
    </li>
    <li><a href="#内存管理">内存管理</a>
      <ul>
        <li><a href="#wee_alloc">wee_alloc</a></li>
      </ul>
    </li>
    <li><a href="#wasm-bindgen">wasm-bindgen</a></li>
    <li><a href="#wasm-pack">wasm-pack</a></li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
</details>

                    
                    <p>下面是我所知道的关于将 Rust 编译为 WebAssembly 的所有知识。</p>
<p>前一段时间，我写了一篇<a href="https://surma.dev/things/c-to-webassembly" target="_blank" rel="noopener">如何在没有 Emscripten 的情况下将 C 编译为 WebAssembly</a> 的博客文章，即不默认工具来简化这个过程。在 Rust 中，使 WebAssembly 变得简单的工具称为 <a href="https://rustwasm.github.io/wasm-bindgen/" target="_blank" rel="noopener">wasm-bindgen</a>，我们正在放弃它！同时，Rust 有点不同，因为 WebAssembly 长期以来一直是一流的目标，并且开箱即用地提供了标准库布局。</p>
<h2 id="rust-编译-webassembly-入门">Rust 编译 WebAssembly 入门</h2>
<p>让我们看看如何让 Rust 以尽可能少的偏离标准 Rust 工作流程的方式编译成 WebAssembly。如果你浏览互联网，许多文章和指南都会告诉你使用 <code>cargo init --lib</code> 创建一个 Rust 库项目，然后将 <code>crate-type = [&quot;cdylib&quot;]</code> 添加到你的 <code>cargo.toml</code>，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ini" data-lang="ini"><span class="line"><span class="cl"><span class="k">[package]</span>
</span></span><span class="line"><span class="cl"><span class="na">name</span> <span class="o">=</span> <span class="s">&#34;my_project&#34;</span>
</span></span><span class="line"><span class="cl"><span class="na">version</span> <span class="o">=</span> <span class="s">&#34;0.1.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="na">edition</span> <span class="o">=</span> <span class="s">&#34;2021&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">[lib]</span>
</span></span><span class="line"><span class="cl"><span class="na">crate-type</span> <span class="o">=</span> <span class="s">[&#34;cdylib&#34;]
</span></span></span><span class="line"><span class="cl"><span class="s">   </span>
</span></span><span class="line"><span class="cl"><span class="k">[dependencies]</span>
</span></span></code></pre></div><p>如果你不将 crate 类型设置为 <code>cdylib</code>，Rust 编译器将生成一个 <code>.rlib</code> 文件，这是 Rust 自己的库格式。虽然 <code>cdylib</code> 这个名字暗示了一个与 C 兼容的动态库，但我怀疑它真的只是代表“使用可互操作的格式”或类似的东西。</p>
<div class="alert-note-title">
    <p>什么是 crate?</p>
</div>
<div class="alert alert-note">
    <p>在 Rust 编程中，Crate（中文意思是 &ldquo;板条箱&rdquo;）指的是 Rust 语言中的包（Package），是 Rust 代码的一个单元，用于组织、构建和共享 Rust 代码。一个 Crate 可以包含一个或多个模块（Module），并且可以被其他 Crate 引用和使用。</p>
<p>每个 Crate 都需要有一个 Cargo.toml 文件作为其配置文件。Cargo.toml 中包含了 Crate 的元信息，如名称、版本、作者、依赖等信息。同时，Cargo.toml 中还可以定义编译器选项、环境变量等配置信息，用于构建和发布 Crate。</p>
<p>在 Rust 社区中，有很多优秀的 Crate 可以供使用。通过引用这些 Crate，可以快速、简便地开发高质量的 Rust 应用程序。同时，Rust 社区也鼓励开发者贡献自己的 Crate，以便其他开发者使用和贡献。</p>
<p>cdylib 也可以被称为 &ldquo;C-compatible Dynamic Library&rdquo;。cdylib Crate 可以通过 Rust 语言编写动态链接库，并将其导出为 C ABI（Application Binary Interface）。这使得其他语言（如 C、C++、Python、Java 等）可以通过 C ABI 接口调用 Rust 动态链接库中的函数和变量。这对于 Rust 与其他语言的互操作性非常重要，特别是在需要与现有代码进行集成的情况下。</p>
<p>使用 cdylib Crate 可以方便地创建和发布 Rust 动态链接库，并将其与其他语言进行集成。同时，cdylib Crate 也提供了一些与动态链接库相关的工具和 API，如动态链接库版本管理、符号导出等。这些工具和 API 可以方便地将 Rust 动态链接库的开发和集成过程变得更加简单、可靠和高效。</p>

</div>

<p>现在，我们将使用 Cargo 在创建新库时生成的默认/示例函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="n">left</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">right</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>一切就绪后，我们现在可以将这个库编译为 WebAssembly：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cargo build --target<span class="o">=</span>wasm32-unknown-unknown --release
</span></span></code></pre></div><p>你会在 <code>target/wasm32-unknown-unknown/release/my_project.wasm</code> 找到它。在整篇文章中，我将继续使用 <code>--release</code> 进行构建，因为它使 WebAssembly 模块在我们反汇编时更具可读性。</p>
<div class="alert-note-title">
    <p>什么是 Cargo？</p>
</div>
<div class="alert alert-note">
    <p>Cargo 是一个 Rust 项目管理工具，用于构建、测试、发布 Rust 应用程序和库。Cargo 提供了一个命令行界面和一组 Rust API，用于管理项目依赖、编译、测试和发布过程。</p>
<p>以下是 Cargo 提供的主要功能：</p>
<ol>
<li>依赖管理：Cargo 可以通过 Cargo.toml 文件管理 Rust 项目的依赖。当添加、更新或删除依赖时，Cargo 会自动处理依赖的版本控制、依赖解决和依赖编译等问题。</li>
<li>构建和测试：Cargo 可以使用 rustc 编译器构建 Rust 项目，并自动解决依赖关系。同时，Cargo 还支持项目测试和文档生成等功能。</li>
<li>发布和分发：Cargo 可以将 Rust 项目打包为 Crate 并发布到 crates.io 上，也可以将二进制文件打包为可执行文件并发布到其他平台上。</li>
</ol>
<p>通过使用 Cargo，开发者可以方便地创建、构建、测试和发布 Rust 应用程序和库。同时，Cargo 还提供了一些有用的工具和命令行选项，如清理项目、查询依赖、查看构建日志等，用于提高 Rust 项目的开发效率和质量。</p>

</div>

<h3 id="可执行文件与库">可执行文件与库</h3>
<p>你可以创建一个 Rust 可执行文件（通过 <code>cargo init --bin</code>），而不是创建一个库。但是请注意，你要么必须让 <code>main()</code> 函数具有完善的签名，要么使用 <code>#![no_main]</code> 关闭编译器以让它知道缺少 <code>main()</code> 是故意的。</p>
<p>那个更好吗？这对我来说似乎是一个品味问题，因为这两种方法在功能上似乎是等同的并且生成相同的 WebAssembly 代码。大多数时候，WebAssembly 模块似乎扮演了一个库的角色，而不是一个可执行文件（除了在 <a href="https://wasi.dev/" target="_blank" rel="noopener">WASI</a> 的上下文中，稍后会详细介绍！），所以在我看来，库方法在语义上似乎更可取。除非另有说明，否则我将在本文的其余部分使用库设置。</p>
<h3 id="导出">导出</h3>
<p>继续库样式的设置，让我们看看编译器生成的 WebAssembly 代码。为此，我推荐 <a href="https://github.com/WebAssembly/wabt" target="_blank" rel="noopener">WebAssembly Binary Toolkit</a>（简称“wabt”），它提供了有用的工具，如 wasm2wat。另外，请确保安装了 <a href="https://github.com/WebAssembly/binaryen" target="_blank" rel="noopener">Binarygen</a>，因为本文后面我们将需要 wasm-opt。Binaryen 还提供了 <code>wasm-dis</code>，其工作方式与 wasm2wat 类似，但不产生 WebAssembly 文本格式 (WAT)。它生成标准化程度较低的 WebAssembly S-Expression 文本格式 (WAST)。最后，ByteCodeAlliance 的 <a href="https://github.com/bytecodealliance/wasm-tools" target="_blank" rel="noopener">wasm-tools</a> 提供了 <code>wasm-tools print</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">wasm2wat ./target/wasm32-unknown-unknown/release/my_project.wasm
</span></span></code></pre></div><p>此命令会将 WebAssembly 二进制文件转换为 WAT：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">(</span><span class="nf">module</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">table</span> <span class="p">(;</span><span class="mi">0</span><span class="p">;)</span> <span class="mi">1</span> <span class="mi">1</span> <span class="n">funcref</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">memory</span> <span class="p">(;</span><span class="mi">0</span><span class="p">;)</span> <span class="mi">16</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="n">global</span> <span class="err">$</span><span class="nf">__stack_pointer</span> <span class="p">(</span><span class="n">mut</span> <span class="n">i32</span><span class="p">)</span> <span class="p">(</span><span class="n">i32</span><span class="p">.</span><span class="k">const</span> <span class="mi">1048576</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">global</span> <span class="p">(;</span><span class="mi">1</span><span class="p">;)</span> <span class="nf">i32</span> <span class="p">(</span><span class="n">i32</span><span class="p">.</span><span class="k">const</span> <span class="mi">1048576</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">global</span> <span class="p">(;</span><span class="mi">2</span><span class="p">;)</span> <span class="nf">i32</span> <span class="p">(</span><span class="n">i32</span><span class="p">.</span><span class="k">const</span> <span class="mi">1048576</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="n">export</span> <span class="s">&#34;memory&#34;</span> <span class="p">(</span><span class="n">memory</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="n">export</span> <span class="s">&#34;__data_end&#34;</span> <span class="p">(</span><span class="n">global</span> <span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="n">export</span> <span class="s">&#34;__heap_base&#34;</span> <span class="p">(</span><span class="n">global</span> <span class="mi">2</span><span class="p">)))</span>
</span></span></code></pre></div><p>令人发指的是，我们发现我们的 add 函数已从二进制文件中完全删除。我们只剩下一个堆栈指针和两个全局变量，它们指定数据部分的结束位置和堆的开始位置。事实证明，将函数声明为 <code>pub</code> 不足以让它出现在我们最终的 WebAssembly 模块中。我其实希望这就足够了，但我怀疑 Rust 模块可见性是唯一的，而不是链接器级别的符号可见性。</p>
<p>确保编译器不会删除我们关心的函数的最快方法是添加属性 <code>#[no_mangle]</code>，尽管我不喜欢这个命名。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#[no_mangle]
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">pub</span> <span class="n">fn</span> <span class="nf">add</span><span class="p">(</span><span class="nl">left</span><span class="p">:</span> <span class="n">usize</span><span class="p">,</span> <span class="nl">right</span><span class="p">:</span> <span class="n">usize</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">usize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">left</span> <span class="o">+</span> <span class="n">right</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>很少需要，但是你可以通过使用  <code>#[export_name = &quot;...&quot;]</code> 导出一个名称与其 Rust 内部名称不同的函数。</p>
<p>将我们的 <code>add</code> 函数标记为导出后，我们可以再次编译项目并检查生成的 WebAssembly 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="p">(</span><span class="nf">module</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">type</span> <span class="p">(;</span><span class="mi">0</span><span class="p">;)</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="n">param</span> <span class="n">i32</span> <span class="n">i32</span><span class="p">)</span> <span class="p">(</span><span class="n">result</span> <span class="n">i32</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="n">func</span> <span class="err">$</span><span class="nf">add</span> <span class="p">(</span><span class="n">type</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="n">param</span> <span class="n">i32</span> <span class="n">i32</span><span class="p">)</span> <span class="p">(</span><span class="n">result</span> <span class="n">i32</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">local</span><span class="p">.</span><span class="n">get</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">local</span><span class="p">.</span><span class="n">get</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">i32</span><span class="p">.</span><span class="n">add</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">table</span> <span class="p">(;</span><span class="mi">0</span><span class="p">;)</span> <span class="mi">1</span> <span class="mi">1</span> <span class="n">funcref</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">memory</span> <span class="p">(;</span><span class="mi">0</span><span class="p">;)</span> <span class="mi">16</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="n">global</span> <span class="err">$</span><span class="nf">__stack_pointer</span> <span class="p">(</span><span class="n">mut</span> <span class="n">i32</span><span class="p">)</span> <span class="p">(</span><span class="n">i32</span><span class="p">.</span><span class="k">const</span> <span class="mi">1048576</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">global</span> <span class="p">(;</span><span class="mi">1</span><span class="p">;)</span> <span class="nf">i32</span> <span class="p">(</span><span class="n">i32</span><span class="p">.</span><span class="k">const</span> <span class="mi">1048576</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">global</span> <span class="p">(;</span><span class="mi">2</span><span class="p">;)</span> <span class="nf">i32</span> <span class="p">(</span><span class="n">i32</span><span class="p">.</span><span class="k">const</span> <span class="mi">1048576</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="n">export</span> <span class="s">&#34;memory&#34;</span> <span class="p">(</span><span class="n">memory</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="n">export</span> <span class="s">&#34;add&#34;</span> <span class="p">(</span><span class="n">func</span> <span class="err">$</span><span class="n">add</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="n">export</span> <span class="s">&#34;__data_end&#34;</span> <span class="p">(</span><span class="n">global</span> <span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="n">export</span> <span class="s">&#34;__heap_base&#34;</span> <span class="p">(</span><span class="n">global</span> <span class="mi">2</span><span class="p">)))</span>
</span></span></code></pre></div><p>这个模块可以用普通的 WebAssembly API 实例化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">importObj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&#34;fs&#34;</span><span class="p">).</span><span class="nx">readFileSync</span><span class="p">(</span><span class="s2">&#34;./my_project.wasm&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">{</span><span class="nx">instance</span><span class="p">}</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">WebAssembly</span><span class="p">.</span><span class="nx">instantiate</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">importObj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Deno
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">Deno</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s2">&#34;./my_project.wasm&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">{</span><span class="nx">instance</span><span class="p">}</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">WebAssembly</span><span class="p">.</span><span class="nx">instantiate</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">importObj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// For Web, it’s advisable to use `instantiateStreaming` whenever possible:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s2">&#34;./my_project.wasm&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">{</span><span class="nx">instance</span><span class="p">}</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl">  <span class="kr">await</span> <span class="nx">WebAssembly</span><span class="p">.</span><span class="nx">instantiateStreaming</span><span class="p">(</span><span class="nx">response</span><span class="p">,</span> <span class="nx">importObj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">instance</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// returns 42
</span></span></span></code></pre></div><p>突然之间，我们几乎可以使用 Rust 的所有功能来编写 WebAssembly。</p>
<p>需要特别注意模块边界处的函数（即你从 JavaScript 调用的函数）。至少就目前而言，最好坚持使用<a href="https://webassembly.github.io/spec/core/syntax/types.html#number-types" target="_blank" rel="noopener">能够清晰映射到 WebAssembly 的类型</a>（如<code>i32</code>或<code>f64</code>）。如果你使用更高级别的类型，如数组、切片，甚至 <code>String</code>，该函数最终可能会使用比它们在 Rust 中更多的参数，并且通常需要对内存布局和类似原则有更深入的了解。</p>
<h3 id="abi">ABI</h3>
<p>请注意：是的，我们正在成功地将 Rust 编译为 WebAssembly。然而，在 Rust 版本中，可能会生成一个具有完全不同函数签名的 WebAssembly 模块。函数参数从调用者传递到被调用者的方式（例如作为指向内存的指针或作为立即值）是应用程序二进制接口定义或简称“ABI”的一部分。<code>rustc</code> 默认使用 Rust 的 ABI，它不稳定，主要考虑 Rust 内部。</p>
<p><code>rustc</code> 为了稳定这种情况，我们可以显式定义要为函数使用哪个 ABI。这是通过使用 <a href="https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier" target="_blank" rel="noopener"><code>extern</code></a> 关键字来完成的。跨语言函数调用的一个长期选择是 <a href="https://github.com/WebAssembly/tool-conventions/blob/main/BasicCABI.md" target="_blank" rel="noopener">C ABI</a>，我们将在此处使用它。C ABI 不会改变，所以我们可以确定我们的 WebAssembly 模块接口也不会改变。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[no_mangle]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="n">left</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">right</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="n">left</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">right</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>我们甚至可以省略 <code>&quot;C&quot;</code> 而只使用 <code>extern</code>，因为 C ABI 是默认的替代 ABI。</p>
<h3 id="导入">导入</h3>
<p>WebAssembly 的一个重要部分是它的沙箱。它确保在 WebAssembly VM 中运行的代码无法访问主机环境中的任何内容，除了通过 imports 对象显式传递到沙箱中的函数。</p>
<p>假设我们想在我们的 Rust 代码中生成随机数。我们可以引入 <code>rand</code> Rust 沙箱，但如果主机环境中已经有东西，为什么还要发布代码。作为第一步，我们需要声明我们的 WebAssembly 模块需要导入：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[link(wasm_import_module = </span><span class="s">&#34;Math&#34;</span><span class="cp">)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">random</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">f64</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[export_name = </span><span class="s">&#34;add&#34;</span><span class="cp">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="n">left</span>: <span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">right</span>: <span class="kt">f64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">random</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>extern &quot;C&quot;</code> 块（不要与上面的 <code>extern &quot;C&quot;</code> 函数混淆）声明编译器希望在链接时由“其他人”提供的函数。这通常是你在 Rust 中链接 C 库的方式，但该机制也适用于 WebAssembly。但是，外部函数总是隐式不安全的，因为编译器无法为非 Rust 函数提供任何安全保证。因此，除非我们将调用包装在 <code>unsafe { ... }</code> 块中，否则我们无法调用它们。</p>
<p>上面的代码可以编译，但不会运行。我们的 JavaScript 代码抛出错误，需要更新以满足我们指定的导入。导入对象是导入模块的字典，每个模块都是导入项的字典。在我们的 Rust 代码中，我们声明了一个导入模块&quot;Math&quot;，并期望一个被调用的函数&quot;random&quot;出现在该模块中。这些值当然是经过仔细选择的，这样我们就可以传入整个 Math 对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">importObj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">Math</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">random</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">importObj</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">Math</span> <span class="p">};</span>
</span></span></code></pre></div><p>为了避免到处注入 <code>unsafe { ... }</code>，通常需要编写包装函数来恢复 Rust 的安全不变量。这是 Rust 内联模块的一个很好的用例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">mod</span> <span class="nn">math</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">mod</span> <span class="nn">math_js</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="cp">#[link(wasm_import_module = </span><span class="s">&#34;Math&#34;</span><span class="cp">)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">random</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">f64</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">random</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">math_js</span>::<span class="n">random</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[export_name = </span><span class="s">&#34;add&#34;</span><span class="cp">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="n">left</span>: <span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">right</span>: <span class="kt">f64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">math</span>::<span class="n">random</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>顺便说一句，如果我们没有指定 <code>#[link(wasm_import_module = ...)]</code>属性，则函数将在默认 <code>env</code> 模块上运行。此外，就像你可以使用 <code>#[export_name = &quot;...&quot;]</code> 更改导出的函数的名称一样，你可以使用 <code>#[link_name = &quot;...&quot;]</code> 更改导入的函数的名称。</p>
<h3 id="高级类型">高级类型</h3>
<p>我之前说过，在模块边界处理函数的最有效方法是使用透明映射到 WebAssembly 支持的数据类型的值类型。当然，编译器允许你使用更复杂的类型作为函数的参数和值。在这些情况下，编译器生成 <a href="https://github.com/WebAssembly/tool-conventions/blob/main/BasicCABI.md" target="_blank" rel="noopener">C ABI</a> 中指定的代码（除了 rustc 目前不完全符合 C ABI 的<a href="https://github.com/rustwasm/team/issues/291" target="_blank" rel="noopener">不足</a>）。</p>
<p>无需赘述，类型大小（例如，struct、enum 等）就变成了一个简单的指针。数组和元组是有大小的类型，如果它们使用少于 32 位，它们将被转换为立即值。更复杂的情况是函数返回大于 32 位的数组类型的值：如果是这种情况，函数将不会收到返回值，而是会收到一个附加类型的参数 i32，该函数将利用指向此参数的指针来存储结果。如果一个函数返回一个元组，无论元组的大小如何，它总是被认为是函数的参数。</p>
<p><code>(?Sized)</code> 具有未指定类型的函数参数，例如 <code>str</code>、<code>[u8]</code> 或 <code>dyn MyTrait</code>，由两部分组成：第一部分是指向数据的指针，第二部分是指向元数据的指针。如果是 str 的一个或一部分，则元数据是数据的长度。在特征对象的实例中，它是一个虚拟表（或 vtable），它是指向各个特征函数实现的函数指针列表。如果你想了解更多有关 Rust 中的 VTable 的信息，我可以推荐 Thomas Bächler 的<a href="https://articles.bchlr.de/traits-dynamic-dispatch-upcasting" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>我在这里省略了重要的细节，因为建议你不要编写下一个 wasm-bindgen，除非你非要这样做。我建议依靠现有工具而不是创建新工具。</p>
<h2 id="模块大小">模块大小</h2>
<p>当 WebAssembly 部署在 web 上时，它的二进制文件的大小非常重要。每一点都必须通过网络传输并通过浏览器的 WebAssembly 编译器，因此，较小的二进制大小意味着在 WebAssembly 开始运行之前用户等待的时间更少。如果我们将默认项目构造为发布版本，我们将生成 1.7MB 的 WebAssembly。这对于两个数字相加的功能似乎太大了。</p>
<blockquote>
<p>数据部分：WebAssembly 模块的大部分由数据组成。即数据在特定点保存在内存中，然后复制到线性内存。这些部分的编译成本很低，因为编译器会跳过它们，在分析和减少模块的启动时间时请记住这一点。</p>
</blockquote>
<p>检查 WebAssembly 模块内部结构的一种简单方法是 <code>llvm-objdump</code>，这应该可以在你的系统上访问。或者，你可以使用 <code>wasm-objdump</code>，它是 wabt 的一部分，通常提供相同的接口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ llvm-objdump -h target/wasm32-unknown-unknown/release/my_project.wasm
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">target/wasm32-unknown-unknown/release/my_project.wasm: file format wasm
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Sections:
</span></span><span class="line"><span class="cl">Idx Name            Size     VMA      Type
</span></span><span class="line"><span class="cl">  <span class="m">0</span> TYPE            <span class="m">00000007</span> <span class="m">00000000</span>
</span></span><span class="line"><span class="cl">  <span class="m">1</span> FUNCTION        <span class="m">00000002</span> <span class="m">00000000</span>
</span></span><span class="line"><span class="cl">  <span class="m">2</span> TABLE           <span class="m">00000005</span> <span class="m">00000000</span>
</span></span><span class="line"><span class="cl">  <span class="m">3</span> MEMORY          <span class="m">00000003</span> <span class="m">00000000</span>
</span></span><span class="line"><span class="cl">  <span class="m">4</span> GLOBAL          <span class="m">00000019</span> <span class="m">00000000</span>
</span></span><span class="line"><span class="cl">  <span class="m">5</span> EXPORT          0000002b <span class="m">00000000</span>
</span></span><span class="line"><span class="cl">  <span class="m">6</span> CODE            <span class="m">00000009</span> <span class="m">00000000</span> TEXT
</span></span><span class="line"><span class="cl">  <span class="m">7</span> .debug_info     00062c72 <span class="m">00000000</span>
</span></span><span class="line"><span class="cl">  <span class="m">8</span> .debug_pubtypes <span class="m">00000144</span> <span class="m">00000000</span>
</span></span><span class="line"><span class="cl">  <span class="m">9</span> .debug_ranges   0002af80 <span class="m">00000000</span>
</span></span><span class="line"><span class="cl"> <span class="m">10</span> .debug_abbrev   <span class="m">00001055</span> <span class="m">00000000</span>
</span></span><span class="line"><span class="cl"> <span class="m">11</span> .debug_line     00045d24 <span class="m">00000000</span>
</span></span><span class="line"><span class="cl"> <span class="m">12</span> .debug_str      0009f40c <span class="m">00000000</span>
</span></span><span class="line"><span class="cl"> <span class="m">13</span> .debug_pubnames 0003e3f2 <span class="m">00000000</span>
</span></span><span class="line"><span class="cl"> <span class="m">14</span> name            0000001c <span class="m">00000000</span>
</span></span><span class="line"><span class="cl"> <span class="m">15</span> producers       <span class="m">00000043</span> <span class="m">00000000</span>
</span></span></code></pre></div><p><code>llvm-objdump</code> 过于笼统，为那些有使用其他语言汇编经验的人提供熟悉的命令行。然而，专门用于调试二进制字符串的大小，它缺少简单的工具，如按大小排序部分或按功能分解部分。幸运的是，有专门为此设计的 WebAssembly 专用工具 <a href="https://rustwasm.github.io/twiggy/" target="_blank" rel="noopener">Twiggy</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ twiggy top target/wasm32-unknown-unknown/release/my_project.wasm
</span></span><span class="line"><span class="cl"> Shallow Bytes │ Shallow % │ Item
</span></span><span class="line"><span class="cl">───────────────┼───────────┼─────────────────────────────────────────
</span></span><span class="line"><span class="cl">        <span class="m">652300</span> ┊    36.67% ┊ custom section <span class="s1">&#39;.debug_str&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="m">404594</span> ┊    22.75% ┊ custom section <span class="s1">&#39;.debug_info&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="m">285988</span> ┊    16.08% ┊ custom section <span class="s1">&#39;.debug_line&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="m">254962</span> ┊    14.33% ┊ custom section <span class="s1">&#39;.debug_pubnames&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="m">176000</span> ┊     9.89% ┊ custom section <span class="s1">&#39;.debug_ranges&#39;</span>
</span></span><span class="line"><span class="cl">          <span class="m">4181</span> ┊     0.24% ┊ custom section <span class="s1">&#39;.debug_abbrev&#39;</span>
</span></span><span class="line"><span class="cl">           <span class="m">324</span> ┊     0.02% ┊ custom section <span class="s1">&#39;.debug_pubtypes&#39;</span>
</span></span><span class="line"><span class="cl">            <span class="m">67</span> ┊     0.00% ┊ custom section <span class="s1">&#39;producers&#39;</span>
</span></span><span class="line"><span class="cl">            <span class="m">25</span> ┊     0.00% ┊ custom section <span class="s1">&#39;name&#39;</span> headers
</span></span><span class="line"><span class="cl">            <span class="m">20</span> ┊     0.00% ┊ custom section <span class="s1">&#39;.debug_pubnames&#39;</span> headers
</span></span><span class="line"><span class="cl">            <span class="m">19</span> ┊     0.00% ┊ custom section <span class="s1">&#39;.debug_pubtypes&#39;</span> headers
</span></span><span class="line"><span class="cl">            <span class="m">18</span> ┊     0.00% ┊ custom section <span class="s1">&#39;.debug_ranges&#39;</span> headers
</span></span><span class="line"><span class="cl">            <span class="m">17</span> ┊     0.00% ┊ custom section <span class="s1">&#39;.debug_abbrev&#39;</span> headers
</span></span><span class="line"><span class="cl">            <span class="m">16</span> ┊     0.00% ┊ custom section <span class="s1">&#39;.debug_info&#39;</span> headers
</span></span><span class="line"><span class="cl">            <span class="m">16</span> ┊     0.00% ┊ custom section <span class="s1">&#39;.debug_line&#39;</span> headers
</span></span><span class="line"><span class="cl">            <span class="m">15</span> ┊     0.00% ┊ custom section <span class="s1">&#39;.debug_str&#39;</span> headers
</span></span><span class="line"><span class="cl">            <span class="m">14</span> ┊     0.00% ┊ <span class="nb">export</span> <span class="s2">&#34;__heap_base&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="m">13</span> ┊     0.00% ┊ <span class="nb">export</span> <span class="s2">&#34;__data_end&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="m">12</span> ┊     0.00% ┊ custom section <span class="s1">&#39;producers&#39;</span> headers
</span></span><span class="line"><span class="cl">             <span class="m">9</span> ┊     0.00% ┊ <span class="nb">export</span> <span class="s2">&#34;memory&#34;</span>
</span></span><span class="line"><span class="cl">             <span class="m">9</span> ┊     0.00% ┊ add
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></div><p>现在很明显，模块大小的所有主要贡献者都是与模块用途无关的自定义组件。它们的标题暗示它们包含用于故障排除的信息，因此这些部分是为构建和发布而发出的这一事实有些不合常规。这似乎与我们代码的一个长期存在的问题有关，该问题导致它在编译时没有调试符号，但在我们的机器上预编译的标准库仍然有调试符号。</p>
<p>为了解决这个问题，我们在 <code>Cargo.toml</code> 中添加了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="p">[</span><span class="nx">profile</span><span class="p">.</span><span class="nx">release</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">strip</span> <span class="p">=</span> <span class="kc">true</span>
</span></span></code></pre></div><p>这将导致 <code>rustc</code> 删除所有自定义部分，包括为函数分配名称的部分。这可能不是我们想要的，因为 twiggy 的输出将只包含 <code>saycode[0]</code> 或类似的函数。如果你想维护函数名称，我们可以使用特定的模式来删除信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="p">[</span><span class="nx">profile</span><span class="p">.</span><span class="nx">release</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">strip</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="nx">strip</span> <span class="p">=</span> <span class="s2">&#34;debuginfo&#34;</span>
</span></span></code></pre></div><p>如果你想完全细粒度控制，你可以恢复并完全禁用 <code>rustc</code> 的 strip 方法，而是使用 <code>llvm-strip</code> 或 <code>wasm-strip</code>。这使你能够决定应保留哪些自定义部件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">llvm-strip --keep-section<span class="o">=</span>name target/wasm32-unknown-unknown/release/my_project.wasm
</span></span></code></pre></div><p>移除外层后，我们剩下一个与 116B 一样大或大于 116B 的块。拆解它会发现该模块的唯一目的是调用 add 并执行 <code>(f64.add (local.get 0) (local.get 1))</code>，这意味着 Rust 编译器能够生成最佳代码。当然，代码库的大小增加了，这使得掌握二进制大小变得更加困难。</p>
<h3 id="自定义部分">自定义部分</h3>
<blockquote>
<p>有趣的事实：我们可以使用 Rust 将我们的自定义部分添加到 WebAssembly 模块中。如果我们声明一个字节数组（不是切片！），我们可以添加一个 <code>#[link_section=...]</code> 属性来将这些字节打包到它自己的部分中。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">const</span><span class="w"> </span><span class="n">_</span>: <span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cp">#[link_section = </span><span class="s">&#34;surmsection&#34;</span><span class="cp">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="no">SECTION_CONTENT</span>: <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="sa">b</span><span class="s">&#34;hello world&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></div><p>我们可以使用 <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Module/customSections" target="_blank" rel="noopener"><code>WebAssembly.Module.customSection()</code> AP</a>I 或使用 <code>llvm-objdump</code> 提取这些数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ llvm-objdump -s -j surmsection target/wasm32-unknown-unknown/release/my_project.wasm
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">target/wasm32-unknown-unknown/release/my_project.wasm: file format wasm
</span></span><span class="line"><span class="cl">Contents of section surmsection:
</span></span><span class="line"><span class="cl"> <span class="m">0000</span> 68656c6c 6f20776f 726c64             hello world
</span></span></code></pre></div><h3 id="偷偷摸摸的膨胀">偷偷摸摸的膨胀</h3>
<p>我在网上看到一些关于 Rust 为看似很小的工作创建 WebAssembly 模块的抱怨。根据我的经验，Rust 创建的 WebAssembly 二进制文件可能很大的原因有以下三个：</p>
<ul>
<li>调试构建（即忘记将 <code>--release</code> 传递给 Cargo）</li>
<li>调试符号（即忘记运行 <code>llvm-strip</code>）</li>
<li>意外的字符串格式和恐慌</li>
</ul>
<p>我们已经看到了前两个。让我们仔细看看最后一个。这个无害的程序编译成 18KB 的 WebAssembly：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">static</span><span class="w"> </span><span class="no">PRIMES</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">nth_prime</span><span class="p">(</span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="no">PRIMES</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>好吧，也许它毕竟不是那么无害。你可能已经知道我要干嘛了。</p>
<h3 id="恐慌">恐慌</h3>
<p>快速浏览一下 twiggy 就会发现，影响 Wasm 模块大小的主要因素是与字符串格式化、恐慌和内存分配相关的函数。这说得通！参数 n 未清理并用于索引数组。Rust 别无选择，只能注入边界检查。如果边界检查失败，Rust 会崩溃，这是创建格式正确的错误消息和堆栈跟踪所必需的。</p>
<p>解决这个问题的一种方法是自己进行边界检查。Rust 的编译器非常擅长仅在需要时注入检查。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">nth_prime</span><span class="p">(</span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="no">PRIMES</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="no">PRIMES</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>可以说更惯用的方法是依靠<code>Option&lt;T&gt;</code>API 来控制错误情况的处理方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">nth_prime</span><span class="p">(</span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="no">PRIMES</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="no">PRIMES</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">).</span><span class="n">copied</span><span class="p">().</span><span class="n">unwrap_or</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>第三种方法是使用 <code>unchecked</code> Rust 明确提供的一些方法。这些为未定义的行为打开了大门，因此是 <code>unsafe</code>，但如果你能够承担起安全的重担，性能（或文件大小）的提高将是显着的！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">nth_prime</span><span class="p">(</span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="no">PRIMES</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="no">PRIMES</span><span class="p">.</span><span class="n">get_unchecked</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>我们可以尝试处理恐慌可能发生的位置，并尝试手动处理这些路径。然而，一旦我们开始依赖第三方 crate，成功的机会就会减少，因为我们无法轻易改变库内部处理错误的方式。</p>
<h3 id="lto">LTO</h3>
<p>我们可能不得不接受这样一个事实，即我们无法避免代码库中出现 panic 的代码路径。虽然我们可以尝试减轻恐慌的影响（我们会的！），但有一个相当强大的优化通常可以节省一些重要的代码。这个优化过程由 LLVM 提供，称为 <a href="https://llvm.org/docs/LinkTimeOptimization.html" target="_blank" rel="noopener">LTO（Link Time Optimization，链接时优化）</a>。 <code>rustc</code> 在将所有内容链接到最终二进制文件之前编译和优化每个 crate。然而，一些优化只有在链接后才会变得明显。例如，许多函数根据输入有不同的分支。在编译期间，你只会看到来自同一个 crate 的函数调用。在链接时，你知道对任何给定函数的所有可能调用，这意味着现在可以消除其中一些代码分支。</p>
<p>LTO 默认处于关闭状态，因为它是一项代价高昂的优化，会显着减慢编译时间，尤其是在较大的 crate 中。你可以通过在 Cargo.toml 中配置 <code>rustc</code> 的许多代码生成选项启用。具体来说，我们需要将这一行添加到我们的 <code>Cargo.toml</code> 中以在发布版本中启用 LTO：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="p">[</span><span class="nx">package</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;my_project&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;0.1.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">edition</span> <span class="p">=</span> <span class="s2">&#34;2021&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">lib</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">crate-type</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;cdylib&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">[</span><span class="nx">profile</span><span class="p">.</span><span class="nx">release</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">lto</span> <span class="p">=</span> <span class="kc">true</span>
</span></span></code></pre></div><p>启用 LTO 后，剥离的二进制文件减少到 2.3K，这令人印象深刻。LTO 的唯一成本是更长的链接时间，但如果二进制大小是一个问题，LTO 将成为一项利器，因为它“仅”花费构建时间并且不需要更改代码。</p>
<h3 id="wasm-opt">wasm-opt</h3>
<p>另一个几乎应该成为构建管道一部分的工具是来自 <a href="https://github.com/WebAssembly/binaryen" target="_blank" rel="noopener">binaryen</a> 的 <code>wasm-opt</code>。它是另一个优化过程的集合，完全在 WebAssembly VM 指令上工作，独立于生成它们的源语言。像 Rust 这样的高级语言有更多的信息可以用来应用更复杂的优化，所以 <code>wasm-opt</code> 不能替代你的语言编译器的优化。但是，它通常设法将模块大小减少几个额外的字节。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">wasm-opt -O3 -o output.wasm target/wasm32-unknown-unknown/my_project.wasm
</span></span></code></pre></div><p>在我们的例子中，<code>wasm-opt</code> 进一步缩小了 Rust 的 2.3K WebAssembly 二进制文件，最后是 2.0K。好的！但别担心，我不会就此打住。这对于数组中的查找来说仍然太大了。</p>
<h2 id="非标准">非标准</h2>
<p>Rust 有一个<a href="https://docs.rs/std" target="_blank" rel="noopener">标准库</a>，其中包含你每天进行系统编程时所需的许多抽象和实用程序：访问文件、获取当前时间或打开网络套接字。一切都在那里供你使用，无需去 <a href="https://crates.io/" target="_blank" rel="noopener">crates.io</a> 或类似网站上搜索。然而，许多数据结构和函数对它们的使用环境做出了假设：它们假设硬件的细节被抽象成一个统一的 API，并且它们假设它们可以以某种方式分配（和释放）任意大小的内存块。通常，这两项工作都是由操作系统完成的，我们大多数人每天都在操作系统上工作。</p>
<p>但是，当你通过原始 API 实例化 WebAssembly 模块时，情况就不同了：沙箱（WebAssembly 的定义安全功能之一）将 WebAssembly 代码与主机隔离开来，从而与操作系统隔离开来。你的代码只能访问一大块线性内存，它甚至无法弄清楚哪些部分正在使用，哪些部分可以使用。</p>
<blockquote>
<p>WASI：这不是本文的一部分，但就像 WebAssembly 是对运行代码的处理器的抽象一样，<a href="https://wasi.dev/" target="_blank" rel="noopener">WASI</a>（WebAssembly 系统接口）旨在成为对运行代码的操作系统的抽象，并为你提供可以使用单一、统一的 API。Rust 支持 WASI，尽管 WASI 本身仍在发展中。</p>
</blockquote>
<p>这意味着 Rust 给了我们一种虚假的安全感！它为我们提供了一个没有操作系统支持的完整标准库。事实上，许多 stdlib 模块只是别名或者失败了。也就是说，它们在没有操作系统支持的情况下不能正常工作。在没有操作系统支持的情况下，许多返回 <code>Result &lt;T&gt;</code> 类型的函数可能会因为无法正常工作而始终返回 Err，这意味着无法得到正确的操作结果。同样，其他一些函数可能会因为无法正常工作而导致程序崩溃。</p>
<h3 id="向无操作系统设备学习">向无操作系统设备学习</h3>
<p>只是一个线性内存块。没有管理内存或外围设备的中央实体。只是算术。如果你曾经使用过嵌入式系统，这听起来可能很熟悉。虽然现代嵌入式系统运行 Linux，但较小的微处理器没有资源来这样做。 <a href="https://www.rust-lang.org/what/embedded" target="_blank" rel="noopener">Rust 还针对那些超受限环境</a>，<a href="https://docs.rust-embedded.org/book/" target="_blank" rel="noopener">Embedded Rust Book</a> 和 <a href="https://docs.rust-embedded.org/embedonomicon/" target="_blank" rel="noopener">Embedomicon</a> 解释了如何为这些环境正确编写 Rust。</p>
<p>要进入裸机世界🤘，我们必须在代码中添加一行：<code>#![no_std]</code>。这个 crate 宏告诉 Rust 不要链接到标准库。相反，它只链接到 <a href="https://docs.rs/core" target="_blank" rel="noopener">core</a>。Embedonomicon 非常简洁地<a href="https://docs.rust-embedded.org/embedonomicon/smallest-no-std.html#what-does-no_std-mean" target="_blank" rel="noopener">解释</a>了这意味着什么：</p>
<blockquote>
<p><code>core</code> crate 是 <code>std</code> crate 的子集，它对程序将在其上运行的系统做出零假设。因此，它为语言原语（如浮点数、字符串和切片）提供 API，以及公开处理器功能（如原子操作和 SIMD 指令）的 API。但是，它缺少任何处理堆内存分配和 I/O 的 API。</p>
<p>对于应用程序，std 不仅仅是提供一种访问操作系统抽象的方法。std 还负责设置堆栈溢出保护、处理命令行参数以及在调用程序的主函数之前生成主线程。 <code>#![no_std]</code> 应用程序缺少所有标准运行时，因此如果需要它必须初始化自己的运行时。</p>
</blockquote>
<p>这听起来有点可怕，但让我们一步一步来。我们首先将上面的 panic-y 素数程序声明为 <code>no_std</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#![no_std]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">static</span><span class="w"> </span><span class="no">PRIMES</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">nth_prime</span><span class="p">(</span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="no">PRIMES</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>很遗憾，Embedonomicon 段落预示了这一点。因为我们没有提供核心依赖项的一些基础知识。在列表的最顶部，我们需要定义在这种环境中发生恐慌时应该发生什么。这是由恰当命名的恐慌处理程序完成的，Embedonomicon 给出了一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[panic_handler]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">panic</span><span class="p">(</span><span class="n">_panic</span>: <span class="kp">&amp;</span><span class="nc">core</span>::<span class="n">panic</span>::<span class="n">PanicInfo</span><span class="o">&lt;</span><span class="nb">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>这对于嵌入式系统来说是非常典型的，有效地阻止了处理器在崩溃发生后进行任何进一步的处理。然而，这在 web 上不是好的行为，所以对于 WebAssembly，我通常选择手动发出无法访问的指令来阻止任何 Wasm VM 运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[panic_handler]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">panic</span><span class="p">(</span><span class="n">_panic</span>: <span class="kp">&amp;</span><span class="nc">core</span>::<span class="n">panic</span>::<span class="n">PanicInfo</span><span class="o">&lt;</span><span class="nb">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">core</span>::<span class="n">arch</span>::<span class="n">wasm32</span>::<span class="n">unreachable</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>有了这个，我们的程序再次编译。剥离和 <code>wasm-opt</code> 后，二进制文件大小为 168B。极简主义再次获胜！</p>
<h2 id="内存管理">内存管理</h2>
<p>当然，我们因非标准而放弃了很多。没有堆分配，就没有 <code>Box</code>，没有 <code>Vec</code>，没有 <code>String</code> 和许多其他有用的东西。幸运的是，我们可以在不放弃整个操作系统的情况下取回这些东西。</p>
<p><code>std</code> 提供的很多东西实际上只是来自 <code>core</code> 的另一个称为 <code>alloc</code> 的东西。 <code>alloc</code> 包含有关内存分配和依赖于它的数据结构的所有内容。通过导入它，我们可以重新获得我们信任的 <code>Vec</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#![no_std]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// One of the few occastions where we have to use `extern crate`
</span></span></span><span class="line"><span class="cl"><span class="c1">// even in Rust Edition 2021.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">alloc</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">alloc</span>::<span class="n">vec</span>::<span class="nb">Vec</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[no_mangle]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">nth_prime</span><span class="p">(</span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Please enjoy this horrible implementation of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// The Sieve of Eratosthenes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">primes</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">primes</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">primes</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">any</span><span class="p">(</span><span class="o">|</span><span class="n">prime</span><span class="o">|</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">prime</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">primes</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">current</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">primes</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">last</span><span class="p">().</span><span class="n">unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[panic_handler]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">panic</span><span class="p">(</span><span class="n">_panic</span>: <span class="kp">&amp;</span><span class="nc">core</span>::<span class="n">panic</span>::<span class="n">PanicInfo</span><span class="o">&lt;</span><span class="nb">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">core</span>::<span class="n">arch</span>::<span class="n">wasm32</span>::<span class="n">unreachable</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>当然，尝试编译它会失败——我们实际上并没有告诉 Rust 我们的内存管理是什么样的，Vec 需要知道它才能运行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cargo build --target<span class="o">=</span>wasm32-unknown-unknown --release
</span></span><span class="line"><span class="cl">error: no global memory allocator found but one is required<span class="p">;</span> 
</span></span><span class="line"><span class="cl">  link to std or add <span class="sb">`</span><span class="c1">#[global_allocator]` to a static item that implements </span>
</span></span><span class="line"><span class="cl">  the GlobalAlloc trait
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">error: <span class="sb">`</span><span class="c1">#[alloc_error_handler]` function required, but not found</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">note: use <span class="sb">`</span><span class="c1">#![feature(default_alloc_error_handler)]` for a default error handler</span>
</span></span></code></pre></div><p>在撰写本文时，在 Rust 1.67 中，你需要提供一个在分配失败时调用的错误处理程序。在下一个版本中，Rust 1.68 <code>default_alloc_error_handler</code> 已经稳定下来，这意味着每个非标准的 Rust 程序都将带有这个错误处理程序的默认实现。如果你仍想提供自己的错误处理程序，你可以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[alloc_error_handler]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">alloc_error</span><span class="p">(</span><span class="n">_</span>: <span class="nc">core</span>::<span class="n">alloc</span>::<span class="n">Layout</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">core</span>::<span class="n">arch</span>::<span class="n">wasm32</span>::<span class="n">unreachable</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>有了这个复杂的错误处理程序，我们最终应该提供一种方法来进行实际的内存分配。就像我在 <a href="https://surma.dev/things/c-to-webassembly" target="_blank" rel="noopener">C 到 WebAssembly</a> 的文章中一样，我的自定义分配器将是一个最小的 bump 分配器，它往往又快又小，但不会释放内存。我们静态分配一个 arena 作为我们的堆，并跟踪“空闲区域”的开始位置。由于我们不使用 Wasm 线程，因此我也会忽略线程安全。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">core</span>::<span class="n">cell</span>::<span class="n">UnsafeCell</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="no">ARENA_SIZE</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[repr(C, align(32))]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">SimpleAllocator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">arena</span>: <span class="nc">UnsafeCell</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="no">ARENA_SIZE</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">head</span>: <span class="nc">UnsafeCell</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">SimpleAllocator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">SimpleAllocator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">arena</span>: <span class="nc">UnsafeCell</span>::<span class="n">new</span><span class="p">([</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="no">ARENA_SIZE</span><span class="p">]),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">head</span>: <span class="nc">UnsafeCell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SimpleAllocator</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[global_allocator]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">static</span><span class="w"> </span><span class="no">ALLOCATOR</span>: <span class="nc">SimpleAllocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimpleAllocator</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div><p>将 <code>#[global_allocator]</code> 全局变量标记为管理堆的实体。此变量的类型必须实现 GlobalAlloc 特性。特性上的 GlobalAlloc 方法都使用 &amp;self，所以如果你想修改数据类型中的任何值，你必须使用内部可变性。我这里选择了 UnsafeCell。使用 UnsafeCell 使我们的结构隐式 !Sync，Rust 不允许全局静态变量。这就是为什么我们还必须手动实现 Synctrait 来告诉 Rust 我们知道我们有责任使这种数据类型成为线程安全的（而我们完全忽略了这一点）。</p>
<p>该结构被标记为 <code>#[repr(C)]</code> 的原因很简单，以便我们可以手动指定对齐方式。这样我们就可以确保即使是 arena 中的第一个字节（以及我们返回的第一个指针的扩展）也具有 32 位对齐，这应该可以满足大多数数据结构。</p>
<p>现在为特征的 GlobalAlloc 的实际实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">GlobalAlloc</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SimpleAllocator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span>: <span class="nc">Layout</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">layout</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">align</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">layout</span><span class="p">.</span><span class="n">align</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Find the next address that has the right alignment.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">get</span><span class="p">()).</span><span class="n">next_multiple_of</span><span class="p">(</span><span class="n">align</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Bump the head to the next free byte
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">arena</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="no">ARENA_SIZE</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">arena</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// If we ran out of arena space, we return a null pointer, which
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// signals a failed allocation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">get_mut</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">core</span>::<span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dealloc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">_layout</span>: <span class="nc">Layout</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="cm">/* lol */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><code>#[global_allocator]</code> 不仅仅是 <code>#[no_std]</code>！你还可以使用它来覆盖 Rust 的默认分配器并将其替换为你自己的分配器，因为 Rust 的默认分配器消耗大约 10K Wasm 空间。</p>
<h3 id="wee_alloc">wee_alloc</h3>
<p>当然，你不必自己实现分配器。事实上，依靠经过良好测试的实施可能是明智的。处理分配器中的错误和微妙的内存损坏并不好玩。</p>
<p>许多指南推荐 <code>wee_alloc</code>，这是一个非常小的 (&lt;1KB) 分配器，由 Rust WebAssembly 团队编写，也可以释放内存。可悲的是，它似乎没有得到维护，并且有一个<a href="https://github.com/rustwasm/wee_alloc/issues/105" target="_blank" rel="noopener">关于内存损坏和内存泄漏的未解决问题</a>。</p>
<p>在任何相当复杂的 WebAssembly 模块中，Rust 的默认分配器消耗的 10KB 只是整个模块大小的一小部分，所以我建议坚持使用它并知道分配器经过良好测试和性能。</p>
<h2 id="wasm-bindgen">wasm-bindgen</h2>
<p>现在我们已经完成了几乎所有困难的事情，我们已经看到了使用 <a href="https://rustwasm.github.io/wasm-bindgen/" target="_blank" rel="noopener">wasm-bindgen</a> 为 WebAssembly 编写 Rust 的便捷方法。</p>
<p>wasm-bindgen 的关键特性是 <code>#[wasm_bindgen]</code> 宏，我们可以将它放在我们想要导出的每个函数上。这个宏添加了我们在本文前面手动添加的相同编译器指令，但它还做了一些更有用的事情。</p>
<p>例如，如果我们将上面的宏添加到我们的 <code>add</code> 函数中，它会发出另一个以<a href="https://github.com/rustwasm/wasm-bindgen/blob/main/crates/cli-support/src/descriptor.rs" target="_blank" rel="noopener">数字格式</a>返回我们的函数 <code>__wbindgen_describe_add</code> 的描述。具体来说，我们函数的描述符如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="n">Function</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Function</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">arguments</span>: <span class="p">[</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">U32</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">U32</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">],</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">shim_idx</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ret</span>: <span class="nc">U32</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">inner_ret</span>: <span class="nb">Some</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">U32</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w">
</span></span></span></code></pre></div><p>这是一个非常简单的函数，但是 wasm-bindgen 中的描述符能够表示非常复杂的函数签名。</p>
<blockquote>
<p><strong>展开：</strong> 如果你想查看宏发出的代码 <code>#[wasm_bindgen]</code>，请使用 rust-analyzer 的“递归扩展宏”功能。你可以通过命令面板在 VS Code 运行它。</p>
</blockquote>
<p>这些描述符有什么用？wasm-bindgen 不仅提供了一个宏，它还附带了一个 CLI，我们可以使用它来对我们的 Wasm 二进制文件进行后处理。CLI 提取这些描述符并使用此信息生成自定义 JavaScript 绑定（然后删除所有不再需要的描述符函数）。生成的 JavaScript 具有处理更高级别类型的所有例程，允许你无缝传递类型，例如字符串、<code>ArrayBuffer</code> 甚至闭包。</p>
<p>如果你想为 WebAssembly 编写 Rust，我推荐 wasm-bindgen。wasm-bindgen 不适用于 <code>#![no_std]</code>，但实际上这很少成为问题。</p>
<h2 id="wasm-pack">wasm-pack</h2>
<p>我还想提一下 <a href="https://rustwasm.github.io/wasm-pack/" target="_blank" rel="noopener">wasm-pack</a>，这是另一个用于 WebAssembly 的 Rust 工具。我们使用全套工具来编译和处理我们的 WebAssembly 以优化最终结果。<code>wasm-pack</code> 是一种对大多数这些过程进行编码的工具。它可以使用针对 WebAssembly 优化的所有设置引导一个新的 Rust 项目。它构建项目并使用所有正确的标志调用 <code>cargo</code>，然后它调用 <code>wasm-bindgen</code> CLI 来生成绑定，最后它运行 <code>wasm-opt</code> 以确保我们不会留下任何性能问题。<code>wasm-pack</code> 还能够准备你的 WebAssembly 模块以发布到 npm，但我个人从未使用过该功能。</p>
<h2 id="总结">总结</h2>
<p>Rust 是一种用于 WebAssembly 的优秀语言。启用 LTO 后，你将获得非常小的模块。Rust 的 WebAssembly 工具非常出色，自从我第一次在 <a href="https://squoosh.app/" target="_blank" rel="noopener">Squoosh</a> 中使用它以来，它变得更好了。发出的胶水代码 <code>wasm-bindgen</code> 既现代又 tree-shaken。看到它在幕后是如何工作的，我从中获得了很多乐趣，它帮助我理解和欣赏所有工具为我所做的事情。我希望你也有同感。非常感谢 <a href="https://twitter.com/opinionatedpie" target="_blank" rel="noopener">Ingrid</a>、<a href="https://twitter.com/rreverser" target="_blank" rel="noopener">Ingvar</a> 和 <a href="https://twitter.com/saulecabrera/" target="_blank" rel="noopener">Saul</a> 审阅这篇文章。</p>

                </div>
                

<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/webassembly/">WebAssembly</a>
  
  <a class="badge badge-light" href="/tag/rust/">Rust</a>
  
</div>











  
  
    



  
  
  
  
  
  <div class="media author-card content-widget-hr mb-4">
    

    <div class="media-body">
      <p class="card-title"><a href="/author/surma/">Surma</a></p>
      
      
      
    </div>
  </div>


  





<div class="article-widget">
  
<div class="container-xl row post-nav">
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1" href="/blog/role-based-access-control-five-common-authorization-patterns/" rel="next">
    <div class="meta-nav">下一页</div>
    <p>基于角色的访问控制：五种常见的授权模型</p></a>
  
  
  
  <a class="col-6 post-nav-item btn btn-lg mb-md-1"  href="/blog/not-a-supplier/" rel="prev">
    <div class="meta-nav">上一页</div>
    <p>我不是供应商</p></a>
  
</div>

</div>










  

<p class="edit-page">
  <a href="https://github.com/cloudnativeto/cloudnative.to/edit/master/content/blog/rust-to-wasm/index.md">
    <i class="fas fa-pen pr-2"></i>编辑本页
  </a>
</p>




  
  
  <div class="article-widget content-widget-hr">
    <p class="related-title">相关推荐</p>
    <ul>
      
      <li><a href="/blog/is-it-too-early-to-leverage-ai-for-webassembly/">将 AI 应用于 WebAssembly 还为时过早吗？</a></li>
      
      <li><a href="/blog/docker-without-containers/">WebAssembly：无需容器就能运行 Docker！</a></li>
      
      <li><a href="/blog/docker-wasm-quick-intro/">用 Docker 和 WebAssembly 打造容器的新时代！</a></li>
      
      <li><a href="/blog/spin-wasm-ga/">初创公司 Fermyon 发布 Spin 1.0 用于 WebAssembly 无服务器应用</a></li>
      
      <li><a href="/blog/wasm-containers/">使用 OCI 容器运行 WebAssembly 工作负载</a></li>
      
    </ul>
  </div>
  





  
  
  

  

  
  <section id="comments" class="mb-3 pt-0">
    <script>
  let themeNumber = localStorage.getItem('wcTheme');
  var giscusTheme = "light";
  if (themeNumber == 1){
    giscusTheme = "dark";
  }
  let giscusAttributes = {
    "src": "https://giscus.app/client.js",
    "data-theme": giscusTheme,
    "data-repo":"cloudnativeto\/cloudnative.to",
    "data-repo-id":"MDEwOlJlcG9zaXRvcnkyMzc3NDUxOTA=",
    "data-category":"General",
    "data-category-id":"MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMyMDU5MzUy",
    "data-mapping":"pathname",
    "data-reactions-enabled":"",
    "data-emit-metadata":"0",
    "data-input-position":"top",
    "data-theme":giscusTheme,
    "data-lang":"zh-CN",
    "data-loading":"lazy",
    "crossorigin":"annoymous",
    "origins":"https://cloudnative.to",
    "originsRegex":"http://localhost:[0-9]+",
    "async": "",
  };

  let giscusScript = document.createElement("script");
  Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
  document.querySelector('#comments').appendChild(giscusScript);
</script>

  </section>
  



            </article>
        </main>
    </div>
</div>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">

  



  

  
  <div class="copyright py-4 bg-footer">
      <div class="row justify-content-center">
        <div class="text-center footer-color">
          <p class="mb-0">© 2020-2024 云原生社区保留所有权利</p>
        </div>
    </div>
  </div>

</footer>

    </div>
    
  </div>

  


<script src="/js/vendor-bundle.min.b4708d4364577c16ab7001b265a063a4.js"></script>




  

  
  

  

  
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/highlight.min.js" integrity="sha512-Ypjm0o7jOxAd4hpdoppSEN0TQOC19UtPAqD+4s5AlXmUvbmmS/YMxYqAqarQYyxTnB6/rqip9qcxlNB/3U9Wdg==" crossorigin="anonymous"></script>
    
    
  










  
  <script id="search-hit-fuse-template" type="text/x-template">
    <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <div class="article-metadata search-hit-type">{{relpermalink}}</div>
          <a href="{{relpermalink}}">{{title}}</a>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
    </div>
  </script>
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin="anonymous"></script>
  












  
  
  
  
  
  
  







<script id="page-data" type="application/json">{"use_headroom":false}</script>










  
  


<script src="/zh/js/wowchemy.min.27bfa4a749fe1d78b45ea21d607b67f4.js"></script>







<script>

var mybutton = document.getElementById("backTopBtn");


window.onscroll = function() {scrollFunction()};

function scrollFunction() {
  if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
    mybutton.style.display = "block";
  } else {
    mybutton.style.display = "none";
  }
}


function topFunction() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
</script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
<script>
  anchors.add();
</script>



<script>



(function() {
  'use strict';

  if(!document.queryCommandSupported('copy')) {
    return;
  }

  function flashCopyMessage(el, msg) {
    el.className = "highlight-copy-btn";
    el.textContent = msg;
    setTimeout(function() {
      el.textContent = "";
      el.className = "highlight-copy-btn fa fa-copy";
    }, 1000);
  }

  function selectText(node) {
    var selection = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
    return selection;
  }

  function addCopyButton(containerEl) {
    var copyBtn = document.createElement("button");
    copyBtn.className = "highlight-copy-btn fa fa-copy";
    copyBtn.textContent = "";

    var codeEl = containerEl.firstElementChild;
    copyBtn.addEventListener('click', function() {
      try {
        var selection = selectText(codeEl);
        document.execCommand('copy');
        selection.removeAllRanges();
        
        flashCopyMessage(copyBtn, '已复制')
        
      } catch(e) {
        console && console.log(e);
        flashCopyMessage(copyBtn, 'Failed :\'(')
      }
    });

    containerEl.appendChild(copyBtn);
  }

  
  var highlightBlocks = document.getElementsByClassName('highlight');
  Array.prototype.forEach.call(highlightBlocks, addCopyButton);
})();
</script>



<script>

function Collapse(e){
  var node = document.getElementById(e);
  if (node.className.indexOf('fa-angle-down') > -1){
    node.setAttribute("class", "fa-solid fa-angle-right");
    }else{
    node.setAttribute("class", "fa-solid fa-angle-down");
    }
}
</script>


</body>
</html>
