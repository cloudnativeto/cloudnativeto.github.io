<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>狄卫华 | 云原生社区（中国）</title>
    <link>https://cloudnative.to/translators/%E7%8B%84%E5%8D%AB%E5%8D%8E/</link>
      <atom:link href="https://cloudnative.to/translators/%E7%8B%84%E5%8D%AB%E5%8D%8E/index.xml" rel="self" type="application/rss+xml" />
    <description>狄卫华</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 13 Dec 2018 19:23:09 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/translators/%E7%8B%84%E5%8D%AB%E5%8D%8E/avatar_hu3a395957e706dd9a75beaeb8d444caf4_12610_270x270_fill_q75_lanczos_center.jpg</url>
      <title>狄卫华</title>
      <link>https://cloudnative.to/translators/%E7%8B%84%E5%8D%AB%E5%8D%8E/</link>
    </image>
    
    <item>
      <title>微服务生态从百家争鸣阶段演化到服务网格</title>
      <link>https://cloudnative.to/blog/from-fragmented-microservices-ecosystem-to-service-mesh/</link>
      <pubDate>Thu, 13 Dec 2018 19:23:09 +0800</pubDate>
      <guid>https://cloudnative.to/blog/from-fragmented-microservices-ecosystem-to-service-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.avinetworks.com/from-fragmented-microservices-ecosystem-to-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在过去几年中，我们注意到应用程序架构正在迅速转变为分布式微服务架构——单体和庞大的应用程序被分解为更小的单个服务，其可被独立修改、构建、部署和管理。这种模式的主要优点就是简洁和快速，同时由于其对其他服务的依赖性很小或者完全没有依赖，更易于升级和独立扩展。这与敏捷和DevOps理念非常吻合，这种模式也已经被许多规模化的Web公司成功采用。过去的许多年中，这些公司中的大多数都能够很好地采用这种模式，但是近几年中成功将这种模式发扬光大的两大推手非Docker和Kubernetes莫属。Docker简化了将微服务构建为Linux容器的过程，Kubernetes则能够以资源优化的方式来部署、管理和扩展服务。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6290u94jj30p70cn763_hu256c4b7089550d7a772476741821216b_53684_d1ad04b0065ff1799f2f6c9185c80be5.webp 400w,
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6290u94jj30p70cn763_hu256c4b7089550d7a772476741821216b_53684_0762cbe556cb8b0f70b70a33ff603ff1.webp 760w,
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6290u94jj30p70cn763_hu256c4b7089550d7a772476741821216b_53684_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6290u94jj30p70cn763_hu256c4b7089550d7a772476741821216b_53684_d1ad04b0065ff1799f2f6c9185c80be5.webp&#34;
               width=&#34;760&#34;
               height=&#34;381&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;应用架构演进&#34;&gt;应用架构演进&lt;/h2&gt;
&lt;p&gt;在这篇博客中，我们不会花太多时间讨论微服务架构的优缺点。相反，我们将专注于在向基于微服务构建的云原生架构的重大转变上。&lt;/p&gt;
&lt;p&gt;虽然微服务架构提供了灵活性，但其也带有复杂性。Kubernetes在部署和管理微服务方面发挥了非常重要的作用，但我们需要的不仅仅是单一的运行在生产环境中的云原生应用程序——还需要在服务发现、安全性、流量管理等方面需要更加深入的了解。尤其是在相互通信的成千上百个服务经常被删除、生产、扩展和更新的复杂环境下，深入的了解更加有必要性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6296ogt3j30qf0b9wfx_huddc5a70ed1fde762be0e65622e51fd2b_41433_95b554d68509ecdc94ee5aecea2855d5.webp 400w,
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6296ogt3j30qf0b9wfx_huddc5a70ed1fde762be0e65622e51fd2b_41433_1a4568dd4d4b7baa9860518836e1719b.webp 760w,
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6296ogt3j30qf0b9wfx_huddc5a70ed1fde762be0e65622e51fd2b_41433_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6296ogt3j30qf0b9wfx_huddc5a70ed1fde762be0e65622e51fd2b_41433_95b554d68509ecdc94ee5aecea2855d5.webp&#34;
               width=&#34;760&#34;
               height=&#34;324&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;微服务架构面临的挑战&#34;&gt;微服务架构面临的挑战&lt;/h2&gt;
&lt;p&gt;这种规模化和动态化对于早期运行单体程序和管理应用程序的基础设施带来了具体的转变。为支持这种动态环境，新一代架构需要在生态系统中补充大量的新技术。为了交付所有的用户场景，我们需要在基础架构栈的每个级别上提供多个解决方案。根据需要，基础架构人员开始将这些技术集成到平台上，但这也意味着程序开发人员需要额外的负担来支持这些技术。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy629doo63j30rd0cedif_hu4ac12c2f7930e076ff1cec64f97b4603_72134_0101c53b3c274ca063b03daf8b45b1bc.webp 400w,
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy629doo63j30rd0cedif_hu4ac12c2f7930e076ff1cec64f97b4603_72134_a5d87365d649ba4ffbf72270f0f3ee56.webp 760w,
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy629doo63j30rd0cedif_hu4ac12c2f7930e076ff1cec64f97b4603_72134_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy629doo63j30rd0cedif_hu4ac12c2f7930e076ff1cec64f97b4603_72134_0101c53b3c274ca063b03daf8b45b1bc.webp&#34;
               width=&#34;760&#34;
               height=&#34;344&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;基础架构栈高层视图&#34;&gt;基础架构栈高层视图&lt;/h2&gt;
&lt;p&gt;这不是人们所期望的，并且也绝对不是微服务架构做出的的敏捷性、易于开发和部署的承诺。&lt;/p&gt;
&lt;p&gt;此后出现了服务网格的理念，这也是Avi Networks在此术语被创造之前一直专注于为客户提供的内容，并且由Istio和Linkerd等开源项目推动下形成了事实上的标准。我们很高兴看到社区热情拥抱了服务网格，而且我们也认为服务网格是微服务基础架构的必要组成部分。&lt;/p&gt;
&lt;p&gt;那么什么是 “服务网格” ，其如何帮助解决这些问题的呢？服务网格实质上是提供了上面图中在基础架构中的多层服务，与此同时程序开发者无需集成或修改代码就可以利用这些服务。它不仅使服务之间的通信快速可靠，而且服务网络还提供细粒度的流量管理、故障恢复、安全（加密、授权和认证）和可观察性（如跟踪、日志和监控）。所有这些都是从使用某种架构的开发人员中抽象出来的，其中所有服务间的通信都流经sidecar代理，代理与每个服务一起部署，从而创建一个服务网格。Sidecar由集中控制平面管理配置，用于流量路由和策略实施。尽管运行与应用程序容器一样多的sidecar容器一直是争论的焦点，但服务网格的优势和功能似乎超过了运维问题。&lt;/p&gt;
&lt;p&gt;在本博客系列的其余部分，我将深入探讨如何实现服务网格，并使用Istio的参考架构来完成旅程，因为Istio是当前最广泛使用和最知名的服务网格解决方案之一。但Istio是否解决了所有问题，并且在处理当今微服务世界中存在的重要场景方面是否完整？我们将深入探讨这一点，并在本系列的后续部分讨论所有内容。 敬请关注！&lt;/p&gt;
&lt;p&gt;Manish Chugtu - CTO Cloud Infrastructure和Microservices@Avi Networks，是一位创新思想领军人物，在架构，设计和产品开发方面拥有 18 年以上的经验，在架构和开发高度可扩展的企业解决方案方面拥有丰富的经验。目前，他致力于推动Avi在容器和云基础架构领域的战略， &lt;a href=&#34;https://www.linkedin.com/in/manishchugtu/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;他的 LinkedIn&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Envoy 中的 xDS REST 和 gRPC 协议详解</title>
      <link>https://cloudnative.to/blog/envoy-xds-protocol/</link>
      <pubDate>Fri, 28 Sep 2018 19:07:20 +0800</pubDate>
      <guid>https://cloudnative.to/blog/envoy-xds-protocol/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Envoy 通过查询文件或管理服务器来动态发现资源。概括地讲，对应的发现服务及其相应的 API 被称作  &lt;em&gt;xDS&lt;/em&gt; 。Envoy 通过订阅（ &lt;em&gt;subscription&lt;/em&gt; ）方式来获取资源，如监控指定路径下的文件、启动 gRPC 流或轮询 REST-JSON URL。后两种方式会发送 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/discovery.proto#discoveryrequest&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;DiscoveryRequest&lt;/code&gt;&lt;/a&gt; 请求消息，发现的对应资源则包含在响应消息 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/discovery.proto#discoveryresponse&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;DiscoveryResponse&lt;/code&gt;&lt;/a&gt; 中。下面，我们将具体讨论每种订阅类型。&lt;/p&gt;
&lt;h2 id=&#34;文件订阅&#34;&gt;文件订阅&lt;/h2&gt;
&lt;p&gt;发现动态资源的最简单方式就是将其保存于文件，并将路径配置在 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/core/config_source.proto#core-configsource&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ConfigSource&lt;/a&gt; 中的 &lt;code&gt;path&lt;/code&gt; 参数中。Envoy 使用 &lt;code&gt;inotify&lt;/code&gt;（Mac OS X 上为 &lt;code&gt;kqueue&lt;/code&gt;）来监控文件的变化，在文件被更新时，Envoy 读取保存的 &lt;code&gt;DiscoveryResponse&lt;/code&gt; 数据进行解析，数据格式可以为二进制 protobuf、JSON、YAML 和协议文本等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：core.ConfigSource 配置格式如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;path&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;api_config_source&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;{...}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;ads&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;{...}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;文件订阅方式可提供统计数据和日志信息，但是缺少 ACK/NACK 更新的机制。如果更新的配置被拒绝，xDS API 则继续使用最后一个的有效配置。&lt;/p&gt;
&lt;h2 id=&#34;grpc-流式订阅&#34;&gt;gRPC 流式订阅&lt;/h2&gt;
&lt;h3 id=&#34;单资源类型发现&#34;&gt;单资源类型发现&lt;/h3&gt;
&lt;p&gt;每个 xDS API 可以单独配置 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/core/config_source.proto#core-apiconfigsource&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;ApiConfigSource&lt;/code&gt;&lt;/a&gt;，指向对应的上游管理服务器的集群地址。每个 xDS 资源类型会启动一个独立的双向 gRPC 流，可能对应不同的管理服务器。API 交付方式采用最终一致性。可以参考后续聚合服务发现（ADS） 章节来了解必要的显式控制序列。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：core.ApiConfigSource 配置格式如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;api_type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;cluster_names&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;grpc_services&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;refresh_delay&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;{...}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;request_timeout&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;{...}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;类型-url&#34;&gt;类型 URL&lt;/h4&gt;
&lt;p&gt;每个 xDS API 都与给定的资源的类型存在 1:1 对应。关系如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/data-plane-api/blob/master/envoy/api/v2/lds.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LDS： &lt;code&gt;envoy.api.v2.Listener&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/data-plane-api/blob/master/envoy/api/v2/rds.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RDS： &lt;code&gt;envoy.api.v2.RouteConfiguration&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/data-plane-api/blob/master/envoy/api/v2/cds.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CDS： &lt;code&gt;envoy.api.v2.Cluster&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/data-plane-api/blob/master/envoy/api/v2/eds.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EDS： &lt;code&gt;envoy.api.v2.ClusterLoadAssignment&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/data-plane-api/blob/master/envoy/api/v2/auth/cert.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SDS：&lt;code&gt;envoy.api.v2.Auth.Secret&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3#any&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;类型 URL&lt;/em&gt;&lt;/a&gt; 的概念如下所示，其采用 &lt;code&gt;type.googleapis.com/&amp;lt;resource type&amp;gt;&lt;/code&gt; 的形式，例如 CDS 对应于  &lt;code&gt;type.googleapis.com/envoy.api.v2.Cluster&lt;/code&gt;。在 Envoy 的请求和管理服务器的响应中，都包括了资源类型 URL。&lt;/p&gt;
&lt;h4 id=&#34;acknack-和版本&#34;&gt;ACK/NACK 和版本&lt;/h4&gt;
&lt;p&gt;每个 Envoy 流以  &lt;code&gt;DiscoveryRequest&lt;/code&gt; 开始，包括了列表订阅的资源、订阅资源对应的类型 URL、节点标识符和空的 &lt;code&gt;version_info&lt;/code&gt;。EDS 请求示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;version_info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy }&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resource_names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type_url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;type.googleapis.com/envoy.api.v2.ClusterLoadAssignment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;response_nonce&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;管理服务器可立刻或等待资源就绪时发送 &lt;code&gt;DiscoveryResponse &lt;/code&gt;作为响应，示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;version_info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;foo ClusterLoadAssignment proto encoding&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;bar ClusterLoadAssignment proto encoding&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type_url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;type.googleapis.com/envoy.api.v2.ClusterLoadAssignment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;nonce&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Envoy 在处理 &lt;code&gt;DiscoveryResponse&lt;/code&gt; 响应后，将通过流发送一个新的请求，请求包含应用成功的最后一个版本号和管理服务器提供的 &lt;code&gt;nonce&lt;/code&gt;。如果本次更新已成功应用，则 &lt;code&gt;version_info&lt;/code&gt; 的值设置为 &lt;strong&gt;X&lt;/strong&gt;，如下序列图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-version-update-after-ack&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/envoy-xds-protocol/7e0ee03agy1fvmxs5aod1j20cc06y74c.jpg&#34; alt=&#34;Version update after ACK&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Version update after ACK
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在此序列图及后续中，将统一使用以下缩写格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DiscoveryRequest&lt;/code&gt;： (V=&lt;code&gt;version_info&lt;/code&gt;，R=&lt;code&gt;resource_names&lt;/code&gt;，N=&lt;code&gt;response_nonce&lt;/code&gt;，T=&lt;code&gt;type_url&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DiscoveryResponse&lt;/code&gt;： (V=&lt;code&gt;version_info&lt;/code&gt;，R=&lt;code&gt;resources&lt;/code&gt;，N=&lt;code&gt;nonce&lt;/code&gt;，T=&lt;code&gt;type_url&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：在&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;信息安全&lt;/a&gt;中，&lt;strong&gt;Nonce&lt;/strong&gt;是一个在加密通信只能使用一次的数字。在认证协议中，它往往是一个&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;随机&lt;/a&gt;或&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;伪随机&lt;/a&gt;数，以避免&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;重放攻击&lt;/a&gt;。Nonce也用于&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%B5%81%E5%AF%86%E7%A0%81&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;流密码&lt;/a&gt;以确保安全。如果需要使用相同的密钥加密一个以上的消息，就需要Nonce来确保不同的消息与该密钥加密的密钥流不同。（引用自&lt;a href=&#34;https://zh.wikipedia.org/wiki/Nonce&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;维基百科&lt;/a&gt;）在本文中&lt;code&gt;nonce&lt;/code&gt;是每次更新的数据包的唯一标识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;版本为 Envoy 和管理服务器提供了共享当前应用配置的概念和通过 ACK/NACK 来进行配置更新的机制。如果 Envoy 拒绝配置更新 &lt;strong&gt;X&lt;/strong&gt;，则回复 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/discovery.proto#envoy-api-field-discoveryrequest-error-detail&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;error_detail&lt;/code&gt;&lt;/a&gt; 及前一个的版本号，在当前情况下为空的初始版本号，&lt;code&gt;error_detail&lt;/code&gt; 包含了有关错误的更加详细的信息：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-no-version-update-after-nack&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/envoy-xds-protocol/7e0ee03agy1fvmxtjqtcsj20cc06y0ss.jpg&#34; alt=&#34;No version update after NACK&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      No version update after NACK
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;后续，API 更新可能会在新版本 &lt;strong&gt;Y&lt;/strong&gt; 上成功：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ack-after-nack&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/envoy-xds-protocol/7e0ee03agy1fvmxtwzc96j20cc0923yp.jpg&#34; alt=&#34;ACK after NACK&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      ACK after NACK
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;每个流都有自己的版本概念，但不存在跨资源类型的共享版本。在不使用 ADS 的情况下，每个资源类型可能具有不同的版本，因为 Envoy API 允许指向不同的 EDS/RDS 资源配置并对应不同的 &lt;code&gt;ConfigSources&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;何时发送更新&#34;&gt;何时发送更新&lt;/h4&gt;
&lt;p&gt;管理服务器应该只向 Envoy 客户端发送上次 &lt;code&gt;DiscoveryResponse&lt;/code&gt; 后更新过的资源。Envoy 则会根据接受或拒绝 &lt;code&gt;DiscoveryResponse&lt;/code&gt; 的情况，立即回复包含 ACK/NACK 的  &lt;code&gt;DiscoveryRequest&lt;/code&gt; 请求。如果管理服务器每次发送相同的资源集结果，而不是根据其更新情况，则会导致 Envoy 和管理服务器通讯效率大打折扣。&lt;/p&gt;
&lt;p&gt;在同一个流中，新的 &lt;code&gt;DiscoveryRequests&lt;/code&gt; 将取代此前具有相同的资源类型 &lt;code&gt;DiscoveryRequest&lt;/code&gt; 请求。&lt;strong&gt;这意味着管理服务器只需要响应给定资源类型最新的 &lt;code&gt;DiscoveryRequest&lt;/code&gt; 请求即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;资源提示&#34;&gt;资源提示&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;DiscoveryRequest&lt;/code&gt; 中的 &lt;code&gt;resource_names&lt;/code&gt; 信息作为资源提示出现。一些资源类型，例如 &lt;code&gt;Cluster&lt;/code&gt; 和 &lt;code&gt;Listener&lt;/code&gt; 将使用一个空的 &lt;code&gt;resource_names&lt;/code&gt;，因为 Envoy 需要获取管理服务器对应于节点标识的所有 &lt;code&gt;Cluster&lt;/code&gt;（CDS）和  &lt;code&gt;Listener&lt;/code&gt;（LDS）。对于其他资源类型，如 &lt;code&gt;RouteConfigurations&lt;/code&gt;（RDS）和 &lt;code&gt;ClusterLoadAssignments&lt;/code&gt;（EDS），则遵循此前的 CDS/LDS 更新，Envoy 能够明确地枚举这些资源。&lt;/p&gt;
&lt;p&gt;LDS/CDS 资源提示信息将始终为空，并且期望管理服务器的每个响应都提供 &lt;code&gt;LDS/CDS&lt;/code&gt; 资源的完整状态。缺席的 &lt;code&gt;Listener&lt;/code&gt; 或 &lt;code&gt;Cluster&lt;/code&gt; 将被删除。&lt;/p&gt;
&lt;p&gt;对于 EDS/RDS，管理服务器并不需要为每个请求的资源进行响应，而且还可能提供额外未请求的资源。&lt;code&gt;resource_names&lt;/code&gt; 只是一个提示。Envoy 将默默地忽略返回的多余资源。如果请求的资源中缺少相应的 RDS 或 EDS 更新，Envoy 将保留对应资源的最后的值。管理服务器可能会依据  &lt;code&gt;DiscoveryRequest&lt;/code&gt; 中 &lt;code&gt;node&lt;/code&gt; 标识推断其所需的 EDS/RDS 资源，在这种情况下，提示信息可能会被丢弃。从相应的角度来看，空的 EDS/RDS &lt;code&gt;DiscoveryResponse&lt;/code&gt; 响应实际上是表明在 Envoy 中为一个空的资源。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;Listener&lt;/code&gt; 或 &lt;code&gt;Cluster&lt;/code&gt; 被删除时，其对应的 EDS 和 RDS 资源也需要在 Envoy 实例中删除。为使 EDS 资源被 Envoy 已知或跟踪，就必须存在应用过的 &lt;code&gt;Cluster&lt;/code&gt; 定义（如通过 CDS 获取）。RDS 和 &lt;code&gt;Listeners&lt;/code&gt; 之间存在类似的关系（如通过 LDS 获取）。&lt;/p&gt;
&lt;p&gt;对于 EDS/RDS ，Envoy 可以为每个给定类型的资源生成不同的流（如每个 &lt;code&gt;ConfigSource&lt;/code&gt; 都有自己的上游管理服务器的集群）或当指定资源类型的请求发送到同一个管理服务器的时候，允许将多个资源请求组合在一起发送。虽然可以单个实现，但管理服务器应具备处理每个给定资源类型中对单个或多个 &lt;code&gt;resource_names&lt;/code&gt;  请求的能力。下面的两个序列图对于获取两个 EDS 资源都是有效的 &lt;code&gt;{foo，bar}&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-multiple-eds-requests-on-the-same-stream&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/envoy-xds-protocol/7e0ee03agy1fvmxuviiqsj20eh06ymx9.jpg&#34; alt=&#34;Multiple EDS requests on the same stream&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Multiple EDS requests on the same stream
    &lt;/figcaption&gt;&lt;/figure&gt;

















&lt;figure  id=&#34;figure-multiple-eds-requests-on-distinct-streams&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/envoy-xds-protocol/7e0ee03agy1fvmxv7cv21j20j20a4wet.jpg&#34; alt=&#34;Multiple EDS requests on distinct streams&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Multiple EDS requests on distinct streams
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;资源更新&#34;&gt;资源更新&lt;/h4&gt;
&lt;p&gt;如上所述，Envoy 可能会更新  &lt;code&gt;DiscoveryRequest&lt;/code&gt; 中出现的 &lt;code&gt;resource_names&lt;/code&gt; 列表，其中 &lt;code&gt;DiscoveryRequest&lt;/code&gt;  是用来 ACK/NACK 管理服务器的特定的 &lt;code&gt;DiscoveryResponse&lt;/code&gt; 。此外，Envoy 后续可能会发送额外的 &lt;code&gt;DiscoveryRequests&lt;/code&gt; ，用于在特定 &lt;code&gt;version_info&lt;/code&gt; 上使用新的资源提示来更新管理服务器。例如，如果 Envoy 在 EDS 版本 &lt;strong&gt;X&lt;/strong&gt; 时仅知道集群 &lt;code&gt;foo&lt;/code&gt;，但在随后收到的 CDS 更新时额外获取了集群 &lt;code&gt;bar&lt;/code&gt; ，它可能会为版本 &lt;strong&gt;X&lt;/strong&gt; 发出额外的 &lt;code&gt;DiscoveryRequest&lt;/code&gt; 请求，并将 &lt;code&gt;{foo，bar}&lt;/code&gt; 作为请求的 &lt;code&gt;resource_names&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-cds-response-leads-to-eds-resource-hint-update&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/envoy-xds-protocol/006tNc79ly1fvph0p7u8zj31fm0lq0ve.jpg&#34; alt=&#34;CDS response leads to EDS resource hint update&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      CDS response leads to EDS resource hint update
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里可能会出现竞争状况；如果 Envoy 在版本 &lt;strong&gt;X&lt;/strong&gt; 上发布了资源提示更新请求，但在管理服务器处理该请求之前发送了新的版本号为 &lt;strong&gt;Y&lt;/strong&gt;  的响应，针对 &lt;code&gt;version_info&lt;/code&gt; 为 &lt;strong&gt;X&lt;/strong&gt; 的版本，资源提示更新可能会被解释为拒绝  &lt;strong&gt;Y&lt;/strong&gt; 。为避免这种情况，通过使用管理服务器提供的 &lt;code&gt;nonce&lt;/code&gt;，Envoy 可用来保证每个 &lt;code&gt;DiscoveryRequest&lt;/code&gt; 对应到相应的 &lt;code&gt;DiscoveryResponse&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-eds-update-race-motivates-nonces&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/envoy-xds-protocol/006tNc79ly1fvph04ln3fj31kw0rogqc.jpg&#34; alt=&#34;EDS update race motivates nonces&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      EDS update race motivates nonces
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;管理服务器不应该为含有过期 &lt;code&gt;nonce&lt;/code&gt; 的 &lt;code&gt;DiscoveryRequest&lt;/code&gt; 发送 &lt;code&gt;DiscoveryResponse&lt;/code&gt; 响应。在向 Envoy 发送的 &lt;code&gt;DiscoveryResponse&lt;/code&gt;  中包含了的新 &lt;code&gt;nonce&lt;/code&gt; ，则此前的 &lt;code&gt;nonce&lt;/code&gt; 将过期。在资源新版本就绪之前，管理服务器不需要向 Envoy 发送更新。同版本的早期请求将会过期。在新版本就绪时，管理服务器可能会处理同一个版本号的多个 &lt;code&gt;DiscoveryRequests&lt;/code&gt;请求。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-requests-become-stale&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/envoy-xds-protocol/006tNc79ly1fvpgy6xewrj31b415ctcy.jpg&#34; alt=&#34;Requests become stale&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Requests become stale
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上述资源更新序列表明 Envoy 并不能期待其发出的每个 &lt;code&gt;DiscoveryRequest&lt;/code&gt; 都得到 &lt;code&gt;DiscoveryResponse&lt;/code&gt; 响应。&lt;/p&gt;
&lt;h4 id=&#34;最终一致性考虑&#34;&gt;最终一致性考虑&lt;/h4&gt;
&lt;p&gt;由于 Envoy 的 xDS API 采用最终一致性，因此在更新期间可能导致流量被丢弃。例如，如果通过 CDS/EDS 仅获取到了集群 &lt;strong&gt;X&lt;/strong&gt;，而且 &lt;code&gt;RouteConfiguration&lt;/code&gt; 引用了集群  &lt;strong&gt;X&lt;/strong&gt;；在 CDS/EDS 更新集群  &lt;strong&gt;Y&lt;/strong&gt;  配置之前，如果将 &lt;code&gt;RouteConfiguration&lt;/code&gt; 将引用的集群调整为 &lt;strong&gt;Y&lt;/strong&gt; ，那么流量将被吸入黑洞而丢弃，直至集群 &lt;strong&gt;Y&lt;/strong&gt; 被 Envoy 实例获取。&lt;/p&gt;
&lt;p&gt;对某些应用程序，可接受临时的流量丢弃，客户端重试或其他 Envoy sidecar 会掩盖流量丢弃。那些对流量丢弃不能容忍的场景，可以通过以下方式避免流量丢失，CDS/EDS 更新同时携带 &lt;strong&gt;X&lt;/strong&gt; 和 &lt;strong&gt;Y&lt;/strong&gt; ，然后发送 RDS 更新从 &lt;strong&gt;X&lt;/strong&gt; 切换到 &lt;strong&gt;Y&lt;/strong&gt; ，此后发送丢弃 &lt;strong&gt;X&lt;/strong&gt; 的 CDS/EDS 更新。&lt;/p&gt;
&lt;p&gt;一般来说，为避免流量丢弃，更新的顺序应该遵循 &lt;code&gt;make before break&lt;/code&gt; 模型，其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须始终先推送 CDS 更新（如果有）。&lt;/li&gt;
&lt;li&gt;EDS 更新（如果有）必须在相应集群的 CDS 更新后到达。&lt;/li&gt;
&lt;li&gt;LDS 更新必须在相应的 CDS/EDS 更新后到达。&lt;/li&gt;
&lt;li&gt;与新添加的监听器相关的 RDS 更新必须在最后到达。&lt;/li&gt;
&lt;li&gt;最后，删除过期的 CDS 集群和相关的 EDS 端点（不再被引用的端点）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有新的集群/路由/监听器或者允许更新时临时流量丢失的情况下，可以独立推送 xDS 更新。请注意，在 LDS 更新的情况下，监听器须在接收流量之前被预热，例如如其配置了依赖的路由，则先需先从 RDS 进行获取。添加/删除/更新集群信息时，集群也需要进行预热。另一方面，如果管理平面确保路由更新时所引用的集群已经准备就绪，路由可以不用预热。&lt;/p&gt;
&lt;h3 id=&#34;聚合服务发现ads&#34;&gt;聚合服务发现（ADS）&lt;/h3&gt;
&lt;p&gt;当管理服务器进行资源分发时，通过上述保证交互顺序的方式来避免流量丢弃是一项很有挑战的工作。ADS 允许单一管理服务器通过单个 gRPC 流，提供所有的 API 更新。配合仔细规划的更新顺序，ADS 可规避更新过程中流量丢失。使用 ADS，在单个流上可通过类型 URL 来进行复用多个独立的 &lt;code&gt;DiscoveryRequest&lt;/code&gt;/&lt;code&gt;DiscoveryResponse&lt;/code&gt; 序列。对于任何给定类型的 URL，以上 &lt;code&gt;DiscoveryRequest&lt;/code&gt; 和 &lt;code&gt;DiscoveryResponse&lt;/code&gt; 消息序列都适用。 更新序列可能如下所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-edscds-multiplexed-on-an-ads-stream&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/envoy-xds-protocol/006tNc79ly1fvpgxnl947j313q0wgq62.jpg&#34; alt=&#34;EDS/CDS multiplexed on an ADS stream&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      EDS/CDS multiplexed on an ADS stream
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;每个 Envoy 实例可使用单独的 ADS 流。&lt;/p&gt;
&lt;p&gt;最小化 ADS 配置的 &lt;code&gt;bootstrap.yaml&lt;/code&gt; 片段示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;&amp;lt;node identifier&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;dynamic_resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cds_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{&lt;span class=&#34;nt&#34;&gt;ads&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;lds_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{&lt;span class=&#34;nt&#34;&gt;ads&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ads_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;api_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;GRPC&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;grpc_services&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;envoy_grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ads_cluster&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;static_resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;clusters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ads_cluster&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;connect_timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;seconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;STATIC&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;&amp;lt;ADS management server IP address&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;&amp;lt;ADS management server port&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;lb_policy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ROUND_ROBIN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http2_protocol_options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;admin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;增量-xds&#34;&gt;增量 xDS&lt;/h3&gt;
&lt;p&gt;增量 xDS 是可用于允许的 ADS、CDS 和 RDS 单独 xDS 端点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xDS 客户端对跟踪资源列表进行增量更新。这支持 Envoy 按需/惰性地请求额外资源。例如，当与未知集群相对应的请求到达时，可能会发生这种情况。&lt;/li&gt;
&lt;li&gt;xDS 服务器可以增量更新客户端上的资源。这支持 xDS 资源可伸缩性的目标。管理服务器只需交付更改的单个集群，而不是在修改单个集群时交付所有上万个集群。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;xDS 增量会话始终位于 gRPC 双向流的上下文中。这允许 xDS 服务器能够跟踪到连接的 xDS 客户端的状态。xDS REST 版本不支持增量。&lt;/p&gt;
&lt;p&gt;在增量 xDS 中，nonce 字段是必需的，用于匹配  &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/discovery.proto#discoveryrequest&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;IncrementalDiscoveryResponse&lt;/code&gt;&lt;/a&gt; 关联的 ACK 或 NACK &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/discovery.proto#discoveryrequest&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;IncrementalDiscoveryRequest&lt;/code&gt;&lt;/a&gt;。可选地，存在响应消息级别的 system_version_info，但仅用于调试目的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IncrementalDiscoveryRequest&lt;/code&gt; 可在以下 3 种情况下发送：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;xDS 双向 gRPC 流的初始消息。&lt;/li&gt;
&lt;li&gt;作为对先前的 &lt;code&gt;IncrementalDiscoveryResponse&lt;/code&gt; 的 ACK 或 NACK 响应。在这种情况下，&lt;code&gt;response_nonce&lt;/code&gt; 被设置为响应中的 nonce 值。ACK 或 NACK 由可由 &lt;code&gt;error_detail&lt;/code&gt; 字段是否出现来区分。&lt;/li&gt;
&lt;li&gt;客户端自发的 &lt;code&gt;IncrementalDiscoveryRequest&lt;/code&gt;。此场景下可以采用动态添加或删除被跟踪的 &lt;code&gt;resource_names&lt;/code&gt; 集。这种场景下，必须忽略 &lt;code&gt;response_nonce&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在第一个示例中，客户端连接并接收它的第一个更新并 ACK。第二次更新失败，客户端发送 NACK 拒绝更新。xDS客户端后续会自发地请求 “wc” 相关资源。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-incremental-session-example&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/envoy-xds-protocol/006tNc79ly1fvpgwfbep7j31kw0vldli.jpg&#34; alt=&#34;Incremental session example&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Incremental session example
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在重新连接时，支持增量的 xDS 客户端可能会告诉服务器其已知资源从而避免通过网络重新发送它们。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-incremental-reconnect-example&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/envoy-xds-protocol/006tNc79ly1fvpgx05z3kj31kw0phwif.jpg&#34; alt=&#34;Incremental reconnect example&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Incremental reconnect example
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;rest-json-轮询订阅&#34;&gt;REST-JSON 轮询订阅&lt;/h2&gt;
&lt;p&gt;单个 xDS  API 可对 REST 端点进行的同步（长）轮询。除了无持久流与管理服务器交互外，消息顺序与上述相似。在任何时间点，只存在一个未完成的请求，因此响应消息中的 &lt;code&gt;nonce&lt;/code&gt; 在 REST-JSON 中是可选的。&lt;code&gt;DiscoveryRequest&lt;/code&gt; 和 &lt;code&gt;DiscoveryResponse&lt;/code&gt; 的消息编码遵循 &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3#json&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JSON 变换 proto3&lt;/a&gt; 规范。ADS 不支持 REST-JSON 轮询。&lt;/p&gt;
&lt;p&gt;当轮询期间设置为较小的值时，则可以等同于长轮询，这时要求避免发送 &lt;code&gt;DiscoveryResponse&lt;/code&gt;，&lt;a href=&#34;#%e4%bd%95%e6%97%b6%e5%8f%91%e9%80%81%e6%9b%b4%e6%96%b0&#34;&gt;除非对请求的资源发生了更改&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Istio分布式跟踪应用程序</title>
      <link>https://cloudnative.to/blog/distributed-tracing-istio-and-your-applications/</link>
      <pubDate>Tue, 17 Jul 2018 12:53:14 +0800</pubDate>
      <guid>https://cloudnative.to/blog/distributed-tracing-istio-and-your-applications/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://thenewstack.io/distributed-tracing-istio-and-your-applications/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在微服务领域，分布式跟踪正逐渐成为调试和跟踪应用程序最重要的依赖工具。&lt;/p&gt;
&lt;p&gt;最近的聚会和会议上，我发现很多人对分布式跟踪的工作原理很感兴趣，但同时对于分布式跟踪如何与Istio和&lt;a href=&#34;https://aspenmesh.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aspen Mesh&lt;/a&gt;等服务网格进行配合使用存在较大的困惑。特别地，我经常被问及以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tracing如何与Istio一起使用？在Span中收集和报告哪些信息？&lt;/li&gt;
&lt;li&gt;是否必须更改应用程序才能从Istio的分布式跟踪中受益？&lt;/li&gt;
&lt;li&gt;如果目前在应用程序中报告Span，它将如何与Istio中的Span进行交互？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这篇博客中，我将尝试回答这些问题。&lt;/p&gt;
&lt;p&gt;在我们深入研究这些问题之前，建议先快速了解为什么我要写与分布式跟踪相关博客。如果您关注&lt;a href=&#34;https://aspenmesh.io/blog/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aspen Mesh&lt;/a&gt;的博客，您会注意到我写了两篇与tracing相关的博客，一篇关于 &lt;a href=&#34;https://aspenmesh.io/2018/01/distributed-tracing-with-istio-in-aws/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;”使用Istio跟踪AWS中的服务请求“&lt;/a&gt;，另一篇关于&lt;a href=&#34;https://aspenmesh.io/2018/04/tracing-grpc-with-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;”使用Istio跟踪gRPC应用程序&amp;quot;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们在Aspen Mesh有一个非常小的工程团队，如果经常在子系统或组件上工作，您很快就会成为（或标记或分配）常驻专家。我在微服务中添加了分布式跟踪，并在AWS环境中将其与Istio集成，在此过程中发现了值得分享的各种有趣的经验。在过去的几个月里，我们一直在大量使用跟踪来了解我们的微服务，现在这种方法已经成为我们排查问题首先采用的手段。后续，我们继续回答上面提到的问题。&lt;/p&gt;
&lt;h2 id=&#34;tracing如何与istio一起使用&#34;&gt;Tracing如何与Istio一起使用？&lt;/h2&gt;
&lt;p&gt;Istio在应用程序运行的Pod容器中注入sidecar代理（Envoy）。sidecar代理透明地拦截（防火墙魔法）进出应用程序的所有网络流量。拦截模式下，sidecar代理处于一个独特的位置，可以自动跟踪所有网络请求（包括HTTP/1.1、HTTP/2.0和gRPC）。&lt;/p&gt;
&lt;p&gt;让我们看看sidecar代理对来自客户端（外部或其他微服务）的传入Pod请求所做的更改。从现在开始，为了简单起见，我将假设跟踪标头采用&lt;a href=&#34;https://github.com/openzipkin/b3-propagation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zipkin&lt;/a&gt;格式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果传入请求没有任何跟踪头，则在请求传递到与sidecar同一Pod中的应用程序容器前，sidecar代理将创建根Span（其中trace、parent和Span ID具有完全相同的Span）。&lt;/li&gt;
&lt;li&gt;如果传入的请求有跟踪信息（如正在使用Istio Ingress或者微服务是从另一个注入了sidecar代理的微服务中调用），那么sidecar代理将从跟踪头中提取Span上下文，在将请求传递到同一Pod中的应用程序容器之前，创建一个新的兄弟（sibling）Span（与传入头相同的trace、parent和Span ID）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在应用程序容器发出相反方向上的出站请求（外部服务或集群中的服务）时，Pod中的sidecar代理在向上游服务发出请求之前执行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不存在跟踪头，则sidecar代理会创建根Span并将Span上下文作为头部注入新请求。&lt;/li&gt;
&lt;li&gt;如果存在跟踪头，则sidecar代理从头部中提取Span上下文，并基于此上下文创建&lt;strong&gt;子Span&lt;/strong&gt;。新上下文作为请求中的跟踪头传播到上游服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上面的解释，您应该注意到对于微服务调用链中的每一跳，将获得Istio报告的两个Span，一个来自客户端sidecar（&lt;code&gt;span.kind&lt;/code&gt;设置为client）和一个来自服务器sidecar（&lt;code&gt;span.kind&lt;/code&gt;设置为server）。sidecar创建的所有Span都由sidecar自动报告给配置的后端跟踪系统，比如Jaeger或Zipkin等。&lt;/p&gt;
&lt;p&gt;接下来，让我们看一下Span中报告的信息。Span包含以下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;x-request-id&lt;/strong&gt;：报告为 &lt;code&gt;guid:x-request-id&lt;/code&gt;，这对于将访问日志与Span相关联非常有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;upstream cluster&lt;/strong&gt;：发出请求的上游服务。如果Span跟踪对Pod的传入请求，则通常将其设置为 &lt;code&gt;in.&amp;lt;name&amp;gt;&lt;/code&gt;。如果Span跟踪出站请求，则将其设置为 &lt;code&gt;out.&amp;lt;name&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP headers&lt;/strong&gt;：在可用时报告以下 HTTP 头部信息：
&lt;ul&gt;
&lt;li&gt;+URL&lt;/li&gt;
&lt;li&gt;+Method&lt;/li&gt;
&lt;li&gt;+User 代理&lt;/li&gt;
&lt;li&gt;+Protocol&lt;/li&gt;
&lt;li&gt;+Request 大小&lt;/li&gt;
&lt;li&gt;+Response 大小&lt;/li&gt;
&lt;li&gt;+Response 标记&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个Span的开始和结束时间。&lt;/li&gt;
&lt;li&gt;跟踪的元数据：这包括trace ID、Span ID和Span类型（client或server）。除此之外，还会报告每个Span的操作名称。操作名称设置为影响路由配置的虚拟服务（或 v1alpha1 中的路由规则），如果选择了默认路由，则设置为 “default-route”。这对于了解哪个Istio路由配置对Span生效非常有用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来让我们继续讨论第二个问题。&lt;/p&gt;
&lt;h2 id=&#34;是否必须修改应用程序才能利用istio追踪&#34;&gt;是否必须修改应用程序才能利用Istio追踪？&lt;/h2&gt;
&lt;p&gt;是的，您需要在应用程序中添加逻辑，以便将传入跟踪头部信息从传入请求传播到传出请求，这样才能从Istio的分布式跟踪中获得更多有价值的信息。&lt;/p&gt;
&lt;p&gt;如果应用程序容器在传入请求的上下文中发出新的出站请求，且传入请求中未包括跟踪头，则sidecar代理会为出站请求创建根Span。这意味着您将始终只看到两个微服务的路径。另一方面，如果应用程序容器确实将跟踪头部信息从传入请求传播到传出请求，则sidecar代理将创建如上所述的子Span。通过创建子Span，您可以了解跨多个微服务的依赖关系。&lt;/p&gt;
&lt;p&gt;在应用程序中传播跟踪头有两种选择。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查找&lt;a href=&#34;https://istio.io/docs/tasks/telemetry/distributed-tracing/#understanding-what-happened&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio文档&lt;/a&gt;中提到的跟踪头，并将其从传入请求传输到传出请求。这种方法很简单，几乎适用于所有情况。但是，它有一个主要缺点，无法向Span添加自定义标记信息例如用户信息等。您无法创建应用程序中的事件相关的子Span。由于是在不了解Span格式或上下文的情况下传播跟踪信息，因此添加特定于应用程序的信息的能力有限。&lt;/li&gt;
&lt;li&gt;第二种方法是在应用程序中设置跟踪客户端，并使用&lt;a href=&#34;http://opentracing.io/documentation/pages/api/index&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Opentracing API&lt;/a&gt;将跟踪头部信息从传入请求传播到传出请求。我创建了一个&lt;a href=&#34;https://github.com/aspenmesh/tracing-go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;跟踪示例包&lt;/a&gt;，它提供了一种在您的应用程序中设置&lt;a href=&#34;https://github.com/jaegertracing/jaeger-client-go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;jaeger-client-go&lt;/a&gt;的简单方法，该方法与Istio兼容。以下代码段可用于应用程序的主功能中：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;s&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;s&#34;&gt;&amp;#34;github.com/spf13/cobra&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;s&#34;&gt;&amp;#34;github.com/spf13/viper&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;s&#34;&gt;&amp;#34;github.com/aspenmesh/tracing-go&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setupTracing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;// Configure Tracing
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;tOpts&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tracing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;ZipkinURL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;viper&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GetString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;trace_zipkin_url&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;JaegerURL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;viper&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GetString&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;trace_jaeger_url&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;LogTraceSpans&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;viper&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GetBool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;trace_log_spans&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tOpts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Validate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Invalid options for tracing: &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tracer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;io&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Closer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tOpts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;TracingEnabled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;tracer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tracing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Configure&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;myapp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tOpts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nx&#34;&gt;tracer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Failed to configure tracing: &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tracer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要注意的关键点是在&lt;a href=&#34;https://github.com/aspenmesh/tracing-go/blob/master/config.go#L124&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tracing-go&lt;/a&gt;包中我将Opentracing全局跟踪器设置Jaeger。 这使我能够使用Opentracing API将跟踪头从传入请求传播到传出请求，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;s&#34;&gt;&amp;#34;net/http&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;s&#34;&gt;&amp;#34;golang.org/x/net/context&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;s&#34;&gt;&amp;#34;golang.org/x/net/context/ctxhttp&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	 &lt;span class=&#34;nx&#34;&gt;ot&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;github.com/opentracing/opentracing-go&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;injectTracingHeaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;incomingReq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;addr&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;ifSpan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;SpanFromContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;incomingReq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Span&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;outgoingReq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;GET&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;ot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GlobalTracer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Inject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nx&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nx&#34;&gt;ot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;HTTPHeaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nx&#34;&gt;ot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HTTPHeadersCarrier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;outgoingReq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Header&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;resp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ctxhttp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Do&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;outgoingReq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;c1&#34;&gt;// Do something with resp
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您还可以使用Opentracing API 来设置Span标记或从Istio添加的跟踪上下文创建子Span，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;SetSpanTag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;incomingReq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;ifSpan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;SpanFromContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;incomingReq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Span&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;SetTag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除了上述好处之外，您不必直接处理跟踪信息，但跟踪器（在本例中为Jaeger）会为您处理它。 我强烈建议使用此方法，因为它在应用程序中提供了跟踪的基础，增强了跟踪功能而不会产生太多开销。&lt;/p&gt;
&lt;p&gt;现在让我们继续讨论第三个问题。&lt;/p&gt;
&lt;h2 id=&#34;istio报告的span如何与应用程序创建的span交互&#34;&gt;Istio报告的Span如何与应用程序创建的Span交互？&lt;/h2&gt;
&lt;p&gt;如果您希望应用程序报告的Span是Istio添加的跟踪上下文的子Span，则应使用OpenTracing API &lt;a href=&#34;https://godoc.org/github.com/opentracing/opentracing-go#StartSpanFromContext&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;StartSpanFromContext&lt;/a&gt;而不是使用&lt;a href=&#34;https://godoc.org/github.com/opentracing/opentracing%20go#StartSpan&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;StartSpan&lt;/a&gt;。如果存在跟踪头部信息，则&lt;code&gt;StartSpanFromContext&lt;/code&gt;从父级上下文创建子Span，否则创建根Span。&lt;/p&gt;
&lt;p&gt;请注意，在上面的所有示例中，我都使用了OpenTracing Go API，但您应该能够使用与应用程序相同语言编写的任何跟踪客户端库，只要它与OpenTracing API兼容即可。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
