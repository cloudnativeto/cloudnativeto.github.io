<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>张晓辉 | 云原生社区（中国）</title>
    <link>https://cloudnative.to/translators/%E5%BC%A0%E6%99%93%E8%BE%89/</link>
      <atom:link href="https://cloudnative.to/translators/%E5%BC%A0%E6%99%93%E8%BE%89/index.xml" rel="self" type="application/rss+xml" />
    <description>张晓辉</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Wed, 18 Aug 2021 21:05:42 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/translators/%E5%BC%A0%E6%99%93%E8%BE%89/avatar_hu1ad2546a9b7c413f2c11e4aa1a7995e3_52301_270x270_fill_q75_lanczos_center.jpg</url>
      <title>张晓辉</title>
      <link>https://cloudnative.to/translators/%E5%BC%A0%E6%99%93%E8%BE%89/</link>
    </image>
    
    <item>
      <title>Kubernetes 云集群面临通过 Argo Workflows 实施的网络攻击</title>
      <link>https://cloudnative.to/blog/kubernetes-cyberattacks-argo-workflows/</link>
      <pubDate>Wed, 18 Aug 2021 21:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/kubernetes-cyberattacks-argo-workflows/</guid>
      <description>&lt;p&gt;本文翻译自 &lt;a href=&#34;https://threatpost.com/kubernetes-cyberattacks-argo-workflows/167997/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Cloud Clusters Face Cyberattacks via Argo Workflows&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;译者点评&#34;&gt;译者点评&lt;/h2&gt;
&lt;p&gt;行业中一直不缺安全的声音，安全也是永远绕不过的槛。再优雅再先进的架构设计，无法保障安全也是一文不值，甚至干系到企业的存活。&lt;/p&gt;
&lt;p&gt;近期在云原生领域，安全也是被屡次被提起重视。从 &lt;a href=&#34;https://cloudnative.to/blog/istio-first-security-assessment/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 首次安全评估结果公布&lt;/a&gt;、&lt;a href=&#34;https://mp.weixin.qq.com/s/W8oT2YabhHNSLsWXJbPSnw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 云原生安全白皮书发布&lt;/a&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/PRXtfz2Vc3Q8dhjoazY8Pw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;美国国家安全局出品《Kubernetes 加固指南》&lt;/a&gt;、&lt;a href=&#34;http://www.gov.cn/zhengce/content/2021-08/17/content_5631671.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《关键信息基础设施安全保护条例》的颁布&lt;/a&gt;看出，下到社区到基金会，上到国内外政府对安全的重视。&lt;/p&gt;
&lt;p&gt;近几年开源越来越热，各种的工具层出不穷。仪表盘可以说是离用户最近的一层，也是安全最容易被疏忽的一处，尤其是很多仪表盘并未提供用户校验或者容易配置错误。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;Argo 的 web 仪表盘权限配置错误，会允许未经身份验证的攻击者在 Kubernetes 目标上运行代码，包括加密币挖掘容器。&lt;/p&gt;
&lt;p&gt;安全研究人员发出警告，Kubernetes 集群正受到配置错误的 Argo Workflow 实例的攻击。&lt;/p&gt;
&lt;p&gt;Argo Workflow 是一个开源的、容器原生的工作流引擎，用于在 Kubernetes 上编排并行作业 &amp;ndash; 以加快机器学习和大数据处理等计算密集型作业的处理时间。与此同时，Kubernetes 是一种流行的用于管理云部署的容器编排引擎。&lt;/p&gt;
&lt;p&gt;根据 Intezer 的一项分析，由于一些实例不需要外部用户的认证可以直接通过仪表盘访问，恶意软件运营商正在通过 Argo 将加密旷工投放到云中。因此，这些错误配置的权限可以让威胁者在受害者的环境中运行未经授权的代码。&lt;/p&gt;
&lt;p&gt;根据&lt;a href=&#34;https://www.intezer.com/blog/container-security/new-attacks-on-kubernetes-via-misconfigured-argo-workflows&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;周二发布&lt;/a&gt;的 Intezer 的分析，&amp;ldquo;在许多情况下，配置了允许任何访问用户部署工作流程的权限。在权限配置错误的情况下，攻击者有可能访问一个开放的 Argo 仪表盘并提交他们自己的工作流程。&lt;/p&gt;
&lt;p&gt;研究人员说，这些错误配置还可能暴露敏感信息，如代码、凭证和私有容器镜像名称（可用于协助其他类型的攻击）。&lt;/p&gt;
&lt;p&gt;Intezer 对网络的扫描发现了大量未受保护的实例，这些实例由多个行业的公司运营，包括技术、金融和物流。&lt;/p&gt;
&lt;p&gt;Intezer 表示：&amp;ldquo;我们已经确定了受感染的节点，由于存在数百个错误配置的部署，有可能出现更大规模的攻击&amp;rdquo;。在一个案例中，坏代码在 Docker Hub 的一个暴露的集群上运行了 9 个月才被发现并删除。&lt;/p&gt;
&lt;p&gt;攻击的实施并不困难。研究人员观察到，不同的流行 Monero（门罗币）挖掘恶意软件被部署在位于 Docker Hub 等资源库的容器中，包括 Kannix 和 XMRig。网络犯罪分子只需要通过 Argo 或其他途径将这些容器中的一个拉入 Kubernetes。例如，微软最近&lt;a href=&#34;https://threatpost.com/microsoft-cryptomining-kubeflow/166777/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标记了&lt;/a&gt; 通过运行机器学习工作流程的 Kubeflow 框架侵占 Kubernetes 的一些矿工。&lt;/p&gt;
&lt;p&gt;研究人员称：“在 Docker Hub 中，仍然存在许多攻击者可以使用的门罗币挖矿选择。通过简单的搜索，可以看到至少有 45 个有数百万下载量的容器”&lt;/p&gt;
&lt;h2 id=&#34;如何检查-argo-的错误配置&#34;&gt;如何检查 Argo 的错误配置&lt;/h2&gt;
&lt;p&gt;研究人员指出，查看权限是否配置正确的最快方法是简单地尝试从企业环境之外的未经认证的隐身浏览器访问 Argo Workflows 仪表盘。&lt;/p&gt;
&lt;p&gt;研究人员补充说，一种更主动技术的检查方法是访问实例的 API 并检查状态码。&lt;/p&gt;
&lt;p&gt;根据分析，“向 [实例:端口]/api/v1/info 发送 HTTP GET 请求，未经授权的用户将收到‘411 Unauthorized’响应状态码，这说明实例配置正确，而成功的响应状态码‘200 Success’可能表明未经授权的用户能够访问该实例”。&lt;/p&gt;
&lt;p&gt;管理员还可以检查日志和工作流时间线中的任何可疑活动。Intezer 指出，任何运行时间过长的工作流都可能表明存在加密挖矿活动。&lt;/p&gt;
&lt;p&gt;研究人员指出，“即使你的集群部署在 Amazon Web Services（AWS）、EKS 或者 Azure Kubernetes Service（AKS）等托管的云 Kubernetes 服务上，责任共担模型仍声明需要为部署的应用安全负责的是云用户，而不是供应商。”&lt;/p&gt;
&lt;h2 id=&#34;云错误配置为网络攻击提供媒介&#34;&gt;云错误配置为网络攻击提供媒介&lt;/h2&gt;
&lt;p&gt;错误配置&lt;a href=&#34;https://threatpost.com/google-cloud-buckets-exposed-misconfiguration/159429/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;持续困扰&lt;/a&gt;着云计算部门和各种规模的组织。去年秋天的一项分析发现，6% 的谷歌云存储桶被错误配置，并向公网开放，任何人都可以访问其内容。&lt;/p&gt;
&lt;p&gt;有时这些失误会成为头条新闻。3 月，&lt;a href=&#34;https://threatpost.com/hobby-lobby-customer-data-cloud-misconfiguration/164980/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;有消息称&lt;/a&gt;，Hobby Lobby 将 138GB 的敏感信息放在一个向公网开放的云存储桶中。这些信息包括客户的姓名、支付卡的部分详细信息、电话号码以及实际地址和电子邮件地址。&lt;/p&gt;
&lt;p&gt;根据云原生计算基金会（CNCF）&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2020/11/CNCF_Survey_Report_2020.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2020 年调查&lt;/a&gt;，91% 的受访者正在使用 Kubernetes，受访者称使用和部署容器的首要挑战是复杂性、安全性和缺乏培训。&lt;/p&gt;
&lt;p&gt;Intezer 研究人员指出，“Kubernetes&amp;hellip;&amp;hellip;是 GitHub 上最受欢迎的存储库之一，有超过 10 万个提交，超过 3000 个贡献者。每年，使用 Kubernetes 的企业和他们部署的集群数量都在稳步增加。由于企业使用容器和 Kubernetes 集群所面临的这些挑战，攻击者从未有更大的机会来利用安全方面的弱点&amp;hellip;&amp;hellip;仍然存在错误配置或利用的可能性。”&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>开源评估框架</title>
      <link>https://cloudnative.to/blog/a-framework-for-open-source-evaluation/</link>
      <pubDate>Sun, 08 Aug 2021 17:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/a-framework-for-open-source-evaluation/</guid>
      <description>&lt;p&gt;本文翻译自 Bilgin Ibryam  的文章 &lt;a href=&#34;https://monetize.substack.com/p/a-framework-for-open-source-evaluation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A Framework for Open Source Evaluation&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如今，真&lt;a href=&#34;https://www.linuxjournal.com/content/open-vs-fauxpen&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;假&lt;/a&gt;开源无处不在。最近开源项目转为闭源的案例越来越多，同时也有不少闭源项目（按照 &lt;a href=&#34;https://opensource.org/osd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OSI 定义&lt;/a&gt;）像开源一样构建社区的例子。这怎么可能，开源项目不应该始终如此吗？&lt;/p&gt;
&lt;p&gt;开源不是非黑即白，它具有开放性、透明、协作性和信任性的多个&lt;a href=&#34;https://monetize.substack.com/p/a-holistic-vision-of-open-source&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;维度&lt;/a&gt;。有些开源是 Github 上的任何项目，有些必须通过 OSI 定义，有些是必须遵守不成文但普遍接受的开源规范。这里通过看一些商业和技术方面，再讨论社区管理习惯，来同大家分享一下我对评估开源项目的看法。&lt;/p&gt;
&lt;h2 id=&#34;免责声明&#34;&gt;免责声明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这些是我的个人观点，与我的雇主或我所属的软件基金会和项目无关。&lt;/li&gt;
&lt;li&gt;这不是法律或专业意见（我不是律师，也不是专门从事 OSS 评估的），而是外行的意见。
更新：我收到了多位开源律师的反馈并更新了文章！&lt;/li&gt;
&lt;li&gt;这篇博文由&lt;a href=&#34;https://monetize.substack.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;订阅&lt;/a&gt;和&lt;a href=&#34;https://twitter.com/bibryam/status/1371045284751507463&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;分享&lt;/a&gt;按钮赞助，点击这些按钮表示支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;知识产权&#34;&gt;知识产权&lt;/h2&gt;
&lt;p&gt;关于“开源”项目的第一个问题是关于知识产权的所有权。好消息是，即使不了解这些法律含义，你可以应用一个简单的 Litmus 测试。该项目是否属于你信任的信誉良好的开源基金会？例如，&lt;a href=&#34;https://www.fsf.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FSF&lt;/a&gt; 拥有其托管项目的版权，更多情况下拥有基金会（如 &lt;a href=&#34;https://www.apache.org/foundation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ASF&lt;/a&gt;、&lt;a href=&#34;https://www.linuxfoundation.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LF&lt;/a&gt;) 通过贡献者许可协议，聚合对其项目的贡献许可权。在任何一种情况下，你都可以相信他们将充当良好的去中心化管家，并且不会在一夜之间改变项目的未来方向。如果一个项目不属于信誉良好的软件基金会，而是由一家公司提供支持，那么问题是你是否信任该公司作为供应链合作伙伴。如果这些问题的答案是肯定的，请转到下一部分。如果答案是否定的，那么你最好调查一下版权所有者是谁，以及他们对你的长期前景和潜在风险是什么。今天的单一供应商开源项目，明天可能会变成闭源。&lt;/p&gt;
&lt;h2 id=&#34;许可&#34;&gt;许可&lt;/h2&gt;
&lt;p&gt;商标出现在许可之前的原因是软件的权利人（通常是作者）通过许可授予最终用户使用一个或多个软件副本的许可。自由软件许可证是一种说明，它授予源代码或其二进制形式的使用者修改和重新分发该软件的权利。如果没有许可，这些行为将受到版权法的禁止。这里的重点是权利人可以改变主意并更改许可。权利持有人可以决定在多个许可证下分发软件或随时将许可证更改为非开源许可证。该软件也可能在&lt;a href=&#34;https://opensource.org/node/878&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公共领域&lt;/a&gt;，在这种情况下，它不受版权法的限制。公共领域并不等同于开源许可证，这是一种不太流行的方法，我们可以在这里忽略。&lt;/p&gt;
&lt;p&gt;同样，如果不是律师，这是一个外行对许可的 Litmus 测试：该项目是否根据 OSI 批准的&lt;a href=&#34;https://opensource.org/licenses/alphabetical&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;许可清单&lt;/a&gt;获得的许可？如果答案是肯定的，那么你可以依靠这些基金会的尽职调查来审查、分类许可并指出任何限制。如果答案是否定的，请让你公司的律师来查看和解释许可上的每个字以及可能的许可兼容性影响。&lt;/p&gt;
&lt;h2 id=&#34;治理&#34;&gt;治理&lt;/h2&gt;
&lt;p&gt;在余下的检查中，我们正在从更多的商业和法律方面转向涉及开源项目领域的技术和社区。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-开源评估框架&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.substack.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F7f06c148-d675-4bb7-803e-b3704f0016ef_3309x2473.png&#34; alt=&#34;开源评估框架&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      开源评估框架
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;假设不担心商标持有方（未来的合作伙伴）、许可（使用开源软件的条款），下一个问题是治理。&lt;a href=&#34;https://www.oasis-open.org/policies-guidelines/open-projects-process/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;治理&lt;/a&gt;是项目决定谁来做什么、他们应该如何做以及何时做的规则或习惯。它定义了与不同项目角色相关的职责、特权和权限，以及人们如何分配到角色和从角色中删除。此处的示例是小型日常活动，例如谁有权批准拉取请求、投票给候选发布、就项目架构达成共识、定义项目路线图以及选举项目治理委员会。&lt;/p&gt;
&lt;p&gt;如果你正在评估对你的组织具有战略意义的项目，你想知道谁负责。不仅如此，你甚至可能&lt;a href=&#34;https://hackernoon.com/reciprocity-in-open-source-e60fb98ee1cc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;希望&lt;/a&gt;你的开发人员对项目的方向有发言权。&lt;/p&gt;
&lt;p&gt;还有一个简单的 Litmus 测试：对于开源基金会的项目，对于谁可以对重要决策进行投票，以及如何成为决策委员会的一部分，都有明确的规则。在某些基金会（例如 ASF）中，它基于社区成员的个人功绩，而在某些基金会（例如&lt;a href=&#34;https://www.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; CNCF &lt;/a&gt;）中，它从成为付费成员组织的员工开始。在基于区块链的开源项目中，它是基于&lt;a href=&#34;https://bit.ly/devprtcl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;令牌（Token）&lt;/a&gt;的投票持有人。其他基金会有不同的规则，但都力求在多个参与者之间实现中立和权力下放。如果一个项目由一家公司或一个人管理，你相信他们会为项目和社区的利益做出最佳决策。其中一些项目可能已经写下了他们遵循的治理规则，而有些可能根本没有。由你来确定治理动态及其对你的项目参与的重要性。除了具有治理透明度和公开决策之外，另一个方面是治理机构的信任度和声誉。当你查看项目的治理委员会时，是否有一位或一组具有经过验证的技术和社交技能的领导者，让你相信他们可以将项目提升到一个新的水平？或者你是否看到一个在政治斗争中不断争论的团体？这些是开源项目是否会成功并长期发展的一些指标，还是可以预期的头痛和停滞。&lt;/p&gt;
&lt;h2 id=&#34;基础设施&#34;&gt;基础设施&lt;/h2&gt;
&lt;p&gt;拥有开源许可可能在技术上有资格作为开源项目，但这并不能说明项目是否以开源方式构建。有许多在 OSI 批准的许可下发布的软件示例，但它们是在封闭的基础设施之后开发的。通过基础设施，我的意思是用户快速提问的聊天频道。进行更深入的开发人员讨论的论坛和邮件列表。审查拉取请求的源代码管理系统，以及运行测试和每晚创建二进制文件的构建服务器。&lt;/p&gt;
&lt;p&gt;对于关注开源项目的商务人士和律师来说，这些可能并不重要，但对于将要使用开源项目的技术人员来说，这些是一些假设的好处。这里要做的检查是探索软件是否是使用开放式基础设施以开源方式开发的，而不是闭门造车。以下是几个示例问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户可以在项目聊天中提出问题并在没有中间人的情况下从另一个用户那里得到答案吗？&lt;/li&gt;
&lt;li&gt;开发人员能否与项目提交者联系并获得深入的技术问题的答案？&lt;/li&gt;
&lt;li&gt;你能否运行最新版本并确认已知的错误已修复？&lt;/li&gt;
&lt;li&gt;架构师可以参加每周一次的社区电话会议并确定项目的未来方向吗？（原文 Can an architect the weekly community call and figure out the future direction of the project? ）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于封闭的基础架构，你必须创建支持工单并付费才能获得类似问题的答案。通过开放的基础设施和开放的参与，那些知道如何以开源方式工作的人可以获得答案。&lt;/p&gt;
&lt;h2 id=&#34;社区和采用&#34;&gt;社区和采用&lt;/h2&gt;
&lt;p&gt;开源软件的主要好处之一是它允许好创意的发展和传播。你可能拥有最先进的技术、最宽松的许可和开放式开发，但如果该软件没有不断壮大的社区和不断提高的采用率，那就是一个值得调查的迹象。不同的项目会有不同的采用率。有些可能会迅速成长为主流或被其他同类型项目所取代。一些项目可能有一个小但持续的增长率和一个持续数十年的生态社区。社区规模和采用率是开源项目的最终寿命指标。以下是你可以提出的一些示例问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目中有多少活跃的开发人员（提交者），平均提交率是多少？&lt;/li&gt;
&lt;li&gt;上个月有多少用户订阅了用户论坛以及提出了多少问题？&lt;/li&gt;
&lt;li&gt;软件的最新稳定版本已被下载多少次？&lt;/li&gt;
&lt;li&gt;还有哪些项目和服务&lt;a href=&#34;https://libraries.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;依赖&lt;/a&gt;并使用这个项目？&lt;/li&gt;
&lt;li&gt;有多少商业组织支持这个项目？&lt;/li&gt;
&lt;li&gt;是否有商业组织围绕它提供产品、支持和服务？&lt;/li&gt;
&lt;li&gt;这个项目有多少 StackOverflow 问题？&lt;/li&gt;
&lt;li&gt;有多少书籍、会议演讲和职位描述提到了这个项目？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行这些问题会给你一个指示，即该项目是在增长并成为其领域的事实上的标准，还是停滞不前并可能被下一个大项目所取代。&lt;/p&gt;
&lt;p&gt;通常，开源与快节奏的开发和创新有关。同时，开源也是一种创建广泛采用和创建非官方标准的机制。许多开源项目已经变成了标准，例如用于容器编排的 Kubernetes、用于流处理的 Apache Kafka、用于 Web 服务器的 Apache httpd 等。软件中最昂贵的事情之一是找到具有合适技能的人。使用采用率高的开源项目将使你有更好的机会找到技术娴熟的人，并让他们能够更长时间地重复使用他们的技能。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;根据开源项目的关键程度，有不同的风险和评估标准。对于战略性的、难以替代的项目，这将是你的 IT 基础设施的基础，你需要是已经成为其领域事实上的开源标准的完善项目。在这里确定谁拥有该项目的商标以及谁将成为你的长期合作伙伴非常重要。通常，这些合作伙伴是项目所属软件基金会的成员组织或持有项目 IP 的单个公司。对于后者，你可能需要考虑长期风险，例如核心开发人员分叉项目的机会、提供项目即服务的超大规模者、公司收购等。&lt;/p&gt;
&lt;p&gt;对于交付速度最重要的非战略性、战术性、短期项目，你可以让你的开发人员根据开放性、社区协作和热度（对于某些前端技术很重要）来推动选择和挑选项目。在这里，定期的安全修复、开发人员支持和许可兼容性检查等中短期风险可能就足够了。&lt;/p&gt;
&lt;p&gt;在任何一种情况下，都没有适合所有情况的单一评估标准。你必须在长期商业风险、技术稳定性与最新热度、创新和开发人员满意度之间取得平衡。这里的框架将为你概括需要探索的领域和需要考虑的一些风险。祝你好运！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云上细粒度访问管理的参考架构</title>
      <link>https://cloudnative.to/blog/access-management-reference-architecture/</link>
      <pubDate>Sat, 08 May 2021 10:30:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/access-management-reference-architecture/</guid>
      <description>&lt;p&gt;本文翻译自 &lt;a href=&#34;https://www.infoq.com/articles/access-management-reference-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A Reference Architecture for Fine-Grained Access Management on the Cloud&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;什么是访问管理&#34;&gt;什么是访问管理？&lt;/h1&gt;
&lt;p&gt;访问管理是识别用户或一组用户是否应该能够访问给定资源（例如主机、服务或数据库）的过程。例如，对于开发人员来说是否可以使用 SSH 登录生产应用程序服务器，如果可以，那么可以登录多长时间？如果 SRE 在非支持时间尝试访问数据库，他们这样做？如果数据工程师已转移到其他团队，他们是否应该继续访问 ETL 管道的 S3 存储桶？&lt;/p&gt;
&lt;h1 id=&#34;现在如何进行访问管理&#34;&gt;现在如何进行访问管理？&lt;/h1&gt;
&lt;p&gt;在云上各种基础设施和数据服务激增之前，访问管理是 DevOps 和 Security 团队要解决的相对简单的问题。VPN 和堡垒主机是（现在仍然是）在网络级别封锁所有关键资源的首选机制。用户必须先通过 VPN 服务器进行身份验证，或者登录到堡垒主机，然后才能访问专用网络上的所有资源。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/27/16195301216852.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当资源是静态的并且它们的数量相对较小时，此方法效果很好。但是，随着越来越多的资源动态地涌入专用网络的各处，VPN / 堡垒主机解决方案变得站不住脚。&lt;/p&gt;
&lt;p&gt;具体来说，在三个方面，VPN 和堡垒主机不足以作为一种有效的访问管理机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;它们作用于网络层面&lt;/strong&gt;：用户通过 VPN 进行身份验证并获得对专用网络的访问权限后，他们实际上就可以访问其上运行的所有服务。无法根据用户的身份在基础架构或数据服务的粒度上管理访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;凭据是攻击的媒介&lt;/strong&gt;：VPN 和堡垒主机都要求用户记住并存储凭据。过期和轮换凭证作为安全策略非常困难，尤其是在涉及大量用户的情况下，凭证因此成为潜在的攻击媒介。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不能管理第三方 SaaS 工具&lt;/strong&gt;：SaaS 工具（如 Looker、Tableau 和 Periscope Data）需要直接访问数据端点。因此，使用这些工具访问数据的任何人都无法通过使用了相同的机制和凭据的基础设施进行身份验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;云上访问管理的新架构&#34;&gt;云上访问管理的新架构&lt;/h1&gt;
&lt;p&gt;在本文中，我们将定义新的参考架构，为那些正在寻求简化访问管理云资源（从 SSH 主机、数据库、数据仓库到消息管道和云存储终结点）解决方案的云原生企业。&lt;/p&gt;
&lt;p&gt;它解决了 VPN 和堡垒主机无法克服的以下特定挑战：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在细粒度的服务级别上进行访问鉴权&lt;/li&gt;
&lt;li&gt;消除共享凭据和个人帐户管理&lt;/li&gt;
&lt;li&gt;通过第三方 SaaS 工具控制访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，它为具有敏感数据的组织带来以下商业利益：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过跨所有服务的会话记录和活动监视来满足 FedRamp 和 SOC2 等合规性标准的可审核性&lt;/li&gt;
&lt;li&gt;基于访问者的身份，通过细粒度的授权策略来限制或清除敏感数据，从而实现隐私和数据治理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该架构建立在以下三个核心原则的基础上，这些原则的实现使 DevOps 和 Security 团队可以在对所有环境进行全面控制的同时，通过简单而一致的体验来提高用户的工作效率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为访问资源的用户建立不可否认的身份&lt;/li&gt;
&lt;li&gt;使用短期的短暂令牌和证书代替静态凭证和密钥&lt;/li&gt;
&lt;li&gt;在一处集中所有资源类型的细粒度访问策略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图显示了参考架构及其组件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/27/16195323349746.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上图中的 VPN / 堡垒主机已替换为接入网关（Access Gateway）。接入网关实际上是微服务的集合，负责验证单个用户、基于特定属性授权他们的请求，并最终授予他们访问专用网络中的基础结构和数据服务的权限。&lt;/p&gt;
&lt;p&gt;接下来，让我们看一下各个组件，以了解之前概括的核心原理是如何实现的。&lt;/p&gt;
&lt;h2 id=&#34;访问控制器&#34;&gt;访问控制器&lt;/h2&gt;
&lt;p&gt;支持此体系结构的关键见解是将用户身份验证委派给单个服务（访问控制器），而不是将责任分配给用户可能需要访问的服务。这种联合在 SaaS 应用程序世界中很常见。由单一服务负责身份验证，可以简化应用程序所有者的用户配置和接触配置，并加快应用程序开发。&lt;/p&gt;
&lt;p&gt;对于实际的身份验证序列，访问控制器本身通常会与身份提供商集成，例如 &lt;a href=&#34;https://auth0.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Auth0&lt;/a&gt; 或 &lt;a href=&#34;https://www.okta.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Okta&lt;/a&gt;，因此，可以跨提供者和协议提供有用的抽象。最终，身份提供商以签名的 SAML 声明\JWT 令牌或临时证书的形式保证用户的身份不可否认。这样就无需依赖受信任的子网作为用户身份的代理。与 VPN 允许用户访问网络上的所有服务不同，它还允许将访问策略配置到服务的粒度。&lt;/p&gt;
&lt;p&gt;将身份验证委派给身份提供者的另一个好处是，可以使用零信任原则对用户进行身份验证。 具体来说，可以创建身份提供者策略以强制执行以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;禁止从信誉不佳的地理位置和 IP 地址访问&lt;/li&gt;
&lt;li&gt;禁止从已知漏洞的设备（未修补的 OS、较旧的浏览器等）进行访问&lt;/li&gt;
&lt;li&gt;成功进行 SAML 交换后立即触发 MFA&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;身份验证序列如何工作&#34;&gt;身份验证序列如何工作：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;用户首先通过访问控制器进行身份验证，访问控制器又将身份验证委派给身份提供者。&lt;/li&gt;
&lt;li&gt;成功登录到身份提供者后，访问控制器将生成一个短暂的临时证书，进行签名并将其返回给用户。或者，它可以代替证书生成令牌。只要证书或令牌有效，就可以将其用于连接到 接入网关管理的任何授权基础设施或数据服务。到期后，必须获取新的证书或令牌。&lt;/li&gt;
&lt;li&gt;用户将在步骤（2）中获得的证书传递给他们选择的工具，然后连接到接入网关。根据用户请求访问的服务，基础设施网关或数据网关将首先允许访问控制器验证用户的证书，然后再允许他们访问该服务。因此，访问控制器充当用户与其访问的服务之间的 CA，因此为每个用户提供了不可否认的身份。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;策略引擎&#34;&gt;策略引擎&lt;/h2&gt;
&lt;p&gt;当访问控制器强制对用户进行身份验证时，策略引擎会对用户的请求强制进行细粒度的授权。它以易于使用的 YAML 语法接受授权规则（查看最后的示例），并根据用户请求和响应对它们进行评估。&lt;/p&gt;
&lt;p&gt;开放策略代理（OPA）是一个开源的 CNCF 项目，是策略引擎的一个很好的例子。它可以自己作为微服务运行，也可以用作其他微服务进程空间中的库。OPA 中的策略以称为 Rego 的语言编写。另外，也可以在 Rego 之上轻松构建一个简单的 YAML 界面，以简化政策规范。&lt;/p&gt;
&lt;p&gt;具有独立于基础结构和数据服务的安全模型的独立策略引擎的优点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以以与服务和位置无关的方式指定安全策略
&lt;ul&gt;
&lt;li&gt;例如在所有 SSH 服务器上禁止特权命令&lt;/li&gt;
&lt;li&gt;例如强制执行 MFA 检查所有服务（基础设施和数据）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;策略可以保存在一个地方并进行版本控制
&lt;ul&gt;
&lt;li&gt;策略可以作为代码签入 GitHub 存储库&lt;/li&gt;
&lt;li&gt;每项变更在提交之前都要经过协作审核流程&lt;/li&gt;
&lt;li&gt;存在版本历史记录，可以轻松地还原策略更改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基础设施网关和数据网关都依赖于策略引擎，以分别评估用户的基础设施和数据活动。&lt;/p&gt;
&lt;h2 id=&#34;基础设施网关&#34;&gt;基础设施网关&lt;/h2&gt;
&lt;p&gt;基础设施网关管理和监控对基础设施服务的访问，例如 SSH 服务器和 Kubernetes 集群。它与策略引擎连接，以确定细化的授权规则，并在用户会话期间对所有基础设施活动强制执行这些规则。 为了实现负载平衡，网关可以包含一组工作节点，可以在 AWS 上部署为自动扩展组，也可以在 Kubernetes 集群上作为副本集运行。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.boundaryproject.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hashicorp 边界&lt;/a&gt; 是基础设施网关的示例。这是一个开源项目，使开发人员、DevOps 和 SRE 可以使用细粒度的授权来安全地访问基础设施服务（SSH 服务器、Kubernetes 群集），而无需直接访问网络，同时又禁止使用 VPN 或堡垒主机。&lt;/p&gt;
&lt;p&gt;基础设施网关支持 SSH 服务器和 Kubernetes 客户端使用的各种连接协议，并提供以下关键功能：&lt;/p&gt;
&lt;h3 id=&#34;会话记录&#34;&gt;会话记录&lt;/h3&gt;
&lt;p&gt;这涉及复制用户在会话期间执行的每个命令。捕获的命令通常会附加其他信息，例如用户的身份、他们所属的各种身份提供者组、当天的时间、命令的持续时间以及响应的特征（是否成功、是否有错误、是否已读取或写入数据等）。&lt;/p&gt;
&lt;h3 id=&#34;活动监控&#34;&gt;活动监控&lt;/h3&gt;
&lt;p&gt;监控使会话记录的概念更进一步。除了捕获所有命令和响应，基础设施网关还将安全策略应用于用户的活动。在发生违规的情况下，它可以选择触发警报、阻止有问题的命令及其响应或完全终止用户的会话。&lt;/p&gt;
&lt;h2 id=&#34;数据网关&#34;&gt;数据网关&lt;/h2&gt;
&lt;p&gt;数据网关管理和监控对数据服务的访问，例如 MySQL、PostgreSQL 和 MongoDB 等托管数据库、AWS RDS 等 DBaaS 端点、Snowflake 和 Bigquery 等数据仓库、AWS S3 等云存储以及 Kafka 和 Kinesis。它与策略引擎连接，以确定细化的授权规则，并在用户会话期间对所有数据活动强制执行这些规则。&lt;/p&gt;
&lt;p&gt;与基础设施网关类似，数据网关可以包含一组工作节点，可以在 AWS 上部署为自动扩展组，也可以在 Kubernetes 集群上作为副本集运行。&lt;/p&gt;
&lt;p&gt;由于与基础设施服务相比，数据服务的种类更多，因此数据网关通常将支持大量的连接协议和语法。&lt;/p&gt;
&lt;p&gt;此类数据网关的示例是 &lt;a href=&#34;https://cyral.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cyral&lt;/a&gt;，这是一种轻量级的拦截服务，以边车（sidecar）的方式部署来监控和管理对现代数据终端节点的访问，如 AWS RDS、Snowflake、Bigquery，、AWS S3、Apache Kafka 等。其功能包括：&lt;/p&gt;
&lt;h3 id=&#34;会话记录-1&#34;&gt;会话记录&lt;/h3&gt;
&lt;p&gt;这类似于记录基础设施活动，并且涉及用户在会话期间执行的每个命令的副本，并使用丰富的审计信息进行注释。&lt;/p&gt;
&lt;h3 id=&#34;活动监控-1&#34;&gt;活动监控&lt;/h3&gt;
&lt;p&gt;同样，这类似于监视基础设施活动。例如，以下策略阻止数据分析人员读取敏感的客户 PII。&lt;/p&gt;
&lt;h3 id=&#34;隐私权执行&#34;&gt;隐私权执行&lt;/h3&gt;
&lt;p&gt;与基础设施服务不同，数据服务授予用户对通常位于数据库、数据仓库、云存储和消息管道中的与客户、合作伙伴和竞争对手有关的敏感数据的读写访问权限。 出于隐私原因，对数据网关的一个非常普遍的要求是能够清理（也称为令牌化或屏蔽）PII，例如电子邮件、姓名、社会保险号、信用卡号和地址。&lt;/p&gt;
&lt;h2 id=&#34;那么这种体系结构如何简化访问管理&#34;&gt;那么这种体系结构如何简化访问管理？&lt;/h2&gt;
&lt;p&gt;让我们看一些常见的访问管理方案，以了解与使用 VPN 和堡垒主机相比，接入网关架构如何提供细粒度的控制。&lt;/p&gt;
&lt;h2 id=&#34;特权活动监控pam&#34;&gt;特权活动监控（PAM）&lt;/h2&gt;
&lt;p&gt;这是一个简单的策略，可以在一个地方监视所有基础设施和数据服务中的特权活动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅允许属于 Admins 和 SRE 组的个人在 SSH 服务器、Kubernetes 集群和数据库上运行特权命令。&lt;/li&gt;
&lt;li&gt;虽然可以运行特权命令，但是有一些例外形式的限制。具体来说，以下命令是不允许的：
&lt;ul&gt;
&lt;li&gt;“sudo” 和 “yum” 命令可能无法在任何 SSH 服务器上运行&lt;/li&gt;
&lt;li&gt;“kubectl delete” 和 “kubectl taint” 命令可能无法在任何 Kubernetes 集群上运行&lt;/li&gt;
&lt;li&gt;“drop table” 和 “create user” 命令可能无法在任何数据库上运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/27/16195354276750.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;零特权zsp执行&#34;&gt;零特权（ZSP）执行&lt;/h2&gt;
&lt;p&gt;下一个策略显示了一个实施零特权的示例——一种默认情况下没有人可以访问基础设施或数据服务的范例。只有满足一个或多个合格标准，才能获得访问权限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只允许属于支持组的个人访问&lt;/li&gt;
&lt;li&gt;个人必须 on-call 才能获得访问权限。可以通过检查事件响应服务（例如 PagerDuty）中的时间表来确定通话状态&lt;/li&gt;
&lt;li&gt;成功通过身份验证后会触发多因子身份验证（MFA）检查&lt;/li&gt;
&lt;li&gt;他们必须使用 TLS 连接到基础设施或数据服务&lt;/li&gt;
&lt;li&gt;最后，如果正在访问数据服务，则不允许进行全表扫描（例如，缺少 WHERE 或 LIMIT 子句的 SQL 请求最终将读取整个数据集）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/27/16195356881012.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;隐私和数据保护&#34;&gt;隐私和数据保护&lt;/h2&gt;
&lt;p&gt;最后一条策略显示了涉及数据清理的数据治理示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果市场营销人员正在访问 PII（社会保险号（SSN）、信用卡号（CCN）、年龄），先清洗数据然后再返回&lt;/li&gt;
&lt;li&gt;如果有人正在使用 Looker 或 Tableau 服务访问 PII，同时清洗数据&lt;/li&gt;
&lt;li&gt;清理规则由 PII 的特定类型定义
&lt;ul&gt;
&lt;li&gt;对于 SSN，清洗前 5 位数字&lt;/li&gt;
&lt;li&gt;对于 CCN，清洗最后 4 位数字&lt;/li&gt;
&lt;li&gt;对于年龄，请清洗最后一位数字，即请求者将知道年龄段，但从不知道实际年龄&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/27/16195358881245.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;概括&#34;&gt;概括&lt;/h2&gt;
&lt;p&gt;我们看到，对于高度动态的云环境，VPN 和堡垒主机不足以作为高效云环境中的有效访问管理机制。一种新的访问管理体系结构，其重点是不可否认的用户身份，短暂的证书或令牌以及集中的细粒度授权引擎，可有效解决 VPN 和堡垒主机无法解决的难题。除了为访问关键基础设施和数据服务的用户提供全面的安全性之外，该体系结构还可以帮助组织实现其审核、合规性、隐私和保护目标。&lt;/p&gt;
&lt;p&gt;我们还讨论了该架构的参考实现，其中使用了以开发人员为中心的著名开源解决方案，例如 Hashicorp Boundary 和 OPA 以及 Cyral（一种用于现代数据服务的快速且无状态的辅助工具）。 他们一起可以在云上提供细粒度且易于使用的访问管理解决方案。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://atbug.oss-cn-hangzhou.aliyuncs.com/2021/04/27/16195361264391.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Manav Mital&lt;/strong&gt; 是 Cyral 的联合创始人兼首席执行官，Cyral 是首个为数据云提供可见性、访问控制和保护的云原生安全服务。Cyral 成立于 2018 年，与各种组织合作 - 从云原生初创企业到财富 500 强企业，因为它们采用 DevOps 文化和云技术来管理和分析数据。 Manav 拥有 UCLA 的计算机科学硕士学位和坎普尔的印度理工学院的计算机科学学士学位。&lt;/p&gt;
&lt;h2 id=&#34;关于译者&#34;&gt;关于译者&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Addo Zhang&lt;/strong&gt; 云原生从业人员，爱好各种代码。更多翻译：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/beRHn9l2K4eiS8M1IevcRA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;分布式系统在 Kubernetes 上的进化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/V6lO9sT_6hJVled9sOI4IA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2021 年及未来的云原生预测&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/mw9LhDPiTyooUAXAoKHwTA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用架构：为什么要随着市场演进&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>分布式系统在 Kubernetes 上的进化</title>
      <link>https://cloudnative.to/blog/distributed-systems-kubernetes/</link>
      <pubDate>Mon, 29 Mar 2021 22:30:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/distributed-systems-kubernetes/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://www.infoq.com/articles/distributed-systems-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Evolution of Distributed Systems on Kubernetes&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在 3 月份的 QCon 上，我做了一个关于 Kubernetes 的分布式系统进化的演讲。首先，我想先问一个问题，微服务之后是什么？我相信大家都有各自的答案，我也有我的答案。你会在最后发现我的想法是什么。为了达到这个目的，我建议大家看看分布式系统的需求是什么？以及这些需求在过去是如何发展的，从单体应用开始到 Kubernetes，再到最近的 Dapr、Istio、Knative 等项目，它们是如何改变我们做分布式系统的方式。我们将尝试对未来做一些预测。&lt;/p&gt;
&lt;h2 id=&#34;现代分布式应用&#34;&gt;现代分布式应用&lt;/h2&gt;
&lt;p&gt;为了给这个话题提供更多的背景信息，我认为的分布式系统是由数百个组件组成的系统。这些组件可以是有状态的、无状态的或者无服务器的。此外，这些组件可以用不同的语言创建，运行在混合环境上，并开发开源技术、开放标准和互操作性。我相信你可以使用闭源软件来构建这样的系统，也可以在 AWS 和其他地方构建。具体到这次演讲，我将关注 Kubernetes 生态系统，以及你如何在 Kubernetes 平台上构建这样一个系统。&lt;/p&gt;
&lt;p&gt;我们从分布式系统的需求讲起。我认为是我们要创建一个应用或者服务，并写一些业务逻辑。那从运行时的平台到构建分布式系统，我们还需要什么呢？在底层，最开始是我们要一些生命周期的能力。当你用任一语言开发你的应用时，我们希望有能力把这个应用可靠地打包和部署、回滚、健康检查。并且能够把应用部署到不同的节点上，并实现资源隔离、扩展、配置管理，以及所有这些。这些都是你创建分布式应用所需要的第一点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/55image001-1616431697020_hu613d9ccb7375737a591578d947068bcb_107667_272bb665358a944e4728533c8f993354.webp 400w,
               /blog/distributed-systems-kubernetes/55image001-1616431697020_hu613d9ccb7375737a591578d947068bcb_107667_49e787feb828b444f870ba9ab93ff1f5.webp 760w,
               /blog/distributed-systems-kubernetes/55image001-1616431697020_hu613d9ccb7375737a591578d947068bcb_107667_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/55image001-1616431697020_hu613d9ccb7375737a591578d947068bcb_107667_272bb665358a944e4728533c8f993354.webp&#34;
               width=&#34;760&#34;
               height=&#34;393&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第二点是围绕网络。我们有了应用之后，我们希望它能够可靠地连接到其他服务，无论该服务是在集群内部还是在外部。我们希望其具有服务发现、负载均衡的能力。为了不同的发布策略或是其他的一些原因的我们希望有流量转移的能力。然后我们还希望其具有与其他系统进行弹性通信的能力，无论是通过重试、超时还是断路器。要有适当的安全保障，并且要有足够的监控、追踪、可观察性等等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/25image002-1616431698392_hu40d65728dbe864d1bd589c9bb7469dd4_106207_c98f57c81a8f9e65ad0d97db12875398.webp 400w,
               /blog/distributed-systems-kubernetes/25image002-1616431698392_hu40d65728dbe864d1bd589c9bb7469dd4_106207_b2a70454f781665ceadd4724463ea5b7.webp 760w,
               /blog/distributed-systems-kubernetes/25image002-1616431698392_hu40d65728dbe864d1bd589c9bb7469dd4_106207_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/25image002-1616431698392_hu40d65728dbe864d1bd589c9bb7469dd4_106207_c98f57c81a8f9e65ad0d97db12875398.webp&#34;
               width=&#34;760&#34;
               height=&#34;399&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们有了网络之后，接下来就是我们希望有能力与不同的 API 和端点交互，即资源绑定&amp;ndash;与其他协议和不同的数据格式交互。甚至能够从一种数据格式转换成另一种数据格式。我还会在这里加入诸如过滤功能，也就是说，当我们订阅一个主题时，我们也许只对某些事件感兴趣。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/45image003-1616431697873_hue12043d2dd7d631830018414064ed60d_103753_c9e1126d291776f6e16d2a97a6ff8510.webp 400w,
               /blog/distributed-systems-kubernetes/45image003-1616431697873_hue12043d2dd7d631830018414064ed60d_103753_dc6f6a1e0db4bff235d2ced1bb755cc8.webp 760w,
               /blog/distributed-systems-kubernetes/45image003-1616431697873_hue12043d2dd7d631830018414064ed60d_103753_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/45image003-1616431697873_hue12043d2dd7d631830018414064ed60d_103753_c9e1126d291776f6e16d2a97a6ff8510.webp&#34;
               width=&#34;760&#34;
               height=&#34;391&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;你认为最后一类是什么？是状态。当我在说状态和有状态的抽象时，我并不是在谈论实际的状态管理，比如数据库或者文件系统的功能。我要说的更多是有关幕后依赖状态的开发人员抽象。可能，你需要具有工作流管理的能力。也许你想管理运行时间长的进程或者做临时调度或者某些定时任务来定期运行服务。也许你还想进行分布式缓存，具有幂等性或者支持回滚。所有这些都是开发人员级的原语，但在幕后，它们依赖于具有某种状态。你想随意使用这些抽象来创建完善的分布式系统。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/26image004-1616431697348_hu736938cf73b10d10a79aa5587129f163_70806_8cf3cd74afe9c6ec75c5d87d09420deb.webp 400w,
               /blog/distributed-systems-kubernetes/26image004-1616431697348_hu736938cf73b10d10a79aa5587129f163_70806_714c2b245b2bb2b4c901d8114b64c883.webp 760w,
               /blog/distributed-systems-kubernetes/26image004-1616431697348_hu736938cf73b10d10a79aa5587129f163_70806_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/26image004-1616431697348_hu736938cf73b10d10a79aa5587129f163_70806_8cf3cd74afe9c6ec75c5d87d09420deb.webp&#34;
               width=&#34;760&#34;
               height=&#34;430&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们将使用这个分布式系统原语的框架来评估它们在 Kubernetes 和其他项目上的变化情况。&lt;/p&gt;
&lt;h2 id=&#34;单体架构传统中间件功能&#34;&gt;单体架构——传统中间件功能&lt;/h2&gt;
&lt;p&gt;假设我们从单体架构以及如何获得这些能力开始。在那种情况下，首先是当我说单体的时候，在分布式应用的情况下我想到的是 ESB。ESB 是相当强大的，当我们检查我们的需求列表时，我们会说 ESB 对所有有状态的抽象有很好的支持。&lt;/p&gt;
&lt;p&gt;使用 ESB，你可以进行长时间运行的流程的编排、分布式事务、回滚和幂等。此外，ESB 还提供了出色的资源绑定能力，并且有数百个连接器，支持转换、编排，甚至有联网功能。最后，ESB 甚至可以做服务发现和负载均衡。&lt;/p&gt;
&lt;p&gt;它具有围绕网络连接的弹性的所有功能，因此它可以进行重试。可能 ESB 本质上不是很分布式，所以它不需要非常高级的网络和发布能力。ESB 欠缺的主要是生命周期管理。因为它是单一运行时，所以第一件事就是你只能使用一种语言。通常是创建实际运行时的语言，Java、.NET 或者其他的语言。然后，因为是单一运行时，我们不能轻松地进行声明式的部署或者自动调配。部署是相当大且非常重的，所以它通常涉及到人机交互。这种单体架构的另一个难点是扩展：“我们无法扩展单个组件。”&lt;/p&gt;
&lt;p&gt;最后却并非最不重要的一点是，围绕隔离，无论是资源隔离还是故障隔离。使用单体架构无法完成所有这些工作。从我们的需求框架来看，ESB 的单体架构不符合条件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/40image005-1616431696438_hu132c6f72fea95f7770338885779e5c70_103984_f00ee50d827ae85fc488ba39086cc879.webp 400w,
               /blog/distributed-systems-kubernetes/40image005-1616431696438_hu132c6f72fea95f7770338885779e5c70_103984_720bc95a2e4bf7b9188865d52753f8ab.webp 760w,
               /blog/distributed-systems-kubernetes/40image005-1616431696438_hu132c6f72fea95f7770338885779e5c70_103984_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/40image005-1616431696438_hu132c6f72fea95f7770338885779e5c70_103984_f00ee50d827ae85fc488ba39086cc879.webp&#34;
               width=&#34;760&#34;
               height=&#34;401&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;云原生架构微服务和-kubernetes&#34;&gt;云原生架构——微服务和 Kubernetes&lt;/h2&gt;
&lt;p&gt;接下来，我建议我们研究一下云原生架构以及这些需求是如何变化的。如果我们从一个非常高的层面来看，这些架构是如何发生变化的，云原生可能始于微服务运动。微服务使我们可以按业务领域进行拆分单体应用。事实证明，容器和 Kubernetes 实际上是管理这些微服务的优秀平台。让我们来看一下 Kubernetes 对于微服务特别有吸引力的一些具体特性和功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/13image006-1616431699209_hu939656f418f043d112c2476a2cbd3075_59238_fd900d7b6227c1db9b32918193aabacf.webp 400w,
               /blog/distributed-systems-kubernetes/13image006-1616431699209_hu939656f418f043d112c2476a2cbd3075_59238_eed7e5d000515aa33ae55f3ffff88427.webp 760w,
               /blog/distributed-systems-kubernetes/13image006-1616431699209_hu939656f418f043d112c2476a2cbd3075_59238_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/13image006-1616431699209_hu939656f418f043d112c2476a2cbd3075_59238_fd900d7b6227c1db9b32918193aabacf.webp&#34;
               width=&#34;760&#34;
               height=&#34;447&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从一开始，进行健康状况探测的能力就是 Kubernetes 受欢迎的原因。在实践中，这意味着当你将容器部署到 Pod 中时，Kubernetes 会检查进程的运行状况。通常情况下，该过程模型还不够好。你可能仍然有一个已启动并正在运行的进程，但是它并不健康。这就是为什么还可以使用就绪度和存活度检查的原因。Kubernetes 会做一个就绪度检查，以确定你的应用在启动期间何时准备接受流量。它将进行活跃度检查，以检查服务的运行状况。在 Kubernetes 之前，这并不是很流行，但今天几乎所有语言、所有框架、所有运行时都有健康检查功能，你可以在其中快速启动端点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/29image007-1616431696697_hu72a1b45d33c8734b71c9791a83279455_47519_f6b0cfdfbecd32c16baa39cbef308a04.webp 400w,
               /blog/distributed-systems-kubernetes/29image007-1616431696697_hu72a1b45d33c8734b71c9791a83279455_47519_6b3ca111afafc344ed91f67cc75c267e.webp 760w,
               /blog/distributed-systems-kubernetes/29image007-1616431696697_hu72a1b45d33c8734b71c9791a83279455_47519_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/29image007-1616431696697_hu72a1b45d33c8734b71c9791a83279455_47519_f6b0cfdfbecd32c16baa39cbef308a04.webp&#34;
               width=&#34;760&#34;
               height=&#34;388&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes 引入的下一个特性是围绕应用程序的托管生命周期——我的意思是，你不再控制何时启动、何时关闭服务。你相信平台可以做到这一点。Kubernetes 可以启动你的应用；它可以将其关闭，然后在不同的节点上移动它。为此，你必须正确执行平台在应用启动和关闭期间告诉你的事件。&lt;/p&gt;
&lt;p&gt;Kubernetes 流行的另一件特性是围绕着声明式部署。这意味着你不再需要启动服务；检查日志是否已经启动。你不必手动升级实例——支持声明式部署的 Kubernetes 可以为你做到这一点。根据你选择的策略，它可以停止旧实例并启动新实例。此外，如果出现问题，可以进行回滚。&lt;/p&gt;
&lt;p&gt;另外就是声明你的资源需求。创建服务时，将其容器化。最好告诉平台该服务将需要多少 CPU 和内存。Kubernetes 利用这些信息为你的工作负载找到最佳节点。在使用 Kubernetes 之前，我们必须根据我们的标准将实例手动放置到一个节点上。现在，我们可以根据自己的偏好来指导 Kubernetes，它将为我们做出最佳的决策。&lt;/p&gt;
&lt;p&gt;如今，在 Kubernetes 上，你可以进行多语言配置管理。无需在应用程序运行时进行配置查找就可以进行任何操作。Kubernetes 会确保配置最终在工作负载所在的同一节点上。这些配置被映射为卷或环境变量，以供你的应用程序使用。&lt;/p&gt;
&lt;p&gt;事实证明，我刚才谈到的那些特定功能也是相关的。比如说，如果要进行自动放置，则必须告诉 Kubernetes 服务的资源需求。然后，你必须告诉它要使用的部署策略。为了让策略正确运行，你的应用程序必须执行来自环境的事件。它必须执行健康检查。一旦采用了所有这些最佳实践并使用所有这些功能，你的应用就会成为出色的云原生公民，并且可以在 Kubernetes 上实现自动化了（这是在 Kubernetes 上运行工作负载的基本模式）。最后，还有围绕着构建 Pod 中的容器、配置管理和行为，还有其他模式。&lt;/p&gt;
&lt;p&gt;我要简要介绍的下一个主题是工作负载。从生命周期的角度来看，我们希望能够运行不同的工作负载。我们也可以在 Kubernetes 上做到这一点。运行十二要素应用程序和无状态微服务非常简单。Kubernetes 可以做到这一点。这不是你将要承担的唯一工作量。可能你还有有状态的工作负载，你可以使用有状态集在 Kubernetes 上完成此工作。&lt;/p&gt;
&lt;p&gt;你可能还有的另一个工作负载是单例。也许你希望某个应用程序的实例是整个集群中应用程序的唯一一个实例&amp;ndash;你希望它成为可靠的单例。如果失败，则重新启动。因此，你可以根据需求以及是否希望单例至少具有一种或最多一种语义来在有状态集和副本集之间进行选择。你可能还有的另一个工作负载是围绕作业和定时作业&amp;ndash;有了 Kubernetes，你也可以实现这些。&lt;/p&gt;
&lt;p&gt;如果我们将所有这些 Kubernetes 功能映射到我们的需求，则 Kubernetes 可以满足生命周期需求。我通常创建的需求列表主要是由 Kubernetes 今天提供给我们的。这些是任何平台上的预期功能，而 Kubernetes 可以为你的部署做的是配置管理、资源隔离和故障隔离。此外，除了无服务器本身之外，它还支持其他工作负载。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/12image008-1616431698134_huad01425b13819d58bf5ce7fe8cf70809_102465_db7c3aec9e36e30744e97f2a510cb1cf.webp 400w,
               /blog/distributed-systems-kubernetes/12image008-1616431698134_huad01425b13819d58bf5ce7fe8cf70809_102465_3f8d0c85af8113954837b304233ff9cc.webp 760w,
               /blog/distributed-systems-kubernetes/12image008-1616431698134_huad01425b13819d58bf5ce7fe8cf70809_102465_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/12image008-1616431698134_huad01425b13819d58bf5ce7fe8cf70809_102465_db7c3aec9e36e30744e97f2a510cb1cf.webp&#34;
               width=&#34;760&#34;
               height=&#34;412&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然后，如果这就是 Kubernetes 给开发者提供的全部功能，那么我们该如何扩展 Kubernetes 呢？以及如何使它具有更多功能？因此，我想描述当今使用的两种常用方法。&lt;/p&gt;
&lt;h2 id=&#34;进程外扩展机制&#34;&gt;进程外扩展机制&lt;/h2&gt;
&lt;p&gt;首先是 Pod 的概念，Pod 是用于在节点上部署容器的抽象。此外，Pod 给我们提供了两组保证：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一组是部署保证 &amp;ndash; Pod 中的所有容器始终位于同一个节点上。这意味着它们可以通过 localhost 相互通信，也可以使用文件系统或通过其他 IPC 机制进行异步通信。&lt;/li&gt;
&lt;li&gt;Pod 给我们的另一组保证是围绕生命周期的。Pod 中的所有容器并非都相等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/22image009-1616431698660_hub72f2e05da37ce6ca521d57fcfa5aed2_120673_b94da961c1db132e2a82bf358e00191c.webp 400w,
               /blog/distributed-systems-kubernetes/22image009-1616431698660_hub72f2e05da37ce6ca521d57fcfa5aed2_120673_02b1168f05c88b72708bb616a44214a2.webp 760w,
               /blog/distributed-systems-kubernetes/22image009-1616431698660_hub72f2e05da37ce6ca521d57fcfa5aed2_120673_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/22image009-1616431698660_hub72f2e05da37ce6ca521d57fcfa5aed2_120673_b94da961c1db132e2a82bf358e00191c.webp&#34;
               width=&#34;760&#34;
               height=&#34;420&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;根据使用的是 init 容器还是应用程序容器，你会获得不同的保证。例如，init 容器在开始时运行；当 Pod 启动时，它按顺序一个接一个地运行。他们仅在之前的容器已成功完成时运行。它们有助于实现由容器驱动的类似工作流的逻辑。&lt;/p&gt;
&lt;p&gt;另一方面，应用程序容器是并行运行的。它们在整个 Pod 的生命周期中运行，这也是 sidecar 模式的基础。sidecar 可以运行多个容器，这些容器可以协作并共同为用户提供价值。这也是当今我们看到的扩展 Kubernetes 附加功能的主要机制之一。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/9image010-1616431695489_huc21e0dbf873b2b18dd3a2e6f250cddaa_58896_60ab023347f9e52446de178e5a87ca9c.webp 400w,
               /blog/distributed-systems-kubernetes/9image010-1616431695489_huc21e0dbf873b2b18dd3a2e6f250cddaa_58896_3bba45198e1107fe0d3fab8124725b5b.webp 760w,
               /blog/distributed-systems-kubernetes/9image010-1616431695489_huc21e0dbf873b2b18dd3a2e6f250cddaa_58896_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/9image010-1616431695489_huc21e0dbf873b2b18dd3a2e6f250cddaa_58896_60ab023347f9e52446de178e5a87ca9c.webp&#34;
               width=&#34;760&#34;
               height=&#34;510&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了解释以下功能，我必须简要地告诉你 Kubernetes 内部的工作方式。它是基于调谐循环的。调谐循环的思想是将期望状态驱动到实际状态。在 Kubernetes 中，很多功能都是靠这个来实现的。例如，当你说我要两个 Pod 实例，这系统的期望状态。有一个控制循环不断地运行，并检查你的 Pod 是否有两个实例。如果不存在两个实例，它将计算差值。它将确保存在两个实例。&lt;/p&gt;
&lt;p&gt;这方面的例子有很多。一些是副本集或有状态集。资源定义映射到控制器是什么，并且每个资源定义都有一个控制器。该控制器确保现实世界与所需控制器相匹配，你甚至可以编写自己的自定义控制器。&lt;/p&gt;
&lt;p&gt;当在 Pod 中运行应用程序时，你将无法在运行时加载任何配置文件更改。然而，你可以编写一个自定义控制器，检测 config map 的变化，重新启动 Pod 和应用程序&amp;ndash;从而获取配置更改。&lt;/p&gt;
&lt;p&gt;事实证明，即使 Kubernetes 拥有丰富的资源集合，但它们并不能满足你的所有不同需求。Kubernetes 引入了自定义资源定义的概念。这意味着你可以对需求进行建模并定义适用于 Kubernetes 的 API。它与其他 Kubernetes 原生资源共存。你可以用能理解模型的任何语言编写自己的控制器。你可以设计一个用 Java 实现的 ConfigWatcher，描述我们前面所解释的内容。这就是 operator 模式，即与自定义资源定义一起使用的控制器。如今，我们看到很多 operator 加入，这就是第二种扩展 Kubernetes 附加功能的方式。&lt;/p&gt;
&lt;p&gt;接下来，我想简单介绍一下基于 Kubernetes 构建的一些平台，这些平台大量使用 sidecar 和 operator 来给开发者提供额外的功能。&lt;/p&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;让我们从服务网格开始，什么是服务网格？&lt;/p&gt;
&lt;p&gt;我们有两个服务，服务 A 要调用服务 B，并且可以用任何语言。把这个当做是我们的应用工作负载。服务网格使用 sidecar 控制器，并在我们的服务旁边注入一个代理。你最终会在 Pod 中得到两个容器。代理是一个透明的代理，你的应用对这个代理完全无感知&amp;ndash;它拦截所有传入和传出的流量。此外，代理还充当数据防火墙。&lt;/p&gt;
&lt;p&gt;这些服务代理的集合代表了你的数据平面，并且很小且无状态。为了获得所有状态和配置，它们依赖于控制平面。控制平面是保持所有配置，收集指标，做出决定并与数据平面进行交互的有状态部分。此外，它们是不同控制平面和数据平面的正确选择。事实证明，我们还需要一个组件-一个 API 网关，以将数据获取到我们的集群中。一些服务网格具有自己的 API 网关，而某些使用第三方。如果你研究下所有这些组件，它们将提供我们所需的功能。&lt;/p&gt;
&lt;p&gt;API 网关主要专注于抽象我们服务的实现。它隐藏细节并提供边界功能。服务网格则相反。在某种程度上，它增强了服务内的可见性和可靠性。可以说，API 网关和服务网格共同提供了所有网络需求。要在 Kubernetes 上获得网络功能，仅使用服务是不够的：“你需要一些服务网格。”&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/19image011-1616431696146_hua736156ab15f738466f4b208c2dd288a_92733_d0759acc6c97c273774c8faff1040591.webp 400w,
               /blog/distributed-systems-kubernetes/19image011-1616431696146_hua736156ab15f738466f4b208c2dd288a_92733_87b22af8d5148561b2bd3834ac014ec2.webp 760w,
               /blog/distributed-systems-kubernetes/19image011-1616431696146_hua736156ab15f738466f4b208c2dd288a_92733_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/19image011-1616431696146_hua736156ab15f738466f4b208c2dd288a_92733_d0759acc6c97c273774c8faff1040591.webp&#34;
               width=&#34;760&#34;
               height=&#34;592&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;什么是-knative&#34;&gt;什么是 Knative？&lt;/h2&gt;
&lt;p&gt;我要讨论的下一个主题是 Knative，这是 Google 几年前启动的一个项目。它是 Kubernetes 之上的一层，可为您提供无服务器功能，并具有两个主要模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Knative 服务 - 围绕着请求-应答交互，以及&lt;/li&gt;
&lt;li&gt;Knative Eventing - 更多的是用于事件驱动的交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只是让你感受一下，Knative Serving 是什么？通过 Knative Serving，你可以定义服务，但这不同于 Kubernetes 服务。这是 Knative 服务。使用 Knative 服务定义工作负载后，你就会得到具有无服务器的特征的部署。你不需要有启动并运行实例。它可以在请求到达时从零开始。你得到的是无服务器的能力；它可以迅速扩容，也可以缩容到零。&lt;/p&gt;
&lt;p&gt;Knative Eventing 为我们提供了一个完全声明式的事件管理系统。假设我们有一些要与之集成的外部系统，以及一些外部的事件生产者。在底部，我们将应用程序放在具有 HTTP 端点的容器中。借助 Knative Eventing，我们可以启动代理，该代理可以触发 Kafka 映射的代理，也可以在内存或者某些云服务中。此外，我们可以启动连接到外部系统的导入器，并将事件导入到我们的代理中。这些导入器可以基于，例如，具有数百个连接器的 Apache Camel。&lt;/p&gt;
&lt;p&gt;一旦我们将事件发送给代理，然后用 YAML 文件声明，我们可以让容器订阅这些事件。在我们的容器中，我们不需要任何消息客户端&amp;ndash;比如 Kafka 客户端。我们的容器将使用云事件通过 HTTP POST 获取事件。这是一个完全平台管理的消息传递基础设施。作为开发人员，你必须在容器中编写业务代码，并且不处理任何消息传递逻辑。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/8image012-1616431698919_hu1bfbd0067ee22e03acd2464f33e79d26_115403_f49026d59798dd5307fd510e7bb42c41.webp 400w,
               /blog/distributed-systems-kubernetes/8image012-1616431698919_hu1bfbd0067ee22e03acd2464f33e79d26_115403_96b27ffbc7ce312ba9997645c5a01469.webp 760w,
               /blog/distributed-systems-kubernetes/8image012-1616431698919_hu1bfbd0067ee22e03acd2464f33e79d26_115403_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/8image012-1616431698919_hu1bfbd0067ee22e03acd2464f33e79d26_115403_f49026d59798dd5307fd510e7bb42c41.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从我们的需求的角度来看，Knative 可以满足其中的一些要求。从生命周期的角度来看，它为我们的工作负载提供了无服务器的功能，因此能够将其扩展到零，并从零开始激活。从网络的角度来看，如果服务网格之间存在某些重叠，则 Knative 也可以进行流量转移。从绑定的角度来看，它对使用 Knative 导入程序进行绑定提供了很好的支持。它可以使我们进行发布/订阅，或点对点交互，甚至可以进行一些排序。它可以满足几类需求。&lt;/p&gt;
&lt;h2 id=&#34;什么是-dapr&#34;&gt;什么是 Dapr？&lt;/h2&gt;
&lt;p&gt;另一个使用 sidecar 和 operator 的项目是 &lt;a href=&#34;https://dapr.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dapr&lt;/a&gt;，它是微软几个月前才开始并且正在迅速流行起来。此外，1.0 版本 &lt;a href=&#34;https://www.infoq.com/news/2021/02/dapr-production-ready/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;被认为是生产可用的&lt;/a&gt;。它是一个作为 sidecar 的分布式系统工具包&amp;ndash;Dapr 中的所有内容都是作为 sidecar 提供的，并且有一套他们所谓的构件或功能集的集合。&lt;/p&gt;
&lt;p&gt;这些功能是什么呢？第一组功能是围绕网络。Dapr 可以进行服务发现和服务之间的点对点集成。同样，它也可以进行服务网格的追踪、可靠通信、重试和恢复。第二套功能是围绕资源绑定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它有很多云 API、不同系统的连接器，以及&lt;/li&gt;
&lt;li&gt;也可以做消息发布/订阅和其他逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有趣的是，Dapr 还引入了状态管理的概念。除了 Knative 和服务网格提供的功能外，Dapr 在状态存储之上进行了抽象。此外，你通过存储机制支持与 Dapr 进行基于键值的交互。&lt;/p&gt;
&lt;p&gt;在较高的层次上，架构是你的应用程序位于顶部，可以使用任何语言。你可以使用 Dapr 提供的客户端库，但你不必这样做。你可以使用语言功能来执行称为 sidecar 的 HTTP 和 gRPC。与 服务网格的区别在于，这里的 Dapr sidecar 不是一个透明的代理。它是一个显式代理，你必须从你的应用中调用它，并通过 HTTP 或 gRPC 与之交互。根据你需要的功能，Dapr 可以与其他如云服务的系统对话。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/18image013-1616431699532_hu406fdb5279126ecbc05585c03ed26a64_106252_1512cfe0a03b882107e060959cae8d3d.webp 400w,
               /blog/distributed-systems-kubernetes/18image013-1616431699532_hu406fdb5279126ecbc05585c03ed26a64_106252_f6c5cf89448cfb0f1878f27e9f1221c1.webp 760w,
               /blog/distributed-systems-kubernetes/18image013-1616431699532_hu406fdb5279126ecbc05585c03ed26a64_106252_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/18image013-1616431699532_hu406fdb5279126ecbc05585c03ed26a64_106252_1512cfe0a03b882107e060959cae8d3d.webp&#34;
               width=&#34;760&#34;
               height=&#34;396&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 Kubernetes 上，Dapr 是作为 sidecar 部署的，并且可以在 Kubernetes 之外工作（不仅仅是 Kubernetes）。此外，它还有一个 operator &amp;ndash; 而 sidecar 和 Operator 是主要的扩展机制。其他一些组件管理证书、处理基于 actor 的建模并注入 sidecar。你的工作负载与 sidecar 交互，并尽其所能与其他服务对话，让你与不同的云提供商进行互操作。它还为你提供了额外的分布式系统功能。&lt;/p&gt;
&lt;p&gt;综上所述，这些项目所提供的功能，我们可以说 ESB 是分布式系统的早期化身，其中我们有集中式的控制平面和数据平面&amp;ndash;但是扩展性不好。在云原生中，集中式控制平面仍然存在，但是数据平面是分散的&amp;ndash;并且具有隔音功能和高度的可扩展性。&lt;/p&gt;
&lt;p&gt;我们始终需要 Kubernetes 来做良好的生命周期管理，除此之外，你可能还需要一个或多个附加组件。你可能需要 Istio 来进行高级联网。你可能会使用 Knative 来进行无服务器工作负载，或者使用 Dapr 来做集成。这些框架可与 Istio 和 Envoy 很好的配合使用。从 Dapr 和 Knative 的角度来看，你可能必须选择一个。它们共同以云原生的方式提供了我们过去在 ESB 上拥有的东西。&lt;/p&gt;
&lt;h2 id=&#34;未来云原生趋势--生命周期趋势&#34;&gt;未来云原生趋势&amp;ndash;生命周期趋势&lt;/h2&gt;
&lt;p&gt;在接下来的部分，我列出了一些我认为在这些领域正在发生令人振奋的发展的项目。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/8image014-1616431695762_hu605bb942f9a76395b916b67173ad510a_154322_49677f5c5949d10354d581fc70f0dea2.webp 400w,
               /blog/distributed-systems-kubernetes/8image014-1616431695762_hu605bb942f9a76395b916b67173ad510a_154322_77c966a99a439c3225e8446241660319.webp 760w,
               /blog/distributed-systems-kubernetes/8image014-1616431695762_hu605bb942f9a76395b916b67173ad510a_154322_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/8image014-1616431695762_hu605bb942f9a76395b916b67173ad510a_154322_49677f5c5949d10354d581fc70f0dea2.webp&#34;
               width=&#34;760&#34;
               height=&#34;443&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我想从生命周期开始。通过 Kubernetes，我们可以为应用程序提供一个有用的生命周期，这可能不足以进行更复杂的生命周期管理。比如，如果你有一个更复杂的有状态应用，则可能会有这样的场景，其中 Kubernetes 中的部署原语不足以为应用提供支持。&lt;/p&gt;
&lt;p&gt;在这些场景下，你可以使用 operator 模式。你可以使用一个 operator 来进行部署和升级，还可以将 S3 作为服务备份的存储介质。此外，你可能还会发现 Kubernetes 的实际健康检查机制不够好。假设存活检查和就绪检查不够好。在这种情况下，你可以使用 operator 对你的应用进行更智能的存活和就绪检查，然后在此基础上进行恢复。&lt;/p&gt;
&lt;p&gt;第三个领域就是自动伸缩和调整。你可以让 operator 更好的了解你的应用，并在平台上进行自动调整。目前，编写 operator 的框架主要有两个，一个是 Kubernetes 特别兴趣小组的 Kubebuilder，另一个是红帽创建的 operator 框架的一部分&amp;ndash;operator SDK。它有以下几个方面的内容：&lt;/p&gt;
&lt;p&gt;Operator SDK 让你可以编写 operator &amp;ndash; operator 生命周期管理器来管理 operator 的生命周期，以及可以发布你的 operator 到 OperatorHub。如今在 OperatorHub，你会看到 100 多个 operator 用于管理数据库、消息队列和监控工具。从生命周期空间来看，operator 可能是 Kubernetes 生态系统中发展最活跃的领域。&lt;/p&gt;
&lt;h2 id=&#34;网络趋势---envoy&#34;&gt;网络趋势 - Envoy&lt;/h2&gt;
&lt;p&gt;我选的另一个项目是 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;。服务网格接口规范的引入将使你更轻松地切换不同的服务网格实现。在部署上 Istio 对架构进行了一些整合。你不再需要为控制平面部署 7 个 Pod；现在，你只需要部署一次就可以了。更有趣的是在 Envoy 项目的数据平面上所正在发生的：越来越多的第 7 层协议被添加到 Envoy 中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/11image015-1616431697613_hu81bf218714bd671eea2dc70407511b53_122452_6f0e4d86712117b0aca717f889d2f6f5.webp 400w,
               /blog/distributed-systems-kubernetes/11image015-1616431697613_hu81bf218714bd671eea2dc70407511b53_122452_5d79c7f1de86f2406154e66f112bdd3b.webp 760w,
               /blog/distributed-systems-kubernetes/11image015-1616431697613_hu81bf218714bd671eea2dc70407511b53_122452_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/11image015-1616431697613_hu81bf218714bd671eea2dc70407511b53_122452_6f0e4d86712117b0aca717f889d2f6f5.webp&#34;
               width=&#34;760&#34;
               height=&#34;379&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;服务网格增加了对更多协议的支持，比如 MongoDB、ZooKeeper、MySQL、Redis，而最新的协议是 Kafka。我看到 Kafka 社区现在正在进一步改进他们的协议，使其对服务网格更加友好。我们可以预料将会有更紧密的集成、更多的功能。最有可能的是，会有一些桥接的能力。你可以从服务中在你的应用本地做一个 HTTP 调用，而代理将在后台使用 Kafka。你可以在应用外部，在 sidecar 中针对 Kafka 协议进行转换和加密。&lt;/p&gt;
&lt;p&gt;另一个令人兴奋的发展是引入了 HTTP 缓存。现在 Envoy 可以进行 HTTP 缓存。你不必在你的应用中使用缓存客户端。所有这些都是在 sidecar 中透明地完成的。有了 tap 过滤器，你可以 tap 流量并获得流量的副本。最近，WebAssembly 的引入，意味着如果你要为 Envoy 编写一些自定义的过滤器，你不必用 C++ 编写，也不必编译整个 Envoy 运行时。你可以用 WebAssembly 写你的过滤器，然后在运行时进行部署。这些大多数还在进行中。它们不存在，说明数据平面和服务网格无意停止，仅支持 HTTP 和 gRPC。他们有兴趣支持更多的应用层协议，为你提供更多的功能，以实现更多的用例。最主要的是，随着 WebAssembly 的引入，你现在可以在 sidecar 中编写自定义逻辑。只要你没有在其中添加一些业务逻辑就可以了。&lt;/p&gt;
&lt;h2 id=&#34;绑定趋势---apache-camel&#34;&gt;绑定趋势 - Apache Camel&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://camel.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache Camel&lt;/a&gt; 是一个用于集成的项目，它具有很多使用企业集成模式连接到不同系统的连接器。 比如 &lt;a href=&#34;https://camel.apache.org/releases/release-3.0.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Camel version 3&lt;/a&gt; 就深度集成到了 Kubernetes 中，并且使用了我们到目前为止所讲的那些原语，比如 operator。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/7image016-1616431694981_hu7f3b04c3da178baac554084da78a218c_112218_75d11e42436a2b58572f6aa2feacbdc9.webp 400w,
               /blog/distributed-systems-kubernetes/7image016-1616431694981_hu7f3b04c3da178baac554084da78a218c_112218_a0a170194a4c60dfe98a7ef9558ceb7e.webp 760w,
               /blog/distributed-systems-kubernetes/7image016-1616431694981_hu7f3b04c3da178baac554084da78a218c_112218_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/7image016-1616431694981_hu7f3b04c3da178baac554084da78a218c_112218_75d11e42436a2b58572f6aa2feacbdc9.webp&#34;
               width=&#34;760&#34;
               height=&#34;374&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;你可以在 Camel 中用 Java、JavaScript 或 YAML 等语言编写你的集成逻辑。最新的版本引入了一个 Camel operator，它在 Kubernetes 中运行并理解你的集成。当你写好 Camel 应用，将其部署到自定义资源中，operator 就知道如何构建容器或查找依赖项。根据平台的能力，不管是只用 Kubernetes，还是带有 Knative 的 Kubernetes，它都可以决定要使用的服务以及如何实现集成。在运行时之外有相当多的智能 &amp;ndash; 包括 operator &amp;ndash; 所有这些都非常快地发生。为什么我会说这是一个绑定的趋势？主要是因为 Apache Camel 提供的连接器的功能。这里有趣的一点是它如何与 Kubernetes 深度集成。&lt;/p&gt;
&lt;h2 id=&#34;状态趋势---cloudstate&#34;&gt;状态趋势 - Cloudstate&lt;/h2&gt;
&lt;p&gt;另一个我想讨论的项目是 &lt;a href=&#34;https://cloudstate.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloudstate&lt;/a&gt; 和与状态相关的趋势。Cloudstate 是 Lightbend 的一个项目，主要致力于无服务器和功能驱动的开发。最新发布的版本，正在使用 sidecar 和 operator 与 Kubernetes 进行深度集成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/8image017-1616431996943_hu478fc12ef29c40d14fdc80d66b1ace62_112913_9cbf78191ac150b0e235ae4622f65d48.webp 400w,
               /blog/distributed-systems-kubernetes/8image017-1616431996943_hu478fc12ef29c40d14fdc80d66b1ace62_112913_b640a1f76ccb2f9b20b928708ff31615.webp 760w,
               /blog/distributed-systems-kubernetes/8image017-1616431996943_hu478fc12ef29c40d14fdc80d66b1ace62_112913_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/8image017-1616431996943_hu478fc12ef29c40d14fdc80d66b1ace62_112913_9cbf78191ac150b0e235ae4622f65d48.webp&#34;
               width=&#34;760&#34;
               height=&#34;447&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个创意是，当你编写你的功能时，你在功能中要做的就是使用 gRPC 来获取状态并与之进行交互。整个状态管理在与其他 sidecar 群集的 sidear 中进行。它使你能够进行事件溯源、CQRS、键值查询、消息传递。&lt;/p&gt;
&lt;p&gt;从应用程序角度来看，你并不了解所有这些复杂性。你所做的只是调用一个本地的 sidecar，而 sidecar 会处理这些复杂的事情。它可以在后台使用两个不同的数据源。而且它拥有开发人员所需的所有有状态抽象。&lt;/p&gt;
&lt;p&gt;到目前为止，我们已经看到了云原生生态系统中的最新技术以及一些仍在进行中的开发。我们如何理解这一切？&lt;/p&gt;
&lt;h2 id=&#34;多运行时微服务已经到来&#34;&gt;多运行时微服务已经到来&lt;/h2&gt;
&lt;p&gt;如果你看微服务在 Kubernetes 上的样子，则将需要使用某些平台功能。此外，你将需要首先使用 Kubernetes 的功能进行生命周期管理。然后，很有可能透明地，你的服务会使用某些服务网格（例如 Envoy）来获得增强的网络功能，无论是流量路由、弹性、增强的安全性，甚至出于监控的目的。除此之外，根据你的场景和使用的工作负载可能需要 Dapr 或者 Knative。所有这些都代表了进程外附加的功能。剩下的就是编写业务逻辑，不是放在最上面而是作为一个单独的运行时来编写。未来的微服务很有可能将是由多个容器组成的这种多运行时。有些是透明的，有些则是非常明确的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/6image018-1616431996411_hu956722b853b4a081c21ac7e2835ed12e_129596_cb3bd53f765a126e5b24dde9eb204f30.webp 400w,
               /blog/distributed-systems-kubernetes/6image018-1616431996411_hu956722b853b4a081c21ac7e2835ed12e_129596_54b79850bbe4020f62502e79e262b528.webp 760w,
               /blog/distributed-systems-kubernetes/6image018-1616431996411_hu956722b853b4a081c21ac7e2835ed12e_129596_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/6image018-1616431996411_hu956722b853b4a081c21ac7e2835ed12e_129596_cb3bd53f765a126e5b24dde9eb204f30.webp&#34;
               width=&#34;760&#34;
               height=&#34;367&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;智能的-sidecar-和愚蠢的管道&#34;&gt;智能的 sidecar 和愚蠢的管道&lt;/h2&gt;
&lt;p&gt;如果更深入地看，那可能是什么样的，你可以使用一些高级语言编写业务逻辑。是什么并不重要，不必仅是 Java，因为你可以使用任何其他语言并在内部开发自定义逻辑。&lt;/p&gt;
&lt;p&gt;你的业务逻辑与外部世界的所有交互都是通过 sidecar 发生的，并与平台集成进行生命周期管理。它为外部系统执行网络抽象，为你提供高级的绑定功能和状态抽象。sidecar 是你不需要开发的东西。你可以从货架上拿到它。你用一点 YAML 或 JSON 配置它，然后就可以使用它。这意味着你可以轻松地更新 sidecar，因为它不再被嵌入到你的运行时。这使得打补丁、更新变得更加更容易。它为我们的业务逻辑启用了多语言运行时。&lt;/p&gt;
&lt;h2 id=&#34;微服务之后是什么&#34;&gt;微服务之后是什么？&lt;/h2&gt;
&lt;p&gt;这让我想到了最初的问题，微服务之后是什么？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/6image020-1616431995910_hu02b9b6b72398f550aef8fb1022ec8690_65916_cf7c160269023c46cef9f062064218d4.webp 400w,
               /blog/distributed-systems-kubernetes/6image020-1616431995910_hu02b9b6b72398f550aef8fb1022ec8690_65916_c5cd6504ea3dfe3ada27d2996f960d42.webp 760w,
               /blog/distributed-systems-kubernetes/6image020-1616431995910_hu02b9b6b72398f550aef8fb1022ec8690_65916_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/6image020-1616431995910_hu02b9b6b72398f550aef8fb1022ec8690_65916_cf7c160269023c46cef9f062064218d4.webp&#34;
               width=&#34;760&#34;
               height=&#34;366&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果我们看下架构的发展历程，应用架构在很高的层面上是从单体应用开始的。然而微服务给我们提供了如何把一个单体应用拆分成独立的业务域的指导原则。之后又出现了无服务器和功能即服务（FaaS），我们说过可以按操作将其进一步拆分，从而实现极高的可扩展性-因为我们可以分别扩展每个操作。&lt;/p&gt;
&lt;p&gt;我想说的是 FaaS 并不是最好的模式 &amp;ndash; 因为功能并不是实现合理的复杂服务的最佳模式，在这种情况下，当多个操作必须与同一个数据集进行交互时，你希望它们驻留在一起。可能是多运行时（我把它称为 &lt;a href=&#34;https://www.infoq.com/articles/multi-runtime-microservice-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mecha 架构&lt;/a&gt;），在该架构中你将业务逻辑放在一个容器中，而所有与基础设施相关的关注点作为一个单独的容器存在。它们共同代表多运行时微服务。也许这是一个更合适的模型，因为它有更好的属性。&lt;/p&gt;
&lt;p&gt;你可以获得微服务的所有好处。仍然将所有域和所有限界上下文放在一处。你将所有的基础设施和分布式应用需求放在一个单独的容器中，并在运行时将它们组合在一起。大概，现在最接近这种模型的是 Dapr。他们正在遵循这种模型。如果你仅对网络方面感兴趣，那么可能使用 Envoy 也会接近这种模型。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Bilgin Ibryam&lt;/strong&gt; 是红帽公司的产品经理和前架构师、提交人，并且是 Apache 软件基金会的成员。他是开源布道者，经常写博客、发表演讲，是 &lt;a href=&#34;https://k8spatterns.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Patterns&lt;/a&gt; 和 Camel Design Patterns 书籍的作者。Bilgin 目前的工作主要集中在分布式系统、事件驱动架构以及可重复的云原生应用开发模式和实践上。请关注他 @bibryam 了解未来类似主题的更新。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>服务网格比较：Istio 与 Linkerd</title>
      <link>https://cloudnative.to/blog/service-mesh-comparison-istio-vs-linkerd/</link>
      <pubDate>Mon, 25 Jan 2021 21:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/service-mesh-comparison-istio-vs-linkerd/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://dzone.com/articles/service-mesh-comparison-istio-vs-linkerd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh Comparison: Istio vs Linkerd&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;根据 &lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2020/03/CNCF_Survey_Report.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF&lt;/a&gt; 的&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2020/03/CNCF_Survey_Report.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最新年度调查&lt;/a&gt;，很明显，很多人对在他们的项目中使用服务网格表现出了极大的兴趣，并且许多人已经在他们的生产中使用它们。将近 69％ 的人正在评估 Istio，64％ 的人正在研究 Linkerd。Linkerd 是市场上第一个服务网格，但是 Istio 的服务网格更受欢迎。这两个项目都是最前沿的，而且竞争非常激烈，因此选择哪一个是一个艰难的选择。在此博客文章中，我们将了解有关 Istio 和 Linkerd 的架构，其及组件的更多信息，并比较其特性以帮你做出明智的决定。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-comparison-istio-vs-linkerd/13816813-1596629136427_hua0a7c096c19dc3272171726c72ad8d5e_13341_b22b750c84170588475a1125e857197e.webp 400w,
               /blog/service-mesh-comparison-istio-vs-linkerd/13816813-1596629136427_hua0a7c096c19dc3272171726c72ad8d5e_13341_ff72ec5d273131e33cc2a9cd67d8c33e.webp 760w,
               /blog/service-mesh-comparison-istio-vs-linkerd/13816813-1596629136427_hua0a7c096c19dc3272171726c72ad8d5e_13341_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-comparison-istio-vs-linkerd/13816813-1596629136427_hua0a7c096c19dc3272171726c72ad8d5e_13341_b22b750c84170588475a1125e857197e.webp&#34;
               width=&#34;760&#34;
               height=&#34;396&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;服务网格简介&#34;&gt;服务网格简介&lt;/h2&gt;
&lt;p&gt;在过去的几年中，微服务架构已经成为设计软件应用程序的流行风格。在这种架构中，我们将应用程序分解为可独立部署的服务。这些服务通常是轻量级的、多语言的，并且通常由各种职能团队进行管理。直到这些服务的数量变得庞大且难以管理之前，这种架构风格效果很好。突然之间，它们不再简单了。这在管理各个方面（例如安全性、网络流量控制和可观察性）带来了挑战。&lt;strong&gt;服务网格&lt;/strong&gt;可以帮助应对这些挑战。&lt;/p&gt;
&lt;p&gt;术语&lt;strong&gt;服务网格&lt;/strong&gt;用于描述组成此类应用程序的微服务网络及其之间的交互。随着服务数量和复杂性的增加，其扩展和管理变得越来越困难。服务通常提供服务发现、负载均衡、故障恢复、指标和监控。服务网格通常还具有更复杂的操作要求，例如A/B测试、金丝雀发布、限流、访问控制和端到端身份验证。服务网格为负载均衡、服务到服务的身份验证、监控等提供了一种创建服务网络的简单方法，同时对服务代码的更改很少或没有更改。&lt;/p&gt;
&lt;p&gt;让我们看一下 Istio 和 Linkerd 的架构。请注意，这两个项目都在快速演进，并且本文基于 Istio 1.6 版本和 Linkerd 2.7 版本。&lt;/p&gt;
&lt;h2 id=&#34;istio&#34;&gt;Istio&lt;/h2&gt;
&lt;p&gt;Istio 是一个提供了作为服务网格的整套解决方案的开源平台，提供了安全、连接和监控微服务的统一方法。它得到了 IBM、Google 和 Lyft 等行业领军者的支持。Istio 是最流行、最完善的解决方案之一，其高级特性适用于各种规模的企业。它是 Kubernetes 的一等公民，被设计成模块化、平台无关的系统。有关 Istio 的快速演示，请参考我们&lt;a href=&#34;https://www.infracloud.io/blogs/service-mesh-demo-istio-sockshop/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以前的文章&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;架构&#34;&gt;架构&lt;/h3&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio架构&#34;
           src=&#34;https://cloudnative.to/blog/service-mesh-comparison-istio-vs-linkerd/arch.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Istio架构来源：&lt;a href=&#34;https://istio.io/latest/docs/concepts/what-is-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;istio.io&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;组件&#34;&gt;组件&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 是由 Lyft 用 C++ 编写的高性能代理，它可以协调服务网格中所有服务的所有入站和出站流量。它作为 Sidecar 代理与服务一起部署。&lt;/p&gt;
&lt;p&gt;Envoy提供以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态服务发现&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;TLS 终止&lt;/li&gt;
&lt;li&gt;HTTP/2 和 gRPC 代理&lt;/li&gt;
&lt;li&gt;断路器&lt;/li&gt;
&lt;li&gt;健康检查&lt;/li&gt;
&lt;li&gt;按百分比分配流量实现的分阶段发布&lt;/li&gt;
&lt;li&gt;故障注入&lt;/li&gt;
&lt;li&gt;丰富的指标&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在较新的 Istio 版本中，Sidecar 代理对 Mixer 的工作承担了额外的责任。在早期版本的 Istio（&amp;lt;1.6）中，使用 Mixer 从网格收集遥测信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pilot&lt;/strong&gt; 为 Sidecar 代理提供服务发现、流量管理功能和弹性。它将控制流量行为的高级路由规则转换为 Envoy 的特定配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Citadel&lt;/strong&gt; 通过内置的身份和凭证管理实现了强大的服务到服务和最终用户身份验证。它可以在网格中启用授权和零信任安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Galley&lt;/strong&gt; 是 Istio 配置验证、提取、处理和分发组件。&lt;/p&gt;
&lt;h3 id=&#34;核心功能&#34;&gt;核心功能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流量管理&lt;/strong&gt; — 智能流量路由规则、流量控制和服务级别属性（如断路器、超时和重试）的管理。它使我们能够轻松设置 A/B测试、金丝雀发布和并按比例分配流量的分阶段发布。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全性&lt;/strong&gt; — 在服务之间提供安全的通信通道，并管理大规模身份验证、授权和加密。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可观察性&lt;/strong&gt; — 强大的链路跟踪、监控和日志功能提供了深度洞察（deep insights）和可见性。它有助于有效地检测和解决问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Istio&lt;/strong&gt; 还具有一个附加组件基础结构服务，该服务支持对微服务的监控。Istio 与 Prometheus、Grafana、Jaeger 和服务网格仪表盘 Kiali 等应用程序集成。 &lt;/p&gt;
&lt;h2 id=&#34;linkerd&#34;&gt;Linkerd&lt;/h2&gt;
&lt;p&gt;Linkerd 是 Buoyant 为 Kubernetes 设计的开源超轻量级的服务网格。用 Rust 完全重写以使其超轻量级和高性能，它提供运行时调试、可观察性、可靠性和安全性，而无需在分布式应用中更改代码。&lt;/p&gt;
&lt;h3 id=&#34;架构-1&#34;&gt;架构&lt;/h3&gt;
&lt;p&gt;Linkerd 具有三个组件 — UI、数据平面和控制平面。它通过在每个服务实例旁边安装轻量级透明代理来工作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-comparison-istio-vs-linkerd/control-plane_hu40502cf4db3b86f45764139317b1ecfc_81911_1994eff395cb1611c78af91194257340.webp 400w,
               /blog/service-mesh-comparison-istio-vs-linkerd/control-plane_hu40502cf4db3b86f45764139317b1ecfc_81911_01e58f2747e380c3bdc7e62483b0a933.webp 760w,
               /blog/service-mesh-comparison-istio-vs-linkerd/control-plane_hu40502cf4db3b86f45764139317b1ecfc_81911_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-comparison-istio-vs-linkerd/control-plane_hu40502cf4db3b86f45764139317b1ecfc_81911_1994eff395cb1611c78af91194257340.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;控制平面&#34;&gt;控制平面&lt;/h3&gt;
&lt;p&gt;Linkerd 的控制平面是一组提供了服务网格的核心功能的服务。它聚合了遥测数据、提供面向用户的 API，并为数据平面代理提供控制数据。以下是控制平面的组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;控制器&lt;/strong&gt; — 它包含一个公共 API 容器，该容器为 CLI 和仪表盘提供 API。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt; — 数据平面中的每个代理都将访问此组件以查找将请求发送到的位置。它有用于每个路由指标、重试和超时的服务描述信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;身份&lt;/strong&gt; — 它提供了一个&lt;em&gt;证书颁发机构&lt;/em&gt;，该&lt;em&gt;证书颁发机构&lt;/em&gt;接受来自代理的 CSR 并返回以正确身份签发的证书。它提供了 mTLS 功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理注入器&lt;/strong&gt; — 它是一个准入控制器，用于查找注解（&lt;code&gt;linkerd.io/inject: enabled&lt;/code&gt;）并更改 pod 规范以添加 &lt;code&gt;initContainer&lt;/code&gt; 和包含代理本身的 sidecar。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务配置文件验证器&lt;/strong&gt; — 这也是一个准入控制器，用于在保存新&lt;a href=&#34;https://linkerd.io/2/reference/service-profiles/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务描述&lt;/a&gt;之前对其进行验证。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tap&lt;/strong&gt; — 它从 CLI 或仪表盘接收实时监控请求和响应的指令，以在应用程序中提供可观察性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web&lt;/strong&gt;  — 提供 Web 仪表盘。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Grafana&lt;/strong&gt; — Linkerd 通过 Grafana 提供开箱即用的仪表盘。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Prometheus&lt;/strong&gt;  — 通过 &lt;code&gt;/metrics&lt;/code&gt; 在端口 4191 上代理的断点来收集和存储所有 Linkerd 指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据平面&#34;&gt;数据平面&lt;/h3&gt;
&lt;p&gt;Linkerd 数据平面由轻量级代理组成，这些轻量级代理作为边车容器与服务容器的每个实例一起部署。在具有特定注解的 Pod 的初始化阶段，将代理注入（请参见上面的代理注入器）。自从 2.x 由 Rust 中完全重写以来，该代理一直非常轻量级和高性能。这些代理拦截与每个 Pod 之间的通信，以提供检测和加密（TLS），而无需更改应用程序代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理功能：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP、HTTP/2和任意 TCP 协议的透明、零配置代理。&lt;/li&gt;
&lt;li&gt;自动为 HTTP 和 TCP 流量导出 Prometheus 指标。&lt;/li&gt;
&lt;li&gt;透明的零配置 WebSocket 代理。&lt;/li&gt;
&lt;li&gt;自动的、可感知延迟的 7 层负载均衡。&lt;/li&gt;
&lt;li&gt;非 HTTP 流量的自动的 4 层负载均衡。&lt;/li&gt;
&lt;li&gt;按需诊断 tap API。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;比较&#34;&gt;比较&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Istio&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Linkerd&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;易于安装&lt;/td&gt;
&lt;td&gt;由于各种配置选项和灵活性，对于团队来说可能不堪重负。&lt;/td&gt;
&lt;td&gt;因为有内置和开箱即用的配置，适配起来是相对容易的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;平台&lt;/td&gt;
&lt;td&gt;Kubernetes、虚拟机&lt;/td&gt;
&lt;td&gt;Kubernetes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持的协议&lt;/td&gt;
&lt;td&gt;gRPC、HTTP/2、HTTP/1.x、Websocket 和所有 TCP 流量。&lt;/td&gt;
&lt;td&gt;gRPC、HTTP/2、HTTP/1.x、Websocket 和所有 TCP 流量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;入口控制器&lt;/td&gt;
&lt;td&gt;Envoy，Istio 网关本身。&lt;/td&gt;
&lt;td&gt;任何 – Linkerd 本身不提供入口功能。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;多集群网格和扩展支持&lt;/td&gt;
&lt;td&gt;通过各种配置选项以及在 Kubernetes 集群外部扩展网格的稳定版本支持多集群部署。&lt;/td&gt;
&lt;td&gt;2.7 版本，多群集部署仍处于试验阶段。根据最新版本 2.8，多群集部署是稳定的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务网格接口（SMI）兼容性&lt;/td&gt;
&lt;td&gt;通过第三方 CRD。&lt;/td&gt;
&lt;td&gt;原生的流量拆分和指标，而不用于流量访问控制。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;监控功能&lt;/td&gt;
&lt;td&gt;功能丰富&lt;/td&gt;
&lt;td&gt;功能丰富&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;追踪支持&lt;/td&gt;
&lt;td&gt;Jaeger、Zipkin&lt;/td&gt;
&lt;td&gt;所有支持 OpenCensus 的后端&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路由功能&lt;/td&gt;
&lt;td&gt;各种负载均衡算法（轮训、随机最少连接），支持基于百分比的流量拆分，支持基于标头和路径的流量拆分。&lt;/td&gt;
&lt;td&gt;支持 EWMA（指数加权移动平均）负载均衡算法，通过 SNI 支持基于百分比的流量拆分。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;弹性&lt;/td&gt;
&lt;td&gt;断路、重试和超时、故障注入、延迟注入。&lt;/td&gt;
&lt;td&gt;无断路、无延迟注入支持。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;安全&lt;/td&gt;
&lt;td&gt;mTLS支持所有协议、可以使用外部 CA 证书/密钥、支持授权规则。&lt;/td&gt;
&lt;td&gt;除了 TCP 之外，还支持 mTLS，可以使用外部 CA/密钥，但尚不支持授权规则。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能&lt;/td&gt;
&lt;td&gt;在最新的 1.6 版本中，Istio 的资源占用越来越好并且延迟得到了改善。&lt;/td&gt;
&lt;td&gt;Linkerd 的设计非常轻巧 - 根据第三方&lt;a href=&#34;https://linkerd.io/2019/05/18/linkerd-benchmarks/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基准测试&lt;/a&gt;，它比 Istio 快 3-5 倍。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;企业支援&lt;/td&gt;
&lt;td&gt;不适用于 OSS 版本。如果您将 Google 的 GKE 与 Istio 一起使用，或者将 Red Hat OpenShift 与 Istio 作为服务网格使用，则可能会得到各个供应商的支持。&lt;/td&gt;
&lt;td&gt;开发了 Linkerd OSS 版本的 Buoyant 提供了完整的企业级工程、支持和培训。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;服务网格正成为云原生解决方案和微服务架构中必不可少的组成部分。它完成了所有繁重的工作，例如流量管理、弹性和可观察性，让开发人员专注于业务逻辑。Istio 和 Linkerd 都已经成熟，并已被多家企业用于生产。对需求的计划和分析对于选择要使用哪个服务网格至关重要。请在分析阶段投入足够的时间，因为在游戏的后期从一个迁移到另一个很复杂。&lt;/p&gt;
&lt;p&gt;选择与服务网格一样复杂和关键的技术时，不仅要考虑技术，还要考虑使用技术的背景。缺少背景，很难说 A 是否比 B 好，因为答案确实是“取决于”。我喜欢 Linkerd 的简单，包括入门和以后管理服务网格。此外，多年来，Linkerd 与来自企业公司的用户一起得到了加强。 &lt;/p&gt;
&lt;p&gt;一个中可能有一些功能看起来不错，但请确保检查另一个是否计划在不久的将来发布该功能，并基于不仅是理论上的评估，而且还要在概念验证沙箱中对它们进行尝试，做出明智的决定。这种概念验证应集中在易用性、功能匹配以及更重要的是技术的操作方面。引入技术相对容易，最困难的部分是在其生命周期中运行和管理它。&lt;/p&gt;
&lt;p&gt;请让我们知道你的想法和意见。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com/articles/what-is-a-service-mesh-and-why-do-you-need-one&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dzone.com/articles/what-is-a-service-mesh-and-why-do-you-need-one&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://martinfowler.com/articles/microservices.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://martinfowler.com/articles/microservices.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/docs/concepts/traffic-management/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://istio.io/docs/concepts/traffic-management/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://servicemesh.es/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.freepik.com/free-vector/versus-vs-fight-battle-screen-background_6972702.htm#page=1&amp;amp;query=versus&amp;amp;position=0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Freepik.com的标题和特色图片&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;架构图来自 &lt;a href=&#34;https://istio.io/latest/docs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt; 和 &lt;a href=&#34;https://linkerd.io/2/reference/architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt; 的文档。&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>迁移到服务网格</title>
      <link>https://cloudnative.to/blog/migrating-to-service-mesh/</link>
      <pubDate>Mon, 28 Sep 2020 16:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/migrating-to-service-mesh/</guid>
      <description>&lt;p&gt;本文译自&lt;a href=&#34;https://allegro.tech/2020/05/migrating-to-service-mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Migrating to Service Mesh&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;今年 &lt;a href=&#34;https://allegro.tech/about-us/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Allegro.pl&lt;/a&gt; 已满21 岁。该公司在为数以百万计的波兰人提供在线购物服务的同时，还参与了许多技术进步。您可以使用公共云产品，机器学习来打破僵局。即使我们使用的许多技术似乎只是在大肆宣传，但他们的采用依然有可靠的理由的支持。让我告诉你一个我有幸从事的项目的故事。&lt;/p&gt;
&lt;h2 id=&#34;为什么要迁移到服务网格&#34;&gt;为什么要迁移到服务网格&lt;/h2&gt;
&lt;p&gt;我不准备对 Service Mesh 的背景知识做过多的讨论，因为已经有大量关于此主题的文章。我曾写过&lt;a href=&#34;https://nofluffjobs.com/blog/jakie-korzysci-daje-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一篇文章&lt;/a&gt;（波兰语），专门介绍我们为什么决定从这种方法中收益。&lt;/p&gt;
&lt;p&gt;这里只列出我们想要的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将通用平台代码从SDK（服务发现、负载均衡、分布式跟踪）中分离&lt;/li&gt;
&lt;li&gt;将 mTLS 的逻辑从 SDK 和应用程序分离&lt;/li&gt;
&lt;li&gt;统一服务间通信的访问控制&lt;/li&gt;
&lt;li&gt;统一服务间流量的 HTTP 层面可观察性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统的复杂性&#34;&gt;系统的复杂性&lt;/h2&gt;
&lt;p&gt;类似 Allegro.pl 这样的在线市场是一个复杂的野兽。业务的许多部分都按照自己的节奏来演进并使用不同的技术。我们的服务（主要基于 JVM）主要运行在作为本地私有云解决方案的 Mesos/Marathon 上。我们刚刚开始将服务迁移到 Kubernetes。在合理的情况下（并且需要将其与我们的技术栈集成），我们也会使用公有云。一些服务打包在 Docker 中。但是我们的架构不仅仅有微服务。我们还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必要的一些边缘解决方案（API 网关、边缘代理、前端后端等）&lt;/li&gt;
&lt;li&gt;外部负载均衡器&lt;/li&gt;
&lt;li&gt;反向代理&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://allegro.tech/2019/05/hermes-1-0-released.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;分布式消息代理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;几种运行在虚拟机上的服务&lt;/li&gt;
&lt;li&gt;用于批处理任务的 Hadoop 集群&lt;/li&gt;
&lt;li&gt;以及臭名昭著的独立的且仍在运行的 PHP 整体&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何迁移到服务网格&#34;&gt;如何迁移到服务网格&lt;/h2&gt;
&lt;p&gt;旅途始于 2018年底。当时我们评估了现有的解决方案，然后发现大多数技术仅针对 k8s。我们&lt;a href=&#34;https://envoy-control.readthedocs.io/en/latest/ec_vs_other_software/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;尝试了&lt;/a&gt; &lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;，结果证明仅要求 k8s 容器提供的网络隔离。我们需要一个定制的&lt;a href=&#34;https://blog.envoyproxy.io/service-mesh-data-plane-vs-control-plane-2774e720f7fc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;控制平面&lt;/a&gt;将所有的东西整合在一起。同时我们使用&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;作为最稳定、最先进的 L7 代理，其可以满足我们的需求。Envoy 是用 C++ 开发的，由于其内存管理且没有垃圾收集和许多令人印象深刻的架构决策（例如线程模型），提供了可预测的稳定的延迟。&lt;/p&gt;
&lt;h3 id=&#34;控制平面&#34;&gt;控制平面&lt;/h3&gt;
&lt;p&gt;我的团队负责为 JVM 开发人员提供接入平台组件的框架。我们在基于 JVM 的语言：Java 和 Kotlin 拥有丰富的经验。同样我们也对 Go 有一定的了解。Envoy 团队提供了控制平面的两种实现：一种是用 Go 编写的，另一种是用 Java 编写的。我们决定用 Kotlin 来编写我们的解决方案，并将其开源。幕后，我们使用了 &lt;a href=&#34;https://github.com/envoyproxy/java-control-plane/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;java-control-plane&lt;/a&gt; 库，并参与其维护。&lt;/p&gt;
&lt;p&gt;我们平台的服务发现是基于 &lt;a href=&#34;https://www.consul.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hashicorp 的 Consul&lt;/a&gt;。我们已经使用 Java 编写了与 Consul 高效集成的 &lt;a href=&#34;https://github.com/allegro/consul-recipes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;库&lt;/a&gt;，我们在项目中使用了该库。我们将其作为我们的控制平面 &lt;a href=&#34;https://github.com/allegro/envoy-control&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;envoy-control&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因为它使用了一种高级语言，即 Kotlin 和 JVM 生态的工具，我们可以用它做很多有趣的事情，比如使用 &lt;a href=&#34;https://www.testcontainers.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Testcontainers&lt;/a&gt; 进行可靠性测试。这些测试模拟了几种可能的生产故障，并且可以在笔记本电脑上快速运行。该测试套件替我们节省了&lt;strong&gt;大量&lt;/strong&gt;时间。&lt;/p&gt;
&lt;p&gt;此外，经过一段时间的 Envoy 和 envoy-control 的维护之后，我们一直认为我们需要一个管理面板。因此我们通过支持服务实现了 GUI 组件来简化操作。从控制中心我们可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出服务的所有实例&lt;/li&gt;
&lt;li&gt;对特定的 Envoy 实例进行故障诊断（获取配置转储、统计信息）&lt;/li&gt;
&lt;li&gt;更改特定 Envoy 实例的日志级别&lt;/li&gt;
&lt;li&gt;在 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;XDS&lt;/a&gt; 处理之前获取 envoy-control 的配置快照&lt;/li&gt;
&lt;li&gt;比较 envoy-control 实例来验证其一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据平面&#34;&gt;数据平面&lt;/h3&gt;
&lt;p&gt;我们平台上的服务通过内部部署组件进行部署，该组件读取位于每个服务仓库根目录下的 YAML 描述文件。部署元数据可用于每个服务的环境，然后由另一个组件（我们称之为 envoy-wrapper）读取。它准备一个基本的 Envoy 配置文件并启动 Envoy。其余部分有 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;XDS 协议&lt;/a&gt;处理，并与 envoy-control 进行通信来连续传输 Envoy 的配置。在发送给 envoy-control 的元数据中，服务列出了它们的依赖关系。列出所需服务限制 Envoy 所需的数据量。某些类似 Hadoop 执行程序的特权服务，需要所有可用的服务的数据，这种情况也会存在。&lt;/p&gt;
&lt;p&gt;我们还在使用 Puppet 配置的虚拟机上运行 Envoy。我们使用 Envoy 的&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/hot_restart.html?highlight=hot%20restart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;热重启&lt;/a&gt; 能力来提升这些后端服务的能力。&lt;/p&gt;
&lt;h2 id=&#34;状态&#34;&gt;状态&lt;/h2&gt;
&lt;p&gt;当我们使用 Envoy 作为 &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sidecar&lt;/a&gt; 来启动一个服务时，我们使用取巧的方式来完成服务在 Consul 中的注册。注册使用的是 Envoy 的端口，而不是服务的端口。使用这项技术，我们实现了迁移的第一步-将服务的入口流量转移到 Envoy。&lt;/p&gt;
&lt;p&gt;如果有出口流量，事情就不那么容易了。由于缺少容器化的网络隔离，iptables 一直是维护和调试的噩梦。我们为引入 Envoy 作为出口制定了长期的策略。我们决定所有服务都需要将其 SDK 更新为支持使用 Envoy 作为代理的指定的 HTTP 客户端。&lt;/p&gt;
&lt;p&gt;这个决定是迁移工作中的非常重要的一步。我们不想破坏现有平台的功能，比如 SDK 中实现的负载均衡。我们希望早日地凸显出 Service Mesh 的价值来引起雪球效应。同时，我们以敏捷的方式引入新的功能。&lt;/p&gt;
&lt;p&gt;一个指定的代理是平滑迁移的关键所在。为了处理尚未在 Service Mesh 中实现或需要特定处理类型的特定场景，我们创建了一个特别的 HTTP 客户端拦截器。该拦截器将决定是否代理请求。决策基于一组标志，对于具有高度控制权的部署，我们可以覆盖这些标志并精心部署。&lt;/p&gt;
&lt;p&gt;我们尚无法代理流量的一个例子是通过应用程序代码使用 &lt;a href=&#34;https://en.wikipedia.org/wiki/Mutual_authentication&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mTLS&lt;/a&gt; 的场景。我们不想破坏现有设置提供的安全性。但是，当我们准备就绪时，我们只需要翻转一个标志，然后重新部署，流量便会通过 Envoy。&lt;/p&gt;
&lt;p&gt;谈到安全性，为了对 Envoy 进行身份验证，我们不适用 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/security/ssl#secret-discovery-service-sds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SDS 进行证书分发&lt;/a&gt;。我们的主机配备了由部署组件提供的证书。我们计划使用这些证书对 Envoy 进行身份验证，使其成为证书所述的服务。这样，我们就可以使用 Envoy 执行的访问规则所施加的权限来限制服务之间的通信。&lt;/p&gt;
&lt;p&gt;在撰写本文时，我们有 830 个服务通过 Envoy 接受入口流量。其中将近 500 个通过 Envoy 通信以进行出口流量。上周，我们观察到 Mesh 入口流量的峰值 &amp;gt; 620000 req/s，出口流量 &amp;gt; 230000 req/s。我们可以从 Grafana 看到流量的情况，以了解当时的场景。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://allegro.tech/img/articles/2020-05-07-migrating-to-service-mesh/envoy_overview_traffic.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-service-mesh-overview-dashboard&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://allegro.tech/img/articles/2020-05-07-migrating-to-service-mesh/envoy_overview_traffic.png&#34; alt=&#34;Service Mesh overview dashboard&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Service Mesh overview dashboard
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;应用程序开发人员可以在专有的 Dashboard 上查看其特定的服务流量特征。如果需要，甚至可以从指标角度研究特定 Envoy 实例。&lt;/p&gt;
&lt;p&gt;在此过程中，我们能够保持现有路由解决方案和数据中心之间的负载平衡，包括基于金丝雀发布、特定服务标签、或者 Consul 中实例权重的特定子集。&lt;/p&gt;
&lt;h2 id=&#34;曲折&#34;&gt;曲折&lt;/h2&gt;
&lt;p&gt;通过引入代理组件，我们在迁移过程中遇到了许多问题。这里仅列出一部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Envoy 对 HTTP 非常严格。例如，我们需要更新许多位置来使请求头名称不区分大小写&lt;/li&gt;
&lt;li&gt;我们在许多部署中发现突然增加的 503 错误。原因可能是由于连接超时（否则不会被解释为应用程序级别的问题，只能由客户端重试），或者是我们的服务注册机制中的竞争条件，偶尔发生&lt;/li&gt;
&lt;li&gt;当我们继承 Hadoop 时，我们开始遇到一个问题，即 Envoy 在接收配置时会卡住，最终无法使用。这是由于进入所谓的“集群预热”状态。当整个服务消失时，就会发生这种情况，在我们的环境中，这并不罕见。&lt;a href=&#34;https://github.com/envoyproxy/java-control-plane/pull/128&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们更新了以前的提交&lt;/a&gt;，并&lt;a href=&#34;https://github.com/envoyproxy/java-control-plane/pull/131&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;对 java-contraol-plane 做了进一步改进&lt;/a&gt;来解决我们的特定问题&lt;/li&gt;
&lt;li&gt;我们还尽早决定鼓励开发人员通过 Envoy 将流量代理到&lt;a href=&#34;https://en.wikipedia.org/wiki/Network_domain&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;更多域&lt;/a&gt;。这里域，我们是指不属于 mesh 但由 DNS（外部或者内部域名）表示的目标。这引起了一些意外，例如 Envoy 不支持 &lt;a href=&#34;https://github.com/envoyproxy/envoy/issues/1451&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTP CONNECT 方法&lt;/a&gt;&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;或者 &lt;a href=&#34;https://github.com/envoyproxy/envoy/issues/1451&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;H2 upgrade 机制&lt;/a&gt;&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;我们发现的另一个有趣的问题是在将 Envoy 部署到 PHP 单体应用环境中之后，Envoy 的统计数据被误导。热重启后，gauges 上的还是&lt;a href=&#34;https://github.com/envoyproxy/envoy/issues/10806&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;来自上一个实例的值&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;演进&#34;&gt;演进&lt;/h2&gt;
&lt;p&gt;在复杂的环境中部署 Service Mesh 是一项巨大的变革，数百名应用程序开发人员进行了大量工作。迁移帮助团队减少了技术债务。这种减少是迁移到提供 Service Mesh 支持的最新版本库的副产品。为 k8s 创建的现成的崭新的控制平面非常适合未开发的项目，但是对于许多存在异构技术栈的组织来说，这是无法达到的。Envoy 的主要创建者 Matt Klein 最近在&lt;a href=&#34;https://mattklein123.dev/2020/03/15/on-the-state-of-envoy-proxy-control-planes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;中描述了这一事实 。我希望这个故事对您有所帮助，并展示在这种环境下从鸟瞰角度看生产部署的样子。我们接下来要考虑的是将现有服务与 k8s 原生解决方案集成在一起的方法，来为我们的用户提供无缝的体验。我们在稳定和优化我们的控制平面方面进行了大量工作，该控制平面现在在生产中托管了 5000 多个 Envoy 实例，其中一些需要针对 Consul 中注册的近 1000 个服务实例进行配置。我们的愿景以及下一步要做的是，开发人员无需修改库和迁移，就能重新访问分布式跟踪。Envoy 可以做到这一点。&lt;/p&gt;
&lt;h2 id=&#34;最后-感谢&#34;&gt;(最后) 感谢&lt;/h2&gt;
&lt;p&gt;Envoy 社区提供了大量的支持。我们在需要的时候获得了帮助并且 Pull Request 合并快。Envoy 的更新速度非常快，我们正在提取大量可观察性数据，而且几乎不会对我们的服务间通信带来影响。对&lt;a href=&#34;https://github.com/chemicL/envoy-timeouts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我自己&lt;/a&gt;和我有幸一起合作的出色的团队来说，学习经验绝对是无价之宝。我们是应用程序开发人员，但是在整个过程中我们学习了很多的网络和协议知识。我们将继续回馈社区，并期待在评论中听到您使用 Service Mesh 的经历。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;译者注：在 HTTP 协议中，CONNECT 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;译者注：为了更方便地部署新协议，HTTP/1.1 引入了 Upgrade 机制，它使得客户端和服务端之间可以借助已有的 HTTP 语法升级到其它协议&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
