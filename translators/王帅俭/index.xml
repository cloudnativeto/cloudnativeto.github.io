<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>王帅俭 | 云原生社区</title>
    <link>https://cloudnative.to/translators/%E7%8E%8B%E5%B8%85%E4%BF%AD/</link>
      <atom:link href="https://cloudnative.to/translators/%E7%8E%8B%E5%B8%85%E4%BF%AD/index.xml" rel="self" type="application/rss+xml" />
    <description>王帅俭</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Fri, 07 Dec 2018 12:52:58 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/translators/%E7%8E%8B%E5%B8%85%E4%BF%AD/avatar_hue38add62c87b7486d80c9f3fda25dfc1_12220_270x270_fill_q75_lanczos_center.jpg</url>
      <title>王帅俭</title>
      <link>https://cloudnative.to/translators/%E7%8E%8B%E5%B8%85%E4%BF%AD/</link>
    </image>
    
    <item>
      <title>Envoy中的数据统计</title>
      <link>https://cloudnative.to/blog/envoy-stats/</link>
      <pubDate>Fri, 07 Dec 2018 12:52:58 +0800</pubDate>
      <guid>https://cloudnative.to/blog/envoy-stats/</guid>
      <description>&lt;p&gt;这是我在&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;架构系列中的第3篇文章。这篇文章基于以前关于Envoy的&lt;a href=&#34;https://medium.com/@mattklein123/envoy-threading-model-a8d44b922310&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;线程模型&lt;/a&gt;和&lt;a href=&#34;https://medium.com/@mattklein123/envoy-hot-restart-1d16b14555b5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;热重启&lt;/a&gt;功能的帖子。如果您还没有阅读这些帖子，请先阅读。 需要指出的是，随着预演的结束，我们现在可以进入更有趣的话题！&lt;/p&gt;
&lt;h2 id=&#34;统计概述&#34;&gt;统计概述&lt;/h2&gt;
&lt;p&gt;到目前为止，Envoy所做的最重要的事情是为分布式系统的可观测性提供了一个健壮的平台。这包括统计数据、日志记录和分布式跟踪。这篇文章将集中在统计数据和Envoy是如何实现允许高容量的同时保持卓越性能的。Envoy目前支持三种不同的统计数据:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Counter（计数器）&lt;/strong&gt;：只能增加不会减少的无符号整数。 例如，总请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gauge（计量）&lt;/strong&gt;：可以同时增加和减少的无符号整数。 例如，目前有效的请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Timer/hitogram（计时器/直方图）&lt;/strong&gt;：无符号整数，最终将产生汇总百分位值。Envoy不区分计时器（通常以毫秒为单位）和原始直方图（可以是任何单位）。 例如，上游请求时间（以毫秒为单位）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Envoy目前不支持任何浮点统计数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/envoy-stats/006tNbRwly1fxv00zgfu2j30m804ugmh_huf7f3688ffc51e6a27ba202f38813ac41_29421_2316e4a37a0bdc18a04b3884de8511b5.webp 400w,
               /blog/envoy-stats/006tNbRwly1fxv00zgfu2j30m804ugmh_huf7f3688ffc51e6a27ba202f38813ac41_29421_ec4e37070856cdbf03605b9dba8675c7.webp 760w,
               /blog/envoy-stats/006tNbRwly1fxv00zgfu2j30m804ugmh_huf7f3688ffc51e6a27ba202f38813ac41_29421_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/envoy-stats/006tNbRwly1fxv00zgfu2j30m804ugmh_huf7f3688ffc51e6a27ba202f38813ac41_29421_2316e4a37a0bdc18a04b3884de8511b5.webp&#34;
               width=&#34;760&#34;
               height=&#34;165&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;center&gt;Envoy生成很多对调试分布式系统有用的数据！&lt;/center&gt;
## 统计子系统目标
&lt;p&gt;Envoy统计子系统的总体目标如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;粗略的线性吞吐量：可以与任意数量的工作线程一起扩展。另一种说法是:在稳定状态下，使用stats时应该没有跨线程争用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在使用热重启时，状态应该在逻辑上保持一致。这意味着即使有两个Envoy进程在运行，当逻辑上认为是单个进程时，所有计数器、量规和直方图都应该是一致的。（有关这方面的更多信息，请参阅&lt;a href=&#34;https://medium.com/@mattklein123/envoy-hot-restart-1d16b14555b5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;热重启&lt;/a&gt;这篇文章）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计数据应该包含在作用域内并作为一个组释放。作用域是具有公共前缀的统计数据的逻辑分组。例如:&lt;code&gt;http.admin.*&lt;/code&gt;。这一点很重要，因为Envoy具有动态性。Envoy支持各种&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;管理API&lt;/a&gt;，如监听器发现服务（LDS）和集群发现服务（CDS） API。为了不耗尽内存，Envoy需要清理不再使用的统计数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计范围应该能够重叠和正确的引用计数。这意味着如果作用域A使用一个名为&lt;code&gt;foo.bar.baz&lt;/code&gt;的属性，作用域B也使用&lt;code&gt;foo.bar.baz&lt;/code&gt;属性，那么&lt;code&gt;foo.bar.baz&lt;/code&gt;的属性的引用计数应该是2。这对于热重启（两个进程将在一段时间内写入相同的统计数据）和动态管理API（在一段时间内，更新的监听器或集群将引用与旧监听器或集群相同的统计数据）都是必需的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计数据子系统应该能够很好地执行直到数据平面处理开始时才知道的统计信息。许多统计数据本质上是“固定的”，可以在加载配置或动态API重新配置数据平面时创建（例如，&lt;code&gt;cluster.foo.upstream_rq_5xx&lt;/code&gt;）。这些都是低频事件。其他统计信息，例如详细的HTTP响应代码度量（例如，&lt;code&gt;cluster.foo.upstream_rq_503&lt;/code&gt;），在数据开始流动之前都不知道。使用“动态”的统计数据永远不会像使用“固定”的统计数据那样快，但是即使在处理每个内核每秒数千个请求的10次时，性能仍然应该是足够的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为一个整体，上述目标需要一个复杂的系统来满足。我们现在将深入研究这个系统是如何工作的。&lt;/p&gt;
&lt;h2 id=&#34;数据架构&#34;&gt;数据架构&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/envoy-stats/006tNbRwly1fxv13dqf7mj30m808zwf9_hubd6d9c259526179c1e2a6513193b119b_26676_3a9ee800366a75d9dccb41cd84cae387.webp 400w,
               /blog/envoy-stats/006tNbRwly1fxv13dqf7mj30m808zwf9_hubd6d9c259526179c1e2a6513193b119b_26676_d46dcaeab96f31575cc584f5622c159d.webp 760w,
               /blog/envoy-stats/006tNbRwly1fxv13dqf7mj30m808zwf9_hubd6d9c259526179c1e2a6513193b119b_26676_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/envoy-stats/006tNbRwly1fxv13dqf7mj30m808zwf9_hubd6d9c259526179c1e2a6513193b119b_26676_3a9ee800366a75d9dccb41cd84cae387.webp&#34;
               width=&#34;760&#34;
               height=&#34;307&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;center&gt;图1：高级统计架构，蓝色统计数据显示了一个作用域分组。&lt;/center&gt;
**图1**显示了Envoy数据统计子系统的高级架构。它由以下几个部分组成。
&lt;h3 id=&#34;存储&#34;&gt;存储&lt;/h3&gt;
&lt;p&gt;stat存储是Envoy内部的一个单例对象，并提供了一个简单的接口，通过该接口，其余代码可以获得作用域、计数器、计量和直方图的句柄。调用代码负责维护所有创建的作用域的所有权语义。当作用域被销毁时，所有包含的统计数据的引用计数都会减少1。如果任何统计数据达到0引用计数，它们将被释放。&lt;/p&gt;
&lt;h3 id=&#34;统计数据&#34;&gt;统计数据&lt;/h3&gt;
&lt;p&gt;如前所述，统计数据包括计数器、量规和直方图。从终端用户的角度来看，这些接口使用起来非常简单。例如，计数器和计量都包括&lt;code&gt;inc()&lt;/code&gt;和&lt;code&gt;dec()&lt;/code&gt;方法，而只有计量包括&lt;code&gt;set()&lt;/code&gt;方法。程序员看不到任何潜在的存储复杂性。&lt;/p&gt;
&lt;h3 id=&#34;flusher&#34;&gt;Flusher&lt;/h3&gt;
&lt;p&gt;为了获得高性能，使用原子CPU指令在内部缓冲所有的状态变化。在可配置的间隔内，所有计数器和计量都被冲到flusher中。注意，在当前的架构中，直方图值直接发送到接收器。下面将更详细地描述这一点。Flusher在main线程中运行。&lt;/p&gt;
&lt;h3 id=&#34;sink&#34;&gt;Sink&lt;/h3&gt;
&lt;p&gt;统计数据接收器是一个接口，它接受通用的统计数据并将其转换为特定于后端的连线格式。所有接收器都使用TLS，这样在刷新输出时就不会出现争用。然而，在实践中，目前只有主线会冲掉计数器和量规。所有线程都刷新直方图。&lt;/p&gt;
&lt;p&gt;目前Envoy只支持TCP和UDP &lt;a href=&#34;https://github.com/b/statsd_spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;statsd&lt;/a&gt;协议。statsd是一种非常简单但得到广泛支持的传输格式。在未来，很可能会实现其他本地统计数据接收器，如&lt;a href=&#34;https://prometheus.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus&lt;/a&gt;、&lt;a href=&#34;https://www.wavefront.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wavefront&lt;/a&gt;和 &lt;a href=&#34;https://www.influxdata.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfluxDB&lt;/a&gt;。还要注意Envoy目前不支持维度或标签统计。这将在下面的工作部分中进一步讨论。&lt;/p&gt;
&lt;h3 id=&#34;admin&#34;&gt;Admin&lt;/h3&gt;
&lt;p&gt;从操作的角度来看，能够实时地到达一个节点并转储当前状态是非常有用的。Envoy可以通过&lt;code&gt;/stats&lt;/code&gt;&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;管理端点&lt;/a&gt;实现此功能。管理端点直接查看存储库以加载所有计数器和计量并打印它们。这个端点目前不输出任何直方图数据。这同样是由于在当前的实现中直方图值是直接写入接收器的，因此存储不知道它们。&lt;/p&gt;
&lt;h3 id=&#34;直方图的架构&#34;&gt;直方图的架构&lt;/h3&gt;
&lt;p&gt;正如已经多次提到的，Envoy目前不维护进程内直方图数据。除了开发效率之外，没有什么特别的原因；Lyft使用的statsd摄取管道提供了自己的直方图支持，并希望直方图值直接发送到它。因此，直方图值目前不能通过管理端点查看。未来我们很可能直接在Envoy内部实现&lt;a href=&#34;http://hdrhistogram.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HDR直方图&lt;/a&gt;。这一点将在下面进一步讨论。&lt;/p&gt;
&lt;h3 id=&#34;线程本地热重启的能力存储&#34;&gt;线程本地热重启的能力存储&lt;/h3&gt;
&lt;p&gt;以上所有的背景都完成了，现在是时候深入到有趣的部分：实践中是如何工作的?&lt;/p&gt;
&lt;h4 id=&#34;统计项&#34;&gt;统计项&lt;/h4&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/envoy-stats/006tNbRwly1fxv1793dqqj30m8028glv_hu30f54fd114145af92b3751f8bbeeff3f_12826_2688680706d293061cc3c081fc16d272.webp 400w,
               /blog/envoy-stats/006tNbRwly1fxv1793dqqj30m8028glv_hu30f54fd114145af92b3751f8bbeeff3f_12826_4bff9b9938a4fe08022694ceb4df6cab.webp 760w,
               /blog/envoy-stats/006tNbRwly1fxv1793dqqj30m8028glv_hu30f54fd114145af92b3751f8bbeeff3f_12826_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/envoy-stats/006tNbRwly1fxv1793dqqj30m8028glv_hu30f54fd114145af92b3751f8bbeeff3f_12826_2688680706d293061cc3c081fc16d272.webp&#34;
               width=&#34;760&#34;
               height=&#34;76&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;center&gt;图2：共享内存中单独的计数器/计量统计项&lt;/center&gt;
正如我们在[热重启文章](https://medium.com/@mattklein123/envoy-hot-restart-1d16b14555b5)中已经讨论过的那样，最终，所有统计数据都存储在共享内存中，以便可以在所有进程中使用它们。**图2**显示了单个stat条目。它由以下几个部分组成:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Name&lt;/strong&gt;：完全解析的属性名，例如&lt;code&gt;http.admin.downstream_cx_active&lt;/code&gt;。目前限制为128个字符。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value&lt;/strong&gt;：属性的当前值。该数据包含量具的当前值和计数器的当前总价值。所有的数据写操作都使用原子操作，所以它们在多线程环境下是安全的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pending increment&lt;/strong&gt;：此数据仅供计数器使用。除了值之外，每个增量都是原子式的。之所以这样做，是因为大多数统计数据接收器想要获取刷新之间的增量而不是总数。因此，在冲洗期间计数器是锁住的。挂起的增量被写入计数器，然后归零。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flags&lt;/strong&gt;：目前只支持标志&lt;code&gt;used&lt;/code&gt;。这表示如果统计数据被写过，那么代码能够区分零和从未写过。Envoy不会刷新从来没有使用过的统计数据，以避免压倒性的统计后端很少使用的统计数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ref count&lt;/strong&gt;：Ref count允许重叠范围（可能在多个进程中）使用相同的底层统计数据。只有当ref计数为0时，才释放统计数据内存供将来使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;存储-1&#34;&gt;存储&lt;/h4&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/envoy-stats/006tNbRwly1fxv1e9mvjdj30m80f1gn7_hua48cded1631941f90fc93c54c64de2c0_48455_41c5df4852e4d032baa2bd60ee0eaf81.webp 400w,
               /blog/envoy-stats/006tNbRwly1fxv1e9mvjdj30m80f1gn7_hua48cded1631941f90fc93c54c64de2c0_48455_c8f1906fac059b2c8fc28debad23c953.webp 760w,
               /blog/envoy-stats/006tNbRwly1fxv1e9mvjdj30m80f1gn7_hua48cded1631941f90fc93c54c64de2c0_48455_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/envoy-stats/006tNbRwly1fxv1e9mvjdj30m80f1gn7_hua48cded1631941f90fc93c54c64de2c0_48455_41c5df4852e4d032baa2bd60ee0eaf81.webp&#34;
               width=&#34;760&#34;
               height=&#34;514&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;center&gt;图3:线程本地热重启支持的存储体系结构&lt;/center&gt;
**图3** 显示了Envoy内部使用的线程本地stat存储的设计。这个版本的商店满足了之前发布的所有设计目标。现在我们将详细介绍它的工作原理。
&lt;ol&gt;
&lt;li&gt;该存储是单例存储，整个Envoy流程都使用它。所有的范围、计数器和标准引用都是从这个单例中心存储库获得的。（本节将不介绍直方图，因为目前直方图不重要，直接刷新到TLS 统计数据接收器）。&lt;/li&gt;
&lt;li&gt;当线程试图通过作用域获取计数器或量规时，它首先在作用域TLS缓存中按名称查找计数器或量规。如果在缓存中找到了统计数据，它将立即返回给调用者，而不需要任何锁定。如果没有找到该属性，则必须从范围中央缓存中获取该属性。&lt;/li&gt;
&lt;li&gt;范围中央缓存通过标准进程范围内的互斥锁锁定（在稳定状态下，它不应该被高度竞争，因为统计信息将在范围TLS缓存中找到）。如果在中心缓存中找到了统计数据，那么它将返回到TLS缓存，在那里存储它以供以后无锁查找。如果在中央缓存中没有找到该属性，则必须从共享内存中分配该属性。&lt;/li&gt;
&lt;li&gt;共享内存包含一系列固定的个人统计条目（图2）。Envoy包含一个非常基本的分配器，搜索统计条目名称相同的槽(支持热重启和重叠范围)或一个空位置,选择初始化槽如果目前空,增加引用计数,并返回它。这是在热重启期间跨进程统计数据的工作方式。两个进程都将从共享内存中分配一个统计数据条目槽，但是其中一个进程最终将引用计数增加到两个（相同的进程在重叠作用域创建期间发生）。如果在共享内存中找不到空间，Envoy将增加一个“panic”属性并返回一个特殊的溢出属性槽，以便进程可以在降级状态下继续运行。一旦一个统计数据槽被分配，它就被包装在一个进程本地数据结构中，存储在范围中心缓存中，存储在范围TLS缓存中，然后最终返回给调用者。&lt;/li&gt;
&lt;li&gt;回想一下，stat子系统的目标之一是使作用域安全可删除。作用域是全局对象，由主线程和单例存储管理。删除作用域时，不同线程上的作用域TLS缓存可能持有对单个统计数据的引用。为了说明这一点，“作用域缓存刷新”事件通过TLS发送到每个线程。线程使用&lt;a href=&#34;https://medium.com/@mattklein123/envoy-threading-model-a8d44b922310&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;线程模型文章&lt;/a&gt;中描述的类似RCU的行为释放所有对作用域统计的引用。一旦计数器或表的最后一次引用计数被减少，共享内存统计项插槽也被释放。这是通过在统计数据条目插槽上减少引用计数来完成的。如果这个引用计数现在为零，那么这个槽就被完全释放了，并且可以被任何进程用于一个新的状态。如果前面的描述有点混乱，总结一下：Envoy中的所有统计数据都由两个引用计数控制。第一个引用计数用于进程内TLS缓存的状态，第二个引用用于多个进程共享的备份状态入口槽。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;回顾一下，让我们看看上面的设计如何满足所有的原始目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性吞吐量&lt;/strong&gt;：在稳定状态下，所有的统计数据分配都通过作用域TLS缓存进行。对于大量的工作线程来说这要求不能加锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在热重新启动期间逻辑上是一致的&lt;/strong&gt;：最终，所有同名的数据在共享内存中使用相同的备份存储。这在流程之间创建了逻辑一致性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统计数据包含在一个作用域内，可以作为一个组释放，也可以重叠&lt;/strong&gt;：作用域具有完全独立的中央缓存和TLS缓存，以及独立的每个统计数据引用计数。一个作用域可以被移除，并且它的所有统计数据的引用计数将会减少，并且可能会被释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;足够的动态统计数据性能&lt;/strong&gt;：通过范围TLS缓存查找动态统计数据并使用O(1)哈希表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;未来的工作&#34;&gt;未来的工作&lt;/h2&gt;
&lt;p&gt;虽然Envoystats子系统工作得很好，但是有几个方面在未来可以改进:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;维度/标记状态:&lt;/strong&gt; 大多数更新的状态后端支持维度/标记，而不仅仅是一个扁平的层次命名空间。在特使统计数据的某些区域中，这是很有用的。短期而言，我们可能会添加全球标记支持，作为支持它的后端（如Prometheus、Wavefront和流感数据库）的第一步。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程本地原子缓存:&lt;/strong&gt; 在worker数量和吞吐量极高的情况下，单个stat值上的原子争用将成为一个问题。这可以通过移动到TLS计数器和压力表来解决，这些计数器和压力表在冲洗之前被聚集到中央存储中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内置的HDR直方图:&lt;/strong&gt; 由于几个原因（管理输出、基于异常值的延迟检测和没有内置直方图支持的接收器），向Envoy添加直接的HDR直方图支持将非常有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;额外的静态接收器:&lt;/strong&gt; 如前所述，我们希望直接支持更多的后端，如Prometheus、Wavefront、InfluxDB等。幸运的是，接收器接口很简单，添加新的实现并不困难。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;为了满足上述目标，Envoy的数据统计子系统的设计是新颖的。到目前为止，它在实践中表现得非常好，对于其他用例来说，扩展起来应该相对容易。&lt;/p&gt;
&lt;h2 id=&#34;代码链接&#34;&gt;代码链接&lt;/h2&gt;
&lt;p&gt;本文中涉及到的一些接口及实现的头文件请参考下面链接:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/envoy/blob/master/include/envoy/stats/stats.h&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/envoyproxy/envoy/blob/master/include/envoy/stats/stats.h&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/envoy/tree/master/source/common/stats&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/envoyproxy/envoy/tree/master/source/common/stats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IBM云计算CTO讲述Istio项目的起源、分工及目标</title>
      <link>https://cloudnative.to/blog/istio-aims-to-be-the-mesh-plumbing-for-containerized-microservices/</link>
      <pubDate>Tue, 28 Aug 2018 16:15:25 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-aims-to-be-the-mesh-plumbing-for-containerized-microservices/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-aims-to-be-the-mesh-plumbing-for-containerized-microservices/0069RVTdly1fupfdbzbm4j30iu0altbn_hu38e80df0dbbce15ca492361965d8557d_101173_998821358242d768cedc06db76aa6326.webp 400w,
               /blog/istio-aims-to-be-the-mesh-plumbing-for-containerized-microservices/0069RVTdly1fupfdbzbm4j30iu0altbn_hu38e80df0dbbce15ca492361965d8557d_101173_934323d208abdfd79445f05de6712061.webp 760w,
               /blog/istio-aims-to-be-the-mesh-plumbing-for-containerized-microservices/0069RVTdly1fupfdbzbm4j30iu0altbn_hu38e80df0dbbce15ca492361965d8557d_101173_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-aims-to-be-the-mesh-plumbing-for-containerized-microservices/0069RVTdly1fupfdbzbm4j30iu0altbn_hu38e80df0dbbce15ca492361965d8557d_101173_998821358242d768cedc06db76aa6326.webp&#34;
               width=&#34;678&#34;
               height=&#34;381&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://www.nextplatform.com/2018/08/15/istio-aims-to-be-the-mesh-plumbing-for-containerized-microservices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文原标题为：Istio目标是成为容器化微服务的网状管道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在精彩的软件容器世界中，原本早已解决的问题又有新的解决方案出现，给人有种恍惚的感觉。在许多情况下这些问题很久以前就得到了解决，但现代云原生架构的出现，推动部署更大规模的应用程序，这就需要新的工具和方法来管理这些服务。&lt;/p&gt;
&lt;p&gt;微服务就是一个很好的例子。在此模型下，典型的应用程序或服务将被分解为可独立部署的功能模块，这些模块可以彼此分开扩展和维护，并且链接在一起以提供整个应用程序或服务的全部功能。&lt;/p&gt;
&lt;p&gt;在使用容器开发微服务时，后者可能是比较棘手的部分。当所有组件可能分布在服务器节点集群中，并且它们的实例不断上线并被更新的版本替换时，如何将它们连接起来？在面向服务的体系结构（SOA）中，微服务可以被看作是&lt;a href=&#34;https://www.nextplatform.com/2017/01/03/from-monolith-to-microservices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;进化的继承者&lt;/a&gt;，这种任务类似于企业服务总线（ESB）所处理的任务。因此，我们需要的是ESB的云原生版本。&lt;/p&gt;
&lt;p&gt;这是一个相对较新的开源项目&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;旨在填补的工作。它被正式描述为服务网格，因为它的一部分与基础设施一起分布在它管理的容器旁边，并且它开始着手满足服务发现、负载均衡、消息路由、遥测和监控的要求，当然还有安全。&lt;/p&gt;
&lt;p&gt;Istio源自IBM和谷歌之间的合作，实际上包含了一些现有的组件，特别是由打车服务公司Lyft开发的组件。它以某种形式存在至少一年，但最终在7月底达到1.0版的里程碑，这意味着它现在终于被认为足够成熟，可以作为生产基础设施的一部分来运行。&lt;/p&gt;
&lt;p&gt;IBM研究员兼IBM云计算首席技术官Jason McGee告诉The Next Platform，&lt;strong&gt;云原生生态系统已基本确定容器作为核心打包和运行时构造，而Kubernetes则作为管理容器的编排系统。但McGee解释说，还有第三块谜题还在空中，Istio旨在满足这一要求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“如何管理在容器平台上运行的应用程序或服务之间的交互？”McGee问道。 “如果您正在构建微服务，或者您有一组应用程序，那么应用程序之间的通信会出现很多有趣的问题。您如何了解到底是那些服务在交互，性能以及如何收集应用程序之间通信的数据，如何保护控制哪些服务可以相互通信，以及如何确保应用程序的安全，特别是在我们今天使用的更动态或分布式架构情况下，您可能在公有云或私有云上同时有组件。“&lt;/p&gt;
&lt;p&gt;McGee说他几年前在IBM的团队已经开始研究这个问题了，当时他遇到了谷歌的同行并发现他们正走在同一条道路上，&lt;strong&gt;但IBM主要关注流量路由、版本控制和A/B测试方面，Google专注于安全和遥测。两者决定合并各自的努力成果，这样就诞生了Istio。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Istio由以下组件组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Envoy，被描述为sidecar代理，因为它作为代理部署在每个微服务实例旁边。&lt;/li&gt;
&lt;li&gt;Mixer，它是一个核心组件，用于通过Envoy代理执行策略，并从中收集遥测指标。&lt;/li&gt;
&lt;li&gt;Pilot，负责配置代理。&lt;/li&gt;
&lt;li&gt;Citadel，负责颁发证书的中心化组件，也有自己的每个节点代理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Envoy是由Lyft开发的组件，被McGee描述为“非常小的足迹，第4到第7层智能路由器”，它捕获与其配对的微服务的所有传入和传出流量、控制流量、应用策略和收集遥测信息。 Pilot是IBM提供的主要组件，作为部署在基础架构中的所有Envoy代理的控制平面。&lt;/p&gt;
&lt;p&gt;“如果你想象在一个服务网格中，你可能有一百个微服务，如果每个服务都有多个实例，你可能有数百或数千个智能路由，你需要一种方法对它们进行编程，所以Istio引入了这个称为Pilot的东西。可以把它想象成程序员，所有这些路由器的控制平面。所以你有一个地方可以来编程这个服务网络，然后围绕数据收集进行遥测，围绕安全的证书管理，但从根本上你有这个智能路由层和这个控制平面来管理它， “McGee解释道。&lt;/p&gt;
&lt;p&gt;Istio还有自己的API，允许用户将其插入现有的后端系统，例如用于日志记录和遥测。&lt;/p&gt;
&lt;p&gt;根据谷歌的说法，Istio的监控功能使用户能够测量服务之间的实际流量，例如每秒请求数，错误率和延迟，还可以生成依赖关系图，以便用户可以看到服务如何相互影响。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-aims-to-be-the-mesh-plumbing-for-containerized-microservices/0069RVTdly1fupgnkp2owj30iu08rwfg_hu4068920557354add179848378b4c3b6f_38992_8080196b01855625c8523550ddf51983.webp 400w,
               /blog/istio-aims-to-be-the-mesh-plumbing-for-containerized-microservices/0069RVTdly1fupgnkp2owj30iu08rwfg_hu4068920557354add179848378b4c3b6f_38992_35956a004cd5114cd848ff24e8918c1f.webp 760w,
               /blog/istio-aims-to-be-the-mesh-plumbing-for-containerized-microservices/0069RVTdly1fupgnkp2owj30iu08rwfg_hu4068920557354add179848378b4c3b6f_38992_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-aims-to-be-the-mesh-plumbing-for-containerized-microservices/0069RVTdly1fupgnkp2owj30iu08rwfg_hu4068920557354add179848378b4c3b6f_38992_8080196b01855625c8523550ddf51983.webp&#34;
               width=&#34;678&#34;
               height=&#34;315&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过Envoy sidecar代理，Istio还可以在每个服务调用时使用双向TLS身份验证（mTLS），加密并使用户能够在基础架构范围内对每个调用进行授权。&lt;/p&gt;
&lt;p&gt;Istio的目的是，消除开发人员需要担心的许多问题：实例之间的通信安全问题，控制哪个实例可以与哪些实例进行通信以及提供执行诸如金丝雀部署之类的操作，如果是特定微服务代码的新版本发布了，那么只有一个实例的子集会被更新，直到您满意新代码的运行可靠为止&lt;/p&gt;
&lt;p&gt;应该注意的是，其他服务网状平台已经存在，例如开源端的Linkerd或Conduit，而微软有一项服务，被称为&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/service-fabric-mesh/service-fabric-mesh-overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Azure Service Fabric Mesh&lt;/a&gt;，目前作为其云平台的技术预览。此外，服务网格表示网络管道上方的抽象层，因此假设已经为每个容器实例配置了网络接口，IP地址和其他网络属性。这通常意味着，无论何时创建新的容器实例，部署微服务还将需要一个单独的工具来自动化网络配置。&lt;/p&gt;
&lt;p&gt;然而，IBM希望Istio将成为云原生工具包的标准组成部分，&lt;a href=&#34;https://www.nextplatform.com/2018/07/17/when-does-kubernetes-become-invisible-and-ubiquitous/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;正如Kubernetes所发生的那样&lt;/a&gt;，Kubernetes是基于Borg和Omega技术的，而这些技术是为谷歌自己的内部集群和其上运行的容器层而开发的。&lt;/p&gt;
&lt;p&gt;“从社区的角度来看，我的期望是Istio将成为架构的默认部分，就像容器和Kubernetes已经成为云原生架构的默认部分一样，”McGee说。为此，IBM希望将Istio与其公有云提供的托管Kubernetes服务以及其内部部署的IBM Cloud Private堆栈集成在一起。&lt;/p&gt;
&lt;p&gt;“所以，你今天可以运行Istio，我们支持今天在这两个平台上运行Istio，但期望应该是在不久的将来，我们将内置Istio，所以每当你使用我们的平台时， Istio组件集成在里面了，您可以利用它，并且不必负责部署和管理Istio本身，只需在您的应用程序中使用它即可，“McGee说。&lt;/p&gt;
&lt;p&gt;谷歌已经添加了Istio支持，尽管它只是将其标记为alpha版本，作为托管服务的一部分，该服务在其云平台上的客户的Google Kubernetes Engine（GKE）集群中自动安装和维护。&lt;/p&gt;
&lt;p&gt;Istio也获得了业内其他公司的支持，尤其是Red Hat，几年前Red Hat以Docker容器和Kubernetes为基础，重新设计了OpenShift应用程序平台。&lt;/p&gt;
&lt;p&gt;Red Hat的Istio产品经理人称“红胡子”的Brian Harrington表示Red Hat打算将服务网格集成到OpenShift中，但Red Hat希望在提交之前能够看到改进的一些粗略的地方，例如多租户支持。&lt;/p&gt;
&lt;p&gt;“Istio现在的目标是他们所谓的软多租户，也就是说，我们希望在组织内部可用，以便该组织内的两个不同的团队可以使用并信任它，前提是团队内只要没有一个人的行为过于恶意，大家都没有准备去影响其他人的服务。通过我们运行OpenShift Online的方式，我们让客户运行我们从未看过的代码，并且我们必须最终安排这两个客户并存，这是一个非常不同的多租户挑战，“Harrington解释道。&lt;/p&gt;
&lt;p&gt;“我们需要对这个多租户功能有更高的信心;我们需要对性能和稳定性有更高的信心。在这些方面还没有看到有完美的解决方案，但是在进行规模测试和自动化一些回归测试时，我们看到了一些我们认为可以提供大量价值的地方，我们还在社区层面贡献了一个名为&lt;a href=&#34;http://www.kiali.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kiali&lt;/a&gt;的项目，给出了Istio操作过程的可视化，这只是我们产品的一部分，“他补充道。&lt;/p&gt;
&lt;p&gt;换句话说， Istio只是为那些希望构建云原生应用程序基础架构的用户提供的添加到选项菜单中的另一个开源工具。 像Red Hat这样的供应商将把它融入他们经过测试和支持的企业平台产品中，比如OpenShift，而其他供应商则希望自己混合搭配并构建它。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么你应该关心Istio gateway</title>
      <link>https://cloudnative.to/blog/why-you-should-care-about-istio-gateways/</link>
      <pubDate>Mon, 13 Aug 2018 20:44:06 +0800</pubDate>
      <guid>https://cloudnative.to/blog/why-you-should-care-about-istio-gateways/</guid>
      <description>&lt;p&gt;如果您要拆分单体架构，使用Istio管理您的微服务的一个巨大优势是，它利用与传统负载均衡器和应用分发控制器类似的入口模型的配置。&lt;/p&gt;
&lt;p&gt;在负载均衡器领域，虚拟IP和虚拟服务器一直被认为是使运营商能够以灵活和可扩展的方式配置入口流量的概念（&lt;a href=&#34;https://devcentral.f5.com/articles/wils-virtual-server-versus-virtual-ip-address&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lori Macvittie对此有一些相关的想法&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;在Istio中，&lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#Gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway&lt;/a&gt;控制网格边缘的服务暴露。Gateway允许用户指定L4-L6设置，如端口和TLS设置。对于Ingress流量的L7设置，Istio允许您将网关绑定到&lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#VirtualService&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VirtualServices&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这种分离使得管理流入到网格的流量变得容易，就像在传统负载均衡器中将虚拟IP绑定到虚拟服务器一样。这使得传统技术栈用户能够以无缝方式迁移到微服务。对于习惯于整体和边缘负载均衡器的团队来说，这是一种自然的进步，而不需要考虑全新的网络配置方式。&lt;/p&gt;
&lt;p&gt;需要注意的一点是，在服务网格中路由流量和将外部流量引入网格不同。在网格中，您在正常流量中分辨异常的部分，因为只要在服务网格内，默认情况下Istio可以与（与Kubernetes兼容）所有应用通信。&lt;strong&gt;如果您不希望与某些服务进行通信，则必须添加策略。反向代理（类似于传统的负载均衡器）获取进入网格的流量，您必须准确指定哪些流量允许进入网格。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;早期版本的Istio利用Kubernetes的&lt;a href=&#34;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#ingress-v1beta1-extensions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ingress资源&lt;/a&gt;，但最近发布的Istio v1 alpha3 API利用Gateway提供更丰富的功能，因为Kubernetes Ingress已被证明不足以满足Istio应用程序的要求。Kubernetes Ingress API合并了L4-6和L7的规范，这使得拥有单独信任域（如SecOps和NetOps）的组织中的不同团队难以拥有Ingress流量管理。&lt;/p&gt;
&lt;p&gt;此外，Ingress API的表现力不如Istio为Envoy提供的路由功能。在Kubernetes Ingress API中进行高级路由的唯一方法是为不同的入口控制器添加注解。组织内的单独关注点和信任域保证需要一种更有效的方式来管理入口，这些可以由Istio Gateway和VirtualServices来完成。&lt;/p&gt;
&lt;p&gt;一旦流量进入网格，最好能够为VirtualServices提供分离的关注点，以便不同的团队可以管理其服务的流量路由。 L4-L6规范通常是SecOps或NetOps可能关注的内容。 L7规范是集群运营商或应用程序所有者最关心的问题。因此，正确分离关注点至关重要。&lt;/p&gt;
&lt;p&gt;由于我们相信团队责任的力量，我们认为这是一项重要的能力。由于我们相信Istio的力量，我们正在Istio社区中提交&lt;a href=&#34;https://docs.google.com/document/d/17K0Tbp2Hv1RAkpFxVTIYPLQRuceyUnABtt0amd9ZVow/edit#heading=h.m6yvqjh71gxi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFE&lt;/a&gt;，这将有助于为网格内的流量管理启用所有权语义。&lt;/p&gt;
&lt;p&gt;我们很高兴Istio已经发布&lt;a href=&#34;https://thenewstack.io/istio-1-0-come-for-traffic-routing-stay-for-distributed-tracing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;1.0版本&lt;/a&gt;，并且很乐意继续为项目和社区做出贡献。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
