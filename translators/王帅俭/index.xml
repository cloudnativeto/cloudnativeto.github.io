<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>王帅俭 | 云原生社区</title>
    <link>https://cloudnative.to/translators/%E7%8E%8B%E5%B8%85%E4%BF%AD/</link>
      <atom:link href="https://cloudnative.to/translators/%E7%8E%8B%E5%B8%85%E4%BF%AD/index.xml" rel="self" type="application/rss+xml" />
    <description>王帅俭</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Fri, 07 Dec 2018 12:52:58 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/translators/%E7%8E%8B%E5%B8%85%E4%BF%AD/avatar_hue38add62c87b7486d80c9f3fda25dfc1_12220_270x270_fill_q75_lanczos_center.jpg</url>
      <title>王帅俭</title>
      <link>https://cloudnative.to/translators/%E7%8E%8B%E5%B8%85%E4%BF%AD/</link>
    </image>
    
    <item>
      <title>Envoy中的数据统计</title>
      <link>https://cloudnative.to/blog/envoy-stats/</link>
      <pubDate>Fri, 07 Dec 2018 12:52:58 +0800</pubDate>
      <guid>https://cloudnative.to/blog/envoy-stats/</guid>
      <description>&lt;p&gt;这是我在&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;架构系列中的第3篇文章。这篇文章基于以前关于Envoy的&lt;a href=&#34;https://medium.com/@mattklein123/envoy-threading-model-a8d44b922310&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;线程模型&lt;/a&gt;和&lt;a href=&#34;https://medium.com/@mattklein123/envoy-hot-restart-1d16b14555b5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;热重启&lt;/a&gt;功能的帖子。如果您还没有阅读这些帖子，请先阅读。 需要指出的是，随着预演的结束，我们现在可以进入更有趣的话题！&lt;/p&gt;
&lt;h2 id=&#34;统计概述&#34;&gt;统计概述&lt;/h2&gt;
&lt;p&gt;到目前为止，Envoy所做的最重要的事情是为分布式系统的可观测性提供了一个健壮的平台。这包括统计数据、日志记录和分布式跟踪。这篇文章将集中在统计数据和Envoy是如何实现允许高容量的同时保持卓越性能的。Envoy目前支持三种不同的统计数据:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Counter（计数器）&lt;/strong&gt;：只能增加不会减少的无符号整数。 例如，总请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gauge（计量）&lt;/strong&gt;：可以同时增加和减少的无符号整数。 例如，目前有效的请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Timer/hitogram（计时器/直方图）&lt;/strong&gt;：无符号整数，最终将产生汇总百分位值。Envoy不区分计时器（通常以毫秒为单位）和原始直方图（可以是任何单位）。 例如，上游请求时间（以毫秒为单位）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Envoy目前不支持任何浮点统计数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/envoy-stats/006tNbRwly1fxv00zgfu2j30m804ugmh_huf7f3688ffc51e6a27ba202f38813ac41_29421_2316e4a37a0bdc18a04b3884de8511b5.webp 400w,
               /blog/envoy-stats/006tNbRwly1fxv00zgfu2j30m804ugmh_huf7f3688ffc51e6a27ba202f38813ac41_29421_ec4e37070856cdbf03605b9dba8675c7.webp 760w,
               /blog/envoy-stats/006tNbRwly1fxv00zgfu2j30m804ugmh_huf7f3688ffc51e6a27ba202f38813ac41_29421_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/envoy-stats/006tNbRwly1fxv00zgfu2j30m804ugmh_huf7f3688ffc51e6a27ba202f38813ac41_29421_2316e4a37a0bdc18a04b3884de8511b5.webp&#34;
               width=&#34;760&#34;
               height=&#34;165&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;center&gt;Envoy生成很多对调试分布式系统有用的数据！&lt;/center&gt;
## 统计子系统目标
&lt;p&gt;Envoy统计子系统的总体目标如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;粗略的线性吞吐量：可以与任意数量的工作线程一起扩展。另一种说法是:在稳定状态下，使用stats时应该没有跨线程争用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在使用热重启时，状态应该在逻辑上保持一致。这意味着即使有两个Envoy进程在运行，当逻辑上认为是单个进程时，所有计数器、量规和直方图都应该是一致的。（有关这方面的更多信息，请参阅&lt;a href=&#34;https://medium.com/@mattklein123/envoy-hot-restart-1d16b14555b5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;热重启&lt;/a&gt;这篇文章）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计数据应该包含在作用域内并作为一个组释放。作用域是具有公共前缀的统计数据的逻辑分组。例如:&lt;code&gt;http.admin.*&lt;/code&gt;。这一点很重要，因为Envoy具有动态性。Envoy支持各种&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;管理API&lt;/a&gt;，如监听器发现服务（LDS）和集群发现服务（CDS） API。为了不耗尽内存，Envoy需要清理不再使用的统计数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计范围应该能够重叠和正确的引用计数。这意味着如果作用域A使用一个名为&lt;code&gt;foo.bar.baz&lt;/code&gt;的属性，作用域B也使用&lt;code&gt;foo.bar.baz&lt;/code&gt;属性，那么&lt;code&gt;foo.bar.baz&lt;/code&gt;的属性的引用计数应该是2。这对于热重启（两个进程将在一段时间内写入相同的统计数据）和动态管理API（在一段时间内，更新的监听器或集群将引用与旧监听器或集群相同的统计数据）都是必需的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计数据子系统应该能够很好地执行直到数据平面处理开始时才知道的统计信息。许多统计数据本质上是“固定的”，可以在加载配置或动态API重新配置数据平面时创建（例如，&lt;code&gt;cluster.foo.upstream_rq_5xx&lt;/code&gt;）。这些都是低频事件。其他统计信息，例如详细的HTTP响应代码度量（例如，&lt;code&gt;cluster.foo.upstream_rq_503&lt;/code&gt;），在数据开始流动之前都不知道。使用“动态”的统计数据永远不会像使用“固定”的统计数据那样快，但是即使在处理每个内核每秒数千个请求的10次时，性能仍然应该是足够的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为一个整体，上述目标需要一个复杂的系统来满足。我们现在将深入研究这个系统是如何工作的。&lt;/p&gt;
&lt;h2 id=&#34;数据架构&#34;&gt;数据架构&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/envoy-stats/006tNbRwly1fxv13dqf7mj30m808zwf9_hubd6d9c259526179c1e2a6513193b119b_26676_3a9ee800366a75d9dccb41cd84cae387.webp 400w,
               /blog/envoy-stats/006tNbRwly1fxv13dqf7mj30m808zwf9_hubd6d9c259526179c1e2a6513193b119b_26676_d46dcaeab96f31575cc584f5622c159d.webp 760w,
               /blog/envoy-stats/006tNbRwly1fxv13dqf7mj30m808zwf9_hubd6d9c259526179c1e2a6513193b119b_26676_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/envoy-stats/006tNbRwly1fxv13dqf7mj30m808zwf9_hubd6d9c259526179c1e2a6513193b119b_26676_3a9ee800366a75d9dccb41cd84cae387.webp&#34;
               width=&#34;760&#34;
               height=&#34;307&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;center&gt;图1：高级统计架构，蓝色统计数据显示了一个作用域分组。&lt;/center&gt;
**图1**显示了Envoy数据统计子系统的高级架构。它由以下几个部分组成。
&lt;h3 id=&#34;存储&#34;&gt;存储&lt;/h3&gt;
&lt;p&gt;stat存储是Envoy内部的一个单例对象，并提供了一个简单的接口，通过该接口，其余代码可以获得作用域、计数器、计量和直方图的句柄。调用代码负责维护所有创建的作用域的所有权语义。当作用域被销毁时，所有包含的统计数据的引用计数都会减少1。如果任何统计数据达到0引用计数，它们将被释放。&lt;/p&gt;
&lt;h3 id=&#34;统计数据&#34;&gt;统计数据&lt;/h3&gt;
&lt;p&gt;如前所述，统计数据包括计数器、量规和直方图。从终端用户的角度来看，这些接口使用起来非常简单。例如，计数器和计量都包括&lt;code&gt;inc()&lt;/code&gt;和&lt;code&gt;dec()&lt;/code&gt;方法，而只有计量包括&lt;code&gt;set()&lt;/code&gt;方法。程序员看不到任何潜在的存储复杂性。&lt;/p&gt;
&lt;h3 id=&#34;flusher&#34;&gt;Flusher&lt;/h3&gt;
&lt;p&gt;为了获得高性能，使用原子CPU指令在内部缓冲所有的状态变化。在可配置的间隔内，所有计数器和计量都被冲到flusher中。注意，在当前的架构中，直方图值直接发送到接收器。下面将更详细地描述这一点。Flusher在main线程中运行。&lt;/p&gt;
&lt;h3 id=&#34;sink&#34;&gt;Sink&lt;/h3&gt;
&lt;p&gt;统计数据接收器是一个接口，它接受通用的统计数据并将其转换为特定于后端的连线格式。所有接收器都使用TLS，这样在刷新输出时就不会出现争用。然而，在实践中，目前只有主线会冲掉计数器和量规。所有线程都刷新直方图。&lt;/p&gt;
&lt;p&gt;目前Envoy只支持TCP和UDP &lt;a href=&#34;https://github.com/b/statsd_spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;statsd&lt;/a&gt;协议。statsd是一种非常简单但得到广泛支持的传输格式。在未来，很可能会实现其他本地统计数据接收器，如&lt;a href=&#34;https://prometheus.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus&lt;/a&gt;、&lt;a href=&#34;https://www.wavefront.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wavefront&lt;/a&gt;和 &lt;a href=&#34;https://www.influxdata.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfluxDB&lt;/a&gt;。还要注意Envoy目前不支持维度或标签统计。这将在下面的工作部分中进一步讨论。&lt;/p&gt;
&lt;h3 id=&#34;admin&#34;&gt;Admin&lt;/h3&gt;
&lt;p&gt;从操作的角度来看，能够实时地到达一个节点并转储当前状态是非常有用的。Envoy可以通过&lt;code&gt;/stats&lt;/code&gt;&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;管理端点&lt;/a&gt;实现此功能。管理端点直接查看存储库以加载所有计数器和计量并打印它们。这个端点目前不输出任何直方图数据。这同样是由于在当前的实现中直方图值是直接写入接收器的，因此存储不知道它们。&lt;/p&gt;
&lt;h3 id=&#34;直方图的架构&#34;&gt;直方图的架构&lt;/h3&gt;
&lt;p&gt;正如已经多次提到的，Envoy目前不维护进程内直方图数据。除了开发效率之外，没有什么特别的原因；Lyft使用的statsd摄取管道提供了自己的直方图支持，并希望直方图值直接发送到它。因此，直方图值目前不能通过管理端点查看。未来我们很可能直接在Envoy内部实现&lt;a href=&#34;http://hdrhistogram.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HDR直方图&lt;/a&gt;。这一点将在下面进一步讨论。&lt;/p&gt;
&lt;h3 id=&#34;线程本地热重启的能力存储&#34;&gt;线程本地热重启的能力存储&lt;/h3&gt;
&lt;p&gt;以上所有的背景都完成了，现在是时候深入到有趣的部分：实践中是如何工作的?&lt;/p&gt;
&lt;h4 id=&#34;统计项&#34;&gt;统计项&lt;/h4&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/envoy-stats/006tNbRwly1fxv1793dqqj30m8028glv_hu30f54fd114145af92b3751f8bbeeff3f_12826_2688680706d293061cc3c081fc16d272.webp 400w,
               /blog/envoy-stats/006tNbRwly1fxv1793dqqj30m8028glv_hu30f54fd114145af92b3751f8bbeeff3f_12826_4bff9b9938a4fe08022694ceb4df6cab.webp 760w,
               /blog/envoy-stats/006tNbRwly1fxv1793dqqj30m8028glv_hu30f54fd114145af92b3751f8bbeeff3f_12826_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/envoy-stats/006tNbRwly1fxv1793dqqj30m8028glv_hu30f54fd114145af92b3751f8bbeeff3f_12826_2688680706d293061cc3c081fc16d272.webp&#34;
               width=&#34;760&#34;
               height=&#34;76&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;center&gt;图2：共享内存中单独的计数器/计量统计项&lt;/center&gt;
正如我们在[热重启文章](https://medium.com/@mattklein123/envoy-hot-restart-1d16b14555b5)中已经讨论过的那样，最终，所有统计数据都存储在共享内存中，以便可以在所有进程中使用它们。**图2**显示了单个stat条目。它由以下几个部分组成:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Name&lt;/strong&gt;：完全解析的属性名，例如&lt;code&gt;http.admin.downstream_cx_active&lt;/code&gt;。目前限制为128个字符。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value&lt;/strong&gt;：属性的当前值。该数据包含量具的当前值和计数器的当前总价值。所有的数据写操作都使用原子操作，所以它们在多线程环境下是安全的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pending increment&lt;/strong&gt;：此数据仅供计数器使用。除了值之外，每个增量都是原子式的。之所以这样做，是因为大多数统计数据接收器想要获取刷新之间的增量而不是总数。因此，在冲洗期间计数器是锁住的。挂起的增量被写入计数器，然后归零。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flags&lt;/strong&gt;：目前只支持标志&lt;code&gt;used&lt;/code&gt;。这表示如果统计数据被写过，那么代码能够区分零和从未写过。Envoy不会刷新从来没有使用过的统计数据，以避免压倒性的统计后端很少使用的统计数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ref count&lt;/strong&gt;：Ref count允许重叠范围（可能在多个进程中）使用相同的底层统计数据。只有当ref计数为0时，才释放统计数据内存供将来使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;存储-1&#34;&gt;存储&lt;/h4&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/envoy-stats/006tNbRwly1fxv1e9mvjdj30m80f1gn7_hua48cded1631941f90fc93c54c64de2c0_48455_41c5df4852e4d032baa2bd60ee0eaf81.webp 400w,
               /blog/envoy-stats/006tNbRwly1fxv1e9mvjdj30m80f1gn7_hua48cded1631941f90fc93c54c64de2c0_48455_c8f1906fac059b2c8fc28debad23c953.webp 760w,
               /blog/envoy-stats/006tNbRwly1fxv1e9mvjdj30m80f1gn7_hua48cded1631941f90fc93c54c64de2c0_48455_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/envoy-stats/006tNbRwly1fxv1e9mvjdj30m80f1gn7_hua48cded1631941f90fc93c54c64de2c0_48455_41c5df4852e4d032baa2bd60ee0eaf81.webp&#34;
               width=&#34;760&#34;
               height=&#34;514&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;center&gt;图3:线程本地热重启支持的存储体系结构&lt;/center&gt;
**图3** 显示了Envoy内部使用的线程本地stat存储的设计。这个版本的商店满足了之前发布的所有设计目标。现在我们将详细介绍它的工作原理。
&lt;ol&gt;
&lt;li&gt;该存储是单例存储，整个Envoy流程都使用它。所有的范围、计数器和标准引用都是从这个单例中心存储库获得的。（本节将不介绍直方图，因为目前直方图不重要，直接刷新到TLS 统计数据接收器）。&lt;/li&gt;
&lt;li&gt;当线程试图通过作用域获取计数器或量规时，它首先在作用域TLS缓存中按名称查找计数器或量规。如果在缓存中找到了统计数据，它将立即返回给调用者，而不需要任何锁定。如果没有找到该属性，则必须从范围中央缓存中获取该属性。&lt;/li&gt;
&lt;li&gt;范围中央缓存通过标准进程范围内的互斥锁锁定（在稳定状态下，它不应该被高度竞争，因为统计信息将在范围TLS缓存中找到）。如果在中心缓存中找到了统计数据，那么它将返回到TLS缓存，在那里存储它以供以后无锁查找。如果在中央缓存中没有找到该属性，则必须从共享内存中分配该属性。&lt;/li&gt;
&lt;li&gt;共享内存包含一系列固定的个人统计条目（图2）。Envoy包含一个非常基本的分配器，搜索统计条目名称相同的槽(支持热重启和重叠范围)或一个空位置,选择初始化槽如果目前空,增加引用计数,并返回它。这是在热重启期间跨进程统计数据的工作方式。两个进程都将从共享内存中分配一个统计数据条目槽，但是其中一个进程最终将引用计数增加到两个（相同的进程在重叠作用域创建期间发生）。如果在共享内存中找不到空间，Envoy将增加一个“panic”属性并返回一个特殊的溢出属性槽，以便进程可以在降级状态下继续运行。一旦一个统计数据槽被分配，它就被包装在一个进程本地数据结构中，存储在范围中心缓存中，存储在范围TLS缓存中，然后最终返回给调用者。&lt;/li&gt;
&lt;li&gt;回想一下，stat子系统的目标之一是使作用域安全可删除。作用域是全局对象，由主线程和单例存储管理。删除作用域时，不同线程上的作用域TLS缓存可能持有对单个统计数据的引用。为了说明这一点，“作用域缓存刷新”事件通过TLS发送到每个线程。线程使用&lt;a href=&#34;https://medium.com/@mattklein123/envoy-threading-model-a8d44b922310&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;线程模型文章&lt;/a&gt;中描述的类似RCU的行为释放所有对作用域统计的引用。一旦计数器或表的最后一次引用计数被减少，共享内存统计项插槽也被释放。这是通过在统计数据条目插槽上减少引用计数来完成的。如果这个引用计数现在为零，那么这个槽就被完全释放了，并且可以被任何进程用于一个新的状态。如果前面的描述有点混乱，总结一下：Envoy中的所有统计数据都由两个引用计数控制。第一个引用计数用于进程内TLS缓存的状态，第二个引用用于多个进程共享的备份状态入口槽。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;回顾一下，让我们看看上面的设计如何满足所有的原始目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线性吞吐量&lt;/strong&gt;：在稳定状态下，所有的统计数据分配都通过作用域TLS缓存进行。对于大量的工作线程来说这要求不能加锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在热重新启动期间逻辑上是一致的&lt;/strong&gt;：最终，所有同名的数据在共享内存中使用相同的备份存储。这在流程之间创建了逻辑一致性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统计数据包含在一个作用域内，可以作为一个组释放，也可以重叠&lt;/strong&gt;：作用域具有完全独立的中央缓存和TLS缓存，以及独立的每个统计数据引用计数。一个作用域可以被移除，并且它的所有统计数据的引用计数将会减少，并且可能会被释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;足够的动态统计数据性能&lt;/strong&gt;：通过范围TLS缓存查找动态统计数据并使用O(1)哈希表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;未来的工作&#34;&gt;未来的工作&lt;/h2&gt;
&lt;p&gt;虽然Envoystats子系统工作得很好，但是有几个方面在未来可以改进:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;维度/标记状态:&lt;/strong&gt; 大多数更新的状态后端支持维度/标记，而不仅仅是一个扁平的层次命名空间。在特使统计数据的某些区域中，这是很有用的。短期而言，我们可能会添加全球标记支持，作为支持它的后端（如Prometheus、Wavefront和流感数据库）的第一步。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程本地原子缓存:&lt;/strong&gt; 在worker数量和吞吐量极高的情况下，单个stat值上的原子争用将成为一个问题。这可以通过移动到TLS计数器和压力表来解决，这些计数器和压力表在冲洗之前被聚集到中央存储中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内置的HDR直方图:&lt;/strong&gt; 由于几个原因（管理输出、基于异常值的延迟检测和没有内置直方图支持的接收器），向Envoy添加直接的HDR直方图支持将非常有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;额外的静态接收器:&lt;/strong&gt; 如前所述，我们希望直接支持更多的后端，如Prometheus、Wavefront、InfluxDB等。幸运的是，接收器接口很简单，添加新的实现并不困难。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;为了满足上述目标，Envoy的数据统计子系统的设计是新颖的。到目前为止，它在实践中表现得非常好，对于其他用例来说，扩展起来应该相对容易。&lt;/p&gt;
&lt;h2 id=&#34;代码链接&#34;&gt;代码链接&lt;/h2&gt;
&lt;p&gt;本文中涉及到的一些接口及实现的头文件请参考下面链接:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/envoy/blob/master/include/envoy/stats/stats.h&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/envoyproxy/envoy/blob/master/include/envoy/stats/stats.h&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/envoy/tree/master/source/common/stats&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/envoyproxy/envoy/tree/master/source/common/stats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>为什么你应该关心Istio gateway</title>
      <link>https://cloudnative.to/blog/why-you-should-care-about-istio-gateways/</link>
      <pubDate>Mon, 13 Aug 2018 20:44:06 +0800</pubDate>
      <guid>https://cloudnative.to/blog/why-you-should-care-about-istio-gateways/</guid>
      <description>&lt;p&gt;如果您要拆分单体架构，使用Istio管理您的微服务的一个巨大优势是，它利用与传统负载均衡器和应用分发控制器类似的入口模型的配置。&lt;/p&gt;
&lt;p&gt;在负载均衡器领域，虚拟IP和虚拟服务器一直被认为是使运营商能够以灵活和可扩展的方式配置入口流量的概念（&lt;a href=&#34;https://devcentral.f5.com/articles/wils-virtual-server-versus-virtual-ip-address&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lori Macvittie对此有一些相关的想法&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;在Istio中，&lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#Gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway&lt;/a&gt;控制网格边缘的服务暴露。Gateway允许用户指定L4-L6设置，如端口和TLS设置。对于Ingress流量的L7设置，Istio允许您将网关绑定到&lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#VirtualService&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VirtualServices&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这种分离使得管理流入到网格的流量变得容易，就像在传统负载均衡器中将虚拟IP绑定到虚拟服务器一样。这使得传统技术栈用户能够以无缝方式迁移到微服务。对于习惯于整体和边缘负载均衡器的团队来说，这是一种自然的进步，而不需要考虑全新的网络配置方式。&lt;/p&gt;
&lt;p&gt;需要注意的一点是，在服务网格中路由流量和将外部流量引入网格不同。在网格中，您在正常流量中分辨异常的部分，因为只要在服务网格内，默认情况下Istio可以与（与Kubernetes兼容）所有应用通信。&lt;strong&gt;如果您不希望与某些服务进行通信，则必须添加策略。反向代理（类似于传统的负载均衡器）获取进入网格的流量，您必须准确指定哪些流量允许进入网格。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;早期版本的Istio利用Kubernetes的&lt;a href=&#34;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#ingress-v1beta1-extensions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ingress资源&lt;/a&gt;，但最近发布的Istio v1 alpha3 API利用Gateway提供更丰富的功能，因为Kubernetes Ingress已被证明不足以满足Istio应用程序的要求。Kubernetes Ingress API合并了L4-6和L7的规范，这使得拥有单独信任域（如SecOps和NetOps）的组织中的不同团队难以拥有Ingress流量管理。&lt;/p&gt;
&lt;p&gt;此外，Ingress API的表现力不如Istio为Envoy提供的路由功能。在Kubernetes Ingress API中进行高级路由的唯一方法是为不同的入口控制器添加注解。组织内的单独关注点和信任域保证需要一种更有效的方式来管理入口，这些可以由Istio Gateway和VirtualServices来完成。&lt;/p&gt;
&lt;p&gt;一旦流量进入网格，最好能够为VirtualServices提供分离的关注点，以便不同的团队可以管理其服务的流量路由。 L4-L6规范通常是SecOps或NetOps可能关注的内容。 L7规范是集群运营商或应用程序所有者最关心的问题。因此，正确分离关注点至关重要。&lt;/p&gt;
&lt;p&gt;由于我们相信团队责任的力量，我们认为这是一项重要的能力。由于我们相信Istio的力量，我们正在Istio社区中提交&lt;a href=&#34;https://docs.google.com/document/d/17K0Tbp2Hv1RAkpFxVTIYPLQRuceyUnABtt0amd9ZVow/edit#heading=h.m6yvqjh71gxi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFE&lt;/a&gt;，这将有助于为网格内的流量管理启用所有权语义。&lt;/p&gt;
&lt;p&gt;我们很高兴Istio已经发布&lt;a href=&#34;https://thenewstack.io/istio-1-0-come-for-traffic-routing-stay-for-distributed-tracing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;1.0版本&lt;/a&gt;，并且很乐意继续为项目和社区做出贡献。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
