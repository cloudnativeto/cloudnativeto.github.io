<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>罗广明 | 云原生社区</title>
    <link>https://cloudnative.to/translators/%E7%BD%97%E5%B9%BF%E6%98%8E/</link>
      <atom:link href="https://cloudnative.to/translators/%E7%BD%97%E5%B9%BF%E6%98%8E/index.xml" rel="self" type="application/rss+xml" />
    <description>罗广明</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 22 Oct 2019 19:25:19 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/translators/%E7%BD%97%E5%B9%BF%E6%98%8E/avatar_hu2a3c8bc746d550421192af01f1d0a928_56838_270x270_fill_q75_lanczos_center.jpg</url>
      <title>罗广明</title>
      <link>https://cloudnative.to/translators/%E7%BD%97%E5%B9%BF%E6%98%8E/</link>
    </image>
    
    <item>
      <title>企业组织中采用服务网格的挑战</title>
      <link>https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/</link>
      <pubDate>Tue, 22 Oct 2019 19:25:19 +0800</pubDate>
      <guid>https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.christianposta.com/challenges-of-adopting-service-mesh-in-enterprise-organizations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;本文作者介绍了企业组织采用服务网格面临的哪些挑战，建议企业应该从数据平面开始逐步推进，从了解它、熟悉它、再到扩大规模使用它，并且以介绍其演讲的幻灯片为切入点介绍了架构演进的步骤。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;最近，我写了&lt;a href=&#34;https://dzone.com/trendreports/migrating-to-microservices-2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一篇&lt;/a&gt;关于在企业组织中采用服务网格的具有哪些挑战的文章，这篇文章是为DZone及其迁移到微服务的报告撰写的。在这篇文章中，我们首先要解决的问题之一是“你是否应该沿着采用服务网格的道路走下去”，我是这么说的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先回答“不”。如果您刚刚开始使用微服务架构和少量的服务，请确保您首先准备好了基础部分。微服务及其相关的基础设施是一种优化方式，可以让您更快的变更应用程序。在没有服务网格的情况下，您可以朝着更快的方向前进。你甚至可能想要一些服务网格带来的好处，而不是去关注它所有的复杂性。那么，请看看类似Gloo的产品，一个建立在Envoy代理上的API网关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为在当前时刻，这是一个非常重要的考虑，有以下两大原因:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总的来看，服务网格的实现还没有准备好投入生产。&lt;/li&gt;
&lt;li&gt;全部投入(all-in)到一个服务网络的复杂性仍然很高。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这并不意味着没有团队成功地使用了服务网格，或者您应该远离它。但是，我确实认为您应该建立这样的能力，当您真正准备好了并且可以从中获益的时候，最终能成功地将服务网格引入。例如，在报告中，我列出了您&lt;strong&gt;可能想要使用&lt;/strong&gt;服务网格的原因:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨多个集群部署大量微服务&lt;/li&gt;
&lt;li&gt;容器/k8s和虚拟机的混合部署&lt;/li&gt;
&lt;li&gt;用于构建服务的语言的异构部署&lt;/li&gt;
&lt;li&gt;网络可观测性的不完整和不一致视图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即使有了以上这些理由，你依然会面临这些挑战:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择哪一个服务网格产品？&lt;/li&gt;
&lt;li&gt;谁来做技术支持？&lt;/li&gt;
&lt;li&gt;单集群的多租户问题&lt;/li&gt;
&lt;li&gt;缺乏多集群的管理方法&lt;/li&gt;
&lt;li&gt;已有服务如何适配（sidecar的生命周期、竞态条件等等）&lt;/li&gt;
&lt;li&gt;开发人员与运维人员的界限在哪里&lt;/li&gt;
&lt;li&gt;非容器环境/混合环境&lt;/li&gt;
&lt;li&gt;中心化 vs 去中心化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过我在&lt;a href=&#34;https://blog.christianposta.com/moving-on-from-red-hat/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat&lt;/a&gt;和现在&lt;a href=&#34;https://blog.christianposta.com/career/new-adventure-starts-at-solo-io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;加起来两年以上的工作，我一直在帮助人们解决那些棘手的问题(顺便说一句，如果你想交谈/需要这些方面的帮助，可以通过&lt;a href=&#34;http://twitter.com/christianposta?lang=en&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt;联系我)。但有一件我从我们的客户/用户一直观察到，并且持续一段时间提出建议，那就是你采用服务网格的第一步，应该总是先使用在一定程度上（自行）隔离的数据平面技术，要了解它是如何工作的，如何实施，如何调试等等。&lt;/p&gt;
&lt;p&gt;例如，在我最近做的一次演讲中，我说过要从Envoy（Envoy是许多服务网格实现的底层数据平面技术）开始。PPT如下:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-start-slow-slide&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;start-slow-slide&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/start-slow-slide_hu41c7057337bdf8947651db183d6af729_314126_f08e1a94e7fbede4768690d136c6e59c.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/start-slow-slide_hu41c7057337bdf8947651db183d6af729_314126_287b5dddfe44dc31432b27f3bbffce53.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/start-slow-slide_hu41c7057337bdf8947651db183d6af729_314126_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/start-slow-slide_hu41c7057337bdf8947651db183d6af729_314126_f08e1a94e7fbede4768690d136c6e59c.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      start-slow-slide
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从架构的角度来看，它可能是这样的:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-single-gateway&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;single-gateway&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/single-gateway_huae96d8327c213fa8a8d0a4bbc67dab51_440393_70af179684f223dd0f426c52cf0f2cbd.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/single-gateway_huae96d8327c213fa8a8d0a4bbc67dab51_440393_2abc4f92a40725efa7bb66d42edff4e0.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/single-gateway_huae96d8327c213fa8a8d0a4bbc67dab51_440393_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/single-gateway_huae96d8327c213fa8a8d0a4bbc67dab51_440393_70af179684f223dd0f426c52cf0f2cbd.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      single-gateway
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当然，如果你要使用Envoy，我&lt;a href=&#34;https://medium.com/solo-io/getting-started-with-a-service-mesh-starts-with-a-gateway-96384deedca2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;建议从Gloo&lt;/a&gt;开始，这基本上是一个&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;具有edge与API网关能力的企业版Envoy&lt;/a&gt;，并且很好地植入了服务网格。一旦你有了它，对它熟练使用，那么你就会准备好增加它的使用，甚至可能通过代理的分层引入一些隔离:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-multi-tier-gw&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;multi-tier-gw&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/multi-tier-gw_hu48e3294b012b96a9599800021aa9a1bc_515191_240a6b31d05afd00d64c89ac5e7f2b8a.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/multi-tier-gw_hu48e3294b012b96a9599800021aa9a1bc_515191_09149a77fbf2dff50528dcc7e4f855d2.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/multi-tier-gw_hu48e3294b012b96a9599800021aa9a1bc_515191_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/multi-tier-gw_hu48e3294b012b96a9599800021aa9a1bc_515191_240a6b31d05afd00d64c89ac5e7f2b8a.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      multi-tier-gw
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来的方法是将网关推入到应用架构中。我们看到我们的用户在每个应用程序边界采用一个网关的方法，开始有了一个网格的“感觉”，但在应用程序引入了一些结构(例如，&lt;a href=&#34;https://medium.com/solo-io/api-gateways-are-going-through-an-identity-crisis-d1d833a313d7&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API网关模式&lt;/a&gt;)。我开始称之为“waypoints”架构。就像飞行员使用航路点（waypoints）来指导他们的飞行计划一样，这些网关为您的应用架构增加了结构，同时解决了诸如安全性和API解耦的南北通信问题，同时为成功采用服务网格奠定了基础。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-bc-gw&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;bc-gw&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/bc-gw_hua2b7641dacb412fc60d8a4f5ba249d94_532778_73290757d39d4e2f998b402f3c1dd54f.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/bc-gw_hua2b7641dacb412fc60d8a4f5ba249d94_532778_39ce87fd69dc3a86b8688329a9ab9083.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/bc-gw_hua2b7641dacb412fc60d8a4f5ba249d94_532778_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/bc-gw_hua2b7641dacb412fc60d8a4f5ba249d94_532778_73290757d39d4e2f998b402f3c1dd54f.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      bc-gw
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，您可以开始在应用程序中引入独立于边界的服务网格代理，以解决棘手的但恰恰是服务网格技术最擅长解决的service-to-service通信挑战:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-push-down-gw&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;push-down-gw&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/push-down-gw_hu9d6a7c9431c187f2ad5e0e5d61658726_608097_e8fa79452386cd054ac5c95cce7d311c.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/push-down-gw_hu9d6a7c9431c187f2ad5e0e5d61658726_608097_3596b05dceb062b4d1f227b433314054.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/push-down-gw_hu9d6a7c9431c187f2ad5e0e5d61658726_608097_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/push-down-gw_hu9d6a7c9431c187f2ad5e0e5d61658726_608097_e8fa79452386cd054ac5c95cce7d311c.webp&#34;
               width=&#34;760&#34;
               height=&#34;433&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      push-down-gw
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里重要的部分是网关，并且仍然有非常有用的用途！它们向应用架构中添加结构和路径点，同时在需要的地方将某些实现细节与其他服务分离并隐藏起来。在很多方面，这都遵循了DDD有界上下文模型，网关提供了一个“反腐败”层。否则，如果你只是把所有的服务都当作“伙伴”，你就会开始坚定地迈向死星:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deathstar&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;deathstar&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/deathstar_hu2d45f23c61ea6542ffc656140423a2ca_1068805_54a216ce336a4adc096dbf896adb76e9.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/deathstar_hu2d45f23c61ea6542ffc656140423a2ca_1068805_8fb8c1c32c67b380429d5f774ee4c888.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/deathstar_hu2d45f23c61ea6542ffc656140423a2ca_1068805_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/deathstar_hu2d45f23c61ea6542ffc656140423a2ca_1068805_54a216ce336a4adc096dbf896adb76e9.webp&#34;
               width=&#34;760&#34;
               height=&#34;433&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      deathstar
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;希望这篇文章有助于您奠定一个成功的方法，通过小范围使用服务网格，然后逐渐缓慢扩展有意义的各个地方，并且你的应用程序可以从服务网格架构中获益。否则，您将承担同时引入太多复杂性的风险，这将违背您实现应用程序和基础设施现代化的意图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>构建Envoy的控制平面手册第5部分 - 部署的权衡</title>
      <link>https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/</link>
      <pubDate>Fri, 14 Jun 2019 10:30:32 +0800</pubDate>
      <guid>https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.christianposta.com/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;作为探索为Envoy构建控制平面系列文章的第5部分，本文介绍了部署控制平面的选项与权衡，着重阐述了保持控制平面与数据平面解耦的几大好处，并且在文章结尾建议构建一个可拔插的控制平面以支持各种新特性、拓展和适配。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;这是探索为Envoy构建控制平面&lt;a href=&#34;https://blog.christianposta.com/envoy/guidfor-build-a-control-plane-to-management-Envoy-Proxy-based-infrastructure/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;系列文章&lt;/a&gt;的第5部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;采用一种机制来动态更新Enovy的路由、服务发现和其他配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-for-envoy-identify-components/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;识别构成控制平面的组件，包括支持存储、服务发现api、安全组件等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-for-envoy-domain-specific-configuration-api/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构建最适合你的使用场景和组织架构的特定域的配置对象和api&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/guidance-for-building-a-control-plane-for-envoy-build-for-pluggability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;考虑如何最好地使你的控制平面可插在你需要它的地方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;部署各种控制平面组件的选项 (本文)&lt;/li&gt;
&lt;li&gt;基于控制平面的测试工具的思考&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上一篇文章中，我们探讨了为什么可拔插控制平面对于跟上快速迭代的Envoy API以及与组织可能采用的不同工作流集成至关重要。在本文中，我们将讨论部署各种控制平面组件时的权衡。&lt;/p&gt;
&lt;h2 id=&#34;部署控制平面组件&#34;&gt;部署控制平面组件&lt;/h2&gt;
&lt;p&gt;一旦您构建并设计了控制平面及其各种支持组件，您就需要准确地决定如何部署它的组件。在确定最适合您的实现时，您需要权衡各种安全性、可伸缩性和可用性问题。这些选项里包括将控制平面组件与数据平面一起部署，以及将控制平面与数据平面完全解耦。这里也有一个折中方案：部署一些与控制平面共存的组件，并保持一些集中。让我们来看看。&lt;/p&gt;
&lt;p&gt;在Istio service-mesh项目中，控制平面组件与数据平面分别部署和运行。这在服务网格实现中非常常见。也就是说，数据平面与应用程序一起运行，处理所有的应用程序流量，并通过gRPC流上的xDS API与控制平面通信。控制平面组件通常在它们自己的命名空间中运行，并且在理想情况下，不当操作或者意外使用将导致组件被锁定。&lt;/p&gt;
&lt;p&gt;Gloo项目作为一个API网关，遵循类似的部署模型。控制平面组件与数据平面解耦，Envoy数据平面使用xDS gRPC流来收集关于监听器、路由、端点和集群等的配置。您可以使用Gloo部署与数据平面代理共存的控制面板组件，但不建议这样做。我们稍后会看一些权衡。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-separatecontrolplane&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;separatecontrolplane&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_a651071f50eaa71ceb37c3e28b1e2568.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_120b92ca1f1516fda4abe3a7aac586ac.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_a651071f50eaa71ceb37c3e28b1e2568.webp&#34;
               width=&#34;760&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      separatecontrolplane
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，我们研究了控制平面组件与数据平面的协同部署。在Contour项目中，默认情况下，控制平面组件是与数据平面一起部署的，尽管&lt;a href=&#34;https://github.com/heptio/contour/blob/master/docs/deploy-seperate-pods.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;存在一个拆分部署的选项&lt;/a&gt;。Contour实际上利用CRD或Ingress资源进行配置，所以所有的配置文件处理和监控都发生在Kubernetes中。然而，xDS服务却是与数据平面共同部署(同样，这是默认情况—您依然可以将它们拆分)。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-codeployed&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;codeployed&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/codeployed_hu2e5f4d5fbc8d87f9c2d950e759df9c70_8897_4600f5795ce4ab7b0321764abfd91021.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/codeployed_hu2e5f4d5fbc8d87f9c2d950e759df9c70_8897_d100aca9c02191713b3068cc33463e30.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/codeployed_hu2e5f4d5fbc8d87f9c2d950e759df9c70_8897_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/codeployed_hu2e5f4d5fbc8d87f9c2d950e759df9c70_8897_4600f5795ce4ab7b0321764abfd91021.webp&#34;
               width=&#34;231&#34;
               height=&#34;174&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      codeployed
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当&lt;a href=&#34;https://www.youtube.com/watch?v=a1tXFUrqt5M&amp;amp;list=PLj6h78yzYM2PF_iYEBntfR0m4KAZET18Q&amp;amp;index=14&amp;amp;t=0s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBay为他们的Envoy部署构建了控制平面&lt;/a&gt;时，他们还将控制平面(discovery pieces)的&lt;em&gt;部分组件&lt;/em&gt;与数据平面联合部署。他们基本上自己实现了一个控制器来监视CRD、Ingress和服务资源，并且生成配置映射。然后，这些配置映射将由与Pod一起运行的&lt;code&gt;discovery&lt;/code&gt;容器使用，并随着改动重新热启动，以及更新Envoy。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/ebay-control-plane_hu20d9f643d17bb9560af9b322a623721a_343064_5df639fb9b4e9f28a9ed5d7949974d16.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/ebay-control-plane_hu20d9f643d17bb9560af9b322a623721a_343064_1d55db1a70d1b864ef0295ae0f2c52d6.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/ebay-control-plane_hu20d9f643d17bb9560af9b322a623721a_343064_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/ebay-control-plane_hu20d9f643d17bb9560af9b322a623721a_343064_5df639fb9b4e9f28a9ed5d7949974d16.webp&#34;
               width=&#34;760&#34;
               height=&#34;220&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/double-click-ebay-control-plane_hub16ca4b77d7d4ef34eeecd11f5e28575_475483_28ced7fab1aefdac2b95193054e22b49.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/double-click-ebay-control-plane_hub16ca4b77d7d4ef34eeecd11f5e28575_475483_efef68d3d8f151fd763584f98d8901d0.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/double-click-ebay-control-plane_hub16ca4b77d7d4ef34eeecd11f5e28575_475483_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/double-click-ebay-control-plane_hub16ca4b77d7d4ef34eeecd11f5e28575_475483_28ced7fab1aefdac2b95193054e22b49.webp&#34;
               width=&#34;760&#34;
               height=&#34;239&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在Ebay的案例中，我们看到了一种“混合”的方法，并且深受其架构其余部分的具体影响。那么，在为Envoy评估控制平面时，或者考虑自己构建控制平面时，应该如何部署控制平面组件?&lt;/p&gt;
&lt;h3 id=&#34;我应该将控制平面与数据平面分开吗&#34;&gt;我应该将控制平面与数据平面分开吗?&lt;/h3&gt;
&lt;p&gt;各种方法都有优缺点。&lt;a href=&#34;https://github.com/solo-io/gloo/graphs/contributor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo团队&lt;/a&gt;认为，对于大多数应用场景来说，保持控制平面独立是正确的选择，应该避免将控制平面与数据平面完全部署在一起。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_a651071f50eaa71ceb37c3e28b1e2568.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_120b92ca1f1516fda4abe3a7aac586ac.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_a651071f50eaa71ceb37c3e28b1e2568.webp&#34;
               width=&#34;760&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果Envoy是L7网络的核心和灵魂，那么控制平面就是大脑。部署与数据平面分离的控制平面非常重要，原因如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全性—如果您的数据平面中的某个节点受到攻击，您肯定不希望因为允许您的控制平面受到攻击而放弃对其他应用程序和网络的控制，从而加剧您的情况。此外，控制平面可以处理密钥、证书或其他机密的分发，这些机密信息应该与数据平面分开保存。&lt;/li&gt;
&lt;li&gt;伸缩性—您可能最终会以不同的方式伸缩数据平面和控制平面。例如，如果您的控制平面正在轮询Kubernetes中的服务/端点等，那么您肯定不希望将这些组件与您的数据平面放在一起—您将扼杀任何可伸缩性的机会。&lt;/li&gt;
&lt;li&gt;分组—您的数据平面可能具有不同的角色和职责；例如，您可能在边缘有数据平面Envoy，这将需要不同的安全性和网络状态，而不是用于微服务的共享代理池与您可能部署的任何sidecar代理。将控制平面与数据平面放在一起会使数据和配置分开变得更加困难。&lt;/li&gt;
&lt;li&gt;资源利用—您可能希望根据组件分配或限制某些资源使用。例如，您的数据平面可能比控制平面更需要计算(控制平面可能更需要内存)，并且您将使用不同的资源限制来满足这些角色的需求。将它们分开可以让您获得更多细粒度的资源池选项，而不只是将它们集中在一起。此外，如果控制平面和数据平面被配置在一起，并且争夺相同的资源，您可能会得到难以诊断的奇怪的尾延迟(Tail Latency)。&lt;/li&gt;
&lt;li&gt;部署/生命周期—您可能希望独立于数据平面对控制平面进行补丁、升级或其他服务。&lt;/li&gt;
&lt;li&gt;存储—如果您的控制平面需要任何类型的存储，那么您可以单独配置它，如果您将组件分离出来，则不需要涉及数据平面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于这些原因，我们建议保持控制平面与数据平面解耦。&lt;/p&gt;
&lt;h2 id=&#34;要点&#34;&gt;要点&lt;/h2&gt;
&lt;p&gt;为Envoy构建控制平面并不容易，一旦您了解了工作流需要从控制平面得到什么，您就需要了解如何最好地部署它。Gloo团队建议构建一个可拔插的控制平面，并将其与数据平面分开，原因如上所述。Gloo的体系结构是这样构建的，它使&lt;a href=&#34;https://github.com/solo-io/gloo/graphs/contributor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo团队&lt;/a&gt;能够快速添加任何新特性和扩展，以支持任何平台、配置、过滤器，以及更多。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>容器、微服务和服务网格简史</title>
      <link>https://cloudnative.to/blog/containers-microservices-service-meshes/</link>
      <pubDate>Mon, 03 Jun 2019 11:20:34 +0800</pubDate>
      <guid>https://cloudnative.to/blog/containers-microservices-service-meshes/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://jpetazzo.github.io/2019/05/17/containers-microservices-service-meshes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;本文通过介绍一个构建和运行微服务的平台dotCloud的历史、容器间路由，进而阐述了它与现代服务网格的相同与不同之处；接着介绍了如何实现一个类似的服务网格以及其与Istio的区别；最后引入了SuperGloo的介绍，一个管理和编排大规模服务网格的开源项目。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;有&lt;a href=&#34;https://containerjournal.com/2018/12/12/what-is-service-mesh-and-why-do-we-need-it/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;许&lt;/a&gt;&lt;a href=&#34;https://www.nginx.com/blog/do-i-need-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;多&lt;/a&gt;&lt;a href=&#34;https://www.oreilly.com/ideas/do-you-need-a-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;的&lt;/a&gt;&lt;a href=&#34;https://www.datawire.io/envoyproxy/service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;材料&lt;/a&gt;是关于服务网格的，这是另一个。为什么呢？因为我想分享给你们一个观点：有一些人认为服务网格在10年前就已经存在，远早于Docker和Kubernetes这样的容器平台的兴起。我并不是说这个观点比其他观点更好或更差，但是由于服务网格是相当复杂的架构，所以我相信多种观点有助于更好地理解它们。&lt;/p&gt;
&lt;p&gt;我将讨论dotCloud平台，这是一个建立在100多个微服务之上的平台，支持数千个运行在容器中的应用程序；我将解释在构建和运行它时所面临的挑战；以及服务网格将如何(或不会)提供帮助。&lt;/p&gt;
&lt;h2 id=&#34;dotcloud的历史&#34;&gt;dotCloud的历史&lt;/h2&gt;
&lt;p&gt;我已经写过关于dotCloud平台的历史和它的一些设计选择，但是我没有过多讨论它的网络层。如果你不想跳进我以前的&lt;a href=&#34;http://jpetazzo.github.io/2017/02/24/from-dotcloud-to-docker/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关于dotCloud的博客&lt;/a&gt;，所有你需要知道的是，这是一个PaaS平台，它允许用户运行各种应用程序(Java、PHP、Python…)，支持广泛的数据服务(MongoDB, MySQL, Redis,…)和与Heroku类似的工作流：您将把代码推到平台上，平台将负责容器镜像的创建和部署。&lt;/p&gt;
&lt;p&gt;我将告诉您流量是如何在dotCloud平台上路由的；不是因为它是特别强大或者其它(我认为这是好的时间!)，主要是因为，如果需要一种方法在一堆微服务或应用程序之间路由通信，dotCloud的设计可以很容易地与今天的工具由一个合适的团队在很短的时间去实现。因此，它将为我们提供一个很好的比较点：“如果我们自己实现它，我们会得到什么”和“如果我们使用现有的服务网格，我们会得到什么”，也就是这个传统的困境 - “构建vs购买”。&lt;/p&gt;
&lt;h2 id=&#34;托管程序的流量路由&#34;&gt;托管程序的流量路由&lt;/h2&gt;
&lt;p&gt;部署在dotCloud上的应用程序可以公开HTTP和TCP端点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP端点&lt;/strong&gt;被动态添加到&lt;a href=&#34;https://github.com/hipache/hipache&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hipache&lt;/a&gt;集群的配置中。这与我们今天使用Kubernetes &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ingress&lt;/a&gt;资源和负载均衡器如&lt;a href=&#34;https://traefik.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik&lt;/a&gt;可以实现的功能类似。&lt;/p&gt;
&lt;p&gt;只要域名指向dotCloud的负载均衡器，客户端就可以使用它们的关联域名连接到HTTP端点。这里没有什么特别的。&lt;/p&gt;
&lt;p&gt;客户端可以使用指定的主机名(类似于gateway-X.dotcloud.com)和端口号连接到TCP端点。&lt;/p&gt;
&lt;p&gt;该主机名将解析为一个“nats”服务器集群(与&lt;a href=&#34;https://nats.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NATS&lt;/a&gt;没有任何关系)，该集群将把传入的TCP连接路由到正确的容器(或者，在有负载均衡服务的情况下，路由到正确的容器)。&lt;/p&gt;
&lt;p&gt;如果您熟悉Kubernetes，这可能会让您想起&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#NodePort&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NodePort&lt;/a&gt;服务。&lt;/p&gt;
&lt;p&gt;dotCloud平台没有与&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ClusterIP&lt;/a&gt;提供相同的服务: 为了简单起见，从平台内部和外部以相同的方式访问服务。&lt;/p&gt;
&lt;p&gt;这已经足够简单了，HTTP和TCP路由网格的最初实现可能都是几百行Python代码，使用的算法相当简单(我敢说，相当简单)，但是随着时间的推移，它们不断发展，以处理平台的增长和额外的需求。&lt;/p&gt;
&lt;p&gt;它不需要对现有程序代码进行大量重构。&lt;a href=&#34;https://12factor.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;十二因素应用程序&lt;/a&gt;尤其可以直接使用通过环境变量提供的地址信息。&lt;/p&gt;
&lt;h2 id=&#34;它与现代服务网格有何不同&#34;&gt;它与现代服务网格有何不同?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可观测性&lt;/strong&gt;是有限的。TCP路由网格没有任何度量指标。至于HTTP路由网格，后来的版本提供了详细的HTTP指标，显示错误代码和响应时间；但是现代服务网格的功能远远不止于此，它还提供了与度量收集系统(例如Prometheus)的集成。&lt;/p&gt;
&lt;p&gt;可观察性不仅从操作角度(帮助我们排除问题)来看很重要，而且对于交付诸如安全的&lt;a href=&#34;https://martinfowler.com/bliki/BlueGreenDeployment.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blue/green deployment&lt;/a&gt;或&lt;a href=&#34;https://martinfowler.com/bliki/CanaryRelease.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;canary deployment&lt;/a&gt;这样的特性也很重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路由效率&lt;/strong&gt;也受到限制。在dotCloud路由网格中，所有流量都必须经过一组专用路由节点。这意味着可能跨越几个AZ(可用性区域)边界，并显著增加延迟。我记得对一些代码做过故障排除，这些代码发出100多个SQL请求来显示给定的页面，并为每个请求打开到SQL服务器的新连接。在本地运行时，页面会立即加载，但在dotCloud上运行时，则需要几秒钟，因为每个TCP连接(以及随后的SQL请求)需要几十毫秒才能完成。在这种情况下，使用长连接就可以解决问题了。&lt;/p&gt;
&lt;p&gt;现代服务网格做得更好。首先，确保连接在源节点上被路由。逻辑流仍然是“客户端→网格→服务”，但是现在网格在本地运行，而不是在远程节点上，所以“客户端→网格”连接是本地连接，因此非常快(微秒而不是毫秒)。&lt;/p&gt;
&lt;p&gt;现代服务网格还实现了更智能的负载均衡算法。通过监控后端健康状况，它们可以在处理速度更快的后端上发送更多的流量，从而提高整体性能。&lt;/p&gt;
&lt;p&gt;现代服务网格的&lt;strong&gt;安全&lt;/strong&gt;也更强大。dotCloud路由网格完全在EC2 Classic上运行，并且没有加密流量(假设有人设法嗅探到EC2上的网络流量，那么无论如何都会遇到更大的麻烦)。现代服务网格可以透明地保护我们所有的通信，例如通过相互的TLS身份验证以及后续的加密。&lt;/p&gt;
&lt;h2 id=&#34;平台服务的流量路由&#34;&gt;平台服务的流量路由&lt;/h2&gt;
&lt;p&gt;好的，我们已经讨论了应用程序如何通信，但是dotCloud平台本身呢?&lt;/p&gt;
&lt;p&gt;平台本身由大约100个微服务组成，负责各种功能。其中一些服务接受来自其他服务的请求，而其中一些服务是后台工作服务，它们将连接到其他服务，但不能自己接收连接。无论哪种方式，每个服务都需要知道它需要连接到的地址的端点。&lt;/p&gt;
&lt;p&gt;许多高级服务都可以使用上面描述的路由网格。事实上，dotCloud平台的100多个微服务中有很大一部分是作为常规应用程序部署在dotCloud平台上的。但是，少量的底层服务(特别是实现路由网格的服务)需要一些更简单的东西，需要较少的依赖关系(因为它们不能依靠自己来运行；这是一个古老的“先有鸡还是先有蛋”的问题)。&lt;/p&gt;
&lt;p&gt;通过直接在几个关键节点上启动容器，而不是依赖于平台的构建器、调度器和运行器服务，部署了这些底层的基本平台服务。如果您想要与现代容器平台进行比较，这就像直接在节点上启动我们的控制平面，使用 &lt;code&gt;docker run&lt;/code&gt;，而不是让Kubernetes为我们做这件事。这与&lt;a href=&#34;https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubeadm&lt;/a&gt;或&lt;a href=&#34;https://github.com/kubernetes-incubator/bootkube&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bootkube&lt;/a&gt;在加载自托管集群使用&lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/static-pod/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;静态pod&lt;/a&gt;相当类似。&lt;/p&gt;
&lt;p&gt;这些服务以一种非常简单粗糙的方式对外开放：有一个YAML文件列出了这些服务，将它们的名称映射到它们的地址；这些服务的每个消费者都需要该YAML文件的副本作为其部署的一部分。&lt;/p&gt;
&lt;p&gt;一方面，这是非常健壮的，因为它不涉及像Zookeeper那样维护外部键/值对存储(请记住，etcd或Consul在当时并不存在)。另一方面，它使得服务迁移变得困难。每次移动一个服务时，它的所有消费者都需要接收一个更新的YAML文件(并可能重新启动)。不是很方便!&lt;/p&gt;
&lt;p&gt;我们最开始的解决方案是让每个消费者都连接到一个本地代理。消费者不需要知道服务的完整地址+端口，只需要知道它的端口号，并通过“localhost”连接。本地代理将处理该连接，并将其路由到实际后端。现在，当一个后端服务需要移动到另一台机器上，或按比例扩容或缩容，不再需要更新它的所有消费者，我们只需要更新所有这些本地代理；我们不再需要重新启动消费者。&lt;/p&gt;
&lt;p&gt;（还计划过将流量封装在TLS连接中，并在接收端使用另一个代理来打开TLS并验证证书，而不涉及该接收服务，该服务将被设置为只接受&lt;code&gt;localhost&lt;/code&gt;上的连接。稍后会详细介绍。)&lt;/p&gt;
&lt;p&gt;这与AirBNB的&lt;a href=&#34;https://medium.com/airbnb-engineering/smartstack-service-discovery-in-the-cloud-4b8a080de619&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SmartStack&lt;/a&gt;非常相似；与之显著不同的是，SmartStack 被实现并部署到生产环境中，而dotCloud的新内部路由网格在dotCloud转向Docker时被搁置。☺&lt;/p&gt;
&lt;p&gt;我个人认为SmartStack是诸如Istio、Linkerd、Consul Connect等系统的先驱之一，因为所有这些系统都遵循这种模式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在每个节点上运行代理&lt;/li&gt;
&lt;li&gt;消费者连接到代理&lt;/li&gt;
&lt;li&gt;控制平面在后端更改时更新代理的配置&lt;/li&gt;
&lt;li&gt;… 利润!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实现一个服务网格&#34;&gt;实现一个服务网格&lt;/h2&gt;
&lt;p&gt;如果我们今天必须实现一个类似的网格，我们可以使用类似的原则。例如，我们可以设置一个内部DNS区域，将服务名称映射到&lt;code&gt;127.0.0.0/8&lt;/code&gt;空间中的地址。然后在集群的每个节点上运行HAProxy，接受每个服务地址上的连接(在“127.0.0.0/8”子网中)，并将它们转发/负载均衡到适当的后端。HAProxy配置可以由&lt;a href=&#34;https://github.com/kelseyhightower/confd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;confd&lt;/a&gt;管理，允许在etcd或Consul中存储后端信息，并在需要时自动将更新后的配置推送到HAProxy。&lt;/p&gt;
&lt;p&gt;这几乎就是Istio的工作原理！但有一些不同之处:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Istio使用&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Proxy&lt;/a&gt;，而不是HAProxy&lt;/li&gt;
&lt;li&gt;Istio存储后端配置使用Kubernetes API，而不是etcd或Consul&lt;/li&gt;
&lt;li&gt;服务在内部子网中分配地址（Kubernetes集群 IP 地址），而不是“127.0.0.0/8”&lt;/li&gt;
&lt;li&gt;Istio有一个额外的组件（Citadel）添加客户端和服务器之间的相互TLS认证&lt;/li&gt;
&lt;li&gt;Istio增加了对新功能的支持，如断路，分布式追踪，金丝雀部署…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们快速回顾一下这些差异。&lt;/p&gt;
&lt;h3 id=&#34;envoy代理&#34;&gt;Envoy代理&lt;/h3&gt;
&lt;p&gt;Envoy代理是由Lyft撰写。它与其他代理（如HAProxy、NGINX、Traefik……）有许多相似之处，但Lyft编写它是因为它们需要当时这些代理中不存在的功能，而且构建一个新的代理比扩展现有代理更有意义。&lt;/p&gt;
&lt;p&gt;Envoy可以单独使用。如果有一个给定的服务需要连接到其他服务，可以把它连接到Envoy，然后动态地在Envoy上配置和重新配置其他服务的位置，从而得到很多额外的优雅的功能，比如可观测性。不需使用定制的客户端库，也不用在代码中对请求添加追踪，而是将流量定向到Envoy，让它来收集指标。&lt;/p&gt;
&lt;p&gt;但是Envoy也可以用作服务网格的&lt;code&gt;数据平面&lt;/code&gt;。这意味着现在将由该服务网格的&lt;code&gt;控制平面&lt;/code&gt;配置Envoy。&lt;/p&gt;
&lt;h3 id=&#34;控制平面&#34;&gt;控制平面&lt;/h3&gt;
&lt;p&gt;说到控制平面：Istio的实现依赖于Kubernetes API。&lt;em&gt;这和使用cond没有太大的不同。&lt;/em&gt; cond依赖etcd或Consul来监视数据存储中的一组键值。Istio依赖Kubernetes API来监视一组Kubernetes资源。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;旁白&lt;/em&gt; ：我个人认为阅读这篇文章&lt;a href=&#34;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md#proposal-and-motivation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes API description&lt;/a&gt;非常有帮助。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Kubernetes API服务器是一个“dumb server”，它提供对API资源的存储、版本控制、验证、更新和监视语义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Istio是为与Kubernetes合作而设计的；如果您想在Kubernetes之外使用它，则需要运行Kubernetes API服务器的实例（以及etcd服务作为支持）。&lt;/p&gt;
&lt;h3 id=&#34;服务地址&#34;&gt;服务地址&lt;/h3&gt;
&lt;p&gt;Istio依赖于Kubernetes对集群ip地址的分配，因此Istio服务获得一个内部地址（不在“127.0.0.0/8”范围内）。&lt;/p&gt;
&lt;p&gt;在没有Istio的Kubernetes集群上，前往给定服务的ClusterIP地址的流量被kube-proxy拦截，并发送到该代理的后端。更具体地说，如果您想了解技术细节：kube-proxy通过设置iptables规则（或IPVS负载均衡器，取决于它是如何设置的）来重写连接到集群IP地址的目标IP地址。&lt;/p&gt;
&lt;p&gt;Istio安装在Kubernetes集群上之后，任何变化都不会发生，直到通过将 &lt;em&gt;sidecar&lt;/em&gt; 容器注入到使用者pod中，显式地为给定的消费者甚至整个namespace启用Istio。sidecar将运行一个Envoy实例，并设置一些iptables规则来拦截到其他服务的流量，并将这些流量重定向到Envoy。&lt;/p&gt;
&lt;p&gt;结合Kubernetes DNS集成，这意味着我们的代码可以连接到一个服务名，一切都“正常工作”。换句话说，我们的代码将发出一个请求，例如&lt;code&gt;http://api/v1/users/4242&lt;/code&gt;，&lt;code&gt;api&lt;/code&gt;被解析至&lt;code&gt;10.97.105.48&lt;/code&gt;，而一个iptables规则将拦截发送给&lt;code&gt;10.97.105.48&lt;/code&gt;的连接并且重定向到他们本地Envoy代理，该代理将请求路由到实际的api的后端。唷!&lt;/p&gt;
&lt;h3 id=&#34;其它&#34;&gt;其它&lt;/h3&gt;
&lt;p&gt;Istio还可以使用名为&lt;em&gt;Citadel&lt;/em&gt;的组件，通过mTLS（双向的TLS）提供端到端加密和身份验证。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Mixer&lt;/em&gt; ，Envoy的另一个功能组件，可以查询 &lt;em&gt;每一个&lt;/em&gt; 请求，并对请求做一个ad-hoc决定，该决定取决于各种因素，例如请求头、后端负载…（别担心：有丰富的规则，以确保mixer高度可用，即使它暂时不可用，Envoy可以继续代理流量。）&lt;/p&gt;
&lt;p&gt;当然，我提到了可观察性：Envoy在提供分布式追踪的同时收集了大量的度量（metrics）。在微服务架构中，如果单个API请求必须经过微服务A、 B、 C和D，分布式追踪将在进入系统的请求添加一个惟一的标识符，并在流经这些微服务的子请求中保留该标识符，允许收集所有相关的请求调用，它们的延迟等。&lt;/p&gt;
&lt;h2 id=&#34;构建vs购买&#34;&gt;构建vs.购买&lt;/h2&gt;
&lt;p&gt;Istio以复杂著称。相比之下，使用我们今天已经拥有的工具，构建像我在本文开头描述的那样的路由网格相对比较简单。那么，构建我们自己的服务网格是否有意义呢?&lt;/p&gt;
&lt;p&gt;如果我们有适度一点的需求（比如不需要可观察性，断路器，和其他细节），我们可能想建立自己的服务网格。但是如果我们正在使用Kubernetes，我们甚至可能不需要这样做，因为Kubernetes已经提供了基本的服务发现和负载平衡。&lt;/p&gt;
&lt;p&gt;现在，如果我们有高级一点需求，“购买”服务网格可能是更好的选择。（由于Istio是开源的，所以它并不总是“购买”，但是我们仍然需要投入工程师的时间来理解它是如何工作、部署和运行的。）&lt;/p&gt;
&lt;h2 id=&#34;istio-vs-linkerd-vs-consul-connect&#34;&gt;Istio vs. Linkerd vs. Consul Connect&lt;/h2&gt;
&lt;p&gt;到目前为止，我们只讨论了Istio，但它并不是唯一的服务网格。&lt;a href=&#34;https://linkerd.io/2/overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt;是另一个流行的选择，还有&lt;a href=&#34;https://learn.hashicorp.com/consult/getting-start-k8s/l7-observability-k8s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Consul Connect&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们应该选哪一个?&lt;/p&gt;
&lt;p&gt;老实说，我也不知道，而且在这一点上，我认为自己的知识不足以帮助任何人做出这个决定。不过你可以参考这些有趣的&lt;a href=&#34;https://thenewstack.io/which-service-mesh-should-i-use/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文章&lt;/a&gt;对它们做的&lt;a href=&#34;https://medium.com/solo-io/linker-or-istio-6fcd2aad6e42&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;比较&lt;/a&gt;，甚至它们的&lt;a href=&#34;https://medium.com/@michael_87395/benchmark-istio-linker-cpu-c36287e32781&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基准测试&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;一种很有潜力的方法是使用&lt;a href=&#34;https://supergloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SuperGloo&lt;/a&gt;这样的工具。SuperGloo提供了一个抽象层来简化和统一服务网格公开的api。我们可以使用SuperGloo提供的更简单的构造，并无缝地从一个服务网格切换到另一个服务网格中，而不是学习各种服务网格的特定api（在我看来，相对复杂）。有点像我们有一个描述HTTP前端和后端的中间配置格式，能够生成NGINX、HAProxy、Traefik、Apache的实际配置…&lt;/p&gt;
&lt;p&gt;我在如何通过SuperGloo使用Istio有点涉足，在以后的博客中，我将说明如何使用SuperGloo将Istio或Linkerd添加到现有的集群，以及后者是否持有的承诺，即让我从一个路由网切换到另一个而不需要重写配置。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
