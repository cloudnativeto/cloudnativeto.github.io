<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>云原生社区（中国）</title>
    <link>https://cloudnativecn.com/translators/%E6%95%96%E5%B0%8F%E5%89%91/</link>
      <atom:link href="https://cloudnativecn.com/translators/%E6%95%96%E5%B0%8F%E5%89%91/index.xml" rel="self" type="application/rss+xml" />
    <description>云原生社区（中国）</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 04 Nov 2021 02:37:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/translators/%E6%95%96%E5%B0%8F%E5%89%91/avatar_hu_993d1b6c8f0963be.jpg</url>
      <title>云原生社区（中国）</title>
      <link>https://cloudnativecn.com/translators/%E6%95%96%E5%B0%8F%E5%89%91/</link>
    </image>
    
    <item>
      <title>Dapr（分布式应用运行时）加入 CNCF 孵化器</title>
      <link>https://cloudnativecn.com/blog/dapr-distributed-application-runtime-joins-cncf-incubator/</link>
      <pubDate>Thu, 04 Nov 2021 02:37:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/dapr-distributed-application-runtime-joins-cncf-incubator/</guid>
      <description>&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;本文英文原文发布在 CNCF 官方博客 &lt;a href=&#34;https://www.cncf.io/blog/2021/11/03/dapr-distributed-application-runtime-joins-cncf-incubator/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dapr (Distributed Application Runtime) joins CNCF Incubator&lt;/a&gt; 上，译者敖小剑，宋净超参与了审校。另外云原生社区中也成立了 &lt;a href=&#34;https://cloudnative.to/community/sig/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dapr 小组&lt;/a&gt;，欢迎各位爱好者加入。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;CNCF &lt;a href=&#34;https://github.com/cncf/toc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;技术监督委员会&lt;/a&gt;（TOC）已经投票决定接受 Dapr 作为 CNCF 的孵化项目。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dapr.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dapr&lt;/a&gt; 是一套使开发者能够轻松编写分布式应用的 API。无论是在 Kubernetes 还是其他环境中，Dapr 都是以 Sidecar 进程运行在应用程序旁边，为开发者提供了一套形式为 pub/sub、状态管理、秘密管理、事件触发器和服务间调用的安全而可靠的原语。在 Dapr 的帮助下，开发人员可以专注于构建业务逻辑而不是基础设施。&lt;/p&gt;
&lt;p&gt;Dapr 维护者和指导委员会成员 Mark Fussell 说：“我听到开发者说 Dapr 如何缩短了他们在 Kubernetes 和其他托管平台上构建可扩展的分布式应用的时间，并解决了他们的业务需求，这对我产生了巨大的鼓舞。现在，随着 Dapr 成为 CNCF 的一部分，开发人员能够更容易地构建、使用和采纳云原生技术。”&lt;/p&gt;
&lt;p&gt;该项目于 2019 年在微软创建。随着时间的推移，许多社区成员加入该项目并做出贡献，扩展并帮助它在 2021 年 2 月达到了稳定的 1.0 版本。今天，Dapr 技术指导委员会管理该项目，其代表来自阿里巴巴、英特尔和微软。&lt;/p&gt;
&lt;p&gt;Dapr 维护者和指导委员会成员 Yaron Schneider 说：“我最自豪的是日益壮大的 Dapr 社区为项目贡献了新的 API 和构建块。我们在项目的 20 多个仓库中都有贡献，从我们的开发者工具和 SDK 到运行时本身。看到开发者来到这个项目并提出新的 API，帮助解决分布式系统的挑战，这是 Dapr 社区的重要成就。”&lt;/p&gt;
&lt;p&gt;Dapr 和多个 CNCF 项目集成。例如，使用 gRPC 进行内部 sidecar 通信，为 ACL 创建 SPIFFIE 身份，以 OpenTelemetry 格式发出遥测数据，使用 Prometheus 进行指标收集，利用 CloudEvents 作为 pub/sub 消息格式，并使用 Operator 在 Kubernetes 上原生运行。&lt;/p&gt;
&lt;p&gt;该项目被阿里云、Legentic、Tdcare、腾讯、Swoop Funding、Man Group、Zeiss &lt;a href=&#34;https://github.com/dapr/community/blob/master/ADOPTERS.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;等组织&lt;/a&gt;在生产中使用。采用者在所有主流云供应商以及企业内部环境上运行 Dapr。&lt;/p&gt;
&lt;p&gt;前阿里巴巴云的资深技术专家李响说：“在阿里云，我们相信 Dapr 将引领微服务开发的方向。通过采用 Dapr，我们的客户可以更快地建立可移植的、强大的分布式系统。”&lt;/p&gt;
&lt;p&gt;Ignition 集团的首席数字化转型官 Russell Stather 说：“使用 Dapr 可以在不改变其他任何东西的情况下轻易的引入新的基础设施。它改变了我们的业务。”&lt;/p&gt;
&lt;p&gt;蔡司的首席架构师 Kai Walter 说：“在我们的多云环境中，Dapr 给了我们需要的灵活性。它提供了一个抽象层，使开发人员能够专注于手头的业务案例。”&lt;/p&gt;
&lt;p&gt;主要组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dapr sidecar&lt;/strong&gt;：在应用程序旁边运行，包含面向开发者的 API。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CLI 和 SDK&lt;/strong&gt;：构成项目的开发者工具体验。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Components-contrib 仓库&lt;/strong&gt;：开发者可以扩展 Dapr，以集成和支持各种云服务和开源技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;显著的里程碑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;15100 个 GitHub Star&lt;/li&gt;
&lt;li&gt;1940 个 Pull Request&lt;/li&gt;
&lt;li&gt;3703 个问题&lt;/li&gt;
&lt;li&gt;1300 个贡献者&lt;/li&gt;
&lt;li&gt;14 次发布，目前稳定版 v1.4&lt;/li&gt;
&lt;li&gt;2600 万次 Docker 拉取&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CNCF 首席技术官 Chris Aniszczyk 说：“分布式应用和微服务构成了容器和云原生的基础，但编写可扩展和可靠的分布式应用是非常困难的。Dapr 与其他 CNCF 项目集成的很好，并提供最佳实践，开发人员可以使用任何语言或框架在上面构建。我们很高兴欢迎 Dapr 加入 CNCF 并努力培养他们的社区。”&lt;/p&gt;
&lt;p&gt;Dapr 项目的路线图包括增加新的配置 API，使开发者更容易管理其应用程序的配置，并在配置发生变化时得到通知；以及一个查询 API，使开发者更容易查询和过滤 Dapr 状态存储数据。此外，该项目正在寻求增加对基于 gRPC 和 WASM 的组件的支持，这将支持状态存储、pub/sub broker、binding 和其他 Dapr 组件的动态发现。最后，Dapr 社区还在讨论新的并发性 API，以解锁领导者选举等场景。&lt;/p&gt;
&lt;p&gt;作为由 CNCF 托管的项目，Dapr 是与其技术利益相一致的中立基金会的一部分，也是更大的 Linux 基金会的一部分，后者提供管理、营销支持和社区推广。Dapr 加入了孵化技术的行列：Argo, Buildpacks, Cilium, CloudEvents, CNI, Contour, Cortex, CRI-O, Crossplane, Dragonfly, emissary-ingress, Falco, Flagger, Flux, gRPC, KEDA, KubeEdge, Longhorn, NATS, Notary, OpenTelemetry, Operator Framework, SPIFFE, SPIRE, 和 Thanos。关于每个级别的成熟度要求，请访问 &lt;a href=&#34;https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 的毕业标准&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 AWS App Mesh 重新定义应用通讯</title>
      <link>https://cloudnativecn.com/blog/redefining-application-communications-with-aws-app-mesh/</link>
      <pubDate>Wed, 03 Apr 2019 20:14:43 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/redefining-application-communications-with-aws-app-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://www.allthingsdistributed.com/2019/03/redefining-application-communications-with-aws-app-mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;原文发表于 2019 年 3 月 27 日。&lt;/p&gt;
&lt;p&gt;在 re:Invent 2018，AWS 宣布了 AWS App Mesh 的公开预览版，App Mesh 是一个服务网格，可以轻松监视和控制跨应用的通信。今天，我很高兴地宣布 App Mesh 已经可以为用户提供使用了（GA）。&lt;/p&gt;
&lt;h2 id=&#34;新的架构模式&#34;&gt;新的架构模式&lt;/h2&gt;
&lt;p&gt;许多客户正在对现有应用进行现代化改造，以求更快更灵活地进行创新。微服务等架构模式使团队能够独立测试服务并不断持续发布应用变更。这种方式可以让开发团队更快地进行实验和迭代，从而提高团队生产力。它还可以让团队快速扩展他们构建和运行应用的方式。&lt;/p&gt;
&lt;p&gt;当构建所有需要以一个应用的形式一起工作的新服务时，他们需要一种方式来在整个应用间连接，监控，控制和调试通信。此类功能的示例包括服务发现，应用级度量和日志，帮助调试流量模式的跟踪，流量整形以及保护服务之间通信的能力。&lt;/p&gt;
&lt;p&gt;通常需要在 SDK 中构建通信管理逻辑，并要求每个开发团队使用它。但是，随着应用的增长和团队数量的增加，跨服务一致地提供这些功能会变得复杂而耗时。&lt;/p&gt;
&lt;p&gt;我们的目标是自动化和抽象通信基础设施，以支撑每个现代应用程序，使团队能够专注于构建业务逻辑并更快地进行创新。&lt;/p&gt;
&lt;h2 id=&#34;重新定义网络&#34;&gt;重新定义网络&lt;/h2&gt;
&lt;p&gt;从历史上看，当您必须为应用搭建服务时，首先要做的就是搭建网络，即虚拟私有云（virtual private cloud/VPC）。一切都发生在 VPC 的环境下。我们的目标是，只要您在 AWS 上运行应用，就不必担心管理网络基础设施。它应该由我们的应用感知网络来处理。我们的网络可自动将您对服务需求的输入转换为基础设施所需的配置并管理其生命周期。今天的 App Mesh，是这个旅程的第一步。&lt;/p&gt;
&lt;h2 id=&#34;app-mesh-愿景&#34;&gt;App Mesh 愿景&lt;/h2&gt;
&lt;p&gt;如果您正在运行由不同团队管理的多个服务，每个团队理想地仅根据其自身服务的特定需求提供输入。他们无需了解为其服务提供支持的基础设施的详细信息。&lt;/p&gt;
&lt;p&gt;与我交谈的开发人员并不关心每个应用的连接。他们关心的问题包括，我的服务可以与谁通信？我可以访问哪些 AWS 资源？我如何处理错误和重试？在接受所有流量之前，如何连接和测试新的服务版本？我需要什么身份和授权才能建立连接或接受连接？这是 App Mesh 尝试做的事情。&lt;/p&gt;
&lt;p&gt;App Mesh 提供简单的声明式方式来建模服务通信。可以定义服务到服务通信的规则，而其他所有内容将会自动处理。将其用作应用中所有服务间通信的控制单点。&lt;/p&gt;
&lt;p&gt;它提供一致的指标，日志和跟踪，并提供跨应用的端到端可见性，以帮助快速识别和调试问题。App Mesh 提供流量路由控制，以支持测试和部署服务的新版本。&lt;/p&gt;
&lt;p&gt;我们对 App Mesh 的愿景是一个 AWS 原生服务网格，与 AWS 原语和高级服务完全集成。包括网络原语和高级服务（类似 AWS Cloud Map 的），计算原语（类似 Amazon EC2 和 AWS Fargate），以及编排工具（包括 AWS EKS，Amazon ECS 和 EC2 上的客户管理的 Kubernetes）。通过 App Mesh 本地集成到 AWS Cloud Map，服务网格中的任何服务都会获得到帐户中每个其他 AWS 资源的映射。&lt;/p&gt;
&lt;h2 id=&#34;app-mesh-如何运作&#34;&gt;App Mesh 如何运作？&lt;/h2&gt;
&lt;p&gt;App Mesh 并行运行并管理部署的每一个微服务的通信，为整个应用形成服务网格。App Mesh 提供 AWS 托管的控制平面，您可以使用该平面为服务建模，并提供识别服务实例的声明式配置和每个服务所需的策略。&lt;/p&gt;
&lt;p&gt;App Mesh 与一个名为 Envoy 的开源高性能网络代理一起工作，该代理作为应用的 Sidecar 运行。它被认为是管理分布式应用网络流量的标准。最重要的是，我们使用 Envoy 是因为我们的许多客户已经在使用它，这使得 App Mesh 的采用变得非常简单。如果您已经在运行基于 Envoy 的服务网格，那么采用 App Mesh 只需要几个基本步骤。&lt;/p&gt;
&lt;p&gt;要开始使用，请使用 App Mesh 控制台，API 或 AWS SDK 来配置服务网格并控制服务之间的流量。接下来，将 Envoy 添加到 EC2 实例，ECS 或 Fargate 任务，或者为部署的每个服务添加 Amazon EKS 或 Kubernetes pod 定义。&lt;/p&gt;
&lt;p&gt;App Mesh 根据提供者服务中设置的策略，计算和分发所需的配置到和每个服务一起部署的代理。App Mesh 数据平面是 App Mesh 控制平面配置的代理集合，用于处理服务的所有传入和传出流量。&lt;/p&gt;
&lt;p&gt;使用 App Mesh，可以轻松导出服务指标，如延迟，错误率，错误代码，服务通信跟踪和服务级别日志。可以将指标发送到多个 AWS 和第三方工具，包括 Amazon CloudWatch，AWS X-Ray 或与 Envoy 集成的任何第三方监控和跟踪工具。&lt;/p&gt;
&lt;p&gt;现在，通过 App Mesh，您可以用加权方式在服务之间路由流量，这样可以轻松实现安全而一致地部署服务。将来，您将能够以一致的方式配置新的流量路由功能，如重试，超时，断电和服务器端限速。&lt;/p&gt;
&lt;h2 id=&#34;app-mesh-是如何构建的&#34;&gt;App Mesh 是如何构建的？&lt;/h2&gt;
&lt;p&gt;App Mesh 致力于提供高度可扩展而灵活的服务网络，支持任何客户工作负载，这些工作负载可以有数十个到数百个不同服务。我们以同样的高标准来构建 App Mesh 的运维可用性，可扩展性和安全性，我们认为这是所有 AWS 服务的关键原则。&lt;/p&gt;
&lt;p&gt;我们的目标是消除运维复杂应用的无差别繁重工作。我们提供工具，服务和可观测性，以确保您可以为自己的架构维护高标准。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-app-mesh&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;APP mesh&#34; srcset=&#34;
               /blog/redefining-application-communications-with-aws-app-mesh/006tKfTcly1g1ppp5q23aj30oz0dnwgb_hu_272c2f319203ebf9.webp 400w,
               /blog/redefining-application-communications-with-aws-app-mesh/006tKfTcly1g1ppp5q23aj30oz0dnwgb_hu_ca81a334954c5a2f.webp 760w,
               /blog/redefining-application-communications-with-aws-app-mesh/006tKfTcly1g1ppp5q23aj30oz0dnwgb_hu_5a112bc3ea15db66.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/redefining-application-communications-with-aws-app-mesh/006tKfTcly1g1ppp5q23aj30oz0dnwgb_hu_272c2f319203ebf9.webp&#34;
               width=&#34;760&#34;
               height=&#34;415&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      APP mesh
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;App Mesh 支持服务运行于 EKS，ECS，Fargate，EC2 和 EC2 上的 Kubernetes。一些客户已经在 AWS 内的托管平台上运行他们的应用。但是，我们了解许多客户需要能够将跨 AWS 部署的服务连接到单个网格中。他们可能还需要灵活地在异构的计算资源集合中运行服务。&lt;/p&gt;
&lt;p&gt;App Mesh 允许跨不同计算环境中的服务运行网格，并提供迁移路径以允许根据需要使用计算资源。它在不同的计算环境中提供一致的可观测性和路由控制。我们希望简化，使连接到网络的任何应用成为网格数据平面中的参与者。&lt;/p&gt;
&lt;p&gt;在您的应用通过服务网络进行通信之后，下一个目标是提供明确的所有权和受控的服务资源变更。App Mesh API 旨在为服务提供所有权边界，以及实现它们的网络组件。从拥有整个服务网格的小型团队到拥有许多不同团队的大型公司，App Mesh 可以对服务网格数据平面上的组件进行安全的事务性更改。&lt;/p&gt;
&lt;p&gt;例如，服务所有者可以为应用定义流量策略，App Mesh 会自动将这些策略分发给适当的消费者。通过与其他 AWS 产品（如 Amazon CloudWatch Logs，Amazon CloudWatch metrics 和 AWS X-Ray）的集成，我们提供了实现网格应用安全部署和运维所需的可观测性工具。&lt;/p&gt;
&lt;h2 id=&#34;采用-app-mesh-的合作伙伴&#34;&gt;采用 App Mesh 的合作伙伴&lt;/h2&gt;
&lt;p&gt;我们的合作伙伴生态系统一直与 AWS 密切合作，将产品与 App Mesh 集成，并为您提供可观测性，服务发现和安全性的工具。这些伙伴包括：&lt;/p&gt;
&lt;p&gt;Alcide、Aqua、Datadog、Hashicorp、Neuvector、SignalFx、Solarwinds、SpotInst、Sysdig、Tetrate、Twistlock、VMWare、Wavefront 和 Weaveworks。&lt;/p&gt;
&lt;h2 id=&#34;开始使用-app-mesh&#34;&gt;开始使用 App Mesh&lt;/h2&gt;
&lt;p&gt;从今天开始，您可以将 App Mesh 与管理的服务一起使用，这些服务由 ECS，EKS，Fargate 以及在 EC2 上运行的 AWS 上的任何 Kubernetes 部署管理。您甚至可以将它与直接在 EC2 上运行的应用程序一起使用。&lt;/p&gt;
&lt;p&gt;我们将 GA 视为起点，而不是终点。我们希望为您提供与我们一起构建的机会，很快我们将启动 AWS App Mesh Beta Channel。它是一个新的公共服务端点，允许您在新服务功能 GA 之前试用新的服务功能并提供反馈。此新服务端点将与标准生产端点分开。它将与 AWS CLI for App Mesh 的预览版本相结合，允许您在不影响其当前生产基础设施的情况下测试新功能。&lt;/p&gt;
&lt;p&gt;要了解更多信息，请参阅 &lt;a href=&#34;https://www.allthingsdistributed.com/2019/03/redefining-application-communications-with-aws-app-mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS App Mesh&lt;/a&gt; 详情页面。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh 中的通用数据平面 API 设计</title>
      <link>https://cloudnativecn.com/blog/the-universal-data-plane-api/</link>
      <pubDate>Thu, 21 Jun 2018 16:11:03 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/the-universal-data-plane-api/</guid>
      <description>&lt;p&gt;正如我之前所说的，在如此短的时间内，&lt;a href=&#34;https://lyft.github.io/envoy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 带来的兴奋既神奇又震撼人心。我经常问自己：envoy 的哪些方面导致了我们所看到的异常的社区增长？虽然 Envoy 具有很多引人注目的特征，但最终我认为有三个主要特征在共同推动：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;性能&lt;/strong&gt;：在具备大量特性的同时，Envoy 提供极高的吞吐量和低尾部延迟差异，而 CPU 和 RAM 消耗却相对较少。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：Envoy 在 L4 和 L7 都提供了丰富的可插拔过滤器能力，使用户可以轻松添加 开源版本中没有的功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API 可配置性&lt;/strong&gt;：或许最重要的是，Envoy 提供了一组可以通过控制平面服务实现的&lt;a href=&#34;https://lyft.github.io/envoy/docs/intro/arch_overview/dynamic_configuration.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;管理 API&lt;/a&gt; 。如果控制平面实现所有的 API，则可以使用通用引导配置在整个基础架构上运行 Envoy。所有进一步的配置更改通过管理服务器以无缝方式动态传送，因此 Envoy 从不需要重新启动。这使得 Envoy 成为通用数据平面，当它与一个足够复杂的控制平面相结合时，会极大的降低整体运维的复杂性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有代理具备超高性能。也有代理具备高度的可扩展性和动态可配置性。在我看来，性能、可扩展性和动态可配置性的&lt;em&gt;结合&lt;/em&gt; 才使得 Envoy 如此的引人注目。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我将概述 Envoy 动态配置 API 背后的历史和动机，讨论从 v1 到 v2 的演变，最后，鼓励更多的负载均衡，代理和控制平面社区来考虑在其产品中支持这些 API。&lt;/p&gt;
&lt;h2 id=&#34;envoy-api-v1-的历史&#34;&gt;Envoy API v1 的历史&lt;/h2&gt;
&lt;p&gt;Envoy 最初的设计目标之一是实现&lt;a href=&#34;https://lyft.github.io/envoy/docs/intro/arch_overview/service_discovery.html#on-eventually-consistent-service-discovery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最终一致的服务发现&lt;/a&gt;系统。为此，我们开发了一个非常简单的&lt;a href=&#34;https://github.com/lyft/discovery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;发现服务&lt;/a&gt;和 &lt;a href=&#34;https://lyft.github.io/envoy/docs/configuration/cluster_manager/sds_api.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Discovery Service (SDS) REST API&lt;/a&gt;，用来返回上游集群成员。该 API 克服了基于 DNS 的服务发现的一些限制（记录限制、缺少额外元数据等），并使我们能够快速实现高可靠性。&lt;/p&gt;
&lt;p&gt;Envoy 开源初期，我们收到了很多关于支持其他服务发现系统的要求，如 Consul、Kubernetes、Marathon、DNS SRV 等。我担心我们对这些系统直接支持的缺失会限制 Envoy 的使用范围而不被人所接纳。添加新的发现适配器的代码编写并不困难，我希望有关方面能够实施新的适配器。而过去一年实际发生是什么？没有一个新的适配器被贡献到代码中，但我们看到了令人难以置信的接受度。为什么？&lt;/p&gt;
&lt;p&gt;事实证明，几乎每个人都以自己的方式来实现 SDS API。API 本身是微不足道的，但我不认为这是人们实现它的唯一原因。另一个原因是，离数据平面越远，事情自然就会开始变得更牢固。Envoy 的消费者通常希望最终服务发现能够集成到特定的工作流程中。API 的简单性使得其可以轻松集成到几乎任何控制平面系统中。甚至像 Consul 系统的用户（参见示例 &lt;a href=&#34;https://verizon.github.io/nelson/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nelson&lt;/a&gt;）也发现中间 API 可以对成员和命名做更智能的处理。因此，即使在如此早期的阶段，我们也看到了对&lt;em&gt;通用数据平面 API&lt;/em&gt; 的渴望：一个简单的 API，从控制平面中抽象出数据平面。&lt;/p&gt;
&lt;p&gt;在过去的一年中，Envoy 添加了多个 v1/REST 管理 API。他们包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://lyft.github.io/envoy/docs/configuration/cluster_manager/cds.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;集群发现服务（CDS）&lt;/a&gt;：使用此 API，Envoy 可以动态地添加/更新/删除所有上游集群（每个集群本身都有自己的服务/端点发现）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lyft.github.io/envoy/docs/configuration/http_conn_man/rds.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;路由发现服务（RDS）&lt;/a&gt;：使用此 API，Envoy 可以动态地添加/更新 HTTP 路由表。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lyft.github.io/envoy/docs/configuration/listeners/lds.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;监听器发现服务（LDS）&lt;/a&gt;：使用此 API，Envoy 可以动态地添加/更新/删除全体监听器，包括其完整的 L4 和 L7 过滤器堆栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当控制平面实现 SDS/CDS/RDS/LDS 时，几乎 Envoy 的所有方面都可以在运行时动态配置。&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt; 和 &lt;a href=&#34;https://verizon.github.io/nelson/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nelson&lt;/a&gt; 都是控制平面的例子，他们在 V1 API 上构建，具备极其丰富的功能。通过使用相对简单的 REST API，Envoy 可以快速迭代性能和数据平面功能，同时仍支持各种不同的控制平面方案。此时，通用数据平面概念正成为现实。&lt;/p&gt;
&lt;h2 id=&#34;v1-api-的缺点和-v2-的引入&#34;&gt;v1 API 的缺点和 v2 的引入&lt;/h2&gt;
&lt;p&gt;v1 API 仅使用 JSON/REST，本质上是轮询。这有几个缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽管 Envoy 在内部使用的是 JSON 模式，但 API 本身并不是强类型，而且安全实现它们的通用服务器也很难。&lt;/li&gt;
&lt;li&gt;虽然轮询工作在实践中是很正常的用法，但更强大的控制平面更喜欢 streaming API，当其就绪后，可以将更新推送给每个 Envoy。这可以将更新传播时间从 30-60 秒降低到 250-500 毫秒，即使在极其庞大的部署中也是如此。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在过去几个月与 Google 的紧密合作中，我们一直在努力研究一组我们称之为 v2 的新 API。v2 API 具有以下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新的 API 模式使用 &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3&lt;/a&gt; 指定，并同时以 gRPC 和 REST + JSON/YAML 端点实现。另外，它们被定义在一个名为 &lt;a href=&#34;https://github.com/lyft/envoy-api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;envoy-api&lt;/a&gt; 的新的专用源代码仓库中。proto3 的使用意味着这些 API 是强类型的，同时仍然通过 proto3 的 JSON/YAML 表示来支持 JSON/YAML 变体。专用存储仓库的使用意味着项目可以更容易的使用 API 并用 gRPC 支持的所有语言生成存根（实际上，对于希望使用它的用户，我们将继续支持基于 REST 的 JSON/YAML 变体）。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：&lt;a href=&#34;https://github.com/lyft/envoy-api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;envoy-api&lt;/a&gt; 仓库在 Envoy 加入 CNCF 后改为 &lt;a href=&#34;https://github.com/envoyproxy/data-plane-api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;envoyproxy/data-plane-api&lt;/a&gt; 仓库，问题后面有提到。&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;v2 API 是 v1 的演进，而不是革命，它是 v1 功能的超集。v1 用户会发现 v2 非常接近他们已经在使用的 API。实际上，我们一直以可以继续永久支持 v1（尽管是最终被冻结的功能集）的方式在 Envoy 中实现 v2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不透明的元数据已被添加到各种 API 响应中，这将极大的增强可扩展性。例如，HTTP 路由中的元数据，附加到上游端点和自定义负载均衡器的元数据，以用来构建站点特有的基于标签的路由。我们的目标是可以在默认的 OSS 发行版之上&lt;a href=&#34;https://github.com/lyft/envoy-filter-example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;轻松插入丰富的功能&lt;/a&gt;。未来将有更强大的关于编写 Envoy 扩展的文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于使用 v2 gRPC（vs. JSON/REST）的 API 消费者，双向流会有一些有趣的增强，我将在下面进行更多讨论。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;v2 API 由以下部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Endpoint Discovery Service (EDS)：这是 v1 SDS API 的替代品。SDS 是一个不幸的名字选择，所以我们正在 v2 中修复这个问题。此外，gRPC 的双向流性质将允许将负载/健康信息报告回管理服务器，为将来的全局负载均衡功能开启大门。&lt;/li&gt;
&lt;li&gt;Cluster Discovery Service (CDS)：和 v1 没有实质性变化。&lt;/li&gt;
&lt;li&gt;Route Discovery Service (RDS)：和 v1 没有实质性变化。&lt;/li&gt;
&lt;li&gt;Listener Discovery Service (LDS)：和 v1 的唯一主要变化是：我们现在允许监听器定义多个并发过滤栈，这些过滤栈可以基于一组监听器路由规则（例如，SNI，源/目的地 IP 匹配等）来选择。这是处理“原始目的地”策略路由的更简洁的方式，这种路由是透明数据平面解决方案（如 Istio）所需要的。&lt;/li&gt;
&lt;li&gt;Health Discovery Service (HDS)：该 API 将允许 Envoy 成为分布式健康检查网络的成员。中央健康检查服务可以使用一组 Envoy 作为健康检查终点并将状态报告回来，从而缓解 N²健康检查问题，这个问题指的是其间的每个 Envoy 都可能需要对每个其他 Envoy 进行健康检查。&lt;/li&gt;
&lt;li&gt;Aggregated Discovery Service (ADS)：总的来说，Envoy 的设计是最终一致的。这意味着默认情况下，每个管理 API 都并发运行，并且不会相互交互。在某些情况下，一次一个管理服务器处理单个 Envoy 的所有更新是有益的（例如，如果需要对更新进行排序以避免流量下降）。此 API 允许通过单个管理服务器的单个 gRPC 双向流对所有其他 API 进行编组，从而实现确定性排序。&lt;/li&gt;
&lt;li&gt;Key Discovery Service (KDS)：该 API 尚未定义，但我们将添加一个专用的 API 来传递 TLS 密钥材料。这将解耦通过 LDS/CDS 发送主要监听器、集群配置和通过专用密钥管理系统发送秘钥素材。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：目前 xds 中没有 kds 的定义，但是有一个 Secret Discovery Service，应该是这个 kds 的改名。以上 API 请参考 &lt;a href=&#34;https://github.com/envoyproxy/data-plane-api/tree/master/envoy/api/v2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/envoyproxy/data-plane-api/tree/master/envoy/api/v2&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;总的来说，我们称所有上述 API 为 &lt;code&gt;xDS&lt;/code&gt;。从 JSON/REST 到 proto3 API 的过渡非常令人兴奋，良好类型的 proto3 API 可以更容易使用，我认为这将进一步提高 API 本身以及 Envoy 的接受度。&lt;/p&gt;
&lt;h2 id=&#34;多代理多控制平面的-api&#34;&gt;多代理多控制平面的 API？&lt;/h2&gt;
&lt;p&gt;服务网格/负载均衡领域现在非常活跃。代理包括 Envoy、&lt;a href=&#34;https://linkerd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt;、&lt;a href=&#34;https://www.nginx.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NGINX&lt;/a&gt;、&lt;a href=&#34;https://www.haproxy.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HAProxy&lt;/a&gt;、&lt;a href=&#34;https://traefik.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik&lt;/a&gt;，来自所有主要云提供商的软件负载均衡器，以及传统硬件供应商（如 F5 和思科）的物理设备。随着众多解决方案的出现，如 &lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;、&lt;a href=&#34;https://verizon.github.io/nelson/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nelson&lt;/a&gt;，集成云解决方案以及许多供应商即将推出的产品等，控制平面领域也在不断升温。&lt;/p&gt;
&lt;p&gt;特别讨论一下 Istio，Linkerd 已经宣布对它的支持，这意味着至少在某种程度上它已经实现了 v1 Envoy API。其他人可能会跟随。在这个数据平面和控制平面快速发展的新世界中，我们将看到组件的混合和匹配；数据平面将与许多控制平面一起工作，反之亦然。我们是否可以让业界受益于一种通用 API，让这种混合和匹配更容易实现？这会有什么帮助？&lt;/p&gt;
&lt;p&gt;在我看来，在接下来的几年中，数据平面本身将大部分商品化。大部分创新（和商业机会扩展）实际上将成为控制平面的一部分。使用 v2 Envoy API，控制平面功能的范围可以会从使用 N² 健康检查的扁平端点命名空间扩展到一个非常丰富的全局负载均衡系统，该系统可进行自动构造子集、负载装卸和均衡、分布式局部健康检查、区域感知路由、基于百分比的自动部署和回滚等。供应商将在提供无缝的微服务运维环境方面展开竞争，而对路由的自动化控制将是其竞争中的主要部分。&lt;/p&gt;
&lt;p&gt;在这个新的世界中，数据平台可以用来与控制平面进行通讯的通用 API 对每个参与者都是一个胜利。控制平面提供商可以将它们的服务提供给实现该 API 的任何数据平面。数据平面可以在功能，性能，规模和健壮性方面展开竞争。此外，解耦允许控制平面提供商提供 SaaS 解决方案，而不需要同时拥有数据平面部署，这是一个主要的痛点。&lt;/p&gt;
&lt;h2 id=&#34;envoy-api-合作邀请&#34;&gt;Envoy API 合作邀请&lt;/h2&gt;
&lt;p&gt;虽然很难知道未来几年会发生什么，但我们对 Envoy 及其相关 API 的采用感到非常兴奋。我们看到了通用的数据平面 API 的价值所在：可以桥接不同系统。根据这些原则，我们邀请更大的数据平面和控制平面供应商以及用户与我们在 &lt;a href=&#34;https://github.com/envoyproxy/data-plane-api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;envoy-api&lt;/em&gt;&lt;/a&gt; 存储仓库中进行协作（请注意，当 Envoy 进入 CNCF 并转换到专用的 envoyproxy GitHub 组织时，我们将重命名该存储仓库为 data-plane-api）。我们不保证我们将添加所有可能的功能，但我们希望看到其他系统使用这些 API 并帮助我们改进它们以满足他们自己的需求。我们的观点是，数据平面的商品化将为最终用户带来巨大收益，这有助于控制平面领域提高迭代和竞争速度，未来几年大部分创新将会发生在控制平面。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;英文原文发布于 2017 年 9 月 6 日，本文发出时 Envoy 已经进入了 CNCF，成为了官方项目，Envoy 原来的代码都已经被重构和迁移，本文中提到的很多链接都已过时，请大家参考 Envoy 官网 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.envoyproxy.io/&lt;/a&gt;，也可以查看 Envoy 官方文档中文版 &lt;a href=&#34;https://servicemesher.github.io/envoy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://servicemesher.github.io/envoy/&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
