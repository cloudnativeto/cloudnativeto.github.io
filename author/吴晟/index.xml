<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>吴晟 | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/author/%E5%90%B4%E6%99%9F/</link>
      <atom:link href="https://cloudnativecn.com/author/%E5%90%B4%E6%99%9F/index.xml" rel="self" type="application/rss+xml" />
    <description>吴晟</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 14 May 2024 11:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/author/%E5%90%B4%E6%99%9F/avatar_hu4764425456967452008.jpg</url>
      <title>吴晟</title>
      <link>https://cloudnativecn.com/author/%E5%90%B4%E6%99%9F/</link>
    </image>
    
    <item>
      <title>SkyWalking 10 发布：服务层次结构、基于 eBPF 的 Kubernetes 网络监控、BanyanDB 等</title>
      <link>https://cloudnativecn.com/blog/skywalking-10-release/</link>
      <pubDate>Tue, 14 May 2024 11:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/skywalking-10-release/</guid>
      <description>&lt;p&gt;Apache SkyWalking 团队今天宣布发布 SkyWalking 10。SkyWalking 10 提供了一系列突破性的功能和增强功能。Layer 和 Service Hierarchy 的引入通过将服务和指标组织成不同的层次，并提供跨层无缝导航，从而简化了监控。利用 eBPF 技术，Kubernetes 网络监控提供了对网络流量、拓扑和 TCP/HTTP 指标的详细洞察。BanyanDB 作为高性能的原生存储解决方案出现，同时扩展的监控支持包括 Apache RocketMQ、ClickHouse 和 Apache ActiveMQ Classic。对多标签名称的支持增强了指标分析的灵活性，而增强的导出和查询功能简化了数据分发和处理。&lt;/p&gt;
&lt;p&gt;本文简要介绍了这些新功能和增强功能以及其他一些值得注意的变化。&lt;/p&gt;
&lt;h2 id=&#34;layer-和-service-hierarchy&#34;&gt;Layer 和 Service Hierarchy&lt;/h2&gt;
&lt;p&gt;Layer 概念是在 SkyWalking 9.0.0 中引入的，它代表计算机科学中的一个抽象框架，例如操作系统（OS_LINUX layer）、Kubernetes（k8s layer）。它根据系统中服务和指标的角色和职责将其组织到不同的层次。SkyWalking 为每个层提供了一套监控和诊断工具，但层之间存在 gap，无法轻松跨层桥接数据。&lt;/p&gt;
&lt;p&gt;在 SkyWalking 10 中，SkyWalking 提供了跨层跳转/连接的新功能，为用户提供无缝的监控体验。&lt;/p&gt;
&lt;h3 id=&#34;layer-jump&#34;&gt;Layer Jump&lt;/h3&gt;
&lt;p&gt;在拓扑图中，用户可以点击服务节点跳转到另一层服务的仪表板。下图显示了通过点击拓扑节点从 GENERAL 层服务拓扑跳转到 VIRTUAL_DATABASE 服务层仪表板的过程。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1-layer-jump&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1: Layer Jump&#34; srcset=&#34;
               /blog/skywalking-10-release/layer_jump_hu10142577769154495990.webp 400w,
               /blog/skywalking-10-release/layer_jump_hu4601478764814933129.webp 760w,
               /blog/skywalking-10-release/layer_jump_hu1143009278059272433.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/skywalking-10-release/layer_jump_hu10142577769154495990.webp&#34;
               width=&#34;760&#34;
               height=&#34;382&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1: Layer Jump
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2-layer-jump-dashboard&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 2: Layer jump Dashboard&#34; srcset=&#34;
               /blog/skywalking-10-release/layer_jump2_hu11703627951284172173.webp 400w,
               /blog/skywalking-10-release/layer_jump2_hu17778451633452738051.webp 760w,
               /blog/skywalking-10-release/layer_jump2_hu9431654776986396508.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/skywalking-10-release/layer_jump2_hu11703627951284172173.webp&#34;
               width=&#34;760&#34;
               height=&#34;259&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2: Layer jump Dashboard
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;service-hierarchy&#34;&gt;Service Hierarchy&lt;/h3&gt;
&lt;p&gt;SkyWalking 10 引入了一个新概念，称为 Service Hierarchy，它定义了各层中现有逻辑相同服务的关系。OAP 将检测不同层次的服务，并尝试建立连接。用户可以点击任何层的服务拓扑节点或服务仪表板中的 Hierarchy Services 获取 Hierarchy Topology。在此拓扑图中，用户可以看到不同层次服务之间的关系和指标摘要，并且可以跳转到该层的服务仪表板。当服务发生性能问题时，用户可以轻松分析不同层次的指标并找出根本原因：&lt;/p&gt;
&lt;p&gt;以下是 Service Hierarchy 关系的示例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用程序 &lt;code&gt;song&lt;/code&gt; 同时在 Kubernetes 集群中部署了 SkyWalking agent 和 Service Mesh。因此，应用程序 &lt;code&gt;song&lt;/code&gt; 跨越了 GENERAL、MESH、MESH_DP 和 K8S_SERVICE 层，SkyWalking 可以监控这些层次，Service Hierarchy 拓扑如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-3-service-hierarchy-agent-with-k8s-service-and-mesh-with-k8s-service&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 3: Service Hierarchy Agent With K8s Service And Mesh With K8s Service&#34; srcset=&#34;
               /blog/skywalking-10-release/song_hu17989075818403223189.webp 400w,
               /blog/skywalking-10-release/song_hu15999669808595071985.webp 760w,
               /blog/skywalking-10-release/song_hu11492588395586370092.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/skywalking-10-release/song_hu17989075818403223189.webp&#34;
               width=&#34;760&#34;
               height=&#34;457&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3: Service Hierarchy Agent With K8s Service And Mesh With K8s Service
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;还可以有 Service Instance Hierarchy 拓扑来获取跨层的单实例状态，如下所示：    















&lt;figure  id=&#34;figure-图-4-instance-hierarchy-agent-with-k8s-servicepod&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 4: Instance Hierarchy Agent With K8s Service(Pod)&#34; srcset=&#34;
               /blog/skywalking-10-release/song_instance_hu3813211082561186002.webp 400w,
               /blog/skywalking-10-release/song_instance_hu1690291293558603073.webp 760w,
               /blog/skywalking-10-release/song_instance_hu5469054882107122005.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/skywalking-10-release/song_instance_hu3813211082561186002.webp&#34;
               width=&#34;760&#34;
               height=&#34;379&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4: Instance Hierarchy Agent With K8s Service(Pod)
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在 Kubernetes 集群中部署并由应用程序 &lt;code&gt;song&lt;/code&gt; 使用的 PostgreSQL 数据库 &lt;code&gt;psql&lt;/code&gt;。因此，数据库 &lt;code&gt;psql&lt;/code&gt; 跨越 &lt;code&gt;VIRTUAL_DATABASE&lt;/code&gt;、&lt;code&gt;POSTGRESQL&lt;/code&gt; 和 &lt;code&gt;K8S_SERVICE&lt;/code&gt; 层，SkyWalking 可以监控这些层次，Service Hierarchy 拓扑如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5-service-hierarchy-agentvirtual-database-with-real-database-and-k8s-service&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 5: Service Hierarchy Agent(Virtual Database) With Real Database And K8s Service&#34; srcset=&#34;
               /blog/skywalking-10-release/postgre_hu6996347874478222530.webp 400w,
               /blog/skywalking-10-release/postgre_hu8552692846907299522.webp 760w,
               /blog/skywalking-10-release/postgre_hu9609057140340617837.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/skywalking-10-release/postgre_hu6996347874478222530.webp&#34;
               width=&#34;760&#34;
               height=&#34;422&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5: Service Hierarchy Agent(Virtual Database) With Real Database And K8s Service
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;有关更多支持的层次以及如何检测不同层次服务之间的关系，请参阅 &lt;a href=&#34;https://skywalking.apache.org/docs/main/latest/en/concepts-and-designs/service-hierarchy/#service-hierarchy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Hierarchy&lt;/a&gt;。有关如何在 SkyWalking 中配置 Service Hierarchy，请参阅 &lt;a href=&#34;https://skywalking.apache.org/docs/main/latest/en/concepts-and-designs/service-hierarchy-configuration/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Hierarchy Configuration&lt;/a&gt; 部分。&lt;/p&gt;
&lt;h2 id=&#34;使用-ebpf-监控-kubernetes-网络流量&#34;&gt;使用 eBPF 监控 Kubernetes 网络流量&lt;/h2&gt;
&lt;p&gt;在之前的版本中，SkyWalking 提供了 &lt;a href=&#34;https://skywalking.apache.org/docs/main/latest/en/setup/backend/backend-k8s-monitoring-metrics-cadvisor/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;来自 kube-state-metrics 和 cAdvisor 的 Kubernetes (K8s) 监控&lt;/a&gt;，它可以监控 Kubernetes 集群状态和 Kubernetes 资源的指标。&lt;/p&gt;
&lt;p&gt;在 SkyWalking 10 中，通过利用 &lt;a href=&#34;https://skywalking.apache.org/docs/skywalking-rover/latest/readme/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache SkyWalking Rover&lt;/a&gt; 0.6+，SkyWalking 具有使用 eBPF 监控 Kubernetes 网络流量的能力，可以收集和映射 Kubernetes 环境中应用程序的访问日志。通过这些数据，SkyWalking 可以从 Kubernetes 角度分析和提供服务流量、拓扑、TCP/HTTP 级别指标。&lt;/p&gt;
&lt;p&gt;下图显示了 Kubernetes 网络流量的拓扑和 TCP 仪表板：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-6-kubernetes-network-traffic-topology&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 6: Kubernetes Network Traffic Topology&#34; srcset=&#34;
               /blog/skywalking-10-release/k8s_topology_hu4276743585279988251.webp 400w,
               /blog/skywalking-10-release/k8s_topology_hu8219443752033304945.webp 760w,
               /blog/skywalking-10-release/k8s_topology_hu5445802710443120622.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/skywalking-10-release/k8s_topology_hu4276743585279988251.webp&#34;
               width=&#34;760&#34;
               height=&#34;459&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6: Kubernetes Network Traffic Topology
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-7-kubernetes-network-traffic-tcp-dashboard&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 7: Kubernetes Network Traffic TCP Dashboard&#34; srcset=&#34;
               /blog/skywalking-10-release/k8s_dashboard_hu2794396169615117733.webp 400w,
               /blog/skywalking-10-release/k8s_dashboard_hu5455487476317143218.webp 760w,
               /blog/skywalking-10-release/k8s_dashboard_hu11092733754357776690.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/skywalking-10-release/k8s_dashboard_hu2794396169615117733.webp&#34;
               width=&#34;760&#34;
               height=&#34;433&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7: Kubernetes Network Traffic TCP Dashboard
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;有关如何使用 eBPF 监控 Kubernetes 网络流量的更多详细信息，请参阅 &lt;a href=&#34;https://skywalking.apache.org/blog/2024-03-18-monitor-kubernetes-network-by-ebpf/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 eBPF 监控 Kubernetes 网络流量&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;banyandb---原生-apm-数据库&#34;&gt;BanyanDB - 原生 APM 数据库&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://skywalking.apache.org/docs/skywalking-banyandb/latest/readme/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BanyanDB&lt;/a&gt; 0.6.0 和 &lt;a href=&#34;https://github.com/apache/skywalking-banyandb-java-client&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BanyanDB Java 客户端&lt;/a&gt; 0.6.0 随 SkyWalking 10 一起发布。作为 SkyWalking 的原生存储解决方案，BanyanDB 将成为 SkyWalking 的下一代存储解决方案。推荐在 0.6 到 1.0 期间用于中等规模的部署。
它展示了高性能改进的潜力。与 Elasticsearch 在同一规模下相比，CPU 使用率降低 50%，内存使用率降低 50%，磁盘使用量减少 40%。&lt;/p&gt;
&lt;h2 id=&#34;apache-rocketmq-服务器监控&#34;&gt;Apache RocketMQ 服务器监控&lt;/h2&gt;
&lt;p&gt;Apache RocketMQ 是一个开源的分布式消息和流平台，广泛应用于互联网、大数据、移动互联网、物联网等领域。SkyWalking 为 RocketMQ 提供了一个基本的监控仪表板，包括以下指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cluster Metrics：包括当天产生/消费的消息数、总生产者/消费者 TPS、生产者/消费者消息大小、截至昨天产生/消费的消息数、最大消费者延迟、最大 commitLog 磁盘比、commitLog 磁盘比、拉取/发送线程池队列头等待时间、topic count 和 broker count。&lt;/li&gt;
&lt;li&gt;Broker Metrics：包括生产/消费 TPS、生产者/消费者消息大小。&lt;/li&gt;
&lt;li&gt;Topic Metrics：包括最大生产者/消费者消息大小、消费者延迟、生产/消费 TPS、生产/消费偏移、生产/消费消息大小、消费者组数和代理数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图显示了 RocketMQ Cluster Metrics 仪表板：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-8-apache-rocketmq-服务器监控&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 8: Apache RocketMQ 服务器监控&#34; srcset=&#34;
               /blog/skywalking-10-release/rocket_mq_hu16145755530748750030.webp 400w,
               /blog/skywalking-10-release/rocket_mq_hu7327102152519477921.webp 760w,
               /blog/skywalking-10-release/rocket_mq_hu7750846284856592431.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/skywalking-10-release/rocket_mq_hu16145755530748750030.webp&#34;
               width=&#34;760&#34;
               height=&#34;409&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 8: Apache RocketMQ 服务器监控
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;有关 RocketMQ 监控的更多指标和详细信息，请参阅 &lt;a href=&#34;https://skywalking.apache.org/docs/main/latest/en/setup/backend/backend-rocketmq-monitoring/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache RocketMQ 服务器监控&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;clickhouse-server-监控&#34;&gt;ClickHouse Server 监控&lt;/h2&gt;
&lt;p&gt;ClickHouse 是一个开源的列式数据库管理系统，可以实时生成分析数据报告，广泛用于在线分析处理 (OLAP)。ClickHouse 监控提供了 ClickHouse 服务器的指标、事件和异步指标的监控，包括以下部分的指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Server Metrics&lt;/li&gt;
&lt;li&gt;Query Metrics&lt;/li&gt;
&lt;li&gt;Network Metrics&lt;/li&gt;
&lt;li&gt;Insert Metrics&lt;/li&gt;
&lt;li&gt;Replica Metrics&lt;/li&gt;
&lt;li&gt;MergeTree Metrics&lt;/li&gt;
&lt;li&gt;ZooKeeper Metrics&lt;/li&gt;
&lt;li&gt;Embedded ClickHouse Keeper Metrics&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图显示了 ClickHouse Cluster Metrics 仪表板：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-9-clickhouse-服务器监控&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 9: ClickHouse 服务器监控&#34; srcset=&#34;
               /blog/skywalking-10-release/clickhouse_hu17124604017186211784.webp 400w,
               /blog/skywalking-10-release/clickhouse_hu12955312275850674690.webp 760w,
               /blog/skywalking-10-release/clickhouse_hu7506951408873536930.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/skywalking-10-release/clickhouse_hu17124604017186211784.webp&#34;
               width=&#34;760&#34;
               height=&#34;408&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 9: ClickHouse 服务器监控
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;有关 ClickHouse 监控的更多指标和详细信息，请参阅 &lt;a href=&#34;https://skywalking.apache.org/docs/main/latest/en/setup/backend/backend-clickhouse-monitoring/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ClickHouse 服务器监控&lt;/a&gt;，以及一篇可以帮助快速入门的博客 &lt;a href=&#34;https://skywalking.apache.org/blog/2024-03-12-monitoring-clickhouse-through-skywalking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 SkyWalking 监控 ClickHouse&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;apache-activemq-服务器监控&#34;&gt;Apache ActiveMQ 服务器监控&lt;/h2&gt;
&lt;p&gt;Apache ActiveMQ Classic 是一个流行且强大的开源消息和集成模式服务器。SkyWalking 为 ActiveMQ 提供了一个基本的监控仪表板，包括以下指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cluster Metrics：包括内存使用率、写入/读取速率和平均/最大写入持续时间。&lt;/li&gt;
&lt;li&gt;Broker Metrics：包括节点状态、连接数、生产者/消费者数和代理下的写入/读取速率。根据集群模式，一个集群可以包含一个或多个代理。&lt;/li&gt;
&lt;li&gt;Destination Metrics：包括生产者/消费者数、不同状态的消息、队列和队列/主题中的入队持续时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图显示了 ActiveMQ Cluster Metrics 仪表板：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-10-apache-activemq-服务器监控&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 10: Apache ActiveMQ 服务器监控&#34; srcset=&#34;
               /blog/skywalking-10-release/active_mq_hu18083523541544368436.webp 400w,
               /blog/skywalking-10-release/active_mq_hu8505261505937757510.webp 760w,
               /blog/skywalking-10-release/active_mq_hu15374837709644185011.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/skywalking-10-release/active_mq_hu18083523541544368436.webp&#34;
               width=&#34;760&#34;
               height=&#34;642&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 10: Apache ActiveMQ 服务器监控
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;有关 ActiveMQ 监控的更多指标和详细信息，请参阅 &lt;a href=&#34;https://skywalking.apache.org/docs/main/latest/en/setup/backend/backend-activemq-monitoring/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache ActiveMQ 服务器监控&lt;/a&gt;，以及一篇可以帮助快速入门的博客 &lt;a href=&#34;https://skywalking.apache.org/blog/2024-04-19-monitoring-activemq-through-skywalking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 SkyWalking 监控 ActiveMQ&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;支持多标签名称&#34;&gt;支持多标签名称&lt;/h2&gt;
&lt;p&gt;在 SkyWalking 10 之前，SkyWalking 不会在指标数据中存储标签名称，这使得 MQE 必须使用 &lt;code&gt;_&lt;/code&gt; 作为通用标签名称，无法使用多个标签名称查询指标数据。&lt;/p&gt;
&lt;p&gt;SkyWalking 10 支持在指标数据中存储标签名称，MQE 可以使用多个标签名称查询或计算指标数据。例如：&lt;code&gt;k8s_cluster_deployment_status&lt;/code&gt; 指标具有 &lt;code&gt;namespace&lt;/code&gt;、&lt;code&gt;deployment&lt;/code&gt; 和 &lt;code&gt;status&lt;/code&gt; 标签。如果我们想查询所有 &lt;code&gt;namespace=skywalking-showcase&lt;/code&gt; 和 &lt;code&gt;status=true&lt;/code&gt; 的部署指标值，可以使用以下表达式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;k8s_cluster_deployment_status{namespace=&amp;#39;skywalking-showcase&amp;#39;, status=&amp;#39;true&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相关增强：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于在 SkyWalking 9.6.0 中告警规则配置已迁移到 MQE，因此告警规则也支持多标签名称。&lt;/li&gt;
&lt;li&gt;PromeQL 服务支持多标签名称查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;metrics-grpc-导出器&#34;&gt;Metrics gRPC 导出器&lt;/h2&gt;
&lt;p&gt;SkyWalking 10 增强了 &lt;a href=&#34;https://skywalking.apache.org/docs/main/latest/en/setup/backend/exporter/#grpc-exporter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;metrics gPRC exporter&lt;/a&gt;，支持将所有类型的指标数据导出到 gRPC 服务器。&lt;/p&gt;
&lt;h2 id=&#34;skywalking-原生-ui-指标查询切换到-v3-api&#34;&gt;SkyWalking 原生 UI 指标查询切换到 V3 API&lt;/h2&gt;
&lt;p&gt;SkyWalking 原生 UI 指标查询弃用 V2 API，全部迁移到 &lt;a href=&#34;https://skywalking.apache.org/docs/main/latest/en/api/query-protocol/#v3-apis&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;V3 API&lt;/a&gt; 和 &lt;a href=&#34;https://skywalking.apache.org/docs/main/next/en/api/metrics-query-expression/#metrics-query-expressionmqe-syntax&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MQE&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;其他值得注意的增强功能&#34;&gt;其他值得注意的增强功能&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;支持 Java 21 运行时和 oap-java21 镜像用于 Java 21 运行时。&lt;/li&gt;
&lt;li&gt;从镜像中删除 CLI（&lt;code&gt;swctl&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;支持更多的 MQE 函数和操作。&lt;/li&gt;
&lt;li&gt;增强原生 UI 并改善用户体验。&lt;/li&gt;
&lt;li&gt;修复了一些 Bug 和 CVE。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>可观测性峰会 2023</title>
      <link>https://cloudnativecn.com/event/observability-summit-2023/</link>
      <pubDate>Sat, 22 Apr 2023 09:30:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/event/observability-summit-2023/</guid>
      <description>&lt;p&gt;活动日程请见&lt;a href=&#34;https://huodongxing.com/event/6695157778700&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;活动行&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 eBPF 准确定位服务网格的关键性能问题</title>
      <link>https://cloudnativecn.com/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/</link>
      <pubDate>Tue, 05 Jul 2022 17:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/</guid>
      <description>&lt;h2 id=&#34;background&#34;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;Apache SkyWalking 观察部署在服务网格中的服务的度量、日志、追踪和事件。在进行故障排除时，SkyWalking 错误分析是一个宝贵的工具，可以帮助确定错误发生的位置。然而，确定性能问题更加困难：利用预先存在的观察数据往往不可能找到性能问题的根本原因。为此，动态调试和故障排除在进行服务性能剖析时就必不可少。在这篇文章中，我们将讨论如何使用 eBPF 技术来改进 SkyWalking 中的剖析功能，并用于分析服务网格中的性能影响。&lt;/p&gt;
&lt;h2 id=&#34;trace-profiling-in-skywalking&#34;&gt;SkyWalking 中的追踪剖析&lt;/h2&gt;
&lt;p&gt;自 SkyWalking 7.0.0 以来，Trace Profiling 通过定期对线程堆栈进行采样，让开发者知道运行哪行代码花费更多时间，从而帮助开发者发现性能问题。然而，Trace Profiling 不适合以下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程模型&lt;/strong&gt;：Trace Profiling 对于剖析在单线程中执行的代码最有用。它对严重依赖异步执行模式的中间件不太有用。例如，Go 中的 Goroutines 或 Kotlin Coroutines。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语言&lt;/strong&gt;：目前，Trace Profiling 只支持 Java 和 Python，因为在 Go 和 Node.js 等一些语言的运行时中不容易获得线程栈。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Agent 绑定&lt;/strong&gt;：Trace Profiling 需要安装 Agent，根据语言的不同，这可能很麻烦（例如，PHP 必须依赖其 C 内核；Rust 和 C/C++ 需要的仪器需要手动安装）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关联性&lt;/strong&gt;：由于追踪剖析只与单个请求相关，所以当无法确认哪个请求产生问题时则变得难已处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生命周期短的服务&lt;/strong&gt;：由于（至少）两个原因，Trace Profiling 不支持短声明周期的服务：
&lt;ul&gt;
&lt;li&gt;在启动阶段，很难区分系统性能和类代码操作。&lt;/li&gt;
&lt;li&gt;Trace Profiling 与一个端点相连，以识别性能影响，但没有端点来匹配这些短生命周期的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幸运的是，有一些技术比 Trace Profiling 更实用。&lt;/p&gt;
&lt;h2 id=&#34;introduce-ebpf&#34;&gt;eBPF 简介&lt;/h2&gt;
&lt;p&gt;我们发现，eBPF —— 一种可以在操作系统内核中运行沙盒程序的技术，从而安全有效地扩展内核的功能，而不需要修改内核或加载内核模块，可以帮助我们填补 Trace Profiling 留下的空白。eBPF 技术正在流行，因为它打破了传统上的用户和内核空间之间的障碍。现在我们可以将程序作为字节码注入到内核中运行，而不需要定制和重新编译内核。可观测可以很好地利用这一点。&lt;/p&gt;
&lt;p&gt;在下图中，我们可以看到，当系统执行 &lt;code&gt;execve&lt;/code&gt; 系统调用时，eBPF 程序被触发，通过使用函数调用获得当前进程的运行时信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ebpf-程序调用流程图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;eBPF 程序调用流程图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu5970380327249639133.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu1614202018015767874.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu7454622095889629497.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu5970380327249639133.webp&#34;
               width=&#34;760&#34;
               height=&#34;578&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      eBPF 程序调用流程图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用 eBPF 技术，可以将 SkyWalking 的剖析能力范围扩大到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局性能剖析&lt;/strong&gt;：在 eBPF 之前，数据收集被限制在代理可以观察的范围内。由于 eBPF 程序在内核中运行，它们可以观察到所有的线程。当你不确定某个性能问题是否是由一个特定的请求引起的，这一点特别有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据内容&lt;/strong&gt;：eBPF 可以转储用户和内核空间的线程栈，所以如果性能问题发生在内核空间就更容易被发现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理绑定&lt;/strong&gt;：所有现代 Linux 内核都支持 eBPF，所以不需要安装任何东西。这意味着它是一个免编排与代理的模型。这减少了由内置软件引起的摩擦，这些软件可能没有安装正确的代理，如服务网格中的 Envoy。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;采样类型&lt;/strong&gt;：与追踪剖析不同，eBPF 是事件驱动的，因此，不受间隔轮询的限制。例如，eBPF 可以触发事件，并根据传输大小的阈值收集更多的数据。这可以让系统在极端负载下分流和优先收集数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ebpf-limitations&#34;&gt;eBPF 的局限性&lt;/h3&gt;
&lt;p&gt;虽然 eBPF 为发掘性能瓶颈提供了显著的优势，但没有任何技术是完美的。eBPF 有一些限制，如下所述（幸运的是，由于 SkyWalking 不依赖 eBPF，其影响是有限的）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Linux 版本要求&lt;/strong&gt;：eBPF 程序需要的 Linux 内核版本要 4.4 以上，更新的内核版本可以提供更多的数据收集。BCC 记录了 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/13b5563c11f7722a61a17c6ca0a1a387d2fa7788/docs/kernel-versions.md#main-features&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不同 Linux 内核版本所支持的功能&lt;/a&gt;，不同版本之间的差异在于 eBPF 收集的数据集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要特权权限&lt;/strong&gt;：所有打算将 eBPF 程序加载到 Linux 内核的进程必须在特权模式下运行。因此，代码中的错误或其他问题可能对安全有很大的影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对动态语言的支持较弱&lt;/strong&gt;：eBPF 对基于 JIT 的动态语言，如 Java，支持较弱。这也取决于你想收集什么数据。对于 Profiling，eBPF 不支持解析程序的字符表（symbol），这就是为什么大多数基于 eBPF 的剖析技术只支持静态语言如 C、C++、Go 和 Rust。然而，字符表映射有时可以通过语言所提供的工具来解决。例如，在 Java 中，可以使用 &lt;a href=&#34;https://github.com/jvm-profiling-tools/perf-map-agent#architecture&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;perf-map-agent&lt;/a&gt; 来生成字符表映射。然而，动态语言不支持附加（&lt;code&gt;uprobe&lt;/code&gt;）功能，而这种功能可以让我们通过符号追踪执行事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;introducing-skywalking-rover&#34;&gt;SkyWalking Rover 简介&lt;/h3&gt;
&lt;p&gt;SkyWalking Rover 是 SkyWalking 生态系统中引入的 eBPF 剖析功能。下图显示了 SkyWalking Rover 的整体架构。SkyWalking Rover 目前支持 Kubernetes 环境，必须部署在 Kubernetes 集群内。与 SkyWalking 后端服务器建立连接后，它将当前机器上的进程信息保存到 SkyWalking。当用户通过用户界面创建 eBPF 剖析任务时，SkyWalking Rover 会接收任务并在相关的基于 C、C++、Golang 和 Rust 语言的程序中执行。&lt;/p&gt;
&lt;p&gt;除了需要具有 eBPF 功能的内核外，部署 SkyWalking Rover 没有其他先决条件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-skywalking-rover-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SkyWalking Rover 架构图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu14181635542096480807.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu10018641345865856161.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu5594261587348231627.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu14181635542096480807.webp&#34;
               width=&#34;760&#34;
               height=&#34;259&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SkyWalking Rover 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;cpu-profiling-with-rover&#34;&gt;使用 Rover 进行 CPU 剖析&lt;/h3&gt;
&lt;p&gt;CPU 剖析是显示服务性能的最直观方式。受 &lt;a href=&#34;https://www.brendangregg.com/offcpuanalysis.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Brendan Gregg 的博客文章&lt;/a&gt; 的启发，我们将 CPU 剖析分为两种类型，并在 Rover 中加以实施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU 剖析&lt;/strong&gt;：线程在 CPU 上的运行时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;off-CPU 剖析&lt;/strong&gt;：线程在 I/O、锁、定时器、分页 / 交换等方面被阻塞时的等待时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;profiling-envoy-with-ebpf&#34;&gt;用 eBPF 对 Envoy 进行剖析&lt;/h2&gt;
&lt;p&gt;Envoy 是一个流行的代理，在 Istio 服务网格中被用作为数据平面。在 Kubernetes 集群中，Istio 将 Envoy 作为 sidecar 注入到每个服务的 pod 中，在那里透明地拦截和处理传入和传出的流量。作为数据平面，Envoy 的任何性能问题都会影响到网格中的所有服务流量。在这种情况下，使用 eBPF 剖析来分析生产中由服务网格引起的问题是比较有力的。&lt;/p&gt;
&lt;h3 id=&#34;demo-environment&#34;&gt;演示环境&lt;/h3&gt;
&lt;p&gt;如果你想看到详细过程，我们已经建立了一个演示环境，在那里我们部署了一个 Nginx 服务进行压力测试。流量被 Envoy 拦截并转发到 Nginx。安装整个环境的命令可以在 &lt;a href=&#34;https://github.com/mrproliu/skywalking-rover-profiling-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; 上获取。&lt;/p&gt;
&lt;h2 id=&#34;on-cpu-profiling&#34;&gt;CPU 剖析&lt;/h2&gt;
&lt;p&gt;当服务的 CPU 使用率很高时，CPU 剖析适用于分析线程堆栈。如果堆栈被转储的次数较多，意味着线程堆栈占据了更多的 CPU 资源。&lt;/p&gt;
&lt;p&gt;在使用演示配置文件安装 Istio 时，我们发现有两个地方的性能可以优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Zipkin 追踪&lt;/strong&gt;：不同的 Zipkin 采样百分比对 QPS 有直接影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问日志格式&lt;/strong&gt;：减少 Envoy 访问日志的字段可以提高 QPS。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;zipkin-追踪&#34;&gt;Zipkin 追踪&lt;/h3&gt;
&lt;h3 id=&#34;zipkin-100-采样&#34;&gt;Zipkin 100% 采样&lt;/h3&gt;
&lt;p&gt;在默认的演示配置文件中，Envoy 使用 100% 采样作为默认的追踪策略。这对性能有什么影响？&lt;/p&gt;
&lt;p&gt;如下图所示，使用 CPU 剖析，我们发现它大约需要 &lt;strong&gt;16%&lt;/strong&gt; 的 CPU 开销。在固定消耗 &lt;strong&gt;2 个 CPU&lt;/strong&gt; 的情况下，其 QPS 可以达到 &lt;strong&gt;5.7K&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-zipkin-100-采样-cpu-剖析的火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Zipkin 100% 采样 CPU 剖析的火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_hu219877918642946772.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_hu12595813771310330087.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_hu6408216201499505126.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_hu219877918642946772.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Zipkin 100% 采样 CPU 剖析的火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;禁用-zipkin-追踪&#34;&gt;禁用 Zipkin 追踪&lt;/h3&gt;
&lt;p&gt;此时，我们发现，如果没有必要，可以降低 Zipkin 采样比例，甚至可以禁用追踪。根据 &lt;a href=&#34;https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#Tracing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 文档&lt;/a&gt;，我们可以在安装 Istio 时使用以下命令禁用追踪。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set &lt;span class=&#34;s1&#34;&gt;&amp;#39;meshConfig.enableTracing=false&amp;#39;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set &lt;span class=&#34;s1&#34;&gt;&amp;#39;meshConfig.defaultConfig.tracing.sampling=0.0&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;禁用追踪后，我们再次进行 CPU 剖析。根据下图，我们发现 Zipkin 已经从火焰图中消失了。在与前面的例子相同的 &lt;strong&gt;2 个 CPU&lt;/strong&gt; 消耗下，QPS 达到 &lt;strong&gt;9K&lt;/strong&gt;，几乎增加了 &lt;strong&gt;60%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-禁用-zipkin-追踪的-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;禁用 Zipkin 追踪的 CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu13067807285226527396.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu7183978279299237306.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu9130309760498234537.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu13067807285226527396.webp&#34;
               width=&#34;760&#34;
               height=&#34;384&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      禁用 Zipkin 追踪的 CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;tracing-with-throughput&#34;&gt;追踪吞吐量&lt;/h3&gt;
&lt;p&gt;在 CPU 使用率相同的情况下，我们发现，当追踪功能被禁用时，Envoy 的性能会大大提升。当然，这需要我们在 Zipkin 收集的样本数量和 Envoy 的预期性能（QPS）之间做出权衡。&lt;/p&gt;
&lt;p&gt;下表说明了在相同的 CPU 使用率下，不同的 Zipkin 采样比例对 QPS 的影响。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Zipkin 采样比例&lt;/th&gt;
          &lt;th&gt;QPS&lt;/th&gt;
          &lt;th&gt;CPU&lt;/th&gt;
          &lt;th&gt;备注&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;100% &lt;strong&gt;（默认）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;5.7K&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Zipkin 占用 16%&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;1%&lt;/td&gt;
          &lt;td&gt;8.1K&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Zipkin 占用 0.3%&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;禁用&lt;/td&gt;
          &lt;td&gt;9.2K&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;Zipkin 占用 0%&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;access-log-format&#34;&gt;访问日志格式&lt;/h2&gt;
&lt;h3 id=&#34;default-log-format&#34;&gt;默认访问日志格式&lt;/h3&gt;
&lt;p&gt;在默认的演示配置文件中，默认的访问日志格式包含大量的数据。下面的火焰图显示了在解析数据时涉及的各种功能，如请求头、响应头和流媒体主体。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-默认访问日志格式的-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;默认访问日志格式的 CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu14830024941474199287.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu14614282912882975842.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu11800178874605225408.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu14830024941474199287.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      默认访问日志格式的 CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;simplifying-access-log-format&#34;&gt;简化访问日志格式&lt;/h3&gt;
&lt;p&gt;通常情况下，我们不需要访问日志中的所有信息，所以我们通常可以简化它来获得我们需要的信息。下面的命令简化了访问日志的格式，只显示基本信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set meshConfig.accessLogFormat&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;[% START_TIME%] \&amp;#34;% REQ (:METHOD)% % REQ (X-ENVOY-ORIGINAL-PATH?:PATH)% % PROTOCOL%\&amp;#34;% RESPONSE_CODE%\n&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;简化访问日志格式后，我们发现 QPS 从 &lt;strong&gt;5.7K&lt;/strong&gt; 增加到 &lt;strong&gt;5.9K&lt;/strong&gt;。当再次执行 CPU 剖析时，日志格式化的 CPU 使用率从 &lt;strong&gt;2.4%&lt;/strong&gt; 下降到 &lt;strong&gt;0.7%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简化日志格式帮助我们提高了性能。&lt;/p&gt;
&lt;h2 id=&#34;off-cpu-剖析&#34;&gt;Off-CPU 剖析&lt;/h2&gt;
&lt;p&gt;Off-CPU 剖析适用于由非高 CPU 使用率引起的性能问题。例如，当一个服务中有太多的线程时，使用 off-CPU 剖析可以揭示出哪些线程花费了更多的时间进行上下文切换。&lt;/p&gt;
&lt;p&gt;我们提供两个维度的数据汇总。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;切换次数&lt;/strong&gt;：一个线程切换上下文的次数。当线程返回到 CPU 时，它完成了一次上下文切换。开关次数较多的线程栈会花费更多时间进行上下文切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;切换持续时间&lt;/strong&gt;：一个线程切换上下文所需的时间。切换持续时间较长的线程栈在 off-CPU 花费的时间较多。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;write-access-log&#34;&gt;写入访问日志&lt;/h3&gt;
&lt;h4 id=&#34;enable-write&#34;&gt;启用写入&lt;/h4&gt;
&lt;p&gt;使用与之前 CPU 测试相同的环境和设置，我们进行了 off-CPU 剖析。如下图所示，我们发现访问日志的写入占总上下文切换的 &lt;strong&gt;28%&lt;/strong&gt; 左右。下图中的 &lt;code&gt;__write&lt;/code&gt; 也表明这是 Linux 内核中的方法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-启用写入的-off-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;启用写入的 off-CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hu16547892170890319974.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hu16646578101085935854.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hu5081504830125445828.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hu16547892170890319974.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      启用写入的 off-CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;禁用写入&#34;&gt;禁用写入&lt;/h4&gt;
&lt;p&gt;SkyWalking 实现了 Envoy 的访问日志服务（ALS）功能，允许我们使用 gRPC 协议将访问日志发送到 SkyWalking 可观察性分析平台（OAP）。即使禁用访问日志，我们仍然可以使用 ALS 来捕获 / 汇总日志。我们使用以下命令禁用了对访问日志的写入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo --set meshConfig.accessLogFile&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;禁用访问日志功能后，我们进行了 off-CPU 剖析。如下图所示，文件写入条目已经消失了。Envoy 的吞吐量也从 &lt;strong&gt;5.7K&lt;/strong&gt; 增加到 &lt;strong&gt;5.9K&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-禁用访问日志功能后的-off-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;禁用访问日志功能后的 off-CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu3918893974181222883.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu14044134748959804922.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu6630598025925199458.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu3918893974181222883.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      禁用访问日志功能后的 off-CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇文章中，我们研究了 Apache SkyWalking 的 Trace Profiling 可以给我们带来的启示，以及使用 eBPF 剖析可以实现的更多功能。所有这些功能都在 &lt;a href=&#34;https://github.com/apache/skywalking-rover&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;skywalking-rover&lt;/a&gt; 中实现。除了 CPU 和 off-CPU 剖析之外，你还会发现以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连续剖析&lt;/strong&gt;，帮助你自动剖析，无需人工干预。例如，当 Rover 检测到 CPU 超过一个可配置的阈值时，它会自动执行 CPU 剖析任务。&lt;/li&gt;
&lt;li&gt;更多的剖析类型，以丰富使用场景，如网络和内存剖析。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #4 上海站</title>
      <link>https://cloudnativecn.com/event/service-mesh-meetup-04/</link>
      <pubDate>Sun, 25 Nov 2018 13:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/event/service-mesh-meetup-04/</guid>
      <description>&lt;h2 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h2&gt;
&lt;h4 id=&#34;observability-and-istio-telemetry&#34;&gt;Observability and Istio telemetry&lt;/h4&gt;
&lt;p&gt;吴晟 Apache SkyWalking 创始人、Apache Sharding-Sphere 原型作者、比特大陆资深技术专家、CNCF OpenTracing 标准化委员会成员&lt;/p&gt;
&lt;h4 id=&#34;蚂蚁集团-service-mesh-渐进式迁移方案&#34;&gt;蚂蚁集团 Service Mesh 渐进式迁移方案&lt;/h4&gt;
&lt;p&gt;敖小剑 蚂蚁集团高级技术专家，十六年软件开发经验，微服务专家，Service Mesh 布道师，Servicemesher 社区联合创始人&lt;/p&gt;
&lt;p&gt;张瑜标 阿里巴巴技术专家、前京东 Hadoop 负责人、Hadoop 代码贡献者、现负责 UC 基于 Kubernetes 自研的 PaaS 平台整体的稳定性&lt;/p&gt;
&lt;h4 id=&#34;探讨和实践基于-isito-的微服务治理事件监控&#34;&gt;探讨和实践基于 Isito 的微服务治理事件监控&lt;/h4&gt;
&lt;p&gt;徐运元 谐云科技云平台架构师，致力于容器 PaaS 平台、企业级容器云平台的方案设计和技术落地&lt;/p&gt;
&lt;h4 id=&#34;envoycontour-与-kubernetes-实践&#34;&gt;Envoy、Contour 与 Kubernetes 实践&lt;/h4&gt;
&lt;p&gt;冯玮 七牛容器云平台产品架构师，曾在百度和华为从事公有云领域高性能分布式计算和存储平台的架构设计和产品研发&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #2 北京站</title>
      <link>https://cloudnativecn.com/event/service-mesh-meetup-02/</link>
      <pubDate>Sun, 29 Jul 2018 13:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/event/service-mesh-meetup-02/</guid>
      <description>&lt;h2 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;张亮（京东金融数据研发负责人）：Service Mesh 的延伸 —— 论道 Database Mesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人简介：张亮，京东金融数据研发负责人。热爱开源，目前主导两个开源项目 Elastic-Job 和 Sharding-Sphere(Sharding-JDBC)。擅长以 java 为主分布式架构以及以 Kubernetes 和 Mesos 为主的云平台方向，推崇优雅代码，对如何写出具有展现力的代码有较多研究。2018 年初加入京东金融，现担任数据研发负责人。目前主要精力投入在将 Sharding-Sphere 打造为业界一流的金融级数据解决方案之上。&lt;/p&gt;
&lt;p&gt;随着 Service Mesh 概念的推广与普及，云原生、低接入成本以及分布式组件下移等理念，已逐渐被认可。在 Service Mesh 依旧处于高速迭代的发展期的同时，以它的理念为参考，其他的 Mesh 思想也在崭露萌芽。Database Mesh 即是 Service Mesh 的其中一种延伸，虽然理念与 Service Mesh 相近，但数据库与无状态的服务却有着巨大的差别。Database Mesh 与分布式数据库（如 NoSQL 和 NewSQL）的功能范畴并非重叠而是互补，它更加关注数据库之上的中间啮合层。本次将与您一起交流 Database Mesh 的一些思考，以及探讨如何与现有产品相结合，实现更加强大与优雅的云原生数据库解决方案。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;吴晟（Apache SkyWalking 创始人）：Observability on Service Mesh —— Apache SkyWalking 6.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人简介：Apache SkyWalking 创始人，PPMC 和 Committer，比特大陆资深技术专家，&lt;a href=&#34;http://tetrate.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate.io&lt;/a&gt; Founding Engineer，专注 APM 和自动化运维相关领域。Microsoft MVP。CNCF OpenTracing 标准化委员会成员。Sharding-Sphere PMC 成员。&lt;/p&gt;
&lt;p&gt;APM 在传统意义上，都是通过语言探针，对应用性能进行整体分析。但随着 Cloud Native, K8s 容器化之后，以 Istio 为代表的 Service Mesh 的出现，为可观测性和 APM 提供了一种新的选择。SkyWalking 作为传统上提供多语言自动探针的 Apache 开源项目，在 service mesh 的大背景下，也开始从新的角度提供可观测性支持。&lt;/p&gt;
&lt;p&gt;SkyWalking 和 Tetrate Inc. Istio 核心团队合作，从 Mixer 接口提取遥感数据，提供 SkyWalking 语言探针一样的功能，展现 service mesh 风格探针的强大力量。之后，也会和更多的 mesh 实现进行合作，深入在此领域的运用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;朵晓东（蚂蚁集团，高级技术专家）：蚂蚁集团开源的 Service Mesh 数据平面 SOFA MOSN 深层揭秘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人简介：蚂蚁集团高级技术专家，专注云计算技术及产品。Apache Kylin 创始团队核心成员；蚂蚁金融云 PaaS 创始团队核心成员，Antstack 网络产品负责人；SOFAMesh 创始团队核心成员。&lt;/p&gt;
&lt;p&gt;Service Mesh 技术体系在蚂蚁落地过程中，我们意识到 Mesh 结合云原生在多语言，流量调度等各方面的优势，同时面对蚂蚁内部语言体系与运维构架深度融合，7 层流量调度规则方式复杂多样，金融级安全要求等诸多特征带来的问题和挑战，最终选择结合蚂蚁自身情况自研 Golang 版本数据平面 MOSN，同时拥抱开源社区，支持作为 Envoy 替代方案与 Istio 集成工作。本次 session 将从功能、构架、跨语言、安全、性能、开源等多方面分享 Service Mesh 在蚂蚁落地过程中在数据平面的思考和阶段成果。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;丁振凯（新浪微博，微博搜索架构师）：微博 Service Mesh 实践 - WeiboMesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人简介：微博搜索架构师，主要负责搜索泛前端架构工作。主导搜索结果和热搜榜峰值应对及稳定性解决方案，以及微服务化方案落地。在 Web 系统架构方面拥有比较丰富的实践和积累。喜欢思考，深究技术本质。去年十一鹿晗关晓彤事件中一不小心成为网红工程师，并成功登上自家热搜榜。&lt;/p&gt;
&lt;p&gt;WeiboMesh 源自于微博内部对异构体系服务化的强烈需求以及对历史沉淀的取舍权衡，它没有把历史作为包袱，而是巧妙的结合自身实际情况完成了对 Service Mesh 规范的实现。目前 WeiboMesh 在公司内部已经大规模落地，并且已经开源，WeiboMesh 是非常接地气的 Service Mesh 实现。本次分享主要介绍微博在跨语言服务化面临的问题及 WeiboMesh 方案介绍，并结合业务实例分析 WeiboMesh 的独到之处。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
