<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jonh Wendell | 云原生社区（中国）</title>
    <link>https://cloudnative.to/author/jonh-wendell/</link>
      <atom:link href="https://cloudnative.to/author/jonh-wendell/index.xml" rel="self" type="application/rss+xml" />
    <description>Jonh Wendell</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://cloudnative.to/author/jonh-wendell/avatar_hue38add62c87b7486d80c9f3fda25dfc1_12220_270x270_fill_q75_lanczos_center.jpg</url>
      <title>Jonh Wendell</title>
      <link>https://cloudnative.to/author/jonh-wendell/</link>
    </image>
    
    <item>
      <title>Istio控制平面故障后会发生什么？</title>
      <link>https://cloudnative.to/blog/istio-what-happens-when-control-plane-is-down/</link>
      <pubDate>Thu, 22 Nov 2018 22:07:15 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-what-happens-when-control-plane-is-down/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://bani.com.br/2018/11/istio-what-happens-when-control-plane-is-down/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;大家好！我在Istio上做了一些实验，禁用控制平面的组件，并观察应用和服务网格会发生什么。下面是我的笔记。&lt;/p&gt;
&lt;h2 id=&#34;pilot&#34;&gt;Pilot&lt;/h2&gt;
&lt;p&gt;Pilot负责Istio的流量控制特性，同时将Sidecar更新至最新的网格配置。&lt;/p&gt;
&lt;p&gt;Pilot启动以后，监听端口 &lt;em&gt;15010&lt;/em&gt; （gRPC）和 &lt;em&gt;8080&lt;/em&gt; （HTTP）。&lt;/p&gt;
&lt;p&gt;当应用的Sidecar（Envoy，Istio-Proxy）启动以后，它将会连接 &lt;em&gt;pilot.istio-system:15010&lt;/em&gt; ，获取初始配置，并保持长连接。&lt;/p&gt;
&lt;p&gt;Pilot会监听Kubernetes资源，只要检测到网格发生变化，就会将最新的配置通过gRPC连接推送到Sidecar上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当Pilot停止以后，Pilot和Sidecar之间的gRPC连接被关闭，同时Sidecar会一直尝试重连。&lt;/li&gt;
&lt;li&gt;网络流量不会受到Pilot停止的影响，因为所有的配置被推送过来以后，就会存储在Sidecar的内存中。&lt;/li&gt;
&lt;li&gt;网格中新的变更信息（例如新的Pod、规则、服务等等）不会继续到达Sidecar，因为Pilot不再监听这些变化并转发。&lt;/li&gt;
&lt;li&gt;当Pilot重新上线以后，Sidecar就会重新建立连接（一直尝试重连）并获取到最新的网格配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mixer-policy&#34;&gt;Mixer Policy&lt;/h2&gt;
&lt;p&gt;Policy执行网络策略。&lt;/p&gt;
&lt;p&gt;Mixer在启动时读取配置，并监听Kubernetes的资源变化。一旦检测到新的配置，Mixer就会将其加载至内存中。&lt;/p&gt;
&lt;p&gt;Sidecar在每次请求服务应用时，检查（发起连接）Mixer Policy Pod。&lt;/p&gt;
&lt;p&gt;当Mixer Policy Pod停止以后，所有到服务的请求会失败，并收到 &lt;strong&gt;“503 UNAVAILABLE:no healthy upstream”&lt;/strong&gt; 的错误——因为所有 sidecar 无法连接到这些Pod。&lt;/p&gt;
&lt;p&gt;在Istio 1.1版本中新增了[global]配置（ &lt;em&gt;policyCheckfailOpen&lt;/em&gt; ），允许 &lt;em&gt;“失败打开”&lt;/em&gt; 策略，也即当Mixer Policy Pod无法响应时，所有的请求会成功，而不是报 &lt;em&gt;503&lt;/em&gt; 错误。默认情况下该配置设置为 &lt;em&gt;false&lt;/em&gt; ，也即 &lt;em&gt;“失败关闭”&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;当Mixer停止后，我们在网格中执行的操作（例如新增规则、更新配置等等）都不会对应用产生影响，直到Mixer重新启动。&lt;/p&gt;
&lt;h2 id=&#34;mixer-telemetry&#34;&gt;Mixer Telemetry&lt;/h2&gt;
&lt;p&gt;Telemetry为Istio插件提供遥测信息。&lt;/p&gt;
&lt;p&gt;Sidecar什么时候调用Telemetry Pod取决于两个因素：批量完成100次请求和请求时间超过1秒钟（默认配置），这两个条件只要有一个先满足就会执行该操作，这是为了避免对Telemetry Pod造成过于频繁的调用。&lt;/p&gt;
&lt;p&gt;当Telemetry Pod停止以后，Sidecar记录一次失败信息（在Pod标准错误输出里），并丢弃遥测信息。请求不会受到影响，正如Policy Pod停止时一样。当Telemetry Pod重新启动以后，就会继续从Sidecar收到遥测信息。&lt;/p&gt;
&lt;h2 id=&#34;其它信息&#34;&gt;其它信息&lt;/h2&gt;
&lt;p&gt;值得注意的是，Istio允许自定义控制平面的组件。例如，如果不需要Policy，你可以完全禁用Mixer Policy。Istio 1.1对这种模块化的特性支持的更好。更多信息，可以参考&lt;a href=&#34;https://istio.io/docs/setup/kubernetes/minimal-install/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这篇文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当然，Pilot、Mixer Policy和Mixer Telemetry在高可用部署场景工作的也很好，可以同时运行多副本。实际上，默认配置通过 &lt;em&gt;HorizontalPodAutoscaler&lt;/em&gt; 允许启动1到5个Pod。（详细请参考&lt;a href=&#34;https://github.com/istio/istio/blob/release-1.1/install/kubernetes/helm/subcharts/mixer/templates/autoscale.yaml#L15&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这篇文档&lt;/a&gt;和&lt;a href=&#34;https://github.com/istio/istio/blob/release-1.1/install/kubernetes/helm/subcharts/mixer/values.yaml#L14&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这篇文档&lt;/a&gt;）&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
