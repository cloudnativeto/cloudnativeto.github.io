<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>陈亦帅 | 云原生社区（中国）</title>
    <link>https://cloudnative.to/author/%E9%99%88%E4%BA%A6%E5%B8%85/</link>
      <atom:link href="https://cloudnative.to/author/%E9%99%88%E4%BA%A6%E5%B8%85/index.xml" rel="self" type="application/rss+xml" />
    <description>陈亦帅</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 09 Mar 2023 12:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/author/%E9%99%88%E4%BA%A6%E5%B8%85/avatar_hu5cac0e12d1a110c102159eb24fc6c63c_82579_270x270_fill_q75_lanczos_center.jpg</url>
      <title>陈亦帅</title>
      <link>https://cloudnative.to/author/%E9%99%88%E4%BA%A6%E5%B8%85/</link>
    </image>
    
    <item>
      <title>一文了解VictoriaMetrics</title>
      <link>https://cloudnative.to/blog/victoriametrics/</link>
      <pubDate>Thu, 09 Mar 2023 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/victoriametrics/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文首先对VictoriaMetrics的功能和架构进行介绍。接着，使用一个场景例子演示单集群VictoriaMetrics的安装，并验证其对Prometheus的兼容性和可替换性。&lt;/p&gt;
&lt;h2 id=&#34;victoriametrics简介&#34;&gt;VictoriaMetrics简介&lt;/h2&gt;
&lt;p&gt;我们知道，若要保证一个系统的稳定运行，那么对于这个系统的监控是不可或缺的环节。当今在云原生领域中，Prometheus作为已经毕业的CNCF项目，已经成为了非常主流的监控和报警工具。但它也存在一些缺点，例如：默认情况下，其数据存储于本地文件的TSDB中，不利于容灾和做数据管理，若用于生产一般需要搭配第三方的如InfulxDB进行使用。大数据量的场景下，指标的收集和管理性能存在一定的瓶颈。&lt;/p&gt;
&lt;p&gt;而我们今天介绍的VictoriaMetrics可以认为是Prometheus在上述问题上的一个增强版。它不仅能作为时序数据库结合Prometheus使用进行指标的长期远程存储，也能单独作为一个监控解决方案对Prometheus进行平替。&lt;/p&gt;
&lt;p&gt;对比其他一些主流的监控方案、时序数据库，VictoriaMetrics具有如下优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指标数据的收集和查询具有极高的性能和良好的垂直和水平伸缩性，比InfluxDB和TimesscaleDB的性能高出20倍&lt;/li&gt;
&lt;li&gt;在处理高技术时间序列时，内存方面做出了优化，比InfluxDB少10x倍，比Prometheus、Thanos或Cortex少7倍&lt;/li&gt;
&lt;li&gt;数据存储的压缩方式更加高效。比TimescaleDB少70倍，与Prometheus、Thanos、Cortex相比，所需存储空间也少7倍。&lt;/li&gt;
&lt;li&gt;针对高延迟IO和低IOPS存储进行了优化&lt;/li&gt;
&lt;li&gt;单节点的VictoriaMetrics即可替代Thanos、M3DB、Cortex、InfluxDB或TimescaleDB等竞品中等规模的集群&lt;/li&gt;
&lt;li&gt;对于Prometheus具有良好的兼容性，能够支持Prometheus的配置文件、PromQL、各类API、数据格式，并有一些自己的增强API。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;victoriametrics的架构&#34;&gt;VictoriaMetrics的架构&lt;/h2&gt;
&lt;p&gt;VictoriaMetrics分为单节点和集群两个方案。两种方案都提供了二进制文件、docker、helm以及operator等部署方式。对于数据采集点对于100w/s的场景，官方推荐使用单节点版，单节点版相当于一个all-in-one的包，包含了大部分的功能，但不支持告警，简单好维护。多集群的架构图如图1所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图1-victoriametrics集群版架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图1 VictoriaMetrics集群版架构图&#34; srcset=&#34;
               /blog/victoriametrics/1_hu4b0799c295d2c886c15763b6f06c706f_129414_e44f0df98ac66edde43f94b781da56e3.webp 400w,
               /blog/victoriametrics/1_hu4b0799c295d2c886c15763b6f06c706f_129414_b164cfd96aa6485afad89e6e0d24f053.webp 760w,
               /blog/victoriametrics/1_hu4b0799c295d2c886c15763b6f06c706f_129414_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/1_hu4b0799c295d2c886c15763b6f06c706f_129414_e44f0df98ac66edde43f94b781da56e3.webp&#34;
               width=&#34;760&#34;
               height=&#34;514&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图1 VictoriaMetrics集群版架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;VictorMetrics集群部分主要包含了以下几个组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vmstorage：它是一个有状态的组件，主要负责存储原始数据并返回指定标签过滤器在给定时间范围内的查询数据，集群部署的必选组件，默认端口为8482。&lt;/li&gt;
&lt;li&gt;vminsert：无状态的服务组件，主要负责接收摄取的数据并根据指标名称和标签的哈希值分散从存储到部署了vmstorage的节点中去，集群部署的必选组件，默认端口为8480。&lt;/li&gt;
&lt;li&gt;vmselect：无状态的额服务组件，面向外部终端的查询组件，根据收到的请求去各个vmstorage节点中获取数据，集群部署的必选组件，默认端口为8481。&lt;/li&gt;
&lt;li&gt;vmagent：主要负责数据指标的抓取，并将它们存储在VictoriaMetrics或其他支持remote write协议的Prometheus兼容的存储系统中，会占用本地磁盘缓存。它是一个可选组件，位于图1的Writers那层Load balancer与各个采集源之间，类似于Prometheus中pushgateway的地位。是一个可选组件，默认占用端口8429。其组件作用如图2所示：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图2-vmagent的作用&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图2 vmagent的作用&#34; srcset=&#34;
               /blog/victoriametrics/2_hu2ca8a1876025a1a8b0105c54c67abeaf_51132_dcce0ad1fd90587994b8dc924da16074.webp 400w,
               /blog/victoriametrics/2_hu2ca8a1876025a1a8b0105c54c67abeaf_51132_af661aced6b9e8032231846526bce014.webp 760w,
               /blog/victoriametrics/2_hu2ca8a1876025a1a8b0105c54c67abeaf_51132_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/2_hu2ca8a1876025a1a8b0105c54c67abeaf_51132_dcce0ad1fd90587994b8dc924da16074.webp&#34;
               width=&#34;760&#34;
               height=&#34;653&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图2 vmagent的作用
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vmalert：类似于Prometheus中的alertmanager，是一个告警的相关组件，如果不需要告警功能可以不使用该组件，是一个可选组件，默认占用端口为8880。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集群部署模式下，各个服务可以进行独立的扩展，但部署vmstorage节点之间建议互不通信和进行数据共享，单节点模式的二进制文件或镜像已经集成了三个必选组件的功能。&lt;/p&gt;
&lt;p&gt;下面我们将使用单集群的方式在K8S中对VictoriaMetrics进行部署，并验证其对于Prometheus的兼容性。&lt;/p&gt;
&lt;h2 id=&#34;victoriametrics单节点的安装和兼容性验证&#34;&gt;VictoriaMetrics单节点的安装和兼容性验证&lt;/h2&gt;
&lt;p&gt;首先，我们使用Prometheus-Operator进行Prometheus以及相关诸如node-exporter、grafana的快速安装。接着，在K8S内部署单节点的VictoriaMetrics。最后，开启远程写入将Prometheus的数据写入VictoriaMetrics中，并在grafana中浏览Prometheus和VictoriaMetrics的指标，若结果相同，说明在不使用告警功能的情况下，VictoriaMetrics可兼容替换Prometheus进行使用（单节点版不包含告警功能）。整体的组件图如图3所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图3-场景组件图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图3 场景组件图&#34; srcset=&#34;
               /blog/victoriametrics/3_hu8c390b4f40ba0ad6e0e235c71fb27f4e_8941_66e10a0c0a8fdc7c4ccf9deec2a81ffd.webp 400w,
               /blog/victoriametrics/3_hu8c390b4f40ba0ad6e0e235c71fb27f4e_8941_79197cf85ee424230b1ccf37bce6b6ff.webp 760w,
               /blog/victoriametrics/3_hu8c390b4f40ba0ad6e0e235c71fb27f4e_8941_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/3_hu8c390b4f40ba0ad6e0e235c71fb27f4e_8941_66e10a0c0a8fdc7c4ccf9deec2a81ffd.webp&#34;
               width=&#34;395&#34;
               height=&#34;201&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图3 场景组件图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;使用kube-prometheus安装prometheus相关组件&#34;&gt;使用kube-prometheus安装prometheus相关组件&lt;/h2&gt;
&lt;p&gt;首先，我们克隆和使用 kube-prometheus (&lt;a href=&#34;https://github.com/prometheus-operator/kube-prometheus&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/prometheus-operator/kube-prometheus&lt;/a&gt;) 这个项目来进行图3中蓝色、黄色以及粉色部分组件的快速安装，该项目和 prometheus-operator 的区别就类似于 Linux 内核和 CentOS/Ubuntu&lt;/p&gt;
&lt;p&gt;这些发行版的关系，真正起作用的是 Operator 去实现的，kube-prometheus 项目编写了一系列常用的监控资源清单，更加容易上手安装。不过需要注意 Kubernetes 版本和 kube-prometheus 的兼容，各个版本的兼容关系如图4所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图4-kube-prometheus项目版本兼容情况&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图4 kube-prometheus项目版本兼容情况&#34; srcset=&#34;
               /blog/victoriametrics/4_hu6a8a72cfc807a6181ad0f1781b9edbca_15234_822f5c4a507402b5cec9851b5e4bdb5b.webp 400w,
               /blog/victoriametrics/4_hu6a8a72cfc807a6181ad0f1781b9edbca_15234_fb8bf53a5c7daadfc3316cd3f826de5a.webp 760w,
               /blog/victoriametrics/4_hu6a8a72cfc807a6181ad0f1781b9edbca_15234_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/4_hu6a8a72cfc807a6181ad0f1781b9edbca_15234_822f5c4a507402b5cec9851b5e4bdb5b.webp&#34;
               width=&#34;760&#34;
               height=&#34;165&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图4 kube-prometheus项目版本兼容情况
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;由于作者本地的K8s环境为1.21版本，所以我们这里下载使用release-0.9的版本到本地，接着进行进行解压并重命名（起始目录为压缩包所在目录），并进入工作目录，命令如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tar -xvf kube-prometheus-0.9.0.tar.gz&lt;/li&gt;
&lt;li&gt;mv kube-prometheus-0.9.0 kube-prometheus&lt;/li&gt;
&lt;li&gt;cd kube-prometheus&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下一步，我们执行命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kubectl create -f manifests/setup&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这会帮我们安装创建prometheus-operator的命名空间（默认是monitoring）和所需的CRD资源。&lt;/p&gt;
&lt;p&gt;接着，执行命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kubectl wait &amp;ndash;for condition=Established &amp;ndash;all CustomResourceDefinition &amp;ndash;namespace=monitoring&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个命令会校验和等待我们所需CRD和命名空间的完成。&lt;/p&gt;
&lt;p&gt;最后，执行命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kubectl create -f manifests/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它会帮我们安装项目已经定义好的Prometheus、node-exporter、kube-state-metrics、alertmanager组件。为了后续方便使用Prometheus和grafana，我们将两个服务对应的service设置成NodePort（默认为ClusterIP）。命令为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kubectl edit svc prometheus-k8s -n monitoring&lt;/li&gt;
&lt;li&gt;kubectl edit svc grafana -n monitoring&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完成之后，总体的服务清单如图5所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5-kube-prometheus安装后的总览图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 5 kube-prometheus安装后的总览图&#34; srcset=&#34;
               /blog/victoriametrics/5_hu56c1b5422ceffea1a351d154b8ebc4ea_438243_3727531c84331085cead98a2a07c4510.webp 400w,
               /blog/victoriametrics/5_hu56c1b5422ceffea1a351d154b8ebc4ea_438243_e8a8ef8864940dc79a95d29a179851a3.webp 760w,
               /blog/victoriametrics/5_hu56c1b5422ceffea1a351d154b8ebc4ea_438243_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/5_hu56c1b5422ceffea1a351d154b8ebc4ea_438243_3727531c84331085cead98a2a07c4510.webp&#34;
               width=&#34;760&#34;
               height=&#34;530&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5 kube-prometheus安装后的总览图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们通过http://&lt;node-ip&gt;:30246就可以访问grafana了，我们可以看到kube-prometheus这个项目的grafana已经为我们关联了图5中的prometheus，具体见图6：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-6-grafana内的prometheus数据源配置&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 6 grafana内的prometheus数据源配置&#34; srcset=&#34;
               /blog/victoriametrics/6_hu6ca55a6e62f3980dd91295bfc854d4a4_258016_9be4659b80503a2f7786854835df1393.webp 400w,
               /blog/victoriametrics/6_hu6ca55a6e62f3980dd91295bfc854d4a4_258016_4df3e251132396b531affddfa9d5c30d.webp 760w,
               /blog/victoriametrics/6_hu6ca55a6e62f3980dd91295bfc854d4a4_258016_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/6_hu6ca55a6e62f3980dd91295bfc854d4a4_258016_9be4659b80503a2f7786854835df1393.webp&#34;
               width=&#34;760&#34;
               height=&#34;493&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6 grafana内的prometheus数据源配置
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;点击面板左侧的Explore，我们可以进行指标查询，此处我们查询节点的CPU使用率指标“instance:node_cpu:ratio”，查询结果如图7和图8所示（由于作者的Prometheus做了联邦配置所以结果样本会偏多，只看cnp_cluster为“local-cluster”的样本即可）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-7-prometheus数据源指标浏览页面1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 7 prometheus数据源指标浏览页面1&#34; srcset=&#34;
               /blog/victoriametrics/7_hu442c1429fdac83b2c5e75e67be3b884b_141571_b7b5ab2175bc3641c7f5adbc8f02ff75.webp 400w,
               /blog/victoriametrics/7_hu442c1429fdac83b2c5e75e67be3b884b_141571_76b2aaf7de5f94cfbeb20dd2d74fe4d2.webp 760w,
               /blog/victoriametrics/7_hu442c1429fdac83b2c5e75e67be3b884b_141571_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/7_hu442c1429fdac83b2c5e75e67be3b884b_141571_b7b5ab2175bc3641c7f5adbc8f02ff75.webp&#34;
               width=&#34;760&#34;
               height=&#34;303&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7 prometheus数据源指标浏览页面1
    &lt;/figcaption&gt;&lt;/figure&gt;

















&lt;figure  id=&#34;figure-图-8-prometheus数据源指标浏览页面2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 8 prometheus数据源指标浏览页面2&#34; srcset=&#34;
               /blog/victoriametrics/8_hu9667b3f884afa79e09cc2a180fe83022_490364_096481af418ddce36c7ae0daccf2020d.webp 400w,
               /blog/victoriametrics/8_hu9667b3f884afa79e09cc2a180fe83022_490364_a8ac3337824455562494977a55cb0a56.webp 760w,
               /blog/victoriametrics/8_hu9667b3f884afa79e09cc2a180fe83022_490364_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/8_hu9667b3f884afa79e09cc2a180fe83022_490364_096481af418ddce36c7ae0daccf2020d.webp&#34;
               width=&#34;760&#34;
               height=&#34;401&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 8 prometheus数据源指标浏览页面2
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;在k8s中部署victoriametrics&#34;&gt;在K8S中部署VictoriaMetrics&lt;/h2&gt;
&lt;p&gt;接下来我们进行VictoriaMetrics的部署，由于我们要使用VictoriaMetrics作为远程存储，所以在部署时需要为VictoriaMetrics服务挂载一个存储，此处我们使用Local PV作为其存储（生产环境一般使用NFS或者ceph）。一般来说，Local PV对应的存储介质应该是一块外挂在宿主机的磁盘或者块设备，我们这里暂时将本机节点的/Users/chris/data/k8s/vm这个目录看成是一个挂载的独立磁盘，然后我们依次准备StorageClass、PV和PVC的资源清单，其内容如下代码块所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
&lt;/code&gt;&lt;/pre&gt;&lt;center&gt;StorageClass定义&lt;/center&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: victoria-metrics-data
spec:
  accessModes:
    - ReadWriteMany
  capacity:
    storage: 10Gi
  storageClassName: local-storage
  local:
    path: /Users/chris/data/k8s/vm-operator
  persistentVolumeReclaimPolicy: Retain
  nodeAffinity:
    required:
      nodeSelectorTerms:
        - matchExpressions:
            - key: project
              operator: In
              values:
                - local-cluster
&lt;/code&gt;&lt;/pre&gt;&lt;center&gt;PV定义&lt;/center&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: victoria-metrics-data
  namespace: kube-vm
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: local-storage
&lt;/code&gt;&lt;/pre&gt;&lt;center&gt;PVC定义&lt;/center&gt;
&lt;p&gt;PV定义中我们设置了一个亲和性的nodeSelector进行使用，是因为本地存储不能随着Pod进行漂移，所以要求Pod固定到一个节点上，一旦漂移到其他节点上，另外的节点是没有对应的数据的（project=local-cluster是我们实现为node设置的一个标签对）。并且我们在StorageClass定义中创建StorageClass的时候设置了延迟绑定，当节点第一次调度的时候才进行PV与PVC的绑定过程。因为假如我们一开始就绑定了PV和PVC在node1节点，且PV的存储卷在node1节点，但Pod只能运行在node2节点，那么就会出现冲突，导致调度失败，延迟调度就是让K8S调度器的总和考虑调度规则，再Pod被调度时再考虑PVC到底应该和哪个PV进行绑定。&lt;/p&gt;
&lt;p&gt;接着，我们定义VictoriaMetrics的Deployment和它的Service，如下代码块所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: victoria-metrics
  namespace: kube-vm
spec:
  selector:
    matchLabels:
      app: victoria-metrics
  template:
    metadata:
      labels:
        app: victoria-metrics
    spec:
      volumes:
        - name: storage
          persistentVolumeClaim:
            claimName: victoria-metrics-data
      containers:
        - name: vm
          image: victoriametrics/victoria-metrics:v1.79.8
          imagePullPolicy: IfNotPresent
          args:
            - -storageDataPath=/var/lib/victoria-metrics-data
            - -retentionPeriod=1w
          ports:
            - containerPort: 8428
              name: http
          volumeMounts:
            - mountPath: /var/lib/victoria-metrics-data
              name: storage
&lt;/code&gt;&lt;/pre&gt;&lt;center&gt;VictoriaMetrics的Deployment清单&lt;/center&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: victoria-metrics
  namespace: kube-vm
spec:
  type: NodePort
  ports:
    - port: 8428
  selector:
    app: victoria-metrics
&lt;/code&gt;&lt;/pre&gt;&lt;center&gt;VictoriaMetrics的Service清单&lt;/center&gt;
&lt;p&gt;Deployment定义中，我们使用-storageDataPath参数指定了数据存储目录，-retentionPeriod参数指定了数据的保留周期为1个星期，Service中使用NodePort的方式对服务进行了暴露。&lt;/p&gt;
&lt;p&gt;最后，我们先使用命令&lt;code&gt;kubectl create ns kube-vm&lt;/code&gt;创建命名空间，再依次使用kubectl apply -f命令应用上述代码块的资源定义清单即可。部署之后的结果图，如图9所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-9-victoriametrics部署结果&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 9 VictoriaMetrics部署结果&#34; srcset=&#34;
               /blog/victoriametrics/14_hu03c1e120b4f9dd59893ba858ed2ffdac_146102_5b7fe5b69e2488d66141ba968a15870e.webp 400w,
               /blog/victoriametrics/14_hu03c1e120b4f9dd59893ba858ed2ffdac_146102_0336f27a9d70f82f253ad86250600482.webp 760w,
               /blog/victoriametrics/14_hu03c1e120b4f9dd59893ba858ed2ffdac_146102_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/14_hu03c1e120b4f9dd59893ba858ed2ffdac_146102_5b7fe5b69e2488d66141ba968a15870e.webp&#34;
               width=&#34;760&#34;
               height=&#34;241&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 9 VictoriaMetrics部署结果
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;依据图3的场景，我们需要在Prometheus中开启远程写入。我们可以在kube-promethus项目下的manifest目录下找到prometheus-prometheus.yaml文件，在清单的最后添加VictoriaMetrics在K8S中的DNS路径，并重新apply即可，如图10所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-10-prometheus开启远程写入&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 10 prometheus开启远程写入&#34; srcset=&#34;
               /blog/victoriametrics/15_hu812ed3cbf2c10361b429a002462b2095_455819_e323cb305fe06488966e2aaf3f7bb252.webp 400w,
               /blog/victoriametrics/15_hu812ed3cbf2c10361b429a002462b2095_455819_0b9d56149a054f2a87ecb5fb82f5f0af.webp 760w,
               /blog/victoriametrics/15_hu812ed3cbf2c10361b429a002462b2095_455819_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/15_hu812ed3cbf2c10361b429a002462b2095_455819_e323cb305fe06488966e2aaf3f7bb252.webp&#34;
               width=&#34;760&#34;
               height=&#34;393&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 10 prometheus开启远程写入
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;验证兼容性&#34;&gt;验证兼容性&lt;/h2&gt;
&lt;p&gt;我们使用图5部署好的grafana添加一个新的prometheus数据源，数据源地址为图14部署的VictoriaMetrics的DNS地址，并命名数据源为victoriametrics，最后使用这个数据源进行指标&lt;code&gt;instance:node_cpu:ratio&lt;/code&gt;的浏览，整个过程的截图如图11~13所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-11-使用prometheus数据源配置victoriametrics&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 11 使用prometheus数据源配置VictoriaMetrics&#34; srcset=&#34;
               /blog/victoriametrics/16_hu86efa8c6001f28d10908ae170bc8d682_289971_d69d78f0734509ed525aff6f19d61373.webp 400w,
               /blog/victoriametrics/16_hu86efa8c6001f28d10908ae170bc8d682_289971_1d64be0ae9e4ff955c72a46e265c848a.webp 760w,
               /blog/victoriametrics/16_hu86efa8c6001f28d10908ae170bc8d682_289971_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/16_hu86efa8c6001f28d10908ae170bc8d682_289971_d69d78f0734509ed525aff6f19d61373.webp&#34;
               width=&#34;760&#34;
               height=&#34;583&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 11 使用prometheus数据源配置VictoriaMetrics
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-12-victoriametrics浏览指标&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 12 VictoriaMetrics浏览指标&#34; srcset=&#34;
               /blog/victoriametrics/17_hu909bdc3ad1203433a160906d6b0f3132_209043_a5c288b1415097d20b9204204777d645.webp 400w,
               /blog/victoriametrics/17_hu909bdc3ad1203433a160906d6b0f3132_209043_4c771a935fc07cc447a261b67d03f415.webp 760w,
               /blog/victoriametrics/17_hu909bdc3ad1203433a160906d6b0f3132_209043_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/17_hu909bdc3ad1203433a160906d6b0f3132_209043_a5c288b1415097d20b9204204777d645.webp&#34;
               width=&#34;760&#34;
               height=&#34;481&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 12 VictoriaMetrics浏览指标
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-13-指标浏览结果图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 13 指标浏览结果图&#34; srcset=&#34;
               /blog/victoriametrics/18_hua0bcd80e9c33166a772677921ee1b077_526796_e74a554bf40d5790724cd93110525d4b.webp 400w,
               /blog/victoriametrics/18_hua0bcd80e9c33166a772677921ee1b077_526796_a775941900344f7f010de3296c10f637.webp 760w,
               /blog/victoriametrics/18_hua0bcd80e9c33166a772677921ee1b077_526796_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/victoriametrics/18_hua0bcd80e9c33166a772677921ee1b077_526796_e74a554bf40d5790724cd93110525d4b.webp&#34;
               width=&#34;760&#34;
               height=&#34;406&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 13 指标浏览结果图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从图13中可以观察到，跟Promethus相同，我们同样可以正常的从VictoriaMetrics获取该指标的结果数据（图中红框部分，多出一条数据是因为图5部署的Promethus有两个容器组），如官方所说VictoriaMetrics可以兼容Prometheus，并作为一个及其良好的替换方案。&lt;/p&gt;
&lt;p&gt;生产环境中，开启Prometheus的remote_write功能，会导致Prometheus占用主机资源增加，若没有告警的需求，我们可以把图3的Prometheus进行精简，直接让VictoriaMetrics使用之前Prometheus的配置，让各个exporter直接对接到VictoriaMetrics。&lt;/p&gt;
&lt;p&gt;对于有告警需求的场景，我们可以使用vmagent替代图3中Prometheus的角色，部署完整的5个组件进行Prometheus告警系统的替换。VictoriaMetrics官方也提供了类似kube-prometheus的项目vm-operator，它不但能够帮助我们管理VictoriaMetrics的相关规则配置，而且能够识别kube-prometheus中servicemonitor、podmonitor等CRD资源。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;VictoriaMetrics作为近两年新兴流行的时序数据库和监控解决方案，很好的对Prometheus性能和缺点就行了提升和补充，它能够兼容原先Prometheus监控方案进行指标的长久存储也能快速替换升级Prometheus的监控系统，可作为我们搭建系统监控模块的另一种比较好的选择。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qihoo_tech/article/details/120558834&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VictoriaMetrics 入门与实战&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.victoriametrics.com/Single-server-VictoriaMetrics.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VictoriaMetircs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>彻底搞懂 Kubernetes 中的认证</title>
      <link>https://cloudnative.to/blog/authentication-k8s/</link>
      <pubDate>Thu, 15 Sep 2022 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/authentication-k8s/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文首先介绍了K8s的访问控制过程，并对K8s认证的用户模型进行讲解。最后对认证过程中的用户证书认证以及Service Account Token认证进行举例剖析。&lt;/p&gt;
&lt;h2 id=&#34;k8s-api请求访问控制的过程&#34;&gt;K8s API请求访问控制的过程&lt;/h2&gt;
&lt;p&gt;我们知道，不论是通过kubectl客户端还是REST请求访问K8s集群，最终都需要经过API Server来进行资源的操作，生效结果会被持久化至etcd中，etcd中的数据安全就变得十分重要。为了保证etcd的安全性，K8s只允许API Server 去访问操作etcd，此时API Server就担负起了整个etcd的安全。那么K8s是如何管控和保障API Server访问过程的安全的呢？&lt;/p&gt;
&lt;p&gt;如下图1所示，整个过程可以分为4个阶段&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图1-k8s-api请求访问过程&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图1 K8s API请求访问过程&#34; srcset=&#34;
               /blog/authentication-k8s/1_hubfe8124ee1b92cd0e4130484e1055112_24777_ae69c7ac0c615578415c6430d38fd838.webp 400w,
               /blog/authentication-k8s/1_hubfe8124ee1b92cd0e4130484e1055112_24777_ac1b8faa0e776a2ea938ba260fc61d86.webp 760w,
               /blog/authentication-k8s/1_hubfe8124ee1b92cd0e4130484e1055112_24777_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/1_hubfe8124ee1b92cd0e4130484e1055112_24777_ae69c7ac0c615578415c6430d38fd838.webp&#34;
               width=&#34;525&#34;
               height=&#34;295&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图1 K8s API请求访问过程
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;整体过程简述：请求发起方进行K8s API请求，经过Authentication（认证）、Authorization（鉴权）、AdmissionControl（准入控制）三个阶段的校验，最后把请求转化为对K8s对象的变更操作持久化至etcd中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;认证阶段&lt;/strong&gt;。当请求发起方建立与API Server的安全连接后，进入请求的认证阶段（图中步骤1）。认证的方式主要有：客户端证书、密码、普通token、bootstrap token和JWT认证(主要用于Service Account)。认证模块会检查请求头或者客户端证书的内容，我们可以同时配置一种或几种方式对请求进行认证。多种认证方式会被依次执行，只要一种方式通过，请求便得到合法认证。当所有方式都未通过时，会返回401状态码并中断请求。认证解决的问题是校验访问方是否合法并识别其身份。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;鉴权阶段&lt;/strong&gt;。K8s API访问请求必须包括请求者的用户名、请求的操作以及操作对象，该阶段就是对用户的操作合法性进行校验。如果现有策略声明用户具有完成请求操作的权限，则对请求进行授权。K8s支持ABAC模式、RBAC模式、Webhook模式等多种授权模块。同样的，当多个授权模块被配置时，请求只要满足其中任意一种授权规则便会被放行，反之，API Server会返回403状态码并终止该请求。鉴权是为了判别用户的操作权限范围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准入控制阶段&lt;/strong&gt;。准入控制是请求操作被持久化到etcd之前的“拦截器”。准入控制模块由多个“准入控制器”构成，“准入控制器”就是一段自定义代码，它们能够在请求对K8s创建、修改、删除或者连接一个K8s对象时生效。官方自带了30多个准入控制器可供使用，同时支持用户扩展。准入控制器的作用往往是检查请求的规范性或者赋予一些默认信息。例如，我们在创建一个pod时，准入控制器会检查提交的信息是否符合pod资源的规范，并对请求中没有明确规定的字段，设置对应的默认值填充到请求中。与前两个阶段不同的是，只要有一个“准入校验”逻辑未通过，那么请求就会被拒绝。若请求仅仅是读取一个对象，“准入控制器”将不会生效。准入控制作用于K8s中的对象，通过校验规范和默认值的设置，能够保证系统的安全可靠。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久化阶段&lt;/strong&gt;。当我们的请求通过了前面三个阶段的校验，它会被转换为一个 K8s 对象相应的变更请求，最终持久化到etcd中。&lt;/p&gt;
&lt;p&gt;需要注意的是，认证授权过程只存在HTTPS形式的API中。即是说，客户端使用HTTP连接到API Server，是不会进行认证授权的。但API Server的非安全认证端口 8080 已经在v1.12中废弃了，全面使用了HTTPS。接下来让我们来详细了解下K8s的认证。&lt;/p&gt;
&lt;h2 id=&#34;k8s的用户模型&#34;&gt;K8s的用户模型&lt;/h2&gt;
&lt;p&gt;从图1中我们可以看出，K8s的用户主要分为两类：通过客户端进行连接的人类操作者和K8s内诸如进程、控制器等非人类操作的客户端。我们称前者为Normal Users（常规用户），后者为Service Account（服务账户）。因为K8s内没有为Normal Users定义存储对象，我们无法像操作pod一样在K8s内部管理这类用户，它们通常是由外部服务进行管理，借由证书凭证或者静态配置文件进行认证。而Service Account可由K8s API直接进行管理。&lt;/p&gt;
&lt;p&gt;下表给出了其主要区别:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类目&lt;/th&gt;
&lt;th&gt;Normal Users&lt;/th&gt;
&lt;th&gt;Service Account&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;针对对象&lt;/td&gt;
&lt;td&gt;人类用户&lt;/td&gt;
&lt;td&gt;进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;范围&lt;/td&gt;
&lt;td&gt;全cluster唯一&lt;/td&gt;
&lt;td&gt;namespace&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设计目的&lt;/td&gt;
&lt;td&gt;与企业数据库同步，在用户级别进行操作权限的控制&lt;/td&gt;
&lt;td&gt;更轻量化，在任务进程级别进行管控&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主要认证方法&lt;/td&gt;
&lt;td&gt;Basic认证、X509证书认证&lt;/td&gt;
&lt;td&gt;Service Account token认证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;例子&lt;/td&gt;
&lt;td&gt;我们使用kubectl操作客户端，K8s是把我们映射成kubectl所使用客户端证书中CN字段所对应的信息，而不是真正你身份证上的信息&lt;/td&gt;
&lt;td&gt;Pod等通过API Server从etcd中检索和更新自身状态时，API Server对其进行身份认证，只有通过校验的pod才能获取信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们可以一次性启用多种认证方式，但通常应该至少包含以下两方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;针对于Service Account的token方式；&lt;/li&gt;
&lt;li&gt;至少一种用于Normal Users身份验证的其他方式。
通过认证的用户会被包含在名为system：authenticated的group中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;basic认证&#34;&gt;Basic认证&lt;/h2&gt;
&lt;p&gt;认证方法是管理员将password、user、uid、group信息加入到csv格式的静态文件中，并在API Server启动时使用参数&amp;ndash;Basic-authfile={文件路径}，指定使用的凭证文件。之后，认证凭证就将一直有效，只有在重启API Server时才能修改密码。凭证文件中的数据示例如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;password,user,uid,&amp;#34;group1,group2,group3&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，当一个user对应多个组，多个group之间需要用逗号分隔并且使用双引号。&lt;/p&gt;
&lt;p&gt;客户端请求时，需要在头部加入Basic BASE64ENCODED(USER:PASSWORD)，服务端会校验用户名和密码。该方式使用简单，但是因为用户名和密码使用明文，用户名和密码修改必须重启服务，十分不灵活，一般只用于测试场景。&lt;/p&gt;
&lt;h2 id=&#34;x509证书认证&#34;&gt;X509证书认证&lt;/h2&gt;
&lt;p&gt;本文我们假设读者已经了解数字证书和 CA 的基本原理，若不了解可以先阅读下这篇文章&lt;a href=&#34;https://www.zhaohuabing.com/post/2020-03-19-pki/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《数字证书原理》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;K8s中组件之间通信，证书的验证是在协议层通过TLS完成的，TLS验证分为2种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器单向认证：服务器端持有证书证明自己身份，用于服务端不关心客户端身份而客户端需要确认服务器身份的场景。例如火车票购票网站，我们必须保证其是官方而非恶意服务器，但网站允许任何客户端进行连接访问；&lt;/li&gt;
&lt;li&gt;双向TLS认证：双方都要持有证书，并验证对方证书确认身份。一般用于服务端持有信息比较敏感，只有特定客户端才能访问的场景。例如：K8s内组件提供的接口往往包含集群内部信息，若被非法访问会影响整体安全，所以K8s内部组件之间都是双向TLS认证。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;双向认证的简化过程如下图2所示&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图2-双向tls过程&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图2 双向TLS过程&#34; srcset=&#34;
               /blog/authentication-k8s/2_hu0fb8997a8d2b30285500fae6fea37a06_41825_93c13a024038ef1c136267b29d6cc424.webp 400w,
               /blog/authentication-k8s/2_hu0fb8997a8d2b30285500fae6fea37a06_41825_fec882c9093e583e95bde7bfd9e8dc4c.webp 760w,
               /blog/authentication-k8s/2_hu0fb8997a8d2b30285500fae6fea37a06_41825_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/2_hu0fb8997a8d2b30285500fae6fea37a06_41825_93c13a024038ef1c136267b29d6cc424.webp&#34;
               width=&#34;760&#34;
               height=&#34;309&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图2 双向TLS过程
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当两个组件进行双向TLS认证时，会涉及到下表中的相关文件：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;服务端证书&lt;/td&gt;
&lt;td&gt;包含服务端公钥和服务端身份信息&lt;/td&gt;
&lt;td&gt;通过根证书手动或者kubeadm自动生成的API Server服务端证书文件apiserver.crt&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务器私钥&lt;/td&gt;
&lt;td&gt;主要用于TLS认证时进行数字签名，证明自己是服务端证书的拥有者&lt;/td&gt;
&lt;td&gt;通过根证书手动或者kubeadm生成的API Server服务端私钥文件apiserver.key&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;客户端证书&lt;/td&gt;
&lt;td&gt;包含客户端公钥和客户端身份信息&lt;/td&gt;
&lt;td&gt;由同一个CA根证书签发的.crt文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;客户端私钥&lt;/td&gt;
&lt;td&gt;主要用于TLS认证时进行数字签名，证明自己是客户端证书的拥有者&lt;/td&gt;
&lt;td&gt;由同一个CA根证书签发的.key文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务端CA根证书&lt;/td&gt;
&lt;td&gt;签发服务端证书的 CA 根证书&lt;/td&gt;
&lt;td&gt;通过openssl等工具生成的ca.crt文件,并在服务端启动时进行指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;客户端CA根证书&lt;/td&gt;
&lt;td&gt;签发客户端证书的 CA 根证书&lt;/td&gt;
&lt;td&gt;通过openssl等工具生成的ca.crt文件,并在客户端启动时进行指定(一般与服务端使用一个)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面我们用一个例子来演示证书签发并进行客户端配置的过程, 演示的K8s环境已经存在CA根证书文件以及API Server文件，文件和目录情况如图3所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图3-文件和目录情况图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图3 文件和目录情况图&#34; srcset=&#34;
               /blog/authentication-k8s/3_hue3781dad79719ec85ec6a02f6cf3aeb7_246740_a3371881a89a5753a3dd450f4cd0d878.webp 400w,
               /blog/authentication-k8s/3_hue3781dad79719ec85ec6a02f6cf3aeb7_246740_0fb33d50af7048046693427827d56ddc.webp 760w,
               /blog/authentication-k8s/3_hue3781dad79719ec85ec6a02f6cf3aeb7_246740_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/3_hue3781dad79719ec85ec6a02f6cf3aeb7_246740_a3371881a89a5753a3dd450f4cd0d878.webp&#34;
               width=&#34;760&#34;
               height=&#34;56&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图3 文件和目录情况图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其中ca.crt是我们使用的CA根证书，apiserver.crt是我们K8s API Server的服务端证书文件，它由ca.crt根证书进行签发和配置，例子中API Server的启动参数如图4所示:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图4-api-server的启动配置&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图4 API Server的启动配置&#34; srcset=&#34;
               /blog/authentication-k8s/4_huf8b0e0b27451f6612c835ece317b0408_1459877_a3e6f0ffe3f5e753b9a7a2ee7ee8a161.webp 400w,
               /blog/authentication-k8s/4_huf8b0e0b27451f6612c835ece317b0408_1459877_c2c66428e0ad5e13956395107f0c0daf.webp 760w,
               /blog/authentication-k8s/4_huf8b0e0b27451f6612c835ece317b0408_1459877_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/4_huf8b0e0b27451f6612c835ece317b0408_1459877_a3e6f0ffe3f5e753b9a7a2ee7ee8a161.webp&#34;
               width=&#34;760&#34;
               height=&#34;752&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图4 API Server的启动配置
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;红框部分信息分别指明了API Server所使用的CA根证书、服务端证书和服务端私钥的路径。签发用户证书步骤如下(以openssl工具为例):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成私钥&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图5-生成用户私钥&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图5 生成用户私钥&#34; srcset=&#34;
               /blog/authentication-k8s/5_hu66e6f1580a4b0a8a01a3c5d187dda74a_496542_0e0750c0d4323130396230f967847e21.webp 400w,
               /blog/authentication-k8s/5_hu66e6f1580a4b0a8a01a3c5d187dda74a_496542_2cfe4625957237e896a814bc8eb91298.webp 760w,
               /blog/authentication-k8s/5_hu66e6f1580a4b0a8a01a3c5d187dda74a_496542_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/5_hu66e6f1580a4b0a8a01a3c5d187dda74a_496542_0e0750c0d4323130396230f967847e21.webp&#34;
               width=&#34;760&#34;
               height=&#34;122&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图5 生成用户私钥
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用私钥为用户生成签署请求文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图6-生成签署请求文件&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图6 生成签署请求文件&#34; srcset=&#34;
               /blog/authentication-k8s/6_hua9216d3ded00945c2cd71104f5d437b5_249475_49eec9cc278e8adbbf817f4c45e64611.webp 400w,
               /blog/authentication-k8s/6_hua9216d3ded00945c2cd71104f5d437b5_249475_cea52ee404b39522914fb501c3d9734d.webp 760w,
               /blog/authentication-k8s/6_hua9216d3ded00945c2cd71104f5d437b5_249475_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/6_hua9216d3ded00945c2cd71104f5d437b5_249475_49eec9cc278e8adbbf817f4c45e64611.webp&#34;
               width=&#34;760&#34;
               height=&#34;57&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图6 生成签署请求文件
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;命令中指定的CN是Common Name的缩写，代表最终生成客户端证书认证通过后在K8s内被识别的用户名，O是Organization的缩写，代表被识别用户所属的组。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;使用服务端信任的CA其签署证书&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图7-签署证书&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图7 签署证书&#34; srcset=&#34;
               /blog/authentication-k8s/7_hu39d51431bc0094910805a656e13260b5_254109_bd6c09d2132fccd9eea56047bc105f5e.webp 400w,
               /blog/authentication-k8s/7_hu39d51431bc0094910805a656e13260b5_254109_34273aed3f7c92512fe50a16dc36d89a.webp 760w,
               /blog/authentication-k8s/7_hu39d51431bc0094910805a656e13260b5_254109_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/7_hu39d51431bc0094910805a656e13260b5_254109_bd6c09d2132fccd9eea56047bc105f5e.webp&#34;
               width=&#34;760&#34;
               height=&#34;90&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图7 签署证书
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;至此，一个客户端证书便签发完毕了。我们可以查看其中的内容：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图8-my-usercrt&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图8 my-user.crt&#34; srcset=&#34;
               /blog/authentication-k8s/8_hudbee336d575ad782182e972f0f347830_661048_d5ec8663215a5161628e936236685ce1.webp 400w,
               /blog/authentication-k8s/8_hudbee336d575ad782182e972f0f347830_661048_501bbc4a12e899f2bca1fb59a427dc49.webp 760w,
               /blog/authentication-k8s/8_hudbee336d575ad782182e972f0f347830_661048_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/8_hudbee336d575ad782182e972f0f347830_661048_d5ec8663215a5161628e936236685ce1.webp&#34;
               width=&#34;760&#34;
               height=&#34;335&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图8 my-user.crt
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其中CN和O的信息即来自步骤2所输入，K8s通过这两个信息确定访问用户的信息，示意图如9所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图9-用户信息认证示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图9 用户信息认证示意图&#34; srcset=&#34;
               /blog/authentication-k8s/9_hu1f455efa49ea7895988b97e48d1278b7_21417_8c0a1f6bae18f66305421ad96aff226e.webp 400w,
               /blog/authentication-k8s/9_hu1f455efa49ea7895988b97e48d1278b7_21417_2af929705660201f95c28e1c8c1e6800.webp 760w,
               /blog/authentication-k8s/9_hu1f455efa49ea7895988b97e48d1278b7_21417_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/9_hu1f455efa49ea7895988b97e48d1278b7_21417_8c0a1f6bae18f66305421ad96aff226e.webp&#34;
               width=&#34;653&#34;
               height=&#34;263&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图9 用户信息认证示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;那么如何配置客户端才能使用这个证书呢？K8s的每个客户端（例如：kubectl）都有一个配置文件用来记录客户端证书验证相关信息，我们称为kubeconfig。K8s中的每个组件都有一个这样的配置文件来关联集群、用户以及证书的情况，我们以kubectl为例，来说明如何使用kubeconfig：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看当前kubectl的配置文件内容。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;默认情况下，kubectl命令从$HOME/.kube目录下查找一个名字叫做config的文件作为kubeconfig，我们也可以用命令&lt;code&gt;kubectl config view&lt;/code&gt;来列出相关配置内容，结果如图10所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图10-kubectl-config-view结果图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图10 kubectl config view结果图&#34; srcset=&#34;
               /blog/authentication-k8s/10_huf1b919d22dcb342a96cb22ac13f59775_1098266_3a7d7d68fbff6af59049941a4a1a5cbd.webp 400w,
               /blog/authentication-k8s/10_huf1b919d22dcb342a96cb22ac13f59775_1098266_e00920a1d15394fd9d4c6e07b24e04a8.webp 760w,
               /blog/authentication-k8s/10_huf1b919d22dcb342a96cb22ac13f59775_1098266_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/10_huf1b919d22dcb342a96cb22ac13f59775_1098266_3a7d7d68fbff6af59049941a4a1a5cbd.webp&#34;
               width=&#34;578&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图10 kubectl config view结果图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clusters: 集群列表。包含访问 API Server的URL、认证信息、名称等；&lt;/li&gt;
&lt;li&gt;contexts: kubectl 的可用上下文列表，标明了用户和集群的使用映射关系；&lt;/li&gt;
&lt;li&gt;users: 用户列表，包含访问 API Server 时的客户端证书信息、私钥以及名称；&lt;/li&gt;
&lt;li&gt;current-context: kubectl当前使用的上下文名称，即上下文列表中的某个特定项名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubectl配置kubeconfig后与集群进行交互时的整体结构如图11所示&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图11-kubectl交互整体结构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图11 kubectl交互整体结构图&#34; srcset=&#34;
               /blog/authentication-k8s/11_hu5509616b3e33c28cc5b144511ab0f6c7_18737_2b9c1e87691f821adce62f8639d81c4d.webp 400w,
               /blog/authentication-k8s/11_hu5509616b3e33c28cc5b144511ab0f6c7_18737_191d1f751858c0cd2104c5b125e6cd6e.webp 760w,
               /blog/authentication-k8s/11_hu5509616b3e33c28cc5b144511ab0f6c7_18737_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/11_hu5509616b3e33c28cc5b144511ab0f6c7_18737_2b9c1e87691f821adce62f8639d81c4d.webp&#34;
               width=&#34;721&#34;
               height=&#34;501&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图11 kubectl交互整体结构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;建立用户和证书的关系&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图12-建立用户证书关系&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图12 建立用户证书关系&#34; srcset=&#34;
               /blog/authentication-k8s/12_hu0b1d2a6e5eea00bd092ec65dd08324c4_487277_7d3b545937455c3a6125f9b840a4c030.webp 400w,
               /blog/authentication-k8s/12_hu0b1d2a6e5eea00bd092ec65dd08324c4_487277_d8ec831a1140ef50bcbaf8b48fc9c4bf.webp 760w,
               /blog/authentication-k8s/12_hu0b1d2a6e5eea00bd092ec65dd08324c4_487277_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/12_hu0b1d2a6e5eea00bd092ec65dd08324c4_487277_7d3b545937455c3a6125f9b840a4c030.webp&#34;
               width=&#34;760&#34;
               height=&#34;88&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图12 建立用户证书关系
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;再次使用&lt;code&gt;kubectl config view&lt;/code&gt;查看配置可以发现多了一个user的配置项&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图13-新增的用户配置&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图13 新增的用户配置&#34; srcset=&#34;
               /blog/authentication-k8s/13_hue4ebf15a86d418d9afb4788e12753679_394210_cbd58d1f3c0e7ca7aea7ddb265c6eac2.webp 400w,
               /blog/authentication-k8s/13_hue4ebf15a86d418d9afb4788e12753679_394210_34838b390f116e73120b8adad6004e8e.webp 760w,
               /blog/authentication-k8s/13_hue4ebf15a86d418d9afb4788e12753679_394210_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/13_hue4ebf15a86d418d9afb4788e12753679_394210_cbd58d1f3c0e7ca7aea7ddb265c6eac2.webp&#34;
               width=&#34;706&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图13 新增的用户配置
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;把集群信息和用户信息进行关联&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图14-关联集群和用户信息&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图14 关联集群和用户信息&#34; srcset=&#34;
               /blog/authentication-k8s/14_hu38f7b8881eb51f60bf574bee04b4bb22_341144_fedb280997ec3d8a2f1319b469a40ea4.webp 400w,
               /blog/authentication-k8s/14_hu38f7b8881eb51f60bf574bee04b4bb22_341144_b838c949f91b66adcc7d5b0a4234d49c.webp 760w,
               /blog/authentication-k8s/14_hu38f7b8881eb51f60bf574bee04b4bb22_341144_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/14_hu38f7b8881eb51f60bf574bee04b4bb22_341144_fedb280997ec3d8a2f1319b469a40ea4.webp&#34;
               width=&#34;760&#34;
               height=&#34;172&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图14 关联集群和用户信息
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图15演示首先由默认的context中管理员权限的证书查看pods的情况，接着切换到我们新添加的chris用户再查看default空间下pods的情况对比：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图15-上下文切换使用对比&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图15 上下文切换使用对比&#34; srcset=&#34;
               /blog/authentication-k8s/15_huaec4a6291423eb5f89f6f5c3976c30f2_952885_35814e47068faf4b458706018d975976.webp 400w,
               /blog/authentication-k8s/15_huaec4a6291423eb5f89f6f5c3976c30f2_952885_902ccfb9b04621661f8b225ad33d0687.webp 760w,
               /blog/authentication-k8s/15_huaec4a6291423eb5f89f6f5c3976c30f2_952885_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/15_huaec4a6291423eb5f89f6f5c3976c30f2_952885_35814e47068faf4b458706018d975976.webp&#34;
               width=&#34;760&#34;
               height=&#34;328&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图15 上下文切换使用对比
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们发现，开始我们使用Kubernetes-admin99用户能够正常查询defaut下的pod信息，但切换到上下文chris@cluster99后，访问被阻止了，但是用户没有认证失败，chris用户被正确识别了。这是因为我们虽然通过了认证阶段，但是在第二阶段（鉴权阶段），我们并没有为chris用户添加相应的操作权限导致（权限控制部分我们讲解），至此对于用户的认证已经生效。&lt;/p&gt;
&lt;p&gt;使用x509证书认证相对Basic认证来说显然会更安全，只要证书不泄露，便可认为是安全的。但目前却没有便捷的方案注销证书，若使用证书轮转，则需要重新办法所有证书。所以使用x509证书认证适用于Kubernetes内部组件之间认证，普通用户认证并不推荐通过证书的形式进行认证。&lt;/p&gt;
&lt;p&gt;图16列出了K8s中各个主要组件证书的使用情况&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图16-k8s主要组件证书使用情况&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图16 K8s主要组件证书使用情况&#34; srcset=&#34;
               /blog/authentication-k8s/16_hu1b015a9e5097a8ec9f762e27de1b2c6b_16345_3e294c1fb02c05431d769c97b4135e0c.webp 400w,
               /blog/authentication-k8s/16_hu1b015a9e5097a8ec9f762e27de1b2c6b_16345_43dc1022746f223045874db1b7ebc25f.webp 760w,
               /blog/authentication-k8s/16_hu1b015a9e5097a8ec9f762e27de1b2c6b_16345_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/16_hu1b015a9e5097a8ec9f762e27de1b2c6b_16345_3e294c1fb02c05431d769c97b4135e0c.webp&#34;
               width=&#34;658&#34;
               height=&#34;391&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图16 K8s主要组件证书使用情况
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其中kubelet即作为服务端为API Server提供主机运行情况，同时又作为客户端从API Server中获取信息所以既存在客户端证书又存在服务端证书，API Server同理，其他组件只作为客户端从API Server中获取信息，所以拥有客户端证书即可。&lt;/p&gt;
&lt;h2 id=&#34;service-account-token认证&#34;&gt;Service Account token认证&lt;/h2&gt;
&lt;p&gt;Service Account是K8s中唯一能够通过API自己管理的实体账号。它主要用于Pod访问API Server。每个namespace创建的时候，K8s会自动在这个namespace下面创建一个默认的Service Account和对应的secret实例，该Service Account只能访问这个namespace的资源。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图17-default空间下的service-account和其对应的secret&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图17 default空间下的Service Account和其对应的secret&#34; srcset=&#34;
               /blog/authentication-k8s/17_hue86652601d60b95cc5c11042cbbe3885_391958_84dd149e366a902d3ddd2a05ef7cb3fe.webp 400w,
               /blog/authentication-k8s/17_hue86652601d60b95cc5c11042cbbe3885_391958_24b9532b7f05de43ab6a66314484b6b4.webp 760w,
               /blog/authentication-k8s/17_hue86652601d60b95cc5c11042cbbe3885_391958_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/17_hue86652601d60b95cc5c11042cbbe3885_391958_84dd149e366a902d3ddd2a05ef7cb3fe.webp&#34;
               width=&#34;760&#34;
               height=&#34;292&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图17 default空间下的Service Account和其对应的secret
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Service Account包含了namespace、token 和 ca三部分内容，通过base64编码保存于对应的 secret 中。namespace 指定了Pod所属的namespace，ca用于生成和验证 token，token用作身份验证。三者都通过mount的方式挂载在pod文件系统的目录 /var/run/secrets/kubernetes.io/serviceaccount/下。若创建的pod未自己指定Service Account，K8s会为其绑定默认的Service Account。图18、图19和图20展示了上述内容。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图18-service-account对应secret内容&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图18 Service Account对应secret内容&#34; srcset=&#34;
               /blog/authentication-k8s/18_huad0b2497c175de7a826016100ad82a7c_1295371_97b9d3c7cec8bdf8fb53fdb29262222e.webp 400w,
               /blog/authentication-k8s/18_huad0b2497c175de7a826016100ad82a7c_1295371_109b5e5f5245c28b7963821e6b2f1816.webp 760w,
               /blog/authentication-k8s/18_huad0b2497c175de7a826016100ad82a7c_1295371_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/18_huad0b2497c175de7a826016100ad82a7c_1295371_97b9d3c7cec8bdf8fb53fdb29262222e.webp&#34;
               width=&#34;760&#34;
               height=&#34;212&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图18 Service Account对应secret内容
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图19-default空间下的pod绑定默认service-account&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图19 default空间下的pod绑定默认Service Account&#34; srcset=&#34;
               /blog/authentication-k8s/19_hu69149bf896849991b14b5e9525d572ae_1391655_e773f3e8f38676c255fc03bb5ee34029.webp 400w,
               /blog/authentication-k8s/19_hu69149bf896849991b14b5e9525d572ae_1391655_9b62f3e6ad0fb24bbf70157bd3887c58.webp 760w,
               /blog/authentication-k8s/19_hu69149bf896849991b14b5e9525d572ae_1391655_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/19_hu69149bf896849991b14b5e9525d572ae_1391655_e773f3e8f38676c255fc03bb5ee34029.webp&#34;
               width=&#34;760&#34;
               height=&#34;523&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图19 default空间下的pod绑定默认Service Account
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图20-挂载目录下的内容&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图20 挂载目录下的内容&#34; srcset=&#34;
               /blog/authentication-k8s/20_hu409ed341600c71c004f6267688e18362_138200_e5b1406fa31486ce5f19c47d5dbd0475.webp 400w,
               /blog/authentication-k8s/20_hu409ed341600c71c004f6267688e18362_138200_999113175203063b39544dcabddaf415.webp 760w,
               /blog/authentication-k8s/20_hu409ed341600c71c004f6267688e18362_138200_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/20_hu409ed341600c71c004f6267688e18362_138200_e5b1406fa31486ce5f19c47d5dbd0475.webp&#34;
               width=&#34;760&#34;
               height=&#34;165&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图20 挂载目录下的内容
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当为一个Pod指定了Service Account后，K8s会为这个Service Account生成一个JWT（JSON Web Token），并使用secret将该token加载到pod上。JWT认证机制的原理也是通过CA根证书进行签名和公私钥校验token。其中公钥和私钥分别被配置到了API Server和Controller-Manager的命令行参数中。如图21和图22所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图21-部分api-server启动参数&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图21 部分API Server启动参数）&#34; srcset=&#34;
               /blog/authentication-k8s/21_hu0975a78e4f0e8f8c39a26c0ae5e5f0b7_59985_d017f0350363a026c30b45ea4a2a46a2.webp 400w,
               /blog/authentication-k8s/21_hu0975a78e4f0e8f8c39a26c0ae5e5f0b7_59985_9abb5979e26d074cc4945090621bfbc0.webp 760w,
               /blog/authentication-k8s/21_hu0975a78e4f0e8f8c39a26c0ae5e5f0b7_59985_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/21_hu0975a78e4f0e8f8c39a26c0ae5e5f0b7_59985_d017f0350363a026c30b45ea4a2a46a2.webp&#34;
               width=&#34;749&#34;
               height=&#34;84&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图21 部分API Server启动参数）
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图22-部分controller-manager启动参数&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图22 部分Controller-Manager启动参数&#34; srcset=&#34;
               /blog/authentication-k8s/22_hu356c7e7eceb563101040ddd2d4067b1b_57631_07530e853011c5fe02e96e4152b362dd.webp 400w,
               /blog/authentication-k8s/22_hu356c7e7eceb563101040ddd2d4067b1b_57631_9e4bf88fe9cbc82e90cfee1af64ea184.webp 760w,
               /blog/authentication-k8s/22_hu356c7e7eceb563101040ddd2d4067b1b_57631_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/22_hu356c7e7eceb563101040ddd2d4067b1b_57631_07530e853011c5fe02e96e4152b362dd.webp&#34;
               width=&#34;760&#34;
               height=&#34;55&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图22 部分Controller-Manager启动参数
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;之后Pod便可使用token来访问API Server了。API Server再验证对应token信息，就能知道这个token是对应Service Account，最后识别到对应Service Account的权限。图23展示了K8s使用和验证Service Account Token的过程。图片来源于文章：https://cloudnative.to/blog/k8s-certificate/#kube-apiserver-%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图23-service-accounttoken的使用和验证过程&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图23 Service AccountToken的使用和验证过程&#34; srcset=&#34;
               /blog/authentication-k8s/23_hue896d8f3f666cceb652b6782801f7485_39591_2404c3a95f5532d120bafac6be7dc1fd.webp 400w,
               /blog/authentication-k8s/23_hue896d8f3f666cceb652b6782801f7485_39591_b1745334529ccdb5568b129dbdc9893f.webp 760w,
               /blog/authentication-k8s/23_hue896d8f3f666cceb652b6782801f7485_39591_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/23_hue896d8f3f666cceb652b6782801f7485_39591_2404c3a95f5532d120bafac6be7dc1fd.webp&#34;
               width=&#34;760&#34;
               height=&#34;462&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图23 Service AccountToken的使用和验证过程
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;与创建namespace创建defalut类似，若我们通过K8s API的方式创建Service Account，它一样会创建对应的secret。当Pod使用该Service Account的token去API Server认证，API Server一样可以识别Token对应的Service Account从而通过认证（与证书认证相同的是若没有进行授权，一样无法通过鉴权阶段）。如图24和图25所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图24-手动创建service-account&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图24 手动创建Service Account&#34; srcset=&#34;
               /blog/authentication-k8s/24_hu62e735b989478ab3224825a6598a80ef_909832_74e5e93bf1a59ce2706c7431bf2c4c1c.webp 400w,
               /blog/authentication-k8s/24_hu62e735b989478ab3224825a6598a80ef_909832_1b582383ed62c0b97013f9450c2182ac.webp 760w,
               /blog/authentication-k8s/24_hu62e735b989478ab3224825a6598a80ef_909832_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/24_hu62e735b989478ab3224825a6598a80ef_909832_74e5e93bf1a59ce2706c7431bf2c4c1c.webp&#34;
               width=&#34;760&#34;
               height=&#34;527&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图24 手动创建Service Account
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图25-查看验证创建service-account对应secret&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图25 查看验证创建Service Account对应secret&#34; srcset=&#34;
               /blog/authentication-k8s/25_hu570d8e29b95c165452c670bcb60e2b3c_1875620_19167a605fb80bbefcbb96c236b39fb8.webp 400w,
               /blog/authentication-k8s/25_hu570d8e29b95c165452c670bcb60e2b3c_1875620_3fb0c165ec689716aeb9fab7d777983f.webp 760w,
               /blog/authentication-k8s/25_hu570d8e29b95c165452c670bcb60e2b3c_1875620_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/authentication-k8s/25_hu570d8e29b95c165452c670bcb60e2b3c_1875620_19167a605fb80bbefcbb96c236b39fb8.webp&#34;
               width=&#34;760&#34;
               height=&#34;314&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图25 查看验证创建Service Account对应secret
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;K8s的访问控制有4个阶段，其中认证阶段的主要对象为Normal Users和Service Account，单单通过认证并不能访问API Server；&lt;/li&gt;
&lt;li&gt;X509证书认证是K8s中针对用户的常用认证方式，其组件间只用了双向TLS的认证方式，若客户端需要访问API Server 除了生成客户端证书同时还要配置对应的kubeconfig；&lt;/li&gt;
&lt;li&gt;Service Account Token是K8s针对Service Account的主要认证方式，其认证原理是基于JWT，其中的证书只用于验证token，最后API Service对于Service Account的识别是基于传递给API Service的token；&lt;/li&gt;
&lt;li&gt;Service Account主要设计用于K8s内部，Pod等进程是主要使用者，它是K8s唯一自主管理的认证标识，创建Service Account后会生成对应的secret。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/2016079&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://cloud.tencent.com/developer/article/2016079&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.javashuo.com/article/p-gocttrgh-ny.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.javashuo.com/article/p-gocttrgh-ny.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/blog/k8s-certificate/#kube-apiserver-%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://cloudnative.to/blog/k8s-certificate/#kube-apiserver-%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/468010077&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://zhuanlan.zhihu.com/p/468010077&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/authentication/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubernetes.io/docs/reference/access-authn-authz/authentication/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
