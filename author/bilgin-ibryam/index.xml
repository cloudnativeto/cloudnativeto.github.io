<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bilgin Ibryam | 云原生社区（中国）</title>
    <link>https://cloudnative.to/author/bilgin-ibryam/</link>
      <atom:link href="https://cloudnative.to/author/bilgin-ibryam/index.xml" rel="self" type="application/rss+xml" />
    <description>Bilgin Ibryam</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://cloudnative.to/author/bilgin-ibryam/avatar_hue4c6e3ace37b6f1a17e4d3fa34c4b399_24612_270x270_fill_q75_lanczos_center.jpg</url>
      <title>Bilgin Ibryam</title>
      <link>https://cloudnative.to/author/bilgin-ibryam/</link>
    </image>
    
    <item>
      <title>后 Serverless 时代的云计算趋势分析</title>
      <link>https://cloudnative.to/blog/cloud-computing-post-serverless-trends/</link>
      <pubDate>Fri, 02 Feb 2024 13:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-computing-post-serverless-trends/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://www.infoq.com/articles/cloud-computing-post-serverless-trends/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud-Computing in the Post-Serverless Era: Current Trends and beyond&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要：这篇文章主要讨论了未来云计算领域的三大趋势：从基本元素到云构件作为服务的转变、从超大规模到超专业化的转变、以及从基础设施到组合式编程作为服务的转变。作者指出，未来的云服务将更加集成编程构件，使得开发人员能够无缝地使用他们喜欢的编程语言来组合应用程序。文章强调了这些趋势对开发人员和运营团队的影响，并指出了这些变化将如何塑造未来以开发人员为中心的云服务。&lt;/p&gt;
&lt;h2 id=&#34;主要观点&#34;&gt;主要观点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无服务器计算正在超越其最初的范围，函数部分或完全被多才多艺的云构建取代，标志着云架构的新时代。&lt;/li&gt;
&lt;li&gt;云市场正朝着高度专业化的垂直多云服务转变，提供独特的、精细粒度的功能，专门满足开发人员的需求。&lt;/li&gt;
&lt;li&gt;即将推出的云服务将充满构建，改变开发人员处理路由、过滤和事件触发等任务的方式，使其更高效和用户友好。&lt;/li&gt;
&lt;li&gt;从基础设施即代码转向构建即代码的趋势显著，开发人员使用熟悉的编程语言进行更直观的云服务配置。&lt;/li&gt;
&lt;li&gt;微服务正在云景观中重新定义，从仅仅是架构边界演变为组织边界，在统一的开发者语言下整合各种云构建。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AWS Lambda 将在今年迎来其 10 周年之际，无服务器计算不再仅限于“函数即服务”（FaaS）。今天，无服务器描述了不需要手动配置、提供按需自动扩展和使用基于消耗的定价的云服务。这一转变是云计算中更广泛演变的一部分，无服务器技术不断变革。本文关注无服务器之后的未来，探讨云景观将如何发展超越当前的超级扩展模型以及对开发人员和运营团队的影响。我将探讨塑造这一演变的前三大趋势。&lt;/p&gt;
&lt;h2 id=&#34;从基本构件到构建即服务&#34;&gt;从基本构件到构建即服务&lt;/h2&gt;
&lt;p&gt;在软件开发中，“模块”或“组件”通常指的是执行一组协同操作的自包含软件单元。这个概念与通常在长时间运行的计算服务（如虚拟机（VM）或容器服务）上运行的微服务架构相对应。AWS EC2 是第一个广泛可访问的云计算服务之一，提供可扩展的 VM。引入这样的可扩展、可访问的云资源为微服务架构变得实用和普及提供了基础。这种转变导致将庞大的应用程序分解成可独立部署的微服务单元。&lt;/p&gt;
&lt;p&gt;让我们继续使用软件单元的这个类比。函数是一个代码块，封装了一系列具有定义的输入和输出的单一任务的语句序列。这个代码单元与 FaaS 执行模型非常匹配。在事件触发无需管理基础架构的情况下执行代码的 FaaS 概念在 AWS Lambda 之前已经存在，但缺乏广泛的实施和认可。&lt;/p&gt;
&lt;p&gt;在 AWS Lambda 将 FaaS 带入主流之前，已经有了执行代码以响应事件而无需管理基础架构的 FaaS 概念，如 Google App Engine、Azure WebJobs、IronWorker 和 AWS Elastic Beanstalk 等服务。Lambda 作为 FaaS 的首个重大商业实施，通过简化开发人员的部署流程，成为其流行的催化剂。这一进步导致将微服务转变为更小的、可单独扩展的、事件驱动的操作。&lt;/p&gt;
&lt;p&gt;在向作为服务提供的更小软件单元的演进中，人们可能会想知道我们是否会看到基本的编程元素，如表达式或语句作为服务（例如 int x = a + b;）。然而，演进的方向与此不同。相反，我们正在见证函数的最小化和最终由可配置的云构建替代。在软件开发中，构建涵盖了诸如条件语句（if-else、switch 语句）、循环（for、while）、异常处理（try-catch-finally）或用户定义的数据结构等元素，这些元素在控制程序流程或管理复杂数据类型方面发挥着重要作用。在云服务中，构建与能够组成分布式应用程序的能力相一致，它们互相链接软件模块，如微服务和函数，并管理它们之间的数据流。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-computing-post-serverless-trends/f1_hu2af43fe4a71a9d2c64e3fa98f41d525b_44219_9c980474de5866ca35459826802767be.webp 400w,
               /blog/cloud-computing-post-serverless-trends/f1_hu2af43fe4a71a9d2c64e3fa98f41d525b_44219_8d0ee991f4e49651b2003ee4f6014239.webp 760w,
               /blog/cloud-computing-post-serverless-trends/f1_hu2af43fe4a71a9d2c64e3fa98f41d525b_44219_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-computing-post-serverless-trends/f1_hu2af43fe4a71a9d2c64e3fa98f41d525b_44219_9c980474de5866ca35459826802767be.webp&#34;
               width=&#34;760&#34;
               height=&#34;296&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云构建取代函数，取代微服务，取代庞大的应用程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然以前可能使用函数来过滤、路由、批量处理、拆分事件，或调用另一个云服务或函数，但现在这些操作以及更多操作都可以在你的函数中使用更少的代码，或者在许多情况下根本不需要函数代码。它们可以被可配置的云构建替代，这些构建是云服务的一部分。让我们看一些 AWS 的具体示例，以演示从 Lambda 函数代码到云构建的过渡：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;请求路由&lt;/strong&gt; - 不再使用 Lambda 来解析请求并将其路由到正确的后端端点，而是可以使用&lt;a href=&#34;https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-routes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Gateway 路由&lt;/a&gt;进行路由。而且，API Gateway 还可以与其他 AWS 服务集成，直接调用它们，消除了对函数的需求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求验证&lt;/strong&gt; - API Gateway 可以使用 OpenAPI 验证请求的主体、查询字符串参数和标头。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据转换&lt;/strong&gt; - API Gateway 可以使用 Apache Velocity 模板来&lt;a href=&#34;https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;转换&lt;/a&gt;请求和响应数据，以覆盖有效载荷、参数、标头和状态代码，而无需使用 Lambda。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流式数据库更改&lt;/strong&gt; - &lt;a href=&#34;https://aws.amazon.com/blogs/database/dynamodb-streams-use-cases-and-design-patterns/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DynamoDB Streams&lt;/a&gt;会发出所有数据更改。这对于任何数据存储来说都是一个必要的构建，消除了应用程序代码的双重写入和任何数据轮询代码，通过&lt;a href=&#34;https://www.infoq.com/articles/microservices-inside-out/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;将微服务内外颠倒&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件触发&lt;/strong&gt; - &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS 事件源映射&lt;/a&gt;允许通过从事件源读取并调用 Lambda 函数来触发 Lambda。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件过滤&lt;/strong&gt; - &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;事件源映射&lt;/a&gt;可以执行事件过滤，以控制从流或队列中调用 Lambda 函数的哪些记录。这消除了在函数内编写过滤逻辑的需要，并大大减小了函数的大小和成本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件批处理&lt;/strong&gt; - 类似地，事件源映射会将记录批处理成单个有效载荷，然后发送给你的函数。不需要手动循环聚合事件或在处理之前拆分它们。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件转换&lt;/strong&gt; - &lt;a href=&#34;https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes-input-transformation.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EventBridge Pipes&lt;/a&gt;可以在将数据发送到目标之前使用 JSON 路径语法来转换源数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件丰富化&lt;/strong&gt; - EventBridge Pipes 还可以调用另一个端点来丰富请求，然后进一步处理它。这提供了可以完全声明性使用的&lt;a href=&#34;https://www.enterpriseintegrationpatterns.com/patterns/messaging/DataEnricher.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;内容丰富器模式&lt;/a&gt;的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件路由&lt;/strong&gt; - 与请求路由类似，EventBridge &lt;a href=&#34;https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rules.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;规则&lt;/a&gt;可以执行事件路由，允许你从应用程序代码中卸载此责任，并消除 Lambda 函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于结果的路由&lt;/strong&gt; - Lambda &lt;a href=&#34;https://aws.amazon.com/blogs/compute/introducing-aws-lambda-destinations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Destination&lt;/a&gt;允许异步调用将执行结果路由到其他 AWS 服务，以配置代码替换 Lambda 调用代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用其他服务&lt;/strong&gt; - &lt;a href=&#34;https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-services.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;StepFunction&lt;/a&gt; 任务不需要 Lambda 函数来调用其他服务或外部 HTTP 端点。通过这种方式，StepFunction 任务定义可以执行例如&lt;a href=&#34;https://aws.amazon.com/blogs/aws/external-endpoints-and-testing-of-task-states-now-available-in-aws-step-functions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;执行 HTTP 调用&lt;/a&gt;或读取、更新和删除数据库记录等操作，而无需 Lambda 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这只是应用程序代码构建变成无服务器云构建的一些示例。你可以通过配置验证输入值，而不是在函数中使用 if-else 逻辑。你可以在函数之外声明性地定义路由逻辑，而不是使用 case 或 switch 语句从函数内调用其他代码。事件可以在数据更改时触发，批处理或拆分，无需重复构造，例如 for 或 while 循环。&lt;/p&gt;
&lt;p&gt;事件可以在没有函数的情况下进行验证、转换、批处理、路由、过滤和丰富。故障可以在没有 try-catch 代码的情况下进行处理和定向到 &lt;a href=&#34;https://aws.amazon.com/about-aws/whats-new/2023/06/amazon-sqs-dead-letter-queue-redrive-aws-sdk-cli/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DLQs 和回退&lt;/a&gt;，而成功完成可以定向到其他函数和服务端点。将这些构建从应用程序代码移到构建配置中减少了应用程序代码的大小，或者将其移除，消除了安全修补和任何维护的需要。&lt;/p&gt;
&lt;p&gt;在编程中，原语和构建具有不同的含义和作用。原语是编程语言固有的基本数据类型。它包含了基本值，例如整数、浮点数、布尔值或字符，不包含其他类型。与此概念类似，云 - 就像一个巨大的编程运行时 - 正在从基础设施原语（如网络负载均衡器、虚拟机、文件存储和数据库）进化为更精致和可配置的云构建。&lt;/p&gt;
&lt;p&gt;与编程构建类似，这些云构建编排分布式应用程序交互并管理复杂的数据流。然而，这些构建不是孤立的云服务；没有独立的“过滤器服务”或“事件发射器服务”。没有“构建作为服务”，但它们越来越成为核心云原语（如网关、数据存储、消息代理和函数运行时）的重要功能。&lt;/p&gt;
&lt;p&gt;这种演进降低了应用程序代码的复杂性，并在许多情况下消除了自定义函数的需求。这从 FaaS 到 NoFaaS（无麻烦，意味着简单）的转变刚刚开始，有深入的&lt;a href=&#34;https://www.youtube.com/watch?v=sdCA0Y7QDrM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;和 GitHub 上的代码示例。接下来，我将探讨垂直多云服务中构建丰富的云服务的出现。&lt;/p&gt;
&lt;h2 id=&#34;从超大规模到超专业化&#34;&gt;从超大规模到超专业化&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&#34;https://www.diagrid.io/blog/evolution-of-cloud-computing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;无服务器后云时代&lt;/a&gt;，仅提供高度可扩展的云原语（如容器和函数的计算，或诸如键/值存储、事件存储、关系数据库或网络原语等存储服务）已经不再足够。无服务器后云服务必须富含开发者构建，并卸载应用程序的大部分基础设施。这超越了为广泛用户群体进行通用云服务的超大规模；它涉及深度专业化，并向更具要求的用户公开高级构建。&lt;/p&gt;
&lt;p&gt;像 AWS、Azure、GCP 等超大规模云服务提供商，凭借其广泛的服务范围和庞大的用户群体，很好地把握了新用户需求和构建。然而，提供这些更细粒度的开发者构建会增加复杂性。每个服务中的每个新构建都需要深入学习曲线以了解其有效利用的特定内容。因此，在无服务器后时代，我们将看到垂直多云服务的兴起，这些服务在一个领域表现出色。这代表了云服务的超专业化。&lt;/p&gt;
&lt;p&gt;以 Confluent Cloud 为例。虽然所有主要的超大规模云服务提供商（AWS、Azure、GCP 等）都提供 Kafka 服务，但没有一家能够与 Confluent Cloud 提供的开发者体验和构建相匹配。通过其 Kafka 代理、众多的 Kafka 连接器、集成的模式注册表、Flink 处理、数据治理、跟踪和消息浏览器，Confluent Cloud 提供了最丰富和专业化的 Kafka 服务，超越了超大规模云服务提供商的提供。&lt;/p&gt;
&lt;p&gt;这种趋势并不孤立；许多例子包括 MongoDB Atlas 与 DocumentDB、GitLab 与 CodeCommit、DataBricks 与 EMR、RedisLabs 与 ElasticCache 等。除了已建立的云公司外，新一波初创公司正在崭露头角，专注于一个多云原语（如专业化的计算、存储、网络、构建流水线、监控等）并通过开发者构建来丰富它，以提供独特的价值主张。以下是一些专门化于单一开源技术的云服务，旨在提供丰富的构建体验，并吸引用户远离超大规模云服务提供商：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://vercel.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vercel&lt;/a&gt;：以其出色的前端开发者体验而闻名，简化了 Web 应用程序的部署。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://railway.app/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Railway&lt;/a&gt;：以增强后端开发者体验以及简单的部署和扩展管理而著名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://supabase.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Supabase&lt;/a&gt;：是 Firebase 的开源替代方案，提供更灵活的相似功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://fauna.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fauna&lt;/a&gt;：以声明性关系查询和强一致性事务中的功能业务逻辑而闻名的无服务器数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://neon.tech/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Neon&lt;/a&gt;：提供最简单的无服务器 PostgreSQL，具有数据库分支和最小管理开销等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://planetscale.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PlanetScale&lt;/a&gt;：以高级 MySQL 云服务而闻名，侧重于开发友好的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://polyscale.ai/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PolyScale&lt;/a&gt;：专注于通过智能缓存优化数据性能的 AI 驱动缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://upstash.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstash&lt;/a&gt;：提供全托管的低延迟无服务器 Kafka 解决方案，适用于事件流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.diagrid.io/catalyst&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Diagrid Catalyst&lt;/a&gt;：提供用于消息、数据和工作流的无服务器 Dapr API，充当云服务之间的连接纽带。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://temporal.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Temporal&lt;/a&gt;：提供持久的执行，为可靠管理复杂工作流程提供平台。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个列表代表了一个不断增长的生态系统的一部分，这个生态系统是建立在超大规模云服务提供商提供的核心云原语之上的垂直多云服务。它们通过提供一套全面的可编程构建和增强的开发者体验来竞争。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-无服务器云服务通过丰富的开发人员构造超专业地处理一件事&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;无服务器云服务通过丰富的开发人员构造，超专业地处理一件事&#34; srcset=&#34;
               /blog/cloud-computing-post-serverless-trends/f2_hu81d2c012dc32729ef0c06650105a1c99_90677_f625166ab97ebbf6b5053481367e1def.webp 400w,
               /blog/cloud-computing-post-serverless-trends/f2_hu81d2c012dc32729ef0c06650105a1c99_90677_505183c6d3f627cbbabf789248d11149.webp 760w,
               /blog/cloud-computing-post-serverless-trends/f2_hu81d2c012dc32729ef0c06650105a1c99_90677_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-computing-post-serverless-trends/f2_hu81d2c012dc32729ef0c06650105a1c99_90677_f625166ab97ebbf6b5053481367e1def.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      无服务器云服务通过丰富的开发人员构造，超专业地处理一件事
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;一旦完成了这个过渡，缺乏丰富构建的基本云服务，甚至是无服务器的云服务，都会显得像过时的本地软件。存储服务必须像 DynamoDB 一样流式传输更改；消息代理应包括类似于 EventBridge 的构建，用于事件驱动的路由、过滤和终端点调用，包括重试和 DLQs；发布/订阅系统应提供消息批处理、拆分、过滤、转换和丰富功能。&lt;/p&gt;
&lt;p&gt;最终，虽然超大规模云服务提供商通过不断增加的服务数组在水平方向扩展，但超专业化服务提供商在垂直方向增长，提供一个丰富构建的最佳服务，形成一个&lt;a href=&#34;https://www.infoq.com/articles/cloud-bound-applications/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;生态系统&lt;/a&gt;的垂直多云服务。云服务竞争的未来将从基础设施原语转向核心云原语和面向开发者的构建的组合。&lt;/p&gt;
&lt;h2 id=&#34;从基础设施到组合即代码cac&#34;&gt;从基础设施到组合即代码（CaC）&lt;/h2&gt;
&lt;p&gt;云构建越来越模糊了应用程序和基础设施职责之间的界限。下一个演进是云自动化的“左移”，将应用程序和自动化代码集成为工具和责任的一部分。让我们看看这个过渡是如何展开的。&lt;/p&gt;
&lt;p&gt;云基础设施管理的第一代是由基础设施即代码（IaC）定义的，这是一种旨在简化基础设施的供应和管理的模式。这种方法建立在云计算中虚拟化的商品化趋势的基础上。&lt;/p&gt;
&lt;p&gt;最初的 IaC 工具引入了专门用于以可重复的方式创建、配置和管理云资源的领域特定语言（DSL）。像 Chef、Ansible、Puppet 和 Terraform 这样的工具引领了这个阶段。这些工具利用了声明性语言，允许运维团队以代码定义基础设施的期望状态，抽象出底层的复杂性。&lt;/p&gt;
&lt;p&gt;然而，随着云计算从低级粗粒度基础设施过渡到更面向开发者的可编程细粒度构建，使用现有通用编程语言来定义这些构建的趋势正在兴起。新的参与者，如 Pulumi 和 AWS Cloud Development Kit（CDK），处于这一浪潮的前沿，支持诸如 TypeScript、Python、C#、Go 和 Java 等语言。&lt;/p&gt;
&lt;p&gt;采用通用编程语言的转变是由于需要克服声明性语言的局限性，后者在以编程方式定义云构建方面缺乏表现力和灵活性，并且由于云构建配置的责任从运维转向开发者。与适用于低级静态基础设施的声明性语言的静态性质不同，通用编程语言使开发者能够定义动态、逻辑驱动的云构建，实现与应用程序代码更紧密的对齐。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-将应用程序的组成从基础设施转移到开发人员团队&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;将应用程序的组成从基础设施转移到开发人员团队&#34; srcset=&#34;
               /blog/cloud-computing-post-serverless-trends/f3_hu8b369d7de1b4dfcb4a7596d847746bcc_63367_064507ef326821fcd3732d40314b4364.webp 400w,
               /blog/cloud-computing-post-serverless-trends/f3_hu8b369d7de1b4dfcb4a7596d847746bcc_63367_defcd6ae887e69eda11575b28505c3ae.webp 760w,
               /blog/cloud-computing-post-serverless-trends/f3_hu8b369d7de1b4dfcb4a7596d847746bcc_63367_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-computing-post-serverless-trends/f3_hu8b369d7de1b4dfcb4a7596d847746bcc_63367_064507ef326821fcd3732d40314b4364.webp&#34;
               width=&#34;760&#34;
               height=&#34;432&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      将应用程序的组成从基础设施转移到开发人员团队
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;无服务器后云开发人员需要通过创建函数和微服务来实现业务逻辑，但还需要使用可编程云构建将它们组合在一起。这塑造了更广泛的开发者责任集，用于开发和组合云应用程序。例如，具有 Lambda 函数中的业务逻辑的代码还需要 API Gateway 中的路由、过滤和请求转换配置。&lt;/p&gt;
&lt;p&gt;另一个 Lambda 函数可能需要 DynamoDB 流配置来流式传输特定数据更改，EventBridge 路由、过滤和丰富配置。&lt;/p&gt;
&lt;p&gt;第三个应用程序可能将其大部分编排逻辑表达为 StepFunction，其中 Lambda 代码只是一个小任务。开发者，而不是平台工程师或运维成员，可以将这些代码单元组合在一起。工具，如 Pulumi、AWS CDK 和其他工具，允许开发者使用他们选择的语言来实现函数，并使用相同的语言来组合它与云环境的交互，最适合这个时代。&lt;/p&gt;
&lt;p&gt;平台团队仍然可以使用声明性语言，比如 Terraform，来管理、保护、监视和启用云环境中的团队，但以开发者为重点的构建，结合以开发者为重点的云自动化语言，将云构建向左移动，并使开发者能够自助使用云服务成为现实。&lt;/p&gt;
&lt;p&gt;从 DSL 到通用编程语言的过渡标志着 IaC 演进的重要里程碑。它承认了应用程序代码向云构建的过渡，这些构建通常需要开发者更深入地控制资源以满足应用程序需求。这个转变代表了 IaC 工具的成熟，现在需要满足更广泛的基础设施编排需求，为更复杂、更高级的抽象和工具铺平了道路。&lt;/p&gt;
&lt;p&gt;基础设施管理的过程将从静态配置转向更加动态、基于代码的方法。这一演进不仅仅止步于基础设施即代码，它正在超越到一个更加微妙的领域，被称为组合即代码。这一范式进一步模糊了应用程序代码和基础设施之间的界限，导致更加流畅、高效和开发者友好的实践。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;总结趋势及其加强效应，我们观察到编程构建逐渐整合到云服务中。每个计算服务都将集成 CI/CD 流水线；数据库将提供来自边缘的 HTTP 访问并发出更改事件；消息代理将通过过滤、路由、幂等性、转换、DLQ 等功能增强能力。&lt;/p&gt;
&lt;p&gt;基础设施服务正在演变为无服务器 API、从代码中推断的基础设施 (&lt;a href=&#34;https://klo.dev/state-of-infrastructure-from-code-2023/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IfC&lt;/a&gt;)、&lt;a href=&#34;https://vercel.com/blog/framework-defined-infrastructure&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;框架定义的基础设施&lt;/a&gt;，或由开发者明确组合 (CaC)。这一演进导致了更小的函数，有时甚至是 NoFaaS 模式，为超专业化、以开发者为先的垂直多云服务铺平了道路。这些服务将提供&lt;a href=&#34;https://thenewstack.io/raising-the-serverless-bar-infrastructure-apis-unleash-more-value-for-enterprises/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可编程 API 的基础设施&lt;/a&gt;，使开发者能够无缝地使用他们喜欢的编程语言合并其应用程序。&lt;/p&gt;
&lt;p&gt;使用云服务进行应用程序构建的左移将与应用程序编程越来越融合，将微服务从一种架构风格转变为一种组织风格。一个微服务将不再只是一个单一的部署单元或过程边界，而是由开发者选择的单一语言中实现和粘合的函数、容器和云构建组成。未来正在成为超专业化，并专注于以开发者为先的云。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>软件堆栈的商品化：应用为先的云服务如何改变游戏规则</title>
      <link>https://cloudnative.to/blog/dapr-cloud-services/</link>
      <pubDate>Mon, 16 Oct 2023 11:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/dapr-cloud-services/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://www.infoq.com/presentations/dapr-cloud-services/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.infoq.com/presentations/dapr-cloud-services/&lt;/a&gt;，是 Ibryam 今年三月在 QCon London 的分享。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;摘要：软件堆栈的商品化是如何改变应用为先的云服务的游戏规则。通过使用开源项目和 API 将应用程序与集成逻辑绑定在一起，可以实现更高级别的抽象。Dapr 是一组作为 API 公开的分布式基元，可以作为 Sidecar 部署。应用程序云服务将计算和集成能力作为 SaaS 提供，开发人员可以将核心应用程序逻辑绑定到云服务上。这种应用程序优先云服务的出现使得应用程序可以更加专业化，并且可以在不同的云提供商之间灵活迁移。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ibryam: 我叫 Bilgin Ibryam。我在这里要告诉大家我对云服务的演变以及这将如何影响我们正在构建的分布式应用的看法。这将是一个快节奏的演讲，我们没有时间深入研究每个技术和模式，而是快速概述架构的演变，并试图分析这对云原生应用的未来可能意味着什么。我是 Diagrid 的产品经理，我们正在为开发人员构建 API。在此之前，我是红帽公司的顾问、架构师和产品经理，在那里我使用了一些项目，比如集成框架 Apache Camel，并对其进行了贡献并撰写了一本书。同样，我也使用过 Kubernetes 作为开发人员，并撰写了一本关于 Kubernetes 的书，您可以从提供的 URL 中免费获得赞助。我们将看看应用是如何从单体应用变成微服务、函数以及即将到来的其他形式的。同时，我们还将看看基础架构是如何演变为云服务的形式，并且它如何塑造应用架构。&lt;/p&gt;
&lt;h2 id=&#34;早期云时代&#34;&gt;早期云时代&lt;/h2&gt;
&lt;p&gt;让我们从回顾云之前和云早期时代开始。在我看过的时间线上，这是微服务运动之前的时代。那是云成为主流之前的时代。这主要是指本地和早期云时代，如早期的 EC2 实例。如果我们看一下当时代表性的应用架构，比如构建在 ESB 平台之上的应用，我们会发现开发人员不得不自己实现或从 ESB 中使用所有东西。这包括与应用程序打包、部署在 SOAR 平台上、甚至在 VM 上放置应用程序等相关的内容。新更新的部署和发布流程。处理基于 SOAP 和 Web 服务甚至 RPC 的同步交互的应用程序的配置和扩展方面。所有这些都是在应用程序内部控制的。当时，我们还没有像断路器模式、mTLS 这样的东西。开发人员负责服务发现、重试、超时、身份验证、授权。在异步交互类别下，我包括通过消息传递的任何形式的交互，这涉及到消息转换、从一种协议连接到另一种协议、连接到各种系统、死信队列。最后，在有状态的模式和工作流程下，通常需要持久状态，包括业务工作流编排或更简单的 Saga 模式实现。幂等消费者、共享分布式日志、定时器、Cron 作业，所有这些模式都需要在应用层内部由开发人员实现。在这个时代，所有这些责任都由应用程序处理。&lt;/p&gt;
&lt;p&gt;那基础设施呢？作为当时的开发人员，我会将基础设施视为一个薄薄的层次，并且对它的期望并不是很高。基础设施会以虚拟机的形式为开发人员提供计算能力，以关系数据库和消息代理的形式提供网络和存储。即使这些也有时会成为 ESB 平台提供的应用层的一部分。那么界面和这两个层次和团队之间的边界是怎样的呢？它以操作系统抽象的形式存在。运维团队会为您提供特定容量的虚拟机，可能还会安装 Java 或某个应用服务器，然后就完成了。会有一张列有静态 IP 和端口号的清单，用来引用其他服务和数据库。这基本上就是在云计算和早期云计算时代的情况了。那时还没有被广泛接受的可用于不同语言和环境的应用格式和 API。从应用开发人员的角度来看，这是一个智能单体和愚蠢静态基础设施的时代。&lt;/p&gt;
&lt;h2 id=&#34;内部架构&#34;&gt;内部架构&lt;/h2&gt;
&lt;p&gt;虽然这是 2010 年之前的最新技术，但随着接下来几年里发生的一些重大软件开发趋势，对应用开发产生了复兴和新的兴趣。这些趋势至今仍然具有影响力。让我们看看它们。软件架构有不同的方面和不同的可视化方式。在流行的方式中，有一种被称为“4+1 架构模型”，它包括逻辑视图、物理视图、过程视图和开发视图。这种技术主要依赖于使用 UML 和图表来可视化这些不同的视图。后来，还出现了另一种流行的软件架构可视化方式，它被称为 C4，由 Simon Brown 创建，它采用更简化的方法，从系统上下文、运行应用程序的容器、构成应用程序的组件、以及类和包的代码级别等层次来看待软件。&lt;/p&gt;
&lt;p&gt;对于这次演讲，我想采用更简单的方式，只谈论应用程序架构的两个层次，我将其称为内部架构和外部架构。内部架构是由开发人员完全控制的一切，包括类、函数、包、应用程序内部的不同层次，甚至是外部系统的抽象。我们可以说内部架构就是放入容器镜像中的所有内容，并且从运维和平台的角度来看，它被视为一个黑盒子。外部架构是应用程序与之交互的一切的集合。这是构成整个系统的其他服务、数据库和云服务。作为运维人员，您必须了解这些外部交互，并确保连接可靠、安全、可观察。与 C4 模型相比，内部架构基本上是级别 1 和 2，即系统上下文和容器，而外部架构基本上是级别 3 和 4，即组件和代码。&lt;/p&gt;
&lt;p&gt;在放置此免责声明后，让我们来看看一些在单体应用程序中发生的值得记忆的影响以及它们如何改变应用程序的内部架构。第一个是域驱动设计，这个术语是由埃里克·埃文斯在他的书《领域驱动设计》中创造的。域驱动设计是一组原则和模式，帮助开发人员封装复杂的业务逻辑，并弥合业务现实与代码之间的差距。虽然这本书是在微服务出现近十年之前写的，但它为微服务奠定了基础，并成为后来微服务的基石，通过帮助开发人员将单体应用程序拆分为代表不同业务领域的较小的松散耦合模块，这些模块由有界上下文表示。我认为下一个重大转变是六边形架构，由阿利斯泰·科克伯恩提出，旨在避免面向对象软件设计中的结构陷阱。这些陷阱包括层之间的不必要的依赖关系以及用户界面与业务逻辑的相互污染。基本上，这种方法通过解耦组件并提供一种标准化的与外部依赖进行交互的方法，改进了三层应用程序的灵活性和可维护性。还有一些相关的思想，如洋葱架构、干净架构，由阿姨鲍勃提出。这些设计模式基本上强调应用程序层内的关注点分离，并将应用程序代码库组织成具有特定职责的不同层。所有这些架构风格都有助于将应用程序的业务逻辑与基础架构分离，并允许开发人员对基础架构进行更改而不影响业务逻辑，反之亦然。&lt;/p&gt;
&lt;p&gt;然后出现了微服务和 12 因素应用程序。基于域驱动设计的思想，如有界上下文、聚合和六边形架构，构建了微服务。微服务基本上允许每个服务独立发布和扩展，以满足不断变化的业务需求。12 因素应用程序方法代表了开发微服务基础应用程序和现代可扩展云应用程序的一组最佳实践。这些想法都建立在前一个想法的基础上，但可能也稍微改变了它。由于这些应用程序开发趋势的结果，在过去的十年中，应用程序的内部架构发生了显着变化。我们之前看到的单体架构变得禁忌，几乎成为反模式，并开始向微服务和函数过渡。&lt;/p&gt;
&lt;h2 id=&#34;计算优先的云时代&#34;&gt;计算优先的云时代&lt;/h2&gt;
&lt;p&gt;当应用程序开发人员忙于从单体架构过渡到微服务时，让我们看看此时基础架构层发生了什么。由于应用程序内部架构和云迁移的所有变化，我们开始看到为微服务提供独立中间件的出现。无论是用于集成中间件（如 Apache Camel、Spring Integration）还是用于工作流编排的项目（如 Conductor、Cadence、Camunda），这些专门的框架开始提供一些微服务的需求，无论是部署在本地还是在云端，它们仍然留在开发人员的领域内。这种转变代表了将集成责任从单体应用程序中分离出来，但由开发人员管理的独立组件。更有趣的是在计算和低级网络层发生了什么。Docker 于 2013 年宣布发布，这在计算抽象层面解锁了巨大的创新。这基本上为运维团队提供了云和计算，例如 Kubernetes 和 lambda。所有这些都意味着运行时责任开始转移到底层平台，并成为运维团队和云服务的责任。对于开发人员来说，它们不再是关注点。&lt;/p&gt;
&lt;p&gt;基于容器的打包意味着可以统一编排使用任何语言编写的应用程序，即执行诸如放置、部署、扩展、配置管理之类的操作，从开发人员的责任转移到运维团队和云服务。它们不再需要开发人员关注。网络也变得更加动态和应用程序化。一些可靠性、服务发现、故障转移、可观察性、路由等职责转移到了平台级别，成为运维团队的责任。我认为这种迅速转变的主要原因之一是我们首次拥有了多语言应用程序特定格式，例如 Docker 和 Kubernetes。这些基本上是在图表上表示的红色框。这些技术弥合了开发人员和运维团队之间的鸿沟，并使用两个团队都使用的共同语言、共同模式、抽象和工具，实现了 DevOps 和 GitOps 等实践。&lt;/p&gt;
&lt;p&gt;我想深入探讨一下在这种情况下应用程序与计算之间的合同。无论您是在 Kubernetes 上将微服务作为容器运行，还是在纯容器服务上运行，或者将其作为无服务器函数运行，应用程序与运行时平台之间都有一定的合同。为了与我们将在后面看到的其他类型的平台区分开，并强调这通常是托管服务或 SaaS 提供的，我将其称为计算云。应用程序与计算云之间的合同是通过 API 交互、配置甚至实践（例如滚动部署）形式存在的。所有这些，我们将其称为计算绑定。让我们看看如何将应用程序与计算层绑定，以及这些 API 是什么。&lt;/p&gt;
&lt;p&gt;假设我们有一个在容器中有一些应用逻辑的微服务。该应用程序有自己的数据库、内部状态，并且可能与其他系统和服务进行通信。这些是外部依赖项。然后，当我们在计算平台上运行这样的应用程序时，最初这两者之间存在一些合同。通过配置界面，无论是 YAML 文件还是其他格式，我们将某些资源需求传递给计算平台，即 Kubernetes 中的 CPU 和内存请求和限制。在 AWS Lambda 的情况下，这是内存请求。我们将使用这两个运行时平台进行比较。我们使用其他配置策略来定义应用程序应该在哪里运行。对于 Lambda 来说，选择区域或在边缘部署 Lambda 的选项。在 Kubernetes 中，有更丰富的配置选项，例如污点、容忍度、亲和性、反亲和性等。还可以有其他元数据，例如标签、环境变量，我们将其传递给计算平台，以便它知道如何配置我们的应用程序。甚至有一定的合同，如何将此配置从平台传递到应用程序，通常是通过环境变量，但也可以通过特定位置的已挂载文件以特定格式传递。还存在生命周期挂钩。平台现在知道如何启动和停止我们的应用程序，并在启动期间触发某些事件，或在关闭之前或其他重要的生命周期阶段触发事件，应用程序可以与之交互。对于 Kubernetes，有启动后事件和停止前事件。对于 Lambda，也有类似的扩展 API，允许应用程序拦截初始化、调用和关闭阶段。然后，平台还有 API 来检查应用程序的健康状况。API 来检查应用程序是否已启动，以及是否需要平台采取任何纠正措施。对于 Kubernetes 来说，这基本上是平台执行的各种健康探测。对于 Lambda 来说，由于 Lambda 运行时间非常短，基本上健康状况是由响应状态决定的，并且决定平台是否应该重试请求。&lt;/p&gt;
&lt;p&gt;然后，每个计算平台还提供了收集日志、指标和跟踪的方式，现在主要基于结构化日志格式、Prometheus 和 OpenTelemetry 基于度量和跟踪。无论您是否意识到这一点，这些都是一些明确和不明确的合同、约定和实践，称为应用程序与计算云之间的计算绑定，无论您使用哪种平台。我将计算云包括在内，还包括了各种服务网格和透明的 mTLS、可靠性和可观察性问题。如果您看看应用程序与平台之间的所有这些 API，我们作为开发人员几乎不需要做什么。也许我们需要实现健康探测 API，确保应用程序被正确地容器化，并且可以启动和关闭。就这些而言，大部分绑定是由运维团队在运行时操作应用程序使用的。所有这些绑定的好处是，如今它们大多受到容器、Kubernetes 和其他开源项目和格式的影响。它们在大多数计算平台、云提供商甚至不同的应用程序架构中都是相当通用的。整体而言，云原生主要关注计算和计算绑定，并且其影响力如此之大。&lt;/p&gt;
&lt;h2 id=&#34;外部架构&#34;&gt;外部架构&lt;/h2&gt;
&lt;p&gt;总而言之，我们研究了应用程序的内部架构是如何从单体架构演变为微服务架构的，并且计算中心的应用程序服务诞生，为应用程序和计算平台之间创建了一种绑定，目前主要由运维团队使用。接下来，我们将看到应用程序的外部架构如何发生变化，也转向云端。我们将研究集成绑定，在本次演讲中，这些是应用程序与其他应用程序云服务、存储层之间的交互集合。这些主要是在应用程序的外部架构中使用的绑定。与计算绑定用于运维团队的情况不同，集成绑定是开发人员在实现应用程序时使用的。同样，我们有我们的容器化应用程序，具有一些内部状态。请注意，当我们查看应用程序的外部架构时，还可以存在应用程序正在与其他第三方系统和服务进行交互的情况。此外，如果您熟悉外部数据的概念，可能还有尚未到达应用程序的状态。该状态可以在工作流引擎中、在 DLQ 中或在重试中。它为此服务指定，但尚未被接受。这是图表上的外部状态，与内部状态一样重要，当我们查看端到端请求流时。这些集成绑定可以是与外部系统的连接器形式。它可以是消息传递和事件逻辑，例如消息重试、过滤器、死信队列、消息延迟、基于内容的路由、处理有毒消息等。所有这些都是集成绑定。它们还可以是服务编排和工作流、Web 钩子和触发器，在特定时间触发应用程序执行特定操作。甚至可以是用于单例组件的分布式日志。基本上，我将开发人员在实现分布式应用程序时必须使用的所有分布式系统模式都归类到此类别中。这些基本上是一系列无差别的技术特性，您必须使用它们来实现应用程序的定制业务逻辑。&lt;/p&gt;
&lt;p&gt;我发现更有趣的是这些集成能力可以存在的位置。与计算绑定类似，借助容器和 Kubernetes，普遍格式，甚至 lambda，运行时管理和网络责任已从应用程序、ESB 转移到由运维或云提供商管理的计算层。同样，我们可以看到一些集成责任正在从应用程序层移动到其自己的层，作为独立的中间件，甚至移动到无服务器云服务中。对于这些集成能力的部署选项，传统方法是将所有这些集成逻辑放在应用程序层内。例如，可以使用 Apache Camel 和 Spring Integration 等项目。Camel 提供了数十种消息模式、连接器的实现，这些都被很好地封装在一个漂亮的 Java DSL 中。这种方法提供了最大的灵活性，但不适用于所有流行的语言，并且将应用程序与集成逻辑或生命周期紧密耦合。另一种极端是将所有集成需求全部转移到类似 AWS EventBridge 的框架中，并将应用程序与其耦合。这些框架，如 EventBridge，基本上是现代无服务器基于云的 ESB。如果使用它，您基本上将应用程序与该提供商的整个生态系统和工具耦合在一起。&lt;/p&gt;
&lt;p&gt;第三种选择是使用事实上的标准、开源项目和 API 来将应用程序与集成逻辑绑定在一起，类似于容器和 Kubernetes 用于计算绑定的方式。这些开放 API 的示例包括 Apache Kafka，其 API 用于流处理。Redis 用于缓存，甚至 AWS S3 用于文件访问，Dapr 用于分布式系统。这些可以部署在本地，因为通常在应用程序本地有一个开源实现，或者它们可以作为云服务使用，并且您甚至可以改变主意来回移动。某些事实上的标准的限制是它们缺乏我在本次演讲中所描述的更高级别抽象。它们主要关注存储访问层。例如，Kafka 用于消息访问，Redis 仅为键值访问，S3 用于云访问。在本次演讲中，我描述的集成绑定不仅仅是存储访问。它们涵盖了高级开发者关注的内容，例如 Dapr 提供的内容。&lt;/p&gt;
&lt;p&gt;我将简要介绍一下 Dapr 是什么。Dapr 是由微软创立并于 2021 年捐赠给 CNCF 的。本质上，Dapr 是一组作为 API 公开的分布式基元，以及作为 Sidecar 部署的。在 Dapr 中，这些能力被称为构建块。它们只是多个实现的 API。例如，有一个状态管理构建块，类似于 Redis API，但它可以有不同的状态存储实现。还有一个类似于 Kafka 的发布/订阅 API，但它有多个实现，比如基于 Kafka、Redis、Amazon SQS、GCP Pub/Sub、RabbitMQ 等。不仅如此，例如发布/订阅 API 可能具有一些其他消息系统所没有的高级功能，但 Dapr 实现了它。例如，DLQs 和过滤，延迟消息传递。基本上，Dapr 实现了我之前讨论的大多数配置绑定，有了有状态的编排模式，这是一个名为 Workflows 的新的 Dapr API。有了 Dapr 中的发布/订阅 API，我之前描述的异步交互。有了 Dapr 中的同步交互，这是 Dapr 中的状态调用 API，等等。在架构方面，Dapr 通常作为 Sidecar 部署，但我们的工作是使其作为 SaaS 工具可用。通过定义良好的 HTTP 和 gRPC API 来使用 Dapr API，无需了解这些 API 的后端实现，这些实现可以由云服务提供商、本地部署或用于开发目的的内存实现提供。&lt;/p&gt;
&lt;p&gt;如果我要将 Dapr 与 Camel 和 EventBridge 进行比较，那么它们之间有很多区别。在耦合方面，Camel 是一个与云无关，但非常与编程语言相关的框架。而 EventBridge 则仅适用于 AWS。Dapr 可以被多种语言在不同的云提供商上使用。它可以作为 Sidecar 与您的应用程序共同部署，并最终作为 SaaS 工具进行使用。某个东西是否与语言和云特定相关不仅仅是关于应用程序的可移植性。一个与云和语言无关的框架允许模式、工具、实践和知识的可移植性，甚至可以在不同的项目、团队和云中共享，从而成为通用知识和事实上的标准。&lt;/p&gt;
&lt;h2 id=&#34;应用优先云&#34;&gt;应用优先云&lt;/h2&gt;
&lt;p&gt;最后，让我们看看这些应用程序云服务是什么，以及它们如何影响我们正在构建的应用程序。我们看到计算云接管了来自开发人员到运维的运行时管理和网络的责任，甚至是托管的云服务。有趣的是，新的计算服务都是关于个别应用程序的。这里我列举了一些 AWS 的服务，但其他云提供商也有类似的服务。这个列表还在不断增长，甚至扩展到边缘。网络服务也变得更加注重应用程序。它们能够理解 HTTP、gRPC 甚至应用程序协议，并为您提供应用层的控制。以类似的方式，我看到了集成云的诞生。集成云基本上是一组托管服务，将集成责任从开发人员身上剥离，并将其作为无服务器能力提供。除了纯存储服务，如 Postgres、MySQL、Kafka、Redis、文件存储外，我还看到了用于处理事件的服务，如 AWS EventBridge、Google Eventarc、Azure Event Grid，以及其他各种变体。还有更多用于有状态编排的服务，如 Step Functions、Temporal Cloud。用于发布/订阅的服务，如 Ably，定时任务服务、Webhooks、数据虚拟化服务、GraphQL 服务等等。所有这些都代表了一个集成云。&lt;/p&gt;
&lt;p&gt;所有这些服务首先是为开发人员创建的，而不是为运维创建的，并且通常是完全托管和无服务器的。在结果架构中，核心应用程序逻辑可以绑定到一个或多个云服务，通过计算和集成 API 进行。其中一些 API 基于开源项目，而一些则是特定于供应商的。开发人员仍然负责在其应用程序中暴露某些 API，并调用集成云的 API，并将其应用程序业务逻辑与该云连接起来。理想情况下，这应该是遵循六边形架构原则完成的，但从更现代的视角来看，使用开放的 API 和格式，而不是原始的进程内方法调用和接口。在这种架构中，计算和集成能力作为 SaaS 进行消费，委托给值得信赖的第三方公司。运维的角色更多地涉及对这些云服务进行管理、安全配置。运维负责实现区分业务逻辑，并重复使用无差异的集成能力作为服务。&lt;/p&gt;
&lt;p&gt;在这里，我们看到更多专业化的应用程序优先云服务，应用程序可以绑定到这些服务。不同的无服务器计算服务、无服务器流量路由服务、事件处理服务、有状态编排服务，理想情况下，一个应用程序不应该绑定到所有这些服务。应用程序应该在同一云区域和云提供商内使用少数服务，并通过开放的 API 进行使用，这样如果需要的话，就可以灵活地迁移到其他地方。在我看来，我们将看到更多的应用程序在云上运行，不仅仅绑定到计算层，也不仅仅绑定到存储层，还绑定到集成层。如果您相信云提供商能够处理数据和计算，为什么不相信它也能处理集成层，只要它具有标准化的边界，实现应用程序和开发人员的可移植性。&lt;/p&gt;
&lt;h2 id=&#34;主要收获&#34;&gt;主要收获&lt;/h2&gt;
&lt;p&gt;最后，为什么所有这些都很重要，这次演讲有哪些主要收获。首先，本次演讲的目标之一是概述应用程序和基础设施在过去二十年的演变。也许这是对未来变化方向的一个指示。就收获而言。首先，您应该使用开放的计算绑定封装应用程序的内部架构，无论是微服务、函数、模块化的单体应用程序，使用容器作为基础。如果您理解容器、它们的生命周期事件、资源约束和健康检查，您就可以快速理解许多计算平台并使用它们，从而受益于整个工具和知识生态系统，而无需重新发明轮子。其次，专注于在应用程序中实现差异化的业务功能，并尝试通过 API 重用无差异的重复分布式功能，就像我们今天对计算和存储所做的那样。归根结底，这归结为可移植性。它很少涉及将应用程序从一个云迁移到另一个云。更多的是关于人员和工具的可移植性。它是从一个项目到另一个项目的可移植性，从一个云到另一个云的可移植性，从一个雇主到另一个雇主的可移植性。我们对于计算层具有这种可移植性，我认为我们也需要对集成层具有同样的可移植性。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生绑定应用：一种让开发者专注于业务逻辑的新架构</title>
      <link>https://cloudnative.to/blog/cloud-bound-applications/</link>
      <pubDate>Thu, 16 Mar 2023 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-bound-applications/</guid>
      <description>&lt;p&gt;本文作者 Bilgin Ibryam 是 Diagrid 的技术产品经理，致力于开发人员生产力工具。在此之前，他曾在 Red Hat 担任顾问和架构师，同时也是 Apache 软件基金会的提交者和成员。Bilgin 还与人合著了两本关于 Kubernetes 模式和 Camel 设计模式的书。在业余时间，Bilgin 喜欢通过博客和其他方式写作和分享他的知识。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：本文的原标题是《什么是云原生绑定应用》。本文介绍了云绑定应用程序的概念，并探讨了在使用云绑定应用程序时需要考虑的几个关键因素。首先，作者解释了云绑定应用程序是指在构建应用程序时使用云提供的服务和资源。作者强调了使用云绑定应用程序可以带来很多好处，例如降低成本和提高可靠性。然而，作者也指出了在使用云绑定应用程序时需要考虑的几个关键因素，包括云供应商锁定、数据隐私和网络连接可靠性等。最后，作者提供了一些建议，帮助企业在使用云绑定应用程序时避免潜在的风险。例如，选择具有高可用性的云服务提供商，并在使用云绑定应用程序时加强数据安全措施。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;关键要点&#34;&gt;关键要点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;云提供商将重点从基础设施服务转移到开发人员直接使用的应用程序优先服务，从而产生了新的应用程序架构。&lt;/li&gt;
&lt;li&gt;这种架构允许开发人员将集成逻辑和管理责任卸载到云服务，并专注于实现业务逻辑。&lt;/li&gt;
&lt;li&gt;“云绑定”代表了云原生从解决以计算为中心的问题向管理应用集成问题的演进。&lt;/li&gt;
&lt;li&gt;云绑定应用程序使用开放 API 和事实标准将应用程序的内部架构与其外部依赖项分离。&lt;/li&gt;
&lt;li&gt;云绑定应用程序使用开放的 API 和数据格式将应用程序绑定到计算基础设施，并将状态编排、事件驱动的交互和可靠的同步交互等集成责任卸载到云服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用程序优先云服务的日益普及导致应用程序和云服务的集成比以前更深入。应用程序和云之间的运行时边界正在从虚拟机转移到容器和函数。在这个最终架构中，应用程序是“云绑定”的，通过将更多应用程序逻辑和管理责任卸载到云服务，开发人员可以专注于业务逻辑。&lt;/p&gt;
&lt;p&gt;本文通过使用保持灵活性和可移植性的开放 API 和标准将应用程序绑定到云服务来检查整个软件堆栈的商品化。&lt;/p&gt;
&lt;h2 id=&#34;内部架构演变&#34;&gt;内部架构演变&lt;/h2&gt;
&lt;p&gt;应用程序的内部架构通常由一个团队拥有和控制。根据所选的语言和运行时，包、模块、接口、类和函数等工具和抽象可帮助开发人员控制内部边界。领域驱动设计 (DDD) 帮助开发人员设计领域模型，这些模型作为抽象来封装复杂的业务逻辑并调解业务现实与代码之间的差距。&lt;/p&gt;
&lt;p&gt;Hexagonal，Onion 和 Clean 架构可以补充  DDD 并安排具有不同边界和外部化基础设施依赖性的应用程序代码。尽管这些方法在开始时是创新的并且在今天仍然适用，但它们最初是为三层 Java 应用程序开发的，该应用程序由部署在共享应用程序运行时中的 JSP、Servlet 和 EJB 组成。当时的主要焦点是将应用程序逻辑与 UI 和数据库分离，并启用隔离测试。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1内部应用架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1：内部应用架构&#34; srcset=&#34;
               /blog/cloud-bound-applications/1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_df15796544d3641c41413a7e0762e87c.webp 400w,
               /blog/cloud-bound-applications/1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_bda3f593a1aeeaa7aefc5304f3419808.webp 760w,
               /blog/cloud-bound-applications/1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-bound-applications/1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_df15796544d3641c41413a7e0762e87c.webp&#34;
               width=&#34;760&#34;
               height=&#34;619&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1：内部应用架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从那时起，微服务和十二因素应用程序等新挑战和概念不断涌现，并影响了我们设计应用程序的方式。微服务的核心是将应用程序逻辑分离到由单个团队拥有的可独立部署的单元中。十二因素应用程序方法旨在创建在动态云环境中运行和扩展的分布式、无状态应用程序。所有这些架构都引入了原则和最佳实践，这些原则和最佳实践塑造了我们构建应用程序内部架构的方式以及我们管理它的方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2应用程序架构演进时间表&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 2：应用程序架构演进时间表&#34; srcset=&#34;
               /blog/cloud-bound-applications/2_hu40b71820fd7baf24807d72301013b030_29518_bf3b668a3da2548818f7d4950c79bb55.webp 400w,
               /blog/cloud-bound-applications/2_hu40b71820fd7baf24807d72301013b030_29518_4547c53e895ffe872f72f0ba59a89e94.webp 760w,
               /blog/cloud-bound-applications/2_hu40b71820fd7baf24807d72301013b030_29518_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-bound-applications/2_hu40b71820fd7baf24807d72301013b030_29518_bf3b668a3da2548818f7d4950c79bb55.webp&#34;
               width=&#34;760&#34;
               height=&#34;278&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2：应用程序架构演进时间表
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;后来在应用程序架构演变时间表中，容器的主流采用和 Kubernetes 的引入彻底改变了应用程序的打包和编排方式。AWS Lambda 引入了高度可扩展的函数即服务 (FaaS) 的概念，将应用程序粒度的概念提升到一个新的水平，并将完整的基础设施管理责任卸载给云提供商。其他技术趋势，例如服务网格和多运行时微服务架构，也已经出现并将非功能方面商品化，例如网络和分布式开发原语，分别将它们提取到 sidecar 中。受微服务的启发，数据网格架构旨在将应用程序的分析数据架构分解为更小、独立的数据域，每个域都有自己的产品和团队。这些以及最近的趋势，例如应用程序优先的云服务，正在开始重塑应用程序的外部架构，我在本文中将其统称为“云绑定应用程序”。&lt;/p&gt;
&lt;h2 id=&#34;外部架构演化&#34;&gt;外部架构演化&lt;/h2&gt;
&lt;p&gt;外部架构是应用程序与其他团队和组织拥有的其他应用程序和基础设施相交的地方，通常以专用的本地中间件、存储系统或云服务的形式出现。应用程序连接到外部系统并卸载其部分职责的方式形成了外部架构。为了从基础架构中受益，应用程序需要绑定到该基础架构并强制执行清晰的边界以保持其敏捷性。一个应用程序的内部架构和实现应该能够在不改变另一个应用程序的情况下进行更改，外部依赖关系（例如云服务）可以在不改变内部结构的情况下进行交换。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-3外部应用架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 3：外部应用架构&#34; srcset=&#34;
               /blog/cloud-bound-applications/3_huf37fbf5460b713081b06bb34dc5f650c_50572_20a9750e727f34d326372f52c0225b9b.webp 400w,
               /blog/cloud-bound-applications/3_huf37fbf5460b713081b06bb34dc5f650c_50572_4956fef84911f343eb2add80f4d827f7.webp 760w,
               /blog/cloud-bound-applications/3_huf37fbf5460b713081b06bb34dc5f650c_50572_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-bound-applications/3_huf37fbf5460b713081b06bb34dc5f650c_50572_20a9750e727f34d326372f52c0225b9b.webp&#34;
               width=&#34;622&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3：外部应用架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从广义上讲，我们可以将应用程序与其周围环境绑定的方式分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算绑定是在计算平台（例如 Kubernetes、容器服务，甚至是 AWS Lambda 等无服务器函数）上运行应用程序所需的所有绑定、配置、API 和合约。大多数情况下，这些绑定对内部架构是透明的，并且由运营团队而非开发人员配置和使用。容器抽象是当今应用程序计算绑定最广泛的“API”。&lt;/li&gt;
&lt;li&gt;集成绑定是对应用程序所依赖的外部依赖项的所有其他绑定的总称。云服务还使用这些绑定与应用程序交互，通常是通过定义明确的 HTTP“API”或专门的消息传递和存储访问协议，例如 AWS S3、Apache Kafka、Redis API 等。集成绑定不像运行时绑定那样透明。开发人员需要围绕它们实现额外的逻辑，例如重试、TTL、延迟、死信队列 (DLQ) 等，并将它们绑定到应用程序的业务逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用程序在云上运行并通过使用这些绑定来使用其他服务。让我们更详细地了解这些绑定背后的内容。&lt;/p&gt;
&lt;h2 id=&#34;计算绑定&#34;&gt;计算绑定&lt;/h2&gt;
&lt;p&gt;对于运营团队来说，理想情况下，每个应用程序都是一个需要在计算平台上运行的黑盒单元。计算绑定用于管理 Kubernetes、AWS Lambda 和其他服务等平台上应用程序的生命周期。这些绑定以应用程序和应用程序运行平台之间的配置和 API 交互集合的形式形式化和定义。这些交互中的大部分对应用程序是透明的，只有少数 API 需要开发人员实现，例如健康端点和指标 API。这是目前 CNCF 对“云原生”定义  和范围的扩展，只要开发者实现云原生应用，他们可以在云计算平台上绑定运行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-4应用程序和平台计算绑定&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 4：应用程序和平台计算绑定&#34; srcset=&#34;
               /blog/cloud-bound-applications/4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_8757d39fa9a483b002667b7270c9d101.webp 400w,
               /blog/cloud-bound-applications/4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_ec0ac96c3ed0af4f5f841d784cc309c8.webp 760w,
               /blog/cloud-bound-applications/4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-bound-applications/4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_8757d39fa9a483b002667b7270c9d101.webp&#34;
               width=&#34;760&#34;
               height=&#34;616&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4：应用程序和平台计算绑定
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;要在云平台上可靠地运行，应用程序必须在从规范到最佳实践的多个层面上与之绑定。这是通过一组行业标准规范（例如容器 API、指标 API）实现的，例如基于 Prometheus、健康端点或云提供商规范（例如 AWS Lambda 或 AWS ECS 规范）。此外，通过云原生最佳技术和共享知识，例如健康检查、部署策略和放置策略。让我们看看当今使用的常见计算绑定。&lt;/p&gt;
&lt;h3 id=&#34;资源需求&#34;&gt;资源需求&lt;/h3&gt;
&lt;p&gt;包括微服务和函数在内的应用程序需要 CPU、内存和存储等资源。这些资源的定义因所使用的平台而异。例如，在 Kubernetes 上，CPU 和内存是通过请求和限制定义的，而在 AWS Lambda 上，用户 指定运行时分配的内存量，以及对应的 CPU 分配。存储在这些平台上的处理方式也不同，Kubernetes 使用临时存储和卷，而 Lambda 提供临时暂存资源和基于 Amazon EFS 挂载的持久存储。&lt;/p&gt;
&lt;h3 id=&#34;生命周期钩子&#34;&gt;生命周期钩子&lt;/h3&gt;
&lt;p&gt;由平台管理的应用程序通常需要了解重要的生命周期事件。例如，在 Kubernetes 上，init 容器等概念和 PostStart 和 PreStop 等钩子允许应用程序对这些事件做出反应。同样，Lambda 的 extensions API 允许应用程序拦截 Init、Invoke 和 Shutdown 阶段。处理生命周期事件的其他选项包括包装器脚本或特定于语言的运行时修改选项，例如 JVM 的关闭钩子。这些机制形成了平台和应用程序之间的契约，使其能够响应和管理自己的生命周期。&lt;/p&gt;
&lt;h3 id=&#34;健康检查&#34;&gt;健康检查&lt;/h3&gt;
&lt;p&gt;运行状况探测是平台监控应用程序运行状况并在必要时采取纠正措施（例如重新启动应用程序）的一种方式。由于请求的生命周期较短，Lambda 函数没有健康探测，而容器化应用程序和编排器（如 Kubernetes、AWS EKS 和 GCP Cloud Run）确实在其定义中包含 健康探测。这使平台能够确保应用程序平稳运行，并在应用程序运行不平稳时采取措施。&lt;/p&gt;
&lt;h3 id=&#34;部署和放置策略&#34;&gt;部署和放置策略&lt;/h3&gt;
&lt;p&gt;一旦知道所需的资源，计算平台就可以开始管理应用程序的生命周期。要以不损害业务逻辑完整性的方式执行此操作，平台必须了解扩展约束。有些应用程序被设计为单例。例如，它们需要维护已处理事件的顺序并且不能扩展到多个实例。其他有状态应用程序可能是仲裁驱动的，并且需要特定数量的最小实例连续运行才能正常运行。还有一些函数，例如无状态函数，可能有利于快速扩展以解决不断增加的负载峰值问题。一旦建立了应用程序的缩放指南，平台就会控制应用程序实例的启动和终止。&lt;/p&gt;
&lt;p&gt;计算还提供滚动、蓝绿、金丝雀、一次等多种部署策略，来控制服务更新的顺序。除了部署顺序之外，这些平台还允许用户指定放置首选项。例如，Kubernetes 提供标签、污点和容忍度、亲和力和反亲和力等选项，而 Lambda 允许用户在区域和边缘放置类型之间进行选择。这些首选项可确保部署应用程序并满足合规性和性能要求。&lt;/p&gt;
&lt;h3 id=&#34;网络流量&#34;&gt;网络流量&lt;/h3&gt;
&lt;p&gt;计算平台还负责将低级网络流量引导至服务实例。这是因为它负责部署排序、放置和自动缩放，这些都会影响流量如何定向到服务实例。健康检查也可以在流量管理中发挥作用，例如 GCP Cloud Run 和 Kubernetes 中的准备情况检查。通过处理这些任务，计算平台有助于确保流量高效且有效地路由到适当的服务实例。&lt;/p&gt;
&lt;h3 id=&#34;监控和报告&#34;&gt;监控和报告&lt;/h3&gt;
&lt;p&gt;任何用于分布式应用程序的计算平台都必须以日志、指标和跟踪的形式提供深入的应用程序洞察力。目前该领域几乎没有被广泛接受的事实标准：日志最好以结构化格式使用，例如 JSON 或其他行业特定标准。计算平台通常收集日志或为专门的日志提取和分析服务提供扩展点以访问日志。这可以是 Kubernetes 上的 DaemonSet，用于监控的 Lambda 合作伙伴扩展，或 Vercel 边缘功能日志 Drainer。计算平台必须支持指标和追踪数据的收集和分析，以全面了解分布式应用程序的性能和行为。有几种行业标准格式和工具可用于处理此数据 OpenTelemetry (OTEL) for Tracking 计算平台可以提供内置工具来收集和分析这些数据，或者为专门服务提供扩展点来访问数据。无论代码粒度（微服务或函数）或位置（边缘或非边缘）如何，计算平台都必须允许捕获日志、指标和追踪数据，并导出到其他同类最佳的云服务。例如 Honeycomb、DataDog、Grafana 等。&lt;/p&gt;
&lt;h3 id=&#34;计算绑定趋势&#34;&gt;计算绑定趋势&lt;/h3&gt;
&lt;p&gt;计算绑定与语言和应用程序运行时无关，主要由运营团队用于在运行时管理应用程序，而不是开发人员实现它们。&lt;/p&gt;
&lt;p&gt;虽然应用程序的大小和复杂性可能因整体和功能而异，但它们通常打包在具有健康检查端点、实施的生命周期挂钩和公开指标的容器中。了解这些计算绑定将帮助你有效地使用任何基于容器的计算平台，无论是本地 Kubernetes 集群、托管容器服务（例如 AWS ECS、Google Cloud Run、Azure Container App），还是基于函数的运行时（例如作为 AWS Lambda、GCP 函数或边缘运行时，例如 Vercel 边缘函数、CloudFlare worker 或 Netlify edge functions 等。使用开放的事实上的标准 API 不仅可以帮助你创建可移植的应用程序，还可以通过使用可跨云供应商和服务提供商移植的操作实践和工具来限制供应商锁定。&lt;/p&gt;
&lt;h2 id=&#34;集成绑定&#34;&gt;集成绑定&lt;/h2&gt;
&lt;p&gt;另一方面，集成绑定旨在供开发人员而不是运营团队使用。它们以常见的分布式系统实现领域为中心，例如服务调用、事件驱动交互、任务调度和有状态工作流编排。它们通过基于云的类似中间件的服务帮助将应用程序与专用存储系统和外部系统连接起来，在本文中统称为集成云。与容器提供计算抽象的方式相同，集成云服务提供与语言无关的集成抽象作为服务。这些原语独立于用例、应用程序实现、运行时和计算环境。例如重试模式、DLQ 模式、Saga 模式、服务发现和 断路器模式都可以集成为服务使用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5应用程序和平台集成绑定&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 5：应用程序和平台集成绑定&#34; srcset=&#34;
               /blog/cloud-bound-applications/5_hufb20aa7c61dad71a4c335dca460c4126_61270_d8bf9e364f58b2f09b5f0902a734a2a2.webp 400w,
               /blog/cloud-bound-applications/5_hufb20aa7c61dad71a4c335dca460c4126_61270_36cc25a7a9c022f4b9694728d36a7cb2.webp 760w,
               /blog/cloud-bound-applications/5_hufb20aa7c61dad71a4c335dca460c4126_61270_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-bound-applications/5_hufb20aa7c61dad71a4c335dca460c4126_61270_d8bf9e364f58b2f09b5f0902a734a2a2.webp&#34;
               width=&#34;760&#34;
               height=&#34;616&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5：应用程序和平台集成绑定
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今天不存在将所有主要模式公开为独立功能的纯集成云。早期的云服务正在提供其中一些集成原语作为存储系统（如 Kafka、Redis 等）的功能，但这些功能很少单独使用或与其他功能结合使用。这里值得注意的例外是 AWS EventBridge 和 Azure Event Grid 等服务，你可以将它们与来自同一提供商的多个云服务一起使用，但不能直接与其他提供商一起使用。这是一个快速发展的领域，有一些很好的例子和一些尚未填补的空白，但我相信它们会在未来出现。应用程序必须绑定到集成的云服务并卸载其中的一些开发人员职责才能运行。以下是集成云服务的主要类型和绑定方面。&lt;/p&gt;
&lt;h3 id=&#34;集成要求&#34;&gt;集成要求&lt;/h3&gt;
&lt;p&gt;与应用程序可以请求资源并向计算平台表达部署和放置偏好的方式相同，应用程序也可以请求和激活特定的集成绑定。这些绑定可以通过以声明方式传递给平台的配置来激活，或者在运行时通过编程交互来激活。例如，应用程序可以使用声明式和编程式订阅 pub/sub 主题。AWS Lambda 函数事件源可以通过配置以声明方式订阅，也可以通过客户端库或 SDK 请求集成平台注册或注销特定绑定以编程方式订阅。应用程序可以订阅 cron 作业触发器、激活外部系统的连接器、进行配置更改等等，所有这些都在集成云上运行。&lt;/p&gt;
&lt;h3 id=&#34;工作流程编排&#34;&gt;工作流程编排&lt;/h3&gt;
&lt;p&gt;持久服务编排逻辑是一种非常普遍的必需品，也是作为服务进行外部化和消费的主要候选者。因此，工作流编排是当今最著名的集成绑定类型之一。该服务的常见用途包括为服务和业务流程编排实施 Saga 模式、使用 AWS Step Functions、Google Stateful Functions、Azure Durable Functions 进行函数编排、使用 Google Workflow 进行任务分配等等。当使用这样的绑定时，部分应用程序编排状态和逻辑被卸载到另一个服务中。虽然应用程序服务具有内部状态和管理该状态的逻辑，但其他部分是外部的，可能在其他一些云服务中。这代表了当今应用程序作为一个独立的单元进行设计和操作的方式的转变。未来的应用程序不仅数据是外部的，而且集成也将是外部的。随着越来越多地采用集成云，更多的集成数据和逻辑将开始存在于外部。&lt;/p&gt;
&lt;h3 id=&#34;时间触发器&#34;&gt;时间触发器&lt;/h3&gt;
&lt;p&gt;时间绑定表示编排绑定的时间限制专业化。它只有一个目标，即根据给定的策略在特定时间触发各种服务。此类别中的示例包括 AWS EventBridge Scheduler、Google Cloud Scheduler、Upstash Qstack 服务等。&lt;/p&gt;
&lt;h3 id=&#34;事件驱动和消息服务&#34;&gt;事件驱动和消息服务&lt;/h3&gt;
&lt;p&gt;这些绑定充当事件存储来卸载请求和解耦应用程序，但它们越来越不限于存储和扩展以提供消息处理模式。它们在事件存储之上提供开发者原语，例如死信队列、重试、延迟传递和消息处理模式，例如过滤、聚合、重新排序、基于内容的路由、窃听等。这种绑定的例子有 Confluent Cloud kSQL、AWS EventBridge、Decodable Data Pipeline 等。&lt;/p&gt;
&lt;h3 id=&#34;外部连接器&#34;&gt;外部连接器&lt;/h3&gt;
&lt;p&gt;这些绑定有助于连接到外部系统。它们还执行数据规范化、错误处理、协议转换和数据转换。示例包括 Knative 源导入器、AWS EventBridge 连接器、Confluent Cloud 连接器、可解码的 Kafka 连接器、AWS Lambda 源和目标。&lt;/p&gt;
&lt;h3 id=&#34;健康检查-1&#34;&gt;健康检查&lt;/h3&gt;
&lt;p&gt;健康检查对于计算连接至关重要，失败的健康检查通常会导致应用程序重启。集成绑定也需要健康检查，但目的不同：集成健康检查不会影响应用程序的运行时，但它会告诉集成云应用程序是否能够处理集成驱动的交互。失败的集成状态检查会停止集成绑定，直到应用程序返回正常状态并且集成绑定恢复。通常，你可以使用相同的应用程序端点进行计算和集成绑定测试。一个很好的例子是 Dapr 应用程序 健康检查，它可以暂时阻止消费者和连接器。将数据插入不健康的应用程序。&lt;/p&gt;
&lt;h3 id=&#34;其他绑定&#34;&gt;其他绑定&lt;/h3&gt;
&lt;p&gt;还有更多的绑定，属于集成绑定的范畴。例如，Kubernetes Downward API 和 Lambda 环境变量等为应用程序提供内省数据，它为应用程序自省和元数据注入提供了一种简单的机制。配置和秘密绑定，其中秘密不仅在启动时注入到应用程序中，而且任何配置更新都通过 sidecars 推送到应用程序，例如 Hashicorp Vault Sidecar Injector 或者 Dapr 的 Configuration API, Kubernetes 的 Service Binding 设置 规范。和不太常见的模式，例如分布式锁，这也是一个集成绑定提供对共享资源的互斥访问。&lt;/p&gt;
&lt;h3 id=&#34;集成绑定趋势&#34;&gt;集成绑定趋势&lt;/h3&gt;
&lt;p&gt;容器正在成为最流行和广泛使用的可移植格式，用于打包和运行应用程序，无论它们是长期运行的微服务还是短期功能。另一方面，集成绑定可以分为不同的问题域，例如事件驱动的交互、有状态的编排和状态访问，并且在底层存储和使用模式方面有所不同。例如，Apache Kafka 是 事实上的标准、用于文档访问的 AWS S3 API、用于键值缓存的 Redis、用于关系数据访问的 PostgreSQL 等等。使它们成为标准的是围绕它们构建的库、工具和服务的不断增长的生态系统，为成熟度、稳定性和未来的向后兼容性提供了很大程度的保证。但这些 API 本质上仅限于存储访问，并且通常需要开发人员解决应用程序代码中的分布式系统挑战。与堆栈上层软件的商品化一致，集成绑定作为服务提供。越来越多的无服务器云服务提供了额外的集成功能，除了数据访问之外，应用程序代码还可以绑定这些功能。&lt;/p&gt;
&lt;p&gt;在此模型中，云绑定应用程序通常在无服务器计算基础设施上运行，遵循云原生原语。它与其他无服务器云服务绑定，用于服务编排、事件处理或同步交互，如下所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-6云绑定应用程序生态系统&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 6：云绑定应用程序生态系统&#34; srcset=&#34;
               /blog/cloud-bound-applications/6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_00bb2daef51a9f499f02107b5b006301.webp 400w,
               /blog/cloud-bound-applications/6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_2a597427cb8ea2d710a43b0d2a9fe03a.webp 760w,
               /blog/cloud-bound-applications/6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-bound-applications/6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_00bb2daef51a9f499f02107b5b006301.webp&#34;
               width=&#34;760&#34;
               height=&#34;638&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6：云绑定应用程序生态系统
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;CNCF 的 Dapr 是一个将大部分集成绑定和开发人员关注点整合到一个开源 API 中的项目。它提供同步服务调用、有状态服务编排、异步事件驱动交互和特定技术连接器作为 API。类似于容器和 Kubernetes 如何充当计算抽象，Dapr 充当外部服务的抽象。Dapr 还提供了独立于底层云服务且往往必须在应用层实现的集成能力，例如弹性策略、死信队列、延迟交付、跟踪、细粒度授权等。Dapr 被设计为多语言并在应用程序外部运行，从而可以轻松交换外部依赖项而无需更改应用程序的内部架构，如 Hexagon Architecture 中所述。虽然 Dapr 主要由实施应用程序的开发人员使用，但一旦引入，Dapr 就会增强分布式应用程序的可靠性和可见性，为运营和架构师团队提供 整体利益。要了解有关此主题的更多信息，请在今年晚些时候亲自或以虚拟方式参加 QConLondon，我将在那里讨论“应用程序优先的云服务如何改变游戏规则”。&lt;/p&gt;
&lt;h2 id=&#34;后云原生应用&#34;&gt;后云原生应用&lt;/h2&gt;
&lt;p&gt;云绑定应用代表了云原生的进步，从只解决计算问题到管理应用层需求。应用程序堆栈中的云服务从基础设施扩展到应用程序优先服务，加速了这一趋势。我们可以在以开发人员为中心的云服务的爆炸式增长中观察到这种转变，包括状态协调、事件驱动的应用程序基础架构、同步交互、基于云的开发和测试环境以及无服务运行时。这种向应用程序优先的云服务的转变正在产生一种新的应用程序架构，越来越多的应用程序逻辑在云服务中运行。应用程序与第三方云服务的这种混合允许开发人员分担更多责任，但是，它可能会限制不断变化的业务需求所需的灵活性和敏捷性。为了保持应用程序的内部和外部架构独立，应用程序和云服务需要在开发时通过清晰的边界解耦，并在运行时使用定义良好的开放 API 和格式进行深度绑定。正如容器和 Kubernetes 为计算提供了开放的 API，我们需要为应用程序集成抽象提供开放的 API。这将使操作实践和工具以及开发模式、功能和实践的可移植性和重用成为可能。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>开源评估框架</title>
      <link>https://cloudnative.to/blog/a-framework-for-open-source-evaluation/</link>
      <pubDate>Sun, 08 Aug 2021 17:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/a-framework-for-open-source-evaluation/</guid>
      <description>&lt;p&gt;本文翻译自 Bilgin Ibryam  的文章 &lt;a href=&#34;https://monetize.substack.com/p/a-framework-for-open-source-evaluation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A Framework for Open Source Evaluation&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如今，真&lt;a href=&#34;https://www.linuxjournal.com/content/open-vs-fauxpen&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;假&lt;/a&gt;开源无处不在。最近开源项目转为闭源的案例越来越多，同时也有不少闭源项目（按照 &lt;a href=&#34;https://opensource.org/osd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OSI 定义&lt;/a&gt;）像开源一样构建社区的例子。这怎么可能，开源项目不应该始终如此吗？&lt;/p&gt;
&lt;p&gt;开源不是非黑即白，它具有开放性、透明、协作性和信任性的多个&lt;a href=&#34;https://monetize.substack.com/p/a-holistic-vision-of-open-source&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;维度&lt;/a&gt;。有些开源是 Github 上的任何项目，有些必须通过 OSI 定义，有些是必须遵守不成文但普遍接受的开源规范。这里通过看一些商业和技术方面，再讨论社区管理习惯，来同大家分享一下我对评估开源项目的看法。&lt;/p&gt;
&lt;h2 id=&#34;免责声明&#34;&gt;免责声明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这些是我的个人观点，与我的雇主或我所属的软件基金会和项目无关。&lt;/li&gt;
&lt;li&gt;这不是法律或专业意见（我不是律师，也不是专门从事 OSS 评估的），而是外行的意见。
更新：我收到了多位开源律师的反馈并更新了文章！&lt;/li&gt;
&lt;li&gt;这篇博文由&lt;a href=&#34;https://monetize.substack.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;订阅&lt;/a&gt;和&lt;a href=&#34;https://twitter.com/bibryam/status/1371045284751507463&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;分享&lt;/a&gt;按钮赞助，点击这些按钮表示支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;知识产权&#34;&gt;知识产权&lt;/h2&gt;
&lt;p&gt;关于“开源”项目的第一个问题是关于知识产权的所有权。好消息是，即使不了解这些法律含义，你可以应用一个简单的 Litmus 测试。该项目是否属于你信任的信誉良好的开源基金会？例如，&lt;a href=&#34;https://www.fsf.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FSF&lt;/a&gt; 拥有其托管项目的版权，更多情况下拥有基金会（如 &lt;a href=&#34;https://www.apache.org/foundation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ASF&lt;/a&gt;、&lt;a href=&#34;https://www.linuxfoundation.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LF&lt;/a&gt;) 通过贡献者许可协议，聚合对其项目的贡献许可权。在任何一种情况下，你都可以相信他们将充当良好的去中心化管家，并且不会在一夜之间改变项目的未来方向。如果一个项目不属于信誉良好的软件基金会，而是由一家公司提供支持，那么问题是你是否信任该公司作为供应链合作伙伴。如果这些问题的答案是肯定的，请转到下一部分。如果答案是否定的，那么你最好调查一下版权所有者是谁，以及他们对你的长期前景和潜在风险是什么。今天的单一供应商开源项目，明天可能会变成闭源。&lt;/p&gt;
&lt;h2 id=&#34;许可&#34;&gt;许可&lt;/h2&gt;
&lt;p&gt;商标出现在许可之前的原因是软件的权利人（通常是作者）通过许可授予最终用户使用一个或多个软件副本的许可。自由软件许可证是一种说明，它授予源代码或其二进制形式的使用者修改和重新分发该软件的权利。如果没有许可，这些行为将受到版权法的禁止。这里的重点是权利人可以改变主意并更改许可。权利持有人可以决定在多个许可证下分发软件或随时将许可证更改为非开源许可证。该软件也可能在&lt;a href=&#34;https://opensource.org/node/878&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公共领域&lt;/a&gt;，在这种情况下，它不受版权法的限制。公共领域并不等同于开源许可证，这是一种不太流行的方法，我们可以在这里忽略。&lt;/p&gt;
&lt;p&gt;同样，如果不是律师，这是一个外行对许可的 Litmus 测试：该项目是否根据 OSI 批准的&lt;a href=&#34;https://opensource.org/licenses/alphabetical&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;许可清单&lt;/a&gt;获得的许可？如果答案是肯定的，那么你可以依靠这些基金会的尽职调查来审查、分类许可并指出任何限制。如果答案是否定的，请让你公司的律师来查看和解释许可上的每个字以及可能的许可兼容性影响。&lt;/p&gt;
&lt;h2 id=&#34;治理&#34;&gt;治理&lt;/h2&gt;
&lt;p&gt;在余下的检查中，我们正在从更多的商业和法律方面转向涉及开源项目领域的技术和社区。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-开源评估框架&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.substack.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F7f06c148-d675-4bb7-803e-b3704f0016ef_3309x2473.png&#34; alt=&#34;开源评估框架&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      开源评估框架
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;假设不担心商标持有方（未来的合作伙伴）、许可（使用开源软件的条款），下一个问题是治理。&lt;a href=&#34;https://www.oasis-open.org/policies-guidelines/open-projects-process/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;治理&lt;/a&gt;是项目决定谁来做什么、他们应该如何做以及何时做的规则或习惯。它定义了与不同项目角色相关的职责、特权和权限，以及人们如何分配到角色和从角色中删除。此处的示例是小型日常活动，例如谁有权批准拉取请求、投票给候选发布、就项目架构达成共识、定义项目路线图以及选举项目治理委员会。&lt;/p&gt;
&lt;p&gt;如果你正在评估对你的组织具有战略意义的项目，你想知道谁负责。不仅如此，你甚至可能&lt;a href=&#34;https://hackernoon.com/reciprocity-in-open-source-e60fb98ee1cc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;希望&lt;/a&gt;你的开发人员对项目的方向有发言权。&lt;/p&gt;
&lt;p&gt;还有一个简单的 Litmus 测试：对于开源基金会的项目，对于谁可以对重要决策进行投票，以及如何成为决策委员会的一部分，都有明确的规则。在某些基金会（例如 ASF）中，它基于社区成员的个人功绩，而在某些基金会（例如&lt;a href=&#34;https://www.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; CNCF &lt;/a&gt;）中，它从成为付费成员组织的员工开始。在基于区块链的开源项目中，它是基于&lt;a href=&#34;https://bit.ly/devprtcl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;令牌（Token）&lt;/a&gt;的投票持有人。其他基金会有不同的规则，但都力求在多个参与者之间实现中立和权力下放。如果一个项目由一家公司或一个人管理，你相信他们会为项目和社区的利益做出最佳决策。其中一些项目可能已经写下了他们遵循的治理规则，而有些可能根本没有。由你来确定治理动态及其对你的项目参与的重要性。除了具有治理透明度和公开决策之外，另一个方面是治理机构的信任度和声誉。当你查看项目的治理委员会时，是否有一位或一组具有经过验证的技术和社交技能的领导者，让你相信他们可以将项目提升到一个新的水平？或者你是否看到一个在政治斗争中不断争论的团体？这些是开源项目是否会成功并长期发展的一些指标，还是可以预期的头痛和停滞。&lt;/p&gt;
&lt;h2 id=&#34;基础设施&#34;&gt;基础设施&lt;/h2&gt;
&lt;p&gt;拥有开源许可可能在技术上有资格作为开源项目，但这并不能说明项目是否以开源方式构建。有许多在 OSI 批准的许可下发布的软件示例，但它们是在封闭的基础设施之后开发的。通过基础设施，我的意思是用户快速提问的聊天频道。进行更深入的开发人员讨论的论坛和邮件列表。审查拉取请求的源代码管理系统，以及运行测试和每晚创建二进制文件的构建服务器。&lt;/p&gt;
&lt;p&gt;对于关注开源项目的商务人士和律师来说，这些可能并不重要，但对于将要使用开源项目的技术人员来说，这些是一些假设的好处。这里要做的检查是探索软件是否是使用开放式基础设施以开源方式开发的，而不是闭门造车。以下是几个示例问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户可以在项目聊天中提出问题并在没有中间人的情况下从另一个用户那里得到答案吗？&lt;/li&gt;
&lt;li&gt;开发人员能否与项目提交者联系并获得深入的技术问题的答案？&lt;/li&gt;
&lt;li&gt;你能否运行最新版本并确认已知的错误已修复？&lt;/li&gt;
&lt;li&gt;架构师可以参加每周一次的社区电话会议并确定项目的未来方向吗？（原文 Can an architect the weekly community call and figure out the future direction of the project? ）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于封闭的基础架构，你必须创建支持工单并付费才能获得类似问题的答案。通过开放的基础设施和开放的参与，那些知道如何以开源方式工作的人可以获得答案。&lt;/p&gt;
&lt;h2 id=&#34;社区和采用&#34;&gt;社区和采用&lt;/h2&gt;
&lt;p&gt;开源软件的主要好处之一是它允许好创意的发展和传播。你可能拥有最先进的技术、最宽松的许可和开放式开发，但如果该软件没有不断壮大的社区和不断提高的采用率，那就是一个值得调查的迹象。不同的项目会有不同的采用率。有些可能会迅速成长为主流或被其他同类型项目所取代。一些项目可能有一个小但持续的增长率和一个持续数十年的生态社区。社区规模和采用率是开源项目的最终寿命指标。以下是你可以提出的一些示例问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目中有多少活跃的开发人员（提交者），平均提交率是多少？&lt;/li&gt;
&lt;li&gt;上个月有多少用户订阅了用户论坛以及提出了多少问题？&lt;/li&gt;
&lt;li&gt;软件的最新稳定版本已被下载多少次？&lt;/li&gt;
&lt;li&gt;还有哪些项目和服务&lt;a href=&#34;https://libraries.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;依赖&lt;/a&gt;并使用这个项目？&lt;/li&gt;
&lt;li&gt;有多少商业组织支持这个项目？&lt;/li&gt;
&lt;li&gt;是否有商业组织围绕它提供产品、支持和服务？&lt;/li&gt;
&lt;li&gt;这个项目有多少 StackOverflow 问题？&lt;/li&gt;
&lt;li&gt;有多少书籍、会议演讲和职位描述提到了这个项目？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行这些问题会给你一个指示，即该项目是在增长并成为其领域的事实上的标准，还是停滞不前并可能被下一个大项目所取代。&lt;/p&gt;
&lt;p&gt;通常，开源与快节奏的开发和创新有关。同时，开源也是一种创建广泛采用和创建非官方标准的机制。许多开源项目已经变成了标准，例如用于容器编排的 Kubernetes、用于流处理的 Apache Kafka、用于 Web 服务器的 Apache httpd 等。软件中最昂贵的事情之一是找到具有合适技能的人。使用采用率高的开源项目将使你有更好的机会找到技术娴熟的人，并让他们能够更长时间地重复使用他们的技能。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;根据开源项目的关键程度，有不同的风险和评估标准。对于战略性的、难以替代的项目，这将是你的 IT 基础设施的基础，你需要是已经成为其领域事实上的开源标准的完善项目。在这里确定谁拥有该项目的商标以及谁将成为你的长期合作伙伴非常重要。通常，这些合作伙伴是项目所属软件基金会的成员组织或持有项目 IP 的单个公司。对于后者，你可能需要考虑长期风险，例如核心开发人员分叉项目的机会、提供项目即服务的超大规模者、公司收购等。&lt;/p&gt;
&lt;p&gt;对于交付速度最重要的非战略性、战术性、短期项目，你可以让你的开发人员根据开放性、社区协作和热度（对于某些前端技术很重要）来推动选择和挑选项目。在这里，定期的安全修复、开发人员支持和许可兼容性检查等中短期风险可能就足够了。&lt;/p&gt;
&lt;p&gt;在任何一种情况下，都没有适合所有情况的单一评估标准。你必须在长期商业风险、技术稳定性与最新热度、创新和开发人员满意度之间取得平衡。这里的框架将为你概括需要探索的领域和需要考虑的一些风险。祝你好运！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>分布式系统在 Kubernetes 上的进化</title>
      <link>https://cloudnative.to/blog/distributed-systems-kubernetes/</link>
      <pubDate>Mon, 29 Mar 2021 22:30:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/distributed-systems-kubernetes/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://www.infoq.com/articles/distributed-systems-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Evolution of Distributed Systems on Kubernetes&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在 3 月份的 QCon 上，我做了一个关于 Kubernetes 的分布式系统进化的演讲。首先，我想先问一个问题，微服务之后是什么？我相信大家都有各自的答案，我也有我的答案。你会在最后发现我的想法是什么。为了达到这个目的，我建议大家看看分布式系统的需求是什么？以及这些需求在过去是如何发展的，从单体应用开始到 Kubernetes，再到最近的 Dapr、Istio、Knative 等项目，它们是如何改变我们做分布式系统的方式。我们将尝试对未来做一些预测。&lt;/p&gt;
&lt;h2 id=&#34;现代分布式应用&#34;&gt;现代分布式应用&lt;/h2&gt;
&lt;p&gt;为了给这个话题提供更多的背景信息，我认为的分布式系统是由数百个组件组成的系统。这些组件可以是有状态的、无状态的或者无服务器的。此外，这些组件可以用不同的语言创建，运行在混合环境上，并开发开源技术、开放标准和互操作性。我相信你可以使用闭源软件来构建这样的系统，也可以在 AWS 和其他地方构建。具体到这次演讲，我将关注 Kubernetes 生态系统，以及你如何在 Kubernetes 平台上构建这样一个系统。&lt;/p&gt;
&lt;p&gt;我们从分布式系统的需求讲起。我认为是我们要创建一个应用或者服务，并写一些业务逻辑。那从运行时的平台到构建分布式系统，我们还需要什么呢？在底层，最开始是我们要一些生命周期的能力。当你用任一语言开发你的应用时，我们希望有能力把这个应用可靠地打包和部署、回滚、健康检查。并且能够把应用部署到不同的节点上，并实现资源隔离、扩展、配置管理，以及所有这些。这些都是你创建分布式应用所需要的第一点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/55image001-1616431697020_hud54f2c89ee51f22ea452f59194b434bd_55223_21e5226137cfd71e298c0c87bf23be63.webp 400w,
               /blog/distributed-systems-kubernetes/55image001-1616431697020_hud54f2c89ee51f22ea452f59194b434bd_55223_19c14667acef199c3aea67e4b4680fed.webp 760w,
               /blog/distributed-systems-kubernetes/55image001-1616431697020_hud54f2c89ee51f22ea452f59194b434bd_55223_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/55image001-1616431697020_hud54f2c89ee51f22ea452f59194b434bd_55223_21e5226137cfd71e298c0c87bf23be63.webp&#34;
               width=&#34;760&#34;
               height=&#34;393&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第二点是围绕网络。我们有了应用之后，我们希望它能够可靠地连接到其他服务，无论该服务是在集群内部还是在外部。我们希望其具有服务发现、负载均衡的能力。为了不同的发布策略或是其他的一些原因的我们希望有流量转移的能力。然后我们还希望其具有与其他系统进行弹性通信的能力，无论是通过重试、超时还是断路器。要有适当的安全保障，并且要有足够的监控、追踪、可观察性等等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/25image002-1616431698392_hu5614317372ebb2362c2b6eddac788ce1_53311_96ec5ff9c1b0467bc2528e9aefda8061.webp 400w,
               /blog/distributed-systems-kubernetes/25image002-1616431698392_hu5614317372ebb2362c2b6eddac788ce1_53311_71a14735d66f1edc2c783ec863568b68.webp 760w,
               /blog/distributed-systems-kubernetes/25image002-1616431698392_hu5614317372ebb2362c2b6eddac788ce1_53311_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/25image002-1616431698392_hu5614317372ebb2362c2b6eddac788ce1_53311_96ec5ff9c1b0467bc2528e9aefda8061.webp&#34;
               width=&#34;760&#34;
               height=&#34;399&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们有了网络之后，接下来就是我们希望有能力与不同的 API 和端点交互，即资源绑定&amp;ndash;与其他协议和不同的数据格式交互。甚至能够从一种数据格式转换成另一种数据格式。我还会在这里加入诸如过滤功能，也就是说，当我们订阅一个主题时，我们也许只对某些事件感兴趣。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/45image003-1616431697873_hua74b57a88b5cffc8e49c7c7b49ec1bcd_52010_ef6fc030694e691364610047087abcd5.webp 400w,
               /blog/distributed-systems-kubernetes/45image003-1616431697873_hua74b57a88b5cffc8e49c7c7b49ec1bcd_52010_c9b2288654abfb01608ffe14af8b819d.webp 760w,
               /blog/distributed-systems-kubernetes/45image003-1616431697873_hua74b57a88b5cffc8e49c7c7b49ec1bcd_52010_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/45image003-1616431697873_hua74b57a88b5cffc8e49c7c7b49ec1bcd_52010_ef6fc030694e691364610047087abcd5.webp&#34;
               width=&#34;760&#34;
               height=&#34;391&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;你认为最后一类是什么？是状态。当我在说状态和有状态的抽象时，我并不是在谈论实际的状态管理，比如数据库或者文件系统的功能。我要说的更多是有关幕后依赖状态的开发人员抽象。可能，你需要具有工作流管理的能力。也许你想管理运行时间长的进程或者做临时调度或者某些定时任务来定期运行服务。也许你还想进行分布式缓存，具有幂等性或者支持回滚。所有这些都是开发人员级的原语，但在幕后，它们依赖于具有某种状态。你想随意使用这些抽象来创建完善的分布式系统。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/26image004-1616431697348_hu42226c3fb2d38026966441b210a11aaa_56096_9fc2bfc34132fd0f4c163353b8e7194b.webp 400w,
               /blog/distributed-systems-kubernetes/26image004-1616431697348_hu42226c3fb2d38026966441b210a11aaa_56096_2b48a30ede87147fcd95e7b65f38b800.webp 760w,
               /blog/distributed-systems-kubernetes/26image004-1616431697348_hu42226c3fb2d38026966441b210a11aaa_56096_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/26image004-1616431697348_hu42226c3fb2d38026966441b210a11aaa_56096_9fc2bfc34132fd0f4c163353b8e7194b.webp&#34;
               width=&#34;760&#34;
               height=&#34;430&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们将使用这个分布式系统原语的框架来评估它们在 Kubernetes 和其他项目上的变化情况。&lt;/p&gt;
&lt;h2 id=&#34;单体架构传统中间件功能&#34;&gt;单体架构——传统中间件功能&lt;/h2&gt;
&lt;p&gt;假设我们从单体架构以及如何获得这些能力开始。在那种情况下，首先是当我说单体的时候，在分布式应用的情况下我想到的是 ESB。ESB 是相当强大的，当我们检查我们的需求列表时，我们会说 ESB 对所有有状态的抽象有很好的支持。&lt;/p&gt;
&lt;p&gt;使用 ESB，你可以进行长时间运行的流程的编排、分布式事务、回滚和幂等。此外，ESB 还提供了出色的资源绑定能力，并且有数百个连接器，支持转换、编排，甚至有联网功能。最后，ESB 甚至可以做服务发现和负载均衡。&lt;/p&gt;
&lt;p&gt;它具有围绕网络连接的弹性的所有功能，因此它可以进行重试。可能 ESB 本质上不是很分布式，所以它不需要非常高级的网络和发布能力。ESB 欠缺的主要是生命周期管理。因为它是单一运行时，所以第一件事就是你只能使用一种语言。通常是创建实际运行时的语言，Java、.NET 或者其他的语言。然后，因为是单一运行时，我们不能轻松地进行声明式的部署或者自动调配。部署是相当大且非常重的，所以它通常涉及到人机交互。这种单体架构的另一个难点是扩展：“我们无法扩展单个组件。”&lt;/p&gt;
&lt;p&gt;最后却并非最不重要的一点是，围绕隔离，无论是资源隔离还是故障隔离。使用单体架构无法完成所有这些工作。从我们的需求框架来看，ESB 的单体架构不符合条件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/40image005-1616431696438_hu708bff12652a40b58706ef620c15b0e7_53626_daac7d81a45dc6ba9bbcd0892eb1bbcf.webp 400w,
               /blog/distributed-systems-kubernetes/40image005-1616431696438_hu708bff12652a40b58706ef620c15b0e7_53626_ee698e3f079c771b7f0246e812a26da4.webp 760w,
               /blog/distributed-systems-kubernetes/40image005-1616431696438_hu708bff12652a40b58706ef620c15b0e7_53626_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/40image005-1616431696438_hu708bff12652a40b58706ef620c15b0e7_53626_daac7d81a45dc6ba9bbcd0892eb1bbcf.webp&#34;
               width=&#34;760&#34;
               height=&#34;401&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;云原生架构微服务和-kubernetes&#34;&gt;云原生架构——微服务和 Kubernetes&lt;/h2&gt;
&lt;p&gt;接下来，我建议我们研究一下云原生架构以及这些需求是如何变化的。如果我们从一个非常高的层面来看，这些架构是如何发生变化的，云原生可能始于微服务运动。微服务使我们可以按业务领域进行拆分单体应用。事实证明，容器和 Kubernetes 实际上是管理这些微服务的优秀平台。让我们来看一下 Kubernetes 对于微服务特别有吸引力的一些具体特性和功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/13image006-1616431699209_hu5e18866c37cc176a6ae0b1af37a2e441_45812_e13925fd065eda48206aac52390840b7.webp 400w,
               /blog/distributed-systems-kubernetes/13image006-1616431699209_hu5e18866c37cc176a6ae0b1af37a2e441_45812_01d30720cd794e3b1cdef1479ea69c3f.webp 760w,
               /blog/distributed-systems-kubernetes/13image006-1616431699209_hu5e18866c37cc176a6ae0b1af37a2e441_45812_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/13image006-1616431699209_hu5e18866c37cc176a6ae0b1af37a2e441_45812_e13925fd065eda48206aac52390840b7.webp&#34;
               width=&#34;760&#34;
               height=&#34;447&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从一开始，进行健康状况探测的能力就是 Kubernetes 受欢迎的原因。在实践中，这意味着当你将容器部署到 Pod 中时，Kubernetes 会检查进程的运行状况。通常情况下，该过程模型还不够好。你可能仍然有一个已启动并正在运行的进程，但是它并不健康。这就是为什么还可以使用就绪度和存活度检查的原因。Kubernetes 会做一个就绪度检查，以确定你的应用在启动期间何时准备接受流量。它将进行活跃度检查，以检查服务的运行状况。在 Kubernetes 之前，这并不是很流行，但今天几乎所有语言、所有框架、所有运行时都有健康检查功能，你可以在其中快速启动端点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/29image007-1616431696697_hu8d4e7c8efa8c7f5d7b720bd0b5e33c05_35745_9bf7e94a04a8950adc8d2df9c2df0649.webp 400w,
               /blog/distributed-systems-kubernetes/29image007-1616431696697_hu8d4e7c8efa8c7f5d7b720bd0b5e33c05_35745_37dc3e67869bf514a5bff113fa8748b8.webp 760w,
               /blog/distributed-systems-kubernetes/29image007-1616431696697_hu8d4e7c8efa8c7f5d7b720bd0b5e33c05_35745_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/29image007-1616431696697_hu8d4e7c8efa8c7f5d7b720bd0b5e33c05_35745_9bf7e94a04a8950adc8d2df9c2df0649.webp&#34;
               width=&#34;760&#34;
               height=&#34;388&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes 引入的下一个特性是围绕应用程序的托管生命周期——我的意思是，你不再控制何时启动、何时关闭服务。你相信平台可以做到这一点。Kubernetes 可以启动你的应用；它可以将其关闭，然后在不同的节点上移动它。为此，你必须正确执行平台在应用启动和关闭期间告诉你的事件。&lt;/p&gt;
&lt;p&gt;Kubernetes 流行的另一件特性是围绕着声明式部署。这意味着你不再需要启动服务；检查日志是否已经启动。你不必手动升级实例——支持声明式部署的 Kubernetes 可以为你做到这一点。根据你选择的策略，它可以停止旧实例并启动新实例。此外，如果出现问题，可以进行回滚。&lt;/p&gt;
&lt;p&gt;另外就是声明你的资源需求。创建服务时，将其容器化。最好告诉平台该服务将需要多少 CPU 和内存。Kubernetes 利用这些信息为你的工作负载找到最佳节点。在使用 Kubernetes 之前，我们必须根据我们的标准将实例手动放置到一个节点上。现在，我们可以根据自己的偏好来指导 Kubernetes，它将为我们做出最佳的决策。&lt;/p&gt;
&lt;p&gt;如今，在 Kubernetes 上，你可以进行多语言配置管理。无需在应用程序运行时进行配置查找就可以进行任何操作。Kubernetes 会确保配置最终在工作负载所在的同一节点上。这些配置被映射为卷或环境变量，以供你的应用程序使用。&lt;/p&gt;
&lt;p&gt;事实证明，我刚才谈到的那些特定功能也是相关的。比如说，如果要进行自动放置，则必须告诉 Kubernetes 服务的资源需求。然后，你必须告诉它要使用的部署策略。为了让策略正确运行，你的应用程序必须执行来自环境的事件。它必须执行健康检查。一旦采用了所有这些最佳实践并使用所有这些功能，你的应用就会成为出色的云原生公民，并且可以在 Kubernetes 上实现自动化了（这是在 Kubernetes 上运行工作负载的基本模式）。最后，还有围绕着构建 Pod 中的容器、配置管理和行为，还有其他模式。&lt;/p&gt;
&lt;p&gt;我要简要介绍的下一个主题是工作负载。从生命周期的角度来看，我们希望能够运行不同的工作负载。我们也可以在 Kubernetes 上做到这一点。运行十二要素应用程序和无状态微服务非常简单。Kubernetes 可以做到这一点。这不是你将要承担的唯一工作量。可能你还有有状态的工作负载，你可以使用有状态集在 Kubernetes 上完成此工作。&lt;/p&gt;
&lt;p&gt;你可能还有的另一个工作负载是单例。也许你希望某个应用程序的实例是整个集群中应用程序的唯一一个实例&amp;ndash;你希望它成为可靠的单例。如果失败，则重新启动。因此，你可以根据需求以及是否希望单例至少具有一种或最多一种语义来在有状态集和副本集之间进行选择。你可能还有的另一个工作负载是围绕作业和定时作业&amp;ndash;有了 Kubernetes，你也可以实现这些。&lt;/p&gt;
&lt;p&gt;如果我们将所有这些 Kubernetes 功能映射到我们的需求，则 Kubernetes 可以满足生命周期需求。我通常创建的需求列表主要是由 Kubernetes 今天提供给我们的。这些是任何平台上的预期功能，而 Kubernetes 可以为你的部署做的是配置管理、资源隔离和故障隔离。此外，除了无服务器本身之外，它还支持其他工作负载。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/12image008-1616431698134_hu69bfcaf0275d855173937b532c9e478f_53968_6367753cf3b400159a2d1c2615f94655.webp 400w,
               /blog/distributed-systems-kubernetes/12image008-1616431698134_hu69bfcaf0275d855173937b532c9e478f_53968_16ba557bd161575047e34c323bba84d0.webp 760w,
               /blog/distributed-systems-kubernetes/12image008-1616431698134_hu69bfcaf0275d855173937b532c9e478f_53968_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/12image008-1616431698134_hu69bfcaf0275d855173937b532c9e478f_53968_6367753cf3b400159a2d1c2615f94655.webp&#34;
               width=&#34;760&#34;
               height=&#34;413&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然后，如果这就是 Kubernetes 给开发者提供的全部功能，那么我们该如何扩展 Kubernetes 呢？以及如何使它具有更多功能？因此，我想描述当今使用的两种常用方法。&lt;/p&gt;
&lt;h2 id=&#34;进程外扩展机制&#34;&gt;进程外扩展机制&lt;/h2&gt;
&lt;p&gt;首先是 Pod 的概念，Pod 是用于在节点上部署容器的抽象。此外，Pod 给我们提供了两组保证：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一组是部署保证 &amp;ndash; Pod 中的所有容器始终位于同一个节点上。这意味着它们可以通过 localhost 相互通信，也可以使用文件系统或通过其他 IPC 机制进行异步通信。&lt;/li&gt;
&lt;li&gt;Pod 给我们的另一组保证是围绕生命周期的。Pod 中的所有容器并非都相等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/22image009-1616431698660_hud137a7b59c43bb79e5474cc782bc3d8a_62938_ed7893f9e17908fa7e40e1c4a66fb845.webp 400w,
               /blog/distributed-systems-kubernetes/22image009-1616431698660_hud137a7b59c43bb79e5474cc782bc3d8a_62938_6f30a946e190e1e88f649755d5c6e261.webp 760w,
               /blog/distributed-systems-kubernetes/22image009-1616431698660_hud137a7b59c43bb79e5474cc782bc3d8a_62938_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/22image009-1616431698660_hud137a7b59c43bb79e5474cc782bc3d8a_62938_ed7893f9e17908fa7e40e1c4a66fb845.webp&#34;
               width=&#34;760&#34;
               height=&#34;420&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;根据使用的是 init 容器还是应用程序容器，你会获得不同的保证。例如，init 容器在开始时运行；当 Pod 启动时，它按顺序一个接一个地运行。他们仅在之前的容器已成功完成时运行。它们有助于实现由容器驱动的类似工作流的逻辑。&lt;/p&gt;
&lt;p&gt;另一方面，应用程序容器是并行运行的。它们在整个 Pod 的生命周期中运行，这也是 sidecar 模式的基础。sidecar 可以运行多个容器，这些容器可以协作并共同为用户提供价值。这也是当今我们看到的扩展 Kubernetes 附加功能的主要机制之一。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/9image010-1616431695489_hua77c596ee023023b85912c79676ca8d3_46005_85e1c176fcddda12b32344969b905dc8.webp 400w,
               /blog/distributed-systems-kubernetes/9image010-1616431695489_hua77c596ee023023b85912c79676ca8d3_46005_5def5d2365b19f84d127e2ec89d957c1.webp 760w,
               /blog/distributed-systems-kubernetes/9image010-1616431695489_hua77c596ee023023b85912c79676ca8d3_46005_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/9image010-1616431695489_hua77c596ee023023b85912c79676ca8d3_46005_85e1c176fcddda12b32344969b905dc8.webp&#34;
               width=&#34;760&#34;
               height=&#34;510&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了解释以下功能，我必须简要地告诉你 Kubernetes 内部的工作方式。它是基于调谐循环的。调谐循环的思想是将期望状态驱动到实际状态。在 Kubernetes 中，很多功能都是靠这个来实现的。例如，当你说我要两个 Pod 实例，这系统的期望状态。有一个控制循环不断地运行，并检查你的 Pod 是否有两个实例。如果不存在两个实例，它将计算差值。它将确保存在两个实例。&lt;/p&gt;
&lt;p&gt;这方面的例子有很多。一些是副本集或有状态集。资源定义映射到控制器是什么，并且每个资源定义都有一个控制器。该控制器确保现实世界与所需控制器相匹配，你甚至可以编写自己的自定义控制器。&lt;/p&gt;
&lt;p&gt;当在 Pod 中运行应用程序时，你将无法在运行时加载任何配置文件更改。然而，你可以编写一个自定义控制器，检测 config map 的变化，重新启动 Pod 和应用程序&amp;ndash;从而获取配置更改。&lt;/p&gt;
&lt;p&gt;事实证明，即使 Kubernetes 拥有丰富的资源集合，但它们并不能满足你的所有不同需求。Kubernetes 引入了自定义资源定义的概念。这意味着你可以对需求进行建模并定义适用于 Kubernetes 的 API。它与其他 Kubernetes 原生资源共存。你可以用能理解模型的任何语言编写自己的控制器。你可以设计一个用 Java 实现的 ConfigWatcher，描述我们前面所解释的内容。这就是 operator 模式，即与自定义资源定义一起使用的控制器。如今，我们看到很多 operator 加入，这就是第二种扩展 Kubernetes 附加功能的方式。&lt;/p&gt;
&lt;p&gt;接下来，我想简单介绍一下基于 Kubernetes 构建的一些平台，这些平台大量使用 sidecar 和 operator 来给开发者提供额外的功能。&lt;/p&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;让我们从服务网格开始，什么是服务网格？&lt;/p&gt;
&lt;p&gt;我们有两个服务，服务 A 要调用服务 B，并且可以用任何语言。把这个当做是我们的应用工作负载。服务网格使用 sidecar 控制器，并在我们的服务旁边注入一个代理。你最终会在 Pod 中得到两个容器。代理是一个透明的代理，你的应用对这个代理完全无感知&amp;ndash;它拦截所有传入和传出的流量。此外，代理还充当数据防火墙。&lt;/p&gt;
&lt;p&gt;这些服务代理的集合代表了你的数据平面，并且很小且无状态。为了获得所有状态和配置，它们依赖于控制平面。控制平面是保持所有配置，收集指标，做出决定并与数据平面进行交互的有状态部分。此外，它们是不同控制平面和数据平面的正确选择。事实证明，我们还需要一个组件 - 一个 API 网关，以将数据获取到我们的集群中。一些服务网格具有自己的 API 网关，而某些使用第三方。如果你研究下所有这些组件，它们将提供我们所需的功能。&lt;/p&gt;
&lt;p&gt;API 网关主要专注于抽象我们服务的实现。它隐藏细节并提供边界功能。服务网格则相反。在某种程度上，它增强了服务内的可见性和可靠性。可以说，API 网关和服务网格共同提供了所有网络需求。要在 Kubernetes 上获得网络功能，仅使用服务是不够的：“你需要一些服务网格。”&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/19image011-1616431696146_hu127ebd62f0d3220acd57b52b7f2e07a9_74048_502779d94c50457ef18b7b7385f1839d.webp 400w,
               /blog/distributed-systems-kubernetes/19image011-1616431696146_hu127ebd62f0d3220acd57b52b7f2e07a9_74048_a3b621452e40c8e58bea995083727f96.webp 760w,
               /blog/distributed-systems-kubernetes/19image011-1616431696146_hu127ebd62f0d3220acd57b52b7f2e07a9_74048_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/19image011-1616431696146_hu127ebd62f0d3220acd57b52b7f2e07a9_74048_502779d94c50457ef18b7b7385f1839d.webp&#34;
               width=&#34;760&#34;
               height=&#34;592&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;什么是-knative&#34;&gt;什么是 Knative？&lt;/h2&gt;
&lt;p&gt;我要讨论的下一个主题是 Knative，这是 Google 几年前启动的一个项目。它是 Kubernetes 之上的一层，可为您提供无服务器功能，并具有两个主要模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Knative 服务 - 围绕着请求 - 应答交互，以及&lt;/li&gt;
&lt;li&gt;Knative Eventing - 更多的是用于事件驱动的交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只是让你感受一下，Knative Serving 是什么？通过 Knative Serving，你可以定义服务，但这不同于 Kubernetes 服务。这是 Knative 服务。使用 Knative 服务定义工作负载后，你就会得到具有无服务器的特征的部署。你不需要有启动并运行实例。它可以在请求到达时从零开始。你得到的是无服务器的能力；它可以迅速扩容，也可以缩容到零。&lt;/p&gt;
&lt;p&gt;Knative Eventing 为我们提供了一个完全声明式的事件管理系统。假设我们有一些要与之集成的外部系统，以及一些外部的事件生产者。在底部，我们将应用程序放在具有 HTTP 端点的容器中。借助 Knative Eventing，我们可以启动代理，该代理可以触发 Kafka 映射的代理，也可以在内存或者某些云服务中。此外，我们可以启动连接到外部系统的导入器，并将事件导入到我们的代理中。这些导入器可以基于，例如，具有数百个连接器的 Apache Camel。&lt;/p&gt;
&lt;p&gt;一旦我们将事件发送给代理，然后用 YAML 文件声明，我们可以让容器订阅这些事件。在我们的容器中，我们不需要任何消息客户端&amp;ndash;比如 Kafka 客户端。我们的容器将使用云事件通过 HTTP POST 获取事件。这是一个完全平台管理的消息传递基础设施。作为开发人员，你必须在容器中编写业务代码，并且不处理任何消息传递逻辑。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/8image012-1616431698919_hu4c3644c5f992f4b7e733085eb3a9bd36_59931_caea628e677e750ddd0ee5b6014c4a2c.webp 400w,
               /blog/distributed-systems-kubernetes/8image012-1616431698919_hu4c3644c5f992f4b7e733085eb3a9bd36_59931_29a486aa309e216863c4be5808aa1035.webp 760w,
               /blog/distributed-systems-kubernetes/8image012-1616431698919_hu4c3644c5f992f4b7e733085eb3a9bd36_59931_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/8image012-1616431698919_hu4c3644c5f992f4b7e733085eb3a9bd36_59931_caea628e677e750ddd0ee5b6014c4a2c.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从我们的需求的角度来看，Knative 可以满足其中的一些要求。从生命周期的角度来看，它为我们的工作负载提供了无服务器的功能，因此能够将其扩展到零，并从零开始激活。从网络的角度来看，如果服务网格之间存在某些重叠，则 Knative 也可以进行流量转移。从绑定的角度来看，它对使用 Knative 导入程序进行绑定提供了很好的支持。它可以使我们进行发布/订阅，或点对点交互，甚至可以进行一些排序。它可以满足几类需求。&lt;/p&gt;
&lt;h2 id=&#34;什么是-dapr&#34;&gt;什么是 Dapr？&lt;/h2&gt;
&lt;p&gt;另一个使用 sidecar 和 operator 的项目是 &lt;a href=&#34;https://dapr.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dapr&lt;/a&gt;，它是微软几个月前才开始并且正在迅速流行起来。此外，1.0 版本 &lt;a href=&#34;https://www.infoq.com/news/2021/02/dapr-production-ready/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;被认为是生产可用的&lt;/a&gt;。它是一个作为 sidecar 的分布式系统工具包&amp;ndash;Dapr 中的所有内容都是作为 sidecar 提供的，并且有一套他们所谓的构件或功能集的集合。&lt;/p&gt;
&lt;p&gt;这些功能是什么呢？第一组功能是围绕网络。Dapr 可以进行服务发现和服务之间的点对点集成。同样，它也可以进行服务网格的追踪、可靠通信、重试和恢复。第二套功能是围绕资源绑定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它有很多云 API、不同系统的连接器，以及&lt;/li&gt;
&lt;li&gt;也可以做消息发布/订阅和其他逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有趣的是，Dapr 还引入了状态管理的概念。除了 Knative 和服务网格提供的功能外，Dapr 在状态存储之上进行了抽象。此外，你通过存储机制支持与 Dapr 进行基于键值的交互。&lt;/p&gt;
&lt;p&gt;在较高的层次上，架构是你的应用程序位于顶部，可以使用任何语言。你可以使用 Dapr 提供的客户端库，但你不必这样做。你可以使用语言功能来执行称为 sidecar 的 HTTP 和 gRPC。与 服务网格的区别在于，这里的 Dapr sidecar 不是一个透明的代理。它是一个显式代理，你必须从你的应用中调用它，并通过 HTTP 或 gRPC 与之交互。根据你需要的功能，Dapr 可以与其他如云服务的系统对话。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/18image013-1616431699532_hu032dbcf074c5e67827d8145c72bd2833_52500_e216d3f0bfda9626d7b836ef50babb71.webp 400w,
               /blog/distributed-systems-kubernetes/18image013-1616431699532_hu032dbcf074c5e67827d8145c72bd2833_52500_1921e2ea2dcf270bd60b7faf81ccd3a6.webp 760w,
               /blog/distributed-systems-kubernetes/18image013-1616431699532_hu032dbcf074c5e67827d8145c72bd2833_52500_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/18image013-1616431699532_hu032dbcf074c5e67827d8145c72bd2833_52500_e216d3f0bfda9626d7b836ef50babb71.webp&#34;
               width=&#34;760&#34;
               height=&#34;396&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 Kubernetes 上，Dapr 是作为 sidecar 部署的，并且可以在 Kubernetes 之外工作（不仅仅是 Kubernetes）。此外，它还有一个 operator &amp;ndash; 而 sidecar 和 Operator 是主要的扩展机制。其他一些组件管理证书、处理基于 actor 的建模并注入 sidecar。你的工作负载与 sidecar 交互，并尽其所能与其他服务对话，让你与不同的云提供商进行互操作。它还为你提供了额外的分布式系统功能。&lt;/p&gt;
&lt;p&gt;综上所述，这些项目所提供的功能，我们可以说 ESB 是分布式系统的早期化身，其中我们有集中式的控制平面和数据平面&amp;ndash;但是扩展性不好。在云原生中，集中式控制平面仍然存在，但是数据平面是分散的&amp;ndash;并且具有隔音功能和高度的可扩展性。&lt;/p&gt;
&lt;p&gt;我们始终需要 Kubernetes 来做良好的生命周期管理，除此之外，你可能还需要一个或多个附加组件。你可能需要 Istio 来进行高级联网。你可能会使用 Knative 来进行无服务器工作负载，或者使用 Dapr 来做集成。这些框架可与 Istio 和 Envoy 很好的配合使用。从 Dapr 和 Knative 的角度来看，你可能必须选择一个。它们共同以云原生的方式提供了我们过去在 ESB 上拥有的东西。&lt;/p&gt;
&lt;h2 id=&#34;未来云原生趋势--生命周期趋势&#34;&gt;未来云原生趋势&amp;ndash;生命周期趋势&lt;/h2&gt;
&lt;p&gt;在接下来的部分，我列出了一些我认为在这些领域正在发生令人振奋的发展的项目。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/8image014-1616431695762_huf074039ea60c8be2649b2197aa5df36c_78774_9bedd9fc6fe5100bbf315e93f8c23513.webp 400w,
               /blog/distributed-systems-kubernetes/8image014-1616431695762_huf074039ea60c8be2649b2197aa5df36c_78774_bcb99c52a4160e16ab690e34f1a78f18.webp 760w,
               /blog/distributed-systems-kubernetes/8image014-1616431695762_huf074039ea60c8be2649b2197aa5df36c_78774_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/8image014-1616431695762_huf074039ea60c8be2649b2197aa5df36c_78774_9bedd9fc6fe5100bbf315e93f8c23513.webp&#34;
               width=&#34;760&#34;
               height=&#34;443&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我想从生命周期开始。通过 Kubernetes，我们可以为应用程序提供一个有用的生命周期，这可能不足以进行更复杂的生命周期管理。比如，如果你有一个更复杂的有状态应用，则可能会有这样的场景，其中 Kubernetes 中的部署原语不足以为应用提供支持。&lt;/p&gt;
&lt;p&gt;在这些场景下，你可以使用 operator 模式。你可以使用一个 operator 来进行部署和升级，还可以将 S3 作为服务备份的存储介质。此外，你可能还会发现 Kubernetes 的实际健康检查机制不够好。假设存活检查和就绪检查不够好。在这种情况下，你可以使用 operator 对你的应用进行更智能的存活和就绪检查，然后在此基础上进行恢复。&lt;/p&gt;
&lt;p&gt;第三个领域就是自动伸缩和调整。你可以让 operator 更好的了解你的应用，并在平台上进行自动调整。目前，编写 operator 的框架主要有两个，一个是 Kubernetes 特别兴趣小组的 Kubebuilder，另一个是红帽创建的 operator 框架的一部分&amp;ndash;operator SDK。它有以下几个方面的内容：&lt;/p&gt;
&lt;p&gt;Operator SDK 让你可以编写 operator &amp;ndash; operator 生命周期管理器来管理 operator 的生命周期，以及可以发布你的 operator 到 OperatorHub。如今在 OperatorHub，你会看到 100 多个 operator 用于管理数据库、消息队列和监控工具。从生命周期空间来看，operator 可能是 Kubernetes 生态系统中发展最活跃的领域。&lt;/p&gt;
&lt;h2 id=&#34;网络趋势---envoy&#34;&gt;网络趋势 - Envoy&lt;/h2&gt;
&lt;p&gt;我选的另一个项目是 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;。服务网格接口规范的引入将使你更轻松地切换不同的服务网格实现。在部署上 Istio 对架构进行了一些整合。你不再需要为控制平面部署 7 个 Pod；现在，你只需要部署一次就可以了。更有趣的是在 Envoy 项目的数据平面上所正在发生的：越来越多的第 7 层协议被添加到 Envoy 中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/11image015-1616431697613_huea764231e7ad3c84ca0ccaf0a20186ac_63595_223ec537b0a2df487e0fa436f5838bb8.webp 400w,
               /blog/distributed-systems-kubernetes/11image015-1616431697613_huea764231e7ad3c84ca0ccaf0a20186ac_63595_47d86bc43466bce1b9098a782a691d1f.webp 760w,
               /blog/distributed-systems-kubernetes/11image015-1616431697613_huea764231e7ad3c84ca0ccaf0a20186ac_63595_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/11image015-1616431697613_huea764231e7ad3c84ca0ccaf0a20186ac_63595_223ec537b0a2df487e0fa436f5838bb8.webp&#34;
               width=&#34;760&#34;
               height=&#34;379&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;服务网格增加了对更多协议的支持，比如 MongoDB、ZooKeeper、MySQL、Redis，而最新的协议是 Kafka。我看到 Kafka 社区现在正在进一步改进他们的协议，使其对服务网格更加友好。我们可以预料将会有更紧密的集成、更多的功能。最有可能的是，会有一些桥接的能力。你可以从服务中在你的应用本地做一个 HTTP 调用，而代理将在后台使用 Kafka。你可以在应用外部，在 sidecar 中针对 Kafka 协议进行转换和加密。&lt;/p&gt;
&lt;p&gt;另一个令人兴奋的发展是引入了 HTTP 缓存。现在 Envoy 可以进行 HTTP 缓存。你不必在你的应用中使用缓存客户端。所有这些都是在 sidecar 中透明地完成的。有了 tap 过滤器，你可以 tap 流量并获得流量的副本。最近，WebAssembly 的引入，意味着如果你要为 Envoy 编写一些自定义的过滤器，你不必用 C++ 编写，也不必编译整个 Envoy 运行时。你可以用 WebAssembly 写你的过滤器，然后在运行时进行部署。这些大多数还在进行中。它们不存在，说明数据平面和服务网格无意停止，仅支持 HTTP 和 gRPC。他们有兴趣支持更多的应用层协议，为你提供更多的功能，以实现更多的用例。最主要的是，随着 WebAssembly 的引入，你现在可以在 sidecar 中编写自定义逻辑。只要你没有在其中添加一些业务逻辑就可以了。&lt;/p&gt;
&lt;h2 id=&#34;绑定趋势---apache-camel&#34;&gt;绑定趋势 - Apache Camel&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://camel.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache Camel&lt;/a&gt; 是一个用于集成的项目，它具有很多使用企业集成模式连接到不同系统的连接器。 比如 &lt;a href=&#34;https://camel.apache.org/releases/release-3.0.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Camel version 3&lt;/a&gt; 就深度集成到了 Kubernetes 中，并且使用了我们到目前为止所讲的那些原语，比如 operator。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/7image016-1616431694981_hua38d05c81c0134063261df9b925fb430_58074_37cf49bbb4103a3057bb76a48040bb4c.webp 400w,
               /blog/distributed-systems-kubernetes/7image016-1616431694981_hua38d05c81c0134063261df9b925fb430_58074_de919b81507db635ff36ebf0805c1118.webp 760w,
               /blog/distributed-systems-kubernetes/7image016-1616431694981_hua38d05c81c0134063261df9b925fb430_58074_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/7image016-1616431694981_hua38d05c81c0134063261df9b925fb430_58074_37cf49bbb4103a3057bb76a48040bb4c.webp&#34;
               width=&#34;760&#34;
               height=&#34;374&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;你可以在 Camel 中用 Java、JavaScript 或 YAML 等语言编写你的集成逻辑。最新的版本引入了一个 Camel operator，它在 Kubernetes 中运行并理解你的集成。当你写好 Camel 应用，将其部署到自定义资源中，operator 就知道如何构建容器或查找依赖项。根据平台的能力，不管是只用 Kubernetes，还是带有 Knative 的 Kubernetes，它都可以决定要使用的服务以及如何实现集成。在运行时之外有相当多的智能 &amp;ndash; 包括 operator &amp;ndash; 所有这些都非常快地发生。为什么我会说这是一个绑定的趋势？主要是因为 Apache Camel 提供的连接器的功能。这里有趣的一点是它如何与 Kubernetes 深度集成。&lt;/p&gt;
&lt;h2 id=&#34;状态趋势---cloudstate&#34;&gt;状态趋势 - Cloudstate&lt;/h2&gt;
&lt;p&gt;另一个我想讨论的项目是 &lt;a href=&#34;https://cloudstate.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloudstate&lt;/a&gt; 和与状态相关的趋势。Cloudstate 是 Lightbend 的一个项目，主要致力于无服务器和功能驱动的开发。最新发布的版本，正在使用 sidecar 和 operator 与 Kubernetes 进行深度集成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/8image017-1616431996943_hubcde24facbc976ae26944d05640d8149_55189_b9a2d486020416fec8cab54bcb5f4913.webp 400w,
               /blog/distributed-systems-kubernetes/8image017-1616431996943_hubcde24facbc976ae26944d05640d8149_55189_0c037c9589d4ab9f60ca066b6ecafb79.webp 760w,
               /blog/distributed-systems-kubernetes/8image017-1616431996943_hubcde24facbc976ae26944d05640d8149_55189_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/8image017-1616431996943_hubcde24facbc976ae26944d05640d8149_55189_b9a2d486020416fec8cab54bcb5f4913.webp&#34;
               width=&#34;760&#34;
               height=&#34;447&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个创意是，当你编写你的功能时，你在功能中要做的就是使用 gRPC 来获取状态并与之进行交互。整个状态管理在与其他 sidecar 群集的 sidear 中进行。它使你能够进行事件溯源、CQRS、键值查询、消息传递。&lt;/p&gt;
&lt;p&gt;从应用程序角度来看，你并不了解所有这些复杂性。你所做的只是调用一个本地的 sidecar，而 sidecar 会处理这些复杂的事情。它可以在后台使用两个不同的数据源。而且它拥有开发人员所需的所有有状态抽象。&lt;/p&gt;
&lt;p&gt;到目前为止，我们已经看到了云原生生态系统中的最新技术以及一些仍在进行中的开发。我们如何理解这一切？&lt;/p&gt;
&lt;h2 id=&#34;多运行时微服务已经到来&#34;&gt;多运行时微服务已经到来&lt;/h2&gt;
&lt;p&gt;如果你看微服务在 Kubernetes 上的样子，则将需要使用某些平台功能。此外，你将需要首先使用 Kubernetes 的功能进行生命周期管理。然后，很有可能透明地，你的服务会使用某些服务网格（例如 Envoy）来获得增强的网络功能，无论是流量路由、弹性、增强的安全性，甚至出于监控的目的。除此之外，根据你的场景和使用的工作负载可能需要 Dapr 或者 Knative。所有这些都代表了进程外附加的功能。剩下的就是编写业务逻辑，不是放在最上面而是作为一个单独的运行时来编写。未来的微服务很有可能将是由多个容器组成的这种多运行时。有些是透明的，有些则是非常明确的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/6image018-1616431996411_hu9677256e25fb448d00b8799539a8db26_68705_dd911c70c87ababcaa021975d6921c95.webp 400w,
               /blog/distributed-systems-kubernetes/6image018-1616431996411_hu9677256e25fb448d00b8799539a8db26_68705_3e3a644dd5f670ad484a92e4f5555ed1.webp 760w,
               /blog/distributed-systems-kubernetes/6image018-1616431996411_hu9677256e25fb448d00b8799539a8db26_68705_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/6image018-1616431996411_hu9677256e25fb448d00b8799539a8db26_68705_dd911c70c87ababcaa021975d6921c95.webp&#34;
               width=&#34;760&#34;
               height=&#34;367&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;智能的-sidecar-和愚蠢的管道&#34;&gt;智能的 sidecar 和愚蠢的管道&lt;/h2&gt;
&lt;p&gt;如果更深入地看，那可能是什么样的，你可以使用一些高级语言编写业务逻辑。是什么并不重要，不必仅是 Java，因为你可以使用任何其他语言并在内部开发自定义逻辑。&lt;/p&gt;
&lt;p&gt;你的业务逻辑与外部世界的所有交互都是通过 sidecar 发生的，并与平台集成进行生命周期管理。它为外部系统执行网络抽象，为你提供高级的绑定功能和状态抽象。sidecar 是你不需要开发的东西。你可以从货架上拿到它。你用一点 YAML 或 JSON 配置它，然后就可以使用它。这意味着你可以轻松地更新 sidecar，因为它不再被嵌入到你的运行时。这使得打补丁、更新变得更加更容易。它为我们的业务逻辑启用了多语言运行时。&lt;/p&gt;
&lt;h2 id=&#34;微服务之后是什么&#34;&gt;微服务之后是什么？&lt;/h2&gt;
&lt;p&gt;这让我想到了最初的问题，微服务之后是什么？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/distributed-systems-kubernetes/6image020-1616431995910_huc332df9c1174ce33ca52c85dfb347e8a_51753_a4bc8c8b9d659807b481f39d897184e8.webp 400w,
               /blog/distributed-systems-kubernetes/6image020-1616431995910_huc332df9c1174ce33ca52c85dfb347e8a_51753_45f16ca76ee9a490fb2a52243da0317c.webp 760w,
               /blog/distributed-systems-kubernetes/6image020-1616431995910_huc332df9c1174ce33ca52c85dfb347e8a_51753_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/distributed-systems-kubernetes/6image020-1616431995910_huc332df9c1174ce33ca52c85dfb347e8a_51753_a4bc8c8b9d659807b481f39d897184e8.webp&#34;
               width=&#34;760&#34;
               height=&#34;366&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果我们看下架构的发展历程，应用架构在很高的层面上是从单体应用开始的。然而微服务给我们提供了如何把一个单体应用拆分成独立的业务域的指导原则。之后又出现了无服务器和功能即服务（FaaS），我们说过可以按操作将其进一步拆分，从而实现极高的可扩展性 - 因为我们可以分别扩展每个操作。&lt;/p&gt;
&lt;p&gt;我想说的是 FaaS 并不是最好的模式 &amp;ndash; 因为功能并不是实现合理的复杂服务的最佳模式，在这种情况下，当多个操作必须与同一个数据集进行交互时，你希望它们驻留在一起。可能是多运行时（我把它称为 &lt;a href=&#34;https://www.infoq.com/articles/multi-runtime-microservice-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mecha 架构&lt;/a&gt;），在该架构中你将业务逻辑放在一个容器中，而所有与基础设施相关的关注点作为一个单独的容器存在。它们共同代表多运行时微服务。也许这是一个更合适的模型，因为它有更好的属性。&lt;/p&gt;
&lt;p&gt;你可以获得微服务的所有好处。仍然将所有域和所有限界上下文放在一处。你将所有的基础设施和分布式应用需求放在一个单独的容器中，并在运行时将它们组合在一起。大概，现在最接近这种模型的是 Dapr。他们正在遵循这种模型。如果你仅对网络方面感兴趣，那么可能使用 Envoy 也会接近这种模型。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Bilgin Ibryam&lt;/strong&gt; 是红帽公司的产品经理和前架构师、提交人，并且是 Apache 软件基金会的成员。他是开源布道者，经常写博客、发表演讲，是 &lt;a href=&#34;https://k8spatterns.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Patterns&lt;/a&gt; 和 Camel Design Patterns 书籍的作者。Bilgin 目前的工作主要集中在分布式系统、事件驱动架构以及可重复的云原生应用开发模式和实践上。请关注他 @bibryam 了解未来类似主题的更新。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
