<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>张哲然 | 云原生社区</title>
    <link>https://cloudnative.to/author/%E5%BC%A0%E5%93%B2%E7%84%B6/</link>
      <atom:link href="https://cloudnative.to/author/%E5%BC%A0%E5%93%B2%E7%84%B6/index.xml" rel="self" type="application/rss+xml" />
    <description>张哲然</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Wed, 21 Aug 2019 15:39:09 +1000</lastBuildDate>
    <image>
      <url>https://cloudnative.to/author/%E5%BC%A0%E5%93%B2%E7%84%B6/avatar_hue38add62c87b7486d80c9f3fda25dfc1_12220_270x270_fill_q75_lanczos_center.jpg</url>
      <title>张哲然</title>
      <link>https://cloudnative.to/author/%E5%BC%A0%E5%93%B2%E7%84%B6/</link>
    </image>
    
    <item>
      <title>基于Flux项目的云原生GitOps实践</title>
      <link>https://cloudnative.to/blog/flux-get-start-easy/</link>
      <pubDate>Wed, 21 Aug 2019 15:39:09 +1000</pubDate>
      <guid>https://cloudnative.to/blog/flux-get-start-easy/</guid>
      <description>&lt;h2 id=&#34;什么是gitops&#34;&gt;什么是GitOps?&lt;/h2&gt;
&lt;p&gt;GitOps, 这已经并不是一个新鲜的概念了。2018年5月初在丹麦举行的哥本哈根KubeCon大会上，Weaveworks公司的演讲将GitOps与Istio Service Mesh进行了集成，如果说以前Docker Swarm与Kubernetes竞争之时Docker公司提出了Docker Native，CNCF基于Kubernetes提出了自己的Cloud Native，毫不夸张的说，Weaveworks公司开源的Weave Flux也可以说是GitOps的‘Native’了。而在2019年8月20日，Flux项目也最终成功加入了CNCF Sandbox，成为了CNCF Sandbox中的一员。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-flux-cd-diagrampng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;flux-cd-diagram.png&#34; srcset=&#34;
               /blog/flux-get-start-easy/flux-cd-diagram_hu74aa861270d7c49d79efe52df022777c_42102_13dc7f788d43ff63edd16a0c7fcf2eae.webp 400w,
               /blog/flux-get-start-easy/flux-cd-diagram_hu74aa861270d7c49d79efe52df022777c_42102_ea9c4711dacf6a1322d4bb731be17e6d.webp 760w,
               /blog/flux-get-start-easy/flux-cd-diagram_hu74aa861270d7c49d79efe52df022777c_42102_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/flux-get-start-easy/flux-cd-diagram_hu74aa861270d7c49d79efe52df022777c_42102_13dc7f788d43ff63edd16a0c7fcf2eae.webp&#34;
               width=&#34;760&#34;
               height=&#34;345&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      flux-cd-diagram.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当然，GitOps的概念是从DevOps慢慢延伸出来的。把时间轴向前调调整，如2014年左右如火如荼的DevOps一样，当时从大到小的互联网企业都在招聘DevOps工程师。然而慢慢脱离了以前DevOps理念的不成熟，随着DevOps的发展，人们才慢慢意识到DevOps并不是所谓的&amp;quot;运维开发&amp;quot;, 而是一种注重了开发团队、测试团队、运维团队的更好的沟通协作，从而去实现持续集成和持续交付的最佳实践。&lt;/p&gt;
&lt;p&gt;如果说之前对DevOps的理念理解是&amp;quot;顾名思义&amp;quot;而导致的问题，那么现在的GitOps也多多少少面临着同样的境地，GitOps绝非是仅仅用Git去做CI/CD的Pipeline，既然Weaveworks开源的Weave Flux可以成为GitOps的主流实践，其给出的描述是这样的: “如果说DevOps的CI/CD Pipeline的终点是互联网公司交付的产品或者是我们最终发布的线上业务，GitOps则把目标转向了当前的容器编排事实标准&amp;ndash;Kubernetes，而GitOps则是一种进行Kubernetes集群管理和应用程序交付的方法。”&lt;/p&gt;
&lt;p&gt;这样一来，GitOps就于传统的DevOps划清了界限。更明确一点说: “DevOps注重的是产品发布中开发/运维/测试的沟通与协作，GitOps则更加贴近集群管理。这个集群还得是&amp;quot;拥抱云原生&amp;quot;基础设施的Kubernetes集群。”&lt;/p&gt;
&lt;p&gt;既然贴近了云原生和Kubernetes，就不得不提到云原生12要素。更值得关注的是，这12要素的第一条就是&amp;quot;基准代码，多份部署&amp;quot;。GitOps的设计者也意识到了这一点，在GitOps中，一旦Git仓库中的代码被更改，CI/CD Pipeline也就会对我们的Kubernetes集群进行更改。GitOps摒弃了传统部署环境的多份环境多份配置文件，并且设计者也应用了Kubernetes控制循环的思想，用Git管理的Kubernetes集群的期望状态也会和Git仓库中的实时状态不断地进行比较。&lt;/p&gt;
&lt;p&gt;接下来的实战就一起来看看Flux项目是怎么用Git来管理整个Kubernetes集群的。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;flux-cd-实践&#34;&gt;Flux CD 实践&lt;/h2&gt;
&lt;p&gt;Flux的安装默认提供了两种方式，传统的使用yaml文件部署的方式或者通过Helm的部署。但是Flux暂未支持Helm的V3版本，所以我们使用传统方式去部署(笔者闲谈:由于笔者使用的是Helm V3版本，也坚信去Tiller化的正确性，但是目前开源社区对Helm V3版本的响应程度着实不高，也导致更多人把精力转向了Kubernetes原生的Kustomize)&lt;/p&gt;
&lt;p&gt;我们直接Clone Flux项目的Github Repo&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;% git clone https://github.com/fluxcd/flux
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;% &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; flux/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;% vim deploy/flux-deployment.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里，我们需要将&amp;ndash;git-url更改为存储生产环境yaml文件的Github Repo，当然如果不想把生产环境的yaml文件托管在Github上，Flux也提供了Gitlab的支持去更好的进行私有环境的部署与管理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-git-repo-configpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Git-Repo-Config.png&#34; srcset=&#34;
               /blog/flux-get-start-easy/Git-Repo-Config_hufa527b4daf39c3a0d645df1385827328_9027_5137fc789cade61115da30f4e1f0eaef.webp 400w,
               /blog/flux-get-start-easy/Git-Repo-Config_hufa527b4daf39c3a0d645df1385827328_9027_5b9c4c50be4a6f447c81293adf710e5e.webp 760w,
               /blog/flux-get-start-easy/Git-Repo-Config_hufa527b4daf39c3a0d645df1385827328_9027_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/flux-get-start-easy/Git-Repo-Config_hufa527b4daf39c3a0d645df1385827328_9027_5137fc789cade61115da30f4e1f0eaef.webp&#34;
               width=&#34;570&#34;
               height=&#34;45&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Git-Repo-Config.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--git-url&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;git@github.com:YOUR-GITHUB/REPO-NAME
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;PS: 因为官方的例子过于繁琐，笔者在这里提供了更直观的例子。这个例子很简单，只由一个Nginx-Deployment和带有NodePort的Nginx-Service组成，项目已经存储在&lt;a href=&#34;https://github.com/youngercloud/flux-get-start-easy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部署Flux到Kubernetes集群中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;% kubectl apply -f deploy
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;PS: 如果使用minikube进行实验，请确保安装socat&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;% yum install -y socat
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;确保Flux Pod进入Running状态并Ready后，我们还需要下载fluxctl二进制命令包，fluxctl将与Kubernetes集群中的flux Pod进行交互。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-flux-deployedpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Flux-Deployed.png&#34; srcset=&#34;
               /blog/flux-get-start-easy/Flux-Deployed_hu1d5fcddf9b9bf6a873c070222baff502_15141_80bc6da7a61cd1c1752c32eb8b7ecb31.webp 400w,
               /blog/flux-get-start-easy/Flux-Deployed_hu1d5fcddf9b9bf6a873c070222baff502_15141_a5ff02c6de999a3eef1712bb218a19d2.webp 760w,
               /blog/flux-get-start-easy/Flux-Deployed_hu1d5fcddf9b9bf6a873c070222baff502_15141_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/flux-get-start-easy/Flux-Deployed_hu1d5fcddf9b9bf6a873c070222baff502_15141_80bc6da7a61cd1c1752c32eb8b7ecb31.webp&#34;
               width=&#34;617&#34;
               height=&#34;76&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Flux-Deployed.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;% wget https://github.com/fluxcd/flux/releases/download/1.13.1/fluxctl_linux_amd64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;% mv fluxctl_linux_amd64 fluxctl &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; chmod +x fluxctl &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; cp fluxctl /usr/local/bin/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;fluxctl安装好之后，我们需要部署我们的Deploy Key到Github Repo上，以实现本地集群和远端Github Repo的连调。&lt;/p&gt;
&lt;p&gt;我们可以通过fluxctl identity命令获取Flux的SSH公钥，如果你想打造一个更方便管理的环境，Flux也可以使用系统SSH所产生的私钥，具体的做法是先删除原本Flux的secret，再通过&amp;ndash;from-file=priveate_key的方式重新创建需要被Pod挂载的Secret私钥。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;% fluxctl identity
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当我们在Git Repo中通过SSH私密部署好Deploy Key并Allow Read/Write Access权限后，我们就可以尝试本地环境和远端Repo的同步了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;% fluxctl sync
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果没有问题的话，Flux会返回以下信息:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-first-sync-successpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;First-Sync-Success.png&#34; srcset=&#34;
               /blog/flux-get-start-easy/First-Sync-Success_hu50905f03cd4478648b0142e4dadcf69b_16412_07c27e3bb0d18e5d1cebacc12068dae4.webp 400w,
               /blog/flux-get-start-easy/First-Sync-Success_hu50905f03cd4478648b0142e4dadcf69b_16412_3dd37016d5c8333129a4d02aca0351f2.webp 760w,
               /blog/flux-get-start-easy/First-Sync-Success_hu50905f03cd4478648b0142e4dadcf69b_16412_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/flux-get-start-easy/First-Sync-Success_hu50905f03cd4478648b0142e4dadcf69b_16412_07c27e3bb0d18e5d1cebacc12068dae4.webp&#34;
               width=&#34;601&#34;
               height=&#34;88&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      First-Sync-Success.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这条信息的出现表明了集群同步已经完毕。接下来我们就可以尝试使用Git去管理Kubernetes集群了。&lt;/p&gt;
&lt;p&gt;我们先执行&lt;code&gt;kubectl get all&lt;/code&gt;查看Kubernetes集群的当前状态。
可以清楚的看到，我们没有手动的使用kubectl执行任何操作，Flux已经自动的帮我们做好了本地集群和远端Git Repo的同步工作，Nginx-Pod已经处在了Running状态。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-nginx-deployment-succeedpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Nginx-Deployment-Succeed.png&#34; srcset=&#34;
               /blog/flux-get-start-easy/Nginx-Deployment-Succeed_hu48298baec5683f45e3d2d0aedb57184b_37547_8042c71c4aac24714f4c43566e45dc30.webp 400w,
               /blog/flux-get-start-easy/Nginx-Deployment-Succeed_hu48298baec5683f45e3d2d0aedb57184b_37547_6f35f9fa9a5e74ce66a5e8036d8feaf6.webp 760w,
               /blog/flux-get-start-easy/Nginx-Deployment-Succeed_hu48298baec5683f45e3d2d0aedb57184b_37547_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/flux-get-start-easy/Nginx-Deployment-Succeed_hu48298baec5683f45e3d2d0aedb57184b_37547_8042c71c4aac24714f4c43566e45dc30.webp&#34;
               width=&#34;685&#34;
               height=&#34;136&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Nginx-Deployment-Succeed.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们可以使用curl命令对已经被Flux部署在Kubernetes集群中的Nginx进行访问测试，可以看到访问测试是成功的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-nginx-old-curlpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Nginx-Old-Curl.png&#34; srcset=&#34;
               /blog/flux-get-start-easy/Nginx-Old-Curl_huf6c5b6d4ae894002e7b42ac9e0502960_29675_e8c3812dec05998b39d0174aa3a0fab0.webp 400w,
               /blog/flux-get-start-easy/Nginx-Old-Curl_huf6c5b6d4ae894002e7b42ac9e0502960_29675_97c91408446ed42ed1d1213e9296ae82.webp 760w,
               /blog/flux-get-start-easy/Nginx-Old-Curl_huf6c5b6d4ae894002e7b42ac9e0502960_29675_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/flux-get-start-easy/Nginx-Old-Curl_huf6c5b6d4ae894002e7b42ac9e0502960_29675_e8c3812dec05998b39d0174aa3a0fab0.webp&#34;
               width=&#34;423&#34;
               height=&#34;244&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Nginx-Old-Curl.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这时，如果我们尝试用git去对集群做出更改，整体的流程和我们平时修改代码的流程是大致相同的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 如果本地仓库没有yaml文件，我们需要先从远端仓库pull下来我们的yaml&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 在本地仓库去更改我们的yaml文件，在这个例子中，我对之前所部署的Nginx版本做出了修改，从1.13.12升级到了1.14.2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-change-to-1142png&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Change-to-1.14.2.png&#34; srcset=&#34;
               /blog/flux-get-start-easy/Change-to-1.14.2_hu98ea0129d32ce09286372ae59895e8ea_35014_654105ec7d4518c348d13103a29cb9f4.webp 400w,
               /blog/flux-get-start-easy/Change-to-1.14.2_hu98ea0129d32ce09286372ae59895e8ea_35014_f9b994af237bb9e950856a52924838b0.webp 760w,
               /blog/flux-get-start-easy/Change-to-1.14.2_hu98ea0129d32ce09286372ae59895e8ea_35014_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/flux-get-start-easy/Change-to-1.14.2_hu98ea0129d32ce09286372ae59895e8ea_35014_654105ec7d4518c348d13103a29cb9f4.webp&#34;
               width=&#34;325&#34;
               height=&#34;472&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Change-to-1.14.2.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. git add FILE_CHANGED&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. git commit -m &amp;ldquo;DESCRIPTION&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. git push&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦我们的代码被提交到远端的GitRepo仓库后，我们就可以再次使用&lt;code&gt;fluxctl sync&lt;/code&gt;命令去进行同步。如果不执行这条命令，Flux也会过几分钟之后自动的去进行同步。&lt;/p&gt;
&lt;p&gt;通过curl命令的测试结果我们可以看到，集群更新已经完毕，我们Kubernetes集群中的Nginx也修改到了1.14.2版本。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-new-version-successpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;New-Version-Success.png&#34; srcset=&#34;
               /blog/flux-get-start-easy/New-Version-Success_hub151637868ed681043acab49afd35fd4_28950_444795e9421ecd0754c54799a071bea4.webp 400w,
               /blog/flux-get-start-easy/New-Version-Success_hub151637868ed681043acab49afd35fd4_28950_6a4bda03041a36d3a581e1fe47805225.webp 760w,
               /blog/flux-get-start-easy/New-Version-Success_hub151637868ed681043acab49afd35fd4_28950_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/flux-get-start-easy/New-Version-Success_hub151637868ed681043acab49afd35fd4_28950_444795e9421ecd0754c54799a071bea4.webp&#34;
               width=&#34;421&#34;
               height=&#34;238&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      New-Version-Success.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;参考连接&#34;&gt;参考连接:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Flux项目Github Repo： &lt;a href=&#34;https://github.com/fluxcd/flux&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/fluxcd/flux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Flux项目官方网站： &lt;a href=&#34;https://fluxcd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://fluxcd.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-flux-logopng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Flux-Logo.png&#34; srcset=&#34;
               /blog/flux-get-start-easy/Flux-Logo_hu97d7ddaef3a42dc8b80bf4b6183bd66f_96330_4676405a88ace1b44a88ec567c3613f8.webp 400w,
               /blog/flux-get-start-easy/Flux-Logo_hu97d7ddaef3a42dc8b80bf4b6183bd66f_96330_c4e157ab78dbc7e573f119a230c349e6.webp 760w,
               /blog/flux-get-start-easy/Flux-Logo_hu97d7ddaef3a42dc8b80bf4b6183bd66f_96330_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/flux-get-start-easy/Flux-Logo_hu97d7ddaef3a42dc8b80bf4b6183bd66f_96330_4676405a88ace1b44a88ec567c3613f8.webp&#34;
               width=&#34;760&#34;
               height=&#34;331&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Flux-Logo.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
