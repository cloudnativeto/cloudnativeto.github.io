<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>李文权 | 云原生社区（中国）</title>
    <link>https://cloudnative.to/author/%E6%9D%8E%E6%96%87%E6%9D%83/</link>
      <atom:link href="https://cloudnative.to/author/%E6%9D%8E%E6%96%87%E6%9D%83/index.xml" rel="self" type="application/rss+xml" />
    <description>李文权</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 06 Aug 2020 19:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/author/%E6%9D%8E%E6%96%87%E6%9D%83/avatar_huf8211f9576c817f3463ba2bbd6abcea5_28904_270x270_fill_q75_lanczos_center.jpg</url>
      <title>李文权</title>
      <link>https://cloudnative.to/author/%E6%9D%8E%E6%96%87%E6%9D%83/</link>
    </image>
    
    <item>
      <title>编译运行 Linux 内核源码中的 eBPF 示例代码</title>
      <link>https://cloudnative.to/blog/compile-bpf-examples/</link>
      <pubDate>Thu, 06 Aug 2020 19:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/compile-bpf-examples/</guid>
      <description>&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;声明：下文提到的&lt;code&gt;bpf/BPF&lt;/code&gt;字样是泛指，包括&lt;code&gt;cBPF&lt;/code&gt;和&lt;code&gt;eBPF&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过文章，你能了解 Linux 内核代码中关于 bpf 程序的编译运行机制，并能学会如何基于 Linux 内核 bpf 示例环境编写你自己的 bpf 程序。文章涉及的实验环境和代码可以到这个 git repo 获取：
&lt;a href=&#34;https://github.com/nevermosby/linux-bpf-learning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/nevermosby/linux-bpf-learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近 Kubecon 2020 China 上已经有了 3 个关于 bpf 的中文分享（来自腾讯和 PingCAP），也看到国内第一梯队公司越来越关心 bpf 这项新技术，欢迎大家都能加入 bpf 学习队伍。&lt;/p&gt;
&lt;h2 id=&#34;内核源码里的-bpf-示例代码概述&#34;&gt;内核源码里的 BPF 示例代码概述&lt;/h2&gt;
&lt;p&gt;示例代码里基本是&lt;strong&gt;kern&lt;/strong&gt;和&lt;strong&gt;user&lt;/strong&gt;成对出现，也就是对于一个示例来说，分别提供了在内核空间运行的和用户空间运行的程序，绝对是良心之作了。&lt;/p&gt;
&lt;h2 id=&#34;下载-linux-内核源代码&#34;&gt;下载 Linux 内核源代码&lt;/h2&gt;
&lt;p&gt;First thing first，第一步是下载内核代码。&lt;/p&gt;
&lt;h3 id=&#34;选择内核版本&#34;&gt;选择内核版本&lt;/h3&gt;
&lt;p&gt;目前社区维护的内核版本繁多，你需要确定下载哪个版本的代码。个人建议是下载与你的操作系统运行一致的内核版本，避免后续编译时出现不兼容问题。&lt;/p&gt;
&lt;h3 id=&#34;选择下载渠道&#34;&gt;选择下载渠道&lt;/h3&gt;
&lt;p&gt;代码下载渠道也很多：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过 Linux 社区官方仓库下载。以下几个网站都是官方维护的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/torvalds/linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&lt;/a&gt;
观察下来，只要有新的commit，基本是实时同步的，下载最新版本的内核代码肯定没问题。如果你跟我一样，需要相对较旧的版本，只要切换相关的目标tag即可。我的内核版本是&lt;strong&gt;v4.15.0&lt;/strong&gt;，下载地址参考如下：
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/tree/v4.15&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/torvalds/linux/tree/v4.15&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tag/?h=v4.15&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tag/?h=v4.15&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 Ubuntu apt 仓库下载。Ubuntu 官方自己维护了每个操作系统版本的背后的 Linux 内核代码，可以通过以下两种 apt 命令方式获取相关代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 第一种方式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 先搜索&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; apt-cache search linux-source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-4.15.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 4.15.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-4.18.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 4.18.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-5.0.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 5.0.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-5.3.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 5.3.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 再安装&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; apt install linux-source-4.15.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 第二种方式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; apt-get &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; linux
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Reading package lists... Done
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NOTICE: &lt;span class=&#34;s1&#34;&gt;&amp;#39;linux&amp;#39;&lt;/span&gt; packaging is maintained in the &lt;span class=&#34;s1&#34;&gt;&amp;#39;Git&amp;#39;&lt;/span&gt; version control system at:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/bionic
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Please use:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/bionic
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;to retrieve the latest &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;possibly unreleased&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; updates to the package.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Need to get &lt;span class=&#34;m&#34;&gt;167&lt;/span&gt; MB of &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; archives.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Get:2 https://mirrors.ustc.edu.cn/ubuntu bionic-updates/main linux 4.15.0-99.100 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;tar&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;158&lt;/span&gt; MB&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;......
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 以上两种方式，内核源代码均下载至/usr/src/目录下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下载完成后，BPF 示例就在&lt;strong&gt;源码根目录/samples/bpf&lt;/strong&gt;目录下，可以到&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;看个在线版的，建议大家通读一遍这个目录下的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf/README.rst&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;README.rst&lt;/a&gt;，了解整体步骤。&lt;/p&gt;
&lt;h2 id=&#34;编译-bpf-示例代码&#34;&gt;编译 BPF 示例代码&lt;/h2&gt;
&lt;h3 id=&#34;安装编译所依赖的工具&#34;&gt;安装编译所依赖的工具&lt;/h3&gt;
&lt;p&gt;在真正开始编译工作之前，请确保你的实验环境已经安装&lt;code&gt;clang&lt;/code&gt;和&lt;code&gt;llvm&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clang &amp;gt;= version 3.4.0&lt;/li&gt;
&lt;li&gt;llvm &amp;gt;= version 3.7.1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;正式编译示例代码&#34;&gt;正式编译示例代码&lt;/h3&gt;
&lt;p&gt;万事俱备了，可以正式开始编译工作。我们说的“编译”其本质就是利用内核目录下不同的&lt;code&gt;Makefile&lt;/code&gt;，通过特定的&lt;code&gt;make&lt;/code&gt;指令完成特定工作。来，先上命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 切换到内核源代码根目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; linux_sourcecode/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 生成内核编译时需要的头文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make headers_install
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 可视化选择你想为内核添加的内核模块，最终生成保存了相关模块信息的.config文件，为执行后面的命令做准备&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make menuconfig
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 使用make命令编译samples/bpf/目录下所有bpf示例代码，注意需要加上最后的/符号&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make samples/bpf/ &lt;span class=&#34;c1&#34;&gt;# or  make M=samples/bpf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如下截图看结果，生成了一大堆的文件，有&lt;code&gt;.o&lt;/code&gt;后缀的目标文件，还有绿色高亮的可执行文件，挑两个执行下，效果符合期待。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kernel-bpf-examples&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kernel-bpf-examples&#34; srcset=&#34;
               /blog/compile-bpf-examples/bpf-kernel-examples_hud2d1bd975ff7a854c43bd69b6af7af9d_351870_7cc7208bdfbded5b98b6bb4bb1d19e63.webp 400w,
               /blog/compile-bpf-examples/bpf-kernel-examples_hud2d1bd975ff7a854c43bd69b6af7af9d_351870_54bbe94991366b3ad0e04247639fe9d6.webp 760w,
               /blog/compile-bpf-examples/bpf-kernel-examples_hud2d1bd975ff7a854c43bd69b6af7af9d_351870_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/compile-bpf-examples/bpf-kernel-examples_hud2d1bd975ff7a854c43bd69b6af7af9d_351870_7cc7208bdfbded5b98b6bb4bb1d19e63.webp&#34;
               width=&#34;760&#34;
               height=&#34;451&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      kernel-bpf-examples
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;分析samplesbpfmakefile文件&#34;&gt;分析&lt;strong&gt;samples/bpf/Makefile&lt;/strong&gt;文件&lt;/h2&gt;
&lt;p&gt;如果你是个喜欢打破砂锅问到底的同学，可以跟我一起看看最后的 make 命令到底用了什么魔法？当然你也可以跳过这个章节。本次分析的 Makefile 是基于内核版本&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;v4.15.0&lt;/a&gt;，不同内核版本的 Makefile 内容会有差异，但总体逻辑是一致的。&lt;/p&gt;
&lt;h3 id=&#34;前提条件&#34;&gt;前提条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果你对&lt;code&gt;make&lt;/code&gt;作为构建工具还不熟悉，可以看看这个&lt;a href=&#34;http://www.ruanyifeng.com/blog/2015/02/make.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;教程&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;Linux 内核中大部分 Makefile 都是基于&lt;a href=&#34;https://www.kernel.org/doc/html/latest/kbuild/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kernel Build System&lt;/a&gt;，简称&lt;code&gt;kbuild&lt;/code&gt;，它是对 Makefile 的扩展，使其在编译内核文件时更加高效、简洁。因此你需要对其有所了解，可以到&lt;a href=&#34;https://www.kernel.org/doc/html/latest/kbuild/makefiles.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;看看官方介绍。&lt;/li&gt;
&lt;li&gt;上文使用的另外两个&lt;strong&gt;make&lt;/strong&gt;命令，利用的是根目录下的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/a&gt;，完成“生成头文件”和“生成.config 文件”，这两步是内核开发的必要步骤，感兴趣的同学移步看&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/Documentation/admin-guide/README.rst&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;README.rst&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分段分析&#34;&gt;分段分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一段关于变量&lt;code&gt;hostprogs-y&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# List of programs to build&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; test_lru_dist
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sock_example
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; fds_example
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sockex1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sockex2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sockex3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Makefile 的第一段是初始化变量&lt;code&gt;hostprogs-y&lt;/code&gt;，乍一看，好像是把所有示例程序名称都赋值给了&lt;code&gt;hostprogs-y&lt;/code&gt;。官方的注释是&lt;strong&gt;List of programs to build&lt;/strong&gt;，直译过来是，“准备构建的程序清单”、，大致能猜出这个变量的意义了，通过查询官方文档，发现一个概念叫&lt;a href=&#34;https://www.kernel.org/doc/html/latest/kbuild/makefiles.html#host-program-support&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Host Program support&lt;/strong&gt;&lt;/a&gt;，意思是在编译阶段就构建出可以在本机直接运行的可执行文件，为了实现这个目的，需要经过两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一步告诉 &lt;strong&gt;kbuild&lt;/strong&gt; 需要生成哪些可执行文件，这个就是通过变量&lt;code&gt;hostprogs-y&lt;/code&gt;来指定。来看源码中的这一行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; test_lru_dist
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;程序&lt;code&gt;test_lru_dist&lt;/code&gt;就是一个被指定的可执行程序名称，&lt;code&gt;kbuild&lt;/code&gt;默认会去同一个目录下查找名为&lt;code&gt;test_lru_dist.c&lt;/code&gt;作为构建这个可执行文件的源文件。类似代码也是同样的意义，总计有41个可执行文件赋值给了变量&lt;code&gt;hostprogs-y&lt;/code&gt;中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二步是将显式依赖关系添加到可执行文件中。这可以通过两种方式来完成，一种是为Makefile中某个&lt;strong&gt;target&lt;/strong&gt;添加这个可执行文件，作为&lt;strong&gt;prerequisites&lt;/strong&gt;，形成依赖关系，这样就可以触发这个可执行文件的构建任务，另一种是直接利用变量 &lt;code&gt;always&lt;/code&gt;，即无需指定第一种方式中的依赖关系，只要Makefile被执行，变量&lt;code&gt;always&lt;/code&gt;中包含的可执行文件都会被构建。来看源码中的相关片段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Tell kbuild to always build the programs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;always :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;hostprogs-y&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到它使用上文提到的第二种方式，保证这些可执行文件一定会被执行构建任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二段关于变量&lt;code&gt;&amp;lt;executeable&amp;gt;-objs&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Libbpf dependencies&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;LIBBPF :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; ../../tools/lib/bpf/bpf.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CGROUP_HELPERS :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; ../../tools/testing/selftests/bpf/cgroup_helpers.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;test_lru_dist-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; test_lru_dist.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sock_example-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sock_example.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;fds_example-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; fds_example.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex1-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex1_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex2-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex2_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex3-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex3_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一、二行是声明并初始化了两个变量&lt;code&gt;LIBBPF&lt;/code&gt;和&lt;code&gt;CGROUP_HELPERS&lt;/code&gt;，以便后续复用。后面的几行是有共性的，&lt;code&gt;:=&lt;/code&gt;符号左边是个有规律的变量：&lt;code&gt;&amp;lt;executeable&amp;gt;-objs&lt;/code&gt;，右边是多个.o 文件，看上去的意义像是右边的多个文件会合并成一个指定文件。通过查询文档可知，可执行文件可以由多个其他文件复合组成，通过&lt;code&gt;&amp;lt;executeable&amp;gt;-objs&lt;/code&gt;这样的语法，可以列出并指定所有用于生成最终可执行文件（命名为&lt;code&gt;executeable&lt;/code&gt;）的文件清单。以如下代码为例，可执行文件&lt;code&gt;sockex1&lt;/code&gt;是由&lt;code&gt;bpf_load.o&lt;/code&gt;、&lt;code&gt;bpf.o&lt;/code&gt;和&lt;code&gt;sockex1_usr.o&lt;/code&gt;链接生成的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex1-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex1_user.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三段关于变量&lt;code&gt;HOSTCFLAGS&lt;/code&gt;和&lt;code&gt;HOSTLOADLIBES&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objtree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/usr/include
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/lib/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/testing/selftests/bpf/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/lib/ -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/include
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/perf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HOSTCFLAGS_bpf_load.o +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objtree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/usr/include -Wno-unused-variable
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_fds_example&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_sockex1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_sockex2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_sockex3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_tracex4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf -lrt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码中有两个关键变量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;变量&lt;code&gt;HOSTCFLAGS&lt;/code&gt;顾名思义，它是在编译 host program（即可执行文件）时，为&lt;strong&gt;编译&lt;/strong&gt;操作指定的特殊选项，如上面代码中使用&lt;code&gt;-I&lt;/code&gt;参数指定依赖的头文件所在目录。默认情况下，这个变量的配置会作用到当前 Makefile 涉及的所有 host program。如果你想为某个 host program 单独指定一个编译选项，可以像上文的这行代码：
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HOSTCFLAGS_bpf_load.o +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objtree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/usr/include -Wno-unused-variable
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;只为&lt;code&gt;bpf_load.o&lt;/code&gt;这个 object 文件指定特殊选项。&lt;/li&gt;
&lt;li&gt;变量&lt;code&gt;HOSTLOADLIBES&lt;/code&gt;是用于&lt;strong&gt;链接&lt;/strong&gt;（link）操作时指定的特殊选项，如上面代码中使用两个 library（因为代码中使用了相关的函数），通过选项&lt;code&gt;-l&lt;/code&gt;加到最终生成的可执行文件中：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libelf&lt;/code&gt;，这个库用来管理 elf 格式的文件，bpf 程序一般都会使用 elf 作为最终格式，因此需要加载这个 library。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;librt&lt;/code&gt;，这个库其实很常用，一般含有&lt;code&gt;#include&amp;lt;time.h&amp;gt;&lt;/code&gt;头文件的代码，都需要加载这个 library，用来支持 real time 相关功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四段关于如何编译 BPF 程序源文件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Trick to allow make to be run from this directory&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;all:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;MAKE&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -C ../../ &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;obj&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.o: &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;src&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;CLANG&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;NOSTDINC_FLAGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LINUXINCLUDE&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;EXTRA_CFLAGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;obj&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/testing/selftests/bpf/ &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-D__KERNEL__ -Wno-unused-value -Wno-pointer-sign &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-D__TARGET_ARCH_&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;ARCH&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -Wno-compare-distinct-pointer-types &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-Wno-gnu-variable-sized-type-not-at-end &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-Wno-address-of-packed-member -Wno-tautological-compare &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-Wno-unknown-warning-option &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;CLANG_ARCH_ARGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-O2 -emit-llvm -c $&amp;lt; -o -&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LLC&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -march&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;bpf -filetype&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;obj -o &lt;span class=&#34;nv&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中有两个系统变量：第一个&lt;code&gt;$@&lt;/code&gt;代表的是 target 所指的文件名；第二个&lt;code&gt;$&amp;lt;&lt;/code&gt;代表的是第一个 prerequisite 的文件名。看过本站关于 BPF 博文的同学可能已经看出如上代码的玄机了，我把它简化下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;clang -I &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/testing/selftests/bpf/ &lt;span class=&#34;se&#34;&gt;\ &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  	      -O2 -emit-llvm -c $&amp;lt; -o -&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\ &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  	      llc -march&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;bpf -filetype&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;obj -o &lt;span class=&#34;nv&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上面的简化版命令，可以看出最后一行 make 命令的本质，就是把所有.c 源代码文件，通过 clang 全部编译成.o 目标文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;对&lt;strong&gt;samples/bpf/Makefile&lt;/strong&gt;这个文件执行 make 命令的本质就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为运行在内核空间的示例源代码（一般文件名称后缀为&lt;strong&gt;kern.c&lt;/strong&gt;），编译生成.o 后缀的目标文件，以便加载到对应 BPF 提供的 hook 中去。&lt;/li&gt;
&lt;li&gt;为运行在用户空间的示例源代码 (一般文件文件后缀为&lt;strong&gt;user.c&lt;/strong&gt;)，编译生成可以在本机直接运行的可执行文件，以便用户可以直接运行测试。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;我在执行-make-命令遇到的问题&#34;&gt;我在执行 Make 命令遇到的问题&lt;/h2&gt;
&lt;p&gt;我自己的实验环境是 Ubuntu 18.04 with 4.15.0 内核，在执行上面的 make 命令时，发生了以下的错误信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;In file included from ./tools/perf/perf-sys.h:9:0,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            	 from samples/bpf/bpf_load.c:28:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h: In &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; ‘sys_perf_event_open’:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h:68:15: error: ‘test_attr__enabled’ undeclared &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;first use in this &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;unlikely&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;test_attr__enabled&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/include/linux/compiler.h:74:43: note: in definition of macro ‘unlikely’
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;c1&#34;&gt;# define unlikely(x)  __builtin_expect(!!(x), 0)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                    	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h:68:15: note: each undeclared identifier is reported only once &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; each &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; it appears in
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;unlikely&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;test_attr__enabled&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/include/linux/compiler.h:74:43: note: in definition of macro ‘unlikely’
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;c1&#34;&gt;# define unlikely(x)  __builtin_expect(!!(x), 0)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                    	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;In file included from samples/bpf/bpf_load.c:28:0:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h:69:3: warning: implicit declaration of &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; ‘test_attr__open’ &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;-Wimplicit-function-declaration&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   test_attr__open&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;attr, pid, cpu, fd, group_fd, flags&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   ^~~~~~~~~~~~~~~
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;scripts/Makefile.host:107: recipe &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; target &lt;span class=&#34;s1&#34;&gt;&amp;#39;samples/bpf/bpf_load.o&amp;#39;&lt;/span&gt; failed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: *** &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;samples/bpf/bpf_load.o&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Error &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Makefile:1823: recipe &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; target &lt;span class=&#34;s1&#34;&gt;&amp;#39;samples/bpf/&amp;#39;&lt;/span&gt; failed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make: *** &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;samples/bpf/&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Error &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据错误信息，查看发生错误的文件为**./tools/perf/perf-sys.h**，报错的那一行是 test 开头的。通过 Google 发现了内核大佬们的邮件来往：&lt;a href=&#34;https://www.spinics.net/lists/netdev/msg608676.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.spinics.net/lists/netdev/msg608676.html&lt;/a&gt;。大佬们建议由于是测试相关的代码，所以可以 skip 掉。修改完的文件在&lt;a href=&#34;https://github.com/nevermosby/linux-bpf-learning/blob/master/bpf/perf-sys.h&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;，请斟酌参考。重新运行 make 命令，错误不再发生了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make samples/bpf/ &lt;span class=&#34;c1&#34;&gt;# and it works&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;编译运行自己的-bpf-程序&#34;&gt;编译运行自己的 BPF 程序&lt;/h2&gt;
&lt;p&gt;如果你想利用 Linux 内核环境来编译自己的 BPF 程序，是非常方便的。只要对&lt;code&gt;samples/bpf/&lt;/code&gt;目录下的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/a&gt;进行一点点自定义改造即可，如果你仔细阅读了上面的分析，那么改造的原理就显而易见了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 假设你自己BPF程序如下所示：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 内核空间代码：my_bpf_101_kern.c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 用户空间代码：my_bpf_101_user.c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 从上之下，添加新的代码行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 1. 追加新的一行至hostprogs-y开头的代码块最后，保证自己的BPF程序能够生成可执行文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; my_bpf_101
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 2. 一般BPF程序使用以下命令即可，具体取决于你的程序是否依赖其他特殊头文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;my_bpf_101-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; my_bpf_101_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 3. 追加新的一行至always开头的代码块最后，保证触发生成可执行文件的任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;always&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; my_bpf_101_kern.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一般的 BPF 程序只需要通过如上 3 处更新加入到 Makefile 中，就可以使用&lt;code&gt;make samples/bpf/&lt;/code&gt;命令，生成你自己程序的可执行文件了。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
