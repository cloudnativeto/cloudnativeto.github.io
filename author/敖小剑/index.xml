<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>敖小剑 | 云原生社区（中国）</title>
    <link>https://cloudnative.to/author/%E6%95%96%E5%B0%8F%E5%89%91/</link>
      <atom:link href="https://cloudnative.to/author/%E6%95%96%E5%B0%8F%E5%89%91/index.xml" rel="self" type="application/rss+xml" />
    <description>敖小剑</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Sat, 22 May 2021 13:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/author/%E6%95%96%E5%B0%8F%E5%89%91/avatar_hue38add62c87b7486d80c9f3fda25dfc1_12220_270x270_fill_q75_lanczos_center.jpg</url>
      <title>敖小剑</title>
      <link>https://cloudnative.to/author/%E6%95%96%E5%B0%8F%E5%89%91/</link>
    </image>
    
    <item>
      <title>云原生社区 meetup 第四期广州站</title>
      <link>https://cloudnative.to/event/cloud-native-meetup-guangzhou-04/</link>
      <pubDate>Sat, 22 May 2021 13:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/event/cloud-native-meetup-guangzhou-04/</guid>
      <description>&lt;h3 id=&#34;开场致辞&#34;&gt;开场致辞&lt;/h3&gt;
&lt;p&gt;讲师：宋净超（Tetrate 布道师、云原生社区创始人）&lt;/p&gt;
&lt;p&gt;讲师介绍：Tetrate 云原生布道师，云原生社区创始人，CNCF Ambassador。&lt;/p&gt;
&lt;h3 id=&#34;有了-nginx-和-kong为什么还需要-apache-apisix&#34;&gt;有了 Nginx 和 Kong，为什么还需要 Apache APISIX？&lt;/h3&gt;
&lt;p&gt;讲师：王院生&lt;/p&gt;
&lt;p&gt;个人介绍：支流科技联合创始人 CTO&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在云原生时代，k8s 和微服务已经成为主流，在带来巨大生产力提升的同时，也增加了系统的复杂度。如何发布、管理和可视化服务，成为了一个重要的问题。每次修改配置都要 reload 的 Nginx、依赖 postgres 才能工作的 Kong，都不是云原生时代的理想之选。这正是我们创造 Apache APISIX 的原因：没有 reload、毫秒内全集群生效、不依赖数据库、极致性能、支持 Java 和 Go 开发插件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;听众收益&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更好的理解 API 网关、服务网格，以及各个开源项目的优劣势&lt;/p&gt;
&lt;h3 id=&#34;云原生时代的研发效能&#34;&gt;云原生时代的研发效能&lt;/h3&gt;
&lt;p&gt;讲师：黄国峰&lt;/p&gt;
&lt;p&gt;个人介绍：腾讯 PCG 工程效能专家。10 多年的软件和互联网从业经验；现任腾讯工程效能部，负责持续集成、研发流程和构建系统等平台；曾任职唯品会高级经理，负责架构团队。在云原生平台下的研发效能方向有丰富的理论知识和实践经验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;云原生时代，软件研发的逻辑彻底改变了。传统的软件开发在本机编码 / 调试、部署到测试环境测试、再发布到生产环境；而云原生时代的开发，基于不可变设施，研发流程从编码、构建、持续测试、持续集成到持续部署，整个过程几乎完全代码化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;听众收益&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解云原生开发的新挑战和难点&lt;/li&gt;
&lt;li&gt;了解腾讯云原生开发实践的流程和思路&lt;/li&gt;
&lt;li&gt;了解腾讯云原生开发中的遇到的坑和解决思路&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;37-手游-go-微服务架构演进和云原生实践&#34;&gt;37 手游 Go 微服务架构演进和云原生实践&lt;/h3&gt;
&lt;p&gt;讲师：吴凌峰&lt;/p&gt;
&lt;p&gt;个人介绍：任职于三七互娱集团 37 手游技术部基础架构组，负责平台 golang 基础框架以及 DevOps、CI/CD 生态建设，从业以来一直专注于云原生、DevOps 和容器化等技术应用和推广，在 golang 工程化领域有一定的心得。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Golang 微服务应用和云原生的概念近年越来越火热，传统技术栈公司随着业务规模增长，在云原生技术应用落地探索和转型的过程中一定会遇到很多共通的问题以及有各自不同的思考，包括如何更好地提升我们的开发效率、提升服务稳定性、降低运维成本？面对不断增长的服务数量和不断变长变复杂的调用关系网，怎样才能更好地观测、管理和保证核心服务高可用，本次演讲分享将会围绕 37 手游转型为 Go 微服务架构以及建设云原生 DevOps 体系的历程、过程中的领悟和思考展开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;听众收益&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解 Golang 云原生微服务框架的关键技术和优化实践经验&lt;/li&gt;
&lt;li&gt;了解云原生观测体系如链路追踪、监控等 Golang 微服务落地实践经验&lt;/li&gt;
&lt;li&gt;了解混合云混合部署 DevOps 和 CI/CD 体系的企业实践经验&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;死生之地不可不察论-api-标准化对-dapr-的重要性&#34;&gt;死生之地不可不察：论 API 标准化对 Dapr 的重要性&lt;/h3&gt;
&lt;p&gt;讲师：敖小剑&lt;/p&gt;
&lt;p&gt;个人介绍：资深码农，十九年软件开发经验，微服务专家，Service Mesh 布道师，Servicemesher 社区联合创始人，Dapr Maintainer。专注于基础架构，Cloud Native 拥护者，敏捷实践者，坚守开发一线打磨匠艺的架构师。曾在亚信、爱立信、唯品会、蚂蚁金服等任职，对基础架构和微服务有过深入研究和实践。目前就职阿里云，在云原生应用平台全职从事 Dapr 开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dapr 作为新兴的云原生项目，以 &amp;ldquo;应用运行时&amp;rdquo; 之名致力于围绕云原生应用的各种分布式需求打造一个通用而可移植的抽象能力层。这个愿景有着令人兴奋而向往的美好前景：一个受到普通认可和遵循的云原生业界标准，基于此开发的云原生应用可以在不同的厂家的云上自由的部署和迁移，恍惚间一派云原生下世界大同的美景。然而事情往往没这么简单，API 的标准化之路异常的艰辛而痛苦，Dapr 的分布式能力抽象在实践中会遇到各种挑战和困扰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;听众收益&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解 Dapr 的愿景和分布式能力抽象层的重要&lt;/li&gt;
&lt;li&gt;了解 Dapr API 在抽象和实现时遇到的实际问题，尤其是取舍之间的艰难&lt;/li&gt;
&lt;li&gt;了解目前 Dapr 在 API 抽象上正在进行的努力和新近准备增加的 API&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Mecha：将 Mesh 进行到底</title>
      <link>https://cloudnative.to/blog/mecha/</link>
      <pubDate>Sun, 10 May 2020 10:30:10 +0800</pubDate>
      <guid>https://cloudnative.to/blog/mecha/</guid>
      <description>&lt;p&gt;内容摘要：Service Mesh 落地实践三年，效果一直并不理想，到了该反思的时候了。Mecha 作为面向服务的分布式能力抽象层，是 Service Mesh 模式的自然进化版本，预计也将是云原生化和 Mesh 化的必然趋势，让我们将 Mesh 进行到底。&lt;/p&gt;
&lt;h2 id=&#34;mecha-介绍&#34;&gt;Mecha 介绍&lt;/h2&gt;
&lt;h3 id=&#34;什么是-macha&#34;&gt;什么是 Macha？&lt;/h3&gt;
&lt;p&gt;Mecha 一词，相信爱好动漫的同学应该都不陌生。是的，就是大家熟悉的那个 Mecha（机甲）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/mecha_huda146d3825fc6d502e05b38609bff098_493667_1cbc714525f3b5cf53b8c494885fde72.webp 400w,
               /blog/mecha/images/mecha_huda146d3825fc6d502e05b38609bff098_493667_a061ba03e06c7e2631ca684e25d3ff1c.webp 760w,
               /blog/mecha/images/mecha_huda146d3825fc6d502e05b38609bff098_493667_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/mecha_huda146d3825fc6d502e05b38609bff098_493667_1cbc714525f3b5cf53b8c494885fde72.webp&#34;
               width=&#34;760&#34;
               height=&#34;381&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Mecha 这个词之所以出现在这里，主要是因为 &lt;strong&gt;Bilgin Ibryam&lt;/strong&gt; 的这个博客文章“&lt;strong&gt;&lt;a href=&#34;https://www.infoq.com/articles/multi-runtime-microservice-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Multi-Runtime Microservices Architecture&lt;/a&gt;&lt;/strong&gt;”，提出了微服务架构的一个新的设想：Multiple Runtime。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：这篇博客文章强烈推荐阅读，我甚至建议在阅读本文之前先阅读这篇文章，因为我今天的内容，可以视为对这个文章的深度解读和思考。为了方便，这里提供一份中文翻译版本 &lt;a href=&#34;https://skyao.io/post/202003-multi-runtime-microservice-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;多运行时微服务架构&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这篇博客中，Bilgin Ibryam 首先分析并总结了分布式应用的四大需求：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/four-needs-of-app_hu3828c8b408219066fbc7297d21b025bb_65201_c3a871139ae88ac89a9d42fa4bf37d83.webp 400w,
               /blog/mecha/images/four-needs-of-app_hu3828c8b408219066fbc7297d21b025bb_65201_b7d039fec5eee69344fec2e54f394d88.webp 760w,
               /blog/mecha/images/four-needs-of-app_hu3828c8b408219066fbc7297d21b025bb_65201_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/four-needs-of-app_hu3828c8b408219066fbc7297d21b025bb_65201_c3a871139ae88ac89a9d42fa4bf37d83.webp&#34;
               width=&#34;760&#34;
               height=&#34;409&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生命周期（Lifecycle）&lt;/li&gt;
&lt;li&gt;网络（Networking）&lt;/li&gt;
&lt;li&gt;状态（State）&lt;/li&gt;
&lt;li&gt;捆绑（Binding）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于每种需求存在的问题和局限性，导致传统解决方案如企业服务总线（ESB）及其变体（例如面向消息的中间件，更轻量级的集成框架等）不再适用。随着微服务架构的发展，以及容器和 Kubernetes 的普及和广泛使用，云原生思想开始影响这些需求的实现方式。未来的架构趋势是通过将所有传统的中间件功能移至其他运行时来全面发展，最后的目标是在服务中只需编写业务逻辑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：详情请见原文，为了节约篇幅，这里只做简单概述，不完全引用原文内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下图是传统中间件平台和云原生平台的对比，传统中间件以各种 SDK 的方式提供能力，而云原生平台则通过各种外围 Runtime（典型如大家熟悉的 Servicemesh/Istio）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/traditional-platform-and-cloudnative-platform_hu18bcab3fc2cc0513aa3cb38bca4a9a66_41954_7697343c2ddcffac66ab8d55c0f11f73.webp 400w,
               /blog/mecha/images/traditional-platform-and-cloudnative-platform_hu18bcab3fc2cc0513aa3cb38bca4a9a66_41954_2f138c221e61d746518e8bb8c70415fd.webp 760w,
               /blog/mecha/images/traditional-platform-and-cloudnative-platform_hu18bcab3fc2cc0513aa3cb38bca4a9a66_41954_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/traditional-platform-and-cloudnative-platform_hu18bcab3fc2cc0513aa3cb38bca4a9a66_41954_7697343c2ddcffac66ab8d55c0f11f73.webp&#34;
               width=&#34;760&#34;
               height=&#34;253&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;因此作者引入了 Multiple Runtime 的概念：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/multi-runtime-microservices_huda146d3825fc6d502e05b38609bff098_210736_c7117f5e98455bf1dfcb097231475336.webp 400w,
               /blog/mecha/images/multi-runtime-microservices_huda146d3825fc6d502e05b38609bff098_210736_096f1294afd1e6e5f90dadb0b95df086.webp 760w,
               /blog/mecha/images/multi-runtime-microservices_huda146d3825fc6d502e05b38609bff098_210736_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/multi-runtime-microservices_huda146d3825fc6d502e05b38609bff098_210736_c7117f5e98455bf1dfcb097231475336.webp&#34;
               width=&#34;760&#34;
               height=&#34;311&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;作者提出：很可能在将来，我们最终将使用多个运行时来实现分布式系统。&lt;strong&gt;多个运行时，不是因为有多个微服务，而是因为每个微服务都将由多个运行时组成&lt;/strong&gt;，最有可能是两个运行时 - 自定义业务逻辑运行时和分布式原语运行时。&lt;/p&gt;
&lt;p&gt;对多运行时微服务架构和 Mecha 的说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;您还记得电影《阿凡达》和科学家们制作的用于去野外探索潘多拉的 Amplified Mobility Platform (AMP)“机车服”吗？这个多运行时架构类似于这些 Mecha-套装，为人形驾驶员赋予超能力。在电影中，您要穿上套装才能获得力量并获得破坏性武器。在这个软件架构中，您将拥有构成应用核心的业务逻辑（称为微逻辑/micrologic）和提供强大的开箱即用的分布式原语的 sidecar mecha 组件。Micrologic 与 mecha 功能相结合，形成多运行时微服务，该服务将进程外功能用于其分布式系统需求。最棒的是，Avatar 2 即将面世，以帮助推广这种架构。我们最终可以在所有软件会议上用令人赞叹的机甲图片代替老式的边车摩托车；-)。接下来，让我们看看该软件架构的详细信息。&lt;/p&gt;
&lt;p&gt;这是一个类似于客户端 - 服务器体系结构的双组件模型，其中每个组件都是独立的运行时。它与纯客户端 - 服务器架构的不同之处在于，这两个组件都位于同一主机上，彼此之间有可靠的网络连接。这两个组件的重要性相当，它们可以在任一方向上发起操作并充当客户端或服务器。其中的一个组件称为 Micrologic，拥有非常少的业务逻辑，把几乎所有分布式系统问题都剥离出去了。另一个伴随的组件是 Mecha，提供了我们在本文中一直讨论的所有分布式系统功能（生命周期除外，它是平台功能）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者在这里正式提出了 Mecha 的理念：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/multi-runtime-microservices-architecture_hu05f2d69ba0319c258f11ab39e179ac17_548510_335e10f87346620c3f0451c68097d838.webp 400w,
               /blog/mecha/images/multi-runtime-microservices-architecture_hu05f2d69ba0319c258f11ab39e179ac17_548510_499fa56fe60cde85a424e282ea21af60.webp 760w,
               /blog/mecha/images/multi-runtime-microservices-architecture_hu05f2d69ba0319c258f11ab39e179ac17_548510_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/multi-runtime-microservices-architecture_hu05f2d69ba0319c258f11ab39e179ac17_548510_335e10f87346620c3f0451c68097d838.webp&#34;
               width=&#34;760&#34;
               height=&#34;377&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;思路大体是：&lt;strong&gt;Smart Runtime， Dumb Pipes&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我对 Mecha 的理解是：业务逻辑在编码开始阶段应该是“裸奔”的，专注于业务逻辑的实现，而尽量不涉及到底层实现逻辑；而在运行时，则应该装备“机甲”，全副武装，大杀四方。熟悉的味道是吧？标准而地道的云原生思想。&lt;/p&gt;
&lt;h3 id=&#34;mecha-的本质&#34;&gt;Mecha 的本质&lt;/h3&gt;
&lt;p&gt;作者在原文中探讨了 Mecha 运行时的特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Mecha 是通用的，高度可配置的，可重用的组件，提供分布式原语作为现成的能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mecha 可以与单个 Micrologic 组件一起部署 (Sidecar 模式)，也可以部署为多个共享 (注：我称之为 Node 模式)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mecha 不对 Micrologic 运行时做任何假设。它与使用开放协议和格式（例如 HTTP/gRPC，JSON，Protobuf，CloudEvents）的多语言微服务甚至单体一起使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mecha 以简单的文本格式（例如 YAML，JSON）声明式地配置，指示要启用的功能以及如何将其绑定到 Micrologic 端点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与其依靠多个代理来实现不同的目的（例如网络代理，缓存代理，绑定代理），不如使用一个 Mecha 提供所有这些能力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是我对上述特性的个人理解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mecha 提供的是&lt;strong&gt;能力&lt;/strong&gt;，以分布式原语体现的各种能力，而不局限于单纯的网络代理。&lt;/li&gt;
&lt;li&gt;Mecha 的部署模型，不局限于 Sidecar 模式，Node 模式在某些场景下（如 Edge/IoT，Serverless FaaS）可能会是更好的方式。至少，Mecha 下有机会按需选择，而不是绑死在 Sidecar 模式上&lt;/li&gt;
&lt;li&gt;Mecha 和 Micrologic 之间的交互是开放而有 API 标准的，Mecha 和 Micrologic 之间的“协议”体现在 API 上，而不是 TCP 通讯协议。这提供了一个契机：一个统一 Micrologic 和 Mecha 之间通讯方式的契机。&lt;/li&gt;
&lt;li&gt;Mecha 可以以声明式的方式进行配置和控制，这非常符合云原生的理念，同样也使得 API 更关注于能力本身，而不是能力如何配置。&lt;/li&gt;
&lt;li&gt;应用需要的能力如此之多（参见上面的图：分布式应用的四大需求），如果每个能力都对应一个代理（不管是 Node 还是 Sidecar），数量会非常夸张，带来的运维压力会很可怕。因此，如 Mecha 这个名字暗示的，运行时应该是整套的形式提供能力，而不是分散。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果用一句话来总结，那么我认为 Mecha 的本质应该是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“面向应用的分布式能力抽象层”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如 Servicemesh 的本质是服务间通讯的抽象层一样，Mecha 的本质是应用需要的各种分布式能力和原语，包括但不限于服务间通讯。&lt;/p&gt;
&lt;p&gt;从这个角度上说，Mecha 覆盖的范围是 Servicemesh 的超集：毕竟 Servicemesh 只覆盖到应用的部分需求（服务间通讯，还只限于同步/一对一/request-response 模式），还有更多的分布式能力和原语有待覆盖。&lt;/p&gt;
&lt;p&gt;换一句话说，Mecha 的目标应该是：&lt;strong&gt;“将 Mesh 进行到底！”&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;mecha-的优势和未来&#34;&gt;Mecha 的优势和未来&lt;/h3&gt;
&lt;p&gt;作者指出：Mecha 的好处是业务逻辑和越来越多的分布式系统问题之间的松耦合。&lt;/p&gt;
&lt;p&gt;下图是业务逻辑和分布式系统问题在不同架构中的耦合：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/coupling-in-different-architectures_hu05f2d69ba0319c258f11ab39e179ac17_281537_613cc1ea486bd9960ffff6d42514bc4a.webp 400w,
               /blog/mecha/images/coupling-in-different-architectures_hu05f2d69ba0319c258f11ab39e179ac17_281537_59f94eb4f92c4e5a37041d63ee16c2e0.webp 760w,
               /blog/mecha/images/coupling-in-different-architectures_hu05f2d69ba0319c258f11ab39e179ac17_281537_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/coupling-in-different-architectures_hu05f2d69ba0319c258f11ab39e179ac17_281537_613cc1ea486bd9960ffff6d42514bc4a.webp&#34;
               width=&#34;760&#34;
               height=&#34;304&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其实思路和 Servicemesh 是一脉相承的，只是覆盖的分布式能力更广泛一些。&lt;/p&gt;
&lt;p&gt;有一个问题：Mecha 会不会成为微服务架构的演进的下一个形态？我个人的答案：是，随着云原生的推进，分布式能力（以传统中间件为典型代表）下沉是大势所趋，Mesh 化的范围必然会继续扩大，也就离 Mecha 的形态越来越近了。这也就是本文标题的立意所在，Mecha 会是微服务乃至云原生的下一站。&lt;/p&gt;
&lt;h2 id=&#34;微软-dapr&#34;&gt;微软 Dapr&lt;/h2&gt;
&lt;p&gt;在介绍完 Mecha/Multiple Runtime 的理念之后，我们来看看目前微软新推出来的 Dapr 项目 —— 这应该是业界第一个 Multiple Runtime 的开源实践项目。&lt;/p&gt;
&lt;p&gt;项目地址：https://github.com/dapr/dapr。&lt;/p&gt;
&lt;h3 id=&#34;dapr-介绍&#34;&gt;Dapr 介绍&lt;/h3&gt;
&lt;p&gt;Dapr 是 Distributed Application Runtime（分布式应用运行时）的缩写，官方介绍说 Dapr 是“一种可移植的，事件驱动的运行时，用于构建跨云和边缘的分布式应用”。&lt;/p&gt;
&lt;p&gt;Dapr 的详细介绍是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dapr 是一种可移植的，serverless 的，事件驱动的运行时，它使开发人员可以轻松构建弹性，无状态和有状态微服务，这些服务运行在云和边缘上，并包含多种语言和开发框架。&lt;/p&gt;
&lt;p&gt;Dapr 整理了构建微服务应用为开放，独立的构建块的最佳实践，使您能够使用自己选择的语言和框架来构建可移植的应用程序。每个构建块都是独立的，您可以在应用中使用其中的一个或多个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Dapr 的功能和定位，下面这一张图就可以概括了：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/dapr-overview_hub0f40905bb31105b15316541e7839891_185368_1bed57e7ef0f9e6d9928ad23e736e58d.webp 400w,
               /blog/mecha/images/dapr-overview_hub0f40905bb31105b15316541e7839891_185368_78fbf8ae17e4b71dd30ac56f9762a2a2.webp 760w,
               /blog/mecha/images/dapr-overview_hub0f40905bb31105b15316541e7839891_185368_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/dapr-overview_hub0f40905bb31105b15316541e7839891_185368_1bed57e7ef0f9e6d9928ad23e736e58d.webp&#34;
               width=&#34;760&#34;
               height=&#34;358&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最底下基础设施是各种云平台（主流公有云都支持）或者边缘环境&lt;/li&gt;
&lt;li&gt;其上是 dapr 提供的分布式能力，dapr 称之为“building block”。&lt;/li&gt;
&lt;li&gt;这些 building block 的能力，以统一的 API（支持 HTTP 和 gRPC）对外提供服务&lt;/li&gt;
&lt;li&gt;应用可以用各种语言编写，然后通过 dapr 提供的 API 使用这些能力，dapr 也提供客户端类库来简化对 API 的调用，实现了多语言的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dapr 提供的具体分布式能力（building block）如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/dapr-building-block_hu792db24d2ffb61797e62677c4dcc3d6f_249632_11b9cc6beb75c1639795aa28c6b5dc17.webp 400w,
               /blog/mecha/images/dapr-building-block_hu792db24d2ffb61797e62677c4dcc3d6f_249632_19e3e2ca167f5d5d2b1c2dc242d1056a.webp 760w,
               /blog/mecha/images/dapr-building-block_hu792db24d2ffb61797e62677c4dcc3d6f_249632_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/dapr-building-block_hu792db24d2ffb61797e62677c4dcc3d6f_249632_11b9cc6beb75c1639795aa28c6b5dc17.webp&#34;
               width=&#34;760&#34;
               height=&#34;309&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;每个 building block 提供的具体能力请参加 Dapr 的官方文档：https://github.com/dapr/docs/tree/master/concepts。&lt;/p&gt;
&lt;h3 id=&#34;dapr-的-api-例子&#34;&gt;Dapr 的 API 例子&lt;/h3&gt;
&lt;p&gt;我们来看一下应用调用 Darp API 的例子，体验一下使用 Dapr 的方式。&lt;/p&gt;
&lt;p&gt;以 Service Invocation / 服务调用为例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/service-invocation_hubb81548a6f7fe9e85b55171d8e544990_45511_ccd65fafd153c8eca940ab3d483b97c9.webp 400w,
               /blog/mecha/images/service-invocation_hubb81548a6f7fe9e85b55171d8e544990_45511_4f18c089bc65eafaa7687efdbd0bb26a.webp 760w,
               /blog/mecha/images/service-invocation_hubb81548a6f7fe9e85b55171d8e544990_45511_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/service-invocation_hubb81548a6f7fe9e85b55171d8e544990_45511_ccd65fafd153c8eca940ab3d483b97c9.webp&#34;
               width=&#34;760&#34;
               height=&#34;266&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;部署和调用方式与 Servicemesh/Istio 极为相似，但是，差别在于：Dapr 是以提供 API 的方式提供 API 背后的能力，而不是提供提供协议代理的方式。&lt;/p&gt;
&lt;p&gt;上图中 1，是 ServiceA 发起请求来调用一个远程服务。其 HTTP request 如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;POST/GET/PUT/DELETE http://localhost:&amp;lt;daprPort&amp;gt;/v1.0/invoke/&amp;lt;appId&amp;gt;/method/&amp;lt;method-name&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数 daprPort 是 Dapr Runtime 启动的监听端口，用来接受应用的 outbound 请求&lt;/li&gt;
&lt;li&gt;参数 appId 是远程应用在 darp 中的关联 id，每个注册到 dapr 的应用都有一个唯一的 appId&lt;/li&gt;
&lt;li&gt;参数 method-name 是要调用的远程应用的方法名或者 URL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;负载可以存放在 HTTP body 中随请求发送，如 json。&lt;/p&gt;
&lt;p&gt;注意，虽然都是提供相同的功能，这里体现了 Dapr（或者说背后的 Mecha）和 Servicemesh 在方式上的差异：暴露 API 还是代理通讯协议。&lt;/p&gt;
&lt;p&gt;我们看一个更明显的例子，dapr 提供的“publish/subscriptions”能力，让应用可以方便的发布消息，或者订阅主题并接收消息。下图是应用发布消息，请求直接发给 dapr 即可：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/publish_hu05f2d69ba0319c258f11ab39e179ac17_87094_010b87f9c55b075d91ab0590a8c16485.webp 400w,
               /blog/mecha/images/publish_hu05f2d69ba0319c258f11ab39e179ac17_87094_33b8b362daf4ec4a31fb4028c09ca986.webp 760w,
               /blog/mecha/images/publish_hu05f2d69ba0319c258f11ab39e179ac17_87094_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/publish_hu05f2d69ba0319c258f11ab39e179ac17_87094_010b87f9c55b075d91ab0590a8c16485.webp&#34;
               width=&#34;760&#34;
               height=&#34;651&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;例子中，参数 topic 指定了消息要发往的主题（例子中是  deathStarStatus）。后续 dapr 会完成将消息入 queue，然后推送到订阅了该 topic 的应用。接收消息的方式也类似，不过这次是 darp 主动发起：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/subscribe_hu05f2d69ba0319c258f11ab39e179ac17_92409_ab899f43eb853d86352e6482ddf520aa.webp 400w,
               /blog/mecha/images/subscribe_hu05f2d69ba0319c258f11ab39e179ac17_92409_c5093f6897ec4b74dd84e04513c15d03.webp 760w,
               /blog/mecha/images/subscribe_hu05f2d69ba0319c258f11ab39e179ac17_92409_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/subscribe_hu05f2d69ba0319c258f11ab39e179ac17_92409_ab899f43eb853d86352e6482ddf520aa.webp&#34;
               width=&#34;760&#34;
               height=&#34;738&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dapr 首先会请求应用，咨询应用需要订阅那些主题（topic），如例子中应用返回的的 TopicA / TopicB&lt;/li&gt;
&lt;li&gt;dapr 实现主题订阅，在接收到消息之后，再把消息发送给应用，通过 URL 参数的不同来区分不同的主题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意在这个调用期间，无论是收发消息，应用完全不用理会底层 pub/sub 的实现机制（比如是 kafka，还是 rocketmq，还是其他公有云提供的消息机制），也完全不用引入该实现机制的客户端 SDK，只是简单的使用 darp 定义的 API 即可，从而实现了和底层的解耦，以及“厂商不绑定”。&lt;/p&gt;
&lt;p&gt;为了进一步简化调用的过程（毕竟发一个最简单的 HTTP GET请求也要应用实现HTTP协议的调用/连接池管理等），dapr提供了各个语言的SDK，如 java / go / python / dotnet / js / cpp / rust。另外同时提供 HTTP 客户端和 gRPC 客户端。&lt;/p&gt;
&lt;p&gt;我们以 Java 为例，java 的 client API 接口定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;DaprClient&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;n&#34;&gt;Mono&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Void&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;publishEvent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;topic&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;n&#34;&gt;Mono&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Void&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;invokeService&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Verb&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;verb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;appId&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体可见：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/dapr/java-sdk/blob/master/sdk/src/main/java/io/dapr/client/DaprClient.java&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/dapr/java-sdk/blob/master/sdk/src/main/java/io/dapr/client/DaprClient.java&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;分析和总结&#34;&gt;分析和总结&lt;/h2&gt;
&lt;p&gt;前面介绍了 Multiple Runtime / Mecha 的架构思想，以及参考实现之一的微软 Dapr 项目。&lt;/p&gt;
&lt;p&gt;由于 Multiple Runtime / Mecha 这个思想非常的新，刚刚提出不久，而微软 Dapr 项目也是一个新出来的项目，不管是理论思想还是实践都处于非常早期的状态，也还没有形成完善的方法论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特别申明&lt;/strong&gt;：以下内容更多是我个人当下的理解和感悟，仅代表个人意见，肯定有很多不成熟甚至谬误的地方，欢迎指正和探讨。&lt;/p&gt;
&lt;h3 id=&#34;mecha-和-dapr-的启示&#34;&gt;Mecha 和 Dapr 的启示&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Mesh 模式应该推向更大的领域&lt;/p&gt;
&lt;p&gt;随着云原生的深入，应用需要的分布式能力应该全面下沉，而不仅仅局限于 Servicemesh 提供的服务间通讯能力；应用形态会朝纯业务逻辑这个目标更进一步，应用更加的云原生化。&lt;/p&gt;
&lt;p&gt;这是大势所趋，也是 Mecha 架构出现和发展的原动力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mecha 强调是“提供能力”，而不是通讯代理&lt;/p&gt;
&lt;p&gt;Mecha 的使用方式和 Servicemesh 有非常大的差异：Mecha 强调的是提供分布式能力给应用使用，这些能力最终以封装完善的 API 的方式呈现。API 体现的是应用对能力的“需求”和“意愿”，不涉及到如何实现，实现是 Mecha 的职责，采用什么样的实现也是由 Mecha 来控制。&lt;/p&gt;
&lt;p&gt;在 Servicemesh 下，不存在这个需求：Servicemesh 提供的是服务间通讯能力，这个能力是由 sidecar 来提供，没有其他的更底层的实现，不存在隔离和替换的可能。受服务通讯协议和报文 schema 的限制，Servicemesh 只能做请求的“转发”，能力聚焦在“如何转发”上，没有其他需要隔离和替代的能力。&lt;/p&gt;
&lt;p&gt;当 Mecha 把能力扩展到 Servicemesh 之外时，很多能力是由外部系统提供：比如 pub-sub 能力可以由不同的 Message Queue 实现；状态管理能力可以连接不同的 Key-Value 实现。此时能力的隔离性和可替代性就成为关键需求：解耦应用和能力实现，容许 Mecha 替换底层实现（进而实现供应商不锁定等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不强求“零侵入”&lt;/p&gt;
&lt;p&gt;在 Servicemesh 中，“零侵入”是一个非常强调的特性，为此不惜引入 iptables 等流量劫持方案。“零侵入”在某些特殊场景下会发挥巨大的优势，如旧有应用不做改造的前提下接入 servicemesh。好处自然不言而喻，但零侵入也有自身的限制：客户端必须能发出符合服务器端要求的网络通讯请求，这个过程外部无法插手。&lt;/p&gt;
&lt;p&gt;对于服务间通讯，这个不是大问题。但是对于其他能力，由于有和实现解耦的需求，再通过客户端自行发起原生协议的请求就不合适了。因此，Mecha 中更倾向于采用低侵入的轻量级 SDK 方案，同样也可以实现跨语言和跨平台，只是需要付出实现各种语言 SDK 的代价。由于这个 SDK 足够轻量，因此代价还不算很高。&lt;/p&gt;
&lt;p&gt;而这些少量的工作量，少量的侵入，可以换取轻量级 SDK 能提供的各种便利和配合（简单理解：开后门），可以实现能力的抽象和 API 的封装。权衡利弊，Mecha 下更倾向于轻量级 SDK 方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不限定 Sidecar 部署&lt;/p&gt;
&lt;p&gt;Sidecar 部署模式，存在资源占用、维护成本增加等缺点，在某些情况下可能并不合适：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;边缘网络，IoT 场景：资源非常有限，不适合启动太多 Sidecar&lt;/li&gt;
&lt;li&gt;FaaS 场景：应用自身足够轻量，甚至比 Sidecar 还要轻量&lt;/li&gt;
&lt;li&gt;Serverless 场景：Scale to Zero 时，对冷启动速度有严格要求，Sidecar 的启动和初始化可能拖累应用启动速度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mecha 下，部署模式不限定于 Sidecar，在合适时容许选择 Node 模式，甚至 Node 模式和 Sidecar 模式混合使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API 和配置是关键&lt;/p&gt;
&lt;p&gt;API 是分布式能力的抽象，需要要对（开发上层业务应用的）客户友好，简单好用，稳定不变。这些 API 也需要标准化，被社区广泛接受和采纳，才能实现厂商不锁定和自由迁移，提升客户价值。&lt;/p&gt;
&lt;p&gt;另外，API 还需要配合配置使用，在把能力抽象为 API 时，是不提供能力的细节控制的。这些控制将在运行时由 Mecha 根据配置实现，可以理解为：“API + 配置 = 完整的能力”。&lt;/p&gt;
&lt;p&gt;API 和配置的制订以及标准化，预计将会是 Mecha 成败的关键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mecha-的精髓&#34;&gt;Mecha 的精髓&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Program to an &lt;strong&gt;interface&lt;/strong&gt;, not an implementation.&lt;/p&gt;
&lt;p&gt;Design Patterns: Elements of Reusable Object-Oriented Software (GOF, 1994)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mecha 的精髓，要从上面这句名言开始：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 Mecha 下，为了实现&lt;strong&gt;解耦&lt;/strong&gt;和&lt;strong&gt;可替换&lt;/strong&gt;， Runtime &lt;strong&gt;隔离&lt;/strong&gt;了底层实现，因此演变为：&amp;ldquo;Program to an &lt;strong&gt;Runtime&lt;/strong&gt;, not an implementation.&amp;rdquo;&amp;quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑到 Runtime 不管是部署为 Sidecar 模式，还是部署为 Node 模式，都是 Localhost，因此有： “Program to an &lt;strong&gt;Localhost&lt;/strong&gt;, not an implementation.”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了简化开发，Mecha 还是会提供轻量级 SDK，提供 API 作为能力的&lt;strong&gt;抽象&lt;/strong&gt;：“Program to an &lt;strong&gt;API&lt;/strong&gt;, not an implementation.”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑到 API 通常是以 interface 的形式提供，因此绕了一圈，Mecha 最后还是回到原点：“Program to an &lt;strong&gt;interface&lt;/strong&gt;, not an implementation.”&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;个人理解，Mecha 的精髓就在于这几个关键点：隔离/抽象/解耦/可替换。如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/mecha-core_hu3b8e8d0b9f984bf252a3398b084f4528_48558_26cde399fc73a8df538cca417f93c755.webp 400w,
               /blog/mecha/images/mecha-core_hu3b8e8d0b9f984bf252a3398b084f4528_48558_255967e8b7ec68a61ceb5198ca0a048a.webp 760w,
               /blog/mecha/images/mecha-core_hu3b8e8d0b9f984bf252a3398b084f4528_48558_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/mecha-core_hu3b8e8d0b9f984bf252a3398b084f4528_48558_26cde399fc73a8df538cca417f93c755.webp&#34;
               width=&#34;677&#34;
               height=&#34;679&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Mecha 下，MicroLogic（也就是业务逻辑的代码实现）不容许直接使用底层实现提供的分布式能力&lt;/li&gt;
&lt;li&gt;Mecha Runtime 将为 Micro Logic 提供分布式能力，同时隔离应用和底层实现&lt;/li&gt;
&lt;li&gt;为了方便使用，提供轻量级 SDK，其中的 API 层实现了分布式能力的抽象，应用只需面向 API 编程&lt;/li&gt;
&lt;li&gt;轻量级 SDK 和 Mecah Runtime 配合，完成对底层实现的解耦和可替换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mecha-的实现原则&#34;&gt;Mecha 的实现原则&lt;/h3&gt;
&lt;p&gt;在 Mecha 的实现上，我理解的原则是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Runtime 是主力，要做厚&lt;/li&gt;
&lt;li&gt;轻量级 SDK 主要是给 Runtime 打配合，要做薄&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/mecha/images/mecha-implementation_huf4410f65aa2156ce431f56d2d65f6101_79027_42985c12b25e087ee898b657ff140599.webp 400w,
               /blog/mecha/images/mecha-implementation_huf4410f65aa2156ce431f56d2d65f6101_79027_92bc9935fdbe61ea9b34e6d3665113de.webp 760w,
               /blog/mecha/images/mecha-implementation_huf4410f65aa2156ce431f56d2d65f6101_79027_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/mecha/images/mecha-implementation_huf4410f65aa2156ce431f56d2d65f6101_79027_42985c12b25e087ee898b657ff140599.webp&#34;
               width=&#34;760&#34;
               height=&#34;223&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;具体的职责划分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;轻量级 SDK：实现多语言接入，低侵入（但不追求零侵入）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API 接口：由轻量级 SDK 中提供统一，目标社区化 + 标准化，给开发者提供一致的编程体验，同时提供可移植性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用：轻量级 SDK/Runtime 配合，提供各种分布式能力，应用无感，只需简单使用 API，不耦合底层实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Mecha 架构中，Runtime 自然是整个架构的核心，扮演类似 Servicemesh 中数据平面的角色&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有分布式能力使用的过程（包括访问内部生态体系和访问外部系统）都被 Runtime 接管和屏蔽实现&lt;/li&gt;
&lt;li&gt;通过CRD/控制平面实现声明式配置和管理（类似Servicemesh）&lt;/li&gt;
&lt;li&gt;部署方式上 Runtime 可以部署为 Sidecar 模式，或者 Node 模式，取决于具体需求，不强制&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：Mecha 有非常多的能力，实现上也有非常多的细节，这里先做一个 High Level 的概述。细节后面会有一系列文章一一覆盖，欢迎多交流讨论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;mecha-总结&#34;&gt;Mecha 总结&lt;/h2&gt;
&lt;p&gt;大概是在 3 月初，当时我第一次阅读“Multi-Runtime Microservices Architecture”这篇文章，有一种豁然开朗的感觉，尤其是有很多之前在反复考虑和权衡但是下不了结论的问题，在这个文章中得到了清晰的解答。可谓受益匪浅。&lt;/p&gt;
&lt;p&gt;在 Servicemesh 探索和实践的这三年中，遇到很多问题，有很多之前没有想到过的问题浮现。比如，以前一直觉得 Servicemesh 中引入 Sidecar 带来的最大麻烦会是性能，但实际上，从目前的实践看，Sidecar 引入后带来的维护代价才是更令人头疼的事情，相比之下 Sidecar 引入带来的性能损失显得无伤大雅。&lt;/p&gt;
&lt;p&gt;总结一下我个人对 Mecha 架构的核心理解，主要是两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mecha 是云原生化和 Mesh 化的必然趋势：云原生在继续发展，应用需要的分布式能力需要继续下沉，越来越多的能力会以 sidecar 的形式出现，这是大势所趋。但不可能出现一个应用部署十几个 sidecar 的局面，这会是运维地狱。因此，必然需要出现新的形态来解决 Sidecar 过多的问题，合并为一个或者多个 Sidecar 就会成为必然。&lt;/li&gt;
&lt;li&gt;Mecha 是 Servicemesh 模式的自然进化版本：Servicemesh 落地实践三年了，效果一直并不理想，到了该反思反省的时候了；而且 Mecha 的范围也远不止服务间通讯，新的需求下应该有新的思考和突破。Servicemesh 现有的固定模式，在 Mecha 下可以尝试打破以探索新的方式：不必拘泥于 Sidecar，试试 Node 模式；不必拘泥于通讯协议转发，试试 Runtime 提供能力解耦底层实现；不必拘泥于零侵入，试试在应用中保留一个足够轻的轻量级 SDK。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;正如曾有说法，说“微服务是 SOA 实践中正确的部分（the Good Part）”，我希望在 Mecha 的探索和实践中，能够从 Servicemesh 的实践中吸取成功的经验和失败的教训，希望 Mecha 也能成为 Servicemesh 的 Good Part。希望在云原生的演进路线中，Mecha 可以继微服务和 Servicemesh 之后，成为云原生落地实践的下一站。&lt;/p&gt;
&lt;p&gt;回到现实，目前 Mecha 和 Multi-Runtime 还是一个非常新的想法，Dapr 项目也才刚刚起步，Mecha 要探索的道路还很漫长，一切都还需要摸索着前进。&lt;/p&gt;
&lt;h2 id=&#34;附录参考资料&#34;&gt;附录：参考资料&lt;/h2&gt;
&lt;p&gt;在文章的最后，特别鸣谢“Multi-Runtime Microservices Architecture”一文的作者“&lt;strong&gt;Bilgin Ibryam&lt;/strong&gt;”，我非常认可这篇文章中的思想和理念，分析归纳的非常到位，提炼和升华的能力令人佩服。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者介绍：&lt;/p&gt;
&lt;p&gt;![](images/Bilgin Ibryam.png)&lt;/p&gt;
&lt;p&gt;Red Hat 的首席架构师，Apache Software Foundation 的 committer 和成员。开源的布道师，博客作者，偶尔演讲，著有书籍 Kubernetes Patterns 和 Camel Design Patterns。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文参考了 Bilgin Ibryam 出品的如下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.com/articles/multi-runtime-microservice-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Multi-Runtime Microservices Architecture&lt;/a&gt;，作者 &lt;a href=&#34;http://ofbizian.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bilgin Ibryam&lt;/a&gt;，Mecha 的思想来自这篇文章，强烈推荐阅读。也可以直接看我翻译的版本 &lt;a href=&#34;https://skyao.io/post/202003-multi-runtime-microservice-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;多运行时微服务架构&lt;/a&gt;。如前所述，建议在阅读本文之前先阅读这篇博客文章。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qconlondon.com/london2020/presentation/evolution-distributed-systems-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Evolution of Distributed Systems on Kubernetes&lt;/a&gt; : 作者 Bilgin Ibryam, 2020 年 3 月在 QCon London 的演讲，依然强烈推荐。内容非常精彩，对 Kubernetes 上分布式系统演进做了很好的总结和展望，当然也依然在布道多运行时微服务架构的理念。本文的很多图片 &lt;a href=&#34;https://qconlondon.com/system/files/presentation-slides/bilgin_-_evolution_of_distributed_systems_on_kubernetes.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;援引自这份 PPT&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh 和 API Gateway 关系深度探讨</title>
      <link>https://cloudnative.to/blog/service-mesh-and-api-gateway/</link>
      <pubDate>Tue, 28 Apr 2020 11:20:46 +0800</pubDate>
      <guid>https://cloudnative.to/blog/service-mesh-and-api-gateway/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;关于 Service Mesh 和 API Gateway 之间的关系，这个问题过去两年间经常被问起，社区也有不少文章和资料给出解答。其中不乏 Christian Posta 这样的网红给出过深度介绍。我在这里做一个资料的整理和汇总，结合个人的理解给出一些看法。另外在本文最后，介绍蚂蚁金服在 Service Mesh 和 API Gateway 融合的这个最新领域的一些开创性的实践和探索，希望给大家一个更有体感的认知。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注 1：为了节约篇幅，我们将直奔主题，假定读者对 Service Mesh 和 API Gateway 已有基本的了解。&lt;/p&gt;
&lt;p&gt;备注 2:  这边文章更关注于梳理整个脉络，内容不会展开的特别细，尤其是其他文章已经详细阐述的部分。如果您在浏览本文之后，还想更深入的了解细节，请继续阅读文章最后的参考资料和推荐阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;原本清晰的界限定位和职责&#34;&gt;原本清晰的界限：定位和职责&lt;/h2&gt;
&lt;p&gt;首先，Service Mesh 和 API Gateway 在功能定位和承担的职责上有非常清晰的界限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Mesh：微服务的网络通信基础设施，负责（系统内部的）服务间的通讯&lt;/li&gt;
&lt;li&gt;API Gateway：负责将服务以 API 的形式暴露（给系统外部），以实现业务功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_f7859c7321a401742114a8636976ce86.webp 400w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_c08d37f9ebed334e95e5091043dee125.webp 760w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_f7859c7321a401742114a8636976ce86.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从功能和职责上说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位于最底层的是拆分好的原子微服务，以服务的形式提供各种能力&lt;/li&gt;
&lt;li&gt;在原子微服务上是（可选的）组合服务，某些场景下需要将若干微服务的能力组合起来形成新的服务&lt;/li&gt;
&lt;li&gt;原子微服务和组合服务部署于 &lt;strong&gt;系统内部&lt;/strong&gt;，在采用 Service Mesh 的情况下，由 Service Mesh 提供服务间通讯的能力&lt;/li&gt;
&lt;li&gt;API Gateway 用于将系统内部的这些服务暴露给 &lt;strong&gt;系统外部&lt;/strong&gt;，以 API 的形式接受外部请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从部署上说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Mesh 部署在系统内部：因为原子微服务和组合服务通常不会直接暴露给外部系统&lt;/li&gt;
&lt;li&gt;API Gateway 部署在系统的边缘：一方面暴露在系统之外，对外提供 API 供外部系统访问；一方面部署在系统内部，以访问内部的各种服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里引入两个使用非常广泛的术语：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_209feadfce8c585c7587bba795d19852.webp 400w,
               /blog/service-mesh-and-api-gateway/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_9f17930a636bbbb70cb99750fbba4279.webp 760w,
               /blog/service-mesh-and-api-gateway/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_209feadfce8c585c7587bba795d19852.webp&#34;
               width=&#34;760&#34;
               height=&#34;326&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;东西向&lt;/strong&gt;通讯：指服务间的相互访问，其通讯流量在服务间流转，流量都位于系统内部&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;南北向&lt;/strong&gt;通讯：指服务对外部提供访问，通常是通过 API Gateway 提供的 API 对外部暴露，其通讯流量是从系统外部进入系统内部。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;解释一下“东西南北”的由来：如上图所示，通常在地图上习惯性的遵循“上北下南，左东右西”的原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结：Service Mesh 和 API Gateway 在功能和职责上分工明确，界限清晰。但如果事情就这么结束，也就不会出现 Service Mesh 和 API Gateway 关系的讨论了，自然也不会有本文。&lt;/p&gt;
&lt;p&gt;问题的根源在哪里？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈推荐阅读：附录中 Christian Posta 的文章 &amp;ldquo;Do I Need an API Gateway if I Use a Service Mesh?&amp;ldquo;对此有深度分析和讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;哲学问题网关访问内部服务算东西向还是南北向&#34;&gt;哲学问题：网关访问内部服务，算东西向还是南北向？&lt;/h2&gt;
&lt;p&gt;如下图所示，图中黄色的线条表示的是 API Gateway 访问内部服务：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_f7859c7321a401742114a8636976ce86.webp 400w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_c08d37f9ebed334e95e5091043dee125.webp 760w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_f7859c7321a401742114a8636976ce86.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;问题来了，从流量走向看：这是外部流量进入系统后，开始访问对外暴露的服务，应该属于“南北向”通讯，典型如上图的画法。但从另外一个角度，如果我们将 API Gateway 逻辑上拆分为两个部分，先忽略对外暴露的部分，单独只看  API Gateway  访问内部服务的部分，这时可以视 API Gateway 为一个普通的客户端服务，它和内部服务的通讯更像是“东西向”通讯：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_d8c9a7c4926c5d5d55309d338745e53c.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_d2fde4544697be18226fa1938b906d63.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_d8c9a7c4926c5d5d55309d338745e53c.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;所以，API Gateway 作为一个客户端访问内部服务时，到底算南北向还是东西向，就成为一个哲学问题：完全取决于我们如何看待 API Gateway，是作为一个整体，还是逻辑上分拆为对内对外两个部分。&lt;/p&gt;
&lt;p&gt;这个哲学问题并非无厘头，在 API Gateway 的各种产品中，关于如何实现“API Gateway 作为一个客户端访问内部服务” ，就通常分成两个流派：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;泾渭分明：视 API Gateway 和内部服务为两个独立事物，API Gateway 访问内部服务的通讯机制自行实现，独立于服务间通讯的机制&lt;/li&gt;
&lt;li&gt;兼容并济：视 API Gateway 为一个普通的内部服务的客户端，重用其内部服务间通讯的机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而最终决策通常也和产品的定位有关：如果希望维持  API Gateway 的独立产品定位，希望可以在不同的服务间通讯方案下都可以使用，则通常选择前者，典型如 kong；如果和服务间通讯方案有非常深的渊源，则通常选择后者，典型如 springcloud 生态下的 zuul 和 springcloud gateway。&lt;/p&gt;
&lt;p&gt;但无论选择哪个流派，都改变不了一个事实，当“API Gateway 作为一个客户端访问内部服务”时，它的确和一个普通内部服务作为客户端去访问其他服务没有本质差异：服务发现，负载均衡，流量路由，熔断，限流，服务降级，故障注入，日志，监控，链路追踪，访问控制，加密，身份认证&amp;hellip;&amp;hellip; 当我们把网关访问内部服务的功能一一列出来时，发现几乎所有的这些功能都是和服务间调用重复。&lt;/p&gt;
&lt;p&gt;这也就造成了一个普遍现象：如果已有一个成熟的服务间通讯框架，再去考虑实现 API Gateway，重用这些重复的能力就成为自然而然的选择。典型如前面提到的 springcloud 生态下的 zuul 以及后面开发的 springcloud gateway，就是以重用类库的方式实现了这些能力的重用。&lt;/p&gt;
&lt;p&gt;这里又是一个类似的哲学问题：当“API Gateway 作为一个客户端访问内部服务”时，它以重用类库的方式实现了代码级别的能力重用，相当于自行实现了一个和普通服务间通讯方案完全一样的客户端，那这个“客户端”发出来的流量算东西向还是南北向？&lt;/p&gt;
&lt;p&gt;答案不重要。&lt;/p&gt;
&lt;h2 id=&#34;sidecar真正的重合点&#34;&gt;Sidecar：真正的重合点&lt;/h2&gt;
&lt;p&gt;在进入 Service Mesh 时代之后，Service Mesh 和 API gateway 的关系开始是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;功能和职责清晰划分&lt;/li&gt;
&lt;li&gt;客户端访问服务的功能高度重叠&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时两者的关系很清晰，而且由于当时 Service Mesh 和 API Gateway 是不同的产品，两者的重合点只是在功能上。&lt;/p&gt;
&lt;p&gt;而随着时间的推移，当 Service Mesh 产品和 API Gateway 产品开始出现相互渗透时，两者的关系就开始变得暧昧。&lt;/p&gt;
&lt;p&gt;在 Service Mesh 出现之后，如何为基于 Service Mesh 的服务选择合适的 API Gateway 方案，就慢慢开始提上日程，而其中选择重用 Service Mesh 的能力也自然成为一个探索的方向，并逐步出现新式 API Gateway 产品，其想法很直接：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何融合东西向和南北向的通讯方案？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中的一个做法就是基于 Service Mesh 的 Sidecar 来实现 API Gateway，从而在南北向通讯中引入 Service Mesh 这种东西向通讯的方案。这里我们不展开细节，我这里援引一个图片（鸣谢赵化冰同学）来解释这个方案的思路：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_54a5263908e4e52e9730a6748f4385f0.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_f2c217e21995849d90b4de49eb926a78.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_54a5263908e4e52e9730a6748f4385f0.webp&#34;
               width=&#34;760&#34;
               height=&#34;244&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个时候 Service Mesh 和 API Gateway 的关系就变得有意思了，因为 Service Mesh 中 sidecar 的引入，所以前面的“哲学问题”又有了一个新的解法：API Gateway 这次真的可以分拆为两个独立部署的物理实体，而不是逻辑上的两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;API Gateway 本体：实现 API Gateway 除了访问内部服务之外的功能&lt;/li&gt;
&lt;li&gt;Sidecar：按照 Service Mesh 的标准做法，我们视 API Gateway 为一个部署于 Service Mesh 中的普通服务，为这个服务 1:1 的部署 sidecar&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_3ed088127c7942f69ca2ad761a9a698a.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_b1b27cce2d81ade8f80fec6d35b9c9cd.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_3ed088127c7942f69ca2ad761a9a698a.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个方案中，原来用于 Service Mesh 的 sidecar，被用在了 API Gateway 中，替代了 API Gateway 中原有的客户端访问的各种功能。这个方案让 API Gateway 的实现简化了很多，也实现了东西向和南北向通讯能力的重用和融合，而 API Gateway 可以更专注于“API Management”的核心功能。&lt;/p&gt;
&lt;p&gt;此时 Service Mesh 和 API Gateway 的关系就从“泾渭分明”变成了“兼容并济”。&lt;/p&gt;
&lt;p&gt;而采用这个方案的公司，通常都是先有 Service Mesh 产品，再基于 Service Mesh 产品规划（或者重新规划）API Gateway 方案，典型如蚂蚁金服的 SOFA Gateway 产品是基于 MOSN，而社区开源产品 Ambassador 和 Gloo 都是基于 Envoy。&lt;/p&gt;
&lt;p&gt;上述方案的优势在于 API Gateway 和 Sidecar 独立部署，职责明确，架构清晰。但是，和 Service Mesh 使用 sidecar 被质疑多一跳会造成性能开销影响效率一样，API Gateway 使用 Sidecar 也被同样的质疑：多了一跳&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;解决“多一跳”问题的方法简单而粗暴，基于 sidecar，将 API Gateway 的功能加进来。这样 API Gateway 本体和 Sidecar 再次合二为一：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_163f8837dff0c118a170820e063a577f.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_020610a9ce6d1f820c23632cfeb9a6c6.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_163f8837dff0c118a170820e063a577f.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;至于走到这一步之后，Service Mesh 和 API Gateway 是什么关系：这到底算是 Service Mesh/sidecar融合了API Gateway，还是 API Gateway 融合了 Service Mesh/Sidecar？这个问题就像斑马到底是白底黑纹还是黑底白纹一样，见仁见智。&lt;/p&gt;
&lt;h2 id=&#34;bff把融合进行到底&#34;&gt;BFF：把融合进行到底&lt;/h2&gt;
&lt;p&gt;BFF（Backend For Frontend）的引入会让 Service Mesh 和 API Gateway 走到一个更加亲密的地步。&lt;/p&gt;
&lt;p&gt;先来看看常规的 BFF 的玩法：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_82b1c5385231645bca4414f8c7a003eb.webp 400w,
               /blog/service-mesh-and-api-gateway/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_217f47d97dac77b6bc6774e3d569d025.webp 760w,
               /blog/service-mesh-and-api-gateway/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_82b1c5385231645bca4414f8c7a003eb.webp&#34;
               width=&#34;760&#34;
               height=&#34;338&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这里，多增加了一个 BFF 层，介于 API Gateway 和内部服务（包括组合服务和原子微服务）之间。注意 BFF 的工作模式和组合服务很类似，都是组合多个服务。但差别在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组合服务还属于服务的范畴，只是实现机制上组合了多个服务，对外暴露的依然是一个完整和规范的服务&lt;/li&gt;
&lt;li&gt;BFF 不同，BFF 如名字所示，Backend For Frontend，完全是为了前端而存在，核心目标之一是简化前端的访问&lt;/li&gt;
&lt;li&gt;对我们今天的话题而言，最关键的一点：BFF 完全收口了从外部进入的流量，而组合服务没有，API Gateway 是可以直接访问原子微服务的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;“BFF 完全收口外部流量”，这一点在 API Gateway 和 Sidecar 融合之后，会变得很有想象空间，我们先看按照前面的融合方式，在有 BFF 的情况下，API Gateway 和 Sidecar 融合后的情景：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_96d4d14bd1670e31108c4e81cd7adebe.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_914a3273f0d0926c14625f45e18036f7.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_96d4d14bd1670e31108c4e81cd7adebe.webp&#34;
               width=&#34;760&#34;
               height=&#34;374&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;放大一点，单独看 API Gateway 和 BFF：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_42493bb04cbd51ededf65744172d2fe8.webp 400w,
               /blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_be4073244f51e2b800b5fef26058168a.webp 760w,
               /blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_42493bb04cbd51ededf65744172d2fe8.webp&#34;
               width=&#34;552&#34;
               height=&#34;416&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;注意到，流量从被 API Gateway 接收，到进入 BFF 在这个流程中，这个请求路径中有两个 sidecar：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;和 BFF 部署在一起的，是没有 API Gateway 功能的普通 Sidecar&lt;/li&gt;
&lt;li&gt;API Gateway 和 Sidecar 融合之后，这就是一个“有 API Gateway 功能的大 Sidecar”（或者是“有 Sidecar 功能的特殊 API Gateway”）：虽然扮演了 API Gateway 的角色，但本质上依然包含一个完整功能的 sidecar，和 BFF 自带的 Sidecar 是等同的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，问题来了：为什么要放两个 sidecar 在流程中，缩减到一个会怎么样？我们尝试将两个 Sidecar 合二为一，去掉 BFF 自带的 Sidecar，直接把扮演 API Gateway 的 sidecar 给 BFF 用：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_19bf30930b38a8ff63db84b4411dc7ab.webp 400w,
               /blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_fc053a06ecb1f70b192ebd292acb723b.webp 760w,
               /blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_19bf30930b38a8ff63db84b4411dc7ab.webp&#34;
               width=&#34;645&#34;
               height=&#34;287&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此时的场景是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流量直接打到 BFF 上（BFF 前面可能会挂其他的网络组件提供负载均衡等功能）&lt;/li&gt;
&lt;li&gt;BFF 的 sidecar 接收流量，完成 API Gateway 的功能，然后将流量转给 BFF&lt;/li&gt;
&lt;li&gt;BFF 通过 sidecar 调用内部服务（和没有合并时一致）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_6a0cf3f9991378844eb7e7cdad30c7fe.webp 400w,
               /blog/service-mesh-and-api-gateway/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_731b76370e8deced8226bd4660256307.webp 760w,
               /blog/service-mesh-and-api-gateway/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_6a0cf3f9991378844eb7e7cdad30c7fe.webp&#34;
               width=&#34;760&#34;
               height=&#34;389&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;注意这里有一个关键点，在前面时特意注明的：“&lt;strong&gt;BFF 完全收口外部流量&lt;/strong&gt;”。这是前提条件，因为原有的 API Gateway 集群已经不再存在，如果 BFF 没能收口全部流量，则这些未能收口的流量会找不到 API Gateway。当然，如果愿意稍微麻烦一点，在部署时清晰的划定需要暴露给外界的服务，直接在这些服务上部署带 API Gateway 功能的 Sidecar，也是可行的，只是管理上会比 BFF 模式要复杂一些。&lt;/p&gt;
&lt;p&gt;另外，在部署上，按照上面的方案，我们会发现：API Gateway“消失”了 —— 不再有一个明确物理部署的 API Gateway 的集群，常规的中心化的网关在这个方案中被融合到每一个 BFF 的实例中，从而实现另外一个重要特性：去中心化。&lt;/p&gt;
&lt;p&gt;上述 Service Mesh 和 API Gateway 融合的方案，并未停留在纸面上。&lt;/p&gt;
&lt;p&gt;在蚂蚁金服内部，我们基于 Service Mesh 和 API Gateway 融合 + 去中心化的思路，进行过开创性的实践和探索。以支付宝移动网关为例，在过去十年间，网关经历了从单体到微服务，从中心化到去中心化，从共享的 gateway.jar 包到利用MOSN实现网关Mesh化/Sidecar化，最终演变成了这样一个方案：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_1ee19086dc89c08fdfb4b06d29218890.webp 400w,
               /blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_9605f0d2f2cc4fed5895eb9fbb8fd01d.webp 760w,
               /blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_1ee19086dc89c08fdfb4b06d29218890.webp&#34;
               width=&#34;760&#34;
               height=&#34;379&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈推荐阅读：附录中我的同事贾岛的文章“蚂蚁金服 API Gateway Mesh 思考与实践”对此有深入介绍和详细描述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文总结了 Service Mesh 和 API Gateway 的关系，整体上说两者的定位和职责“泾渭分明”，但在具体实现上，开始出现融合的趋势：早期传统方式是类库级别的代码复用，最新趋势是 API Gateway 和 Sidecar 合二为一。&lt;/p&gt;
&lt;p&gt;后者的发展才刚刚起步，包括在蚂蚁金服我们也是才开始探索这个方向，但是相信在未来一两年间，社区可能会有更多的类似产品形态出现。&lt;/p&gt;
&lt;p&gt;补充介绍一下文中多次提到的“MOSN”：&lt;/p&gt;
&lt;p&gt;MOSN 是 MOSN 是 Modular Open Smart Network 的简称，是一款使用 Go 语言开发的网络代理软件，由蚂蚁金服开源并经过几十万容器的生产级验证。MOSN 作为云原生的网络数据平面，旨在为服务提供多协议、模块化、智能化、安全的代理能力。MOSN 可以与任何支持 xDS API 的 Service Mesh 集成，亦可以作为独立的四、七层负载均衡，API Gateway、云原生 Ingress 等使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub：https://github.com/mosn/mosn&lt;/li&gt;
&lt;li&gt;官网：https://mosn.io&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;附录参考资料和推荐阅读&#34;&gt;附录：参考资料和推荐阅读&lt;/h2&gt;
&lt;p&gt;意犹未尽的同学，欢迎继续阅读以下内容。&lt;/p&gt;
&lt;p&gt;按文章发表的时间排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://konghq.com/blog/the-difference-between-api-gateways-and-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Difference Between API Gateways and Service Mesh&lt;/a&gt;：2020-02，指导架构师确定何时使用 API 网关以及何时使用服务网格，作者 Marco Palladino，来自 kong。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/microservices/do-i-need-an-api-gateway-if-i-have-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Do I Need an API Gateway if I Use a Service Mesh?&lt;/a&gt;：2020-01，作者 Christian Posta，中文翻译版本请见马若飞同学的 &lt;a href=&#34;https://www.servicemesher.com/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用了 Service Mesh 后我还需要 API 网关吗&lt;/a&gt;，对 Service Mesh 技术和 API 网关的对比，着重分析了两者的功能重合点和分歧点，为技术选型和落地提供了指导思路。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/azCFGyTDGakZqaLEEDMN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;蚂蚁金服 API Gateway Mesh 思考与实践&lt;/a&gt;: 2019-12，作者贾岛，介绍蚂蚁金服支付宝网关的发展和 API Gateway Mesh 的由来，强烈推荐阅读，这个文章非常清晰的介绍了蚂蚁金服在 Service Mesh 和 API Gateway 融合方面的实践。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.servicemesher.com/blog/api-gateways-are-going-through-an-identity-crisis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Gateway 的身份认同危机&lt;/a&gt;: 2019-05, 原文作者 Christian Posta，译者周雨青，讲述 API Gateway 的基本理念如 API 的定义，API Management 的含义，API Gateway 模式，以及服务网格和 API Gateway 的关系。&lt;/li&gt;
&lt;li&gt;长路漫漫踏歌而行：蚂蚁金服 Service Mesh 实践探索：2018-10，我在 QCon 的演讲，我分享了当时蚂蚁金服在服务间通讯范围的探索，提出将服务网格在东西向通讯中的能力重用到南北向通讯中，当时基于 Sidecar 的 SOFA Gateway 产品刚开始开发。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.getambassador.io/api-gateway-vs-service-mesh-104c01fa4784&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Gateway vs Service Mesh&lt;/a&gt;: 2018-09，作者 Richard Li，Datawire 的 CEO，在开发 Ambassador API Gateway。Ambassador 是基于 Envoy 的 API Gateway 开源产品，文章阐述了对服务网格和 API Gateway 的看法，差异，以及对两者集成的看法。&lt;/li&gt;
&lt;li&gt;DreamMesh 抛砖引玉 (9)-API Gateway：2018-03，这个文章也是我写的，2018 年初我和 Service Mesh 社区的一些朋友深入探讨之后，在 DreamMesh 系列博客文章中记录下了当时构想的方案，尤其对 API gateway 和 sidecar 是分是合有详细讨论。当时想法还不够成熟，但大体方向已经有雏形了。鸣谢当时参与讨论的同学！&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/microservices-in-practice/service-mesh-vs-api-gateway-a6d814b9bf56&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh vs API Gateway&lt;/a&gt;: 2017-10，原文作者 &lt;a href=&#34;https://medium.com/@kasunindrasiri&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kasun Indrasiri&lt;/a&gt;，以及 &lt;a href=&#34;https://zhaohuabing.com/2018/04/11/service-mesh-vs-api-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;赵化冰同学翻译的中文版本&lt;/a&gt;，文章不长，主要对比了服务网格和 API Gateway 的产品功能，提出了两者融合的方式——在 API Gateway 中通过服务网格来调用下游服务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Network Functions With ESBs, API Management, and Now.. Service Mesh?&lt;/a&gt;：2017-08，作者 Christian Posta，讲述服务网格与 ESB，消息代理和 API 管理之类的事物的关系。内容非常好，强烈推荐阅读（我不得不吐糟一下：配图太辣眼睛）。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #6 广州站</title>
      <link>https://cloudnative.to/event/service-mesh-meetup-06/</link>
      <pubDate>Sun, 11 Aug 2019 13:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/event/service-mesh-meetup-06/</guid>
      <description>&lt;h2 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h2&gt;
&lt;h4 id=&#34;虎牙直播在微服务改造方面的实践&#34;&gt;虎牙直播在微服务改造方面的实践&lt;/h4&gt;
&lt;p&gt;张波 虎牙基础保障部中间件团队负责人&lt;/p&gt;
&lt;p&gt;本次主要分享虎牙注册中心、名字服务、DNS 的改造实践，以及如何通过 Nacos 实现与 istio 打通实现，使微服务平滑过渡到 service mesh。&lt;/p&gt;
&lt;h4 id=&#34;service-mesh-在蚂蚁集团的生产级安全实践&#34;&gt;Service Mesh 在蚂蚁集团的生产级安全实践&lt;/h4&gt;
&lt;p&gt;彭泽文 蚂蚁集团高级开发工程师&lt;/p&gt;
&lt;p&gt;介绍通过 Envoy SDS（Secret Discovery Service）实现 Sidecar 证书管理的落地方案；分享如何为可信身份服务构建敏感信息数据下发通道，以及 Service Mesh Sidecar 的 TLS 生产级落地实践。&lt;/p&gt;
&lt;h4 id=&#34;基于-kubernetes-的微服务实践&#34;&gt;基于 Kubernetes 的微服务实践&lt;/h4&gt;
&lt;p&gt;涂小刚 慧择网运维经理&lt;/p&gt;
&lt;p&gt;介绍如何跟据现有业务环境情况制定容器化整体解决方案，导入业务进入 K8S 平台，容器和原有业务环境互通。制订接入规范、配置中心对接 K8S 服务、网络互通方案、DNS 互通方案、jenkins-pipeline 流水线构建方案、日志采集方案、监控方案等。&lt;/p&gt;
&lt;h4 id=&#34;service-mesh-发展趋势续棋到中盘路往何方&#34;&gt;Service Mesh 发展趋势（续）：棋到中盘路往何方&lt;/h4&gt;
&lt;p&gt;敖小剑 蚂蚁集团高级技术专家&lt;/p&gt;
&lt;p&gt;继续探讨 Service Mesh 发展趋势：深度分析 Istio 的重大革新 Mixer v2，Envoy 支持 Web Assembly 的意义所在，以及在 Mixer v2 出来之前的权宜之计; 深入介绍 Google Traffic Director 对虚拟机模式的创新支持方式，以及最近围绕 SMI 发生的故事。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Interface 详细介绍</title>
      <link>https://cloudnative.to/blog/service-mesh-interface-detail/</link>
      <pubDate>Wed, 05 Jun 2019 15:54:19 +0800</pubDate>
      <guid>https://cloudnative.to/blog/service-mesh-interface-detail/</guid>
      <description>&lt;h2 id=&#34;smi-介绍&#34;&gt;SMI 介绍&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-interface-detail/images/smi-logo_0_hu3a87f8245ab3762330380eb775186217_149470_ae832527ed2cf8721411954f22bb0f4d.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-logo_0_hu3a87f8245ab3762330380eb775186217_149470_e0ef87655c068c38a13106f707ec7afa.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-logo_0_hu3a87f8245ab3762330380eb775186217_149470_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-interface-detail/images/smi-logo_0_hu3a87f8245ab3762330380eb775186217_149470_ae832527ed2cf8721411954f22bb0f4d.webp&#34;
               width=&#34;760&#34;
               height=&#34;285&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;smi-是什么&#34;&gt;SMI 是什么？&lt;/h3&gt;
&lt;p&gt;5 月 21 号，在 kubeconf 上，微软联合一众小伙伴，宣布了 Service Mesh Interface，简称 SMI。SMI 是一个服务网格规范，定义了通用标准，包含基本特性以满足大多数场景下的通用需求。&lt;/p&gt;
&lt;p&gt;援引来自 SMI 官方网站  &lt;a href=&#34;https://smi-spec.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;smi-spec.io&lt;/a&gt; 的介绍资料，对 Service Mesh Interface 的定位是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A standard interface for service meshes on Kubernetes.&lt;/p&gt;
&lt;p&gt;Kubernetes 上的 service mesh 的标准接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;微软的 &lt;a href=&#34;https://msft.today/hello-service-mesh-interface-smi-a-specification-for-service-mesh-interoperability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方博客文章&lt;/a&gt; 这样介绍 SMI：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SMI 定义了一组通用可移植的 API，为开发人员提供跨不同服务网格技术的互通性，包括 Istio，Linkerd 和 Consul Connect。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-interface-detail/images/smi_hu4a1aea9de87e1103a949eeacdea70aaa_120175_36f7fe051dbb94e33feea87e92357c54.webp 400w,
               /blog/service-mesh-interface-detail/images/smi_hu4a1aea9de87e1103a949eeacdea70aaa_120175_036e9c061e9585230f1fb7be317f542c.webp 760w,
               /blog/service-mesh-interface-detail/images/smi_hu4a1aea9de87e1103a949eeacdea70aaa_120175_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-interface-detail/images/smi_hu4a1aea9de87e1103a949eeacdea70aaa_120175_36f7fe051dbb94e33feea87e92357c54.webp&#34;
               width=&#34;760&#34;
               height=&#34;408&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SMI 是希望在各家 Service Mesh 的实现之上建立一个抽象的 API 层，然后通过这个抽象来解耦和屏蔽底层 Service Mesh 实现，让上层的应用、工具、生态系统可以建立在一个业界标准之上，从而实现跨不同实现的可移植性和互通性。&lt;/p&gt;
&lt;h3 id=&#34;smi-推出的背景&#34;&gt;SMI 推出的背景&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/@idit.levine_92620&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Idit Levine&lt;/a&gt;，初创公司 solo.io 的创始人兼 CEO，作为 SMI 推出的重要力量之一，撰文描述了 SMI 推出的背景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务网格生态系统正在兴起，众多的网格供应商和不同的用例需要不同的技术。所以问题来了：我们如何实现在不破坏最终用户体验的前提下促进行业创新？通过以一组标准 API 达成一致，我们可以提供互通性，并在不同网格以及为这些网格构建的工具之上维持最终用户体验。&lt;/p&gt;
&lt;p&gt;今天发布的 Service Mesh Interface（SMI）是使这一构想走向行业现实的重要一步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面这幅图片可以非常清晰的表述 SMI 的定位，也可以帮助我们一起来解读 SMI 推出的背景：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-interface-detail/images/SMI-Graphic_hu51597e352f0ba4b9470c8f9ea8aaa966_356378_138d91b526114becdd9cbac5d3ae79eb.webp 400w,
               /blog/service-mesh-interface-detail/images/SMI-Graphic_hu51597e352f0ba4b9470c8f9ea8aaa966_356378_841fcf4c69be29a64bef0f6e95ed06f2.webp 760w,
               /blog/service-mesh-interface-detail/images/SMI-Graphic_hu51597e352f0ba4b9470c8f9ea8aaa966_356378_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-interface-detail/images/SMI-Graphic_hu51597e352f0ba4b9470c8f9ea8aaa966_356378_138d91b526114becdd9cbac5d3ae79eb.webp&#34;
               width=&#34;760&#34;
               height=&#34;400&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Service Mesh 的价值正在被普遍认可：从最早的 Linkerd，Envoy，到两年前 Google 力推 Istio，以及 Linkerd2 的推出，最近 AWS 推出了 App Mesh，Google 则将 Istio 搬上了 Google Cloud 推出了 Istio 的公有云托管版本 Google Cloud Service Mesh，还推出了单独的控制平面产品 Google Traffic Director。微软也在去年推出了 Azure 完全托管版本的 Service Fabric Mesh（预览版）。云市场三巨头都已经先后出手。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;市场上出现了众多的 Service Mesh 产品：开源的，闭源的，大公司出的，小公司出的，市场繁荣的同时也带来了市场碎片化的问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-interface-detail/images/smi-background_hu432db2da3bf62d5224437e236f008ab6_35075_786d66aa90f520dbf211ac69fbb787fd.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-background_hu432db2da3bf62d5224437e236f008ab6_35075_5b7658e192eb67f8ed2c89dcb3248f3b.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-background_hu432db2da3bf62d5224437e236f008ab6_35075_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-interface-detail/images/smi-background_hu432db2da3bf62d5224437e236f008ab6_35075_786d66aa90f520dbf211ac69fbb787fd.webp&#34;
               width=&#34;760&#34;
               height=&#34;234&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在云原生理念下，我们推崇应用轻量化，只关注业务逻辑。Service Mesh 技术很好的实现了这一战略目标：运行在 service mesh 上的应用可以和底层 service mesh 的具体实现解耦。理论上应用在不同的 service mesh 实现上迁移是可行的，从这一点说，service mesh 在云原生的道路上迈出了重要一步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是，所有围绕业务应用的外围工作，比如通过 service mesh 对流量进行控制，配置各种安全/监控/策略等行为，以及在这些需求上建立起来的工具和生态系统，却不得不牢牢的绑死在某个具体的 service mesh 实现上，所谓&amp;quot;供应商锁定&amp;quot;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其根本问题在于各家实现不同，又没有统一标准。因此，要想解决上述问题，就必须釜底抽薪：&lt;strong&gt;解决 Service Mesh 的标准化问题&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;微软给出的解决方案就是引入 SMI，作为一个通用的行业规范/标准，如果能让各家 service mesh 提供商都遵循这个标准，则有机会在具体的 service mesh 产品之上，抽象出一个公共层（如定义一组通用可移植的 API），屏蔽掉上层应用/工具/生态系统对具体  service mesh 产品的实现细节。&lt;/p&gt;
&lt;p&gt;是不是觉得 SMI 的概念有种熟悉的味道？是的，没错，类似的事情在 k8s 中之前就发生过很多次，比如 CNI、CRI、CSI，还有下图展示的 Ingress：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-interface-detail/images/smi-concept_hu6cae474c8c97eee9eeea634195c5ce9c_43127_bd81437358c474bc86b88374111f263d.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-concept_hu6cae474c8c97eee9eeea634195c5ce9c_43127_c5cdb8ee4319493f873cd2f485c44217.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-concept_hu6cae474c8c97eee9eeea634195c5ce9c_43127_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-interface-detail/images/smi-concept_hu6cae474c8c97eee9eeea634195c5ce9c_43127_bd81437358c474bc86b88374111f263d.webp&#34;
               width=&#34;760&#34;
               height=&#34;416&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 SMI 中，将这个目标称为 &amp;ldquo;&lt;strong&gt;Interoperability&lt;/strong&gt;&amp;rdquo; / 互通性。我个人理解，这其实和 google 一直在倡导的 &amp;ldquo;not lock-in&amp;rdquo; 是一个概念：有通用的社区标准/行业标准，在此基础上客户可以在多个实现/多个供应商之间自由选择和迁移，没有被绑定的风险，而且提供给用户的功能以及使用方式也保持一致，也就是 Idit Levine 所强调的 &amp;ldquo;维持最终用户体验&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;从这个角度说，我很欣喜的看到 SMI 的推出，虽然这条路可能不是那么容易走，但是，的确，&amp;ldquo;Service Mesh Interface（SMI）是使这一构想走向行业现实的重要一步&amp;rdquo;。&lt;/p&gt;
&lt;h3 id=&#34;和通用数据平面-api-的关系&#34;&gt;和通用数据平面 API 的关系&lt;/h3&gt;
&lt;p&gt;在 SMI 提出来之前不久（大概早两个星期），CNCF 也在进行类似的标准化操作：CNCF 正在筹建通用数据平面 API 工作组（Universal Data Plane API Working Group / UDPA-WG)，以制定数据平面的标准 API，为 L4/L7 数据平面配置提供事实上的标准，初始成员将包括 Envoy 和 gRPC 项目的代表。事实上是 Google 在驱动，主要参与的项目是 Istio 和 Envoy。&lt;/p&gt;
&lt;p&gt;下面这张图片展示 UDPA 和 SMI 这两个新近推出的 Service Mesh 标准 API 的关系：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-interface-detail/images/two-api_hua970b559b9d743d44c34e6fbe181f921_10038_01992c4dcff85bbb7b9839a6bd4f239f.webp 400w,
               /blog/service-mesh-interface-detail/images/two-api_hua970b559b9d743d44c34e6fbe181f921_10038_6e6c3bf8706457392771286ab0ba1cd0.webp 760w,
               /blog/service-mesh-interface-detail/images/two-api_hua970b559b9d743d44c34e6fbe181f921_10038_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-interface-detail/images/two-api_hua970b559b9d743d44c34e6fbe181f921_10038_01992c4dcff85bbb7b9839a6bd4f239f.webp&#34;
               width=&#34;600&#34;
               height=&#34;546&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Universal Data Plane API 是数据平面的标准，控制平面通过这个 API 来控制数据平面的行为。工作组的初始成员来自包括 Envoy 和 gRPC 项目的代表，&lt;strong&gt;背后的公司主要是 Google&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;Service Mesh Interface 是控制平面的标准，上层的应用/工具/生态体系通过 Service Mesh Interface 来实现跨不同的 Service Mesh 实现为最终用户提供一致性的体验。&lt;strong&gt;SMI 由微软牵头&lt;/strong&gt;，联合 Linkerd，HashiCorp，Solo，Kinvolk 和 Weaveworks。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;smi-的目标和愿景&#34;&gt;SMI 的目标和愿景&lt;/h3&gt;
&lt;p&gt;关于 SMI 的目标和愿景，我援引  Idit Levine 的这段话（这段话也同样出现在 smi-spec 的 github 首页）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SMI 是在 Kubernetes 上运行服务网格的规范。它定义了由各种供应商实现的通用标准。这使得最终用户的标准化和服务网格供应商的创新可以两全其美。SMI 实现了灵活性和互通性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更详细而明确的目标描述来自 smi-spec 的 github 首页：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目标&lt;/p&gt;
&lt;p&gt;SMI API 的目标是提供一组通用的，可移植的 Service Mesh API，Kubernetes 用户可以以供应商无关的方式使用这些 API。通过这种方式，可以定义使用 Service Mesh 技术的应用程序，而无需紧密绑定到任何特定实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后还特别强调：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;非目标&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SMI 项目本身不实现服务网格&lt;/strong&gt;。SMI 只是试图定义通用规范。同样，SMI 不定义服务网格的具体范围，而是一个通用子集。欢迎 SMI 供应商添加超出 SMI 规范的供应商特定扩展和 API。我们希望随着时间的推移，随着更多功能被普遍接受为服务网格的一部分，这些定义将迁移到 SMI 规范中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结：首先非常明确的一点是，SMI 是定义标准 API，而不是标准实现。&lt;/p&gt;
&lt;p&gt;而 SMI 的具体目标，在 SMI 的官方网站是这样介绍的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A standard interface for service meshes on Kubernetes: Kubernetes 上的 service mesh 的标准接口&lt;/li&gt;
&lt;li&gt;A basic feature set for the most common service mesh use cases：用于最通用的服务网格用例的基本特性&lt;/li&gt;
&lt;li&gt;Flexibility to support new service mesh capabilities over time：随着时间的推移灵活地支持新的服务网格能力&lt;/li&gt;
&lt;li&gt;Space for the ecosystem to innovate with service mesh technology: 使用服务网格技术实现生态系统创新的空间&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;smi-社区&#34;&gt;SMI 社区&lt;/h3&gt;
&lt;p&gt;有需求，有市场，有想法，有目标，我们再来看看 SMI 阵营现在都有什么力量。&lt;/p&gt;
&lt;p&gt;微软在推出 SMI 时的描述到：SMI 是一个开放项目，由微软，Linkerd，HashiCorp，Solo，Kinvolk 和 Weaveworks 联合启动; 并得到了 Aspen Mesh，Canonical，Docker，Pivotal，Rancher，Red Hat 和 VMware 的支持。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-interface-detail/images/partnership_hub4457b7f81084c722c08045523aee746_100734_c4a82a503392db58c1f69a3f68452678.webp 400w,
               /blog/service-mesh-interface-detail/images/partnership_hub4457b7f81084c722c08045523aee746_100734_3fa667828132054f393be1ff3ace6d2d.webp 760w,
               /blog/service-mesh-interface-detail/images/partnership_hub4457b7f81084c722c08045523aee746_100734_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-interface-detail/images/partnership_hub4457b7f81084c722c08045523aee746_100734_c4a82a503392db58c1f69a3f68452678.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;阵营还是挺强大的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微软：SMI 的带头大哥，云计算的三巨头之一&lt;/li&gt;
&lt;li&gt;Buoyant：Service Mesh 技术的拓荒牛 + 布道者，小而弥坚的初创公司，有一个不大但是力量很强又非常有经验还很务实的团队。其旗下的 Linkerd2 已经明确表示将支持 SMI。&lt;/li&gt;
&lt;li&gt;HashiCorp：大名鼎鼎的 consul 就出自这里，Consul Connect 也是目前活跃的 service mesh 实现之一，虽然 Consul Connect 在国内知名度和影响力都很小（也就年度总结的时候捎带着看一眼状态的那种）。Consul Connect 目前也表示提供了对 SMI 的支持。&lt;/li&gt;
&lt;li&gt;Solo.io：深藏不露的初创型小公司，&amp;ldquo;产品面很广，除了 Service Mesh 方面大有名气的 SuperGloo 和 Service Mesh hub 之外，还有远程调试、混沌工程、unikernels 以及微服务网关等几个产品。&amp;quot;（这段话我从秀龙的文章里面抄过来的，总结的很好）。另外，业界网红 Christian Posta 前段时间加入这家公司。solo 公司旗下的 SuperGloo 是业界第一个 service mesh 编排产品，因此对 SMI 的热爱和支持是无可复加的。SuperGloo 和 Service Mesh Hub 已经实现了对 SMI 的支持。&lt;/li&gt;
&lt;li&gt;Mesery 和 Kinvolk：这两家公司最近在 service mesh 社区有点名气，因为他们近期做了 Istio vs Linkerd 的性能测试并给出了报告，闹的满城风雨。而且他们也都喜欢用 solo 出的 SuperGloo（毕竟业界号称 service mesh 编排的也就独此一家）。&lt;/li&gt;
&lt;li&gt;Aspen Mesh：F5（没错，就是那个巨贵的 F5）出的的 Istio 商业版本。但是没有看到 Aspen Mesh 给出支持 SMI 的信息，暂时还不知道 Aspen Mesh 和 SMI 的关系。&lt;/li&gt;
&lt;li&gt;vmware：vmware 在 2018 年底推出了 VMware NSX Service Mesh，和 Aspen Mesh 一样也是基于 Istio。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他公司就不再一一列出来了，主要是不清楚他们在 SMI 这个事情上扮演什么角色。&lt;/p&gt;
&lt;p&gt;而关键点在于，Google（还有同属 Istio 阵营的 IBM / Lyft）不在其列。而 Service Mesh 的其他玩家，几乎都参与了 SMI，甚至包括原本在 Istio 项目上和 google 一直合作的公司，耐人寻味。&lt;/p&gt;
&lt;h2 id=&#34;smi-规范内容&#34;&gt;SMI 规范内容&lt;/h2&gt;
&lt;h3 id=&#34;smi-规范介绍&#34;&gt;SMI 规范介绍&lt;/h3&gt;
&lt;p&gt;Service Mesh Interface 规范涵盖最常见服务网格能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Traffic Policy/流量策略 - 跨服务应用身份和传输加密等策略&lt;/li&gt;
&lt;li&gt;Traffic Telemetry/流量遥测 - 捕获关键指标，如错误率和服务间的延迟&lt;/li&gt;
&lt;li&gt;Traffic Management/流量管理 - 在不同服务之间转移流量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SMI 规范由多个 API 组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Traffic Access Control/流量访问控制 - 根据客户端的身份配置对特定 pod 和路由的访问，以将应用程序锁定到仅允许的用户和服务。&lt;/li&gt;
&lt;li&gt;Traffic Specs/流量规范 - 定义流量的表示方式，基于每个协议的基础。这些资源与访问控制和其他类型的策略协同工作，以在协议级别管理流量。&lt;/li&gt;
&lt;li&gt;Traffic Split/流量分割 - 逐步引导各种服务之间的流量百分比，以帮助构建金丝雀推出。&lt;/li&gt;
&lt;li&gt;Traffic Metrics/流量指标 - 暴露通用的流量指标，供 dashboard 和 autoscaler 等工具使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：SMI 被指定为 Kubernetes Custom Resource Definitions（CRD）和 Extension API Servers 的集合。这些 API 可以安装到 Kubernetes 集群上，并使用标准工具进行操作。&lt;/p&gt;
&lt;p&gt;在设计上，SMI 强调 &amp;ldquo;Provider Agnostic（供应商无关）&amp;quot;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SMI API 的目标是提供一组通用的可移植的服务网格 API，Kubernetes 用户可以以供应商无关的方式使用这些 API。通过这种方式，人们可以定义使用服务网格技术的应用程序，而无需紧密绑定到任何特定实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们来详细看一下 SMI 规范的具体 API 定义，其定义来自 &lt;a href=&#34;https://github.com/deislabs/smi-spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/deislabs/smi-spec&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;traffic-spec&#34;&gt;Traffic Spec&lt;/h3&gt;
&lt;p&gt;Traffic Spec 资源用于让用户定义流量。通常与 Access Control（访问控制）和其他策略一起使用，以具体定义需要如何处理流经网格的特定类型流量。&lt;/p&gt;
&lt;p&gt;用户往往希望在服务网格内运行许多不同的协议。当然，主要会是 HTTP，但也会有其他协议。Traffic Spec 规范中的每个资源都旨在与特定协议 1:1 匹配。这让用户可以以协议特定的方式来定义流量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTPRouteGroup&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTPRouteGroup 资源用于描述HTTP/1和HTTP/2流量，它枚举了应用程序可以提供的路由。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;specs.smi-spec.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTPRouteGroup&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;the-routes&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matches&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;pathRegex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/metrics&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;methods&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;GET&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;health&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;pathRegex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/ping&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;methods&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的例子定义两个&lt;code&gt;match&lt;/code&gt;，&lt;code&gt;metrics&lt;/code&gt;和&lt;code&gt;health&lt;/code&gt;。name 字段是 key，所有字段都是必需的。正则表达式用于匹配 URI。HTTP Mesh 可以具体制定如 &lt;code&gt;GET&lt;/code&gt; 或用 &lt;code&gt;*&lt;/code&gt; 来匹配所有。&lt;/p&gt;
&lt;p&gt;HTTPRouteGroup 当前的功能限制（未来会加入，只是当前作为第一个版本内容还比较少）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只支持 HTTP 协议，连 gRPC 都还未支持&lt;/li&gt;
&lt;li&gt;&lt;code&gt;match&lt;/code&gt; 字段当前仅适用于 &lt;code&gt;URI&lt;/code&gt;。很明显这是不够的，未来计划扩展以支持 HTTP header，Host 等。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;个人看法：目前在只有 HTTP 协议支持，而且 HTTP 路由定义居然不支持 HTTP header 匹配，足够说明目前 SMI 的确是处于项目早期状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;TCPRoute&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCPRoute 资源用于描述 L4 TCP 流量。这个路由极其简单（或者叫做简陋），定义应用程序接收到的原始的、无协议特征的流量。&lt;/p&gt;
&lt;p&gt;看完下面的 yaml 例子就明白为什么称为极其简单了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;specs.smi-spec.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TCPRoute&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tcp-route&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的路由只做了定义，尚未与任何资源相关联。我们继续看如何使用，比如与 Access Control 配合。&lt;/p&gt;
&lt;h3 id=&#34;traffic-access-control&#34;&gt;Traffic Access Control&lt;/h3&gt;
&lt;p&gt;Traffic Access Control 资源用来为应用程序定义访问控制策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问控制属于授权（authorization）范畴，默认身份验证（Authentication）已经由底层实现处理&lt;/li&gt;
&lt;li&gt;SMI 规范中的访问控制是附加的，默认情况下&lt;strong&gt;拒绝所有流量&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;TrafficTarget 规范&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TrafficTarget 规范用来定义流量访问控制，而 SMI 中访问控制是基于服务身份（service identity）的，并且目前只支持通过 Kubernetes service account 来指派服务身份（其他身份机制将在稍后支持）。&lt;/p&gt;
&lt;p&gt;流量访问控制有三个概念，分别在 TrafficTarget 中以三个字段定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Source：流量的来源，体现为具体的 Pod 列表，目前支持通过 selector 来实现，暂时不支持以资源的方式选择（如指定 Deployment、指定 Service）&lt;/li&gt;
&lt;li&gt;Destination：流量的目标，同样体现为具体的 Pod 列表，也只支持 selector&lt;/li&gt;
&lt;li&gt;Route：流量规范，用来区分 Destination 提供的多种不同的流量访问方式，如下图中的 api 访问和获取 metrics 信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_31ddfafe31a499ef7c9fbdd1a0b07683.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_7f556b78204559e930b76877640d52d8.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_31ddfafe31a499ef7c9fbdd1a0b07683.webp&#34;
               width=&#34;760&#34;
               height=&#34;350&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个例子中，展示对 api 进行访问和获取 metrics 信息这两个操作的流量访问控制：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;# 定义 TrafficSpec&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;specs.smi-spec.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTPRouteGroup&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;api-service-routes&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matches&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;api &lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# api 访问的流量&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;pathRegex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/api&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;methods&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 获取 metrics 的流量&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;pathRegex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;methods&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;GET&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TrafficTarget&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;access.smi-spec.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;api-service-metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 定义获取 metrics 的 Target&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;destination:	# 通过 ServiceAccount 选择 pods&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ServiceAccount&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;api-service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;specs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 引用 traficSec 定义的 route，指定为获取 metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTPRouteGroup&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;api-service-routes&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matches&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;metrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 通过 ServiceAccount 选择 pods&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ServiceAccount&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;prometheus&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TrafficTarget&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;access.smi-spec.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;api-service-api&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 定义访问 api 接口的 Target&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 通过 ServiceAccount 选择 pods&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ServiceAccount&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;api-service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;specs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 引用 traficSec 定义的 route，指定为 api 访问&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTPRouteGroup&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;api-service-routes&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matches&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;api&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 通过 ServiceAccount 选择 pods&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ServiceAccount&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;website-service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ServiceAccount&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;payments-service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述实例定义了两个容许的访问控制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于以 ServiceAccount 为 api-service 运行的 pods，容许来自以 ServiceAccount 为 prometheus 的 pods 访问 api-service-routes 定义下的 metrics 路由&lt;/li&gt;
&lt;li&gt;对于以 ServiceAccount 为 api-service 运行的 pods，容许来自以 ServiceAccount 为 website-service 和 payments-service  的 pods 访问 api-service-routes 定义下的 api 路由&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中有部分字段为可选字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;matches 字段：如果省略，则对 TrafficSpec 下定义的所有 Route 都生效&lt;/li&gt;
&lt;li&gt;Port 字段：如果省略，则表示所有端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SMI 流量访问控制的规则是默认都不容许访问，只有通过 TrafficTarget 指定的符合条件的流量才容许访问。而访问控制的执行，是明确要求在访问的服务器端（即 Destination）强制执行，而是否在客户端（即 Source）进行访问控制则由 SMI 的具体实现来决定。&lt;/p&gt;
&lt;p&gt;注意目前 Traffic Access Control 在定义 Source 和 Destination 时，都是通过 Selector 来定义的，我们细看这张图片：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_31ddfafe31a499ef7c9fbdd1a0b07683.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_7f556b78204559e930b76877640d52d8.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-interface-detail/images/smi-traffic-target_hu9c235f034760d8e5d89b04046e6e58e2_101156_31ddfafe31a499ef7c9fbdd1a0b07683.webp&#34;
               width=&#34;760&#34;
               height=&#34;350&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从访问控制的业务语义上看，上面两个 TrafficTarget 翻译出来就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容许以 ServiceAccount prometheus 运行的服务访问以 ServiceAccount api-service 运行的服务的 metrics&lt;/li&gt;
&lt;li&gt;容许以 ServiceAccount web-service 和 payment-service 运行的服务访问以 ServiceAccount api-service 运行的服务的 api&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而不是我们平时熟悉的资源方式如&amp;quot;容许 A 服务访问 B 服务&amp;rdquo;，即访问控制中对服务的标示目前只能通过 ServiceAccount + Selector 来完成，而不是通过简单的服务 Id 或者名称来指定资源。请注意&amp;quot;容许以身份 A 运行的服务访问以身份 B 运行的服务&amp;rdquo; 和 &amp;ldquo;容许 A 服务访问 B 服务&amp;rdquo; 的细微差别。&lt;/p&gt;
&lt;p&gt;关于这一点，在 SMI 的文档的&amp;quot;Tradeoffs&amp;quot;中提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Resources vs selectors - it would be possible to reference concrete resources such as a deployment instead of selecting across pods.&lt;/p&gt;
&lt;p&gt;资源 vs 选择器 - 可以引用具体资源（如 deployment）而不是 pod 选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;traffic-split&#34;&gt;Traffic Split&lt;/h3&gt;
&lt;p&gt;Traffic Split 资源用来实现流量的百分比拆分，熟悉 Istio 的同学应该非常了解这个功能的强大。&lt;/p&gt;
&lt;p&gt;但是 SMI 中 Traffic Split 的配置方式和 Istio 有非常大的不同，比如下面的配置，要对 foobar 服务按照版本进行流量拆分，v1 和 v2 权重分别为 1 和 500m（1=1000m），在 Traffic Split 的配置中会出现多个 service：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;split.smi-spec.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TrafficSplit&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foobar-rollout&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foobar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# root service，客户端用这个服务名来连接目标应用&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;backends&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# root service 后面的服务，有自己的 selectors, endpoints 和 configuration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foobar-v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foobar-v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;500m&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&amp;ldquo;foobar&amp;rdquo;：通过 &lt;code&gt;spec.service&lt;/code&gt; 指定，这是 Traffic Split 的 root service，是要配置进行流量拆分的目标服务的 FQDN，客户端用这个 service 进行通信，也就是说这个 root service 是暴露给客户端的。&lt;/li&gt;
&lt;li&gt;&amp;ldquo;footer-v1&amp;rdquo; 和 &amp;ldquo;footer-v2&amp;rdquo;：这两个后端服务，是&amp;quot;隐藏&amp;quot;在 root service 后面的，通常是 root service 的子集，典型实现上是 selector 多加一个 version label 限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，如果要对某个服务的两个子集进行流量拆分，典型如版本 v1 和版本 v2，在 SMI 中就会有三个 k8s service 定义：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;资源&lt;/th&gt;
&lt;th&gt;selector（label）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;service foobar&lt;/td&gt;
&lt;td&gt;&lt;code&gt;app: foobar&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;root service&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;service foobar-v1&lt;/td&gt;
&lt;td&gt;&lt;code&gt;app: foobar&lt;/code&gt;, &lt;code&gt;version: v1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;backend service&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;service foobar-v2&lt;/td&gt;
&lt;td&gt;&lt;code&gt;app: foobar&lt;/code&gt;, &lt;code&gt;version: v2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;backend service&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这三个 service 和 pod 的关系如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-interface-detail/images/smi-traffic-split_huaddcd7e9102718607d20de96a4a4f7e1_80014_3605fd37ca86cf5ae54f05f325f911e8.webp 400w,
               /blog/service-mesh-interface-detail/images/smi-traffic-split_huaddcd7e9102718607d20de96a4a4f7e1_80014_6baa983e9763c970e6d1d57da2d4e0d9.webp 760w,
               /blog/service-mesh-interface-detail/images/smi-traffic-split_huaddcd7e9102718607d20de96a4a4f7e1_80014_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-interface-detail/images/smi-traffic-split_huaddcd7e9102718607d20de96a4a4f7e1_80014_3605fd37ca86cf5ae54f05f325f911e8.webp&#34;
               width=&#34;760&#34;
               height=&#34;358&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们来对比 Istio 中实现类似功能的方式，Istio 中需要为准备进行流量拆分的服务定义 VirtualService，通过 subset 来区分不同的流量去向：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;VirtualService&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foobar-route&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;foobar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foobar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foobar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;75&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;subset 在 DestinationRule 中定义，注意这里只涉及到 labels，服务（以 host 标志）并没有多个，还是 foobar：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-yam&#34; data-lang=&#34;yam&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: foobar-destination
spec:
  host: foobar
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Istio 中，service 和 subset 的关系如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-interface-detail/images/istio-traffic-split_hu342454daf6550c3d94a7f94651c1b7be_75174_531f5cf244da75a29a82d989d58d4db4.webp 400w,
               /blog/service-mesh-interface-detail/images/istio-traffic-split_hu342454daf6550c3d94a7f94651c1b7be_75174_522632e61718b6bf2899532befd74348.webp 760w,
               /blog/service-mesh-interface-detail/images/istio-traffic-split_hu342454daf6550c3d94a7f94651c1b7be_75174_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-interface-detail/images/istio-traffic-split_hu342454daf6550c3d94a7f94651c1b7be_75174_531f5cf244da75a29a82d989d58d4db4.webp&#34;
               width=&#34;760&#34;
               height=&#34;358&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可以看到 SMI 中的 backend service 和 Istio 中的 subset 在功能上几乎是对等的。&lt;/p&gt;
&lt;p&gt;但是：SMI 和 Istio 的根本差异在于 Istio 中的 subset 是一个虚拟的抽象对象，在 k8s 中并没有实体资源。而在 SMI 中，backend service 是实实在在存在的 k8s service 资源。&lt;/p&gt;
&lt;p&gt;这里个人觉得有一个隐忧：在 SMI 中，为了进行流量拆分，就不得不为每个版本建立一个独立的 k8s service，service 数量会比 Istio 方案多很多。&lt;/p&gt;
&lt;p&gt;另外就是在权重设置上的细微的差别，SMI 用的是相对 weight（比如可以设置为 1:2），而 Istio 是严格的百分比，而且要求总和为 100。&lt;/p&gt;
&lt;h3 id=&#34;traffic-metrics&#34;&gt;Traffic Metrics&lt;/h3&gt;
&lt;p&gt;Traffic Metrics 资源提供通用集成点，工具可以通过访问这些集成点来抓取指标。Traffic Metrics 遵循 &lt;code&gt;metrics.k8s.io&lt;/code&gt; 的模式，其即时指标可用于各种 CLI 工具，HPA 伸缩等。&lt;/p&gt;
&lt;p&gt;和大多数 Metrics 系统一致，SMI 的 Traffic Metrics 数据包含两个核心对象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Resource：Metrics 和资源绑定，资源可以是 pod 和更高级别的概念如 namespaces, deployments 或者 services。Pod 是 Metrics 可以关联的最细粒度的资源，通过集合可以得到推断出其他。&lt;/li&gt;
&lt;li&gt;Edge：表示流量来源或其目的地，描述力量的方向。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;TrafficMetrics&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TrafficMetrics 是核心资源，关联到资源，具有 edge，延迟百分位数和请求量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;metrics.smi-spec.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TrafficMetrics&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foo-775b9cbd88-ntxsl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foobar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;edge&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;direction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;baz-577db7d977-lsk2q&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foobar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;ld&#34;&gt;2019-04-08T22:25:55Z&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;30s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metrics&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;p99_response_latency&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;unit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;seconds&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;10m&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;p90_response_latency&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;unit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;seconds&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;10m&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;p50_response_latency&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;unit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;seconds&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;10m&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;success_count&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;failure_count&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;TrafficMetrics 的定义和使用暂时没看到有特殊之处。&lt;/p&gt;
&lt;h3 id=&#34;smi-规范总结&#34;&gt;SMI 规范总结&lt;/h3&gt;
&lt;p&gt;从上面我们详细分析的 SMI 主要规范的定义看，Traffic Access Control / Traffic Specs / Traffic Split / Traffic Metrics 这四个目前定义好的规范，无论从功能还是从 API 设计上看，都缺乏亮点，至少与目前大家熟悉的 Istio API 相比，没有明显优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Traffic Specs 中 HTTPRouteGroup 只支持 HTTP1.1，甚至不支持 header，TCPRoute 更是简陋到极致&lt;/li&gt;
&lt;li&gt;Traffic Access Control 只支持 ServiceAccount&lt;/li&gt;
&lt;li&gt;Traffic Split：需要为每个需要拆分的流量额外增加 k8s service&lt;/li&gt;
&lt;li&gt;TrafficMetrics：平平无奇&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考虑到目前 SMI 还是第一个版本，处于项目早期阶段，不够成熟情有可原，我们更要关注的是其后续版本的演进，希望未来 SMI 可以成长为一个足够坚实而可用的标准 API。&lt;/p&gt;
&lt;h2 id=&#34;smi-分析&#34;&gt;SMI 分析&lt;/h2&gt;
&lt;p&gt;前面我们分析过 SMI 推出的背景，我归结为关键的两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有利可图：Service Mesh 技术被普遍看好，其长远价值被各大厂商认可&lt;/li&gt;
&lt;li&gt;有机可趁：作为市场领头羊的 Google 和 Istio，表现疲软&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外 Google 在 Istio 项目上，表现也有些令人费解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;迟迟不进 CNCF：早先还有未能发布 1.0 版本不满足 CNCF 要求的借口，而最近则感觉 Google 一直在避免讨论这个话题&lt;/li&gt;
&lt;li&gt;Istio 一直没有对 Service Mesh 技术进行标准化：只关注自己的 Istio API，对于标准化和基于标准化构建生态系统完全没兴趣。即便是统一数据平面 API 的标准化动作，也让人觉得是 Envoy 在推动。&lt;/li&gt;
&lt;li&gt;宣传和现实的差距：Istio 1.0 的 &amp;ldquo;Product Ready&amp;rdquo;，1.1 版本的&amp;quot;Enterprise Ready&amp;quot;，很让人无语，我很期待 1.2 版本出来时的口号。&lt;/li&gt;
&lt;li&gt;架构设计的不务实：Mixer 是被嘲弄的重灾区，躲在 Mixer 身后的 Pilot 其实问题也一堆，而 Mixer v2 的进展则成为衡量 Istio 未来走向的风向标，是要成为工业级可用的坚实产品，还是继续摆弄优雅架构做花瓶？未来一年我们拭目以待。&lt;/li&gt;
&lt;li&gt;整个社区对 Istio 的不满情绪一直在酝酿和累积：这次 SMI 推出引发的轰动，很大程度是这种情绪的发泄——除了 Google 之外几乎所有的 Servic Mesh 的玩家都参与进来了，这就足够说明问题了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在过去两年，社区一直在期待 Google 和 Istio，但是，这种期待在持续两年的失望之后，开始转向另外的方向：或许我们要更多的考虑 Istio 之外的选择了。&lt;/p&gt;
&lt;p&gt;Service Mesh 的战争，我们原以为会以 Istio 的胜利而迅速结束，但是现在看来，可能这场战争才刚刚开始。&lt;/p&gt;
&lt;p&gt;是重新认真审视这张图片的时候了：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-interface-detail/images/gartner_hu0cefc59b1305d4b12fbb9ada76f070b9_62500_1fe712495bd7bb723701adbdeaf47c7d.webp 400w,
               /blog/service-mesh-interface-detail/images/gartner_hu0cefc59b1305d4b12fbb9ada76f070b9_62500_ebccc8532a6fce525956e9a12ece7927.webp 760w,
               /blog/service-mesh-interface-detail/images/gartner_hu0cefc59b1305d4b12fbb9ada76f070b9_62500_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-interface-detail/images/gartner_hu0cefc59b1305d4b12fbb9ada76f070b9_62500_1fe712495bd7bb723701adbdeaf47c7d.webp&#34;
               width=&#34;760&#34;
               height=&#34;505&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SMI 的推出，意义并不仅仅在于这个 Service Mesh 标准本身，而是带有另外一种特殊含义，就如陈胜吴广的揭竿而起，传递给四方的消息是：天下苦秦久矣！&lt;/p&gt;
&lt;p&gt;文章最后，希望未来有更多的优秀 Service Mesh 产品出现，也希望 Istio 可以知耻而后勇。Service Mesh 技术要想成功普及，一定需要一个或者多个强力产品的出现，而 SMI 的出现则为这场短期不能结束的纷争带来了一个理论可能：无论产品竞争如何激烈，都不影响上层生态，从而避免站队失败的风险和由此带来的犹豫与观望。这才是我个人觉得 SMI 推出的最大意义所在。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://smi-spec.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;smi 官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/deislabs/smi-spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;smi-spec 项目@github &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.redhat.com/en/blog/interoperability-new-service-mesh-interface&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Interoperability with the new Service Mesh Interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.fleeto.us/post/servicemesh-interface/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;意外：Servicemesh Interface（SMI）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://msft.today/hello-service-mesh-interface-smi-a-specification-for-service-mesh-interoperability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hello Service Mesh Interface (SMI): A specification for service mesh interoperability&lt;/a&gt;: 来自微软的博客，比较权威，本文很多内容是援引自此文&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/solo-io/service-mesh-interface-smi-and-our-vision-for-the-community-and-ecosystem-2edc7b728c43&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh Interface (SMI) and our Vision for the Community and Ecosystem&lt;/a&gt;：作者 &lt;a href=&#34;https://medium.com/@idit.levine_92620&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Idit Levine&lt;/a&gt;，是初创公司 solo.io 的创始人兼 CEO，本文同样大量援引此文的内容&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kccnceu19.sched.com/event/MRz7/sponsored-keynote-democratizing-service-mesh-on-kubernetes-gabe-monroy-lead-product-manager-microsoft-azure-container-compute&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Democratizing Service Mesh on Kubernetes&lt;/a&gt;: kubecon 上宣布 SMI 的 keynote，作者 Gabe Monroy，Microsoft Azure Container Compute 的 Lead Product Manager，本文部分图片来自这个演讲的 PPT&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kinvolk.io/blog/2019/05/how-the-service-mesh-interface-smi-fits-into-the-kubernetes-landscape/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How the Service Mesh Interface (SMI) fits into the Kubernetes landscape&lt;/a&gt;: 介绍 SMI 和其他类似的 kubernetes Interface 如 CNI、CRI、CSI 等。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.getambassador.io/kubecon-eu-2019-top-10-takeaways-123b5fcb30a8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KubeCon EU 2019: Top 10 Takeaways&lt;/a&gt;: 来自网红 Daniel Bryant 的文章，包含对 SMI 和 Istio 的看法。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://softwareengineeringdaily.com/2019/05/31/service-mesh-wars-with-william-morgan/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh Wars with William Morgan&lt;/a&gt;：这是我见过的抨击 Istio 最为猛烈的一篇文章，极其火爆，又很有道理的样子&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoworld.com/article/3400116/introducing-the-service-mesh-interface.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;To Istio and beyond: Azure’s Service Mesh Interface&lt;/a&gt;: 有软文嫌疑，但是还是能看出微软推出 SMI 的基本想法&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hashicorp.com/blog/hashicorp-consul-supports-microsoft-s-new-service-mesh-framework&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HashiCorp Consul supports Microsoft’s new Service Mesh Interface&lt;/a&gt;: 介绍 Consul Connect 对 SMI 的支持&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh 发展趋势：云原生中流砥柱</title>
      <link>https://cloudnative.to/blog/201905-servicemesh-development-trend/</link>
      <pubDate>Tue, 28 May 2019 07:15:43 +0800</pubDate>
      <guid>https://cloudnative.to/blog/201905-servicemesh-development-trend/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/logo_hu33fa7b0d130994feec728c7b19e321fb_24980_35ebf810c09f87b17a057091796b93fa.webp 400w,
               /blog/201905-servicemesh-development-trend/logo_hu33fa7b0d130994feec728c7b19e321fb_24980_21a1f0c3f2cb8c9c7b8870714ab2c004.webp 760w,
               /blog/201905-servicemesh-development-trend/logo_hu33fa7b0d130994feec728c7b19e321fb_24980_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/logo_hu33fa7b0d130994feec728c7b19e321fb_24980_35ebf810c09f87b17a057091796b93fa.webp&#34;
               width=&#34;600&#34;
               height=&#34;296&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文内容整理自 5 月 25 日在 Kubernetes &amp;amp; Cloud Native Meetup 上海站发表的主题演讲，主要介绍了 Service Mesh 最新的产品动态，分析其发展趋势和未来走向；结合蚂蚁的上云实践，阐述在云原生背景下 Service Mesh 的核心价值，以及对云原生落地的关键作用。&lt;/p&gt;
&lt;p&gt;内容主要有三个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Service Mesh 产品动态：介绍最近半年 Service Mesh 的产品动态，包括开源项目和云厂商推出的云上服务&lt;/li&gt;
&lt;li&gt;Service Mesh 发展趋势：根据最近的产品动态，总结 Service Mesh 的发展趋势，推断未来的走向&lt;/li&gt;
&lt;li&gt;Service Mesh 与云原生：结合云原生，更好的理解 Service Mesh 的价值和作用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;service-mesh-产品动态&#34;&gt;Service Mesh 产品动态&lt;/h2&gt;
&lt;h3 id=&#34;istio11-发布&#34;&gt;Istio1.1 发布&lt;/h3&gt;
&lt;p&gt;Istio 是目前 Service Mesh 社区最引人注目的开源项目，在今年的 3 月份发布了期待已久的 Istio 1.1 版本，我们来看看 Istio 最近几个版本的发布情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2018 年 6 月 1 日，Istio 发布了 0.8 版本，这是 Istio 历史上第一个 LTS 版本，也是 Istio 历史上变动最大的一个版本&lt;/li&gt;
&lt;li&gt;2018 年 7 月 31 日，Istio 发布了 1.0 版本，号称 &amp;ldquo;Product Ready&amp;rdquo;&lt;/li&gt;
&lt;li&gt;然后就是漫长的等待，Istio 1.0 系列以每个月一个小版本的方式一路发布了 1.0.1 到 1.0.6，然后才开始 1.1.0 snapshot 1 到 6，再 1.1.0-rc 1 到 6，终于在 2019 年 3 月 20 日发布了 1.1 版本，号称 &amp;ldquo;Enterprise Ready&amp;rdquo;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从 Istio 1.0 到 Istio 1.1，中间的时间跨度高达 9 个月！我们来看看经过这漫长的开发时间才发布的 Istio 1.1 版本带来了哪些新的东西：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/istio1.1-new-feature_hu76ac9759400c101aaf18019ac440e349_377617_ac3c651d78d627344c4c8285ba3ba55d.webp 400w,
               /blog/201905-servicemesh-development-trend/istio1.1-new-feature_hu76ac9759400c101aaf18019ac440e349_377617_f2c985e69fdb97625ec36b3a5d7c317d.webp 760w,
               /blog/201905-servicemesh-development-trend/istio1.1-new-feature_hu76ac9759400c101aaf18019ac440e349_377617_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/istio1.1-new-feature_hu76ac9759400c101aaf18019ac440e349_377617_ac3c651d78d627344c4c8285ba3ba55d.webp&#34;
               width=&#34;760&#34;
               height=&#34;260&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图中标红的部分，涉及到 Istio 的架构调整，下面将详细介绍 Istio 1.1 版本中带来的架构变化。&lt;/p&gt;
&lt;h3 id=&#34;istio-11-架构变化&#34;&gt;Istio 1.1 架构变化&lt;/h3&gt;
&lt;p&gt;下图是 Istio 1.0 和 Istio 1.1 的架构图对比：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/istio-constructure_hu4198b4c5ce0c30c2c9b7538d2a15eb29_241299_4898e41f149f860074e9f200ae717006.webp 400w,
               /blog/201905-servicemesh-development-trend/istio-constructure_hu4198b4c5ce0c30c2c9b7538d2a15eb29_241299_42963b6dfc3909427816e0e38495b3c2.webp 760w,
               /blog/201905-servicemesh-development-trend/istio-constructure_hu4198b4c5ce0c30c2c9b7538d2a15eb29_241299_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/istio-constructure_hu4198b4c5ce0c30c2c9b7538d2a15eb29_241299_4898e41f149f860074e9f200ae717006.webp&#34;
               width=&#34;760&#34;
               height=&#34;339&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Istio 1.1 的第一个架构变化来自 Galley：在 Istio 1.1 的架构图中增加了 Galley 组件。但是实际上在 Istio 1.0 版本中 Gallay 组件就已经存在，只是当时 Galley 的功能非常简单，只是做配置更新之后的验证（Validation），在 Istio 1.0 的架构图中都没有出现。而在 Istio 1.1 版本之后，Galley 的定位发生了巨大的变化：Galley 开始分担 Pilot/Mixer 的职责。&lt;/p&gt;
&lt;p&gt;在 Istio 1.1 版本之前的设计中，Istio 的三大组件 Pilot/Mixer/Citadel 都需要访问 kubernetes 的 API Server，以获取服务注册信息和配置信息，包括 kubernetes 原生资源如 service/deployment/pod 等，还有 Istio 的自定义资源（数量多达 50 多个的 CRD） 。这个设计导致 Istio 的各个组件都不得不和 kubernetes 的 API Server 产生强绑定，不仅仅代码大量冗余，而且在测试中也因为需要和 kubernetes 的 API Server 交互导致 Pilot/Mixer 模块测试困难。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，在 Istio 1.1 之后，访问 kubernetes 的 API Server 的工作将逐渐交给 Galley 组件，而其他组件如 Pilot/Mixer 就会和  kubernetes 解耦。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/galley_hu36cadac9783acba6e48912b877f04ef2_31341_f4af3a58e6333e61da9f28567da21e89.webp 400w,
               /blog/201905-servicemesh-development-trend/galley_hu36cadac9783acba6e48912b877f04ef2_31341_852920781500c4f1b02186d4160c01a2.webp 760w,
               /blog/201905-servicemesh-development-trend/galley_hu36cadac9783acba6e48912b877f04ef2_31341_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/galley_hu36cadac9783acba6e48912b877f04ef2_31341_f4af3a58e6333e61da9f28567da21e89.webp&#34;
               width=&#34;400&#34;
               height=&#34;457&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个工作还在进行中，目前 Istio 的 CRD 已经修改为由 Galley 读取，而 K8s 的原生资源（Service / Deployment / Pod 等），暂时还是由 Pilot 读取。&lt;/p&gt;
&lt;p&gt;为了方便在各个组件中同步数据，Istio 引入了 MCP（Mesh Configuration Protocol）协议。在 Istio 1.1 版本中，Pilot 通过 MCP 协议从 Galley 同步数据。MCP 是受 xDS v2 协议（准确说是 aDS）的启发而制定的新协议，用于在 Istio 各模块之间同步数据。&lt;/p&gt;
&lt;p&gt;Istio 1.1 的第二个架构变化来自于 Mixer，在 Istio 1.1 版本中，推荐使用 Out-of-Process Adapter，即进程外适配器。Istio 预计下一个版本将弃用 In-Proxy Adapter，目前所有的 Adapter 都将改为 Out-of-Process adapter。&lt;/p&gt;
&lt;p&gt;什么是 In-Proxy Adapter？下图是 Mixer 的架构图，在 Istio 的设计中，Mixer 是一个独立进程，Proxy 通过远程调用来和 Mixer 交互。而 Mixer 的实现了 Adapter 模式，定义了 Adapter API，然后内建了数量非常多的各种 Adapter。这些 Adatper 的代码存放在 Mixer 代码中，运行时也在 Mixer 的进程内，因此称为 In-Process Adapter。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/in-process-adapter_hu78fe0ba4957a5d6ea19ebf6195b4f388_247736_0c0724fb7f9cf276d4f0459cff1c5d0e.webp 400w,
               /blog/201905-servicemesh-development-trend/in-process-adapter_hu78fe0ba4957a5d6ea19ebf6195b4f388_247736_a6bbb0f913f90e97cd27e9d02a6b96d5.webp 760w,
               /blog/201905-servicemesh-development-trend/in-process-adapter_hu78fe0ba4957a5d6ea19ebf6195b4f388_247736_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/in-process-adapter_hu78fe0ba4957a5d6ea19ebf6195b4f388_247736_0c0724fb7f9cf276d4f0459cff1c5d0e.webp&#34;
               width=&#34;760&#34;
               height=&#34;532&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;In-Process Adapter 的问题在于所有的 Adapter 的实现都和 Mixer 直接绑定，包括代码和运行时。因此当 Adapter 需要更新时就需要更新整个 Mixer，任意一个 Adapter 的实现出现问题也会影响整个 Mixer，而且数量众多的 Adapter 也带来了数量众多的 CRD。为此，Istio 1.1 版本中通过引入 Out-of-Process Adapter 来解决这个问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/out-of-process-adapter_hu5467bc6fcb0eb5e79150281f70c584fa_175045_eb021177df55d5879804aba3a38a1ebc.webp 400w,
               /blog/201905-servicemesh-development-trend/out-of-process-adapter_hu5467bc6fcb0eb5e79150281f70c584fa_175045_a76ee1c7760bbaa107c9c7b87c8a35b0.webp 760w,
               /blog/201905-servicemesh-development-trend/out-of-process-adapter_hu5467bc6fcb0eb5e79150281f70c584fa_175045_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/out-of-process-adapter_hu5467bc6fcb0eb5e79150281f70c584fa_175045_eb021177df55d5879804aba3a38a1ebc.webp&#34;
               width=&#34;760&#34;
               height=&#34;390&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Out-of-Process Adapter 以独立进程的方式运行在 Mixer 进程之外，因此 Out-of-Process Adapter 的开发/部署和配置都可以独立于 Mixer，从而将 Mixer 从 Adaper 的实现细节中解脱出来。&lt;/p&gt;
&lt;p&gt;但是，Out-of-Process Adapter 的引入，会导致新的性能问题：原来 Mixer 和 In-Process Adapter 之间是方法调用，现在改成 Out-of-Process Adapter 之后就变成远程调用了。而 Mixer 一直以来都是 Istio 架构设计中最大的争议，之前 Proxy 和 Mixer 之间的远程调用，已经造成非常大的性能瓶颈，而引入 Out-of-Process Adapter 之后远程调用会从一次会变成多次（每个配置生效的 Out-of-Process Adapter 就意味着一次远程调用），这会让性能雪上加霜。&lt;/p&gt;
&lt;p&gt;总结 Out-of-Process Adapter 的引入：&lt;strong&gt;架构更加的优雅&lt;/strong&gt;，&lt;strong&gt;性能更加的糟糕&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 Istio 1.1 为了架构而不顾性能的同时，Istio 内部也有其他的声音传出，如正在规划中的 Mixer v2。这个规划最重要的决策就是放弃 Mixer 独立进程的想法，改为将 Mixer 的功能合并到 Envoy 中，从而避免 Envoy 和 Mixer 之间远程调用的开销。关于 Mixer 的性能问题和 Mixer 合并的思路，蚂蚁金服在去年六月份开始 SOFAMesh 项目时就有清晰的认识和计划，时隔一年，终于欣喜的看到 Istio 开始正视 Mixer 的架构设计问题并回到正确的方向上。&lt;/p&gt;
&lt;p&gt;对此有兴趣的朋友可以通过阅读下面的文章获取更详细的信息（发表于一年前，但是依然有效）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://skyao.io/talk/201806-service-mesh-explore/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大规模微服务架构下的 Service Mesh 探索之路&lt;/a&gt;: 第二节架构设计中的&amp;quot;合并部分 Mixer 功能&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://skyao.io/post/201804-servicemesh-architecture-introspection/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh 架构反思：数据平面和控制平面的界线该如何划定？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://skyao.io/post/201804-istio-achilles-heel/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mixer Cache: Istio 的阿克琉斯之踵？&lt;/a&gt;：系列文章，有两篇&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://skyao.io/post/201804-istio-mixer-cache-concepts/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Mixer Cache 工作原理与源码分析&lt;/a&gt;: 系列文章，有四篇&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前 Mixer v2 的规划还处于 Review 状态，实现方式尚未有明确决定。如果要合并 Mixer，考虑到目前 Mixer 是基于 Golang 编写，而 Envoy 是基于 c++ ，这意味着需要用 c++重写所有的 Adapter，工作量巨大，恐怕不是短期之内能够完成的。当然也有另外一个新颖（或者说脑洞大开）的思路：引入 Web Assembly（WASM）。目前 Envoy 在进行支持 Web Assembly 的尝试，如果成功，则通过 Web Assembly 的方式来支持 Mixer Adapter 不失为一个好选择。&lt;/p&gt;
&lt;h3 id=&#34;其他社区产品动态&#34;&gt;其他社区产品动态&lt;/h3&gt;
&lt;p&gt;最近，CNCF 在筹建 Universal Data Plane API（UDPA/通用数据平面 API）工作组，以制定数据平面的标准 API，为 L4/L7 数据平面配置提供事实上的标准。Universal Data Plane API 的创意来自 Envoy，实现为 xDS API。而目前 xDS v2 API 已经是数据平面 API 的事实标准，这次的 UDPA 会以 xDS v2 API 为基础。工作组的初始成员来自包括 Envoy 和 gRPC 项目的代表，蚂蚁金服也在积极参与 UDPA 工作组，目前还处于非常早期的筹备阶段。&lt;/p&gt;
&lt;p&gt;Linkerd2 在 2019 年 4 月 17 日发布了最新的稳定版本 Linkerd 2.3 版本。Linkerd2 是目前开源产品中唯一正面对抗 Istio 的存在，不过在国内知名度不高，使用者也很少。比较有意思的是，开发 Linkerd2 的初创公司 Buoyant 最近的 B 轮融资来自 Google 的投资部门。&lt;/p&gt;
&lt;h3 id=&#34;云厂商的产品动态&#34;&gt;云厂商的产品动态&lt;/h3&gt;
&lt;p&gt;随着 Service Mesh 技术的发展，和各方对 Service Mesh 前景的看好，各大主流云提供商都开始在 Service Mesh 技术上发力。&lt;/p&gt;
&lt;p&gt;首先看 AWS，在 2019 年 4 月，AWS 宣布 App Mesh GA。App Mesh 是 AWS 推出的 AWS 原生服务网格，与 AWS 完全集成，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络（AWS cloud map）&lt;/li&gt;
&lt;li&gt;计算（Amazon EC2 和 AWS Fargate）&lt;/li&gt;
&lt;li&gt;编排工具（AWS EKS，Amazon ECS 和 EC2 上客户管理的 k8s）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/appmesh_hu0df9f5e4cbef644aa754ce7a02eca3ca_111065_8f61f99af4a7196100bc35820df8aa8d.webp 400w,
               /blog/201905-servicemesh-development-trend/appmesh_hu0df9f5e4cbef644aa754ce7a02eca3ca_111065_b89589c4721f177139e69dcfc54777cd.webp 760w,
               /blog/201905-servicemesh-development-trend/appmesh_hu0df9f5e4cbef644aa754ce7a02eca3ca_111065_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/appmesh_hu0df9f5e4cbef644aa754ce7a02eca3ca_111065_8f61f99af4a7196100bc35820df8aa8d.webp&#34;
               width=&#34;760&#34;
               height=&#34;415&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;App Mesh 的数据平面采用 Envoy，产品非常有创意的同时支持 VM 和容器，支持多种产品形态，如上图所示。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AWS App Mesh 的更多详细内容，请浏览文章 &lt;a href=&#34;https://skyao.io/post/201904-aws-app-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;用 AWS App Mesh 重新定义应用通讯&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Google 的打法则是围绕 Istio。首先是在 2018 年底推出了 Istio on GKE，即&amp;quot;一键集成 Istio&amp;quot;，并提供遥测、日志、负载均衡、路由和 mTLS 安全能力。接着 Google 又推出 Google Cloud Service Mesh，这是 Istio 的完全托管版本，不仅仅提供 Istio 开源版本的完整特性，还集成了 Google Cloud 上的重要产品 Stackdriver。&lt;/p&gt;
&lt;p&gt;近期，Google 推出 Traffic Director 的 beta 测试版本，Traffic Director 是完全托管的服务网格流量控制平面，支持全局负载均衡，适用于虚拟机和容器，提供混合云和多云支持、集中式健康检查和流量控制，还有一个非常特别的特性：支持基于流量的自动伸缩。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/google-traffic-director_hu411ea5eab09c6df87b9d10a7e2aee0d9_388294_d1046a6ed94bcf2f2c76511175189740.webp 400w,
               /blog/201905-servicemesh-development-trend/google-traffic-director_hu411ea5eab09c6df87b9d10a7e2aee0d9_388294_251f271925435eb1e08a5aec89e5e3a6.webp 760w,
               /blog/201905-servicemesh-development-trend/google-traffic-director_hu411ea5eab09c6df87b9d10a7e2aee0d9_388294_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/google-traffic-director_hu411ea5eab09c6df87b9d10a7e2aee0d9_388294_d1046a6ed94bcf2f2c76511175189740.webp&#34;
               width=&#34;760&#34;
               height=&#34;372&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Google Traffic Director 的详细介绍，请查看我之前的博客文章 &lt;a href=&#34;https://skyao.io/post/201905-google-traffic-director-detail/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Traffic Director 详细介绍&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;微软则推出了 Service Fabric Mesh。Azure Service Fabric 是 Microsoft 的微服务框架，设计用于公共云，内部部署以及混合和多云架构。而 Service Fabric Mesh 是 Azure 完全托管的产品，在 2018 年 8 月推出预览版。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/service-fabric-mesh_hu97f69ebe86cd6cdea030ee80bbc07d17_798359_347a0f7365824849ade6519fca3646d1.webp 400w,
               /blog/201905-servicemesh-development-trend/service-fabric-mesh_hu97f69ebe86cd6cdea030ee80bbc07d17_798359_ca714457b5a8f814656fe5aeaaa47277.webp 760w,
               /blog/201905-servicemesh-development-trend/service-fabric-mesh_hu97f69ebe86cd6cdea030ee80bbc07d17_798359_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/service-fabric-mesh_hu97f69ebe86cd6cdea030ee80bbc07d17_798359_347a0f7365824849ade6519fca3646d1.webp&#34;
               width=&#34;760&#34;
               height=&#34;451&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上周（5 月 21 号）最新消息，微软在 kubeconf 上推出 Service Mesh Interface。SMI 是在 Kubernetes 上运行服务网格的规范，定义了由各种供应商实现的通用标准，使得最终用户的标准化和服务网格供应商的创新可以两全其美，SMI 预期将为 Service Mesh 带来了灵活性和互通性。&lt;/p&gt;
&lt;p&gt;SMI 是一个开放项目，由微软，Linkerd，HashiCorp，Solo，Kinvolk 和 Weaveworks 联合启动; 并得到了 Aspen Mesh，Canonical，Docker，Pivotal，Rancher，Red Hat 和 VMware 的支持。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/smi_hu5a405490fb92ca861965be03b3c4cc37_601218_534e06de4a581f2b70b9ea8a6a2fb404.webp 400w,
               /blog/201905-servicemesh-development-trend/smi_hu5a405490fb92ca861965be03b3c4cc37_601218_9c223269cb3e943cc2ebda1023989a9d.webp 760w,
               /blog/201905-servicemesh-development-trend/smi_hu5a405490fb92ca861965be03b3c4cc37_601218_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/smi_hu5a405490fb92ca861965be03b3c4cc37_601218_534e06de4a581f2b70b9ea8a6a2fb404.webp&#34;
               width=&#34;760&#34;
               height=&#34;400&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-发展趋势&#34;&gt;Service Mesh 发展趋势&lt;/h2&gt;
&lt;p&gt;在分享完最近半年 Service Mesh 产品的动态之后，我们来分析探讨 Service Mesh 的发展趋势。&lt;/p&gt;
&lt;h3 id=&#34;趋势-1上云--托管&#34;&gt;趋势 1：上云 + 托管&lt;/h3&gt;
&lt;p&gt;在微服务/容器这些年的发展历程中，我们会发现一个很有意思（甚至有些哭笑不得）的现象：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/trend1_hud0fd2f7da1445e6476ac6fdf5919fad1_80244_afd1792aa2e0d8094755ba79eb3557bf.webp 400w,
               /blog/201905-servicemesh-development-trend/trend1_hud0fd2f7da1445e6476ac6fdf5919fad1_80244_0914c99870eaadfc0af905b70b452315.webp 760w,
               /blog/201905-servicemesh-development-trend/trend1_hud0fd2f7da1445e6476ac6fdf5919fad1_80244_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/trend1_hud0fd2f7da1445e6476ac6fdf5919fad1_80244_afd1792aa2e0d8094755ba79eb3557bf.webp&#34;
               width=&#34;760&#34;
               height=&#34;308&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了解决单体的复杂度问题，我们引入微服务架构&lt;/li&gt;
&lt;li&gt;为了解决微服务架构下大量应用部署的问题，我们引入容器&lt;/li&gt;
&lt;li&gt;为了解决容器的管理和调度问题，我们引入 kubernetes&lt;/li&gt;
&lt;li&gt;为了解决微服务框架的侵入性问题，我们引入 Service Mesh&lt;/li&gt;
&lt;li&gt;为了让 Service Mesh 有更好的底层支撑，我们又将 Service Mesh 运行在 k8s 上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个过程中，从单个应用（或者微服务）的角度看，的确自身的复杂度降低，在有底层系统支撑的情况下部署/维护/管理/控制/监控等也都大为简化。但是站在整个系统的角度，整体复杂度并没有消失，只是从单体分解到微服务，从应用下沉到 Service Mesh，复杂度从总量上不但没有减少，反而大为增加。&lt;/p&gt;
&lt;p&gt;解决这个问题最好的方式就是 &lt;strong&gt;上云&lt;/strong&gt;，使用 &lt;strong&gt;托管&lt;/strong&gt; 版本的 k8s 和 Service Mesh，从而将底层系统的复杂度交给云厂商，而客户只需要在云的基础上享受 Service Mesh 技术带来的使用便利和强大功能。&lt;/p&gt;
&lt;p&gt;前面我们分享产品动态时，可以看到目前 Google / AWS / 微软 这三巨头都已经推出了各自的 Service Mesh 托管产品，而在国内，阿里云/华为云等也有类似的产品推出，我们蚂蚁金服也将在稍后在金融云上推出 SOFAMesh 的云上托管版本。在这里，我总结为一句话：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;几乎所有的主要公有云提供商都在提供（或者准备提供）Service Mesh 托管方案&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;趋势-2vm-和容器混用&#34;&gt;趋势 2：VM 和容器混用&lt;/h3&gt;
&lt;p&gt;第二个趋势就是 VM 和容器混用，即 Service Mesh 对服务的运行环境的支持，不仅支持容器（尤其指 k8s），也支持虚拟机，而且支持运行在这两个环境下的服务相互访问，甚至直接在产品层面上屏蔽两者的差异。&lt;/p&gt;
&lt;p&gt;比如 Google 的 Traffic Director 产品：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/google-traffic-director_hu411ea5eab09c6df87b9d10a7e2aee0d9_388294_d1046a6ed94bcf2f2c76511175189740.webp 400w,
               /blog/201905-servicemesh-development-trend/google-traffic-director_hu411ea5eab09c6df87b9d10a7e2aee0d9_388294_251f271925435eb1e08a5aec89e5e3a6.webp 760w,
               /blog/201905-servicemesh-development-trend/google-traffic-director_hu411ea5eab09c6df87b9d10a7e2aee0d9_388294_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/google-traffic-director_hu411ea5eab09c6df87b9d10a7e2aee0d9_388294_d1046a6ed94bcf2f2c76511175189740.webp&#34;
               width=&#34;760&#34;
               height=&#34;372&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;AWS 的 App Mesh 产品：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/appmesh_hu0df9f5e4cbef644aa754ce7a02eca3ca_111065_8f61f99af4a7196100bc35820df8aa8d.webp 400w,
               /blog/201905-servicemesh-development-trend/appmesh_hu0df9f5e4cbef644aa754ce7a02eca3ca_111065_b89589c4721f177139e69dcfc54777cd.webp 760w,
               /blog/201905-servicemesh-development-trend/appmesh_hu0df9f5e4cbef644aa754ce7a02eca3ca_111065_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/appmesh_hu0df9f5e4cbef644aa754ce7a02eca3ca_111065_8f61f99af4a7196100bc35820df8aa8d.webp&#34;
               width=&#34;760&#34;
               height=&#34;415&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;都是在产品层面直接提供 VM 和容器混用的支持，不管应用是运行在 vm 上还是容器内都可以支持，而且可以方便的迁移。&lt;/p&gt;
&lt;h3 id=&#34;趋势-3混合云和多云支持&#34;&gt;趋势 3：混合云和多云支持&lt;/h3&gt;
&lt;p&gt;混合云和多云支持最近正成为一个新的技术热点和商业模式，甚至 Google Cloud 都喊出口号，要 &amp;ldquo;All in Hybrid Cloud&amp;rdquo;！&lt;/p&gt;
&lt;p&gt;Google Traffic Director 旗帜鲜明的表达了 Google Cloud 对混合云的重视：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/google-traffic-director-hybird_hu8bfb19ae223fbcbf0029ef2e24d8b8dd_345448_f04d379be0231c4d36b7e74867e2b066.webp 400w,
               /blog/201905-servicemesh-development-trend/google-traffic-director-hybird_hu8bfb19ae223fbcbf0029ef2e24d8b8dd_345448_7b871a1a57eac5f4213a4525445b37ce.webp 760w,
               /blog/201905-servicemesh-development-trend/google-traffic-director-hybird_hu8bfb19ae223fbcbf0029ef2e24d8b8dd_345448_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/google-traffic-director-hybird_hu8bfb19ae223fbcbf0029ef2e24d8b8dd_345448_f04d379be0231c4d36b7e74867e2b066.webp&#34;
               width=&#34;760&#34;
               height=&#34;303&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;下图是 Google Traffic Director  给出的一个应用改造示例：从单体结构转为微服务架构，从私有云转为公有云加私有云的混合云模式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/google-traffic-director-hybird2_hu1663fe30fb3cfb908e301bd3dcb1373b_368093_d3eb460940f2d4a415e46a6799fb3122.webp 400w,
               /blog/201905-servicemesh-development-trend/google-traffic-director-hybird2_hu1663fe30fb3cfb908e301bd3dcb1373b_368093_eab07ce8ecd255c4551eca354423dfd2.webp 760w,
               /blog/201905-servicemesh-development-trend/google-traffic-director-hybird2_hu1663fe30fb3cfb908e301bd3dcb1373b_368093_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/google-traffic-director-hybird2_hu1663fe30fb3cfb908e301bd3dcb1373b_368093_d3eb460940f2d4a415e46a6799fb3122.webp&#34;
               width=&#34;760&#34;
               height=&#34;352&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Service Mesh 毫无疑问是实现上述转型并提供混合云和多云支持的一个非常理想的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;趋势-4和-serverless-的结合&#34;&gt;趋势 4：和 Serverless 的结合&lt;/h3&gt;
&lt;p&gt;Service Mesh 技术和 Serverless 技术是工作在不同纬度的两个技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Mesh 技术的关注点在于&lt;strong&gt;服务间通讯&lt;/strong&gt;，其目标是剥离客户端 SDK，为应用减负，提供的能力主要包括安全性、路由、策略执行、流量管理等。&lt;/li&gt;
&lt;li&gt;Serverless 技术的关注点在于&lt;strong&gt;服务运维&lt;/strong&gt;，目标是客户无需关注服务运维，提供服务实例的自动伸缩，以及按照实际使用付费。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理论上 Service Mesh 技术和 Serverless 技术并没有冲突的地方，可以结合使用。事实上目前业界也开始出现这个趋势，而融合的方式有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Serverless 中引入 Servicemesh：典型如 knative 项目和 knative 的 Google Cloud 托管版本 Google Cloud Run，通过引入对容器的支持和使用 Istio，knative 将 Serverless 的支持扩展到 Function 之外，在极大的扩展 Serverless 适用范围的前提下，也将服务间通讯的能力引入到 Serverless。&lt;/li&gt;
&lt;li&gt;在 Servicemesh 中引入 Serverless：典型如 Google Traffic Director 产品，在提供 Service Mesh 各种能力的同时，支持按照流量自动伸缩服务的实例数量，从而融入了部分 serverless 的特性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于 Serverless 和 Servicemesh 的结合，我们来展望未来形态：未来应该会出现一种新型服务模式，Serverless 和 Servicemesh 合二为一。只要将服务部署上来，就自动可以得到 Servicemesh 的服务间通讯能力和 Serverless 的无服务器运维。在蚂蚁金服，我们将这理解成为是未来云原生应用的终态之一，正在积极的探索其落地的实际方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/servicemesh-serverless_hu65e26f5661ab72408919ba911998fff8_42233_516cba5a24b4588c98b765917b472ba4.webp 400w,
               /blog/201905-servicemesh-development-trend/servicemesh-serverless_hu65e26f5661ab72408919ba911998fff8_42233_026ecec2f78c69ce7b8434d2e96ffa43.webp 760w,
               /blog/201905-servicemesh-development-trend/servicemesh-serverless_hu65e26f5661ab72408919ba911998fff8_42233_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/servicemesh-serverless_hu65e26f5661ab72408919ba911998fff8_42233_516cba5a24b4588c98b765917b472ba4.webp&#34;
               width=&#34;400&#34;
               height=&#34;300&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;趋势-5mesh-模式延伸&#34;&gt;趋势 5：Mesh 模式延伸&lt;/h3&gt;
&lt;p&gt;回顾一下 Service Mesh 模式的核心，其基本原理在于将客户端 SDK 剥离，以 Proxy 独立进程运行；目标是将原来存在于 SDK 中的各种能力下沉，为应用减负，以帮助应用云原生化。&lt;/p&gt;
&lt;p&gt;遵循这个思路，将 Service Mesh 的应用场景泛化，不局限于服务间的同步通信，就可以推广到更多的场景：特征是有网络访问，而是通过客户端 SDK 来实现。&lt;/p&gt;
&lt;p&gt;在蚂蚁金服的实践中，我们发现 Mesh 模式不仅仅适用于服务间同步通讯，也可以延伸到以下场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Database Mesh: 数据库访问&lt;/li&gt;
&lt;li&gt;Message Mesh：消息机制&lt;/li&gt;
&lt;li&gt;Cache Mesh：缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上模式的产品蚂蚁金服都在探索中，相关的产品正在开发和尝试落地。社区也有一些相关的产品，比如 Database Mesh 方面张亮同学在力推的  &lt;a href=&#34;https://shardingsphere.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache Shardingsphere&lt;/a&gt; 项目。&lt;/p&gt;
&lt;p&gt;通过更多的 Mesh 模式，我们可以覆盖更多的场景，从而实现让应用在各个方面都做到减负，而不仅仅是 Service Mesh 对应的服务间通讯，从而为后续的应用云原生化奠定基础。&lt;/p&gt;
&lt;h3 id=&#34;趋势-6标准化不锁定&#34;&gt;趋势 6：标准化，不锁定&lt;/h3&gt;
&lt;p&gt;云原生的一个重要主张，就是希望在云上为用户提供一致的用户体验，提倡标准化，避免供应商绑定（Not Lock-In）。&lt;/p&gt;
&lt;p&gt;从前面分享的 Service Mesh 产品动态可以看出，目前 Service Mesh 市场上出现了众多的供应商和产品：开源的，闭源的，大公司出的，小公司出的，市场繁荣的同时也带来了市场碎片化的问题——所有围绕业务应用的外围工作，比如通过 Service Mesh 对流量进行控制，配置各种安全/监控/策略等行为，以及在这些需求上建立起来的工具和生态系统，却不得不牢牢的绑死在某个具体的 Service Mesh 实现上，所谓”供应商锁定”。其根本问题在于各家实现不同，又没有统一标准。因此，要想解决上述问题，就必须釜底抽薪：&lt;strong&gt;解决 Service Mesh 的标准化问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;就在最近这一个月，Service Mesh 社区出现了两个推动标准化的大事件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CNCF 筹建 Universal Data Plane API（通用数据平面 API）工作组，计划以 xDS v2 API 为基础制定数据平面的标准 API，工作组的初始成员来自包括 Envoy 和 gRPC 项目的代表（可以理解为 Google 为首）&lt;/li&gt;
&lt;li&gt;微软在 kubeconf 上推出 Service Mesh Interface，准备定义在 Kubernetes 上运行服务网格的规范，为 Service Mesh 带来了灵活性和互通性。SMI 由微软牵头，联合 Linkerd，HashiCorp，Solo，Kinvolk 和 Weaveworks。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了方便理解这两个标准，我为大家准备了一张图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/trend6_hud4c24fcecdf2530ebecfff4a28e87244_7565_d1dd5c6065a87a92601c1a126084da12.webp 400w,
               /blog/201905-servicemesh-development-trend/trend6_hud4c24fcecdf2530ebecfff4a28e87244_7565_ef76c93e61c96a47d3a8930affc93d09.webp 760w,
               /blog/201905-servicemesh-development-trend/trend6_hud4c24fcecdf2530ebecfff4a28e87244_7565_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/trend6_hud4c24fcecdf2530ebecfff4a28e87244_7565_d1dd5c6065a87a92601c1a126084da12.webp&#34;
               width=&#34;600&#34;
               height=&#34;546&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其中，Universal Data Plane API 是数据平面的标准，控制平面通过这个 API 来控制数据平面的行为。而 Service Mesh Interface 是控制平面的标准，上层的应用/工具/生态体系通过 Service Mesh Interface 来实现跨不同的 Service Mesh 实现为最终用户提供一致性的体验。&lt;/p&gt;
&lt;p&gt;当然这两个标准化 API 都刚刚起步，而且，标准化的工作通常不仅仅是技术问题，涉及到复杂的利益关系，具体未来走向现在难于推断，只能密切关注。&lt;/p&gt;
&lt;h3 id=&#34;发展趋势分析&#34;&gt;发展趋势分析&lt;/h3&gt;
&lt;p&gt;我们总结一下上面列出的 Service Mesh 最近的 6 个发展趋势：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/trend-analysis_hua2f1357e141ac05f0d34180e0ef1f927_88094_ec52e75852a33bf1b9a3a5e12ec14839.webp 400w,
               /blog/201905-servicemesh-development-trend/trend-analysis_hua2f1357e141ac05f0d34180e0ef1f927_88094_33dc69717925aaaf0fe4c762fc0e21ba.webp 760w,
               /blog/201905-servicemesh-development-trend/trend-analysis_hua2f1357e141ac05f0d34180e0ef1f927_88094_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/trend-analysis_hua2f1357e141ac05f0d34180e0ef1f927_88094_ec52e75852a33bf1b9a3a5e12ec14839.webp&#34;
               width=&#34;760&#34;
               height=&#34;373&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些趋势都和云有关，核心在于让云来提供能力，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让云承担更多职责&lt;/li&gt;
&lt;li&gt;提供更高抽象&lt;/li&gt;
&lt;li&gt;适用更多场景&lt;/li&gt;
&lt;li&gt;减少应用负担：实现应用轻量化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终实现让业务应用&lt;strong&gt;专注业务&lt;/strong&gt;的战略目标。&lt;/p&gt;
&lt;p&gt;对于 Service Mesh 技术未来的走向，我的看法是：Service Mesh 技术必然不是孤立的自行发展，而是在云原生的大环境下，与云原生的其他技术、理念、最佳实践一起相互影响、相互促进、相互支撑、共同发展。云原生是一个庞大的技术体系，Service Mesh 需要在这个体系中获得各种支撑和配合，才能最大限度的发挥自身的优势。&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-与云原生&#34;&gt;Service Mesh 与云原生&lt;/h2&gt;
&lt;p&gt;在最后一段，我们来谈谈 Service Mesh 技术和云原生的关系，也就是本次分享的标题所说的：云原生中流砥柱。&lt;/p&gt;
&lt;p&gt;凭什么？&lt;/p&gt;
&lt;h3 id=&#34;什么是云原生&#34;&gt;什么是云原生？&lt;/h3&gt;
&lt;p&gt;在解释之前，首先问一个问题：什么是云原生？相信这个问题很多同学都问过，或者被问过，每个人心里可能都有自己的理解和表述。在今年年初，我也特意就这个问题问了自己，然后尝试着给出了一个我的答案：&lt;/p&gt;
&lt;p&gt;云原生指 &amp;ldquo;原生为云设计&amp;rdquo;，具体说就是：&lt;strong&gt;应用原生被设计为在云上以最佳方式运行，充分发挥云的优势。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/cloud-native_hue2e9e3d4df0220da50e66a7ece783649_138340_a1e2de9c50c1d3f98e1684aa76116366.webp 400w,
               /blog/201905-servicemesh-development-trend/cloud-native_hue2e9e3d4df0220da50e66a7ece783649_138340_8785d5565f9560a466e0d619f8eba659.webp 760w,
               /blog/201905-servicemesh-development-trend/cloud-native_hue2e9e3d4df0220da50e66a7ece783649_138340_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/cloud-native_hue2e9e3d4df0220da50e66a7ece783649_138340_a1e2de9c50c1d3f98e1684aa76116366.webp&#34;
               width=&#34;600&#34;
               height=&#34;450&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;关于云原生的理解，以及对这句话的详细阐述，这里不详细展开，有兴趣的同学可以浏览我之前的演讲内容，讲的比较深入，厚颜自荐一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://skyao.io/talk/201902-cloudnative-freely-talk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;畅谈云原生（上）&lt;/a&gt;: 如何理解云原生？云原生应用应该是什么样子？云原生下的中间件该如何发展？&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://skyao.io/talk/201902-cloudnative-freely-talk2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;畅谈云原生（下）&lt;/a&gt;: 云和应用该如何衔接？如何让产品更符合云原生？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;service-mesh-的核心价值&#34;&gt;Service Mesh 的核心价值&lt;/h3&gt;
&lt;p&gt;关于 Service Mesh 的核心价值，我个人的理解，不在于 Service Mesh 提供的玲琅满目的各种功能和特性，而是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现业务逻辑和非业务逻辑的分离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将非业务逻辑的功能实现，从客户端 SDK 中剥离出来，放到独立的 Proxy 进程中，这是 Service Mesh 在技术实现上走出的第一步，也是至关重要的第一步：因为这一步，实现了&lt;strong&gt;业务逻辑&lt;/strong&gt;和&lt;strong&gt;非业务逻辑&lt;/strong&gt;的分离，而且是最彻底的物理分离，哪怕需要为此付出一次远程调用的代价。&lt;/p&gt;
&lt;p&gt;而这一步迈出之后，前面就是海阔天空：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务逻辑和非业务逻辑分离之后，我们就可以将这些非业务逻辑继续下沉&lt;/li&gt;
&lt;li&gt;下沉到基础设施，基础设施可以是基于 VM 的，可以是基于容器和 k8s 的；也可以是 VM 和容器混合&lt;/li&gt;
&lt;li&gt;基础设施也可以以云的形式提供，可以是公有云、私有云，也可以是混合云、多云；&lt;/li&gt;
&lt;li&gt;可以选择云上托管，完全托管也好，部分托管也好，产品形态可以很灵活&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结说，业务逻辑和非业务逻辑的分离：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为下沉到基础设施提供可能&lt;/li&gt;
&lt;li&gt;为上云提供可能&lt;/li&gt;
&lt;li&gt;为应用轻量化提供可能&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：这里说的上云，指的是上云原生 (Cloud Native) 的云，而不是上云就绪 (Cloud Ready) 的云。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;mesh-化是云原生落地的关键步骤&#34;&gt;Mesh 化是云原生落地的关键步骤&lt;/h3&gt;
&lt;p&gt;在过去一年中，蚂蚁金服一直在努力探索云原生落地的方式，在这个过程中，我们有一些感悟，其中非常重要的一条就是：Mesh 化是云原生落地的关键步骤。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/cloud-native-important-step_hu4b3bf49a7f90821cbecdaabfda8d805a_136978_d1c5d076a18e09a08fb324eed6dfa784.webp 400w,
               /blog/201905-servicemesh-development-trend/cloud-native-important-step_hu4b3bf49a7f90821cbecdaabfda8d805a_136978_a6f548de59e63a2fe8cae958699cba5b.webp 760w,
               /blog/201905-servicemesh-development-trend/cloud-native-important-step_hu4b3bf49a7f90821cbecdaabfda8d805a_136978_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/cloud-native-important-step_hu4b3bf49a7f90821cbecdaabfda8d805a_136978_d1c5d076a18e09a08fb324eed6dfa784.webp&#34;
               width=&#34;760&#34;
               height=&#34;308&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最下方是云，基于 k8s 和容器打造，提供各种基础能力，这些能力有一部分来自传统中间件的下沉&lt;/li&gt;
&lt;li&gt;在云上是 Mesh 层，包含 Service Mesh 以及我们前面提到的各种扩展的 Mesh 模式，实现通信的标准化&lt;/li&gt;
&lt;li&gt;在通过 Mesh 剥离非业务功能并下沉之后，应用实现了轻量化，传统的 App 和新兴的微服务都可以受益于此&lt;/li&gt;
&lt;li&gt;更进一步，轻量化之后的业务应用，其工作负载在瘦身减负之后变得相当的干净，基本只剩业务逻辑，包括传统的 App，以 Container 形式运行的服务和新颖的 Function，这些负载在往 Serverless 形态转换时相对要轻松很多&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配合 Serverless 技术领域最新的技术潮流和产品发展（如以 knative 项目为代表，Serverless 不再仅仅是 Function 形式，也支持 BaaS 等偏传统的工作负载），Mesh 化为现有应用转型为 Serverless 模式提供助力。&lt;/p&gt;
&lt;p&gt;在这里我们再分享一下蚂蚁金服对未来中间件产品发展的感悟，我们认为中间件的未来在于&lt;strong&gt;Mesh 化，并融入基础设施&lt;/strong&gt;，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/middleware-future_hu789abcbda2cb0d844534f19dd3cd292c_166074_62a0132da6e6b3b96797f61d802b7118.webp 400w,
               /blog/201905-servicemesh-development-trend/middleware-future_hu789abcbda2cb0d844534f19dd3cd292c_166074_3e6a0f848e1d97d48e5003dbebc06d85.webp 760w,
               /blog/201905-servicemesh-development-trend/middleware-future_hu789abcbda2cb0d844534f19dd3cd292c_166074_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/middleware-future_hu789abcbda2cb0d844534f19dd3cd292c_166074_62a0132da6e6b3b96797f61d802b7118.webp&#34;
               width=&#34;760&#34;
               height=&#34;314&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;左边是传统的中间件形态，在云原生时代，我们希望将非业务功能从传统中间件的富客户端中剥离出来，然后将这些能力以及这些能力背后的中间件能力，下沉到基础设施，下沉到云。而中间件产品也会融入基础设施，如图中右边所示。未来的中间件将作为基础设施和云的一部分，而 Mesh 则成为连接应用和基础设施以及其他中间件产品的桥梁。&lt;/p&gt;
&lt;p&gt;更重要的是：业务应用因此而实现轻量化，在剥离各种非业务功能之后，业务应用就实现了只关注业务逻辑的战略目标，从而实现从传统应用到云原生应用的转型。&lt;/p&gt;
&lt;p&gt;总结：通过 Service Mesh 技术，我们实现了业务逻辑和非业务逻辑的分离，为应用的轻量化和云原生化提供可能；并通过将非业务逻辑的各种功能下沉到基础设施和云，极大的增强了基础设施和云的能力，为云原生的落地提供了极大助力。&lt;/p&gt;
&lt;p&gt;因此，我们认为：Service Mesh 技术将在云原生落地中扮演了非常重要的作用，不可或缺。&lt;/p&gt;
&lt;h3 id=&#34;service-mesh-发展展望&#34;&gt;Service Mesh 发展展望&lt;/h3&gt;
&lt;p&gt;最后再次展望一下 Service Mesh 的未来发展。&lt;/p&gt;
&lt;p&gt;左边是 Service Mesh 发展初期的最重要的两个原始动力：&lt;strong&gt;多语言支持&lt;/strong&gt;和&lt;strong&gt;类库升级&lt;/strong&gt;。关于这两点，最近这两年中介绍和推广 Service Mesh 理念和产品的同学基本都讲过，但是今天我想指出的是：这只是 Service Mesh 的&lt;strong&gt;起点&lt;/strong&gt;，而远不是 Service Mesh 的终点。&lt;/p&gt;
&lt;p&gt;Service Mesh 的未来，不会停留在仅仅满足多语言支持和类库升级，而是跟随云原生的大潮，解决各种实际需求，同时又尽量维持上层业务应用的简单直白。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/201905-servicemesh-development-trend/future-of-servicemesh_hu05674298bc66f5c52a7cd9569a417e34_207018_27ae6db1ae65448a50164606e249a41d.webp 400w,
               /blog/201905-servicemesh-development-trend/future-of-servicemesh_hu05674298bc66f5c52a7cd9569a417e34_207018_6092acc8c906834a1f8de0c7c6119651.webp 760w,
               /blog/201905-servicemesh-development-trend/future-of-servicemesh_hu05674298bc66f5c52a7cd9569a417e34_207018_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/201905-servicemesh-development-trend/future-of-servicemesh_hu05674298bc66f5c52a7cd9569a417e34_207018_27ae6db1ae65448a50164606e249a41d.webp&#34;
               width=&#34;760&#34;
               height=&#34;363&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这次分享的最后，我想给大家一个留一个课外作业，有心的同学可以尝试一下：如果您想更深入的理解 Service Mesh 的价值，想对 Service Mesh 未来的发展方向有更清晰的认识，尤其是希望能通过自身的思考和感悟来理解 Service Mesh 而不是简单的被灌输（包括被我灌输），那么请尝试独立的做如下思考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;抛开左边的这两点，不要将思维局限在这个范围内&lt;/li&gt;
&lt;li&gt;考虑云原生的大背景，结合您自身对云原生的理解，和对云的期望&lt;/li&gt;
&lt;li&gt;针对右边的 Service Mesh 的六个趋势，忘记我前面讲述的内容，只考虑其背后的实际场景和客户需求，以及这个场景带来的业务价值，然后认真对比使用 Service Mesh 和不使用 Service Mesh 两种情况下的解决方案&lt;/li&gt;
&lt;li&gt;请在上述思考的过程中，更多的从业务应用的角度来看待问题，假设你是那个云上的应用（还记得前面图上的小 baby 吗？），你会希望被如何对待&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;希望这样的思考能让您有所收获。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google Cloud Run 详细介绍</title>
      <link>https://cloudnative.to/blog/google-cloud-run-intro/</link>
      <pubDate>Mon, 13 May 2019 12:20:46 +0800</pubDate>
      <guid>https://cloudnative.to/blog/google-cloud-run-intro/</guid>
      <description>&lt;p&gt;在 Cloud Next 2019 大会上，Google 宣布了 Cloud Run，这是一个新的基于容器运行 Serverless 应用的解决方案。Cloud Run 基于开源的 knative 项目，宣称要将 serverless 带入容器世界。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cloud-run-介绍&#34;&gt;Cloud Run 介绍&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/28a4d1a9808e275623bbbc81ee19b298.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在旧金山举办的 Google Cloud Next 2019 大会上，Google 宣布了 Cloud Run，这是一个新的基于容器运行 Serverless 应用的解决方案。Cloud Run 基于开源的 knative 项目，是 knative 的 Google Cloud 托管版本，也是业界第一个基于 Knative + Kubernetes 的 Serverless 托管服务。&lt;/p&gt;
&lt;p&gt;援引来自 Google Cloud 官方网站的介绍资料，对 Cloud Run 的定位是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Run stateless HTTP containers on a fully managed environment or in your own GKE cluster.&lt;/p&gt;
&lt;p&gt;在完全托管的环境或者自己的 GKE 集群中运行 serverless HTTP 容器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前 Google Cloud 还处于测试阶段，尚未 GA，而且暂时只在美国地区提供。&lt;/p&gt;
&lt;h2 id=&#34;cloud-run-推出的背景&#34;&gt;Cloud Run 推出的背景&lt;/h2&gt;
&lt;p&gt;这里有一个大的背景：在 knative 出来之前，serverless 市场虽然火热，但是有一个根本性的问题，就是市场碎片化极其严重，有大大小小几十个产品和开源项目，而且存在严重的供应商绑定风险。因此，Google 牵头推出了 knative 开源项目，希望实现 serverless 的标准化和规范化。&lt;/p&gt;
&lt;p&gt;关于 knative 的详细情况，这里不继续展开，有兴趣的同学可以阅读我之前的演讲分享 &lt;a href=&#34;https://www.atatech.org/articles/128783&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative: 重新定义 Serverless&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;google-cloud-上的-serverless&#34;&gt;Google Cloud 上的 Serverless&lt;/h3&gt;
&lt;p&gt;在 Cloud Run 出现之后，目前 Google Cloud 上就有三种 Serverless 产品了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cloud Functions: 事件驱动的 serverless 计算平台&lt;/li&gt;
&lt;li&gt;App Engine: 高可扩展的 serverless web 应用&lt;/li&gt;
&lt;li&gt;Cloud Run: 无状态的 serverless HTTP 容器，口号是 &lt;strong&gt;Bringing Serverless to Containers&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/a254a5969d0da9b36796483cf73c3dbb.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-serverless-computer-on-google-cloudpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/a254a5969d0da9b36796483cf73c3dbb.png&#34; alt=&#34;serverless-computer-on-google-cloud.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      serverless-computer-on-google-cloud.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;bring-serverless-to-containers&#34;&gt;Bring Serverless to Containers&lt;/h3&gt;
&lt;p&gt;这是 Cloud Run/knative 区别于之前的各种 serverless 产品的本质不同之处：支持的工作负载不再局限于 Function，而是任意容器！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：当然基本的容器运行时契约还是要遵守的，具体要求见下面的介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和 Function 相比，以 container 方式呈现的工作负载，给使用者更大的自由度，Google Cloud 对此给出的口号是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Any langurage / 不限语言&lt;/li&gt;
&lt;li&gt;Any library / 不限类库&lt;/li&gt;
&lt;li&gt;Any binary 不限二进制文件（备注：格式还是要限制的，要求 Linux x86_64 ABI 格式）&lt;/li&gt;
&lt;li&gt;Ecosystem of base images / 基础镜像的生态系统&lt;/li&gt;
&lt;li&gt;Industry standard/工业标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/f5e1d702207d1b633cb7482408ef7661.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-bring-serverless-to-containerpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/f5e1d702207d1b633cb7482408ef7661.png&#34; alt=&#34;bring-serverless-to-container.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      bring-serverless-to-container.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google Cloud Run / Knative 对容器的要求，和通用容器相比，强调 &lt;strong&gt;无状态（Stateless）&lt;/strong&gt; / &lt;strong&gt;请求驱动（request-triggered）&lt;/strong&gt; / &lt;strong&gt;可自动伸缩（autoscaled）&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/f95df42e15c178258391a2a74cb51b0b.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-workload-containerpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/f95df42e15c178258391a2a74cb51b0b.png&#34; alt=&#34;workload-container.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      workload-container.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，请求流量通常并非均匀分布，有突发高峰，有长期低谷，甚至有时没有流量。因此，从资源使用率的角度考虑，处理这些请求流量的服务容器的实例也应该随请求流量变化，做到自动伸缩，按需使用，以节约成本。&lt;/p&gt;
&lt;h2 id=&#34;cloud-run-的特性和要求&#34;&gt;Cloud Run 的特性和要求&lt;/h2&gt;
&lt;h3 id=&#34;cloud-run-的特性概述&#34;&gt;Cloud Run 的特性概述&lt;/h3&gt;
&lt;p&gt;下图是整理的 Cloud Run 的几个主要特性，其核心还是那句口号 &amp;ldquo;Bring Serverless to Container&amp;rdquo;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/d3f10b6a5886a874747e4c7515498fcc.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-cloud-run-featurespng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/d3f10b6a5886a874747e4c7515498fcc.png&#34; alt=&#34;cloud-run-features.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      cloud-run-features.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以容器形式出现的工作负载：不只是 Function，极大的丰富了 serverless 的玩法&lt;/li&gt;
&lt;li&gt;兼容 knative API：这也是近年来 Google 的一贯打法，开源项目先行，对社区开放，拉拢盟友建立标准，以无厂商锁定的风险来吸引客户，我将其简称为&amp;quot;开源开放不锁定&amp;quot;。&lt;/li&gt;
&lt;li&gt;GCP 托管：托管的好处自然是客户无需运维，这也是 serverless 的由来和最基本的特性&lt;/li&gt;
&lt;li&gt;流量驱动模式：请求驱动，实例数量可自动伸缩，甚至伸缩到 0，因此无需在业务高峰时预先配置资源和事后手工释放资料，极大的减少运维需要。在此基础上，执行按使用付费，因此可以在不同的应用之间（在公有云上则可以在不同的客户之间）共享成本，以低成本的方式应付短期突发高并发请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cloud Run 的其他特性还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速从容器到生产部署&lt;/li&gt;
&lt;li&gt;开发体验简单&lt;/li&gt;
&lt;li&gt;高可用：自动跨区域的冗余&lt;/li&gt;
&lt;li&gt;和 Stackdrive 的集成，监控/日志/错误报告都是开箱即用&lt;/li&gt;
&lt;li&gt;可自定义域名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些特性容易理解，就不一一展开。&lt;/p&gt;
&lt;h3 id=&#34;适用于更多的场景&#34;&gt;适用于更多的场景&lt;/h3&gt;
&lt;p&gt;传统的基于 Function 负载的 serverless，受限于 Function，适用范围相对有限，尤其不适合非 Function 方式编写的旧有应用，而将应用改造为 Function 一来工作量巨大，二来也不是所有的应用都适合用 Function 形式开发。&lt;/p&gt;
&lt;p&gt;在以 Function 为负载的 serverless 系统中，调用往往发生在外部对 Function 的访问，类似 API gateway 下的南北向通信。Function 之间通常不直接相互调用（某些情况下需要调用时，往往也是走外部调用的通道），因此调用关系相对简单。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/408d2919990b81568734083f0242421b.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-serverless-north-southpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/408d2919990b81568734083f0242421b.png&#34; alt=&#34;serverless-north-south.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      serverless-north-south.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当工作负载从 Function 转变为 Container 之后，不仅仅有 serverless 原有的南北向通信，而且以容器形态出现的工作负载之间相互调用的场景大为增加，这些负载之间的相互调用类似于传统 SOA/微服务框架的东西向服务间通信。Cloud Run 通过支持容器作为工作负载，极大的扩大了 serverless 的适用范围。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/b789978c94647204f33a5a1e202a9a35.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-serverless-east-westpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/b789978c94647204f33a5a1e202a9a35.png&#34; alt=&#34;serverless-east-west.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      serverless-east-west.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了前面列出来的两种场景之外，Cloud Run 还可以适用于其他场景，如事件驱动/异步任务/调度服务等：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/3756b025f89e554e198cc8159060cbd3.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-workload-more-stylepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/3756b025f89e554e198cc8159060cbd3.png&#34; alt=&#34;workload-more-style.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      workload-more-style.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这也迎合了目前 serverless 的发展趋势：未来 serverless 将渗透到各种场景，任何需要按照请求自动实现资源动态调度的工作负载都应该 serverless 化。我称之为：&lt;strong&gt;万物皆可 serverless&lt;/strong&gt;！从 Function 到 Container，serverless 朝这个目标迈出了一大步。&lt;/p&gt;
&lt;h3 id=&#34;cloud-run-的并发模型&#34;&gt;Cloud Run 的并发模型&lt;/h3&gt;
&lt;p&gt;重点看一下 Cloud Run 对请求并发的处理，因为这涉及到如何动态调配服务容器实例的个数。&lt;/p&gt;
&lt;p&gt;在 Cloud Run 中，每个服务都要自动伸缩容器的实例数量来应对请求流量。在 Cloud Run 中对并发（Concurrency）的定义是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Concurrency&lt;/strong&gt; = &amp;ldquo;maximum number of requests that can be sent at the same time to a given container instance&amp;rdquo;&lt;/p&gt;
&lt;p&gt;并发 = &amp;ldquo;可以同时对给定容器实例发送请求的最大数量&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是我们平时理解的&amp;quot;最大并发请求数&amp;quot;，或者&amp;quot;最大工作线程数&amp;quot;。在这一点上，Cloud Run 的做法和 AWS Lambda 还有 Google 自己的 Cloud Function 不同，后两者的做法是每个实例只能同时接受一个请求，相当于“Concurrency=1”。如图，当有多个并发请求时就需要启动多个实例。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/2f69c0f3528dd313836cbdb5725762a3.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-concurrency-1png&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/2f69c0f3528dd313836cbdb5725762a3.png&#34; alt=&#34;concurrency-1.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      concurrency-1.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而在 Cloud Run 中，并发度是可以设置的，容许的值范围是从 1 到 80，默认值是 80，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/311fd84e418f4c362545afa179b4daaa.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-concurrency-settingpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/311fd84e418f4c362545afa179b4daaa.png&#34; alt=&#34;concurrency-setting.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      concurrency-setting.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果并发度设置为 1 则 Cloud Run 的行为也就和 AWS Lambda/Google Cloud Function 一致了，不过对于容器形式的工作负载而言，容器启动和销毁的资源消耗和成本就有过高了，因此 Cloud Run 下通常建议根据实际业务场景设置合适的并发度/请求数上限。这样在处理请求时，可以用一个实例对应多个请求，从而不必启动太多的实例。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/e2bf7c12793ba2969f16fd6625ada7ef.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-concurrency-20png&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/e2bf7c12793ba2969f16fd6625ada7ef.png&#34; alt=&#34;concurrency-20.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      concurrency-20.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;cloud-run-对容器的要求&#34;&gt;Cloud Run 对容器的要求&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/6f73d8eefad9af361963852948b010b1.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-container-runtime-contractpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/6f73d8eefad9af361963852948b010b1.png&#34; alt=&#34;container-runtime-contract.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      container-runtime-contract.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 Google Cloud Run 的文档中， &lt;a href=&#34;https://cloud.google.com/run/docs/reference/container-contract&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Container 运行时契约&lt;/a&gt; 中列出了 Cloud Run 对容器的要求，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语言支持&lt;/p&gt;
&lt;p&gt;可以使用任意语言编写代码，可以使用任意基础镜像，但是容器镜像必须是为 64 位 Linux 编译的; Cloud Run 支持 Linux x86_64 ABI 格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求监听&lt;/p&gt;
&lt;p&gt;容器必须在 &lt;code&gt;0.0.0.0&lt;/code&gt; 上监听，端口由环境变量 &lt;code&gt;PORT&lt;/code&gt; 定义。目前在 Cloud Run 中，PORT 环境变量总是设置为 8080，但是为了可移植性，不能 hardcode。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动时间和响应时间&lt;/p&gt;
&lt;p&gt;容器实例必须在收到请求后的四分钟内启动 HTTP 服务器; 容器实例必须收到 HTTP 请求后的规定时间内发送响应，该时间由 &lt;a href=&#34;https://cloud.google.com/run/docs/configuring/request-timeout&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;request timeout setting&lt;/code&gt;&lt;/a&gt; 配置，包含容器实例的启动时间。否则请求会被终止并返回 504 错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件访问&lt;/p&gt;
&lt;p&gt;容器的文件系统是可写的并受以下影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件系统是基于内存的，写入文件系统会使用容器实例的内存&lt;/li&gt;
&lt;li&gt;写入到文件系统中的数据不会持久化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器实例生命周期考虑&lt;/p&gt;
&lt;p&gt;服务的每个版本都将自动伸缩，如果某个版本没有流量，则会缩减到 0。&lt;/p&gt;
&lt;p&gt;服务应该是无状态的，计算应该限定于请求的范围，如果没有请求则不能使用 CPU。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器实例资源&lt;/p&gt;
&lt;p&gt;每个容器实例分配 1 vCPU 而且不能修改。每个容器实例默认 256M 内存，可以修改，最多为 2G。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，Cloud Run 目前处于测试阶段，因此这些要求可能会随时间而发生变化。&lt;/p&gt;
&lt;p&gt;Container Runtime Contract 更详细的信息，请参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/run/docs/reference/container-contract&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Container Runtime Contract&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/runtime-contract.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Container Runtime Contract&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/opencontainers/runtime-spec/blob/master/spec.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Container Initiative Runtime Specification&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cloud-run-的限制&#34;&gt;Cloud Run 的限制&lt;/h3&gt;
&lt;p&gt;目前 Cloud Run 的限制有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最多 1 个 vCPU 和 2 G 内存&lt;/li&gt;
&lt;li&gt;不能访问 GPU&lt;/li&gt;
&lt;li&gt;没有 Cloud SQL（即将提供）&lt;/li&gt;
&lt;li&gt;没有 VPS 访问（即将提供）&lt;/li&gt;
&lt;li&gt;不支持全局负载均衡&lt;/li&gt;
&lt;li&gt;只支持 HTTP（未来会支持 gRPC）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这些限制，都可以通过选择使用 Cloud Run on GKE 来解决。&lt;/p&gt;
&lt;h3 id=&#34;安全容器-gvisor-的使用&#34;&gt;安全容器 gVisor 的使用&lt;/h3&gt;
&lt;p&gt;gVisor 是由 Google 开源的容器沙箱运行时 (Container sandbox runtime)。用于在宿主机操作系统与容器中的应用之间创建一个安全的隔离边界，便于安全的对外提供大规模部署的容器服务——关于安全容器和 gVisor 的介绍就不在这里展开。&lt;/p&gt;
&lt;p&gt;在 Cloud Run 中，容器是运行在 gVisor 之上的，而不是默认的 Kubernetes runc runtime。gVisor 为 Cloud Run 带来了安全容器的隔离，但是也带来了一些限制。如下图所示，gVisor 支持的 System Call 是有限的，不支持所有的 Linux System Call。但是考虑到 Cloud Run 的主要使用场景是无状态的 HTTP 容器，正常情况下应该不会触发这个限制。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/0720320c9e5ec4be828cc4286a2241ac.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-gvisorpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/0720320c9e5ec4be828cc4286a2241ac.png&#34; alt=&#34;gvisor.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      gvisor.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;和-knative-的关系&#34;&gt;和 knative 的关系&lt;/h2&gt;
&lt;p&gt;Google Cloud 给出的一些 PPT 中宣称 Cloud Run 就是托管版本的 knative，当然这一点我个人有些质疑：当前开源版本的 knative 实在有些不够成熟，应该还达不到生产级强度，Google Cloud 托管的有可能是 knative 的内部版本。但可以肯定的是，Cloud Run 一定是兼容 knative API 的。&lt;/p&gt;
&lt;p&gt;目前 Knative 发展趋势非常不错，尤其社区快速成长，聚拢了一批大小盟友。这里有一份 google 给出的长长列表，列出了当前参与 knative 开发的贡献者来自的公司：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;VMware, Huawei, Cisco, TriggerMesh, Dropbox, SAP, Microsoft, Schibsted, Apache, Independent, China Mobile NTT, CloudBees, Caicloud, Inovex, Docker, Heureka, CNCF, Liz Rice, Zalando, Douyu.com, Nebula. OpsGenie. Terracotta, Eldarion, Giant Swarm, Heroku, Revolgy, SORINT.lab, Switch, Ticketmaster, Virtustream,, Alipay, Blue Box, Cruise Automation, EPAM Systems, EVRY, Foreningen Kollegienet Odense, Giddyinc, IPB, Manifold.co, Orange, Puppet, Stark &amp;amp; Wayne, Weaveworks, Disney Interactive, Ivx, Mediative, Ministère de l&amp;rsquo;Agriculture et de l&amp;rsquo;Alimentation, NatureServe, Samsung SDS. Typeform, Wise2c&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，其中最重要的力量还是来自 google 自己，以及 Redhat、Pivotal、IBM 这三位社区巨头。下图是以公司为单位的贡献度比例：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/b3c67cb6523f850996aa04d71b14bc86.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-knative-companypng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/b3c67cb6523f850996aa04d71b14bc86.png&#34; alt=&#34;knative-company.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      knative-company.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下图是基于 Knative 的几个主要 serverless 产品，除了 Google 的 Cloud Run 之后，还有 Redhat / Pivotal / IBM 等大厂：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/9acb6154b0842a93e2bbd9349231ba2a.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-knative-based-productspng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/9acb6154b0842a93e2bbd9349231ba2a.png&#34; alt=&#34;knative-based-products.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      knative-based-products.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;serverless-计算平台选择&#34;&gt;Serverless 计算平台选择&lt;/h2&gt;
&lt;p&gt;Cloud Run 是一个 serverless 计算平台，用于运行无状态 HTTP 应用程序。它有两种风格：完全托管的环境或 Google Kubernetes Engine 集群。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cloud Run：完全托管，完整的 serverless 体验，客户不需要管理集群，按使用付费。&lt;/li&gt;
&lt;li&gt;Cloud Run on GKE：只具有 serverless 的开发体验，客户需要在自己的 GKE 集群中运行，价格包含在 GKE 集群中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/be5f759c8e6d22b7e7cfab20fb8a58d4.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-cloud-run-on-gkepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/be5f759c8e6d22b7e7cfab20fb8a58d4.png&#34; alt=&#34;cloud-run-on-gke.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      cloud-run-on-gke.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cloud Run on GKE 具有和 Cloud Run 相同的开发体验，但是 Cloud Run on GKE 运行在 k8s 上，有更多的灵活性和控制力，不过需要自己运维。Cloud Run on GKE 可以集成基于 k8s 的策略、控制和管理。允许访问自定义计算机类型，额外的网络和 GPU 支持，以扩展 Cloud Run 服务的运行方式。&lt;/p&gt;
&lt;p&gt;可以在 Cloud Run 和 Cloud Run on GKE 之间按需要选择，另外 Google Cloud 容许在 Cloud Run 和 Cloud Run on GKE 之间切换，无需改动应用。&lt;/p&gt;
&lt;p&gt;Cloud Run 和 Cloud Run on GKE 的详细对比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Cloud Run&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;GKE 上的 Cloud Run&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;价钱&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;按使用付费（见下文）。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;作为 Kubernetes Engine 的一部分提供。定价将在 GA 之前确定。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;机器类型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;每个实例一个 vCPU，可以更改内存&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;GKE 上的标准或自定义机器类型，包括 GPU。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;身份和政策&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;管理允许调用服务的身份（或允许未经身份验证的调用）。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将服务发布到 Internet 或仅将其提供给群集或 VPC 网络。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;联网&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无法访问 VPC /计算引擎网络。服务不是 Istio 服务网格的一部分。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;访问 VPC /计算引擎网络。服务参与 Istio 服务网格。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网址&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自动提供 URL 和 SSL 证书&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自定义域仅包含手动 SSL 证书。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;考虑到 Cloud Run 是 knative 的 google cloud 托管版本，对于客户，则理论上在 Cloud Run 和 Cloud Run on GKE 之外还存在另外一种选择：直接使用开源版本的 knative。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/12c9e1173c8c479185aa9aadc5954302.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-serverless-whereverpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/12c9e1173c8c479185aa9aadc5954302.png&#34; alt=&#34;serverless-wherever.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      serverless-wherever.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者 google 之外的其他基于 knative 的产品，如 Redhat / IBM / Pivotal 等，从而避免了供应商锁定的风险。&lt;/p&gt;
&lt;p&gt;这也是 google 在宣传 Cloud Run 产品是一直反复强调的：开源、开放、不绑定。&lt;/p&gt;
&lt;p&gt;回到在 google cloud 上进行 serverless 平台选择这个话题，现在 google cloud 上的 serverless 有 function/app/container三种模式，而其中的 container 模式又可以细分为 Cloud Run 和 Cloud Run on GKE 两种形态，还有一个自由度极高可以自由发挥的 GKE。下图摘录自 google 的演讲 PPT，做了很好的分类和总结：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/575484dad6e1988bcb23bfe9b9208a7e.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-serverless-hosting-on-gcppng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/575484dad6e1988bcb23bfe9b9208a7e.png&#34; alt=&#34;serverless-hosting-on-gcp.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      serverless-hosting-on-gcp.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;cloud-run-的计费&#34;&gt;Cloud Run 的计费&lt;/h2&gt;
&lt;p&gt;最后关注一下 Cloud Run 的计费，Cloud Run 的官方文档 &lt;a href=&#34;https://cloud.google.com/run/pricing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pricing&lt;/a&gt; 对此有详细的描述，这里摘录部分内容。&lt;/p&gt;
&lt;p&gt;首先，完全托管式的 Cloud Run 仅为使用的资源收取费用，计费到最近的 100 毫秒。而 Cloud Run on GKE 则不同，GKE 上的 Cloud Run 是 Google Kubernetes Engine 集群的附加组件。而 Cloud Run on GKE 部署的工作量包含在 GKE 定价中。而 GKE 上 Cloud Run 的最终定价要到 GA 才确定。&lt;/p&gt;
&lt;p&gt;Cloud Run 的计费模型也颇具创新性，不是完全按请求数量计费，而是同时考量三个指标：CPU/内存/请求数量。搬运一下官方文档作为示意：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;CPU&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Memory&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Requests&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Networking&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;First 180,000 vCPU-seconds free&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;First 360,000 GB-seconds free&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2 million requests free&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Free during beta.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0.00002400/vCPU−secondsbeyondfreequota|0.00002400/vCPU−secondsbeyondfreequota|0.00000250 / GB-second beyond free quota&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$0.40 / million requests beyond free quota&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;测试期间免费&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;按照这个计费模型，将 concurrency 设置为合适的数值（起码不是 1），让一个容器实例可以同时服务多个请求，分享 CPU 和内存，在费用上会更合适。另外上面的计费信息中可以看到，CPU/内存/请求数量都有免费配额，只有超过免费配额的使用才需要付费。免费配额会每月重置。&lt;/p&gt;
&lt;p&gt;Cloud Run 对可计费时间的计算比较良心，只有在容器实例有请求在处理时才计算，从第一个请求开始到最后一个请求结束。而容器实例启动的时间和空闲的时间不计算在内，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/e4ff1e6e6272e8ead0ef539c275559a3.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-屏幕快照-2019-05-13-上午-95621png&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/e4ff1e6e6272e8ead0ef539c275559a3.png&#34; alt=&#34;屏幕快照 2019-05-13 上午 9.56.21.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      屏幕快照 2019-05-13 上午 9.56.21.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;cloud-run-分析&#34;&gt;Cloud Run 分析&lt;/h2&gt;
&lt;p&gt;总结前面的功能介绍，我们可以看到，在 serverless 的常规特性和托管带来的运维便利之外，Cloud Run 的主要特性和卖点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拥抱容器生态&lt;/p&gt;
&lt;p&gt;将 serverless 与容器结合，极大的扩展了 serverless 的适用范围，对于 serverless 市场是一个巨大的创新。对于习惯使用容器/微服务技术的客户，可以更好的迁移过来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥抱社区&lt;/p&gt;
&lt;p&gt;基于开源的 knative，拉拢社区和盟友，通过 knative 实现 serverless 的标准化和平台化，解决了 serverless 市场碎片化的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;极佳的可迁移性&lt;/p&gt;
&lt;p&gt;为客户提供了没有供应商锁定风险的解决方案。理论上 客户可以根据实际需要选择完全托管的 Cloud Run 或 Cloud Run on GKE，或者开源版本的 knative，以及其他基于 knative 的托管平台，。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥抱云原生技术栈&lt;/p&gt;
&lt;p&gt;结合使用 servicemesh 技术和安全容器技术，配合容器/kubernetes，用 Cloud Native 技术栈打通了从底层到上层应用的通道。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结说，Cloud Run 是 Google Cloud 在 serverless 领域的全新尝试，具有创新的产品思路，未来的发展值得关注和借鉴。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;Cloud Run 刚刚发布才一个多月，目前能找到的资料不多，基本都是 Google Cloud放出来的新闻稿/博客和官方文档，还有Cloud Next 大会上的介绍演讲及 PPT。第三方的介绍文章非常的少，因此在调研和整理资料时不得不大量引用来自 Cloud Run 官方渠道的资料和图片。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/run/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Run 官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=gx8VTa1c8DA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Run Overview&lt;/a&gt;: 不到 2 分钟的介绍视频，官方宣传片&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=RVdhyprptTQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Differences between Cloud Run and Cloud Run on GKE&lt;/a&gt;: 官方视频，5 分钟长度，展示 cloud run 和 Cloud Run on GKE 之间的相同点和不同点。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.withgoogle.com/next/sf/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Next&amp;rsquo; 19 大会上和 serverless 相关的演讲&lt;/a&gt;：主要信息还是来自 Next&amp;rsquo; 19 的演讲，在这个页面中选择 &amp;ldquo;serverless&amp;rdquo; 会列出本次大会和 serverless 相关的演讲，大概十余个，视频可以回放，也提供 PPT 下载。（本文的大部分的信息和图片来自这些演讲内容），数量比较多就不一一列举了。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Google Traffic Director 详细介绍</title>
      <link>https://cloudnative.to/blog/google-traffic-director-detail/</link>
      <pubDate>Thu, 09 May 2019 21:38:59 +0800</pubDate>
      <guid>https://cloudnative.to/blog/google-traffic-director-detail/</guid>
      <description>&lt;h2 id=&#34;traffic-director-介绍&#34;&gt;Traffic Director 介绍&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/google-traffic-director-logo.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Traffic Director 是 Google Cloud 推出的完全托管的服务网格流量控制平面。&lt;/p&gt;
&lt;p&gt;援引来自 Traffic Director 官方网站的介绍资料，Traffic Director 的定位是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Enterprise-ready traffic management for open service mesh.&lt;/p&gt;
&lt;p&gt;适用于开放式服务网格的企业级流量管理工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前 Traffic Director 还处于测试阶段，尚未 GA：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 2018 年 7 月的 Cloud Next‘18 大会上，Google Cloud 推出了 Traffic Director 的 alpha 版本&lt;/li&gt;
&lt;li&gt;在 2019 年 4 月的 Cloud Next‘19 大会上，Google Cloud 推出了 Traffic Director 的 beta 版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;traffic-director-推出的背景&#34;&gt;Traffic Director 推出的背景&lt;/h2&gt;
&lt;p&gt;在详细介绍 Traffic Director 的功能之前，我们先看一下 Traffic Director 推出的背景。由于 Traffic Director 刚推出不久，资料非常少，所以下面的内容有很多来自仅有的一点 Traffic Director 的演讲和官方文档。&lt;/p&gt;
&lt;p&gt;在 Cloud Next‘18 /19 介绍 Traffic Director 的演讲中，都谈到 Traffic Director 推出和下列两个趋势有关：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;微服务的普及和 Service Mesh 技术的兴起&lt;/li&gt;
&lt;li&gt;混合云和多云部署&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;从微服务到-service-mesh&#34;&gt;从微服务到 Service Mesh&lt;/h3&gt;
&lt;p&gt;近年来微服务架构大热，传统的单体应用按照微服务的理念进行拆分。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/microservices.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但是当应用从单个巨型单体拆分为数量大增的微服务之后，新的问题出现：如果高效的部署、连接、管理这些服务，并提供安全和监控能力？如果按照传统的侵入式微服务框架的思路，则开发人员就不得不在进行微服务改造时，承受微服务拆分带来的各种技术复杂度。&lt;/p&gt;
&lt;p&gt;但是，当将单体应用拆分到微服务时，客户关注的并不是微服务或者和微服务相关的各种技术，他们真正关注的是：微服务可以给他们带来什么。因此，必须要有一种解决方案，抽象并屏蔽掉微服务实现的技术细节。&lt;/p&gt;
&lt;p&gt;服务网格就是这样一种功能强大的抽象层，在微服务交付方面得到了越来越多的使用。其核心价值有两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Separates applications from app networking / 分离应用和网络&lt;/li&gt;
&lt;li&gt;Decouples operation from development / 解耦开发和运维&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;混合云和多云环境&#34;&gt;混合云和多云环境&lt;/h3&gt;
&lt;p&gt;考虑另一个趋势：在混合云和多云环境下部署和管理服务。客户可能使用公有云，如 GCP 或其他公有云，也可能混合使用私有云。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/multicloud.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这种场景下，该如何简化混合和多云服务的部署？Traffic Director 的思路是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引入 ServiceMesh 技术：通过 ServiceMesh 将通用的核心部分从服务中移除，典型如网络通信代码中的负载均衡，错误注入，失败恢复，流量管理，路由，安全等。&lt;/li&gt;
&lt;li&gt;托管：需要 ServiceMesh 来管理服务，但最好不要自己直接管理 ServiceMesh，而是使用提供托管的基础设施&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;控制平面与托管&#34;&gt;控制平面与托管&lt;/h3&gt;
&lt;p&gt;在服务网格中，服务网格数据平面与服务代理一起传输流量，而服务网格控制平面为这些服务代理提供政策、配置和智能建议：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/servicemesh.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Traffic Director 是 GCP 专为服务网格打造的完全托管式流量控制平面，其架构如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-global-lb/images/Traffic_Director_for_service_mesh.max-1200x1200.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;托管式服务的好处是有服务等级协议 (SLA) 的保障，下面是 Google Cloud 官方对此的声明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作为 Google 的一项托管式服务，Traffic Director 提供生产级 99.99% 可用性的 SLA：如果出现问题，收到通知并负责解决问题是我们的运营人员，而不是您的。您不必担心部署和管理控制平面，因而您的员工可以专注于发展业务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然目前 Traffic Director 还是 beta 测试阶段，上述 SLA 保障需要在 GA 之后才能提供。&lt;/p&gt;
&lt;p&gt;最后我们援引 Matt Klein（Envoy 作者）的这段致辞作为 Traffic Director 推出的背景总结，虽然这段话有做托的嫌疑：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Traffic Director 可以更加便捷地将 Envoy 和服务网格的优势运用到生产环境。由于 Envoy 提供通用型数据平面，Traffic Director 可提供具有开放接口的完全托管式流量控制平面，避免锁定于某一种产品。Traffic Director 的 SLA、全球负载平衡和丰富的流量控制措施可帮助企业和云原生最终用户减少流量管理工作。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里列出的功能我们后面会详细解析，重点看”开放接口”/“避免锁定”这两个关键词：这可以说是 Google 乃至整个 CNCF/Cloud Native 社区一直念念不忘反复提醒的关键字，极其强调标准接口和避免供应商绑定。&lt;/p&gt;
&lt;p&gt;与此对应的是，Traffic Director 采用了开放的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xDS v2 API&lt;/a&gt; 与数据平面中的服务代理进行通信。xDS v2 API 来自 Envoy，目前已经成为 Service Mesh 的事实 API 标准。Traffic Director 通过采用 xDS v2 API 这样的开发 API 实现了其倡导的避免绑定。&lt;/p&gt;
&lt;h2 id=&#34;traffic-director-的功能&#34;&gt;Traffic Director 的功能&lt;/h2&gt;
&lt;h3 id=&#34;全局负载均衡&#34;&gt;全局负载均衡&lt;/h3&gt;
&lt;p&gt;这个功能是 Traffic Director 在各种演讲和介绍中强调的最多的功能，其官方介绍为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Traffic Director 将服务作为虚拟机或容器部署在多个区域中来保证它正常运行，并使用 Traffic Director 通过自动化的跨区域溢出和故障转移来提供全局负载均衡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“作为虚拟机或容器”我们在下一节展开，先看看 Traffic Director 提供的全局负载均衡是什么。&lt;/p&gt;
&lt;p&gt;这是 Traffic Director 官方给出的示例，图中的三个服务分别部署在两个不同的区域。在 Traffic Director 的控制下，流量按照就近原则被发送到具有可用容量的最近的服务实例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-global_load_balancingmax-1400x1400&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-global-lb/images/Global_load_balancing.max-1400x1400.png&#34; alt=&#34;Global_load_balancing.max-1400x1400&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Global_load_balancing.max-1400x1400
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;故障转移是指，如果最接近客户端服务的实例已关闭或过载，则 Traffic Director 会控制流量无缝转移到下一个最近区域中的健康实例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-traffic_director_intelligencemax-1400x1400&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-global-lb/images/Traffic_Director_intelligence.max-1400x1400.png&#34; alt=&#34;Traffic_Director_intelligence.max-1400x1400&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Traffic_Director_intelligence.max-1400x1400
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;跨区域溢出则是指当流量超出当前区域部署的实例的承受能力之后，会突破就近路由的原则，将部分流量导流到其他区域。这背后的逻辑是：就近路由的收益的是本地访问的低网络延迟，在流量突发时，宁可牺牲延迟也要将流量引导到其他区域以保证可用性。&lt;/p&gt;
&lt;p&gt;下面这个动画可以更生动的展示上述描述的”全局负载均衡”/“故障转移”和”跨区域溢出”的功能：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/Traffic_Director_for_open_service_mesh.gif&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;适用于虚拟机和容器&#34;&gt;适用于虚拟机和容器&lt;/h3&gt;
&lt;p&gt;在上面的示例中，提到”Traffic Director 将服务作为虚拟机或容器部署在多个区域中”，这是 Traffic Director 重点强调的另外一个重要功能：支持虚拟机和容器，而且支持混合使用。&lt;/p&gt;
&lt;p&gt;下面这张图片强调了服务部署的多样性：三个服务分别是自己管理的 docker 服务 / 基于虚拟机的服务 / 部署在 GKE 的服务。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/mixed-service.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Traffic Director 官方文档给出的解释是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“按您的节奏进行现代化改造”&lt;/p&gt;
&lt;p&gt;Traffic Director 既适用于基于虚拟机 (Compute Engine) 的应用，也适用于容器化应用（Google Kubernetes Engine 或自行管理的 Kubernetes），并可以增量方式逐步应用于您的服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这背后的考虑是：service mesh 和 k8s 的普及，不会一蹴而就，基于虚拟机的服务会长期存在，因此提供对基于虚拟机服务的支持和打通与容器服务的交互访问就至关重要。这个思路同样出现在 AWS 的 app mesh 产品中，app mesh 也是强调同时支持 VM 服务和容器服务。&lt;/p&gt;
&lt;p&gt;Service Mesh 技术的典型使用场景是运行和管理已经拆解为微服务并按照云原生理念开发的服务，但是考虑到大量遗留应用存在的现实，Traffic Director 通过支持 VM 服务，可以为这些非云原生服务引入高级功能。这个做法在我们之前的介绍中，被戏称为”先上车再买票”，即在不做应用大规模改造的前提下先体现享受 Service Mesh 带来的部分红利，再慢慢逐步和分批做应用改造。&lt;/p&gt;
&lt;p&gt;注意：在 Traffic Director 的支持中，基于虚拟机的服务和基于容器的服务采用一致的流量管理功能，两者并没有功能上的差别。&lt;/p&gt;
&lt;h3 id=&#34;混合云和多云支持&#34;&gt;混合云和多云支持&lt;/h3&gt;
&lt;p&gt;最近看到 Google Cloud 提出要”All in Hybird Cloud”，在这个大背景下，Traffic Director 提供对混合云和多云环境的支持：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/hybird-multicloud.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是完整的应用改造示意，从原有在私有环境下运行的单体应用，转换到在公有云和私有云上的 service mesh 中运行的多个微服务：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/hybird-support.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;集中式健康检查&#34;&gt;集中式健康检查&lt;/h3&gt;
&lt;p&gt;Traffic Director 官方文档对集中式健康检查给出的介绍是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大规模执行运行状况检查&lt;/p&gt;
&lt;p&gt;Traffic Director 通过 GCP 进行大规模运行状况检查。因此，运行状况检查从 Envoy/服务代理分流到 Google 的弹性系统，这样您就可以对各种规模的部署进行大规模运行状况检查。另外，您的实例本身不会因网格规模的运行状况检查而不堪重负。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解释一下这里所说的”因网格规模的运行状况检查而不堪重负”：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大型服务网格会生成大量的健康检查流量，因为每个 sidecar 代理都必须对服务网格中的所有服务实例进行健康检查。随着网格的增长，让每个客户端代理健康检查每个服务器实例，这种做法会产生一个 n^2 健康检查问题，这将成为增长和扩展部署的障碍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Traffic Director 对此给出的解决方案是提供集中式健康检查，Traffic Director 会提供一个全局分布的弹性系统监控所有服务实例。然后，Traffic Director 使用 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/eds.proto#envoy-api-file-envoy-api-v2-eds-proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EDS API&lt;/a&gt; 将聚合的健康检查结果分发到全局网格中的所有代理。如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/health-check.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这样 Proxy 就不需要自行实现健康检测，只要接受 EDS 更新即可（当然客户端被动健康检测还是需要的，当发生无法连接等错误时还是需要处理的）。&lt;/p&gt;
&lt;p&gt;这里 Traffic Director 的做法和 Istio 的标准做法是很类似的，Istio 在 k8s 上部署时，是依赖 k8s 的探测机制来做服务的探活的。Traffic Director 的 health check 机制没有找到详细的介绍资料，暂时不清楚具体的机制，Traffic Director 的介绍中只是提到这个功能是由 GCP 统一提供。&lt;/p&gt;
&lt;p&gt;集中式健康检查这个功能也算是一个卖点，毕竟，虽然 Envoy 自带健康检测机制，但是如果由客户端来实现健康检测，的确是需要每个客户端都检查所有其他服务，连接太多，请求太多，而且随着服务数量和实例数量的增加，健康检测的开销会直线上涨。由平台/基础设施/云等来统一提供集中式健康检查，再通过 xDS/EDS API 下发结果应该会是一个通用的做法。&lt;/p&gt;
&lt;h3 id=&#34;流量控制&#34;&gt;流量控制&lt;/h3&gt;
&lt;p&gt;Traffic Director 目前提供流量控制功能，包括流量路由和策略执行。官方文档的介绍描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过请求路由和丰富的流量政策进行流量控制（Alpha 版）&lt;/p&gt;
&lt;p&gt;Traffic Director 支持高级请求路由功能，如流量拆分、启用 Canary 更新等用例、网址重写/重定向、故障注入、流量镜像，以及基于各种标头值的高级路由功能，包括 Cookie。此外，Traffic Director 还支持许多高级流量政策，包括多种负载平衡方案、熔断和后端异常检测。&lt;/p&gt;
&lt;p&gt;您可以使用 Traffic Director 轻松部署一切功能：从简单的负载平衡，到请求路由和基于百分比的流量拆分等高级功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从最新的 Traffic Director 的介绍 PPT 上看到，Traffic Director 的流量控制功能包含两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Routing Rules&lt;/strong&gt;：定义请求如何路由到网格中的服务
&lt;ul&gt;
&lt;li&gt;Traffic splitting&lt;/li&gt;
&lt;li&gt;Traffic steering&lt;/li&gt;
&lt;li&gt;Timeouts and retries&lt;/li&gt;
&lt;li&gt;Fault Injection&lt;/li&gt;
&lt;li&gt;Mirroring&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Traffic Policies&lt;/strong&gt;：用于服务的路由相关策略
&lt;ul&gt;
&lt;li&gt;Load balancing schemes.&lt;/li&gt;
&lt;li&gt;Outlier detection.&lt;/li&gt;
&lt;li&gt;Circuit breakers&lt;/li&gt;
&lt;li&gt;Timeouts&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;熟悉 Istio API 和 Envoy xDS API 的同学就会发现这些功能非常眼熟，基本上和 Istio / Envoy 提供的功能相同。&lt;/p&gt;
&lt;p&gt;和包括 Istio 在内的所有 Service Mesh 产品一致，Traffic Director 也在强调说这些功能都是可以在不修改应用代码的前提下获得，这是理所当然的重要卖点。&lt;/p&gt;
&lt;p&gt;但是注意：目前这些功能都还是 alpha 阶段，因此支持度应该不会像 Istio 那么齐全。&lt;/p&gt;
&lt;p&gt;我们快速过一下目前提供的功能（图片来自 Google Traffic Director 的演讲 PPT）：&lt;/p&gt;
&lt;p&gt;Traffic Splitting/流量拆分，支持百分比拆分，这是 version based routing，用于实现金丝雀发布/蓝绿部署/AB 测试等：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/traffic-splitting.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Traffic Steering，这是 content based routing，支持 Host / Path / Header 匹配：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/traffic-steering.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在匹配完成之后，除了做流量拆分之外，还可以由其他的功能，如错误注入。Traffic Director 支持的错误注入同样有 Delay 和 Abort 两种：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/fault-injection.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;熔断和异常检测，支持每服务配置，具体的配置方式也和 Istio / Envoy 差不多。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/circuit-breakers.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;流量镜像功能，也称为影子流量。流量会复制一份发送给接受镜像流量的服务，Traffic Director 的实现会在发送给镜像服务的请求的 Host/Authority header 中增加一个“-shadow”后缀。镜像请求是发出去就不管的，无视应答，和 Istio 的处理方式一致。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/traffic-mirror.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;总结：在流量控制这块功能上，Traffic Director 除了因为是 alpha 版本，可能功能支持不够齐全之外，基本和 Istio / Envoy 是一致的。考虑到 Traffic Director 支持 xDS V2 API，和目前只支持 Envoy（理论上兼容任何支持 xDS v2 的代理，但是实际只测试过 Envoy）的现状，Traffic Director 在流量控制上和 Istio / Envoy 高度一致也就非常容易理解。&lt;/p&gt;
&lt;p&gt;需要特别指出的是：目前 beta 版本的 Traffic Director 只支持用 GCP 的 API 来设置流量控制的规则，目前还不支持直接使用 Istio 的 API（CRD）。但是，预计未来将提供支持，从 Roadmap 上也看到有和 Istio 集成的规划。&lt;/p&gt;
&lt;h3 id=&#34;基于流量的自动伸缩&#34;&gt;基于流量的自动伸缩&lt;/h3&gt;
&lt;p&gt;Traffic Director 前面支持的功能，基本都有不出意外的感觉，毕竟熟悉 Istio/Envoy 体系的同学对这些功能都了如指掌。而 自动伸缩这个功能是一个特例。&lt;/p&gt;
&lt;p&gt;援引 Traffic Director 官方文档对此功能的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据您的服务规模智能快速进行地自动扩缩&lt;/p&gt;
&lt;p&gt;Traffic Director 可根据您的需求自动扩缩，您只需按实际用量付费，并且快速智能地进行扩容，无需联系云服务提供商也不必进行任何预热。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到这段描述，第一反应是：这不是 serverless 吗？按需伸缩，按使用付费。&lt;/p&gt;
&lt;p&gt;Traffic Director 在提供标准的 service mesh 功能的同时，也引入了 serverless 的特性。下面是 Traffic Director 中自动伸缩功能的实现方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Traffic Director 根据代理向其报告的负载信号启用自动伸缩。Traffic Director 通知 Compute Engine autoscaler 流量变化，并让 autoscaler 一次性增长到所需的大小（而不是像其他 autoscaler 那样重复步骤），从而减少 autoscaler 对流量峰值做出反应所需的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自动伸缩的功能不仅仅可以用于常规的按照请求流量进行扩容和缩容，也支持某些特殊场景，如前面在介绍全局负载均衡时提到的：如果最接近客户端服务的实例已关闭或过载，则 Traffic Director 会控制流量无缝转移到下一个最近区域中的健康实例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-traffic_director_intelligencemax-1400x1400&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-global-lb/images/Traffic_Director_intelligence.max-1400x1400.png&#34; alt=&#34;Traffic_Director_intelligence.max-1400x1400&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Traffic_Director_intelligence.max-1400x1400
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此时由于原来两个区域的流量都进入了一个区域的 Shopping Car 服务，可能出现流量超出当前承受能力的情况，此时 Traffic Director 会指示 Compute Engine autoscaler 增加 Shopping Car 服务的容量。同理，Payments 服务的容量也会随之增加。&lt;/p&gt;
&lt;p&gt;按照 Google Cloud 官方博客文章的介绍，Traffic Director 在这块的处理非常的复杂而智能：在新增加的容量生效之前，Traffic Director 会暂时将流量重定向到其他可用实例 - 即使在其他区域也是如此。（也就是前面所说的跨区域溢出，其指导原则是可用性目标高于低延迟目标）一旦 autoscaler 增加了足够的工作负载容量以维持峰值，Traffic Director 就会将流量移回最近的 zone 和 region，再次优化流量分配以最小化每个请求的 RTT。&lt;/p&gt;
&lt;p&gt;从这里可以看到，Traffic Director 结合使用了 Service Mesh 的路由控制能力和 Serverless 的按需自动伸缩的资源调度能力，在故障处理和自动运维上表现非常突出。&lt;/p&gt;
&lt;p&gt;可以说，Traffic Director 在 servicemesh 和 serverless 整合的道路上迈出了重要的一步。这是一个非常有创新的想法，值得借鉴和学习。&lt;/p&gt;
&lt;h3 id=&#34;功能限制&#34;&gt;功能限制&lt;/h3&gt;
&lt;p&gt;Traffic Director 官方文档中列出了一些目前的功能限制，这里摘录其中比较重要的部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Beta 版本的 Traffic Director 仅支持 GCP API。Beta 版本的 Traffic Director 不支持 Istio API。&lt;/li&gt;
&lt;li&gt;Traffic Director 仅支持 HTTP 流量。&lt;/li&gt;
&lt;li&gt;Traffic Director 流量控制功能是 Alpha 状态。&lt;/li&gt;
&lt;li&gt;本文档讨论了 Envoy 代理，但您可以将任何 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开放标准 API（xDS v2）代理&lt;/a&gt; 与 Traffic Director 一起使用。但请注意，Google 仅使用 Envoy 代理测试了 Traffic Director。在此测试期间，Traffic Director 仅支持 Envoy 版本 1.9.1 或更高版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;和-istio-的关系&#34;&gt;和 Istio 的关系&lt;/h2&gt;
&lt;p&gt;在了解 Traffic Director 之后，相信很多人会和我一样有同样的问题：Traffic Director 和 Istio 到底有什么关系？&lt;/p&gt;
&lt;p&gt;简单介绍 Istio：Istio 提供控制平面来保护，连接和监控微服务。它有三个组成部分：Pilot 负责流量管理，Mixer 负责可观察性，Istio Security（Citadel）负责服务到服务的安全性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/istio.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Traffic Director 和 Istio 的基本区别在于，Istio 是一个开源产品，而 Traffic Director 是一个完全托管的服务。&lt;/p&gt;
&lt;p&gt;在具体的功能模块上，Traffic Director 将取代 Pilot 的位置：所有 Pilot 能提供的功能，Traffic Director 都将提供。这也是采用 open xDS v2 API 的原因，以便在开源的 Pilot 和 Traffic Director 之间切换。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/pilot-replace.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;总结说：Traffic Director 提供了 GCP 托管的 Pilot，以及全局负载均衡和集中式健康检查等其他功能。&lt;/p&gt;
&lt;p&gt;但请注意，当前 Traffic Director Beta 版本还无法使用 Istio API 配置 Traffic Director，暂时只能使用 GCP API 进行配置。&lt;/p&gt;
&lt;p&gt;在 Sidecar 的注入上，Istio 支持自动注入，而 Traffic Director 目前需要手工注入 Sidecar，不过未来 Traffic Director 应该会支持自动注入，毕竟这个功能实现上并不复杂。&lt;/p&gt;
&lt;p&gt;Traffic Director 的 Roadmap 中，有和 Istio 进一步集成的计划，从下图上看是准备引入 Istio Security（Citadel），以提供安全特性如 mTLS，RBAC 等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/istio-integration.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;暂时未看到有引入 Mixer 的信息。&lt;/p&gt;
&lt;h2 id=&#34;traffic-director-roadmap&#34;&gt;Traffic Director Roadmap&lt;/h2&gt;
&lt;p&gt;援引最新 Traffic Director 介绍的 PPT，Traffic Director 的 Roadmap 中未来准备加入以下内容：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/roadmap.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安全方面的集成，要支持 mTLS/RBAC，看前面的图片是打算引入Istio Security（Citadel）模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可观测性集成：按说是 Istio Mixer 模块，但是没见到介绍，怀疑是不是因为 Mixer 在性能上的拙劣表现，导致 Traffic Director 可能采用其他方案，后续关注。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hybird/Multi-cloud支持&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 Istio API 来进行控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和其他控制平面组建联邦&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/federation.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;traffic-director-分析&#34;&gt;Traffic Director 分析&lt;/h2&gt;
&lt;p&gt;从前面的功能介绍中可以看到，Traffic Director 的重要卖点和特色在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对混合云/多云的支持&lt;/li&gt;
&lt;li&gt;对 VM 服务（或者说非云原生服务）的支持&lt;/li&gt;
&lt;li&gt;整合了 serverless 的部分特性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他功能不是说不重要，而是相对来说比较常规化，即托管的服务网格理论上说应该都会提供这些功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全托管，无需运维，GA 后提供 SLA 保证&lt;/li&gt;
&lt;li&gt;流量管理（包括路由和策略）/安全/可观测性&lt;/li&gt;
&lt;li&gt;全局负载均衡&lt;/li&gt;
&lt;li&gt;集中式健康检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从产品定位上说，Traffic Director 只提供控制平面，对于数据平面理论上只要兼容 xDS v2 API 即可，也就是说 Traffic Director 完全关注在控制平面，前面列出来的几个重要的卖点也都属于控制平面的创新和深耕，和数据平面关系不大，或者说数据平面只需简单的提供底层支持。从这点上看，和 Istio 专注在控制平面，而将数据平面完全委托给 Envoy 的做法可谓一脉相承。&lt;/p&gt;
&lt;p&gt;在 API 的选择上，Traffic Director 的做法是支持开放的 xDS v2 API，以及计划中的通过 Istio API 来进行配置。一方面在产品层面上和开源的 Envoy/Istio 保持一致，另一方面也通过这种方式实现了其一直宣传的不锁定的目标，对于市场宣传和争取客户应该是有利的，也有助于实现混合云和多云战略。&lt;/p&gt;
&lt;p&gt;目前 Traffic Director 还处于 beta 测试阶段，尤其流量配置更是还在 alpha 阶段，产品的成熟度还不够高，roadmap 中也还有很多非常重要甚至急迫（如可观测性）的内容有待完成。因此不适合对 Traffic Director 过早的做判断和评论，我的观点是 Traffic Director 代表的产品方向应该是非常有前途，可以给客户带来实际价值。这是 Google 在 ServiceMesh 领域（甚至是 Serverless 领域）新的探索和尝试，期望有好的结果。&lt;/p&gt;
&lt;p&gt;对 Traffic Director 的理解，我的观点是不能单独的只看 Traffic Director 这一个产品，而是要结合近期 Google 陆续推出的几个相关产品：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google Cloud Service Mesh：ServiceMesh 产品，简单理解为 Istio 的 GCP 托管版本（猜测可能是兼容 Istio API的内部实现/扩展版本），探索方向为在公有云上提供 Service Mesh 托管服务&lt;/li&gt;
&lt;li&gt;Google Cloud Run：Serverless 产品，简单理解为 knative 的 GCP 托管版本（猜测依然可能是兼容 Knative API的内部实现/扩展版本），探索方向为在公有云上提供 Serverless 托管服务&lt;/li&gt;
&lt;li&gt;Anthos：Hybird/Multi-Cloud 产品，号称业界”第一个真正的混合和多云平台”，探索方向为 Google 宣称要“All in”的混合云市场&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后再来看，作为托管版 Service Mesh 控制平台而推出 Traffic Director 产品，我们前面列出的三个卖点和特色：对混合云/多云的支持；对 VM 服务（或者说非云原生服务）的支持；整合 serverless 的部分特性。和这三个新产品可谓交相呼应。&lt;/p&gt;
&lt;p&gt;摘录两句从最近的 Google Cloud Next 大会信息中看到的话，是不是更有体会？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Write once, Run Anywhere/一次写好，哪都能跑&lt;/li&gt;
&lt;li&gt;Use open-source technology easily and in a cloud-native way / 以云原生的方式，轻松使用开源技术&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Google / Google Cloud 在下一盘很大的棋，一盘围绕云和云原生的大棋：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以云为战场，以 kubernetes 为根据地，以开源开放不锁定为口号，以云原生为旗帜，以 ServiceMesh 和 Serviceless 为桥梁连接起应用和基础设施，以混合云为突破口……剑指当前云计算市场排名第一/第二的 AWS/Azure。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;Traffic Director 目前能找到的资料不多，基本都是 Google Cloud放出来的新闻稿/博客和官方文档，还有两次cloud next 大会上的介绍演讲及 PPT。第三方的介绍文章非常的少，因此在调研和整理资料时不得不大量引用来自 Traffic Director 官方渠道的资料和图片。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/traffic-director/docs/traffic-director-concepts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traffic Director concepts&lt;/a&gt;: Google Cloud 上的 Traffic Director 官方文档&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/blog/products/networking/traffic-director-global-traffic-management-for-open-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud networking in depth: How Traffic Director provides global load balancing for open service mesh&lt;/a&gt;：来自 Google Cloud 网站的官方博客文章，发表时间为 2019-04-18&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/cloudzone/google-clouds-traffic-director-what-is-it-and-how-is-it-related-to-the-istio-service-mesh-c199acc64a6d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud’s Traffic Director — What is it and how is it related to the Istio service-mesh?&lt;/a&gt;：来自 Medium 网站的博客文章，原作者为 &lt;a href=&#34;https://medium.com/@iftachsc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Iftach Schonbaum&lt;/a&gt;，发表时间 2019-04-16&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.com/news/2019/04/google-traffic-director&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introducing Traffic Director: Google’s Service Mesh Control Plane&lt;/a&gt;：来自 InfoQ 网站的文章，发布时间 2019-04-25&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=FUITCYMCEhU&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traffic Director &amp;amp; Envoy-Based L7 ILB for Production-Grade Service Mesh &amp;amp; Istio&lt;/a&gt;: Google 在 Cloud Next‘19 大会上的主题演讲，发表时间 2019-04-10（本文的很多图片摘录自这个演讲的 ppt）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?time_continue=2759&amp;amp;v=4U4X_OzJaNY&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hybrid and Open Services with GCP, Envoy and Istio: A Talk with Google and Lyft &lt;/a&gt;: Google 在 Cloud Next‘18 大会上的主题演讲，发表时间 2018-07-26&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CNCF 正在筹建通用数据平面 API 工作组，以制定数据平面的标准 API</title>
      <link>https://cloudnative.to/blog/cncf-udpa-wg/</link>
      <pubDate>Wed, 08 May 2019 10:12:18 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cncf-udpa-wg/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;昨日得到的消息，CNCF 正在筹建通用数据平面 API 工作组（Universal Data Plane API Working Group / UDPA-WG)，以制定数据平面的标准 API，为 L4/L7 数据平面配置提供事实上的标准，初始成员将包括 Envoy 和 gRPC 项目的代表。&lt;/p&gt;
&lt;p&gt;目前还处于非常早期的筹备阶段，具体内容可以见下面的文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1y-H-pQ2mmhBPX_U9pP3mMMUbEpZskxBdEbwd5KlivY4/edit#heading=h.fdi15bvpmxen&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://docs.google.com/document/d/1y-H-pQ2mmhBPX_U9pP3mMMUbEpZskxBdEbwd5KlivY4/edit#heading=h.fdi15bvpmxen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;方便起见，我将目前文档的内容搬运出来并简单翻译如下：&lt;/p&gt;
&lt;h2 id=&#34;文档内容&#34;&gt;文档内容&lt;/h2&gt;
&lt;h3 id=&#34;目标&#34;&gt;目标&lt;/h3&gt;
&lt;p&gt;通用数据平面 API 工作组（Universal Data Plane API Working Group/UDPA-WG）的目标是将对数据平面代理和负载均衡器的通用控制和配置API感兴趣的行业各方聚集在一起。&lt;/p&gt;
&lt;h3 id=&#34;愿景&#34;&gt;愿景&lt;/h3&gt;
&lt;p&gt;通用数据平面 API（UDPA）的愿景在 &lt;a href=&#34;https://blog.envoyproxy.io/the-universal-data-plane-api-d15cec7a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.envoyproxy.io/the-universal-data-plane-api-d15cec7a&lt;/a&gt; 中阐述。我们将寻求一套 API，为 L4/L7 数据平面配置提供事实上的标准，类似于 OpenFlow 在 SDN L2 /L3/L4 中所扮演的角色。&lt;/p&gt;
&lt;p&gt;API 以 proto3 的规范方式定义，并通过定义良好的稳定 API 版本控制策略从现有的 Envoy xDS API 逐步演变。API 将涵盖服务发现，负载均衡分配，路由发现，监听器配置，安全发现，负载报告，健康检查委派等。&lt;/p&gt;
&lt;p&gt;我们将发展和塑造 API 以支持客户端旁视（lookaside）负载均衡（例如 gRPC-LB），Envoy 之外的数据平面代理，硬件 LB，移动客户端等。我们将努力尽可能地与供应商和实现无关，同时不回归支持已投入生产中的 UDPA 的项目（Envoy＆gRPC-LB，到目前为止）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We will strive to be vendor and implementation agnostic to the degree possible while not regressing on support for projects that have committed to UDPA in production (Envoy &amp;amp; gRPC-LB so far).&lt;/p&gt;
&lt;p&gt;后半句的没能理解在说什么，稍后更新……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;成员&#34;&gt;成员&lt;/h3&gt;
&lt;p&gt;初始成员将包括 Envoy 和 gRPC 项目的代表。这将包括来自 谷歌 和 Lyft 的维护者，以及微软和亚马逊的成员。我们正在征求数据平面代理社区更广泛的对初始成员资格的额外兴趣，因为我们认为真正的通用 API 应该反映各种各样的项目，组织和个人。&lt;/p&gt;
&lt;p&gt;我们希望工作组保持小规模，并紧密关注有效平衡增量 API，同时追求长期战略演变。我们将每两周举行一次 Zoom 会议，并通过 TBD 邮件列表进行沟通。&lt;/p&gt;
&lt;h2 id=&#34;解释&#34;&gt;解释&lt;/h2&gt;
&lt;p&gt;上面文档中提到的几个内容：&lt;/p&gt;
&lt;h3 id=&#34;现有的-envoy-xds-api&#34;&gt;现有的 Envoy xDS API&lt;/h3&gt;
&lt;p&gt;Universal Data Plane API 的介绍和设想见 Matt Klein 的博客文章 &lt;a href=&#34;https://blog.envoyproxy.io/the-universal-data-plane-api-d15cec7a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The universal data plane API&lt;/a&gt;，发表于 2017-09-06。也可以看 servermesher 网站翻译的中文版本 &lt;a href=&#34;http://www.servicemesher.com/blog/the-universal-data-plane-api/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh 中的通用数据平面 API 设计&lt;/a&gt;。这个博客阐述了 xDS API 诞生的想法/设计和从v1到v2版本的演进&lt;/p&gt;
&lt;p&gt;Envoy xDS API 最新的定义请见：https://github.com/envoyproxy/data-plane-api&lt;/p&gt;
&lt;h3 id=&#34;稳定的-api-版本控制策略&#34;&gt;稳定的 API 版本控制策略&lt;/h3&gt;
&lt;p&gt;见文档 &lt;a href=&#34;https://docs.google.com/document/d/1xeVvJ6KjFBkNjVspPbY_PwEDHC7XPi0J5p1SqUXcCl8/edit#heading=h.c0uts5ftkk58&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Stable Envoy API versioning&lt;/a&gt; : 这个文档提供了解决 Envoy API 中稳定性问题的设计方案，以及有关 API 当前状态的一些背景，考虑的替代方案以及 Envoy API 中未来方向的讨论。（文档有点长）&lt;/p&gt;
&lt;h3 id=&#34;client-side-lookaside-load-balancing&#34;&gt;client-side lookaside load balancing&lt;/h3&gt;
&lt;p&gt;介绍见 &lt;a href=&#34;https://grpc.io/blog/loadbalancing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://grpc.io/blog/loadbalancing/&lt;/a&gt; 中的“Lookaside Load Balancing”一节。&lt;/p&gt;
&lt;p&gt;注意：旁视（lookaside）负载平衡器也称为外部（external）负载平衡器或单臂（one-arm）负载平衡器&lt;/p&gt;
&lt;p&gt;使用 c 时，负载均衡的智能在特殊的 LB 服务器中实现。客户端查询旁视 LB，LB 响应最合适服务器给客户端使用。保持服务器状态和 LB 算法的实现在旁视 LB 中实现。请注意，客户端可能会选择在 LB 中实现的复杂算法之上实现简单算法。gRPC 使用该模型定义客户端和 LB 之间的通信协议。&lt;/p&gt;
&lt;p&gt;下图说明了这种方法。客户端从旁视 LB (#1) 获取至少一个地址。然后客户端使用此地址生成 RPC (#2)，服务器将负载报告发送到 LB (#3)。旁视 LB 与其他基础设施通信，例如名称解析，服务发现等 (#4)。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://grpc.io/img/image_2.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;之前 servicemesher 社区在多次讨论 servicemesh 市场竞争时，都在笑说：Envoy 才是真正的赢家。&lt;/p&gt;
&lt;p&gt;不仅仅在于 Envoy 表现稳定、使用广泛、顺利从 CNCF 毕业，也在于 Envoy 的 xDS v2 API，已经成为数据平面的事实标准。而这一次 CNCF 组织通用数据平面 API 工作组，准备基于 xDS v2 API 制定官方标准，可以说是水到渠成。&lt;/p&gt;
&lt;p&gt;我目前唯一担心的是：Bueyant 会不会参与进来？Linkerd2 会不会选择放弃现在使用的私有 API 而遵循新标准？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Istio1.1 新特性之限制服务可见性</title>
      <link>https://cloudnative.to/blog/istio-service-visibility/</link>
      <pubDate>Tue, 19 Mar 2019 12:27:13 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-service-visibility/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;对于服务的可见性，在 Istio 设计之初，是没有特别考虑的，或者说，Istio 一开始的假定，就是建立在如下这个前提下的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Istio 中的每个服务都可以访问 Mesh 中的任意服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即在服务发现/请求转发这个层面，对服务访问的可见性不做任何限制，而通过安全机制来解决服务间调用权限的问题，如RBAC的使用。在这个思想的指导下，Pilot组件是需要将全量的服务信息（服务注册信息和服务治理信息）下发到 Sidecar，这样 Sidecar 才能在做到不管服务要请求的目标是哪个服务，都可以做到正确的路由。&lt;/p&gt;
&lt;p&gt;这个机制在 demo 和小规模使用时不是问题，但是，在实际项目落地时，如果服务数量比较多，数以百计/数以千计，则立即显露出来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下发的信息量太大：因此 Pilot 和 Sidecar 的 CPU 使用会很高，因为每次都要将全量的数据下发到每一个 sidecar，需要编解码。Sidecar 的内存使用也会增加。&lt;/li&gt;
&lt;li&gt;下发的频度非常密集：系统中任何一个服务的变动，都需要通知到每一个 Sidecar，即使这个 Sidecar 所在的服务完全不访问它&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-service-visibility/006tKfTcly1g17zrs3ev2j315y0sktd0_hu0cd81104d281fa7be5ca194529aeca03_118312_e452a993369eaeb5f44e4c37a6512c68.webp 400w,
               /blog/istio-service-visibility/006tKfTcly1g17zrs3ev2j315y0sktd0_hu0cd81104d281fa7be5ca194529aeca03_118312_8b2e99355c86b477799dc9783c08810e.webp 760w,
               /blog/istio-service-visibility/006tKfTcly1g17zrs3ev2j315y0sktd0_hu0cd81104d281fa7be5ca194529aeca03_118312_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-service-visibility/006tKfTcly1g17zrs3ev2j315y0sktd0_hu0cd81104d281fa7be5ca194529aeca03_118312_e452a993369eaeb5f44e4c37a6512c68.webp&#34;
               width=&#34;760&#34;
               height=&#34;517&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;试想：假定 A 服务只需要访问 B/C 两个服务，但是在一个有 1000 个服务的系统中，A 服务的 Sidecar 会不得不接收到其他 998 个服务的数据和每一次的变化通知。其所需有效数据和实际得到数据的比例高达 2:1000！&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-service-visibility/006tKfTcly1g17zrsjj4dj315y0skwkf_hu4248d3aeb48706fb5ea81d4989f36576_163413_54e0f9eab171c124865c3279dde3bf55.webp 400w,
               /blog/istio-service-visibility/006tKfTcly1g17zrsjj4dj315y0skwkf_hu4248d3aeb48706fb5ea81d4989f36576_163413_6cdef28f8c2af257e8cbd992ed01ee9c.webp 760w,
               /blog/istio-service-visibility/006tKfTcly1g17zrsjj4dj315y0skwkf_hu4248d3aeb48706fb5ea81d4989f36576_163413_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-service-visibility/006tKfTcly1g17zrsjj4dj315y0skwkf_hu4248d3aeb48706fb5ea81d4989f36576_163413_54e0f9eab171c124865c3279dde3bf55.webp&#34;
               width=&#34;760&#34;
               height=&#34;517&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;因此，在没有服务可见性控制的情况下，Pilot 到 Sidecar 的数据下发的有效性低得可谓令人发指！&lt;/p&gt;
&lt;p&gt;理想模式：同样假定 A 服务只需要访问 B/C 两个服务，如果能通过某个方式将这个信息（成为服务依赖或者服务可见性）提供出来，让 Istio 得到这个信息，那么在 Pilot 往 A 服务的 Sidecar 下发数据时，就可以做一个简单的过滤：只发送 B/C 服务的信息，和只在 B/C 服务发生变更时通知 A。而这个简单过滤所带来的 Pilot 和 Sidecar 之间数据下发的性能提升，是和系统内服务数量成线性关系，很容易就实现两个或者三个数量级的提升。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-service-visibility/006tKfTcly1g17zrtimf4j315y0sk0xo_hu8b89a90a26e476401919030710681402_136412_86c8d77d2877236440d1987ec9640d4d.webp 400w,
               /blog/istio-service-visibility/006tKfTcly1g17zrtimf4j315y0sk0xo_hu8b89a90a26e476401919030710681402_136412_6b16159c5af3141d4138292bb8fabe87.webp 760w,
               /blog/istio-service-visibility/006tKfTcly1g17zrtimf4j315y0sk0xo_hu8b89a90a26e476401919030710681402_136412_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-service-visibility/006tKfTcly1g17zrtimf4j315y0sk0xo_hu8b89a90a26e476401919030710681402_136412_86c8d77d2877236440d1987ec9640d4d.webp&#34;
               width=&#34;760&#34;
               height=&#34;517&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 Istio 问世快 2 年之际，Istio 终于开始正视这个问题——好吧，我坦白，在这一点上，我是有怨言的：Istio 的工程实现中，对实际生产问题的考虑，非常不到位。&lt;/p&gt;
&lt;h2 id=&#34;istio11-新动态&#34;&gt;Istio1.1 新动态&lt;/h2&gt;
&lt;p&gt;Istio 1.1 即将发布，这几天陆续看到新文章介绍 istio1.1 的新功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzIzNzU5NTYzMA==&amp;amp;mid=2247486344&amp;amp;idx=1&amp;amp;sn=342514c520f8977b4c4ab73b81c099e9&amp;amp;chksm=e8c77509dfb0fc1fa5fc9480988a1a93ad501a6bf981c4ed4fcab86db0fed65b169270fc2193&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;pass_ticket=MpgumPaw3Tf881FIiIQQD8PBdu7hskmvp3ANufYG3jLs0TogoH8jvKON9IUTqvt8#rd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio1.1 功能预告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzIxMDY5ODM1OA==&amp;amp;mid=2247484493&amp;amp;idx=1&amp;amp;sn=57e1637d309257ae43bacd0e4d9b2b6f&amp;amp;chksm=9761ed54a01664429e2c9c2fb74a2e183f6caac2fb927bc3ccd6528f591df7f9de5b97faef5a&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;pass_ticket=MpgumPaw3Tf881FIiIQQD8PBdu7hskmvp3ANufYG3jLs0TogoH8jvKON9IUTqvt8#rd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;鸿沟前的服务网格—Istio 1.1 新特性预览&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中和服务可见性直接相关的内容主要是 Sidecar CRD 和 ExportTo 属性。&lt;/p&gt;
&lt;p&gt;引用上面文章的内容，&amp;ldquo;鸿沟前的服务网格—Istio 1.1 新特性预览&amp;rdquo; 的介绍如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新增 Sidecar 资源&lt;/p&gt;
&lt;p&gt;目前版本中，Sidecar 会包含整个网格内的服务信息，在 1.1 中，新建了 Sidecar 资源，通过对这一 CRD 的配置，不但能够限制 Sidecar 的相关服务的数量，从而降低资源占用，提高传播效率；还能方便的对 Sidecar 的代理行为做出更多的精细控制——例如对 Ingress 场景中的被代理端点的配置能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ExportTo&lt;/p&gt;
&lt;p&gt;多个路由管理对象加入了这一字段，用于指定该资源的生效范围。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;Istio1.1 功能预告&amp;rdquo; 一文的介绍是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新的 sidecar：资源：在指定命名空间中使用 sidecar 资源时，支持定义可访问的服务范围，这样可以降低发给 proxy 的配置数量。在大规模的集群中，我们推荐给每个 namespace 增加 sidecar 对象。这个功能主要是为了提升性能，减轻 proxy 计算的负担。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;限制网络资源的生效范围：为所有的网络资源增加了 exportTo 的字段，用来表示此网络资源在哪些 namespace 中生效。这个字段目前只有两个值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;. &lt;/code&gt; 表示此网络资源只在自己定义的 namespace 生效；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;* &lt;/code&gt; 表示此网络资源在所有的 namespace 生效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来围绕服务可见性，对 Istio1.1 新特性做一个深入了解。&lt;/p&gt;
&lt;h2 id=&#34;exportto-属性&#34;&gt;ExportTo 属性&lt;/h2&gt;
&lt;p&gt;Istio 1.1 在 DestinationRule / ServiceEntry / VirtualService 三个 CRD 上新增加了 export_to 字段（忽略其他字段）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;DestinationRule&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;export_to&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ServiceEntry&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;export_to&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;VirtualService&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;export_to&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面是 exportTo 的字段说明，以 destination rule 为例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;exportTo&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;string[]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当前 destination rule 要导出的 namespace 列表。应用于 service 的 destination rule 的解析发生在 namespace 层次结构的上下文中。destination rule 的导出允许将其包含在其他 namespace 中的服务的解析层次结构中。此功能为服务所有者和网格管理员提供了一种机制，用于控制跨 namespace 边界的 destination rule 的可见性。&lt;br/&gt;&lt;br/&gt;如果未指定任何 namespace，则默认情况下将 destination rule 导出到所有 namespace。&lt;br/&gt;&lt;br/&gt;值&lt;code&gt;.&lt;/code&gt; 被保留，用于定义导出到 destination rule 被声明所在的相同 namespace，类似的值&lt;code&gt;*&lt;/code&gt;保留，用于定义导出到所有 namespaces. &lt;br/&gt;&lt;br/&gt;NOTE：在当前版本中，exportTo 值被限制为&lt;code&gt;.&lt;/code&gt;或&lt;code&gt;*&lt;/code&gt;（即，当前 namespace 或所有 namespace）。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从此，对以上三个 CRD 的使用，都必须满足 exportTo 对 namespace 的要求，才能被正确引用。如 gateway CRD 的说明：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// NOTE: Only virtual services exported to the gateway&amp;#39;s namespace
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// (e.g., `exportTo` value of `*`) can be referenced.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// Private configurations (e.g., `exportTo` set to `.`) will not be
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// available. Refer to the `exportTo` setting in `VirtualService`,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// `DestinationRule`, and `ServiceEntry` configurations for details.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hosts&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;k8s-原生-service&#34;&gt;k8s 原生 service&lt;/h3&gt;
&lt;p&gt;前面 exportTo 只能用于 DestinationRule / ServiceEntry / VirtualService，对于我们最关注的 k8s 原生的 service 对象没有涉及。而日常大多数服务都还是普通 k8s 服务，既然 ServiceEntry 这样 Istio 管理之外的服务都有可见性支持，没有理由不控制 Istio 内的服务。&lt;/p&gt;
&lt;p&gt;在 ServiceEntry 的定义中，发现注释部分有如下说明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-properties&#34; data-lang=&#34;properties&#34;&gt;message ServiceEntry {
    // For a Kubernetes Service, the equivalent effect can be achieved by setting
    // the annotation &amp;#34;networking.istio.io/exportTo&amp;#34; to a comma-separated list
    // of namespace names.
    repeated string export_to = 7;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于 k8s 原生 service，上面的注释说用 annotation &amp;ldquo;networking.istio.io/exportTo&amp;rdquo; 可以达到同样的效果。&lt;/p&gt;
&lt;p&gt;翻了一下 Istio 最新的代码，&lt;code&gt;install/kubernetes/helm/istio/charts/mixer/templates/service.yaml&lt;/code&gt; 的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-{{ $key }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{{&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;$.Release.Namespace }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;networking.istio.io/exportTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在&lt;code&gt;pilot/pkg/serviceregistry/kube/conversion.go&lt;/code&gt; 文件中有这个 annotation 的常量定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ServiceExportAnnotation specifies the namespaces to which this service should be exported to.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//   &amp;#34;*&amp;#34; which is the default, indicates it is reachable within the mesh
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//   &amp;#34;.&amp;#34; indicates it is reachable within its namespace
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ServiceExportAnnotation&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;networking.istio.io/exportTo&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;只在 &lt;code&gt;pilot/pkg/serviceregistry/kube/conversion.go&lt;/code&gt; 的 convertService() 方法中使用，这个方法将 k8s 的 api core 中的 v1.Service 转为 istio 抽象模型中的 service：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;convertService&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;svc&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;domainSuffix&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;model&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Service&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;svc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ServiceExportAnnotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;exportTo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;model&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Visibility&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Split&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;svc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ServiceExportAnnotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nx&#34;&gt;exportTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;model&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Visibility&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;逻辑很简单：用&amp;quot;,&amp;ldquo;将 annotation &amp;ldquo;networking.istio.io/exportTo&amp;rdquo; 的值拆开，然后转成对应 Visibility 对象作为 key，以 value 为 true 保存起来。&lt;/p&gt;
&lt;p&gt;Visibility 类型定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Visibility defines whether a given config or service is exported to local namespace, all namespaces or none
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Visibility&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// VisibilityPrivate implies namespace local config
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;VisibilityPrivate&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Visibility&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// VisibilityPublic implies config is visible to all
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;VisibilityPublic&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Visibility&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// VisibilityNone implies config is visible to none
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;VisibilityNone&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Visibility&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;~&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里有三个特殊值，除了前面描述到的 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; 之外，还有一个 &lt;code&gt;~&lt;/code&gt; 表示 none，不过目前没有使用。&lt;/p&gt;
&lt;p&gt;理论上说，这里可以通过 exportTo 字段（或者等效的  annotation &amp;ldquo;networking.istio.io/exportTo&amp;rdquo; ）指定特定的 namespace，比如&amp;rdquo;.,namespace1,namespace2&amp;quot;。但是目前文档中明确指出，只能使用  &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// NOTE: in the current release, the `exportTo` value is restricted to
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// &amp;#34;.&amp;#34; or &amp;#34;*&amp;#34; (i.e., the current namespace or all namespaces).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;sidecar-crd&#34;&gt;Sidecar CRD&lt;/h2&gt;
&lt;p&gt;在 Istio 1.1 中增加了新的 CRD Sidecar，具体的定义可见 &lt;a href=&#34;https://github.com/istio/api/blob/8463cba039d858e8a849847b872ecea50b0994df/networking/v1alpha3/sidecar.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/istio/api/blob/8463cba039d858e8a849847b872ecea50b0994df/networking/v1alpha3/sidecar.proto&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从中摘录部分内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sidecar 描述了 sidecar 代理的配置，sidecar 代理调解与其连接的工作负载的 inbound 和 outbound 通信。默认情况下，Istio 将为网格中的所有 Sidecar 代理服务，使其具有到达网格中每个工作负载所需的必要配置，并在与工作负载关联的所有端口上接收流量。Sidecar 资源提供了一种的方法，在向工作负载转发流量或从工作负载转发流量时，微调端口集合和代理将接收的协议。 &lt;strong&gt;此外，可以限制代理在从工作负载转发 outbound 流量时可以达到的服务集合。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sidecar CRD 的其他功能我们暂时不展开，只看和服务可见性相关的内容，看看 Sidecar CRD 是如何限制可以到达的服务结合的。文档中给出了下面这个简单例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Sidecar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;prod-us1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;egress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;prod-us1/*&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;prod-apis/*&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;istio-system/*&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个示例在 prod-us1 命名空间中声明了 Sidecar 资源，该资源配置命名空间中的 sidecars，允许出口流量到 prod-us1，prod-apis 和 istio-system 命名空间中的公共服务。&lt;/p&gt;
&lt;p&gt;但是注意这个 CRD 需要配合前面的 exportTo 字段使用：即如果 A 服务 (namespace 为 ns1) 要访问 B 服务 (namespace 为 ns2)，则需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先需要 B 服务申明 exportTo 到 ns1 中&lt;/li&gt;
&lt;li&gt;然后再通过 Sidecar CRD 设置 ns1 的 egress 的 hosts 为 &lt;code&gt;&amp;quot;ns2/*&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样通过 exportTo 字段 + Sidecar.egress.hosts 字段的配合，实现了对服务可见性的限制。&lt;/p&gt;
&lt;p&gt;基本原理不复杂，具体实现时还有一些细节需要注意。&lt;/p&gt;
&lt;h3 id=&#34;workloadselector&#34;&gt;WorkloadSelector&lt;/h3&gt;
&lt;p&gt;上面的例子没有使用 WorkloadSelector，因此设置的是整个 namespace 下所有的 Sidecar 的行为，或者说默认行为。可以通过带有 WorkloadSelector 的 Sidecar 资源来覆盖默认设置，hosts 中也可以不用通配符，实现精确控制。&lt;/p&gt;
&lt;p&gt;例如下面的例子，就明确限制了 ns1 下的 服务 service-a 可以访问 ns2 下的服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Sidecar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;service-a-sidecar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ns1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;workloadSelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;service-a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;egress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;ns2/*&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;hosts-字段&#34;&gt;hosts 字段&lt;/h3&gt;
&lt;p&gt;hosts 字段也是可以灵活设置的。文档中描述 hosts 字段为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;必需：以 namespace/dnsName 格式被监听器暴露的的一个或多个服务主机。在指定 namespace 内与 dnsName 匹配的服务将被暴露（也就是可以访问）。相应的服务可以是服务注册表中的服务（例如，Kubernetes 或 cloud foundry 服务）或使用 ServiceEntry 或 VirtualServicec 配置指定的服务。还可以使用同一名称空间中的任何关联的 DestinationRule。&lt;/p&gt;
&lt;p&gt;应使用 FQDN 格式指定 dnsName，在最左侧的组件中可以包含通配符（例如，prod / * .example.com）。将 dnsName 设置为 * 可以从指定的命名空间中选择所有服务（例如，prod/&lt;em&gt;.example.com）。命名空间也可以设置为 * 以从任何可用的命名空间中选择特定服务（例如，&amp;quot;&lt;/em&gt;/ foo.example.com&amp;quot;）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面的例子我们使用了通配符，也可以不使用通配符而明确的指定特定可以访问的服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Sidecar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;service-a-sidecar&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ns1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;workloadSelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;service-a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;egress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;ns2/service-b.example.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;ns2/service-c.example.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然，记得有个前提条件：service-b/service-c 的 k8s service 和相关的 CRD（DestinationRule / ServiceEntry / VirtualService）都必须正确的设置 exportTo。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-service-visibility/006tKfTcly1g17zrt2bzej314e0hn77k_hu9a94fd29acab9e96010f3553887718a0_92542_e8bba88c75a62222e40da2a8d732759a.webp 400w,
               /blog/istio-service-visibility/006tKfTcly1g17zrt2bzej314e0hn77k_hu9a94fd29acab9e96010f3553887718a0_92542_dd13dd3e7e5b5a9d7cfc7962870fe0c0.webp 760w,
               /blog/istio-service-visibility/006tKfTcly1g17zrt2bzej314e0hn77k_hu9a94fd29acab9e96010f3553887718a0_92542_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-service-visibility/006tKfTcly1g17zrt2bzej314e0hn77k_hu9a94fd29acab9e96010f3553887718a0_92542_e8bba88c75a62222e40da2a8d732759a.webp&#34;
               width=&#34;760&#34;
               height=&#34;332&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：这里设计的有点复杂，按照这个思路，如果要实现上述的精确限制，多个环节都必须明确设置。一旦有一个地方出错，就会无法访问，然后 debug 的过程估计不会轻松。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小结：Istio1.1 通过 exportTo 字段 + Sidecar.egress.hosts 字段的配合，实现了对服务可见性的约束&lt;/p&gt;
&lt;h2 id=&#34;代码实现&#34;&gt;代码实现&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;pilot/pkg/model/push_context.go&lt;/code&gt; 中，PushContext 在保存 Service 和 VirtualService 信息时，都分为 private 和 public 两个结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PushContext&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// privateServices are reachable within the same namespace.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;privateServicesByNamespace&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// publicServices are services reachable within the mesh.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;publicServices&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;privateVirtualServicesByNamespace&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Config&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;publicVirtualServices&lt;/span&gt;             &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Config&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以服务为例，会按照 ExportTo 字段的可见性设置来进行区分，将服务分别存放：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Caches list of services in the registry, and creates a map
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// of hostname to service
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PushContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;initServiceRegistry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;env&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Environment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;allServices&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;ns&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Namespace&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ExportTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;defaultServiceExportTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;VisibilityPrivate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;privateServicesByNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                   &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;privateServicesByNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;defaultServiceExportTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;VisibilityPublic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;publicServices&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;publicServices&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ExportTo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;VisibilityPrivate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;privateServicesByNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                   &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;privateServicesByNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;publicServices&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;publicServices&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ServiceByHostname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hostname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ServicePort2Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Hostname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Ports&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当给具体的 proxy 下发数据时：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Services returns the list of services that are visible to a Proxy in a given config namespace
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PushContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Services&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Service&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果 proxy 有 sidecar scope，则从 sidecar scope 获取 service 列表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SidecarScope&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SidecarScope&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Config&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 		   &lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SidecarProxy&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SidecarScope&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Services&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 没有 sidecar scope，就只考虑 exportTo 的影响
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;privateServices&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;privateServicesByNamespace&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;privateServices&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 只给当前 proxy 所在 namespace 的 private 服务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;privateServicesByNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ConfigNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 和 public 的服务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;publicServices&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;out&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;SidecarScope 的说明，来自代码注释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SidecarScope 是 Sidecar resource 的包装器，带有一些预处理数据，用于确定给定 Sidecar 可访问的 Service，VirtualService 和 DestinationRule。预先计算 Sidecar 的 Service，VirtualService 和 DestinationRule 可以提高性能，因为我们不再需要为每个 Sidecar 计算此列表。我们只需将 Sidecar 与 SidecarScope 相匹配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;SidecarScope&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Union of services imported across all egress listeners for use by CDS code.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;services&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;预处理的细节就不继续展开了。&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;从目前 Istio1.1 给出的信息看，Istio 开始着手限制服务间可见性，以“&lt;strong&gt;降低资源占用，提高传播效率&lt;/strong&gt;”——虽然我个人认为这个本应该是设计伊始就应该考虑的问题，但是无论如何，有比没有好。&lt;/p&gt;
&lt;p&gt;对于目前 Istio1.1 在限制服务可见性的做法，聊一下个人看法（保留后续更新修改的权利）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总算提供了一个避免全量数据下发的方式，理论上在服务数量比较多时，通过严格约束服务间的可见性，是可以让 Pilot 到 Sidecar 的数据下发数量起码降低一到两个数量级（1/10 到 1/100），Pilot 的 CPU 使用/Sidecar 的 CPU 使用/Sidecar 的内存占用 应该都可以有明显改善。当然这是理论推断，具体是否做到了还要看 Istio 1.1 的实际测试结果。拭目以待吧，希望是个惊喜。&lt;/li&gt;
&lt;li&gt;可见性的边界，是 namespace，这一点我有些担心：k8s 的 namespace 在实践中一般不会做非常细致的细分，搞不好一个体系里面可能就几个甚至一个 namespace，以 namespace 为边界来决定服务的可见性我个人觉得粒度太大——这一点稍后咨询一下各方情况再做更新。&lt;/li&gt;
&lt;li&gt;设置上有些麻烦，从上面的分析上看，要实现服务 A 对服务 B 的精确限制，需要设置服务 B 的 exportTo，包括 k8s Service/Istio VitualService/Istio Destination Rule，还要设置服务 A 的 Sidecar CRD，至少要设置 4 个地方。繁琐且容易出错，而且语义也不直白：我相信大部分同学如果没有看过类似本文这样的讲解，恐怕很难一下就把这里面的条条道道梳理清楚。&lt;/li&gt;
&lt;li&gt;只是限制服务的可见性，而不是明确的强制要求管理服务间的静态依赖关系，后者其实是我，或者说我们团队想要的。服务可见性和服务静态依赖关系之间有语义上的明确差别：服务可见性不具备强制性的，是笼统的，是可以含糊一点的，从 Istio 的意图看主要是为了效率的提升（毕竟之前的做法太浪费资源）；而服务静态依赖关系是强制性的，依赖明确，设置精准，目标是为体系中的服务调用关系进行强力管控。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先写到这，稍后深入后再补充。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #5 广州站</title>
      <link>https://cloudnative.to/event/service-mesh-meetup-05/</link>
      <pubDate>Sun, 06 Jan 2019 13:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/event/service-mesh-meetup-05/</guid>
      <description>&lt;h3 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h3&gt;
&lt;h4 id=&#34;唯品会-service-mesh-的实践分享&#34;&gt;唯品会 Service Mesh 的实践分享&lt;/h4&gt;
&lt;p&gt;郑德惠 唯品会 Java 资深开发工程师，内部 Service Mesh 框架负责人，唯品会开源项目 vjtools 重要开发者，10 年电信与互联网后台开发经验。&lt;/p&gt;
&lt;h4 id=&#34;sofamosn-持续演进路径及实践案例&#34;&gt;SOFAMosn 持续演进路径及实践案例&lt;/h4&gt;
&lt;p&gt;陈逸凡 花名无钩，蚂蚁集团资深开发工程师。专注于网络接入层，高性能服务器研发，SOFAMosn 团队核心成员&lt;/p&gt;
&lt;h4 id=&#34;在网格的边缘试探企业-istio-试水指南&#34;&gt;在网格的边缘试探——企业 Istio 试水指南&lt;/h4&gt;
&lt;p&gt;崔秀龙 HPE 软件分析师，Kubernetes 权威指南作者之一，Kubernetes、Istio 项目成员&lt;/p&gt;
&lt;h4 id=&#34;roundtable回顾-2018service-mesh-蓄势待发&#34;&gt;Roundtable：回顾 2018，Service Mesh 蓄势待发&lt;/h4&gt;
&lt;p&gt;主持人：宋净超，ServiceMesher 社区联合创始人&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Knative：重新定义 serverless</title>
      <link>https://cloudnative.to/blog/knative-redefine-serverless/</link>
      <pubDate>Wed, 02 Jan 2019 11:35:38 +0800</pubDate>
      <guid>https://cloudnative.to/blog/knative-redefine-serverless/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ypjjbxj30k00f0q6r_hu2e38c54f1ca0dc74fb8b5fbe52af5d4f_75991_8caca862e55e4bb4d08182438d9f58b8.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ypjjbxj30k00f0q6r_hu2e38c54f1ca0dc74fb8b5fbe52af5d4f_75991_c44884666fe68d56c566504b9b85a280.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ypjjbxj30k00f0q6r_hu2e38c54f1ca0dc74fb8b5fbe52af5d4f_75991_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ypjjbxj30k00f0q6r_hu2e38c54f1ca0dc74fb8b5fbe52af5d4f_75991_8caca862e55e4bb4d08182438d9f58b8.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，今天给大家来的演讲专题是“Knative：重新定义 Serverless”, 我是来自蚂蚁金服中间件的敖小剑。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yi4z9yj30k00f040w_hu6c8dfd880936928bd168c54a51b8b11b_72801_ad8683191ff95348872c424da68e970f.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yi4z9yj30k00f040w_hu6c8dfd880936928bd168c54a51b8b11b_72801_cc5b6a656b29ed33f89d43b842a685af.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yi4z9yj30k00f040w_hu6c8dfd880936928bd168c54a51b8b11b_72801_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yi4z9yj30k00f040w_hu6c8dfd880936928bd168c54a51b8b11b_72801_ad8683191ff95348872c424da68e970f.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是我的个人资料，有兴趣的同学可以关注的我的个人技术博客网站 &lt;a href=&#34;https://skyao.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://skyao.io&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yeu4gcj30k00f0my3_hua515fef7721745605fecebf67944ece4_30259_0fc0588293ecde0dbbe3bd8fa3422fe2.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yeu4gcj30k00f0my3_hua515fef7721745605fecebf67944ece4_30259_410edcf7db6c191d237a4d90ba0a6d24.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yeu4gcj30k00f0my3_hua515fef7721745605fecebf67944ece4_30259_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yeu4gcj30k00f0my3_hua515fef7721745605fecebf67944ece4_30259_0fc0588293ecde0dbbe3bd8fa3422fe2.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这次演讲的内容将会有这些，首先给大家介绍一下 knative 是什么，然后是 knative 的主要组件，让大家对 knative 有一个基本的了解。之后我会简单的对 knative 做一些分析和探讨，以及介绍一下 knative 后续的发展。希望本次的内容让大家能够对 knative 有一个基本的认知。&lt;/p&gt;
&lt;h2 id=&#34;什么是-knative&#34;&gt;什么是 knative？&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ymud2uj30k00f00tn_huf52121dfd77e20f126b04cb53bd7f52f_31765_f652f10733961e01c1716a76f09ddc8d.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ymud2uj30k00f00tn_huf52121dfd77e20f126b04cb53bd7f52f_31765_0863e7089fcf7ff8ea40f3414317c5c8.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ymud2uj30k00f00tn_huf52121dfd77e20f126b04cb53bd7f52f_31765_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ymud2uj30k00f00tn_huf52121dfd77e20f126b04cb53bd7f52f_31765_f652f10733961e01c1716a76f09ddc8d.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative 是 Google 牵头发起的 serverless 项目。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yanrbxj30k00f075o_hud74e527f5b12a99f5808428e27848f5d_43297_8a926ffc007cafa6c5090292a0bf0346.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yanrbxj30k00f075o_hud74e527f5b12a99f5808428e27848f5d_43297_41ac35ee6562f0eb9a5c38fb732c9e21.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yanrbxj30k00f075o_hud74e527f5b12a99f5808428e27848f5d_43297_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yanrbxj30k00f075o_hud74e527f5b12a99f5808428e27848f5d_43297_8a926ffc007cafa6c5090292a0bf0346.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是 Knative 的项目定义，注意这句话里面几个关键字：kubernetes，serverless，workload。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yczkalj30k00f03zo_huf0c4d3adb9b43b9ccee54c72ed7e08e1_36821_d17731272409290c8cb09c34da4bf922.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yczkalj30k00f03zo_huf0c4d3adb9b43b9ccee54c72ed7e08e1_36821_98f608bc75513eb76c1e42e90b843cd7.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yczkalj30k00f03zo_huf0c4d3adb9b43b9ccee54c72ed7e08e1_36821_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yczkalj30k00f03zo_huf0c4d3adb9b43b9ccee54c72ed7e08e1_36821_d17731272409290c8cb09c34da4bf922.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是最近几年 Google 做大型项目的常态：产品刚出来，阵营就已经很强大了，所谓先声夺人。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2y8v7unj30k00f0gmk_huca99ac5472260e4c22c7f17aafedabdd_32850_8b11e5cf497f2436512759212fbeb766.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y8v7unj30k00f0gmk_huca99ac5472260e4c22c7f17aafedabdd_32850_86b183453077a6fc01d290b50bfb5260.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y8v7unj30k00f0gmk_huca99ac5472260e4c22c7f17aafedabdd_32850_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2y8v7unj30k00f0gmk_huca99ac5472260e4c22c7f17aafedabdd_32850_8b11e5cf497f2436512759212fbeb766.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是目前 Knative 项目的进展，可以看到这是一个非常新的项目，刚刚起步。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：这是截至 2018-11-24 演讲当天的情况，到 2018 年 12 月底，knative 已经发布了 v0.2.2 和 v0.2.3 两个 bugfix 版本。但也还只是 0.2 &amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yot2wbj30k00f0dh0_hub69e694653f399be07523eb990d7bb71_39159_bc89fb75cd8e4d68d328f4ba3ed4afcc.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yot2wbj30k00f0dh0_hub69e694653f399be07523eb990d7bb71_39159_badfc8925ec225d0282552df6221baa5.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yot2wbj30k00f0dh0_hub69e694653f399be07523eb990d7bb71_39159_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yot2wbj30k00f0dh0_hub69e694653f399be07523eb990d7bb71_39159_bc89fb75cd8e4d68d328f4ba3ed4afcc.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们来看一下，在 knative 出来前，serverless 领域已有的实现，包括云端提供的产品和各种开源项目。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yo906aj30k00f0di1_hu43a20ac26055195109bb6c2a69bea857_66882_9f98794bf25aab0e32656ad856ff491a.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yo906aj30k00f0di1_hu43a20ac26055195109bb6c2a69bea857_66882_b2d9908f3df59f8f18fb5e2f0dab8524.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yo906aj30k00f0di1_hu43a20ac26055195109bb6c2a69bea857_66882_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yo906aj30k00f0di1_hu43a20ac26055195109bb6c2a69bea857_66882_9f98794bf25aab0e32656ad856ff491a.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这幅图片摘自 The New Stack 的一个 serverless 调查，我们忽略调查内容，仅仅看看这里列出来的 serverless 产品的数量——感受是什么？好多 serverless 项目，好多选择！&lt;/p&gt;
&lt;p&gt;那问题来了：到底该怎么选？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ya58f5j30k00f00up_hu32a105a28eebe57cb504319189e61707_60741_bbf00ca32024de6f54babab5b3fbad06.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ya58f5j30k00f00up_hu32a105a28eebe57cb504319189e61707_60741_172581b024523f5d1e2c73c36d9ee9f9.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ya58f5j30k00f00up_hu32a105a28eebe57cb504319189e61707_60741_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ya58f5j30k00f00up_hu32a105a28eebe57cb504319189e61707_60741_bbf00ca32024de6f54babab5b3fbad06.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这就是目前 serverless 的问题：由于缺乏标准，市场呈现碎片化。不同厂商，不同项目，各不相同，因此无论怎么选择，都面临一个风险：供应商绑定！&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ylfrl8j30k00f03zx_huc483fdfb8f222f5fe5379971cef1ca1e_46184_234af184aac8358774907249bb36139f.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ylfrl8j30k00f03zx_huc483fdfb8f222f5fe5379971cef1ca1e_46184_848080b9b557167367f7f718f9db73d4.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ylfrl8j30k00f03zx_huc483fdfb8f222f5fe5379971cef1ca1e_46184_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ylfrl8j30k00f03zx_huc483fdfb8f222f5fe5379971cef1ca1e_46184_234af184aac8358774907249bb36139f.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这段话来自 knative 的官方介绍，google 推出 knative 的理由和动机。其中第一条和第二条针对的是当前 serverless 市场碎片的现状。而第四条多云战略，则是针对供应商绑定的风险。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yjj4hrj30k00f0q4o_huce2effc190f8cbed39e3231c2c8cf9df_53821_d6cbf64661e32770aa5db36671c56d73.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yjj4hrj30k00f0q4o_huce2effc190f8cbed39e3231c2c8cf9df_53821_a7aaf9f11683f82ee3ffadfbb1e8723b.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yjj4hrj30k00f0q4o_huce2effc190f8cbed39e3231c2c8cf9df_53821_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yjj4hrj30k00f0q4o_huce2effc190f8cbed39e3231c2c8cf9df_53821_d6cbf64661e32770aa5db36671c56d73.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;google 描述 knative 的动机之一，是将云原生中三个领域的最佳实践结合起来。&lt;/p&gt;
&lt;p&gt;小结：&lt;/p&gt;
&lt;p&gt;当前 serverless 市场产品众多导致碎片化严重，存在厂商绑定风险，而 google 推出 knative，希望能提供一套简单易用的 serverless 方案，实现 serverless 的标准化和规范化。&lt;/p&gt;
&lt;h2 id=&#34;knative-的主要组件&#34;&gt;Knative 的主要组件&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2y9rm2nj30k00f0gmk_huca99ac5472260e4c22c7f17aafedabdd_32850_29e3a678822cd2045d3aa9f133a04ccc.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y9rm2nj30k00f0gmk_huca99ac5472260e4c22c7f17aafedabdd_32850_84a19e3538d14b625683e1f2b61b849f.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y9rm2nj30k00f0gmk_huca99ac5472260e4c22c7f17aafedabdd_32850_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2y9rm2nj30k00f0gmk_huca99ac5472260e4c22c7f17aafedabdd_32850_29e3a678822cd2045d3aa9f133a04ccc.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第二部分，来介绍一下 knative 的主要组件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ylvenwj30k00f0409_hue5ce241d4bb4e4a1507631fc9d2f684b_54897_1d582cbe55786cddff856b7086f99e3e.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ylvenwj30k00f0409_hue5ce241d4bb4e4a1507631fc9d2f684b_54897_29b5a0d0ecf27398d23824bac7362c97.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ylvenwj30k00f0409_hue5ce241d4bb4e4a1507631fc9d2f684b_54897_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ylvenwj30k00f0409_hue5ce241d4bb4e4a1507631fc9d2f684b_54897_1d582cbe55786cddff856b7086f99e3e.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;前面提到，google 推出 knative，试图将云原生中三个领域的最佳实践结合起来。反应到 knative 产品中，就是这三大主要组件：Build，Serving，Eventing。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yqp82zj30k00f0taa_hu6ef424b13b093219e60e0746c1665449_50722_b9a3f6d371b8e260bdd830d89ad54da9.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yqp82zj30k00f0taa_hu6ef424b13b093219e60e0746c1665449_50722_699b93fdb8d331cfc157b7664d002833.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yqp82zj30k00f0taa_hu6ef424b13b093219e60e0746c1665449_50722_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yqp82zj30k00f0taa_hu6ef424b13b093219e60e0746c1665449_50722_b9a3f6d371b8e260bdd830d89ad54da9.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative Build 组件，实现从代码到容器的目标。为什么不直接使用 dockfile 来完成这个事情？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ykxse9j30k00f0q51_hufa7e8b7ac131e71fe9377223c7879178_65665_fb67863cdec4ff756ba75fc88384ba69.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ykxse9j30k00f0q51_hufa7e8b7ac131e71fe9377223c7879178_65665_7e26c82ebf3a34d0a9a56b190ca0f73f.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ykxse9j30k00f0q51_hufa7e8b7ac131e71fe9377223c7879178_65665_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ykxse9j30k00f0q51_hufa7e8b7ac131e71fe9377223c7879178_65665_fb67863cdec4ff756ba75fc88384ba69.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative Build 在实现时，是表现为 kubernetes 的 CRD，通过 yaml 文件来定义构建过程。这里引入了很多概念如：build，builder，step，template，source 等。另外支持用 service account 做身份验证。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ydy8wvj30k00f00uh_hueaca8b4503ef1b00224eb2add4a883d7_55337_8b1f1d49c929bd6feca9a8cc12ee39e5.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ydy8wvj30k00f00uh_hueaca8b4503ef1b00224eb2add4a883d7_55337_af77b4922540fa58bdb0d37502c4c171.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ydy8wvj30k00f00uh_hueaca8b4503ef1b00224eb2add4a883d7_55337_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ydy8wvj30k00f00uh_hueaca8b4503ef1b00224eb2add4a883d7_55337_8b1f1d49c929bd6feca9a8cc12ee39e5.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative Serving 组件的职责是运行应用以对外提供服务，即提供服务、函数的运行时支撑。&lt;/p&gt;
&lt;p&gt;注意定义中的三个关键：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;kubernetes-based：基于 k8s，也仅支持 k8s，好处是可以充分利用 k8s 平台的能力&lt;/li&gt;
&lt;li&gt;scale-to-zero：serverless 最重要的卖点之一，当然要强调&lt;/li&gt;
&lt;li&gt;request-driven compute：请求驱动的计算&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;值得注意的是，除了 k8s 之外，还有另外一个重要基础：istio！后面会详细聊这个。&lt;/p&gt;
&lt;p&gt;Knative Serving 项目同样也提供了自己的中间件原语，以支持如图所示的几个重要特性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ybms2rj30k00f00um_hu1681e8638b72faf159ba9cb1d81e9d85_59129_17d1543bb13ec8811f2a5e6757b6d7cc.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ybms2rj30k00f00um_hu1681e8638b72faf159ba9cb1d81e9d85_59129_a7bbaf4310ff0883601b249cf9e5d5a4.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ybms2rj30k00f00um_hu1681e8638b72faf159ba9cb1d81e9d85_59129_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ybms2rj30k00f00um_hu1681e8638b72faf159ba9cb1d81e9d85_59129_17d1543bb13ec8811f2a5e6757b6d7cc.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;knative 中有大量的概念抽象，而在这之后的背景，说起来有些意思：knative 觉得 kubernetes 和 istio 本身的概念非常多，多到难于理解和管理，因此 knative 决定要自己提供更高一层的抽象。至于这个做法，会是釜底抽薪解决问题，还是雪上加霜让问题更麻烦&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;knative 的这些抽象都是基于 kubernetes 的 CRD 来实现，具体抽象概念有：Service、Route、Configuration 和 Revision。特别提醒的是，右边图中的 Service 是 knative 中的 service 概念，&lt;code&gt;service.serving.knative.dev&lt;/code&gt;，而不是大家通常最熟悉的 k8s 的 service。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ynrcmoj30k00f0wgc_hu2e1b476413655045b457777996c7cf5d_58829_d79aa7897a53faa25f4d304bbc39e1b0.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ynrcmoj30k00f0wgc_hu2e1b476413655045b457777996c7cf5d_58829_205cef5fe8dc2a603922fbaadde82bbf.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ynrcmoj30k00f0wgc_hu2e1b476413655045b457777996c7cf5d_58829_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ynrcmoj30k00f0wgc_hu2e1b476413655045b457777996c7cf5d_58829_d79aa7897a53faa25f4d304bbc39e1b0.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于 Knative Serving 组件，最重要的特性就是自动伸缩的能力。目前伸缩边界支持从 0 到无限，容许通过配置设置。&lt;/p&gt;
&lt;p&gt;Knative 目前是自己实现的 autoscaler，原来比较简单：Revision 对应的 pod 由 k8s deployment 管理，pod 上的工作负载上报 metrics，汇总到 autoscaler 分析判断做决策，在需要时修改 replicas 数量来实现自动伸缩（后面会再讲这块存在的问题）。&lt;/p&gt;
&lt;p&gt;当收缩到 0，或者从 0 扩展到 1 时，情况会特别一些。knative 在这里提供了名为 Activator 的设计，如图所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Istio Route 控制流量走向，正常情况下规则设置为将流量切到工作负载所在的 pod&lt;/li&gt;
&lt;li&gt;当没有流量，需要收缩到 0 时，规则修改为将流量切到 Activator，如果一直没有流量，则什么都不发生。此时 autoscaler 通过 deployment 将 replicas 设置为 0。&lt;/li&gt;
&lt;li&gt;当新的流量到来时，流量被 Activator 接收，Activator 随即拉起 pod，在 pod 和工作负载准备好之后，再将流量转发过去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yj0vbkj30k00f0wfe_huc994e757b91faa9dc8304fa51a13449c_30566_b2d674da5a5716987cb8c13f47696e36.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yj0vbkj30k00f0wfe_huc994e757b91faa9dc8304fa51a13449c_30566_1a9a7f53b385326a683d93b15695b030.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yj0vbkj30k00f0wfe_huc994e757b91faa9dc8304fa51a13449c_30566_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yj0vbkj30k00f0wfe_huc994e757b91faa9dc8304fa51a13449c_30566_b2d674da5a5716987cb8c13f47696e36.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative Eventing 组件负责事件绑定和发送，同样提供多个抽象概念：Flow，Source，Bus，以帮助开发人员摆脱概念太多的负担（关于这一点，我保留意见）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ynaza9j30k00f075w_hu71a5b268e65c8b821ce96f61ac9eb878_52421_efabe039b4b0a0b0bd6b66d4fc7a66c0.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ynaza9j30k00f075w_hu71a5b268e65c8b821ce96f61ac9eb878_52421_9ddbfb53c6cdf64b600f72ee404025ef.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ynaza9j30k00f075w_hu71a5b268e65c8b821ce96f61ac9eb878_52421_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ynaza9j30k00f075w_hu71a5b268e65c8b821ce96f61ac9eb878_52421_efabe039b4b0a0b0bd6b66d4fc7a66c0.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Bus 是对消息总线的抽象。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yr4beaj30k00f0wg3_hu1345244a9261a39484efd8813e4dea28_51984_7b774e3bc5e9cc8447eef57b05da1716.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yr4beaj30k00f0wg3_hu1345244a9261a39484efd8813e4dea28_51984_6d0a792fc94133786ca41d3d412127d8.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yr4beaj30k00f0wg3_hu1345244a9261a39484efd8813e4dea28_51984_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yr4beaj30k00f0wg3_hu1345244a9261a39484efd8813e4dea28_51984_7b774e3bc5e9cc8447eef57b05da1716.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Source 是事件数据源的抽象。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yk1kkij30k00f0q4j_huecb9741d57c0dfc6ccdac439bf9ad492_51245_d024de5537a54ada9d79e3a126222383.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yk1kkij30k00f0q4j_huecb9741d57c0dfc6ccdac439bf9ad492_51245_5fc39a8e92f3ea1ff982ca26d528727f.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yk1kkij30k00f0q4j_huecb9741d57c0dfc6ccdac439bf9ad492_51245_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yk1kkij30k00f0q4j_huecb9741d57c0dfc6ccdac439bf9ad492_51245_d024de5537a54ada9d79e3a126222383.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative 在事件定义方面遵循了 cloudevents 规范。&lt;/p&gt;
&lt;p&gt;小结：&lt;/p&gt;
&lt;p&gt;简单介绍了一下 knative 中的三大组件，让大家对 knative 的大体架构和功能有个基本的认知。这次就不再继续深入 knative 的实现细节，以后有机会再展开。&lt;/p&gt;
&lt;h2 id=&#34;knative-分析和探讨&#34;&gt;Knative 分析和探讨&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yfiktvj30k00f0q3w_hu3ad5eec275c1ff488717d0ae2cee765f_31059_1f408911414233939585226dbcf73a2f.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yfiktvj30k00f0q3w_hu3ad5eec275c1ff488717d0ae2cee765f_31059_a73227aafa0af29e1f38ba5a896de9f1.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yfiktvj30k00f0q3w_hu3ad5eec275c1ff488717d0ae2cee765f_31059_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yfiktvj30k00f0q3w_hu3ad5eec275c1ff488717d0ae2cee765f_31059_1f408911414233939585226dbcf73a2f.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在第三部分，我们来分析探讨一下 knative 的产品定位，顺便也聊一下为什么我们会看好 knative。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ygta4hj30k00f0758_hu3a416105d110e1d9b8b1185e148ff9bf_30481_40e956d60f9987d2694e7bd21ab38ec2.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ygta4hj30k00f0758_hu3a416105d110e1d9b8b1185e148ff9bf_30481_74e8334a4744367534b593ada68e3303.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ygta4hj30k00f0758_hu3a416105d110e1d9b8b1185e148ff9bf_30481_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ygta4hj30k00f0758_hu3a416105d110e1d9b8b1185e148ff9bf_30481_40e956d60f9987d2694e7bd21ab38ec2.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先，最重要的一点是：knative &lt;strong&gt;不是&lt;/strong&gt;一个 Serverless 实现，而是一个 Serviceless 平台。&lt;/p&gt;
&lt;p&gt;也就是说，knative 不是在现有市场上的 20 多个 serverless 产品和开源项目的基础上简单再增加一个新的竞争者，而是通过建立一个标准而规范的 serverless 平台，容许其他 serverless 产品在 knative 上运行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yq94l2j30k00f00ug_hu0d5076fe3d1c61a8cbf2d52f299fa31d_53541_cb31500bde8addb9c7697694dce2eba0.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yq94l2j30k00f00ug_hu0d5076fe3d1c61a8cbf2d52f299fa31d_53541_a9c86ae0a4d5256b6ad6bd9c647c92c9.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yq94l2j30k00f00ug_hu0d5076fe3d1c61a8cbf2d52f299fa31d_53541_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yq94l2j30k00f00ug_hu0d5076fe3d1c61a8cbf2d52f299fa31d_53541_cb31500bde8addb9c7697694dce2eba0.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative 在产品规划和设计理念上也带来了新的东西，和传统 serverless 不同。工作负载和平台支撑是 knative 最吸引我们的地方。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yfrimxj30k00f00tv_hu3b2ca9fdbb8f6479329f6b1733b4f309_38383_4437dd7475c6b47986c0ff0fd1f91af0.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yfrimxj30k00f00tv_hu3b2ca9fdbb8f6479329f6b1733b4f309_38383_85334dce1ce8dde5d9cdc5ef3b298dbc.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yfrimxj30k00f00tv_hu3b2ca9fdbb8f6479329f6b1733b4f309_38383_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yfrimxj30k00f00tv_hu3b2ca9fdbb8f6479329f6b1733b4f309_38383_4437dd7475c6b47986c0ff0fd1f91af0.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;要不要 Istio？这是 knative 一出来就被人诟病和挑战的点：因为 Istio 的确是复杂度有点高。而 k8s 的复杂度，还有 knative 自身的复杂度都不低，再加上 Istio&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;关于这一点，个人的建议是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果原有系统中没有规划 Istio/Service mesh 的位置，那么为了 knative 而引入 Istio 的确是代价偏高。可以考虑用其他方式替代，最新版本的 knative 已经实现了对 Istio 的解耦，容许替换。&lt;/li&gt;
&lt;li&gt;如果本来就有规划使用 Istio/Service mesh，比如像我们蚂蚁这种，那么 knative 对 Istio 的依赖就不是问题了，反而可以组合使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而 kubernetes + servicemesh + serverless 的组合，我们非常看好。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ydgkfej30k00f0abb_hudf234930641456788813ea2fe4238e59_41623_6d34a9adfb2ce376830661410ca06bfa.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ydgkfej30k00f0abb_hudf234930641456788813ea2fe4238e59_41623_c43d249e027cef656472023cca5dfe8e.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ydgkfej30k00f0abb_hudf234930641456788813ea2fe4238e59_41623_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ydgkfej30k00f0abb_hudf234930641456788813ea2fe4238e59_41623_6d34a9adfb2ce376830661410ca06bfa.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当然，knative 体系的复杂度问题是无法回避的：kubernetes，istio，knative 三者都是复杂度很高的产品，加在一起整体复杂度就非常可观了，挑战非常大。&lt;/p&gt;
&lt;h2 id=&#34;knative-后续发展&#34;&gt;Knative 后续发展&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ykhnnvj30k00f0gmk_huea4ad3711f915d08404edfd08f723161_30844_a395372f5c07bf53fe943bbe4b7353c5.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ykhnnvj30k00f0gmk_huea4ad3711f915d08404edfd08f723161_30844_157123fad9272debcfe89a3c3028db50.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ykhnnvj30k00f0gmk_huea4ad3711f915d08404edfd08f723161_30844_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ykhnnvj30k00f0gmk_huea4ad3711f915d08404edfd08f723161_30844_a395372f5c07bf53fe943bbe4b7353c5.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第四个部分，我们来展望一下 knative 的后续发展，包括如何解决一些现有问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yb5n5nj30k00f03zp_hu4dc6d20bbc31afd3b64db3e15196b381_40220_a7fddc86b6c3c087b2b56dd497eed34f.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yb5n5nj30k00f03zp_hu4dc6d20bbc31afd3b64db3e15196b381_40220_6d83bd91a024c0cd20a8588f062f9fef.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yb5n5nj30k00f03zp_hu4dc6d20bbc31afd3b64db3e15196b381_40220_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yb5n5nj30k00f03zp_hu4dc6d20bbc31afd3b64db3e15196b381_40220_a7fddc86b6c3c087b2b56dd497eed34f.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第一个问题就是性能问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yefneyj30k00f075m_hu61034b31b827e1e66b7310fdab5fc0c5_44136_0afcb1809dfdf154bc607598a568f8df.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yefneyj30k00f075m_hu61034b31b827e1e66b7310fdab5fc0c5_44136_c6fa5d25500990b762ff60c6fdec641f.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yefneyj30k00f075m_hu61034b31b827e1e66b7310fdab5fc0c5_44136_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yefneyj30k00f075m_hu61034b31b827e1e66b7310fdab5fc0c5_44136_0afcb1809dfdf154bc607598a568f8df.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Queue Proxy 也是一个现存的需要替换的模块。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yimwxxj30k00f00tt_hu0be1fd9738a3095c770e9cb6d2ee9484_36300_b6abea0a1b297d976128d040e3a91965.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yimwxxj30k00f00tt_hu0be1fd9738a3095c770e9cb6d2ee9484_36300_9d913121a5e33cea3eec42ae7755b680.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yimwxxj30k00f00tt_hu0be1fd9738a3095c770e9cb6d2ee9484_36300_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yimwxxj30k00f00tt_hu0be1fd9738a3095c770e9cb6d2ee9484_36300_b6abea0a1b297d976128d040e3a91965.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;前面讲过 knative 的 Autoscaler 是自行实现的，而 k8s 目前已经有比较健全原生能力：HPA 和 Custom Metrics。目前 knative 已经有计划要转而使用 k8s 的原生能力。这也符合 Cloud Native 的玩法：将基础能力下沉到 k8s 这样的基础设施，上层减负。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ycjvmtj30k00f0q41_hu95812786dcf379c957a75b50e4897542_36614_c9e54e96f277e4a202c4b09c17dd5788.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ycjvmtj30k00f0q41_hu95812786dcf379c957a75b50e4897542_36614_4d8b3637cf7427f7f38e336ef34178fc.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ycjvmtj30k00f0q41_hu95812786dcf379c957a75b50e4897542_36614_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ycjvmtj30k00f0q41_hu95812786dcf379c957a75b50e4897542_36614_c9e54e96f277e4a202c4b09c17dd5788.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了下沉到 k8s 之外，autoscaler 还有很多细节需要在后续版本中完善。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2y8qjlcj30k00f075c_huadcfdaf0ed6a9d0d937cce59e38515bc_35841_94276822fad83c7e41d2dae63879d8bc.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y8qjlcj30k00f075c_huadcfdaf0ed6a9d0d937cce59e38515bc_35841_a7b11d4d13edc1347a3cba9ab5852aa4.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y8qjlcj30k00f075c_huadcfdaf0ed6a9d0d937cce59e38515bc_35841_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2y8qjlcj30k00f075c_huadcfdaf0ed6a9d0d937cce59e38515bc_35841_94276822fad83c7e41d2dae63879d8bc.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对事件源和消息系统的支持也远不够完善，当然考虑到目前才 0.2.0 版本，可以理解。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2y989gtj30k00f0gn0_hu7bb2da260d1e907cdee49288cf8f8597_45706_e992ff9206fc6338363763413c975459.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y989gtj30k00f0gn0_hu7bb2da260d1e907cdee49288cf8f8597_45706_ffd9377a8421846532ae8c739c716ad4.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y989gtj30k00f0gn0_hu7bb2da260d1e907cdee49288cf8f8597_45706_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2y989gtj30k00f0gn0_hu7bb2da260d1e907cdee49288cf8f8597_45706_e992ff9206fc6338363763413c975459.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;目前 knative 还没有规划 workflow 类的产品。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ymbqcvj30k00f0wgf_hu8b0a32f7a7bee8fce1a066a066f71874_60472_34a44d1ecf0f1f770ab25ce726ad303d.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ymbqcvj30k00f0wgf_hu8b0a32f7a7bee8fce1a066a066f71874_60472_39f6d9feba776124828a14a7a5b549a4.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ymbqcvj30k00f0wgf_hu8b0a32f7a7bee8fce1a066a066f71874_60472_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ymbqcvj30k00f0wgf_hu8b0a32f7a7bee8fce1a066a066f71874_60472_34a44d1ecf0f1f770ab25ce726ad303d.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在网络路由能力方面也有很多欠缺，上面是 knative 在文档中列出来的需求列表。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yc0iq9j30k00f0gn5_huef88602e855103db1b4f015e2bcd2030_47520_992662fee157e48a8843b13ce9e5a595.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yc0iq9j30k00f0gn5_huef88602e855103db1b4f015e2bcd2030_47520_c8bf9e50f05d01fc1739fa8572b2d590.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yc0iq9j30k00f0gn5_huef88602e855103db1b4f015e2bcd2030_47520_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yc0iq9j30k00f0gn5_huef88602e855103db1b4f015e2bcd2030_47520_992662fee157e48a8843b13ce9e5a595.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后聊聊 knative 的可拔插设计，这是 knative 在架构设计上的一个基本原则：顶层松耦合，底层可拔插。&lt;/p&gt;
&lt;p&gt;最顶层是 Build / Serving / Eventing 三大组件，中间是各种能力，通过 k8s 的 CRD 方式来进行声明，然后底层是各种实现，按照 CRD 的要求进行具体的实现。&lt;/p&gt;
&lt;p&gt;在这个体系中，用户接触的是 Build / Serving / Eventing 通用组件，通过通过标准的 CRD 进行行为控制，而和底层具体的实现解耦。理论上，之后在实现层做适配，knative 就可以运行在不同的底层 serverless 实现上。从而实现 knative 的战略目标：提供 serverless 的通用平台，实现 serverless 的标准化和规范化。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yhmny2j30k00f03zg_huf1eb1a2f7f354f340fdc151551e41aee_30607_b92395fc38a1a04ab517015b83e061b8.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yhmny2j30k00f03zg_huf1eb1a2f7f354f340fdc151551e41aee_30607_c9af8c20eedf201bf22dc6de1d890323.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yhmny2j30k00f03zg_huf1eb1a2f7f354f340fdc151551e41aee_30607_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yhmny2j30k00f03zg_huf1eb1a2f7f354f340fdc151551e41aee_30607_b92395fc38a1a04ab517015b83e061b8.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，我们对 knative 做一个简单总结。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yg9jwdj30k00f0q49_hu6ecf96dbbd9752b5d8fb6cbce4e1c478_43341_a5f5fcd2d47bcf7cc3b9d336a3a69f02.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yg9jwdj30k00f0q49_hu6ecf96dbbd9752b5d8fb6cbce4e1c478_43341_fd231b6f180575fd67abedc9e23fd604.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yg9jwdj30k00f0q49_hu6ecf96dbbd9752b5d8fb6cbce4e1c478_43341_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yg9jwdj30k00f0q49_hu6ecf96dbbd9752b5d8fb6cbce4e1c478_43341_a5f5fcd2d47bcf7cc3b9d336a3a69f02.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;先谈一下 knative 的优势，首先是 knative 自身的几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产品定位准确：针对市场现状，不做竞争者而是做平台&lt;/li&gt;
&lt;li&gt;技术方向明确：基于 k8s，走 cloud native 方向&lt;/li&gt;
&lt;li&gt;推出时机精准：k8s 大势已成，istio 接近成熟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，再次强调：kubernetes + service mesh + serverless 的组合，在用好的前提下，应该威力不凡。&lt;/p&gt;
&lt;p&gt;此外，knative 在负载的支撑上，不拘泥于传统的 FaaS，可以支持 BaaS 和传统应用，在落地时适用性会更好，使用场景会更广泛。（备注：在这里我个人有个猜测，knative 名字中 native 可能指的是 native workload，即在 k8s 和 cloud native 语义下的原生工作负载，如果是这样，那么 google 和 knative 的这盘棋就下的有点大了。）&lt;/p&gt;
&lt;p&gt;最后，考虑到目前 serverless 的市场现状，对 serverless 做标准化和规范化，出现一个 serverless 平台，似乎也是一个不错的选择。再考虑到 google 拉拢大佬和社区一起干的一贯风格，携 k8s 和 cloud native 的大势很有可能实现这个目标。&lt;/p&gt;
&lt;p&gt;当然，knative 目前存在的问题也很明显，细节不说，整体上个人感觉有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成熟度：目前才 0.2 版本，实在太早期，太多东西还在开发甚至规划中。希望随着时间的推移和版本演进，knative 能尽快走向成熟。&lt;/li&gt;
&lt;li&gt;复杂度：成熟度的问题还好说，总能一步一步改善的，无非是时间问题。但是 knative 的系统复杂度过高的问题，目前看来几乎是不可避免的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，对 knative 的总结，就一句话：&lt;strong&gt;前途不可限量，但是成长需要时间&lt;/strong&gt;。让我们拭目以待。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yh7tksj30k00f03zu_hu5dbeb818854d87e92c1999f1399d508a_42413_ca72458bc3535d1d3762aa2c97dee251.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yh7tksj30k00f03zu_hu5dbeb818854d87e92c1999f1399d508a_42413_7e93c7dfb2fe3380fa10c21b2437d363.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yh7tksj30k00f03zu_hu5dbeb818854d87e92c1999f1399d508a_42413_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yh7tksj30k00f03zu_hu5dbeb818854d87e92c1999f1399d508a_42413_ca72458bc3535d1d3762aa2c97dee251.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;广告时间，欢迎大家加入 servicemesher 社区，也可以通过关注 servicemesher 微信公众号来及时了解 service mesh 技术的最新动态。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服 Service Mesh 渐进式迁移方案</title>
      <link>https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/</link>
      <pubDate>Thu, 29 Nov 2018 14:51:19 +0800</pubDate>
      <guid>https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxs8jrwxj30qo0f0dip_hu97ec65a8b499e9efd1b82c94e340b8ac_157885_f33814e25ee7dd3a049e2a08ad404675.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxs8jrwxj30qo0f0dip_hu97ec65a8b499e9efd1b82c94e340b8ac_157885_13eea31f47fe2c9c4edac15235b705e1.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxs8jrwxj30qo0f0dip_hu97ec65a8b499e9efd1b82c94e340b8ac_157885_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxs8jrwxj30qo0f0dip_hu97ec65a8b499e9efd1b82c94e340b8ac_157885_f33814e25ee7dd3a049e2a08ad404675.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，今天给大家带来的演讲主题是“蚂蚁金服 Service Mesh 渐进式迁移方案”，给大家介绍一下我们蚂蚁金服主站的 Service Mesh 迁移方案，在稍后的内容中我会给大家解释什么是“渐进式”。今天的演讲方式有些特殊，将会是两位讲师合作。我是敖小剑，来自蚂蚁金服中间件团队，另外一位讲师 龙轼，来自 UC 基础研发部。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsexhquj30qo0f0n08_hu2b8fd6bbe552567e595be84c9ab79e42_65419_62f9fd671254078c5efbf8fa7139883a.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsexhquj30qo0f0n08_hu2b8fd6bbe552567e595be84c9ab79e42_65419_ba2e610959591d5a090605a1cc5fa997.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsexhquj30qo0f0n08_hu2b8fd6bbe552567e595be84c9ab79e42_65419_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsexhquj30qo0f0n08_hu2b8fd6bbe552567e595be84c9ab79e42_65419_62f9fd671254078c5efbf8fa7139883a.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今天的内容将会有四块主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Service Mesh 演进路线：介绍蚂蚁金服计划在主站落地 Service Mesh 的方案，由于涉及到大量的存量应用和超大规模，又要保证迁移过程的平滑，因此我们的落地方案相比社区方案要复杂的多。&lt;/li&gt;
&lt;li&gt;实现平滑迁移的关键：介绍在整个迁移方案中，为了实现平滑迁移的几个关键做法，然后今天我们将详细展开其他的一个关键点：DNS 寻址方案。&lt;/li&gt;
&lt;li&gt;DNS 寻址方案的演进：详细介绍 Kubernetes/Istio/SOFAMesh 一路演进过来的 DNS 寻址方式&lt;/li&gt;
&lt;li&gt;DNS 寻址方案的后续规划：介绍我们在 DNS 寻址方案上的后续规划&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前两块内容将由我来为大家介绍，后两块内容将由我的同事 龙轼 为大家介绍。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsiq2z5j30qo0f0grx_hu64020a3602ac53da7d01a8fd72086965_91665_1f6c0b7edf015c706470e518dbe2c3a8.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsiq2z5j30qo0f0grx_hu64020a3602ac53da7d01a8fd72086965_91665_1ee8402a9ca38edf73fe7ac0845e337a.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsiq2z5j30qo0f0grx_hu64020a3602ac53da7d01a8fd72086965_91665_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsiq2z5j30qo0f0grx_hu64020a3602ac53da7d01a8fd72086965_91665_1f6c0b7edf015c706470e518dbe2c3a8.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在展开内容之前，先看一下背景，Service Mesh 在蚂蚁金服主站落地的背景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标：需要满足我们对长期目标的认可，具体指服务间通讯走 Service Mesh，而且是 Istio 这种带完整的控制平面的 Service Mesh 形态，基础设施要构建在 k8s 之上，而应用的形态要向微服务靠拢。&lt;/li&gt;
&lt;li&gt;现状：而现实是存在很多挑战，首先还有很多应用没有实现微服务化，而且我们的 k8s 普及程度也不够，还有非常多的应用没有运行在 kubernets 之上。Istio 的成熟程度也稍显不足，不够稳定，更大的挑战的是 Istio 目前无法原生支持我们蚂蚁金服的规模，我们还在试图对 Istio 进行改进和扩展。最后，在落地时必须考虑的非常现实的一点：现有系统中为数众多的应用不可能一夜之间全部迁移。&lt;/li&gt;
&lt;li&gt;关键需求：因此在落地实施时，非常重要的需求是：要实现平滑迁移。简单说，微服务 + Service Mesh + kubernetes 是我们的目标，但是如何从现有体系出发，向目标平稳和坚实的迈进，必须给出可行的实践指导。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天演讲的内容，要给大家介绍的就是，在这样的背景下，我们蚂蚁金服选择的 Service Mesh 主站落地演进方案。这个方案预期会在 2019 年初全面铺开。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsmb5l9j30qo0f0q4s_hu3a88acea1340839df2de8bcade3af543_76376_73fbbac811908623ed355ce1dd2e4ef3.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsmb5l9j30qo0f0q4s_hu3a88acea1340839df2de8bcade3af543_76376_e26a559b962fd540674880df4604155b.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsmb5l9j30qo0f0q4s_hu3a88acea1340839df2de8bcade3af543_76376_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsmb5l9j30qo0f0q4s_hu3a88acea1340839df2de8bcade3af543_76376_73fbbac811908623ed355ce1dd2e4ef3.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;主站落地方案的实施原则，这是我们在过去半年的实践中，总结归纳出来的行为指导：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符合远期规划：一定要有清晰的长期目标，明确的知道未来的大方向。避免走弯路，避免浪费投资，理想状态是计划中的每一步都可以为下一步奠定坚实的基础。即使因为某些原因不得已妥协或绕行，也应该清晰的知道后面应该如何回归，谢绝中途推倒重来——代价太高，无法承受。&lt;/li&gt;
&lt;li&gt;循序渐进：认清现实，如此之大的变革，一定是需要分步进行，不要心存一步登天的幻想，现实可行的方式是小步快跑。将整个过程拆解为若干个大步骤，每一步的工作量和复杂度都控制在一个可以接受的范围内，以保证每一步都简单方便，切实可行。&lt;/li&gt;
&lt;li&gt;有可操作性：在操作层面上，要有足够的弹性，即每个步骤中的工作内容，都应该是可以分批进行。以步步为营的方式，逐步扩大战果，杜绝一刀切。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在接下来的演进路线中，大家将会体会到这三个原则在实际落地时的指导作用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsq62x9j30qo0f0ac4_hu1c9b4e2addd8554b91c815c06e95bc51_126895_110373dc85066c0081c3b28f9979c821.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsq62x9j30qo0f0ac4_hu1c9b4e2addd8554b91c815c06e95bc51_126895_5ed9161c5e41a45f8fd0d391349ecf55.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsq62x9j30qo0f0ac4_hu1c9b4e2addd8554b91c815c06e95bc51_126895_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsq62x9j30qo0f0ac4_hu1c9b4e2addd8554b91c815c06e95bc51_126895_110373dc85066c0081c3b28f9979c821.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个图的信息量有点大，描述的是 Service Mesh 和 k8s 落地可能的多种演进路线。&lt;/p&gt;
&lt;p&gt;我们先从最下面开始看，这是当前蚂蚁金服主站大多数应用的现状：即应用&amp;quot;部署在非 k8s 上&amp;quot;，应用也&amp;quot;不是 Service Mesh 形态&amp;quot;。然后看最上面，这是我们期望的蚂蚁金服主站未来的应用终极形态：应用&amp;quot;部署在 k8s 上&amp;quot;，应用也迁移到了&amp;quot;Service Mesh 形态&amp;quot;。&lt;/p&gt;
&lt;p&gt;这里有个特别的地方，我们将 Service Mesh 形态细分为两种模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Sidecar 模式：只有 Sidecar，没有控制平面，和外部系统的各种集成都是在 Sidecar 中直接进行。这是第一代的 Service Mesh，Linkerd/Envoy 都是如此，华为基于 ServiceComb 演进而来的 mesher，新浪微博的 Mesh，包括我们蚂蚁金服基于 MOSN 开发的用于取代多语言客户端的 Mesh 方案。&lt;/li&gt;
&lt;li&gt;Istio 模式：有完善的控制平面，可以提供强大的控制能力，而且从数据平面分离，这是第二代的 Service Mesh，典型如 Istio 和 Conkduit/Linkerd 2.0。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之所以将 Service Mesh 形态细分，是因为我们有着这样一个特殊背景：目前的原生 Istio 无法支撑我们蚂蚁金服的规模，因此在改进完善 Istio 之前，我们不得不暂时在 Sidecar 模式下短暂停留。另外一个原因就是考虑到存量应用的迁移，多一个 Sidecar 模式作为中间缓冲，会让整个迁移过程平滑很多。&lt;/p&gt;
&lt;p&gt;现在我们来介绍图中展示的四条演进路线：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左边的路线 1，思路是先将应用迁移 k8s 部署，再迁移到 Service Mesh 形态。这条路线的最大好处，是过程中每个阶段的绝大多数投资都将最终得以保留，因为符合 k8s+service mesh 的远期目标&lt;/li&gt;
&lt;li&gt;右边的路线 2，思路是跳过 k8s，先迁移到 Service Mesh 形态，一路演进到 Istio 模式，然后最后迁移到 k8s。&lt;/li&gt;
&lt;li&gt;中间的路线 3，直接一步到位，这个路线是 Istio 默认的方式，或者说 Istio 根本没有考虑过迁移的问题，默认客户已经有完善的 k8s，然后将改造好的应用直接部署在 Istio 上。这个路线对于蚂蚁金服主站的复杂场景，当然是不现实的。（补充：只是对蚂蚁金服主站不合适，对于大多数公司，规模不是那么巨大，也没有历史负担，也有 k8s 基础，完全可行。）&lt;/li&gt;
&lt;li&gt;还有一条特别的路线 4，走位飘忽，先和路线 2 一样迁移到 Sidecar 模式，然后走回路线 1，上 k8s，再在有 k8s 支持的情况下继续演进到 Istio 模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们来详细分析各条演进路线的优劣和实施条件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxstzrdqj30qo0f040q_hud604359bb159cd888459cd7b8c11da78_107276_8828b4bb07477483cc76a09300615276.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxstzrdqj30qo0f040q_hud604359bb159cd888459cd7b8c11da78_107276_5851883b9bb65da5a0a926f0a78b4b04.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxstzrdqj30qo0f040q_hud604359bb159cd888459cd7b8c11da78_107276_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxstzrdqj30qo0f040q_hud604359bb159cd888459cd7b8c11da78_107276_8828b4bb07477483cc76a09300615276.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;演进路线 2，和路线 1 的核心差别，在于：是先上 k8s，还是先上 Service Mesh。而且路线 2 是在非 k8s 条件下一路演进 Service Mesh 到我们期望的终极形态 Istio 模式，这意味着过程中和最终目标有非常大的偏移。&lt;/p&gt;
&lt;p&gt;演进路线 2 的好处，在于第一步非常的自然：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有 k8s 的限制，因此不依赖基础设施，实施方便。毕竟，k8s 普及度是个大问题&lt;/li&gt;
&lt;li&gt;在原有的侵入式框架的客户端 SDK 基础上，通过包裹一个 proxy，重用原有 SDK 的能力，可以非常快速的得到一个基本可用的 Sidecar&lt;/li&gt;
&lt;li&gt;除了多一个 proxy 外，没有引入太多的新概念和新思想，符合现有开发人员/运维人员的心智，容易接受&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，路线 2 特别容易落地，可以快速达成短期目标，直接拿到 Service Mesh 的部分红利，如：多语言支持，方便类库升级等。&lt;/p&gt;
&lt;p&gt;但是，这个路线的问题在于再往后走，开始完善 Service Mesh 的功能以向 Istio 模式靠拢时，由于没有 k8s 的底层支持，因此不得不做大量的工作来提供类 k8s 的功能。尤其是 Istio 的非 k8s 支持，官方方案基本上只是一个 demo，完全不具备生产可用性，要完善好，工作量很大。而关键点在于，这些投入，在迁移到 k8s 时，又因为和 k8s 提供的功能重复而被放弃。&lt;/p&gt;
&lt;p&gt;因此，结合我们前面的原则（符合远期规划，不浪费投资），路线 2 对蚂蚁金服主站落地是不合适的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsx61iuj30qo0f0wg9_hu754dbfd5aac8f8067f38b644650fa68b_103508_077b0f453c0ce25bbf07f06007bf4d26.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsx61iuj30qo0f0wg9_hu754dbfd5aac8f8067f38b644650fa68b_103508_83a80d767dc13dbb0215448a2710dd60.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsx61iuj30qo0f0wg9_hu754dbfd5aac8f8067f38b644650fa68b_103508_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsx61iuj30qo0f0wg9_hu754dbfd5aac8f8067f38b644650fa68b_103508_077b0f453c0ce25bbf07f06007bf4d26.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;演进路线 4 是一个非常特殊的路线，可以理解为路线 1（先上 k8s 再上 Service Mesh）的短期妥协版本。因为路线 1 的前提条件是要先大规模铺开 k8s，将现有应用迁移到 k8s 之后再继续往 Service Mesh 演进，这对于还没有普及 k8s 的公司来说是一个非常高的门槛，很容易因此受阻而无法启动。&lt;/p&gt;
&lt;p&gt;因此，如果暂时不具备 k8s 条件，又不想就此止步，那么选择路线 2 是唯一的出路。而上面我们分析过，路线 2 虽然能够在第一步快速拿到短期红利，但是由于偏离长期目标后续发展会有问题。怎么办？&lt;/p&gt;
&lt;p&gt;路线 4 可以是这种场景下的一个折衷选择：在 k8s 没有铺开之前，第一步沿路线 2 走，先吃下非 k8s 下 Sidecar 模式快速落地的红利。然后第二步避开非 k8s 下继续演进到 Istio 模式的大坑，切换到路线 1，回归长期目标。&lt;/p&gt;
&lt;p&gt;好处非常明显：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 k8s 未铺开前，先往前迈进一步，避免就此卡壳&lt;/li&gt;
&lt;li&gt;和路线 2 一样，第一步可以快速的拿到短期红利&lt;/li&gt;
&lt;li&gt;后续转为路线 1 后，因为符合远期规划，因此后续演进不存在投资浪费的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点就是存在少量的投资浪费，毕竟非 k8s 下的 Sidecar 模式还是有些工作内容在迁移到 k8s 之后会有改动。不过，这个改动不会太大，和拿到的红利相比还是值得的。&lt;/p&gt;
&lt;p&gt;路线 4 在操作时，存在一个变数：现有应用在向 Sidecar 模式的 Service Mesh 迁移，是需要一定时间的。有一种可能，就是在迁移过程中，k8s 的普及开始了。这个变数的发生，取决于 Sidecar 模式的 Service Mesh 普及快，还是 k8s 的普及快。&lt;/p&gt;
&lt;p&gt;对路线 4 的分析结果：这是（k8s 没有普及的）特殊时期的选择。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxszj2wkj30qo0f0abt_hu722e4117e2e626dfd92d368860c5d25e_118020_0cdfcaee56adb92ece39049ca5a609e3.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxszj2wkj30qo0f0abt_hu722e4117e2e626dfd92d368860c5d25e_118020_cda8a13b46344ecbbbae37743bcdc046.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxszj2wkj30qo0f0abt_hu722e4117e2e626dfd92d368860c5d25e_118020_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxszj2wkj30qo0f0abt_hu722e4117e2e626dfd92d368860c5d25e_118020_0cdfcaee56adb92ece39049ca5a609e3.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在对四条可能的演进路线分析完成之后，我们来具体介绍蚂蚁金服的最终选择。&lt;/p&gt;
&lt;p&gt;坦言说，在过去半年中，我们的演进路线有几次摇摆和修订，今天我们公布的路线，和过去几个月中我们通过 meetup/技术大会/博客文章 等方式透露出来的方式会有一些变化。主要原因是在过去的这半年中，一方面我们对 Sercice Mesh 的认知更加深入，另一方面是蚂蚁金服的 k8s 背景也在变化。&lt;/p&gt;
&lt;p&gt;首先，在今年年初，我们确认 Service Mesh 大方向时，k8s 还没有在蚂蚁金服普及，而且也没有明确的时间表。因此，我们在一番调研之后，选择了两条腿走路的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在非 k8s 环境下，以 Sidecar 模式先进行少量落地，主要是替换掉原有的多语言客户端（拿短期红利）&lt;/li&gt;
&lt;li&gt;开发 SOFAMesh，集成 MOSN 到 Istio，增加对多种 RPC 协议的支持，增加对 RPC 服务模式的兼容（为最终目标做准备）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在今年 6 月底的杭州第一届 Service Mesh 线下 meetup 中，我们公布了 SOFAMesh 项目，我当时做了一个演讲 &lt;a href=&#34;https://skyao.io/publication/201806-service-mesh-explore/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大规模微服务架构下的 Service Mesh 探索之路&lt;/a&gt; ，有兴趣的同学可以去回顾一下我们当时的背景/需求/设计方案。&lt;/p&gt;
&lt;p&gt;大概在今年九月，我们完成了对非 k8s 下运行 istio 的深入调研，得出的结论是要实现这个模式需要非常多的工作。而且，我们对 Service Mesh 的认知也更加深刻，明确了通过 Service Mesh 将传统中间件能力向以 k8s 为代表的基础设施层下沉的战略方向。期间，内部也明确了 k8s 普及的大方向，因此，综合这两个重要输入，我们选择放弃继续在路线 2 上继续演进（即 istio on 非 k8s）的想法。关于这一点，有兴趣的同学可以去阅读我在 10 月份 QCon 大会上的演讲内容 &lt;a href=&#34;https://skyao.io/publication/201810-ant-finance-service-mesh-practice/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;长路漫漫踏歌而行：蚂蚁金服 Service Mesh 实践探索&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;最近，k8s 普及的时间表再一次明确提前，蚂蚁金服将会在短时间内开启 k8s 的大面积普及。因此，我们的演进路线再一次发生变化。目前最新的演进路线将会是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前还没有开始迁移的应用（处于演进路线图最下方），将按照路线 1 的方式进行迁移：先迁移到 k8s，再迁移到 Sidecar 模式的 Service Mesh&lt;/li&gt;
&lt;li&gt;目前部分已经迁移的应用（路线 2/4 的第一步，非 k8s 部署的 Sidecar 模式），将沿路线 4 迁移，和路线 1 会师&lt;/li&gt;
&lt;li&gt;由于应用众多，因此预计到 k8s + Sidecar 模式 的迁移工作会持续比较长时间，在此期间，我们会同步完善 Istio，和 Istio 官方一起合作来实现 Istio 对超大规模部署的支持&lt;/li&gt;
&lt;li&gt;最后一步，迁移到最终目标（当然这一步的方案依然有很多待定内容，继续努力）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要强调的是：这个演进路线针对的是蚂蚁金服主站的特殊场景，并不具体普适性。大家可以在理解我们演进路线背后的思路和权衡方式之后，再结合自身的实际情况进行决策。比如，我们在 UC 落地时，由于 UC 有完善的 k8s 支持，而且目前落地的规模没那么夸张，因此是直接从&amp;quot;部署在 k8s 上&amp;quot; + &amp;ldquo;不是 Service Mesh 形态&amp;rdquo;，直接迁移到终态的。预计在金融云落实时，也会是如此，因为客户也不会有如此规模。&lt;/p&gt;
&lt;p&gt;总结：前面我们介绍了当应用程序向 Service Mesh 和 K8s 迁移时的几种可能的演进路线，分析了各条路线的利弊。并以蚂蚁金服主站为例，介绍了我们迁移的背景和演进路线的选择思路，希望能够帮助大家更好的理解 Service Mesh 的落地实践，以便在未来设计自家的落地方案时能有所参考。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt3aatgj30qo0f0juh_hudd2637d7e2d197cee5d2aeb059cee1be_66686_07fff39e3f0092d4ce3d0e2683ef3318.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt3aatgj30qo0f0juh_hudd2637d7e2d197cee5d2aeb059cee1be_66686_556cff3bf8a06bd473e942e56a005766.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt3aatgj30qo0f0juh_hudd2637d7e2d197cee5d2aeb059cee1be_66686_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt3aatgj30qo0f0juh_hudd2637d7e2d197cee5d2aeb059cee1be_66686_07fff39e3f0092d4ce3d0e2683ef3318.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;前面给大家介绍了蚂蚁金服主站的 Service Mesh 演进路线，期间谈到要实现现有应用的平滑迁移。今天的第二个内容，将给大家介绍平滑迁移实现中的几个关键做法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt72zxjj30qo0f0jse_hu882e91c5e6775b846a3030219bc1fb77_75210_eb70ce414fe0301dbe124483cec1a205.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt72zxjj30qo0f0jse_hu882e91c5e6775b846a3030219bc1fb77_75210_da8f5e70d5f37ee8aa70647a257b53ff.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt72zxjj30qo0f0jse_hu882e91c5e6775b846a3030219bc1fb77_75210_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt72zxjj30qo0f0jse_hu882e91c5e6775b846a3030219bc1fb77_75210_eb70ce414fe0301dbe124483cec1a205.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先，第一个关键是尽量保证迁移前后服务间网络互通。&lt;/p&gt;
&lt;p&gt;以向 k8s 迁移为例，在非 k8s 环境，典型的服务间访问方式是这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个服务向注册中心注册&lt;/li&gt;
&lt;li&gt;客户端发起访问前，通过注册中心得到目标服务的实例列表信息，如 IP 地址/端口等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在向 k8s 迁移的过程中，我们的做法是保证 k8s 内外网络打通，即服务的 IP 地址（在 k8s 中是 pod ip）是可以相互直接访问的。基于这个前提，服务在迁移到 k8s 的过程中，原有的服务注册/服务发现/发起请求等逻辑都无需修改，是不是在 k8s 内，是不是 pod ip，对原有服务化体系完全是透明的。&lt;/p&gt;
&lt;p&gt;因此，向 k8s 的迁移可以做到对业务应用非常的平滑，基本感知。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt9dqbsj30qo0f00uq_hu984ac7d9794d28429f777ad1bb1289df_110760_d0920ea261d6305bdb48e22281c950e2.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt9dqbsj30qo0f00uq_hu984ac7d9794d28429f777ad1bb1289df_110760_6510e45ebde2fa7328baa3863368d2ef.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt9dqbsj30qo0f00uq_hu984ac7d9794d28429f777ad1bb1289df_110760_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt9dqbsj30qo0f00uq_hu984ac7d9794d28429f777ad1bb1289df_110760_d0920ea261d6305bdb48e22281c950e2.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;透明拦截在迁移过程中，可以起到非常关键的作用。&lt;/p&gt;
&lt;p&gt;以 Service-A 要访问 Service-B，在应用向 Sidecar 模式的 Service Mesh 迁移前后，会有有四种排列组合场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Service-A 和 Service-B 都没有迁移到 Serive Mesh：此时请求会直接从 Service-A 发送到 Service-B，称为直连，这是应用在开始迁移到 Service Mesh 之前的标准工作方式&lt;/li&gt;
&lt;li&gt;Service-A 已经迁移到 Service Mesh，Service-B 还没有：此时 Service-A 发出来的请求，会被劫持，然后发送到和 Service-A 一起部署的 Sidecar（称为 Outbound Sidecar），此时链路中只有一个 Sidecar，称为（客户端）单跳&lt;/li&gt;
&lt;li&gt;Service-B 已经迁移到 Service Mesh，Service-A 还没有：此时 Service-A 发出来的请求，在到达 Service-B 时，会被劫持到和 Service-B 一起部署的 Sidecar（称为 Inbound Sidecar），此时链路中也只有一个 Sidecar，称为（服务器端）单跳&lt;/li&gt;
&lt;li&gt;Service-A 和 Service-B 都迁移到 Serive Mesh：此时 Service-A 发出来的请求，会被两次劫持，分别进入 Outbound Sidecar 和 Inbound Sidecar，此时链路中有两个 Sidecar，称为双跳。这是 Istio 的标准工作模式，也是我们迁移完成之后的最终工作模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这四种场景中，所有的网络请求，请求报文都是完全一致的，即不管是否被劫持到 Sidecar，对请求报文都没有影响，也就是对发出请求报文的客户端和接受请求报文的客户端都是透明的，完全无感之。&lt;/p&gt;
&lt;p&gt;因此，在迁移过程中，可以单个服务逐个迁移，甚至服务的单个实例逐个迁移，而无需修改应用本身。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtcjj4wj30qo0f0jt1_hu84da03916eab4d2ae6e88da69e15cb20_117398_91a5cee9911844ce20cfee3819e1c911.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtcjj4wj30qo0f0jt1_hu84da03916eab4d2ae6e88da69e15cb20_117398_c0e3e2e4d8879774d72bc2d175ae0b16.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtcjj4wj30qo0f0jt1_hu84da03916eab4d2ae6e88da69e15cb20_117398_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtcjj4wj30qo0f0jt1_hu84da03916eab4d2ae6e88da69e15cb20_117398_91a5cee9911844ce20cfee3819e1c911.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在展开第三个关键点之前，我们来探讨一下：在 Service Mesh 时代，理想的客户端应该是什么样子？&lt;/p&gt;
&lt;p&gt;图中我们列举了一个传统的侵入式框架的客户端所包含的功能，在侵入式框架中，大部分的功能都是由客户端实现，因此会包含非常多的功能，如服务发现、负载均衡等基本功能，加密、认证、路由等高级功能。在应用迁移到 Service Mesh 之后，这些功能都下沉到 Service Mesh 中。因此，Service Mesh 下的客户端可以进行大幅度的简化，成为一个新的轻量级客户端。&lt;/p&gt;
&lt;p&gt;对于这个轻量级客户端，我们希望可以尽可能的做的轻薄通用：实现简单，不管哪个编程语言都可以做到轻松实现，因此跨语言就方便了。而且越简单之后升级的可能性就会越少，以避免升级客户端。&lt;/p&gt;
&lt;p&gt;那我们来继续看，这个轻量级客户端里面最后还能剩下什么内容？&lt;/p&gt;
&lt;p&gt;图中列出了三个，其中最重要的，也是必不可少的是目标服务的标识，即无论如何简化，最低限度应该告之要访问谁吧？然后是序列化，对于 RPC 类肯定需要提供编解码功能，不过对于 HTTP/REST 类很多语言直接内置了标准实现。然后链路追踪，需要做一点工作来传递诸如 SpanID 之类的参数，同样这块也有可能通过自动埋点来实现。因此，最理想最单薄的客户端，可能只保留最后一个信息：目标服务的标示。&lt;/p&gt;
&lt;p&gt;在侵入式框架下，目标服务的标示是和服务注册/服务发现是直接关联的，这个标示通常都是服务名，通过服务发现机制实现了一个服务名到服务实例的寻址方式。在 Service Mesh 机制下，由于服务发现机制被下沉到 Service Mesh 中，因此只要底层 Service Mesh 能支持，这个目标服务的标示可以不必拘泥于服务名。&lt;/p&gt;
&lt;p&gt;那么，问题来了，对客户端来说：最简单，最通用，支持最广泛的寻址方式是什么？是 DNS！&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtezb6wj30qo0f0dh6_hu12e6679318c885d1c8d59441f97f2e16_81749_24d7b2d1e4f146b9b6347544488c20bf.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtezb6wj30qo0f0dh6_hu12e6679318c885d1c8d59441f97f2e16_81749_0a641d8751c05676bf9919a51771f550.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtezb6wj30qo0f0dh6_hu12e6679318c885d1c8d59441f97f2e16_81749_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtezb6wj30qo0f0dh6_hu12e6679318c885d1c8d59441f97f2e16_81749_24d7b2d1e4f146b9b6347544488c20bf.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在我们的迁移方案中，我们考虑引入 DNS 寻址方式。除了前面说的 DNS 是支持度最好，使用最普遍的寻址方式，在所有的编程语言和平台上都可以支持之外，我们还希望将 DNS 寻址方式作为未来产品的长期方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 SOFAMesh 和 SOFAMosn 中，我们已经基于名为 x-protocol 的方式实现了 DNS 通用寻址方式，用来解决 Dubbo/HSF/SOFA 等传统 SOA 服务模型在 Service Mesh 下的访问问题（备注：具体内容请见我的博客文章 &lt;a href=&#34;https://skyao.io/post/201809-xprotocol-common-address-solution/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列 (1)-DNS 通用寻址方案&lt;/a&gt; )&lt;/li&gt;
&lt;li&gt;未来在我们的 serverless 产品中，我们希望可以为运行其上的 Function 提供 DNS 寻址支持&lt;/li&gt;
&lt;li&gt;可能还会有其他更加广泛的使用场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在我们的演进过程中，对于客户端 SDK，我们有这样一个思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一方面简化原有的 SDK，去除和 Sidecar 重复的内容（满足短期需求）&lt;/li&gt;
&lt;li&gt;另一方面，考虑到必然有一次客户端 SDK 的更换过程，那么我们希望在简化的同时引入基于 DNS 的通用寻址方式，以便在未来的后续迁移和功能扩展中可以依托这个机制来实现（符合长期目标）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxti92oij30qo0f0wg2_hu5022f37a9e384f05e4bb4041ae958b3f_90688_ffafea72a7cfc4350262e68a974fe0b8.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxti92oij30qo0f0wg2_hu5022f37a9e384f05e4bb4041ae958b3f_90688_0134cb3acd003deefb5164126126f686.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxti92oij30qo0f0wg2_hu5022f37a9e384f05e4bb4041ae958b3f_90688_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxti92oij30qo0f0wg2_hu5022f37a9e384f05e4bb4041ae958b3f_90688_ffafea72a7cfc4350262e68a974fe0b8.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图中描述的是在 Service Mesh 下，客户端通过域名来指定要访问的目标服务，然后通过 DNS 解析机制来串联底层的服务注册/DNS 记录更新/透明劫持传递原始信息/Sidecar 查找路由目标等详细实现机制。&lt;/p&gt;
&lt;p&gt;这里仅做简单示意，我就不详细展开了。在接下来的内容中，我的同事，来自 UC 基础研发部的 龙轼 同学，将为大家详细的展开 DNS 寻址方案的细节实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtk2cbej30qo0f0ad5_hu11d97a0fe81461e050a80a215a935a79_70682_46526dc98b792c7ccf0a98129459d054.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtk2cbej30qo0f0ad5_hu11d97a0fe81461e050a80a215a935a79_70682_4e8c90fbffe6889fc5988ae5eeb01f64.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtk2cbej30qo0f0ad5_hu11d97a0fe81461e050a80a215a935a79_70682_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtk2cbej30qo0f0ad5_hu11d97a0fe81461e050a80a215a935a79_70682_46526dc98b792c7ccf0a98129459d054.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，我是来自 UC 基础研发部的龙轼。感谢小剑老师给我们介绍了蚂蚁和 UC 共建的 Service Mesh 的演进路线和实现平滑迁移的关键。&lt;/p&gt;
&lt;p&gt;接下来由我来向大家分享下实现平滑迁移的关键中的 DNS 寻址方案的演进。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtlzs10j30qo0f0q4l_hu2ab69ae167aa88f9bc5a9a841e6cf9cc_47686_623cf26f519ff50b32018f19bd60d97a.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtlzs10j30qo0f0q4l_hu2ab69ae167aa88f9bc5a9a841e6cf9cc_47686_2b8bb804eaadc4d280ce43565645ea2c.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtlzs10j30qo0f0q4l_hu2ab69ae167aa88f9bc5a9a841e6cf9cc_47686_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtlzs10j30qo0f0q4l_hu2ab69ae167aa88f9bc5a9a841e6cf9cc_47686_623cf26f519ff50b32018f19bd60d97a.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家可以看上面的所示的 DNS 寻址方案的演进，我们先了解下各个服务寻址方案的背景。&lt;/p&gt;
&lt;p&gt;从 SOA 的寻址，到 Kubernetes 的寻址，然后再到 Istio 的寻址，最后是我们的 SOFAMesh 的 DNS 寻址方案。&lt;/p&gt;
&lt;p&gt;它们的寻址方案有什么不同，我们将一一分析它们的细节和总体寻址方案的演进路线。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtnvgf0j30qo0f0gmq_hu2e6bfdd4d1e6072b056fdb689d7d7b23_70347_061aa60931b1fcdd15c1397f9c585833.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtnvgf0j30qo0f0gmq_hu2e6bfdd4d1e6072b056fdb689d7d7b23_70347_0c7b7f9635cb2b66e340de79e4b5e3e4.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtnvgf0j30qo0f0gmq_hu2e6bfdd4d1e6072b056fdb689d7d7b23_70347_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtnvgf0j30qo0f0gmq_hu2e6bfdd4d1e6072b056fdb689d7d7b23_70347_061aa60931b1fcdd15c1397f9c585833.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;现在大家可以先来看下 SOA 架构下基于服务注册和服务发现的寻址。&lt;/p&gt;
&lt;p&gt;我们可以看到图中的 SOA 其实是单进程多接口的，依赖于 SOA 的服务注册与服务发现的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtovfoxj30qo0f0myc_hu46fede31f32e5ca5c7489fe79903bf00_82294_d73de36ab36f30309834d19d6d162900.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtovfoxj30qo0f0myc_hu46fede31f32e5ca5c7489fe79903bf00_82294_da7e377a5de57182a65936c8ff4b9cc6.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtovfoxj30qo0f0myc_hu46fede31f32e5ca5c7489fe79903bf00_82294_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtovfoxj30qo0f0myc_hu46fede31f32e5ca5c7489fe79903bf00_82294_d73de36ab36f30309834d19d6d162900.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来我们看下 Kubernetes 的 DNS 寻址方式，它的寻址方式其实是通过 DNS 的。&lt;/p&gt;
&lt;p&gt;从图中我们可以看到部署到 K8S 上面的 userservice 服务会生成一条 DNS 记录指向 K8S 的 ClusterIP。&lt;/p&gt;
&lt;p&gt;我们在 Pod 里面发起请求时通过 DNS 的 SearchDomain 域名补全规则就会从 DNS 里面查询得到 ClusterIP，我们可以看出 Kubernetes 的寻址方案是单进程单接口的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtr32x9j30qo0f0gmy_hu0001eaf1bbeae97ee78766c74ece341b_90190_674ac856a4c1ad54b6b9bdcbb041ae1b.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtr32x9j30qo0f0gmy_hu0001eaf1bbeae97ee78766c74ece341b_90190_80ef016262db390270a22f5d1cccef33.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtr32x9j30qo0f0gmy_hu0001eaf1bbeae97ee78766c74ece341b_90190_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtr32x9j30qo0f0gmy_hu0001eaf1bbeae97ee78766c74ece341b_90190_674ac856a4c1ad54b6b9bdcbb041ae1b.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;看完 Kubernetes 的服务发现之后我们继续来看 Istio 的服务发现。&lt;/p&gt;
&lt;p&gt;从图中我们可以看出之前的流程都和 K8S 一脉相承，不同的地方在于 Istio 里面有个 SideCar 它把 ClusterIP 拿到之后根据 ClusterIP 从 VirtualHost 里面匹配到 Rule 规则 转发给目标的 Pod 地址。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtt2236j30qo0f00tq_huacd88485823c7a80bccd3c426728f758_77664_91e394c4ae22af3b3103aa1dd3e2f6d5.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtt2236j30qo0f00tq_huacd88485823c7a80bccd3c426728f758_77664_5886c3cefc674c460171ab7043a5ea80.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtt2236j30qo0f00tq_huacd88485823c7a80bccd3c426728f758_77664_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtt2236j30qo0f00tq_huacd88485823c7a80bccd3c426728f758_77664_91e394c4ae22af3b3103aa1dd3e2f6d5.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们来看下 SOFAMesh 的 DNS 通用寻址方案。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据我们之前分析的 SOA 寻址方案和 Kubernetes 寻址方案，我们可以看出如果我们的微服务不经过拆分和改造想上 Service Mesh 的话我们需要支持 SOA 之前的那种单个 Pod 多个接口的。&lt;/li&gt;
&lt;li&gt;从图中看就是我们需要支持 &lt;code&gt;com.alipay.userservice.interface1&lt;/code&gt;, &lt;code&gt;com.alipay.userservice.interface2&lt;/code&gt; 这些接口解析到 ClusterIP, 我们知道 k8s 中的 service 是不支持的。&lt;/li&gt;
&lt;li&gt;那该如何是好，我们只能在 DNS 上做文章修改 DNS 的记录来实现这一功能。确定了这一方案之后我们来看下我们设计的 DNS 寻址方案实现细节。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtx8cboj30qo0f0q3y_hu7ba11f5b4726e00e026a1f23e0a57f1f_74263_cac45e0c8aed8cc4f69a19fbef2a23f8.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtx8cboj30qo0f0q3y_hu7ba11f5b4726e00e026a1f23e0a57f1f_74263_573170805ff01174caf83e97fc6cab5b.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtx8cboj30qo0f0q3y_hu7ba11f5b4726e00e026a1f23e0a57f1f_74263_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtx8cboj30qo0f0q3y_hu7ba11f5b4726e00e026a1f23e0a57f1f_74263_cac45e0c8aed8cc4f69a19fbef2a23f8.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家看这张图：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们用 CRD 定义了一个 RPCService 和之前的 Service 有同样的 selector 的标签。&lt;/li&gt;
&lt;li&gt;然后用 RPC Service Controller 对 RPCService 做 Watch，当 RPCService 有更新的时候我们就把接口就是上述的 &lt;code&gt;com.alipay.userservice.interface1&lt;/code&gt; 的记录写入 CoreDNS 里面&lt;/li&gt;
&lt;li&gt;而 interface 是通过 Pod 里面的 Register Agent 来获取 Dubbo 里面暴露的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu1urkdj30qo0f0wf6_hucb902f54fd34cb6a66ec81cff7b0eca1_51550_84ae7fff2d426b7a6aa5c7f012252919.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu1urkdj30qo0f0wf6_hucb902f54fd34cb6a66ec81cff7b0eca1_51550_260dde339cd7a3748771778d25e79355.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu1urkdj30qo0f0wf6_hucb902f54fd34cb6a66ec81cff7b0eca1_51550_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu1urkdj30qo0f0wf6_hucb902f54fd34cb6a66ec81cff7b0eca1_51550_84ae7fff2d426b7a6aa5c7f012252919.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;好的，说完这个方案的细节之后。我们可以看出其实其他的问题都不大，但是要更新 DNS 的这个我们需要支持。&lt;/p&gt;
&lt;p&gt;一开始我们 K8S 集群里面是用 Kube-DNS 来做 DNS 寻址的，但我们看这张 Kube-DNS 的架构图。&lt;/p&gt;
&lt;p&gt;可以看出修改它成本是比较大的，而且所有的 DNS 都在同一个域里面，这个风险系数很高。如果一旦修改错误势必会影响到之前的 k8s 的 service，导致线上的故障。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu6p6cgj30qo0f0q5b_hu9c0431f21f90131352810f0650a1b511_71396_55a4d2dc00484751c58f4d269ee2c368.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu6p6cgj30qo0f0q5b_hu9c0431f21f90131352810f0650a1b511_71396_792eb076969418bb1b2395ac90b07b3c.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu6p6cgj30qo0f0q5b_hu9c0431f21f90131352810f0650a1b511_71396_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu6p6cgj30qo0f0q5b_hu9c0431f21f90131352810f0650a1b511_71396_55a4d2dc00484751c58f4d269ee2c368.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个时候我们跟踪到社区的 CoreDNS 项目，我们来看下 CoreDNS 的具体的架构。它采用作为 Web 服务器 Caddy 的服务器框架，延用了 Caddy 中的插件机制，大大的增加了 CoreDNS 的灵活性。&lt;/li&gt;
&lt;li&gt;它的插件机制也特别简单，把所有的插件注册进一个 Map 里面来，在调用的时候从 Map 拿出他们有共同接口的函数。有兴趣的同学可以看下 Caddy 的插件代码实现。&lt;/li&gt;
&lt;li&gt;它的 DNS 协议库采用是由 Google 工程师 Meikg 开发的 DNS 库，他同时也是 SkyDNS 的开发者。&lt;/li&gt;
&lt;li&gt;后端可以采用 UDP/TCP、TLS 或者 gRPC 作为后端数据查询。上面有个 Google 工程师用 gRPC 做了一个 CoreDNS 插件的后端数据查询例子，有兴趣的同学可以看下。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxubqi33j30qo0f0djp_hu8282bacb0d8cd4fadd95abb5ed4e4572_82820_09c142a3387af5a7284f133a5c1571b0.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxubqi33j30qo0f0djp_hu8282bacb0d8cd4fadd95abb5ed4e4572_82820_b5472055aabfcf04f7848c3854aaf521.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxubqi33j30qo0f0djp_hu8282bacb0d8cd4fadd95abb5ed4e4572_82820_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxubqi33j30qo0f0djp_hu8282bacb0d8cd4fadd95abb5ed4e4572_82820_09c142a3387af5a7284f133a5c1571b0.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，既然 CoreDNS 的 Plugins 这么强大，我们可不可以用它来实现我们刚才说到的 Renew DNS 的机制。答案很显然是可以。&lt;/p&gt;
&lt;p&gt;我们看下上面的图，实现 CoreDNS 的插件很简单，只需要继承上面的接口就可以了。CoreDNS 官网有具体的教程在教我们怎么写一个插件。这个就不具体的展开了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuel9hoj30qo0f03zw_hufc857944063d1298e626e2293dc9cb29_98186_92daf530e81c84d5521266a7abcd8b37.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuel9hoj30qo0f03zw_hufc857944063d1298e626e2293dc9cb29_98186_0ae63ff58207ba9f7d1e95fcae2139cb.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuel9hoj30qo0f03zw_hufc857944063d1298e626e2293dc9cb29_98186_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuel9hoj30qo0f03zw_hufc857944063d1298e626e2293dc9cb29_98186_92daf530e81c84d5521266a7abcd8b37.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;到了我们最关键的点了：我们应该怎么更新我们的 DNS。其实这点 CoreDNS 社区里面已经有人提出需求用 REST API 的形式提供更新 DNS 的接口。&lt;/li&gt;
&lt;li&gt;互联网任务工程小组也早在 rfc2136 定义了标准的 DNS UPDATE。Google Cloud 和 AWS 都有相应的实现。&lt;/li&gt;
&lt;li&gt;CoreDNS 社区其实已经把接口实现了，但是后端存储是基于 file 的，数据没有落地。蚂蚁和 UC 这边扩展了 ETCD 插件的接口，把对应 DNS UPDATE 接口给实现了，实现 DNS 数据写入 ETCD 里面。&lt;/li&gt;
&lt;li&gt;从图中我们可以看到 &lt;code&gt;rpc.cluster.local&lt;/code&gt; 这个域 和 k8s 域 cluster.local 是在不同的插件链上的。
这样在 k8s 域中没有 dynapirest 插件，我们就不能对 k8s 域中的 DNS 进行更新，这样就把之前 Kube-DNS 改造之后会对 k8s 域里面造成影响给去除了，更加的安全。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuhvylcj30qo0f0n35_hu05a294bf28ff73e65f367c7ee006e240_83683_57ce738d036f285bcba43fb1f754e74c.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuhvylcj30qo0f0n35_hu05a294bf28ff73e65f367c7ee006e240_83683_eadd6edeaede23dc2236227301e0da57.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuhvylcj30qo0f0n35_hu05a294bf28ff73e65f367c7ee006e240_83683_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuhvylcj30qo0f0n35_hu05a294bf28ff73e65f367c7ee006e240_83683_57ce738d036f285bcba43fb1f754e74c.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们可以看下 CoreDNS 后端存储的接口，其实和我们之前对数据操作的接口是没有什么差别的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuk3x3zj30qo0f0go6_hua086b4ca20d060979e8379df5df961fc_63619_0bfe61a0c06613ac4e47b16839933218.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuk3x3zj30qo0f0go6_hua086b4ca20d060979e8379df5df961fc_63619_02caf347455e71fce3e01255ad8851cd.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuk3x3zj30qo0f0go6_hua086b4ca20d060979e8379df5df961fc_63619_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuk3x3zj30qo0f0go6_hua086b4ca20d060979e8379df5df961fc_63619_0bfe61a0c06613ac4e47b16839933218.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;目前 CoreDNS 的 DynAPI 还在主库代码没合并的状态。之后 DynAPI 这个项目会独立成一个插件项目。我们可以看下 CoreDNS 社区的 DynAPI 插件进展。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxumjxr1j30qo0f00vw_hu4290fc23d7b0f07a229e594f4df0bc34_65463_2c45087148336d295e08f1af0a086202.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxumjxr1j30qo0f00vw_hu4290fc23d7b0f07a229e594f4df0bc34_65463_ad3ad902a1af193ea4e8646cd54bd520.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxumjxr1j30qo0f00vw_hu4290fc23d7b0f07a229e594f4df0bc34_65463_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxumjxr1j30qo0f00vw_hu4290fc23d7b0f07a229e594f4df0bc34_65463_2c45087148336d295e08f1af0a086202.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，我们来看下我们的 DynAPI 实现 DNS 更新的一个效果。从图中我们可以看出 record.json 里面的一个域名的更新。通过 DynAPI 我们成功把 record.json 的 DNS 记录给更新进去并且 dns 正常工作了。到现在我们通过 CoreDNS 的插件就把 DNS 更新的需求给解决了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuoytkjj30qo0f0q4a_huaecd81861cfdf766a268f099de8accf5_42940_335abfdfc4375e254c6482aebe802ce0.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuoytkjj30qo0f0q4a_huaecd81861cfdf766a268f099de8accf5_42940_79544ec62cf1d8bc6d61068e6b7f126e.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuoytkjj30qo0f0q4a_huaecd81861cfdf766a268f099de8accf5_42940_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuoytkjj30qo0f0q4a_huaecd81861cfdf766a268f099de8accf5_42940_335abfdfc4375e254c6482aebe802ce0.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其实 CoreDNS 官网还有许多有趣的插件，可以丰富 CoreDNS 的功能和提升 CoreDNS 的性能。大家可以看下中间的 autopath 插件，他把我们多次的在 searchdomain 拼凑的 DNS 记录的查询在在服务器上给实现了。避免了多次的 Client 端和 Server 端的数据交互。有兴趣的同学可以看下 &lt;a href=&#34;https://github.com/coredns/presentations/blob/master/A-Deep-Dive-into-CoreDNS-2018.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A-Deep-Dive-into-CoreDNS-2018&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxurlu6tj30qo0f0q46_hu697e05cc675181f43b7d82dfcdf952ae_68564_84dc530f93969d30275952185fbece40.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxurlu6tj30qo0f0q46_hu697e05cc675181f43b7d82dfcdf952ae_68564_dd6c1748d6076a017135e4db4fdc70fa.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxurlu6tj30qo0f0q46_hu697e05cc675181f43b7d82dfcdf952ae_68564_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxurlu6tj30qo0f0q46_hu697e05cc675181f43b7d82dfcdf952ae_68564_84dc530f93969d30275952185fbece40.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们把 CoreDNS 的功能开发完了，上线的话很多人关注它的性能。我们这边做了一个简单的性能测试，可以看出 CoreDNS 和 Bind DNS 这种现在比较通用的 DNS 的性能还是有点差距的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuu4eu0j30qo0f0tf3_hue7ff765e78b935349b182b3e5cec081b_97289_3b4f2ee963bdda5c3a36a7ffdd8daa8e.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuu4eu0j30qo0f0tf3_hue7ff765e78b935349b182b3e5cec081b_97289_e42e0f242e5be4d351e5be5d10e8c00e.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuu4eu0j30qo0f0tf3_hue7ff765e78b935349b182b3e5cec081b_97289_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuu4eu0j30qo0f0tf3_hue7ff765e78b935349b182b3e5cec081b_97289_3b4f2ee963bdda5c3a36a7ffdd8daa8e.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但是，我们通过上面的图可以看到在一定的 QPS 下，CoreDNS 的延时是很低的。我们可以看到所有的延时都落在 4ms 之内。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuwnsanj30qo0f0abw_hu2ed5448edaa54fb5fd6e4e16c5245000_54682_fb19be6f008eebdab32ac9e4f6f1c536.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuwnsanj30qo0f0abw_hu2ed5448edaa54fb5fd6e4e16c5245000_54682_7ebe40a3e5facd4d4653dc2f363147b4.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuwnsanj30qo0f0abw_hu2ed5448edaa54fb5fd6e4e16c5245000_54682_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuwnsanj30qo0f0abw_hu2ed5448edaa54fb5fd6e4e16c5245000_54682_fb19be6f008eebdab32ac9e4f6f1c536.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了解决 QPS 的问题，我们通过 Kubernetes 的 HPA 给 CoreDNS 进行横向的扩展。&lt;/p&gt;
&lt;p&gt;一开始我们只是通过 CPU 的维度给 CoreDNS 扩展，但发现波动有点大。之后我们切换成通过 QPS 的维度来进行扩容。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuz1c5ej30qo0f0gmc_hud3413c0c7ae70cae78b1dbf9fbf1dabd_60219_92abb891713e0db9be37bb876f67d52b.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuz1c5ej30qo0f0gmc_hud3413c0c7ae70cae78b1dbf9fbf1dabd_60219_c0675bbcb380bf9108e48f4a48d09e4a.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuz1c5ej30qo0f0gmc_hud3413c0c7ae70cae78b1dbf9fbf1dabd_60219_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuz1c5ej30qo0f0gmc_hud3413c0c7ae70cae78b1dbf9fbf1dabd_60219_92abb891713e0db9be37bb876f67d52b.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;CoreDNS 将会在 Kubernetes 1.13 之后成为 Kubernetes 的默认的 DNS 服务。我们将会紧跟社区实施我们的方案并且反馈给社区。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv0youwj30qo0f0tbs_hu5a00da812b612dd897a14ff5f187b694_66640_6990e1d4e7f383945eb7a753bbfc2b25.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv0youwj30qo0f0tbs_hu5a00da812b612dd897a14ff5f187b694_66640_687c8b560bacbf7ae2928d03cf5289c3.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv0youwj30qo0f0tbs_hu5a00da812b612dd897a14ff5f187b694_66640_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv0youwj30qo0f0tbs_hu5a00da812b612dd897a14ff5f187b694_66640_6990e1d4e7f383945eb7a753bbfc2b25.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们再来看下我们后续的一些规划。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv3cwjjj30qo0f075p_hudc21e1c15e19b5880d25d46c44285063_52107_f6e8004cd53845b1eb174a61b989cf57.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv3cwjjj30qo0f075p_hudc21e1c15e19b5880d25d46c44285063_52107_51379ad05b467bf751822a4a3ec200f8.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv3cwjjj30qo0f075p_hudc21e1c15e19b5880d25d46c44285063_52107_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv3cwjjj30qo0f075p_hudc21e1c15e19b5880d25d46c44285063_52107_f6e8004cd53845b1eb174a61b989cf57.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可以看到我们的 DynAPI 其实在安全上还是有欠缺的。我们后续会把 HTTP 加强成 HTTPS 协议来增强 DynAPI 的安全性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv5rwbbj30qo0f0dik_hu0023aa6a7c91b0cfc4331301c6ac21ae_61855_afcc6e418f1c383625b315a95ce88cae.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv5rwbbj30qo0f0dik_hu0023aa6a7c91b0cfc4331301c6ac21ae_61855_db14f1aab6db1d0a19188f2432632de5.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv5rwbbj30qo0f0dik_hu0023aa6a7c91b0cfc4331301c6ac21ae_61855_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv5rwbbj30qo0f0dik_hu0023aa6a7c91b0cfc4331301c6ac21ae_61855_afcc6e418f1c383625b315a95ce88cae.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;还有如果我们 CoreDNS 的后端变化的更新的 Watch 由于 Watch 的范围过大的话，会返回过多的数据。这样会影响到 Watch 的性能，CoreOS 在 ETCD3.2 增加了 proxy 可以让我们根据不同的 ETCD KeySpace 去 Watch，这样大大的提高了 Watch 的性能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv8070fj30qo0f0ab1_hu6485f23e60e2e8e9568294bae27898e8_64699_ba5855a52150ea4c23f3e1223840e916.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv8070fj30qo0f0ab1_hu6485f23e60e2e8e9568294bae27898e8_64699_1a155b965fc813b9eeaae068e35548b1.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv8070fj30qo0f0ab1_hu6485f23e60e2e8e9568294bae27898e8_64699_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv8070fj30qo0f0ab1_hu6485f23e60e2e8e9568294bae27898e8_64699_ba5855a52150ea4c23f3e1223840e916.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后一个，我们建议在创建 Kubernetes 集群的时候把 idc 的信息给带进 Kubernetes 的后缀域名中。这样我们之后可以通过 kubernetai 插件把不同的 Kubernetes 集群的域名进行整合通过本 IDC 缓存提高跨 IDC DNS 的访问速度。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvatmutj30qo0f0whk_hu2cbabba623e88cebfd9cefff42206c53_65339_e1dc879d8d056e8934685548a93441c2.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvatmutj30qo0f0whk_hu2cbabba623e88cebfd9cefff42206c53_65339_e759cb451668749d76e231270fcec3e3.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvatmutj30qo0f0whk_hu2cbabba623e88cebfd9cefff42206c53_65339_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvatmutj30qo0f0whk_hu2cbabba623e88cebfd9cefff42206c53_65339_e1dc879d8d056e8934685548a93441c2.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvdouf2j30qo0f0gnc_huc1406821e9a2af2652eda43d3e3b0695_55814_5bcc52e2cfe11125f500ceaaaf8794d4.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvdouf2j30qo0f0gnc_huc1406821e9a2af2652eda43d3e3b0695_55814_6e9b7c0e8140494d20e81d0021cff817.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvdouf2j30qo0f0gnc_huc1406821e9a2af2652eda43d3e3b0695_55814_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvdouf2j30qo0f0gnc_huc1406821e9a2af2652eda43d3e3b0695_55814_5bcc52e2cfe11125f500ceaaaf8794d4.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们总结下，总体方面小剑老师给我们讲了蚂蚁金服主站 Service Mesh 的渐进式演进路线和实现平滑迁移的几个关键。具体细节方面我们通过 CoreDNS 的单点突破解决了 SOFAMesh 的 DNS 寻址的问题。&lt;/p&gt;
&lt;p&gt;感谢大家，希望这次演讲能让大家有所收获。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #4 上海站</title>
      <link>https://cloudnative.to/event/service-mesh-meetup-04/</link>
      <pubDate>Sun, 25 Nov 2018 13:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/event/service-mesh-meetup-04/</guid>
      <description>&lt;h2 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h2&gt;
&lt;h4 id=&#34;observability-and-istio-telemetry&#34;&gt;Observability and Istio telemetry&lt;/h4&gt;
&lt;p&gt;吴晟 Apache SkyWalking 创始人、Apache Sharding-Sphere 原型作者、比特大陆资深技术专家、CNCF OpenTracing 标准化委员会成员&lt;/p&gt;
&lt;h4 id=&#34;蚂蚁集团-service-mesh-渐进式迁移方案&#34;&gt;蚂蚁集团 Service Mesh 渐进式迁移方案&lt;/h4&gt;
&lt;p&gt;敖小剑 蚂蚁集团高级技术专家，十六年软件开发经验，微服务专家，Service Mesh 布道师，Servicemesher 社区联合创始人&lt;/p&gt;
&lt;p&gt;张瑜标 阿里巴巴技术专家、前京东 Hadoop 负责人、Hadoop 代码贡献者、现负责 UC 基于 Kubernetes 自研的 PaaS 平台整体的稳定性&lt;/p&gt;
&lt;h4 id=&#34;探讨和实践基于-isito-的微服务治理事件监控&#34;&gt;探讨和实践基于 Isito 的微服务治理事件监控&lt;/h4&gt;
&lt;p&gt;徐运元 谐云科技云平台架构师，致力于容器 PaaS 平台、企业级容器云平台的方案设计和技术落地&lt;/p&gt;
&lt;h4 id=&#34;envoycontour-与-kubernetes-实践&#34;&gt;Envoy、Contour 与 Kubernetes 实践&lt;/h4&gt;
&lt;p&gt;冯玮 七牛容器云平台产品架构师，曾在百度和华为从事公有云领域高性能分布式计算和存储平台的架构设计和产品研发&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（3）——TCP 协议扩展</title>
      <link>https://cloudnative.to/blog/x-protocol-tcp-protocol-extension/</link>
      <pubDate>Sun, 14 Oct 2018 14:53:04 +0800</pubDate>
      <guid>https://cloudnative.to/blog/x-protocol-tcp-protocol-extension/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是 SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列文章之一。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（1）——DNS 通用寻址方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnative.to/blog/x-protocol-rapid-decode-forward/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（2）——快速解码转发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnative.to/blog/x-protocol-tcp-protocol-extension/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（3）——TCP 协议扩展&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;在 Istio 和 Envoy 中，对通讯协议的支持，主要体现在 HTTP/1.1 和 HTTP/2 上，这两个是 Istio/Envoy 中的一等公民。而基于 HTTP/1.1 的 REST 和基于 HTTP/2 的 gRPC，一个是目前社区最主流的通讯协议，一个是未来的主流，google 的宠儿，CNCF 御用的 RPC 方案，这两个组成了目前 Istio 和 Envoy（乃至 CNCF 所有项目）的黄金组合。&lt;/p&gt;
&lt;p&gt;而我们 SOFAMesh，在第一时间就遇到和 Istio/Envoy 不同的情况，我们需要支持 REST 和 gRPC 之外的众多协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOFARPC：这是蚂蚁金服大量使用的 RPC 协议 (已开源)&lt;/li&gt;
&lt;li&gt;HSF RPC：这是阿里集团内部大量使用的 RPC 协议 (未开源)&lt;/li&gt;
&lt;li&gt;Dubbo RPC: 这是社区广泛使用的 RPC 协议 (已开源)&lt;/li&gt;
&lt;li&gt;其他私有协议：在过去几个月间，我们收到需求，期望在 SOFAMesh 上运行其他 TCP 协议，部分是私有协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为此，我们需要考虑在 SOFAMesh 和 SOFAMosn 中增加这些通讯协议的支持，尤其是要可以让我们的客户非常方便的扩展支持各种私有 TCP 协议：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/x-protocol-tcp-protocol-extension/supported-protocol_hub14e6855a7cc2129c0d6d96b0a47c7e5_50437_818575bce0b4fe16997b32062a53cb09.webp 400w,
               /blog/x-protocol-tcp-protocol-extension/supported-protocol_hub14e6855a7cc2129c0d6d96b0a47c7e5_50437_d91705dc3b94d7da33b892c7b2d9a7b5.webp 760w,
               /blog/x-protocol-tcp-protocol-extension/supported-protocol_hub14e6855a7cc2129c0d6d96b0a47c7e5_50437_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-tcp-protocol-extension/supported-protocol_hub14e6855a7cc2129c0d6d96b0a47c7e5_50437_818575bce0b4fe16997b32062a53cb09.webp&#34;
               width=&#34;594&#34;
               height=&#34;485&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;实现分析&#34;&gt;实现分析&lt;/h2&gt;
&lt;p&gt;我们来大体看一下，在 SOFAMesh/Istio 中要新增一个通讯协议需要有哪些工作：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/x-protocol-tcp-protocol-extension/tbd_hu0d2998cfd06572013c1c297b3bee347e_70006_53c14817d55293dca386ef686671376b.webp 400w,
               /blog/x-protocol-tcp-protocol-extension/tbd_hu0d2998cfd06572013c1c297b3bee347e_70006_af6840706c17e03dacee5adb8ef43ffa.webp 760w,
               /blog/x-protocol-tcp-protocol-extension/tbd_hu0d2998cfd06572013c1c297b3bee347e_70006_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-tcp-protocol-extension/tbd_hu0d2998cfd06572013c1c297b3bee347e_70006_53c14817d55293dca386ef686671376b.webp&#34;
               width=&#34;760&#34;
               height=&#34;327&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;protocol decoder：负责解析协议，读取协议字段&lt;/li&gt;
&lt;li&gt;protocol encoder：负责生成请求报文，注意通常会有改动，比如修改某些 header&lt;/li&gt;
&lt;li&gt;在 pilot 中需要为新协议生成 Virtual Host 等配置，有 inbound 和 outbound 两份，分别下发到 Sidecar&lt;/li&gt;
&lt;li&gt;在 Sidecar 中，根据下发的 Virtual Host 等配置，进行请求匹配，以决定请求该转发到何处&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：实际下发的配置不止 Virtual Host 配置，为了简单起见，我们仅以 Virtual Host 为例做讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中，protocol encoder 和 protocol decoder 是容易理解的，对于新的通讯协议肯定需要有协议编解码层面的工作必须要完成，这块有工作量是很自然的。&lt;/p&gt;
&lt;p&gt;我们来看看第三块的工作量是什么，inbound 和 outbound 的 Virtual Host 配置示例如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/x-protocol-tcp-protocol-extension/outbound_hu4b27eee18859418a236affb7163822bc_131877_d7d872c3a7408108a8b9bfecc5929dc8.webp 400w,
               /blog/x-protocol-tcp-protocol-extension/outbound_hu4b27eee18859418a236affb7163822bc_131877_a1cd99a9872bce9ccc609a572bfd27c3.webp 760w,
               /blog/x-protocol-tcp-protocol-extension/outbound_hu4b27eee18859418a236affb7163822bc_131877_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-tcp-protocol-extension/outbound_hu4b27eee18859418a236affb7163822bc_131877_d7d872c3a7408108a8b9bfecc5929dc8.webp&#34;
               width=&#34;760&#34;
               height=&#34;593&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;outbound 配置中，注意 domains 字段是各种域名和 ClusterIP，而 routes 中，match 是通过 prefix 来匹配。我们结合 HTTP/1.1，domains 字段是用来和请求的 Host header 进行域名匹配的，比如 &lt;code&gt;Host: istio-telemetry&lt;/code&gt;，这决定了哪些请求是要转发到 istio-telemetry 这个服务的。routes 的 match 用来进行路由匹配的，通过 HTTP 请求的 path 进行匹配。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/x-protocol-tcp-protocol-extension/inbound_hue5aef78d494d37123d1e024ded5922db_82214_da6a74d1f2979b136bcf9e1de2342aca.webp 400w,
               /blog/x-protocol-tcp-protocol-extension/inbound_hue5aef78d494d37123d1e024ded5922db_82214_1365833788422cf86eaa47e3ebbd3cdb.webp 760w,
               /blog/x-protocol-tcp-protocol-extension/inbound_hue5aef78d494d37123d1e024ded5922db_82214_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-tcp-protocol-extension/inbound_hue5aef78d494d37123d1e024ded5922db_82214_da6a74d1f2979b136bcf9e1de2342aca.webp&#34;
               width=&#34;760&#34;
               height=&#34;526&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;inbound 配置类似，只是 inbound 更简单，domains 匹配&lt;code&gt;*&lt;/code&gt;就可以。&lt;/p&gt;
&lt;p&gt;从上面的例子中可以看到，Istio 和 Envoy 的设计有非常浓重的 HTTP 协议的味道，各种语义都是和 HTTP 直接相关。而当我们进行 TCP 协议的转发时，就需要将请求的协议字段进行映射，映射到 HTTP 的相应语义。&lt;/p&gt;
&lt;p&gt;比如，最基本的 Destination，原始语义是请求的目的地，在前面的文章中我们指出过这是请求转发最关键的字段。在 HTTP 协议中，通常是通过 Host header 和 Path 表示，对于 REST 而言还有重要的 Method 字段。&lt;/p&gt;
&lt;p&gt;下面的格式是其他各种协议对这个 Destination 原始语义的实际实现方式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;协议&lt;/th&gt;
&lt;th&gt;实现&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原始语义&lt;/td&gt;
&lt;td&gt;请求的目的地 (Destination)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HTTP/1.1&lt;/td&gt;
&lt;td&gt;Host header，Method，Path&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HTTP/2&lt;/td&gt;
&lt;td&gt;Header 帧中的伪 header &lt;code&gt;:authority&lt;/code&gt;，&lt;code&gt;:path&lt;/code&gt;和&lt;code&gt;:method&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Bolt 协议&lt;/td&gt;
&lt;td&gt;header map 中 key 为”service”的字段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HSF 协议&lt;/td&gt;
&lt;td&gt;协议头中的服务接口名和服务方法名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dubbo 协议&lt;/td&gt;
&lt;td&gt;data 字段（payload）中的 path/method&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些通讯协议在下发规则和进行请求匹配时，就需要进行协调：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义好 Virtual Host 配置中的 domains 字段和 route 中的 match 用到的字段在当前通讯协议中的实际语义&lt;/li&gt;
&lt;li&gt;在 protocol encoder 中读取请求的协议字段，和上面的字段对应&lt;/li&gt;
&lt;li&gt;然后进行请求路由规则匹配（参照 HTTP/1.1 中的 domain 和 route match 的匹配）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这些都是需要以代码的方式进行实现，以满足新通讯协议的要求。正规的做法，是每次新增一个通讯协议就将上述的工作内容重复一遍。这会直接导致大量的高度类似的重复代码。&lt;/p&gt;
&lt;h2 id=&#34;x-protocol-的实现&#34;&gt;x-protocol 的实现&lt;/h2&gt;
&lt;p&gt;在上述需要在协议扩展时修改的四个内容中，有一块是特别的：生成 Virtual Host 配置的工作是在 Pilot 中实现的，而其他三个是在 Sidecar（Envoy 或 MOSN）中。考虑到 protocol encoder 和 protocol decoder 的工作是必不可少的，必然会修改 Sidecar 来增加实现代码，因此简化开发的第一个想法就是：能不能做到不修改 Pilot？&lt;/p&gt;
&lt;p&gt;基本思路就是固定好原始语义，避免每个通讯协议都映射一遍。从前面我们列出来的各个协议的映射情况看，对于 RPC 协议而言，一般目的地信息都是服务名 (有些是接口名)+方法名居多，因此可以考虑直接将服务名和方法名固定下来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RPC 协议在 Virtual Host 配置中就固定为服务名对应 domains 字段，方法名对应 route 中的 match 用到的字段，这样只要修改一次然后各个 RPC 协议公用此配置，以后就不用再重复修改 Pilot。&lt;/li&gt;
&lt;li&gt;protocol encoder 在解析通讯协议完成之后，就直接将协议中对应服务名和方法名的字段提取出来，后面的匹配处理过程就可以公用一套通用实现，这样路由匹配这块也可以不用在重复开发。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在 x-protocol 中，如果需要引入一个新的通讯协议，需要的工作内容只有必不可少的 protocol encoder 和 protocol decoder，和实现以下几个接口：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/x-protocol-tcp-protocol-extension/xprotocol-interfaces_hue021c55e181a756d6a525baf9ca0eda7_95934_5bf098ce4d435353b64fa631895220e1.webp 400w,
               /blog/x-protocol-tcp-protocol-extension/xprotocol-interfaces_hue021c55e181a756d6a525baf9ca0eda7_95934_db60f44bd88383b327d206a940eeb62b.webp 760w,
               /blog/x-protocol-tcp-protocol-extension/xprotocol-interfaces_hue021c55e181a756d6a525baf9ca0eda7_95934_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-tcp-protocol-extension/xprotocol-interfaces_hue021c55e181a756d6a525baf9ca0eda7_95934_5bf098ce4d435353b64fa631895220e1.webp&#34;
               width=&#34;503&#34;
               height=&#34;517&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;X-protocol 在支持新通讯协议上的做法并无新奇之处，只是由于需求特殊有众多通讯协议需要支持，在开发时发现大量重复工作，因此我们选择了一条可以让后面更舒服一点的道路。&lt;/p&gt;
&lt;p&gt;目前这个方案在 SOFAMesh 中采用，我们将进一步检验实际效果，也会和合作的小伙伴时验证，看他们在自行扩展新协议时是否足够理想。这个方案理论上应该可以同样适用于 Istio、Envoy 体系，随着社区对 Istio 的接受程度的提高，在 Istio 上支持各种 TCP 通讯协议的需求会越来越多，有理由相信 Istio 后续可能也会出现类似的方案。毕竟，每次都改一大堆类似的东西，不是一个好做法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（2）——快速解码转发</title>
      <link>https://cloudnative.to/blog/x-protocol-rapid-decode-forward/</link>
      <pubDate>Wed, 10 Oct 2018 11:45:26 +0800</pubDate>
      <guid>https://cloudnative.to/blog/x-protocol-rapid-decode-forward/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是 SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列文章之一。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（1）——DNS 通用寻址方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnative.to/blog/x-protocol-rapid-decode-forward/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（2）——快速解码转发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnative.to/blog/x-protocol-tcp-protocol-extension/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（3）——TCP 协议扩展&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 Istio 和 Envoy 中，对通讯协议的支持，主要体现在 HTTP/1.1 和 HTTP/2 上，而我们 SOFAMesh，则需要支持以下几个 RPC 协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOFARPC：这是蚂蚁金服大量使用的 RPC 协议（已开源）&lt;/li&gt;
&lt;li&gt;HSF RPC：这是阿里集团内部大量使用的 RPC 协议（未开源）&lt;/li&gt;
&lt;li&gt;Dubbo RPC: 这是社区广泛使用的 RPC 协议（已开源）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;更适合的平衡点性能和功能&#34;&gt;更适合的平衡点：性能和功能&lt;/h3&gt;
&lt;p&gt;对于服务间通讯解决方案，性能永远是一个值得关注的点。而 SOFAMesh 在项目启动时就明确要求在性能上要有更高的追求，为此，我们不得不在 Istio 标准实现之外寻求可以获取更高性能的方式，比如支持各种 RPC 协议。&lt;/p&gt;
&lt;p&gt;期间有两个发现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Istio在处理所有的请求转发如REST/gRPC时，会解码整个请求的header信息，拿到各种数据，提取为Attribute，然后以此为基础，提供各种丰富的功能，典型如Content Based Routing。&lt;/li&gt;
&lt;li&gt;而在测试中，我们发现：解码请求协议的 header 部分，对 CPU 消耗较大，直接影响性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，我们有了一个很简单的想法：是不是可以在转发时，不开启部分功能，以此换取转发过程中的更少更快的解码消耗？毕竟，不是每个服务都需要用到 Content Based Routing 这样的高级特性，大部分服务只使用 Version Based Routing，尤其是使用 RPC 通讯协议的服务，没有 HTTP 那么表现力丰富的 header，对 Content Based Routing 的需求要低很多。&lt;/p&gt;
&lt;p&gt;此外，对于部分对性能有极高追求的服务，不开启高级特性而换取更高的性能，也是一种满足性能要求的折中方案。考虑到系统中总存在个别服务对性能非常敏感，我们觉得 Service Mesh 提供一种性能可以接近直连的方案会是一个有益的补充。为了满足这些特例而不至于因此整体否决 Service Mesh 方案，我们需要在 Service Mesh 的大框架下提供一个折中方案。&lt;/p&gt;
&lt;h2 id=&#34;请求转发&#34;&gt;请求转发&lt;/h2&gt;
&lt;p&gt;在我们进一步深入前，我们先来探讨一下实现请求转发的技术细节。&lt;/p&gt;
&lt;p&gt;有一个关键问题：当 Envoy/SOFA MOSN 这样的代理程序，接收到来自客户端的 TCP 请求时，需要获得哪些信息，才可以正确的转发请求到上游的服务器端？&lt;/p&gt;
&lt;h3 id=&#34;最关键的信息destination&#34;&gt;最关键的信息：destination&lt;/h3&gt;
&lt;p&gt;首先，毫无疑问的，必须拿到 destination/目的地，也就是客户端请求必须通过某种方式明确的告之代理该请求的 destination，这样代理程序才能根据这个 destionation 去找到正确的目标服务器，然后才有后续的连接目标服务器和转发请求等操作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zu0jen9j30vs0d475q_huf93c92228802cabcaf39c1704752ab22_52083_37d87d56e174d34865a8872b08d54901.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zu0jen9j30vs0d475q_huf93c92228802cabcaf39c1704752ab22_52083_7b47216a9c17a595ad0e97ad56024043.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zu0jen9j30vs0d475q_huf93c92228802cabcaf39c1704752ab22_52083_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zu0jen9j30vs0d475q_huf93c92228802cabcaf39c1704752ab22_52083_37d87d56e174d34865a8872b08d54901.webp&#34;
               width=&#34;760&#34;
               height=&#34;314&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Destination 信息的表述形式可能有：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. IP 地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能是服务器端实例实际工作的 IP 地址和端口，也可能是某种转发机制，如 Nginx/HAProxy 等反向代理的地址或者 Kubernetes 中的 ClusterIP。&lt;/p&gt;
&lt;p&gt;举例：“192.168.1.1:8080”是实际 IP 地址和端口，“10.2.0.100:80”是 ngxin 反向代理地址，“172.168.1.105:80”是 Kubernetes 的 ClusterIP。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 目标服务的标识符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可用于名字查找，如服务名，可能带有各种前缀后缀。然后通过名字查找/服务发现等方式，得到地址列表（通常是 IP 地址 + 端口形式）。&lt;/p&gt;
&lt;p&gt;举例：“userservice”是标准服务名， “com.alipay/userservice”是加了域名前缀的服务名， “service.default.svc.cluster.local”是 k8s 下完整的全限定名。&lt;/p&gt;
&lt;p&gt;Destination 信息在请求报文中的携带方式有：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 通过通讯协议传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是最常见的形式，标准做法是通过 header 头，典型如 HTTP/1.1 下一般使用 host header，举例如“Host: userservice”。HTTP/2 下，类似的使用“:authority”header。&lt;/p&gt;
&lt;p&gt;对于非 HTTP 协议，通常也会有类似的设计，通过协议中某些字段来承载目标地址信息，只是不同协议中这个字段的名字各有不同。如 SOFARPC，HSF 等。&lt;/p&gt;
&lt;p&gt;有些通讯协议，可能会将这个信息存放在 payload 中，比如后面我们会介绍到的 dubbo 协议，导致需要反序列化 payload 之后才能拿到这个重要信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 通过 TCP 协议传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一种非常特殊的方式，通过在 TCP option 传递，上一节中我们介绍 Istio DNS 寻址时已经详细介绍过了。&lt;/p&gt;
&lt;h3 id=&#34;tcp-拆包&#34;&gt;TCP 拆包&lt;/h3&gt;
&lt;p&gt;如何从请求的通讯协议中获取 destination？这涉及到具体通讯协议的解码，其中第一个要解决的问题就是如何在连续的 TCP 报文中将每个请求内容拆分开，这里就涉及到经典的 TCP 沾包、拆包问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuc1molj30vw0ayaax_hu18ef8036fa90da05c10b49c63267f19a_25646_6bd31f5300234246f191cc8ce7ab6448.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuc1molj30vw0ayaax_hu18ef8036fa90da05c10b49c63267f19a_25646_c466b8ea41006f5ee3c2de7c216b58a9.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuc1molj30vw0ayaax_hu18ef8036fa90da05c10b49c63267f19a_25646_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuc1molj30vw0ayaax_hu18ef8036fa90da05c10b49c63267f19a_25646_6bd31f5300234246f191cc8ce7ab6448.webp&#34;
               width=&#34;760&#34;
               height=&#34;261&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;转发请求时，由于涉及到负载均衡，我们需要将请求发送给多个服务器端实例。因此，有一个非常明确的要求：就是必须以单个请求为单位进行转发。即单个请求必须完整的转发给某台服务器端实例，负载均衡需要以请求为单位，不能将一个请求的多个报文包分别转发到不同的服务器端实例。所以，拆包是请求转发的必备基础。&lt;/p&gt;
&lt;p&gt;由于篇幅和主题限制，我们不在这里展开 TCP 沾包、拆包的原理。后面针对每个具体的通讯协议进行分析时再具体看各个协议的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;多路复用的关键参数requestid&#34;&gt;多路复用的关键参数：RequestId&lt;/h3&gt;
&lt;p&gt;RequestId 用来关联 request 和对应的 response，请求报文中携带一个唯一的 id 值，应答报文中原值返回，以便在处理 response 时可以找到对应的 request。当然在不同协议中，这个参数的名字可能不同（如 streamid 等）。&lt;/p&gt;
&lt;p&gt;严格说，RequestId 对于请求转发是可选的，也有很多通讯协议不提供支持，比如经典的 HTTP1.1 就没有支持。但是如果有这个参数，则可以实现多路复用，从而可以大幅度提高 TCP 连接的使用效率，避免出现大量连接。稍微新一点的通讯协议，基本都会原生支持这个特性，比如 SOFARPC、Dubbo、HSF，还有 HTTP/2 就直接內建了多路复用的支持。&lt;/p&gt;
&lt;p&gt;HTTP/1.1不支持多路复用（http1.1有提过支持幂等方法的pipeline机制但是未能普及），用的是经典的ping-pong模式：在请求发送之后，必须独占当前连接，等待服务器端给出这个请求的应答，然后才能释放连接。因此HTTP/1.1下，并发多个请求就必须采用多连接，为了提升性能通常会使用长连接+连接池的设计。而如果有了requestid和多路复用的支持，客户端和Mesh之间理论上就可以只用一条连接（实践中可能会选择建立多条）来支持并发请求：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zujxeh7j313x0dwtaz_hu2e1713641a39fa208ace680993f05980_79570_d5ef86b93bbe043622da9103ac7d7839.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zujxeh7j313x0dwtaz_hu2e1713641a39fa208ace680993f05980_79570_8b995725a8d495b11fa177860df20352.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zujxeh7j313x0dwtaz_hu2e1713641a39fa208ace680993f05980_79570_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zujxeh7j313x0dwtaz_hu2e1713641a39fa208ace680993f05980_79570_d5ef86b93bbe043622da9103ac7d7839.webp&#34;
               width=&#34;760&#34;
               height=&#34;265&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而 Mesh 与服务器（也可能是对端的 Mesh）之间，也同样可以受益于多路复用技术，来自不同客户端而去往同一个目的地的请求可以混杂在同一条连接上发送。通过 RequestId 的关联，Mesh 可以正确将 reponse 发送到请求来自的客户端。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuxvz4lj310r0dzwgj_hu6cfbed2f112356d30fd55b385ce34bb2_71901_1d2475c8979ccf50f497ccd89be38f9b.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuxvz4lj310r0dzwgj_hu6cfbed2f112356d30fd55b385ce34bb2_71901_8abba393b07592da51693462b90689d4.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuxvz4lj310r0dzwgj_hu6cfbed2f112356d30fd55b385ce34bb2_71901_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuxvz4lj310r0dzwgj_hu6cfbed2f112356d30fd55b385ce34bb2_71901_1d2475c8979ccf50f497ccd89be38f9b.webp&#34;
               width=&#34;760&#34;
               height=&#34;289&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;由于篇幅和主题限制，我们不在这里展开多路复用的原理。后面针对每个具体的通讯协议进行分析时再具体看各个协议的支持情况。&lt;/p&gt;
&lt;h3 id=&#34;请求转发参数总结&#34;&gt;请求转发参数总结&lt;/h3&gt;
&lt;p&gt;上面的分析中，我们可以总结到，对于 Sidecar，要正确转发请求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须获取到 destination 信息，得到转发的目的地，才能进行服务发现类的寻址&lt;/li&gt;
&lt;li&gt;必须要能够正确的拆包，然后以请求为单位进行转发，这是负载均衡的基础&lt;/li&gt;
&lt;li&gt;可选的 RequestId，这是开启多路复用的基础&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，这里我们的第一个优化思路就出来了：尽量只解码获取这三个信息，满足转发的基本要求。其他信息如果有性能开销则跳过解码，所谓“快速解码转发”。基本原理就是牺牲信息完整性追求性能最大化。&lt;/p&gt;
&lt;p&gt;而结合上一节中我们引入的 DNS 通用寻址方案，我们是可以从请求的 TCP options 中得到 ClusterIP，从而实现寻址。这个方式可以实现不解码请求报文，尤其是 header 部分解码 destination 信息开销大时。这是我们的第二个优化思路：跳过解码 destination 信息，直接通过 ClusterIP 进行寻址。&lt;/p&gt;
&lt;p&gt;具体的实现则需要结合特定通讯协议的实际情况进行。&lt;/p&gt;
&lt;h2 id=&#34;主流通讯协议&#34;&gt;主流通讯协议&lt;/h2&gt;
&lt;p&gt;现在我们开始，以 Proxy、Sidecar、Service Mesh 的角度来看看目前主流的通讯协议和我们前面列举的需要在 SOFAMesh 中支持的几个协议。&lt;/p&gt;
&lt;h3 id=&#34;sofarpcbolt协议&#34;&gt;SOFARPC/bolt协议&lt;/h3&gt;
&lt;p&gt;SOFARPC 是一款基于 Java 实现的 RPC 服务框架，详细资料可以查阅 官方文档。SOFARPC 支持 bolt，rest，dubbo 协议进行通信。REST、dubbo 后面单独展开，这里我们关注 bolt 协议。&lt;/p&gt;
&lt;p&gt;bolt 是蚂蚁金服集团开放的基于 Netty 开发的网络通信框架，其协议格式是变长，即协议头+payload。具体格式定义如下，以 request 为例（response 类似）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zv3sqhij312j0833zq_hued217f2a09cd4c777d3a2f3192580a41_42584_960fffea39d84ee3d910879f30783a39.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zv3sqhij312j0833zq_hued217f2a09cd4c777d3a2f3192580a41_42584_ce25ae844da9b55e4db24cacea484102.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zv3sqhij312j0833zq_hued217f2a09cd4c777d3a2f3192580a41_42584_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zv3sqhij312j0833zq_hued217f2a09cd4c777d3a2f3192580a41_42584_960fffea39d84ee3d910879f30783a39.webp&#34;
               width=&#34;760&#34;
               height=&#34;160&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们只关注和请求转发直接相关的字段：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP 拆包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bolt 协议是定长 + 变长的复合结构，前面 22 个字节长度固定，每个字节和协议字段的对应如图所示。其中 classLen、headerLen 和 contentLen 三个字段指出后面三个变长字段 className、header、content 的实际长度。和通常的变长方案相比只是变长字段有三个。拆包时思路简单明了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先读取前 22 个字节，解出各个协议字段的实际值，包括 classLen，headerLen 和 contentLen&lt;/li&gt;
&lt;li&gt;按照 classLen、headerLen 和 contentLen 的大小，继续读取 className、header、content&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Destination&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bolt 协议中的 header 字段是一个 map，其中有一个 key 为“service”的字段，传递的是接口名/服务名。读取稍微麻烦一点点，需要先解码整个 header 字段，这里对性能有影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RequestId&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Blot 协议固定字段中的&lt;code&gt;requestID&lt;/code&gt;字段，可以直接读取。&lt;/p&gt;
&lt;p&gt;SOFARPC 中的 bolt 协议，设计的比较符合请求转发的需要，TCP 拆包，读取 RequestID，都没有性能问题。只是 Destination 的获取需要解码整个 header，性能开销稍大。&lt;/p&gt;
&lt;p&gt;总结：适合配合 DNS 通用解码方案，跳过对整个 header 部分的解码，从而提升性能。当然由于这个 header 本身也不算大，优化的空间有限，具体提升需要等对比测试的结果出来。&lt;/p&gt;
&lt;h3 id=&#34;hsf-协议&#34;&gt;HSF 协议&lt;/h3&gt;
&lt;p&gt;HSF 协议是经过精心设计工作在 4 层的私有协议，由于该协议没有开源，因此不便直接暴露具体格式和字段详细定义。&lt;/p&gt;
&lt;p&gt;不过基本的设计和 bolt 非常类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用变长格式，即协议头+payload&lt;/li&gt;
&lt;li&gt;在协议头中可以直接拿到服务接口名和服务方法名作为 Destination&lt;/li&gt;
&lt;li&gt;有 RequestID 字段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本和 bolt 一致，考虑到 Destination 可以直接读取，比 bolt 还要方便一些，HSF 协议可以说是对请求转发最完美的协议。&lt;/p&gt;
&lt;p&gt;总结：目前的实现方案也只解码了这三个关键字段，速度足够快，不需要继续优化。&lt;/p&gt;
&lt;h3 id=&#34;dubbo-协议&#34;&gt;Dubbo 协议&lt;/h3&gt;
&lt;p&gt;Dubbo 协议也是类似的协议头+payload 的变长结构，其协议格式如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvfi4g9j30oh03gmxj_hub6b1232ae72f161aa090bbc297f82395_16278_6fd9fe6875ef5399b94346cc7a3e39c2.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvfi4g9j30oh03gmxj_hub6b1232ae72f161aa090bbc297f82395_16278_432eb51b664568b20a9eeb353ddb9e50.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvfi4g9j30oh03gmxj_hub6b1232ae72f161aa090bbc297f82395_16278_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvfi4g9j30oh03gmxj_hub6b1232ae72f161aa090bbc297f82395_16278_6fd9fe6875ef5399b94346cc7a3e39c2.webp&#34;
               width=&#34;760&#34;
               height=&#34;107&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其中 long 类型的&lt;code&gt;id&lt;/code&gt;字段用来把请求 request 和返回的 response 对应上，即我们所说的&lt;code&gt;RequestId&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这样 TCP 拆包和多路复用都轻松实现，稍微麻烦一点的是：Destination 在哪里？Dubbo 在这里的设计有点不够理想，在协议头中没有字段可以直接读取到 Destination，需要去读取 data 字段，也就是 payload，里面的 path 字段通常用来保存服务名或者接口名。method 字段用来表示方法名。&lt;/p&gt;
&lt;p&gt;从设计上看，path 字段和 method 字段被存放在 payload 中有些美中不足。庆幸的是，读取这两个字段的时候不需要完整的解开整个 payload，好险，不然，那性能会没法接受的。&lt;/p&gt;
&lt;p&gt;以 hession2 为例，data 字段的组合是：dubbo version + path + interface version + method + ParameterTypes + Arguments + Attachments。每个字段都是一个 byte 的长度 + 字段值的 UTF bytes。因此读取时并不复杂，速度也足够快。&lt;/p&gt;
&lt;p&gt;基本和 HSF 一致，就是 Destination 的读取稍微麻烦一点，放在 payload 中的设计让人吓了一跳，好在有惊无险。整体说还是很适合转发的。&lt;/p&gt;
&lt;p&gt;总结：同 HSF，不需要继续优化。&lt;/p&gt;
&lt;h3 id=&#34;http11&#34;&gt;HTTP/1.1&lt;/h3&gt;
&lt;p&gt;HTTP/1.1的格式应该大家都熟悉，而在这里，不得不指出，HTTP/1.1协议对请求转发是非常不友好的（甚至可以说是恶劣！）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP 请求在拆包时，需要先按照 HTTP header 的格式，一行一行读取，直到出现空行表示 header 结束&lt;/li&gt;
&lt;li&gt;然后必须将整个 header 的内容全部解析出来，才能取出&lt;code&gt;Content-Length header&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Content-Length&lt;/code&gt; 值，才能完成对 body 内容的读取，实现正确拆包&lt;/li&gt;
&lt;li&gt;如果是 chunked 方式，则更复杂一些&lt;/li&gt;
&lt;li&gt;Destination 通常从&lt;code&gt;Host&lt;/code&gt; header 中获取&lt;/li&gt;
&lt;li&gt;没有 RequestId，完全无法实现多路复用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这意味着，为了完成最基本的 TCP 拆包，必须完整的解析全部的 HTTP header 信息，没有任何可以优化的空间。对比上面几个 RPC 协议，轻松自如的快速获取几个关键信息，HTTP 无疑要重很多。这也造成了在 ServiceMesh 下，HTTP/1.1 和 REST 协议的性能总是和其他 RPC 方案存在巨大差异。&lt;/p&gt;
&lt;p&gt;对于注定要解码整个 header 部分，完全没有优化空间可言的 HTTP/1.1 协议来说，Content Based Routing 的解码开销是必须付出的，无论是否使用 Content Based Routing。因此，快速解码的构想，对 HTTP/1.1 无效。&lt;/p&gt;
&lt;p&gt;总结：受 HTTP/1.1 协议格式限制，上述两个优化思路都无法操作。&lt;/p&gt;
&lt;h3 id=&#34;http2和grpc&#34;&gt;HTTP/2和gRPC&lt;/h3&gt;
&lt;p&gt;作为HTTP/1.1的接班人，HTTP/2则表现的要好很多。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：当然 HTTP/2 的协议格式复杂多了，由于篇幅和主题的限制，这里不详细介绍 HTTP/2 的格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先HTTP/2是以帧的方式组织报文的，所有的帧都是变长，固定的9个字节+可变的payload，Length字段指定payload的大小：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvsjz65j30jg0650tg_hu690b3aba121ab0f845d3e9d1c091f3eb_30775_bae9dc3bcd2d7cff745ccef0b03d5bb5.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvsjz65j30jg0650tg_hu690b3aba121ab0f845d3e9d1c091f3eb_30775_a411c33d3170410458a9ffc293546f10.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvsjz65j30jg0650tg_hu690b3aba121ab0f845d3e9d1c091f3eb_30775_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvsjz65j30jg0650tg_hu690b3aba121ab0f845d3e9d1c091f3eb_30775_bae9dc3bcd2d7cff745ccef0b03d5bb5.webp&#34;
               width=&#34;700&#34;
               height=&#34;221&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;HTTP2 的请求和应答，也被称为 Message，是由多个帧构成，在去除控制帧之外，Message 通常由 Header 帧开始，后面接 CONTINUATION 帧和 Data 帧（也可能没有，如 GET 请求）。每个帧都可以通过头部的 Flags 字段来设置 END_STREAM 标志，表示请求或者应答的结束。即 TCP 拆包的问题在 HTTP/2 下是有非常标准而统一的方式完成，完全和 HTTP/2 上承载的协议无关。&lt;/p&gt;
&lt;p&gt;HTTP/2通过Stream內建多路复用，这里的&lt;code&gt;Stream Identifier&lt;/code&gt; 扮演了类似前面的&lt;code&gt;RequestId&lt;/code&gt;的角色。&lt;/p&gt;
&lt;p&gt;而 Destination 信息则通过 Header 帧中的伪 header &lt;code&gt;:authority&lt;/code&gt; 来传递，类似 HTTP/1.1 中的&lt;code&gt;Host&lt;/code&gt; header。不过 HTTP/2 下 header 会进行压缩，读取时稍微复杂一点，也存在需要解压缩整个 header 帧的性能开销。考虑到拆包和获取 RequestId 都不需要解包（只需读取协议头，即 HTTP/2 帧的固定字段），速度足够快，因此存在很大的优化空间：不解码 header 帧，直接通过 DNS 通用寻址方案，这样性能开销大为减少，有望获得极高的转发速度。&lt;/p&gt;
&lt;p&gt;总结：HTTP/2 的帧设计，在请求转发时表现的非常友好。唯独 Destination 信息放在 header 中，会造成必须解码 header 帧。好在 DNS 通用寻址方案可以弥补，实现快速解码和转发。&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-时代的-rpc-理想方案&#34;&gt;Service Mesh 时代的 RPC 理想方案&lt;/h2&gt;
&lt;p&gt;在文章的最后，我们总结并探讨一下，对于 Service Mesh 而言，什么样的 RPC 方案是最理想的？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须可以方便做 TCP 拆包，最好在协议头中就简单搞定，标准方式如固定协议头+length 字段 + 可变 payload。HSF 协议、bolt 协议和 dubbo 协议表现完美，HTTP/2 采用帧的方式，配合 END_STREAM 标志，方式独特但有效。HTTP/1.1 则是反面典型。&lt;/li&gt;
&lt;li&gt;必须可以方便的获取 destination 字段，同样最好在协议头中就简单搞定。HSF 协议表现完美，dubbo 协议藏在 payload 中但终究还是可以快速解码有惊无险的过关，bolt 协议和 HTTP/2 协议就很遗憾必须解码 header 才能拿到，好在 DNS 通用寻址方案可以弥补，但终究丢失了服务名和方法名信息。HTTP/1.1 依然是反面典型。&lt;/li&gt;
&lt;li&gt;最好有 RequestId 字段，同样最好在协议头中就简单搞定。这方面 HSF 协议、dubbo 协议、bolt 协议表现完美，HTTP/2 协议更是直接內建支持。HTTP/1.1 继续反面典型。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，仅以方便用最佳性能进行转发，对 Service Mesh、sidecar 友好而言，最理想的 RPC 方案是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统的变长协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;固定协议头+length 字段 + 可变 payload，然后在固定协议头中直接提供 RequestId 和 destination。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于帧的协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以HTTP/2为基础，除了请求结束的标志位和RequestId外，还需要通过帧的固定字段来提供destination信息。&lt;/p&gt;
&lt;p&gt;或许，在未来，在 Service Mesh 普及之后，对 Service Mesh 友好成为 RPC 协议的特别优化方向，我们会看到表现完美更适合 Service Mesh 时代的新型 RPC 方案。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（1）——DNS 通用寻址方案</title>
      <link>https://cloudnative.to/blog/x-protocol-common-address-solution/</link>
      <pubDate>Mon, 08 Oct 2018 14:58:03 +0800</pubDate>
      <guid>https://cloudnative.to/blog/x-protocol-common-address-solution/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是 SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列文章之一。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（1）——DNS 通用寻址方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnative.to/blog/x-protocol-rapid-decode-forward/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（2）——快速解码转发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnative.to/blog/x-protocol-tcp-protocol-extension/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（3）——TCP 协议扩展&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 2018 年上半年，蚂蚁金服决定基于 Istio 订制自己的 ServiceMesh 解决方案，在 6 月底对外公布了 SOFAMesh，详情请见之前的文章：&lt;a href=&#34;https://skyao.io/publication/201806-service-mesh-explore/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大规模微服务架构下的 Service Mesh 探索之路&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;在 SOFAMesh 的开发过程中，针对遇到的实际问题，我们给出了一套名为 x-protocol 的解决方案，定位是云原生、高性能、低侵入性的通用 Service Mesh 落地方案，依托 Kubernetes 基座，利用其原生的服务注册和服务发现机制，支持各种私有 RPC 协议低成本、易扩展的接入，快速享受 Service Mesh 所带来的红利。&lt;/p&gt;
&lt;p&gt;具体解决的问题包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多通讯协议支持问题，减少开发工作量，简单快捷的接入新协议&lt;/li&gt;
&lt;li&gt;尽量提升性能，提供更灵活的性能与功能的平衡点选择，满足特定高性能场景&lt;/li&gt;
&lt;li&gt;兼容现有 SOA 体系，提供通过接口进行访问的方式，实现不修改业务代码也能顺利接入 Service Mesh&lt;/li&gt;
&lt;li&gt;支持单进程多服务的传统 SOA 程序，可以在微服务改造之前，先受益于 Service Mesh 带来的强大功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本系列文章中，我们将对此进行详细的讲解，首先是“DNS 通用寻址方案”。&lt;/p&gt;
&lt;h2 id=&#34;背景和需求&#34;&gt;背景和需求&lt;/h2&gt;
&lt;h3 id=&#34;soa-的服务模型&#34;&gt;SOA 的服务模型&lt;/h3&gt;
&lt;p&gt;在 SOFAMesh 计划支持的 RPC 框架中，SOFARPC、HSF、Dubbo 都是一脉相承的 SOA 体系，也都支持经典的 SOA 服务模型，通常称为”单进程多服务”，或者叫做”单进程多接口”。（备注：由于服务一词使用过于频繁，下文都统一称为接口以便区分）&lt;/p&gt;
&lt;p&gt;SOA 标准的服务注册，服务发现和调用流程如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201809-xprotocol-common-address-solution/images/soa-standard-process.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在单个 SOA 应用进程内，存在多个接口&lt;/li&gt;
&lt;li&gt;服务注册时，以接口为单位进行多次独立的服务注册&lt;/li&gt;
&lt;li&gt;当客户端进行调用时，按照接口进行服务发现，然后发起调用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当我们试图将这些 SOA 架构的应用搬迁到 ServiceMesh 时，就会遇到服务模型的问题：微服务是单服务模型，也就是一个进程里面只承载一个服务。以 Kubernetes 的服务注册为例，在单进程单服务的模型下，服务名和应用名可以视为一体，Kubernetes 的自动服务注册会将应用名作为服务注册的标示。&lt;/p&gt;
&lt;p&gt;这就直接导致了 SOA 模型和微服务模型的不匹配问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOA 以接口为单位做服务注册和服务发现，而微服务下是服务名&lt;/li&gt;
&lt;li&gt;SOA 是”单进程多接口”，而微服务是”单进程单服务”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一步接一步的需求&#34;&gt;一步接一步的需求&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先上车后补票&lt;/p&gt;
&lt;p&gt;最理想的做法当然是先进行微服务改造，实现微服务拆分。但是考虑到现有应用数量众多，我们可能更愿意在大规模微服务改造之前，先想办法让这些应用可以运行在 ServiceMesh 下，提前受益于 Service Mesh 带来的强大功能。因此，我们需要找到一个合适的方案，让 ServiceMesh 支持没有做微服务改造依然是”单进程多接口”形式的传统 SOA 应用，所谓”先上车后补票”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不修改代码&lt;/p&gt;
&lt;p&gt;考虑到原有的 SOA 应用，相互之间错综复杂的调用关系，最好不要修改代码，即保持客户端依然通过接口名来访问的方式。当然，SOA 架构的客户端 SDK 可能要进行改动，将原有的通过接口名进行服务发现再自行负载均衡进行远程调用的方式，精简为标准的 Servicemesh 调用（即走 Sidecar），因此修改 SDK 依赖包和重新打包应用是不可避免。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持带特殊字符的接口名&lt;/p&gt;
&lt;p&gt;Kubernetes 的服务注册，Service 名是不能携带”.“号的。而 SOA 架构下，接口名有时出于管理方便，有可能是加了域名前缀，如”com.alipay.demo.interface-2”。为了实现不修改原有代码，就只能想办法支持这种带特殊字符的接口名。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考-kubernetes-和-istio&#34;&gt;参考 Kubernetes 和 Istio&lt;/h2&gt;
&lt;p&gt;在进一步讨论解决方案之前，我们先来看一下 kubernetes 和 Istio 中的标准请求寻址方式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：过程稍显复杂，涉及到 Kubernetes/Istio 的一些底层细节。但是了解这个过程对后续的理解非常重要，也可以帮助大家了解 Kubernetes 和 Kubernetes 的工作原理，强烈推荐阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;kubernetes-下的-dns-寻址方式&#34;&gt;Kubernetes 下的 DNS 寻址方式&lt;/h3&gt;
&lt;p&gt;在 Kubernetes 下，如图所示，假定我们部署了一个名为 userservice 的应用，有三个实例，分别在三个 pod 中。则应用部署之后，Kubernetes 会为这个应用分配 ClusterIP 和域名，并在 DNS 中生成一条 DNS 记录，将域名映射到 ClusterIP：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kubernetes-下的-dns-寻址方式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kubernetes 下的 DNS 寻址方式&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u1crhhoj30zz0grad5_hucc81464f40e05ba89f12f4d232053ae9_105561_e00de79b4880c223e53be2332a236ed5.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u1crhhoj30zz0grad5_hucc81464f40e05ba89f12f4d232053ae9_105561_cdfd50655110d683d638702f79b2efd6.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u1crhhoj30zz0grad5_hucc81464f40e05ba89f12f4d232053ae9_105561_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/006tNbRwly1fw0u1crhhoj30zz0grad5_hucc81464f40e05ba89f12f4d232053ae9_105561_e00de79b4880c223e53be2332a236ed5.webp&#34;
               width=&#34;760&#34;
               height=&#34;354&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kubernetes 下的 DNS 寻址方式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当部署在 Kubernetes 下的某个充当客户端的应用发起请求时，如图中的 HTTP GET 请求，目标 URL 地址为“&lt;a href=&#34;http://userservice/id/1000221&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://userservice/id/1000221&lt;/a&gt;&amp;quot;。请求的寻址方式和过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先进行域名解析，分别尝试解析”userservice”/“userservie.default.svc.cluster.local”等域名，得到 ClusterIP&lt;/li&gt;
&lt;li&gt;然后客户端发出请求的报文，目标地址为 ClusterIP，源地址为当前客户端所在的 pod IP（简单起见，端口先忽略）&lt;/li&gt;
&lt;li&gt;请求报文随即被 kube-proxy 拦截，kube-proxy 根据 ClusterIP，拿到 ClusterIP 对应的多个实际服务实例所在的 pod ip，取其中一个，修改目标地址为这个 pod IP&lt;/li&gt;
&lt;li&gt;请求报文最终就被发送到服务实例所在的 pod IP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应答回来的方式类似，userservice 发出的应答报文会被 kube-proxy 拦截并修改为发送到客户端所在的 pod IP。&lt;/p&gt;
&lt;p&gt;我们详细看一下请求和应答全称的四个请求包的具体内容（简单起见继续忽略端口）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kubernetes-dns-寻址&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kubernetes DNS 寻址&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u1t6ucmj31an0hs79k_hud8a8f19b12fa4829b0533c895642acae_179202_fc136ab38d7c46e501dd92b9c9e7f8eb.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u1t6ucmj31an0hs79k_hud8a8f19b12fa4829b0533c895642acae_179202_b98c8505771af2e94d4040011f898248.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u1t6ucmj31an0hs79k_hud8a8f19b12fa4829b0533c895642acae_179202_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/006tNbRwly1fw0u1t6ucmj31an0hs79k_hud8a8f19b12fa4829b0533c895642acae_179202_fc136ab38d7c46e501dd92b9c9e7f8eb.webp&#34;
               width=&#34;760&#34;
               height=&#34;289&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kubernetes DNS 寻址
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;重点关注请求和应答报文的源地址和目标地址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发出的请求，为”客户端到 ClusterIP”&lt;/li&gt;
&lt;li&gt;kube-proxy 拦截到请求后，将请求修改为”客户端到服务器端”&lt;/li&gt;
&lt;li&gt;服务器端收到请求时，表现为”客户端到服务器端”，ClusterIP 被 kube-proxy 屏蔽&lt;/li&gt;
&lt;li&gt;服务器端发送应答，因为收到的请求看似来自客户端，因此应答报文为”服务器端到客户端”&lt;/li&gt;
&lt;li&gt;应答报文被 kube-proxy 拦截，将应答修改为”ClusterIP 到服务器端”&lt;/li&gt;
&lt;li&gt;客户端收到应答，表现为”ClusterIP 到服务器端”，服务器端 IP 被 kube-proxy 屏蔽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;kube-proxy 在客户端和服务器端之间拦截并修改请求和应答的报文，联通两者，但各自屏蔽了一些信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在客户端看来它是在和 ClusterIP 交互，userservice 的具体服务器端实例对客户端是无感知的&lt;/li&gt;
&lt;li&gt;在服务器端看来，客户端是直接在和它交互，ClusterIP 的存在对服务器端是无感知的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更深入一步，看 kube-proxy 在两个拦截和修改报文中的逻辑处理关系，即 kube-proxy 是如何在收到应答时正确的找回原有的 ClusterIP：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-与-clusterip&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kube-proxy 与 ClusterIP&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u2dtdpuj317q0fhtcw_hue0f4af6d0ed7c479c4fb78d58f031209_147625_aaf24845109354cd053f1f97650500c3.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u2dtdpuj317q0fhtcw_hue0f4af6d0ed7c479c4fb78d58f031209_147625_58ed5535b6e00d42fba5ad0e89ea6055.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u2dtdpuj317q0fhtcw_hue0f4af6d0ed7c479c4fb78d58f031209_147625_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/006tNbRwly1fw0u2dtdpuj317q0fhtcw_hue0f4af6d0ed7c479c4fb78d58f031209_147625_aaf24845109354cd053f1f97650500c3.webp&#34;
               width=&#34;760&#34;
               height=&#34;269&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      kube-proxy 与 ClusterIP
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在拦截并修改请求报文之后，kube-proxy 会保存报文修改的 5 元组对应关系（5 元组指源 IP 地址，源端口，协议，目的地 IP 地址，目的地端口）&lt;/li&gt;
&lt;li&gt;在收到应答报文后，根据应答报文中的 5 元组，在保存的 5 元组对应关系中，找到对应信息，得到原有的 ClusterIP 和端口，然后修改应答报文&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结，通过上述 Kubernetes 下的寻址方式，客户端只需发送带简单寻址信息的请求（如“&lt;a href=&#34;http://userservice/id/1000221%22&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://userservice/id/1000221&amp;quot;&lt;/a&gt; 中的”userservice” ），就可以寻址到正确的服务器端。这期间有两个关注点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过 DNS，建立了域名和 ClusterIP 的关系。&lt;/p&gt;
&lt;p&gt;对于客户端，这是它能看到的内容，非常的简单，域名、DNS 是非常容易使用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而通过 kube-proxy 的拦截和转发，又打通了 ClusterIP 和服务器端实际的 Pod IP&lt;/p&gt;
&lt;p&gt;对于客户端，这些是看不到的内容，不管有多复杂，都是 Kubernetes 在底层完成，对客户端，或者说使用者透明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以客户端的视角看来，这个 DNS 寻址方式非常的简单直白：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-与-dns&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kube-proxy 与 DNS&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u2vhim9j319d0c8goz_hu3d6d3fbb0dfcacaf39b24f352d67ad76_114090_ea4f50166580fecfd0b8906fc2d5bd5a.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u2vhim9j319d0c8goz_hu3d6d3fbb0dfcacaf39b24f352d67ad76_114090_436426845815016c0977f6134ca85a86.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u2vhim9j319d0c8goz_hu3d6d3fbb0dfcacaf39b24f352d67ad76_114090_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/006tNbRwly1fw0u2vhim9j319d0c8goz_hu3d6d3fbb0dfcacaf39b24f352d67ad76_114090_ea4f50166580fecfd0b8906fc2d5bd5a.webp&#34;
               width=&#34;760&#34;
               height=&#34;205&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      kube-proxy 与 DNS
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;istio-的-dns-寻址方式&#34;&gt;Istio 的 DNS 寻址方式&lt;/h2&gt;
&lt;p&gt;Istio 的请求寻址方式和普通 kubernetes 非常相似，原理相同，只是 kube-proxy 被 sidecar 取代，然后 sidecar 的部署方式是在 pod 内部署，而且客户端和服务器端各有一个 sidecar。其他基本一致，除了图中红色文本的部分：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-的-dns-寻址方式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio 的 DNS 寻址方式&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u3qux0gj31bg0ijgrw_hudca773d8a22d537d30006ac6134fc013_211121_410089e46ab5270fb51cb37a8874514f.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u3qux0gj31bg0ijgrw_hudca773d8a22d537d30006ac6134fc013_211121_276d01b771ec7378add52d567b0b6b3f.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u3qux0gj31bg0ijgrw_hudca773d8a22d537d30006ac6134fc013_211121_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/006tNbRwly1fw0u3qux0gj31bg0ijgrw_hudca773d8a22d537d30006ac6134fc013_211121_410089e46ab5270fb51cb37a8874514f.webp&#34;
               width=&#34;760&#34;
               height=&#34;297&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio 的 DNS 寻址方式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iptables 在劫持流量时，除了将请求转发到 localhost 的 Sidecar 处外，还额外的在请求报文的 TCP options 中将 ClusterIP 保存为 original dest。&lt;/li&gt;
&lt;li&gt;在 Sidecar（Istio 默认是 Envoy）中，从请求报文 TCP options 的 original dest 处获取 ClusterIP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 TCP options 的 original dest，iptables 就实现了在劫持流量到 Sidecar 的过程中，额外传递了 ClusterIP 这个重要参数。Istio 为什么要如此费力的传递这个 ClusterIP 呢？&lt;/p&gt;
&lt;p&gt;看下图就知道了，这是一个 Virtual Host 的示例，Istio 通过 Pilot 将这个规则发送给 Sidecar/Envoy，依靠这个信息来匹配路由请求找到处理请求的 cluster：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-中的-pilot-注册信息&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio 中的 Pilot 注册信息&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u495625j30rd0ldgot_hu4204cb8ce9eade41ae09467315de1374_118475_33870b26a7d8898807a8f5406a1976aa.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u495625j30rd0ldgot_hu4204cb8ce9eade41ae09467315de1374_118475_00afda41b65d40aa48abc9f5fa7d7ccc.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u495625j30rd0ldgot_hu4204cb8ce9eade41ae09467315de1374_118475_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/006tNbRwly1fw0u495625j30rd0ldgot_hu4204cb8ce9eade41ae09467315de1374_118475_33870b26a7d8898807a8f5406a1976aa.webp&#34;
               width=&#34;760&#34;
               height=&#34;593&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio 中的 Pilot 注册信息
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;domains 中，除了列出域名外，还有一个特殊的 IP 地址，这个就是 Kubernetes 服务的 ClusterIP！因此，Sidecar 可以通过前面传递过来的 ClusterIP 在这里进行路由匹配（当然也可以从报文中获取 destination 然后通过域名匹配）。&lt;/p&gt;
&lt;p&gt;总结，Istio 延续了 Kubernetes 的寻址方式，客户端同样只需发送带简单寻址信息的请求，就可以寻址到正确的服务器端。这期间同样有两个关注点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过 DNS，建立了域名和 ClusterIP 的关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 ClusterIP 和 Pilot 下发给 Virtual Host 的配置，Sidecar 可以完成路由匹配，将 ClusterIP 和目标服务器关联起来&lt;/p&gt;
&lt;p&gt;同样，对于客户端，这些是看不到的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，以客户端的视角看来，Istio 的这个 DNS 寻址方式同样的简单直白！&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-客户端请求&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;客户端请求&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5cxd61j30st03wmxk_hu2c730e4a4c9a17a5a2c565dd74e685f1_18424_cc406e0494732079577d90d132b0ad29.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5cxd61j30st03wmxk_hu2c730e4a4c9a17a5a2c565dd74e685f1_18424_b44ff8943854dcca346c3e8b9de6ed4b.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5cxd61j30st03wmxk_hu2c730e4a4c9a17a5a2c565dd74e685f1_18424_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/006tNbRwly1fw0u5cxd61j30st03wmxk_hu2c730e4a4c9a17a5a2c565dd74e685f1_18424_cc406e0494732079577d90d132b0ad29.webp&#34;
               width=&#34;760&#34;
               height=&#34;103&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      客户端请求
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;dns-通用寻址方案&#34;&gt;DNS 通用寻址方案&lt;/h2&gt;
&lt;h3 id=&#34;解决问题的思路&#34;&gt;解决问题的思路&lt;/h3&gt;
&lt;p&gt;在详细讲述了 Kubernetes 和 Istio 的 DNS 寻址方案之后，我们继续回到我们的主题，我们要解决的问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何在不修改代码，继续使用接口的情况下，实现在 Service Mesh上运行现有的Dubbo/HSF/SOFA等传统SOA应用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-dns-通用寻址方案&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DNS 通用寻址方案&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5kyafgj30zz0grad5_hucc81464f40e05ba89f12f4d232053ae9_105561_60e8a2bf34a44f7234e49bc89ee7f2f6.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5kyafgj30zz0grad5_hucc81464f40e05ba89f12f4d232053ae9_105561_558349e04d0bc3d9b4f86458e94a891d.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5kyafgj30zz0grad5_hucc81464f40e05ba89f12f4d232053ae9_105561_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/006tNbRwly1fw0u5kyafgj30zz0grad5_hucc81464f40e05ba89f12f4d232053ae9_105561_60e8a2bf34a44f7234e49bc89ee7f2f6.webp&#34;
               width=&#34;760&#34;
               height=&#34;354&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DNS 通用寻址方案
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里有一个关键点：Kubernetes 的服务注册是以基于 Service 或者说基于应用 (app name)，而我们的客户端代码是基于接口的。因此，在 Virtual Host 进行路由匹配时，是不能通过域名匹配的。当然，这里理论上还有一个思路，就是将接口注册为 Kubernetes Service。但是，还记得要支持接口特殊字符的需求吗？带点号的接口名，Kubernetes 是不能接受它作为 Service Name 的，直接堵死了将接口名注册到 Kubernetes Service 的道路。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-中注册的服务名称&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio 中注册的服务名称&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5v7kktj30rd0ldgot_hu19eeea1e0a233d5b9aa77668a5df7662_110922_a1719448f7b4f1d30eb7dbe62efb6923.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5v7kktj30rd0ldgot_hu19eeea1e0a233d5b9aa77668a5df7662_110922_8bc45608cae802a106e14b4274b505df.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5v7kktj30rd0ldgot_hu19eeea1e0a233d5b9aa77668a5df7662_110922_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/006tNbRwly1fw0u5v7kktj30rd0ldgot_hu19eeea1e0a233d5b9aa77668a5df7662_110922_a1719448f7b4f1d30eb7dbe62efb6923.webp&#34;
               width=&#34;760&#34;
               height=&#34;593&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio 中注册的服务名称
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这样，我们就只有一条路可以走了：效仿 Istio 的做法，通过 ClusterIP 匹配！&lt;/p&gt;
&lt;p&gt;而要将接口名（如”com.alipay.demo.interface-1”）和 ClusterIP 关联，最简单直接的方式就是&lt;strong&gt;打通 DNS&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sidecar-注册-dns-名称&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Sidecar 注册 DNS 名称&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u6cxesmj31fn0ffgqm_hu8d8985550c30d69b1a013cdef1f0cba6_166782_68c51d2674d44a7c85d22c5adf32ac32.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u6cxesmj31fn0ffgqm_hu8d8985550c30d69b1a013cdef1f0cba6_166782_853e1c0761b7fb0dd0458dcf705d78ef.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u6cxesmj31fn0ffgqm_hu8d8985550c30d69b1a013cdef1f0cba6_166782_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/006tNbRwly1fw0u6cxesmj31fn0ffgqm_hu8d8985550c30d69b1a013cdef1f0cba6_166782_68c51d2674d44a7c85d22c5adf32ac32.webp&#34;
               width=&#34;760&#34;
               height=&#34;227&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Sidecar 注册 DNS 名称
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;只需要在 DNS 记录中，增加接口到 ClusterIP 的映射，然后就可以完全延续 Istio 的标准做法！其他的步骤，如域名解析到 ClusterIP，iptables 拦截并传递 ClusterIP，sidecar 读取 ClusterIP 并匹配路由，都完全可以重用原有方案。&lt;/p&gt;
&lt;h3 id=&#34;具体实现方案&#34;&gt;具体实现方案&lt;/h3&gt;
&lt;p&gt;实现时，我们选择了使用 CoreDNS 作为 Kubernetes 的 DNS 解决方案，然后通过 Service Controller 操作 CoreDNS 的记录来实现 DNS 解析。&lt;/p&gt;
&lt;p&gt;为了收集到 SOA 应用的接口信息，我们还提供了一个 Register Agent 给 Service Controller 收集信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-通过-coredns-注册接口名称&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;通过 CoreDNS 注册接口名称&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u6rzjygj30lb0dc75f_hub7d680a115a60c38a1a371f1ec220b14_43531_cdfe97ec48b34385e3482b3a0d107dc6.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u6rzjygj30lb0dc75f_hub7d680a115a60c38a1a371f1ec220b14_43531_6e1c26c15fa2fcc763282ef6ba606255.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u6rzjygj30lb0dc75f_hub7d680a115a60c38a1a371f1ec220b14_43531_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/x-protocol-common-address-solution/006tNbRwly1fw0u6rzjygj30lb0dc75f_hub7d680a115a60c38a1a371f1ec220b14_43531_cdfe97ec48b34385e3482b3a0d107dc6.webp&#34;
               width=&#34;760&#34;
               height=&#34;476&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      通过 CoreDNS 注册接口名称
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;详细的实现方案，不在本文中重复讲述，请参阅我们之前的分享文章 &lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzUzMzU5Mjc1Nw==&amp;amp;mid=2247484175&amp;amp;idx=1&amp;amp;sn=5cb26b1afe615ac7e06b2ccbee6235b3&amp;amp;chksm=faa0ecd5cdd765c3f285bcb3b23f4f1f3e27f6e99021ad4659480ccc47f9bf25a05107f4fee2&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0828t5isWXmyeWhTeoAoeogw&amp;amp;pass_ticket=DqnjSkiuBZW9Oe68Fjiq%2Bqa6fFCyysQTR7Qgd8%2BX9FfooybAg7NXVAQdLmfG6gRX#rd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFAMesh 的通用协议扩展&lt;/a&gt; 中的 DNS 寻址方案一节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：暂时修改 CoreDNS 记录的方式是直接修改 CoreDNS 的底层数据，不够优雅。未来将修改为通过 CoreDNS 的 Dynamic updates API 接口进行，不过 CoreDNS 的这个 API 还在开发中，需要等待完成。详情见&lt;a href=&#34;https://github.com/coredns/coredns/pull/1822&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;单进程多接口问题的解决&#34;&gt;单进程多接口问题的解决&lt;/h3&gt;
&lt;p&gt;上面的解决方案，在解决通过接口实现访问的同时，也将”单进程多接口”的问题一起解决了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原 SOA 应用上 Kubernetes 时，可以注册为标准的 Kubernetes Service，获取 ClusterIP。此时使用应用名注册，和接口无关。&lt;/li&gt;
&lt;li&gt;通过操作 CoreDNS，我们将该 SOA 应用的各个接口都添加为 DNS 记录，指向该应用的 ClusterIP&lt;/li&gt;
&lt;li&gt;当客户端代码使用不同的接口名访问时，DNS 解析出来的都是同一个 ClusterIP，后续步骤就和接口名无关了&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;欠缺微服务改造带来的限制&#34;&gt;欠缺微服务改造带来的限制&lt;/h3&gt;
&lt;p&gt;需要特别指出的是，DNS 通用寻址方案虽然可以解决使用接口名访问和支持单进程多接口的问题，但是这种方案只是完成了“寻址”，也就是打通端到端的访问通道。由于应用没有进行微服务改造，部署上是依然一个应用（体现为一个进程，在 Kubernetes 上体现为一个 Service）中包含多个接口，本质上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务注册依然是以应用名为基础，对应的 Kubernetes service 和 service 上的 label 也是应用级别&lt;/li&gt;
&lt;li&gt;因此提供的服务治理功能，也是以 Kubernetes 的 Service 为基本单位，包括灰度，蓝绿，版本拆分等所有的 Version Based Routing 功能&lt;/li&gt;
&lt;li&gt;这意味着，只能进行&lt;strong&gt;应用级别&lt;/strong&gt;的服务治理，而不能继续细分到&lt;strong&gt;接口级别&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个限制来源于应用没有进行微服务改造，没有按照接口将应用拆分为多个独立的微服务，因此无法得到更小的服务治理粒度。这也就是我们前面说的“先上车后补票”的含义：在微服务改造前，先获得 Service Mesh 的服务治理的绝大部分功能，再慢慢进行微服务改造。&lt;/p&gt;
&lt;h2 id=&#34;dns-通用寻址方案-1&#34;&gt;DNS 通用寻址方案&lt;/h2&gt;
&lt;p&gt;我们将这个方案称为”DNS 通用寻址方案”，是因为这个方案真的非常的通用，体现在以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对使用者来说，通过域名和 DNS 解析的方式来访问，是非常简单直白而易于接受的，同时也是广泛使用的，适用于各种语言、平台、框架&lt;/li&gt;
&lt;li&gt;这个方案延续了 Kubernetes 和 Istio 的做法，保持了一致的方式，对用户提供了相同的体验&lt;/li&gt;
&lt;li&gt;这个寻址方案，不仅仅可以用于 Dubbo、SOFA、HSF 等 RPC 框架往 Service Mesh 的迁移，也可以适用于基于 HTTP/REST 协议的 SOA 应用，甚至最传统的 web 应用（例如 tomcat 下部署多个 war 包）迁移到 Service Mesh&lt;/li&gt;
&lt;li&gt;我们也在考虑在未来的 Serverless 项目中，将 Function 的寻址也统一到这套方案中，而无需要求每个 Function 都进行一次服务注册&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;概括的说，有了这套 DNS 通用寻址方案，不管需要寻址的实体是什么形态，只要它部署在 Service Mesh 上，满足以下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有正常注册为 Kubernetes Service，分配有 ClusterIP&lt;/li&gt;
&lt;li&gt;为实体（或者更细分的子实体）分配域名或子域名，然后添加到 DNS，解析到 ClusterIP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么我们的 DNS 通用寻址方案，就可以工作，从而将请求正确的转发到目的地。而在此基础上，Service Mesh 所有的强大功能都可以为这些实体所用，实现我们前面的目标：在不修改代码不做微服务改造的情况下，也能提前受益于 Service Mesh 带来的强大服务治理功能。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服大规模微服务架构下的 Service Mesh 探索之路</title>
      <link>https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/</link>
      <pubDate>Wed, 04 Jul 2018 19:56:20 +0800</pubDate>
      <guid>https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是根据蚂蚁金服 Service Mesh 布道师敖小剑在 Service Mesher 社区进行的第一次 Meetup 上分享的《大规模微服务架构下的 Service Mesh 探索之路》现场演讲内容实录整理编辑而成，希望能给关注 Service Mesh 产品的朋友们带来帮助和了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;讲师 PPT 下载地址&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/servicemesher/meetup-slides&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/servicemesher/meetup-slides&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dc36ywj30qo0f0wfd_hubd61f93ec391b654cffd86eb10bac355_30201_b4c03e4a68121dc02ecec84f7e2029a3.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dc36ywj30qo0f0wfd_hubd61f93ec391b654cffd86eb10bac355_30201_98b00c72f6a7fc363887d6487e1ee082.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dc36ywj30qo0f0wfd_hubd61f93ec391b654cffd86eb10bac355_30201_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dc36ywj30qo0f0wfd_hubd61f93ec391b654cffd86eb10bac355_30201_b4c03e4a68121dc02ecec84f7e2029a3.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-敖小剑-蚂蚁金服-service-mesh-杭州-meetup&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;敖小剑 蚂蚁金服 service mesh 杭州 meetup&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d1qg75j30u00k1tcu_hu2e1e24e5e5ad487839b8512545caf457_127348_fdc1883af1b21f5663e303fac23087d6.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d1qg75j30u00k1tcu_hu2e1e24e5e5ad487839b8512545caf457_127348_937d67025fcb6465ca632f2abe7de766.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d1qg75j30u00k1tcu_hu2e1e24e5e5ad487839b8512545caf457_127348_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d1qg75j30u00k1tcu_hu2e1e24e5e5ad487839b8512545caf457_127348_fdc1883af1b21f5663e303fac23087d6.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      敖小剑 蚂蚁金服 service mesh 杭州 meetup
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;今天给大家带来的内容叫做 Service Mesh 探索之路，但是在前面加了一个定语：&lt;strong&gt;大规模微服务架构下&lt;/strong&gt;。之所以加上这个词，是因为我们这个体系是在蚂蚁金服这样一个大的架构下进行的，蚂蚁金服的体量大家可以想象，所以这个探索会带有一个非常隆重的色彩：对性能/规模/高可用等方面的思考。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dewe11j30qo0f0jsq_hu94f99f670695edb5fd498b3f2f0fbf35_42467_177c70219fecac8813574bf67aca4e10.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dewe11j30qo0f0jsq_hu94f99f670695edb5fd498b3f2f0fbf35_42467_d2d537850e6762c775b90f24e809afd7.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dewe11j30qo0f0jsq_hu94f99f670695edb5fd498b3f2f0fbf35_42467_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dewe11j30qo0f0jsq_hu94f99f670695edb5fd498b3f2f0fbf35_42467_177c70219fecac8813574bf67aca4e10.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今年 6 月初，在深圳的 GIAC 大会，我们同事披露了这个正在开发中的 Service Mesh 产品，我们现在暂时命名为 SOFA Mesh。我们目前的产品都在 SOFA 品牌下，比如 SOFA RPC，SOFA Boot 等。今天我们详细介绍 SOFA Mesh 这个单独产品，上次大会只是简单披露，也就是给大家介绍说我们有这样一个产品，而我今天的内容是把这个产品详细展开。&lt;/p&gt;
&lt;p&gt;主要是三个内容：一是 SOFA Mesh 的技术选型，二是它的架构设计，以及在最后跟大家聊一下，蚂蚁金服在 SOFA Mesh 上的开源策略。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5yw0aj30qo0f0gm1_huc540961553654a814d9669c4cf780a0a_17506_ac8173d2c0d643d869fabb681c1e8d70.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5yw0aj30qo0f0gm1_huc540961553654a814d9669c4cf780a0a_17506_ba1d1b677d5da4acb815b5330127829a.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5yw0aj30qo0f0gm1_huc540961553654a814d9669c4cf780a0a_17506_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5yw0aj30qo0f0gm1_huc540961553654a814d9669c4cf780a0a_17506_ac8173d2c0d643d869fabb681c1e8d70.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;一技术选型&#34;&gt;一、技术选型&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpr6w3j30qo0f0tbh_hu75b5c1e742b5a72d5ac29d010706be26_84486_c5c9af8d0c236761f4d442dee2191c1e.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpr6w3j30qo0f0tbh_hu75b5c1e742b5a72d5ac29d010706be26_84486_5de4406be830df0ecd048ce7817908bd.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpr6w3j30qo0f0tbh_hu75b5c1e742b5a72d5ac29d010706be26_84486_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpr6w3j30qo0f0tbh_hu75b5c1e742b5a72d5ac29d010706be26_84486_c5c9af8d0c236761f4d442dee2191c1e.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;先上来一堆要求，刚才我们提到过的，因为是大规模，而蚂蚁金服的体量，大家可以想象到的。实际上在性能，稳定性上，我们的衡量标准，我们考虑的基石，都是以蚂蚁金服这样的一个规模来考虑的。&lt;/p&gt;
&lt;p&gt;在这样一个规模下，我们会涉及到一些跟其他公司不太一样的地方，比如说：我们在&lt;strong&gt;性能&lt;/strong&gt;的考量上会比较重一些。因为如果性能不高的话，可能没法支撑我们这样一个规模。在考虑性能的时候，就有另外一层考量：架构和性能之间的这个权衡和取舍是要非常谨慎的。性能要求不太高的情况下，架构可能的选择，和需要比较高性能的情况下，可能会有完全不一样的取舍。稳定性就不必说了。&lt;/p&gt;
&lt;p&gt;部署方面的要求，首先是我们会用于多种场合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主站是指我们蚂蚁金服内部，比如大家用的最多的支付宝。&lt;/li&gt;
&lt;li&gt;金融云，可能有一部分和我们有联系的同学会有所了解，这个是我们推出的针对金融行业的云。&lt;/li&gt;
&lt;li&gt;然后还有我们的外部客户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;部署上会要求这三个场合都能使用。&lt;/p&gt;
&lt;p&gt;部署环境也会有多种，刚才我们调查到，有部分同学相对比较前沿一些，现在就已经上 k8s 了。有部分同学还是停留在以前的虚拟机以及物理机这种状态，也有一部分自己上了容器，还有部分同学可能会使用不同的公有云和私有云。这几种不同的环境，我们都是需要满足的。&lt;/p&gt;
&lt;p&gt;第三点可能要特殊一些，需要满足各种体系。刚才我们在调查的时候了解到，有部分同学是在做旧有系统改造，那在改造的时候就会遇到一个问题：除了 Service Mesh 之外，还需要跟原来的体系，比如说 SOFA，或者社区主流框架如 Dubbo，Spring Cloud，相互之间打通和过渡。怎么在技术转型期间平滑的让业务做变更，是我们在整个技术选型之前提出的实际要求。整个技术选型是在这样一个背景下进行的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2da5k87j30qo0f0djw_hu686199a655f301a451bce942be70a77a_121665_3a5063e78d99ad24c75d90f9620bb99d.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2da5k87j30qo0f0djw_hu686199a655f301a451bce942be70a77a_121665_e3f42e174e6ff9dfb4be46057c7a30cd.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2da5k87j30qo0f0djw_hu686199a655f301a451bce942be70a77a_121665_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2da5k87j30qo0f0djw_hu686199a655f301a451bce942be70a77a_121665_3a5063e78d99ad24c75d90f9620bb99d.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们做技术选型的时候，有两大方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一个选择是在开源产品上做&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先看右边的路线，起点是找一个开源产品，fork 出来，做增强/扩展/定制，和内部集成。因为开源产品还在继续往前走，所以我们会持续做版本更新，也可以从社区拿到最新版本。相当于是从开源社区做&lt;strong&gt;获取&lt;/strong&gt;，然后接下来做反馈，让我们的一些产品，我们做的东西反馈回去。&lt;/p&gt;
&lt;p&gt;这条路线比较大的好处是从一开始就可以得到社区的支持，社区往前走的时候也跟着往前走。如果做的比较好，愿意让自己的产品反哺社区，那么社区也可以从中受益。&lt;/p&gt;
&lt;p&gt;当然这里面有一个小问题，就是说可能我们自己这个产品路线和开源产品路线可能会有一些分歧，可能我们领先一步，也可能他们领先一步，或者一个事情可能有两个做法。这种情况下，如何让社区的接受我们的改动，会变成这条路线上比较头疼的一个问题。&lt;/p&gt;
&lt;p&gt;这是两条路线上的第一条，选择以开源产品为起点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;另外一种思路全新打造&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;或者，如果手上已经有一套类库或者框架，可以在这个基础上做包装。&lt;/p&gt;
&lt;p&gt;这条路线有一个好处，&lt;strong&gt;可控性&lt;/strong&gt;比较强。因为整个体系是全新打造或者在原有体系上演进而来的，整套体系基本上都是自己的开发团队完全可控的。&lt;/p&gt;
&lt;p&gt;这条路线会遇到一个问题，因为长期上看我们也是希望开源的，而开源就意味着不能将自己内部太多的定制化的东西直接做进去，所以在架构上需要考虑可扩展性，可以定制化。因为开源出去的应该是一个标准产品，这样的产品才可以得到社区和客户的认可。客户希望看到一个干净的东西，也需要做扩展，整个体系在设计上会有所不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两条路线的终点，从图上看，我们有两个目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;第一个目标是内部落地&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面提到的，我们需要在蚂蚁金服主站这样的一个巨大规模的场景下落地，这是蚂蚁金服自身的需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;第二个目标是技术输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为蚂蚁金服在公司策略上有科技输出的内容，不仅仅我们自己用，我们还需要给出去。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在我们来看这个问题：目标在这里，然后有左右两条路线，我们该怎么选择？在做的技术选型的时候，这是一个非常大的分歧点，到底是从左边走，还是从右边走？&lt;/p&gt;
&lt;p&gt;在公布结果之前，我们先来看一下有什么可选方案。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ded119j30qo0f0acl_hu74e1979043a9637a7587d5e0bf02c20c_77795_f8f87855e70b74778605933810c993ec.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ded119j30qo0f0acl_hu74e1979043a9637a7587d5e0bf02c20c_77795_9e5c69d3f054547f1989b13b9c41b55d.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ded119j30qo0f0acl_hu74e1979043a9637a7587d5e0bf02c20c_77795_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ded119j30qo0f0acl_hu74e1979043a9637a7587d5e0bf02c20c_77795_f8f87855e70b74778605933810c993ec.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是开源方案的选择，第一代的 Service Mesh。&lt;/p&gt;
&lt;p&gt;左边的 Linkerd，这个基本上，目前看，大家都已经有点嫌弃了。因为它没有控制平面，用 Scala 写的，基于 JVM，资源消耗比较大。它的可扩展性比较有限的，相对于 Envoy 的扩展性。然后它里面有个 dtab，有接触到的同学就会有认识：dtab 的语法，非常的不人性，很难理解，使用不太方便。另外它的功能是远远不够的，对于蚂蚁金服来说。另外这个产品本身的发展前景已经很暗淡了，所以这个选项就被淘汰了。&lt;/p&gt;
&lt;p&gt;Envoy 是非常不错的，做了一些令我们意外的事情：安心的去做好数据平面，没有往上面做很多的东西，而是创造性的提出了 XDS API。整个设计是非常优秀的，性能和稳定性也表现得非常好，甚至看到业界有一个趋势，有一部分的公司开始把他们的 nginx 替换了，不再用 nginx 了，而是用 envoy。也就是说，现在它的稳定性和性能达到和 nginx 一个级别，nginx 大家应该都有听说过，envoy 已经是这样一个工业成熟度。&lt;/p&gt;
&lt;p&gt;我们当时选型时是比较头疼的，因为它是 c++写的，c++14。和我们技术栈的差异会比较大，因为蚂蚁的技术栈是以 Java 为主，长期的话，我们可能部分转到 Golang 上去。在这种情况下，C++的技术栈，会让我们比较尴尬，也不是说我们找不到会 c++的同学，而是说，长期上会和我们的方向不一致，我们要在 Java 和 Golang 的技术栈之外再加一个 c++，这就比较难受。&lt;/p&gt;
&lt;p&gt;然后我们内部会有大量扩展和定制化的需求。因为我们内部有我们自己的产品，我们自己的需求，我们的通讯方案，我们内部的追踪，监控，日志方案，所以工作量非常大。&lt;/p&gt;
&lt;p&gt;总结说，我们觉得 Envoy 很好，但是我们不能简单用。但是它在数据平面上的表现我们是非常认可的，Envoy 在这点做得非常好。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6vxq4j30qo0f076f_hu1777fcc317e6211f9351767ca2cb7421_66667_b05a00058bc483ec1a10f624d3f895e5.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6vxq4j30qo0f076f_hu1777fcc317e6211f9351767ca2cb7421_66667_0a10e85d7dfb8dee42140a3c971b1266.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6vxq4j30qo0f076f_hu1777fcc317e6211f9351767ca2cb7421_66667_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6vxq4j30qo0f076f_hu1777fcc317e6211f9351767ca2cb7421_66667_b05a00058bc483ec1a10f624d3f895e5.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;开源方案里面的第二代，istio 是我们当时的第一选择，重点关注对象。Istio 现在最大的问题在于它迟迟不能发布生产可用版本，大家如果对 istio 有了解的话，会知道 istio 刚刚发布了 0.8 版本，第一个长期支持版本，但是这个版本也不是生产可用。不出意外的话，按照目前的进度，istio 应该会在 7 月份发布它的 1.0 版本，但是从我们目前的感受上看，1.0 估计可能还是不能工业级的使用。所以需要等，而我们没法等，但是 Istio 的理念和方向我们非常认可。大家看一看，我们这个技术选型有多纠结。&lt;/p&gt;
&lt;p&gt;右边的 Conduit，现在 Conduit 的最大限制是它只支持 k8s。而现在蚂蚁金服还没有普及 k8s，我们现在还有很多系统是跑在非 k8s 上的。第二是它的数据平面是 Rust 编写的，这个语言更加小众了，在座的同学有没有人了解 Rust 这门语言？或者听过。（备注：现场大概十几个人举手）大概 10% 左右的同学听过。好，Rust 语言排名大概在 50 名左右。这个语言本身还是蛮认可的，我还很喜欢这个语言，它的一些特性还是非常有道理，如果掌握好还是可以写出非常好的产品，但是它的入门台阶会比较高一点。这个地方比较讨厌的事情是说，因为这个语言本身比较小众，所以基本上是没办法从社区借力的。这里可以举个例子，大家可以看一下 Conduit 的 committer 的人数，大概是 25 个左右，还包括像我这种只提交了几行代码的。Conduit 从 12 月份开源到现在已经有半年时间，半年时间只有这么多的 committer，其中真正有贡献大概 9 到 10 个人，基本上都是他自己的员工。也就说这个产品基本上没办法从社区借力，一个产品，如果大家一起来帮忙，其实很多的细节是可以完善的，但是 Conduit 就卡在 Rust 语言上。&lt;/p&gt;
&lt;p&gt;然后还是同样有技术栈的问题，因为这个原因，基本上 Conduit 我们也没法用了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddej49j30qo0f076w_hu373760ba158b875413a399c172f887fc_79562_3cdac99c3fdeb7222883ba0839626b81.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddej49j30qo0f076w_hu373760ba158b875413a399c172f887fc_79562_c9704fd6085372f406f6ba2d8c2d6a89.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddej49j30qo0f076w_hu373760ba158b875413a399c172f887fc_79562_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddej49j30qo0f076w_hu373760ba158b875413a399c172f887fc_79562_3cdac99c3fdeb7222883ba0839626b81.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们再看一下国内的在 Service Mesh 领域，其他的一些比较前卫的同学，他们的选择会是什么？&lt;/p&gt;
&lt;p&gt;首先是华为，华为自己做了一套 Golang 版本，名字叫做 Mesher。这是由他们之前的一套类库演进而来。它走的路线是，先有类库和框架，然后加 proxy，proxy 打通了之后再慢慢的开始添加控制平面。这是一条非常非常标准的路线，我这边给一个词叫做&lt;strong&gt;老成持重&lt;/strong&gt;，因为这条路是最安全的：每一步都是基于现有的产品，很快就可以到下一个里程碑，然后每个里程碑都可以解决一些实际问题，可以直接得到一些红利，这个方案是比较比较稳妥的。比如说第一步是把 proxy 做进去，有了这个切入口之后，就在第一时间获取跨语言的红利，还有技术栈下沉的好处。然后控制平面的创新，可以在这个基础上慢慢往前做。&lt;/p&gt;
&lt;p&gt;在对接 Istio 这一条上，现在华为的策略，我们现在从公开途径了解到的是：部分对接 istio，也就是有一部分的 API 兼容 Istio。但是细节上还不太清楚，因为它的开源还没出来，目前得到的消息是，会在 7 月份开源。&lt;/p&gt;
&lt;p&gt;第二个是新浪微博的 Motan Mesh，他们也是 Golang 的，但他不太一样，是全新实现。他们用 Go 语言重新写了一把，主要原因是因为它没有 golang 类库，Motan 是基于 Java 的。&lt;/p&gt;
&lt;p&gt;刚才看到的这两个产品，他们的思路大体上是相同的，差异在哪里？就是启动的时候是用已有的类库还是重新写？这两个选择之间最大的麻烦在于编程语言，华为原来有 go 的类库，所以继续用 golang 包装一下就好了。但是新浪的类库用的是 Java，而 sidecar 选择的是 go 语言，所以只能重新做了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dao36ej30qo0dm0u2_hu79a02ada45f12b5d971933af4ff56fa2_44244_8924c88406eafd9de192492dd6eab02d.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dao36ej30qo0dm0u2_hu79a02ada45f12b5d971933af4ff56fa2_44244_cbb5db0add5f41903fb3e193eb522177.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dao36ej30qo0dm0u2_hu79a02ada45f12b5d971933af4ff56fa2_44244_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dao36ej30qo0dm0u2_hu79a02ada45f12b5d971933af4ff56fa2_44244_8924c88406eafd9de192492dd6eab02d.webp&#34;
               width=&#34;760&#34;
               height=&#34;388&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们再看腾讯，最近看到他们有类似的产品出来。我们看看他们的资料：在数据平台上继续选择 Envoy，因为它比较成熟。腾讯的话大家比较熟悉，尤其是腾讯有非常深厚的 c++背景，所以 Envoy 对他们来说，技术栈是非常 OK 的。而且之前内部其他领域 Envoy 也是在用的，所以底层非常自然的选择了 Envoy。然后控制平面上，据传是&amp;quot;挣扎了一下&amp;quot;。这个词是我抄过的，&amp;ldquo;他们挣扎了一下&amp;rdquo;，最后还是选了 Istio。然后自己做定制和扩展，然后注意到他们也解耦了 k8s。这也是其中一个关键的点：要不要绑定 k8s？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d8l3mqj30qo0f0myg_hu70b686ddeac28f09e5efe198936ef1d3_42544_eac477e5fa74957a7c3edc3a3fd4c7cb.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d8l3mqj30qo0f0myg_hu70b686ddeac28f09e5efe198936ef1d3_42544_5b6e7cc0cac71859d0b43ba7f08cb788.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d8l3mqj30qo0f0myg_hu70b686ddeac28f09e5efe198936ef1d3_42544_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d8l3mqj30qo0f0myg_hu70b686ddeac28f09e5efe198936ef1d3_42544_eac477e5fa74957a7c3edc3a3fd4c7cb.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里还有 UCloud 的一个很有意思的做法，另辟蹊径啊。他的方案很有意思，是一个轻量级的实践：从 Istio 里面，将 Envoy 和 Pilot 单独剥离出来。就是说不用 Istio 整体，把 Mixer 和 Auth 的模块去掉，只要最重要的 Envoy，然后把 Pilot 剥离出来。然后这个 Pilot 还是个定制版，把其他的 adapter 干掉了。Pilot 主要是做服务发现，它底层用 ETCD，做了一个 ETCD 的 adapter，把其他的 adapter 从 Pilot 中去掉。做完这几个事情之后，整个体系就可以脱离 k8s 了，这是一个比较有意思的实践。&lt;/p&gt;
&lt;p&gt;总结：在讲我们技术决策过程之前，我们过了一下目前市场上的主要产品，以及一部分实践者的做法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dbkzxxj30qo0f0jto_hu5af307b255cbf9e3bab5155c0797ca77_71207_476000f5dee08f619a38f0e9d437d488.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dbkzxxj30qo0f0jto_hu5af307b255cbf9e3bab5155c0797ca77_71207_f878eafbcc9c2e10f2162bae91a97074.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dbkzxxj30qo0f0jto_hu5af307b255cbf9e3bab5155c0797ca77_71207_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dbkzxxj30qo0f0jto_hu5af307b255cbf9e3bab5155c0797ca77_71207_476000f5dee08f619a38f0e9d437d488.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们现在来详细讲一下，SOFA Mesh 在技术选型上的考虑。&lt;/p&gt;
&lt;p&gt;首先第一个，数据平台上 Envoy 是最符合我们要求的，Envoy 确实好。第二个事情是 Envoy 提出的 XDS API 设计是非常令人称道的，我们现在对这个的评价是非常高的。它实际上是一套通用的 API，由于时间的缘故，我今天就不在现场展开 API 的细节。只能说 XDS API 基本上已经成为数据平面和控制平面之间的一个事实标准。&lt;/p&gt;
&lt;p&gt;在这种情况下，我们其实是想用 Envoy 的，但是刚才提到我们有个技术栈选择的问题：我们不愿意将 c++纳入到我们主流的技术栈。然后我们本身有太多的扩展和定制，逼得我们不得不去改 Envoy，我们不能简单的拿过去用，我们需要做很多扩展的。&lt;/p&gt;
&lt;p&gt;另外一个事情是，我们这个 proxy 不仅仅是用于 Mesh，我们有可能把它引入到 API Gateway 里头，以及后面会提到的名为 Edge Sidecar 的模块。因为这个原因，所以，怎么说呢，想用，但是不合适用。&lt;/p&gt;
&lt;p&gt;第二就是在 Istio 上，控制平面这一块 Istio 可以说是做的最好的。基本上，到目前为止，在控制平面上，暂时我们还没有看到做的比 Istio 更好的产品，或者说思路。目前 Istio 整个设计理念，包括它的产品方向，也是我们非常认可的。&lt;/p&gt;
&lt;p&gt;但是 Istio 的性能是目前最大的问题，而我们有一个重要的前提：大规模应用。要用在蚂蚁金服主站这样一个场景下，性能和稳定性对我们非常非常的重要。第二个问题是它对非 k8s 的支持不够理想，因为我们还涉及到一个 k8s 没有完全上线的问题。第三个是和侵入式框架互通的问题，我们内部用的是 SOFA，对外推出的时候我们的客户用的可能是 Dubbo 或者 Spring Cloud，Mesh 上去之后，两个系统现在走不通，这是大问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpc73yj30qo0f00ur_huf9d96a7b00761de87e90b89c0900bc3a_61899_c51c71fec1f56d1f9beff1c57fa6b1a0.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpc73yj30qo0f00ur_huf9d96a7b00761de87e90b89c0900bc3a_61899_3a7c2db459e72d7d80313f536139a4c9.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpc73yj30qo0f00ur_huf9d96a7b00761de87e90b89c0900bc3a_61899_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpc73yj30qo0f00ur_huf9d96a7b00761de87e90b89c0900bc3a_61899_c51c71fec1f56d1f9beff1c57fa6b1a0.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最终我们的策略是这样的，这是我们 SOFA Mesh 的技术选型：左边是 Istio 现有的架构，Envoy/Pilot/Mixer/Auth，右边是我们 SOFA Mesh 的架构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最重要的第一点：我们用 Golang 开发的 Sidecar 替换 Envoy，用 Golang 重写整个数据平面。&lt;/li&gt;
&lt;li&gt;第二点是我们会合并一部分的 Mixer 内容进到 Sidecar，也就是 Mixer 的一部分功能会直接做进 Sidecar。&lt;/li&gt;
&lt;li&gt;第三点是我们的 Pilot 和 Auth 会做扩展和增强。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是我们整个的技术选型方案，实际上是 Istio 的一个增强和扩展版本，我们会在整个 Istio 的大框架下去做这个事情，但是会做一些调整。&lt;/p&gt;
&lt;h2 id=&#34;二架构设计&#34;&gt;二、架构设计&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcxvr1j30qo0f0jru_hu0f7ca5a9ee1d13c36afb84f298546547_18388_3c7c7e43cb4be4cc21ab82ade1f876d3.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcxvr1j30qo0f0jru_hu0f7ca5a9ee1d13c36afb84f298546547_18388_640ea1ebfb8399e2d19ecb0f53a97fbb.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcxvr1j30qo0f0jru_hu0f7ca5a9ee1d13c36afb84f298546547_18388_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcxvr1j30qo0f0jru_hu0f7ca5a9ee1d13c36afb84f298546547_18388_3c7c7e43cb4be4cc21ab82ade1f876d3.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然后我们来详细介绍一下在这个技术选型上我们怎么去做实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d34esij30qo0f075z_hu6b925ae67740880946644fa7c7f39792_53903_0767b0aaaa09527842c5ffc9815898e8.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d34esij30qo0f075z_hu6b925ae67740880946644fa7c7f39792_53903_213081ed54430fdadf1c15b94ccb5cff.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d34esij30qo0f075z_hu6b925ae67740880946644fa7c7f39792_53903_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d34esij30qo0f075z_hu6b925ae67740880946644fa7c7f39792_53903_0767b0aaaa09527842c5ffc9815898e8.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先是 Golang 版本的 Sidecar，我们会参考 Envoy，非常明确的实现 XDS API。因为 XDS API 是目前的事实标准，所以我们选择遵循，然后我们会让它兼容 Istio。&lt;/p&gt;
&lt;p&gt;在协议支持上，我们会支持标准的 HTTP/1.1 和 HTTP/2，也就是大家常见的 REST 和 gRPC 协议。然后我们会增加一些特殊的协议扩展，包括 SOFA 协议，Dubbo 协议，HSF 协议。我们现在正在做这几个协议的扩展，然后 XDS API 我们支持，mixer service 我们没有改动，遵循现有实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dg7rw3j30qo0f0gnm_hu214b8a33abbc6b10abc0a2e75178104b_61959_cf3d39f12d1178751419c958034d07c0.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dg7rw3j30qo0f0gnm_hu214b8a33abbc6b10abc0a2e75178104b_61959_79c24ab455f61159587db90e86cb8e95.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dg7rw3j30qo0f0gnm_hu214b8a33abbc6b10abc0a2e75178104b_61959_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dg7rw3j30qo0f0gnm_hu214b8a33abbc6b10abc0a2e75178104b_61959_cf3d39f12d1178751419c958034d07c0.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最大的变化在 Mixer，其实刚才的 Sidecar 虽然是全新编写，但是说白了是做 Envoy 的替换，在架构上没有什么变化。但是第二步的变化就非常大，我们会合并一部分的 Mixer 功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mixer 的三大功能：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;check。也叫 precondition，前置条件检查，比如说黑白名单，权限。&lt;/li&gt;
&lt;li&gt;quota。比如说访问次数之类。&lt;/li&gt;
&lt;li&gt;report。比如说日志，度量等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三大功能里面，注意到，前两个功能是同步阻塞的，就是一定要检查通过，或者是说 quota 验证 OK，才能往下走。如果结果没回来只能等，因为这是业务逻辑，必须要等。而 Report 是可以通过异步和批量的方式来做的。&lt;/p&gt;
&lt;p&gt;在这里，我们现在的决策是：我们会将其中的两个部分 (check 和 quota) 合并进来，原有 report 部分我们会继续保留在 mixer 里面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dgq9tzj30qo0f0q59_hud489c5f203d800b2668fa0b01e2a2fcc_72061_bb2b376a04f65bdd9276ec46fedf73ef.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dgq9tzj30qo0f0q59_hud489c5f203d800b2668fa0b01e2a2fcc_72061_e43410062a13ea4f32b7e47c8371403e.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dgq9tzj30qo0f0q59_hud489c5f203d800b2668fa0b01e2a2fcc_72061_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dgq9tzj30qo0f0q59_hud489c5f203d800b2668fa0b01e2a2fcc_72061_bb2b376a04f65bdd9276ec46fedf73ef.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可能大家会问：为什么我们要选择用这个方案，而不是遵循 Istio 的标准做法？我们之前聊到，我们会尽量去和 Istio 做兼容，跟随 Istio 的设计理念和产品方向，但是我们在它的架构上做了一个重大的调整。为什么？&lt;/p&gt;
&lt;p&gt;最大的问题就是&lt;strong&gt;对性能的影响&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给大家解释一下，看右边这个图，Envoy 在每次请求进来的时候，要去做两次调用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次在请求转发之前要做一次 check，这个 check 里面包含了 quota。Check 完成通过，才能把请求转发过去。&lt;/li&gt;
&lt;li&gt;请求转发完成之后，再调用 report，报告一下响应时间，日志，度量等信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每次 traffic 都会有两次调用：一次 check，一次 report。而这是远程调用，因为这两个模块是两个进程，Mixer 是单独部署的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步阻塞&lt;/strong&gt;意味着必须要等，&lt;strong&gt;远程调用&lt;/strong&gt;意味着有开销而且有延迟。这个事情是发生在&lt;strong&gt;每一次&lt;/strong&gt;请求里面，意味着整个的性能一定会受影响。而考虑到我们蚂蚁金服这样一个体量，其实我们是很难承受。所以我们有自己的观点：我们不是太认可这样的一个方式，我们的想法是说我们要把它拆分出来想一想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果是需要请求做同步阻塞的功能，比如说黑白名单的验证，可能要检查 IP 地址，可能检查 quota。这些逼请求一定要做同步阻塞等待结果的功能，就&lt;strong&gt;不应该放在 Mixer 中&lt;/strong&gt;去完成去远程调用，而应该在 Sidecar 中完成。&lt;/p&gt;
&lt;p&gt;这是我们的观点，原因就是远程调用带来的系统开销，这个代价实在是太高了！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后其他的功能，比如说可以优化为异步的，或者可以以批量方式来提交的，最典型的就是 Report。Report 其实是可以异步提交，可以把十个请求打包到一个 report 同时提交，这些都是 OK 的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是我们的基本想法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d4iuw2j30qo0e5jtm_hu01b0b5212c89c7673dfcab6a57d559f0_70405_81aeaa25e55b26d358cfbbe0f0dad09f.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d4iuw2j30qo0e5jtm_hu01b0b5212c89c7673dfcab6a57d559f0_70405_daa3ba261713b4a6f2604a128a402146.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d4iuw2j30qo0e5jtm_hu01b0b5212c89c7673dfcab6a57d559f0_70405_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d4iuw2j30qo0e5jtm_hu01b0b5212c89c7673dfcab6a57d559f0_70405_81aeaa25e55b26d358cfbbe0f0dad09f.webp&#34;
               width=&#34;760&#34;
               height=&#34;403&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个问题其实在 Istio 里面是给了一个解决方案的。最早的时候，Istio 0.1 版本中，一出来就发现这个问题。从去年 5 月份开始到现在，13 个月的时间里，他只给了一个解决方案，就是在 Mixer 上的这个位置加了一个 Cache。这个的 Cache 的想法是：把这些结果缓存在 Envoy 的内存里面，如果下次的检查参数是相同的，那我们可以根据这样一个缓冲的设计，拿到已经缓存的结果，就可以避免远程调用。这个方式是很理想的，对吧？只要缓存能够命中，那就可以避免这一次远程调用。&lt;/p&gt;
&lt;p&gt;然后第二个优化是 report，现在的 report 是通过异步模式完成的，而且是批量。&lt;/p&gt;
&lt;p&gt;理论上说，如果这两个事情做到足够理想，Mixer 应该就不是瓶颈。对吧？&lt;/p&gt;
&lt;p&gt;问题在于：这个 Cache 真的搞得定吗？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5hscdj30qo0f00ul_hu0dc37bff896cd79829a686d88907a980_57074_ec591367e959ee7a70dfda3fc16c310a.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5hscdj30qo0f00ul_hu0dc37bff896cd79829a686d88907a980_57074_191e2c5cdd7833c3742c55169056dad5.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5hscdj30qo0f00ul_hu0dc37bff896cd79829a686d88907a980_57074_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5hscdj30qo0f00ul_hu0dc37bff896cd79829a686d88907a980_57074_ec591367e959ee7a70dfda3fc16c310a.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们给一个简单的例子，我现在假设 Mixer 有三个 adapter。然后它的输入值是不同的属性，属性是 istio 的概念，理解为若干个输入值。假设，需要三个 adapter 分别检查 A/B/C。如果这三个属性 A/B/C，他们只有 100 个取值范围，每个都是从 0 到 100，我们假设这种最简单的场景。&lt;/p&gt;
&lt;p&gt;如果这三个 adapter 分别做缓存的话，需要多少个缓存项？很容易计算吧？100 个 a，100 个 b，100 个 c，非常容易计算，这种情况下，其实就是 a+b+c 等于 300 嘛。理解一下：有三个输入，每个输入只有一百个取值范围，我们要把他们缓存起来。这些缓存大小，就是允许的范围，然后加起来。只要有 300 个 key，就都可以缓存起来。&lt;/p&gt;
&lt;p&gt;但是，这个方法中，缓存是做在 mixer 这边，每个 adapter 单独缓存。但是，在 Istio 中，缓存是做在 Envoy 这端的，因为做在 mixer 这端是没有用的，还是要远程调用过去。它做缓存的很重要的目标是要在客户端避免远程调用。所以，这种情况下，把缓存放到这里（备注，图中绿色方块）。&lt;/p&gt;
&lt;p&gt;大家现在想一想，现在这里只有一个缓存，只有一个 key/value。现在还有刚才的这个场景，A/B/C 各自的取值范围都是一百。但是现在缓存放在这边的话，实际上的这个 key 要考虑三个值了，A/B/C 的组合。这种情况下，它的最大缓存个数是多少？&lt;/p&gt;
&lt;p&gt;（备注：现场回答，a 乘 b 乘 c）&lt;/p&gt;
&lt;p&gt;a * b * c？还能 a + b + c 吗？做不到了，对不对？现在是 a * b * c，从 300 变成这么大的数了。为什么？因为缓存是在这个地方做的，根本没有办法像这样分开做，所以这里就变成了一个笛卡尔乘积。&lt;/p&gt;
&lt;p&gt;这个笛卡尔乘积有一个很大的麻烦，也就是说，如果 adapter 检查的某个属性，它的取值范围比较大，比如说要检查客户端的 IP 地址？你想想，这个 IP 地址有多少个取值范围？数以几十万几百万计，对吧？这种情况，哪怕在前面再乘以特别小的值，哪怕只是十，二十，如果是加 20 根本没所谓的，加 200，加 2000 都没所谓的，那乘个 200，乘个 2000 试一下？瞬间就被干掉。IP 地址可能只是百万级别，再在前面乘个 100，乘个 1000，瞬间就疯掉了。这个 key 值基本上已经是大到不能接受：要么就全放内存，内存爆掉；要不然限制缓存大小，就放 1 万个，缓存的命中率会非常低，整个缓存相当于失效了。&lt;/p&gt;
&lt;p&gt;这个细节，因为时间原因，不在这里详细讲了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6h2fgj30qo0dzq50_hu1c6f480fcc64204b52e9c8c80c34af27_66033_d6509cedfb21f41591f3e4ad174fb6eb.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6h2fgj30qo0dzq50_hu1c6f480fcc64204b52e9c8c80c34af27_66033_4f9ed59762a1203029011b0d727f3a38.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6h2fgj30qo0dzq50_hu1c6f480fcc64204b52e9c8c80c34af27_66033_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6h2fgj30qo0dzq50_hu1c6f480fcc64204b52e9c8c80c34af27_66033_d6509cedfb21f41591f3e4ad174fb6eb.webp&#34;
               width=&#34;760&#34;
               height=&#34;398&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里讲第二点，我们的反省：隔离怎么做？&lt;/p&gt;
&lt;p&gt;Mixer 有一个基本的设计目标，就是希望提供一个统一的抽象（就是这个 adapter 的概念），用它来隔离基础设施后端和 Istio 的其他部分。但是在这个点上我们的反思是：我们认可这样一个隔离。大家理解基础设施后端的概念吧？举个例子，日志处理如 prometheus，各种后端监控系统。这些系统和应用之间，我们认为这种情况下的确应该做隔离，没必要每个应用都去和基础设施后端产生直接的联系。这个观点是我们是赞许的。&lt;/p&gt;
&lt;p&gt;但是我们现在的意见是，我们把这条线 (备注：连接应用和基础设施后端的标记有红叉的线) 从应用里面拿下来之后，我们把它下沉。下沉到 Sidecar，够不够？Istio 的做法是，它觉得这个地方应该再往前走一步，到 Mixer 里面。由 Mixer 去完成和基础设施后端的连接，走这根线（备注：图中连接 Mixer 和基础设施后端的线）。但是多了这样一个隔离之后的代价，就是在中间的这根红线上，会多一次远程调用。&lt;/p&gt;
&lt;p&gt;现在只有两个选择：和基础设施怎么连？这条线（备注：最左边的）大家都认为没必要，这两条线（备注：中间和右边的线）之间选，两条线的差异，就是要付出一次远程调用的代价。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcki7oj30qo0f0dim_hu100e65e466052b2d1edfa2471a8090bb_84469_51f1e232ceeda668802c1356bf60eebb.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcki7oj30qo0f0dim_hu100e65e466052b2d1edfa2471a8090bb_84469_00f7acc5b9e8239fd3e71b05fe45026f.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcki7oj30qo0f0dim_hu100e65e466052b2d1edfa2471a8090bb_84469_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcki7oj30qo0f0dim_hu100e65e466052b2d1edfa2471a8090bb_84469_51f1e232ceeda668802c1356bf60eebb.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;继续反省：什么是基础设施后端？&lt;/p&gt;
&lt;p&gt;这里我们做一个列表，整个 Istio 现有的 adapter，大家可以看到，大概是这些。前面这两个部分是实现 check 和 quota 的 adapter，后面这些 adapter 是实现 report 功能。&lt;/p&gt;
&lt;p&gt;在这里，我们的反省是：这些功能，比如说黑白名单，比如说基于内存的 quota，或者基于外部 redis 的 quota。我们认为这些功能不太应该视为后端基础设施，因为这些功能更应该是说是体系内置的基本能力，应该直接把它们做成 Mesh 的内置产品，或者说可以做标准化，然后和外部系统集成。这些我认为应该是 Mesh 的最基础的功能，比如说我们 SOFA Mesh 可以提供基于 Redis 的 quota 方案，直接就把这个功能给出来了。我不认为应该再去跟外界的一个所谓的基础设施后端发生联系。&lt;/p&gt;
&lt;p&gt;但是下面这些我们是觉得 OK 的。这些 adapter 大家有概念吧，prometheus 大家应该都接触过的。剩下的这些在国内可能用的不多，是各种日志和 metric 相关的功能。把这些视为基础设施后端，我们是非常理解的。包括我们内部，我们蚂蚁也有很多这样的系统，相信各位自家的监控方案也是不一样的。&lt;/p&gt;
&lt;p&gt;这些视为基础设施，和系统隔离开，我们认为这是非常有必要，可以理解，可以接受。&lt;/p&gt;
&lt;p&gt;这是我们在这一点（备注：何为基础设施后端）上和 istio 的差异。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d3qprxj30qo0f0juf_huac3beb9dcbfd90fd8efe59b7216093c6_88928_a1be2526151e4cf62be493ea580e128c.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d3qprxj30qo0f0juf_huac3beb9dcbfd90fd8efe59b7216093c6_88928_ef6d63e237923ff0cad4a7254ef50c1b.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d3qprxj30qo0f0juf_huac3beb9dcbfd90fd8efe59b7216093c6_88928_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d3qprxj30qo0f0juf_huac3beb9dcbfd90fd8efe59b7216093c6_88928_a1be2526151e4cf62be493ea580e128c.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;因为时间原因，我们就不再深入去讲，这里我给了一些我博客上的文章。前段时间，我们在做技术选型，在做前面整个架构设计时，在这一点上有些讨论。以及我们最重要的决策：为什么要把 Mixer 合并进去。细节都在这几篇文章里面，大家如果有兴趣，可以去详细了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注链接地址&lt;/strong&gt;（请复制网址到浏览器打开）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://skyao.io/post/201804-servicemesh-architecture-introspection/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh 架构反思：数据平面和控制平面的界线该如何划定？&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://skyao.io/post/201804-istio-achilles-heel/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mixer Cache: Istio 的阿克琉斯之踵&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://skyao.io/post/201804-istio-mixer-cache-concepts/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Mixer Cache 工作原理与源码分析 (1)－基本概念&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://skyao.io/post/201806-istio-mixer-cache-principle/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Mixer Cache 工作原理与源码分析 (2)－工作原理&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://skyao.io/post/201806-istio-mixer-cache-main/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Mixer Cache 工作原理与源码分析 (3)－主流程&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://skyao.io/post/201806-istio-mixer-cache-signature/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Mixer Cache 工作原理与源码分析 (4)－签名&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0rypsj30qo0f0mza_huf0ba7c0389188953231d0bad825bf156_63862_e91db03cd5c9dad602efb58f7f9611c9.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0rypsj30qo0f0mza_huf0ba7c0389188953231d0bad825bf156_63862_688d740977fd3d9552b30412904d8b22.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0rypsj30qo0f0mza_huf0ba7c0389188953231d0bad825bf156_63862_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0rypsj30qo0f0mza_huf0ba7c0389188953231d0bad825bf156_63862_e91db03cd5c9dad602efb58f7f9611c9.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们还有一部分现在没有合并进来的 adapter 和 mixer，report 的这部分。但是这块不是说完全没有问题，我们现在有一个担心，report 这块可能会存在一个叫做&lt;strong&gt;网络集中&lt;/strong&gt;的问题。比如说，大家会注意到，应用和 Sidecar 是一对一部署的，有一万个应用，就有一万个 Sidecar。基础设施后端也是多机部署的。&lt;/p&gt;
&lt;p&gt;而现在的方式，流量会先打到 Mixer 来，Mixer 也是高可用的，也是会部署多台。但是这个数量肯定不是一万这个级别，跟这个肯定会有很大的差异。这样流量会先集中，通道会突然间收缩一下。总的流量没变，但是通道的口径要小很多。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7f735j30qo0f00uz_hu17a00aed15d866f416ce7e885cadccba_69195_5f7581a70511d64e139f838cec1965f2.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7f735j30qo0f00uz_hu17a00aed15d866f416ce7e885cadccba_69195_cb14d77a3b7c8ae9488c8bb2c6890485.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7f735j30qo0f00uz_hu17a00aed15d866f416ce7e885cadccba_69195_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7f735j30qo0f00uz_hu17a00aed15d866f416ce7e885cadccba_69195_5f7581a70511d64e139f838cec1965f2.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对网络吞吐量也会有影响。比如最简单的，如果应用直连，走交换机直接就过去了。&lt;/p&gt;
&lt;p&gt;如果是 Sidecar 模式，是在这个位置上（备注：应用和 sidecar 之间的绿色连线）加一个远程调用，但是应用和 Sidecar 之间走的是 localhost，localhost 根本就不走网卡，直接环回地址就走了。对性能不会有什么影响，对网络流量的影响就为零了。所以这两个方案相比，吞吐量不会有变化。&lt;/p&gt;
&lt;p&gt;但是，如果在 Sidecar 和 Backend 之间再加一个 Mixer，这意味着要走两次网络，这样的话会有一个流量翻倍的问题。&lt;/p&gt;
&lt;p&gt;所以这个地方可能会带来一些问题，但暂时我们现在还没做决策，我们现在还不是很确定这个问题会不会导致质的影响。所以我们现在暂时还是把它放在这里，就是说我们后面会做验证，如果在我们的网络方案下，这个方式有问题的话，我们可能再合进去。但是如果没问题的话，我们认为分开之后架构确实会更理想一些，所以我们现在暂时先不合并。&lt;/p&gt;
&lt;p&gt;给大家一些参考，目前 Conduit 最新版本已经把 report 的功能合并进来，然后 check 的功能，会在后续的计划中合并。我们在国内做一些技术交流，华为新浪微博他们现在通通都是选择在 Sidecar 里面实现功能，不走 mixer。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dh5nayj30qo0f00w1_hu20ea04c84c4ff01af78f5d9932abe17b_97233_18e064c5465d21778d7f02d4735db870.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dh5nayj30qo0f00w1_hu20ea04c84c4ff01af78f5d9932abe17b_97233_3d0d746656ca9cac661d00fa40faae91.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dh5nayj30qo0f00w1_hu20ea04c84c4ff01af78f5d9932abe17b_97233_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dh5nayj30qo0f00w1_hu20ea04c84c4ff01af78f5d9932abe17b_97233_18e064c5465d21778d7f02d4735db870.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是我们称之为梦幻级别的服务注册和治理中心，我们对他的要求是比较多的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们需要他支持跨集群，比如说我们现在有多个注册中心，多个注册中心之间可以相互同步信息，然后可以做跨注册中心的调用&lt;/li&gt;
&lt;li&gt;还有支持异构，注册中心可能是不一样的东西。能理解吧，有些是 Service Mesh 的注册中心，比如 Istio 的，有些是 Spring Cloud 的注册中心，比如 Consul。&lt;/li&gt;
&lt;li&gt;然后终极形态，我们希望在两种场景都可以支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;右边的这个图，是我们构想中的比较理想化的注册中心的架构，我们会有各种 adapter 实现，会有一个抽象的模型，把他们抽象起来，然后有一些接口。后来，在我们实现的时候发现，Istio 的路线跟我们有点像，Istio 本身也是做了跨平台的 Adapter，也做了一层抽象，然后它也提出了一些 API。所以我们最终的决策是：往 Pilot 靠。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d2nt63j30qo0f0mzb_hu31720f29613553a7ca4abb201b447775_66040_6826c83871346ce4b5c557edf4fa8c7a.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d2nt63j30qo0f0mzb_hu31720f29613553a7ca4abb201b447775_66040_2ad3162a6db0713c3768cc17586495d3.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d2nt63j30qo0f0mzb_hu31720f29613553a7ca4abb201b447775_66040_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d2nt63j30qo0f0mzb_hu31720f29613553a7ca4abb201b447775_66040_6826c83871346ce4b5c557edf4fa8c7a.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们以 Istio 的 Pilot 模块为基础去做扩展和增强：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加 SOFA Registry 的 Adapter，SOFA Registry 是我们内部的服务注册中心，提供超大规模的服务注册和服务发现的解决方案。所谓超大规模，大家能理解吧？服务数以万计。&lt;/li&gt;
&lt;li&gt;再加一个数据同步的模块，来实现多个服务注册中心之间的数据交换。&lt;/li&gt;
&lt;li&gt;然后第三点就是希望加一个 Open Service Registry API，增加服务注册，因为现在 Istio 的方案只有服务发现，它的服务注册是走 k8s 的，用的是 k8s 的自动服务注册。如果想脱离 k8s 环境，就要提供服务注册的方案。在服务发现和服务模型已经标准化的情况下，我们希望服务注册的 API 也能标准化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d97ijxj30qo0f00ve_hub61408f5335c0ee188f52efefb1db9e4_79731_ab42822f5ce0c4588719fe512fab2bef.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d97ijxj30qo0f00ve_hub61408f5335c0ee188f52efefb1db9e4_79731_0b7e04079039219bc3ce92e6ee98c7e6.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d97ijxj30qo0f00ve_hub61408f5335c0ee188f52efefb1db9e4_79731_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d97ijxj30qo0f00ve_hub61408f5335c0ee188f52efefb1db9e4_79731_ab42822f5ce0c4588719fe512fab2bef.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里还有一个比较特殊的产品，因为时间限制，给大家简单了解一下。&lt;/p&gt;
&lt;p&gt;我们计划的 Edge Sidecar 这个产品，它是东西向服务间通讯的一个特殊桥梁。所谓东西向，大家能理解吧？东西向指服务间通讯，也就是 A 服务调用 B 服务。对应的还有南北向，南北向通常是指从外部网络进来调用服务，如走 API Gateway 调用服务。在东西向通讯中，我们有时会需要一个比较特殊的途径，比如说在这个图中，我们有两个集群，两个集群各有各自的服务注册中心。我们通过增强 Pilot 的方式打通两个注册中心，可以知道对方有什么服务。&lt;/p&gt;
&lt;p&gt;当 A 服务发出一个请求去调用 B 服务的时候，由于两个集群是隔离的，网络无法相通，肯定直接调用不到的。这时 local sidecar 会发现，服务 B 不在本集群，而在右边这个集群里，Local Sidecar 就会将请求转发给 Edge Sidecar，然后由 Edge Sidecar 接力完成后续的工作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2db3805j30qo0f0tas_huaf4ed755b6195b50513ea10595cd2a34_65752_47da0ef16fde2120dfc9508e71b2e48c.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2db3805j30qo0f0tas_huaf4ed755b6195b50513ea10595cd2a34_65752_38763b0e6b2cc16a309d3b3222997813.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2db3805j30qo0f0tas_huaf4ed755b6195b50513ea10595cd2a34_65752_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2db3805j30qo0f0tas_huaf4ed755b6195b50513ea10595cd2a34_65752_47da0ef16fde2120dfc9508e71b2e48c.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个模块的功能会比较特殊一点，因为时间限制，在今天的过程当中，Pilot 和 Edge Sidecar 就不再详细展开。&lt;/p&gt;
&lt;p&gt;下个月在北京的 meetup 上，我们这边负责这一块工作的专家，俊雄同学，会给大家详细展开。&lt;/p&gt;
&lt;h2 id=&#34;三开源策略&#34;&gt;三、开源策略&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddv17cj30qo0f074r_hu4cbc79b86292877c95e98e447c18057d_18949_7ad27f3c9272fa8a69fbfa338151b063.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddv17cj30qo0f074r_hu4cbc79b86292877c95e98e447c18057d_18949_a2f2a53f3857941d81da497c08ee691d.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddv17cj30qo0f074r_hu4cbc79b86292877c95e98e447c18057d_18949_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddv17cj30qo0f074r_hu4cbc79b86292877c95e98e447c18057d_18949_7ad27f3c9272fa8a69fbfa338151b063.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFA Mesh 的开源策略，可能会和大家之前接触到的一些开源产品，有质的差异，非常的不一样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0glyij30qo0f077i_hud09f42771ed9dde81677859d75600201_97687_7e1d658e8586da0d136c5294fc893cdd.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0glyij30qo0f077i_hud09f42771ed9dde81677859d75600201_97687_dc24fc69fa820699022fea0e6a5b08d5.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0glyij30qo0f077i_hud09f42771ed9dde81677859d75600201_97687_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0glyij30qo0f077i_hud09f42771ed9dde81677859d75600201_97687_7e1d658e8586da0d136c5294fc893cdd.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;备注：这块就不整理了，直接看图中文字。&lt;/p&gt;
&lt;p&gt;这是整个大的愿景。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfat8jj30qo0f0n00_hu1240213efdb274534e57be2681e3a045_85740_fbf46bd6db25c60a5de4ce61fb97d6c3.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfat8jj30qo0f0n00_hu1240213efdb274534e57be2681e3a045_85740_af749c46cf1be5b68415ec3e326c8491.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfat8jj30qo0f0n00_hu1240213efdb274534e57be2681e3a045_85740_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfat8jj30qo0f0n00_hu1240213efdb274534e57be2681e3a045_85740_fbf46bd6db25c60a5de4ce61fb97d6c3.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFA Mesh 的开源态度，其实我写左边这些的时候是有很大压力的。用官方话语说，不针对任何人和任何项目，我们不影射任何人。&lt;/p&gt;
&lt;p&gt;但是，大家如果经常用各种开源产品的话，会发现一些问题。比如说，开源的时机。大家接触的开源产品，尤其是国内的，不管是多大的公司，通常都是产品完成之后，甚至是使用好多年。好处是相对稳，缺点是什么？（备注：现场回答，老）对，技术可能已经很老了，十年前的！还有可能是它都已经放弃了，开源出来时自己不再使用。或者说是一个很新的产品，真的很新，他自己不用，说就是做出来给你用的。（备注：现场哄笑）自己不用的产品给你用，你的第一反应是什么？小白鼠是吗？你愿意做小白鼠吗？你敢把公司的这个产品放上面吗？&lt;/p&gt;
&lt;p&gt;SOFA Mesh 这次比较特殊，非常非常特殊。我们这个产品，会在非常早的时间点上开源给大家。我甚至可以跟大家说，其实在这个点上，我们更重要的是摆明态度：我们要开源，我们要把这个产品开源给大家，甚至早到我们自己都不认为这是一个完整的产品。为什么？&lt;/p&gt;
&lt;p&gt;有几个事情，这几点大家认可吧？业界最新的技术，Mesh 是最新技术大家都已经达成共识了吧？业界最好的架构，当然这个我们还在努力中，尽量做好。然后我们会给大家一个承诺，大家不用担心做小白鼠，你能拿到的产品，我们已经趟过一遍了。&lt;/p&gt;
&lt;p&gt;开源动机，这个地方我们也不说大话，就是我们希望能吸引整个社区，谋求这样一个合作，走开源共建的方式。这是为什么我们会选择在现在这个时间点上开源出来。&lt;/p&gt;
&lt;p&gt;整个产品的维护，什么样的产品会让你有信心，不用担心中间断掉？最重要的一点是我们自己在用。想想，如果支付宝在用，你担心这个项目死掉吗？对不对？如果这个产品本身是蚂蚁金服这样级别的公司，在它的线上将会使用的产品，而且是同样一个核心的版本。相信在这种情况下，大家就放心了吧？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gq7wlrj30qo0f076u_huc7108a27a41e490d23fd49485501a7d6_75037_f6b7018746638a3a8caa518b109cb9a4.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gq7wlrj30qo0f076u_huc7108a27a41e490d23fd49485501a7d6_75037_5601fdce05a2bc529004a3e460326e72.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gq7wlrj30qo0f076u_huc7108a27a41e490d23fd49485501a7d6_75037_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gq7wlrj30qo0f076u_huc7108a27a41e490d23fd49485501a7d6_75037_f6b7018746638a3a8caa518b109cb9a4.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFA Mesh 的合作模式，我称之为&amp;quot;多层次全方位开放&amp;quot;。&lt;/p&gt;
&lt;p&gt;中间这幅图，最底下的是&lt;strong&gt;基础类库&lt;/strong&gt;，实现各种功能。我们希望有这样一套基础类库，类比 Netflix 的 OSS 套件。因为 Golang 的类库做的不是很好，没有 Java 沉淀的那么好。目标是希望在这个产品做完之后，能给整个社区沉淀出一套 Golang 的微服务基础类库。最重要的一点，是希望最好能大家合力，在这个点上做出一套成熟稳定性能足够好的产品。这是在类库层面。&lt;/p&gt;
&lt;p&gt;在类库之上，功能模块层面，比如说 Golang 版本的 Sidecar，我们希望它能替换 Envoy 的功能。在原来使用 Envoy 的情况下可以使用这个 Sidecar 来替代。体现在什么层次？就是说，如果想用 Envoy，也很喜欢它，但是可能又受限于 C++语言栈，更希望是 Golang 语言栈的时候，可以选择我们这一套。或者如果我们抱有同样的想法，比如想把 Mixer 合进来，可以在 Sidecar 这个层面上来重用我们的产品，跟我们做合作。或者我们刚才提到的这个产品，增强版本的 Pilot，大家有印象吧？我们会实现一个非常强大的，跨各种集群，各种异构的服务注册机制。然后是 Edge Sidecar，在两个不同的区域之间，比如两个不同的机房，IP 地址不通的情况下，帮你打通服务间调用。这些功能模块，会以单独的产品和项目出现，你可以在某一个产品上跟我们合作。&lt;/p&gt;
&lt;p&gt;第三点就是完整的产品，如果你需要一个完整的 Service Mesh 的产品，把这些所有的功能都包括进来，没问题，SOFA Mesh 可以拿来用。&lt;/p&gt;
&lt;p&gt;有些同学可能会需要更完整的解决方案，我们的金融云会提供 SOFA Mesh 的支持，这是我们的目标。你可以将你的系统，架构在金融云之上。&lt;/p&gt;
&lt;p&gt;今天的几位讲师来自不同的公司，我们非常欢迎业界参与。如果大家有意在 Service Mesh 领域做一些事情，大家可以相互之间做技术的沟通，技术的交流，在社区合作上做一些事情。&lt;/p&gt;
&lt;p&gt;有些同学说，我只是用一下，好像没法做什么贡献。其实，&amp;ldquo;用&amp;quot;是一个很重要的合作，你能够用，你就会遇到问题，有你的诉求，遇到什么样的 bug，有什么样需求没有满足。这些对我们来说，是非常重要的输入。在这一点上，欢迎和我们保持合作。 















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d18aozj30qo0f0406_hu51cf177449875a380a06e6ffc11b9e93_53296_ab8a76abfb14c7bfd474c434af168b4c.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d18aozj30qo0f0406_hu51cf177449875a380a06e6ffc11b9e93_53296_d10874abfff6e8d3da39a8850973e631.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d18aozj30qo0f0406_hu51cf177449875a380a06e6ffc11b9e93_53296_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d18aozj30qo0f0406_hu51cf177449875a380a06e6ffc11b9e93_53296_ab8a76abfb14c7bfd474c434af168b4c.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFA Mesh 的开源宣言，写的比较狗血。但是在这一点上，我觉得这一次 SOFA Mesh 在开源上还是做的比较有诚意。&lt;/p&gt;
&lt;p&gt;首先我们认可这个大方向，我们看好 Service Mesh 的前景。体现在什么上呢？我们现在规划，未来整个蚂蚁金服内部的大部分应用都会逐渐的往 Service Mesh 上落。这个内部已经达成一致了，会往这个方向走。&lt;/p&gt;
&lt;p&gt;第二是说，&amp;ldquo;勇敢探索&amp;rdquo;，&amp;ldquo;耐心填坑&amp;rdquo;，有在 1.0 版本之前用过大型开源产品的同学，对这两个词都应该有深刻体验，对吧？包括前两年用 0.*版本和 1.1/1.2 版本的 k8s 的同学。任何一个新的技术，一个大的方案出来，前期的时候，这些事情是一定会遇到的。但是我们觉得还是要去趟这个事情。&lt;/p&gt;
&lt;p&gt;我们要继续推进这样一个技术进步，包括 Service Mesh 技术社区的推广。大家如果有注意的话说，Service Mesh 技术社区已经重新启动了，我们在跟很多的公司，包括甚至我们一些竞争对手合作。从技术进步的角度说，我们欢迎大家在一个公平的基础上做技术交流。&lt;/p&gt;
&lt;p&gt;然后我们是愿意做分享的，整个产品，我们接下来所有能开源的东西都会开源出来。除了一些内部定制化的东西，内部没有开源的产品的集成。基本上，你们能看到的东西，也就是我们内部用的东西。&lt;/p&gt;
&lt;p&gt;我们寻求和大家的合作，包括刚才讲过的各个层面的合作，哪怕是简单的使用，发现问题给我们提交一些 bug，也是非常好的合作契机。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfuqcij30qo0f0wg4_hu9ac70d308abde9ba080c8c4972f453fe_50934_8b89334afce4e7d1507ccb041ef4eda3.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfuqcij30qo0f0wg4_hu9ac70d308abde9ba080c8c4972f453fe_50934_f2501d473108a63e00707d32b2b49a51.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfuqcij30qo0f0wg4_hu9ac70d308abde9ba080c8c4972f453fe_50934_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfuqcij30qo0f0wg4_hu9ac70d308abde9ba080c8c4972f453fe_50934_8b89334afce4e7d1507ccb041ef4eda3.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里我喊一个口号，这个口号有点大，&amp;ldquo;集结中国力量，共建开源精品&amp;rdquo;。这里面有个词，比较大一点，我也斟酌了一下，中国这两个字敢不敢用。最后我觉得还是用吧，至少到目前为止，Service Mesh 这个技术领域，在全世界目前都还没有成熟的场景落地的情况下，我们目前在这方面的探索，已经是走在最前面的了。&lt;/p&gt;
&lt;p&gt;在这一点上，我们是希望能联合国内在这个领域做探索的同学，我们一起来做这个事情。我们开源的一个重要目的，是说不管大家在商业上有什么样的竞争，至少在技术领域上，包括刚才说的可以在类库层面，产品层面，或者社区合作方面，开展合作。我们希望能够尽可能的联合国内的合作伙伴，包括竞争对手一起来营造整个技术氛围，把整个 Service Mesh 技术体系的基本水准提升上来。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7u1q9j30qo0bwjru_hud86c350c054629ef37a27b087a29765e_18891_c4862907ea01a69d8d9fe515240a4ff8.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7u1q9j30qo0bwjru_hud86c350c054629ef37a27b087a29765e_18891_4da1949eb4d3f78929142bf3bd0bb087.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7u1q9j30qo0bwjru_hud86c350c054629ef37a27b087a29765e_18891_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7u1q9j30qo0bwjru_hud86c350c054629ef37a27b087a29765e_18891_c4862907ea01a69d8d9fe515240a4ff8.webp&#34;
               width=&#34;760&#34;
               height=&#34;339&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这一点应该是大家比较关注的，什么时候开源？我们只能告诉大家说，on the way，正在路上。&lt;/p&gt;
&lt;p&gt;本来这一页的写法应该是贴个地址给大家的，但是因为进度的原因还没有实现，有可能会在一到两个星期之后，在 7 月份的时候开源给大家。&lt;/p&gt;
&lt;p&gt;需要澄清的一点，大家的期望值不要太高，因为我们开源出来的第一个版本，主要是释放姿态，把我们的开源共建的姿态释放出来。我们的第一个版本，肯定不是一个完善的版本。（备注：现场有同学问，有在用吗？）内部有用一部分，Sidecar 内部已经在用了，但是第二部分的内容，比如说 XDS API 的集成，我们现在正在做。我们不希望等把产品做完善了，比如说两年之后非常成熟的情况下再来开源。我们希望尽可能早的开源。&lt;/p&gt;
&lt;p&gt;（备注：现场提问，7 月份的版本，不一定是生产环境可用？）对，是的。有一部分功能是生产可用的，有一部分功能不是，因为我们是迭代上去的。&lt;/p&gt;
&lt;h2 id=&#34;四官方社区网站&#34;&gt;四、官方社区网站&lt;/h2&gt;
&lt;p&gt;这是我们刚刚开通的&lt;a href=&#34;https://www.servicemesher.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh 技术社区的官方网站&lt;/a&gt;，欢迎访问。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d27g5jj30qo0f00ui_hu3cd89c1640f39421dc03a28b0a237e47_55750_a3dfb3371d7d724717ff4d8d97f3e5c6.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d27g5jj30qo0f00ui_hu3cd89c1640f39421dc03a28b0a237e47_55750_56042f5765e19157b46cedffa4fc0dba.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d27g5jj30qo0f00ui_hu3cd89c1640f39421dc03a28b0a237e47_55750_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d27g5jj30qo0f00ui_hu3cd89c1640f39421dc03a28b0a237e47_55750_a3dfb3371d7d724717ff4d8d97f3e5c6.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #1 杭州站</title>
      <link>https://cloudnative.to/event/service-mesh-meetup-01/</link>
      <pubDate>Sat, 30 Jun 2018 13:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/event/service-mesh-meetup-01/</guid>
      <description>&lt;h2 id=&#34;讲师分享&#34;&gt;讲师分享&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV19h411p7jn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区 meetup 第七期深圳站开场致辞 - 宋净超&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1WQ4y1z7zQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 IAST 构建高效的 DevSecOps 流程 - 董志勇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1hf4y1E7KJ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生场景下的开发和调试 - 汪晟杰，黄金浩&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1LL411476c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 在腾讯游戏云原生平台应用 - 田甜&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1TQ4y1C7xx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 KubeVela 构建混合云应用管理平台 - 邓洪超&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Istio Mixer Cache 工作原理与源码分析 part4－签名</title>
      <link>https://cloudnative.to/blog/istio-mixer-cache-part4-signature/</link>
      <pubDate>Mon, 11 Jun 2018 14:03:34 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-mixer-cache-part4-signature/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文转载自&lt;a href=&#34;https://skyao.io/post/201806-istio-mixer-cache-signature/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;敖小剑的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接前文，继续分析 Mixer Check Cache 的源码，这次的重点是签名算法，也就是 Referenced::Signature() 方法。&lt;/p&gt;
&lt;p&gt;前情回顾：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Referenced 保存的是 mixer adapter 使用的引用属性的一个组合，也就是前面例子中的 &lt;code&gt;“a,b,c”或者“a,b,c不存在”&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Referenced 中有两个数据结构： &lt;code&gt;std::vector&amp;lt;AttributeRef&amp;gt; absence_keys_&lt;/code&gt; 和 &lt;code&gt;std::vector&amp;lt;AttributeRef&amp;gt; exact_keys_&lt;/code&gt;，exact_keys_保存的是一定要出现的属性，absence_keys_中保存的是没有出现的属性&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基本流程&#34;&gt;基本流程&lt;/h2&gt;
&lt;p&gt;我们来看详细源代码，具体在文件&lt;code&gt;src/istio/mixerclient/referenced.cc&lt;/code&gt;中，代码的基本流程非常清晰：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Referenced&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Attributes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                           &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;extra_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                           &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 第一步，先检查输入是否匹配保存的引用属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 必须同时满足 absent key 和 exact key 的要求
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckAbsentKeys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckExactKeys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 发现匹配之后，才开始计算签名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;CalculateSignature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;extra_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;切记：请更新到 &lt;code&gt;istio/proxy&lt;/code&gt; 仓库的最新代码，在 master 分支上才能看到这个版本。&lt;/p&gt;
&lt;p&gt;这里的代码在此之前是存在性能问题的，我为此提交了一个改进方案，由于 0.8 版本发布前锁了 master 分支，因此这个 fix 的代码是在 0.8 版本发布之后才进的 master 分支。&lt;/p&gt;
&lt;p&gt;详情请见：&lt;a href=&#34;https://github.com/istio/proxy/issues/1531&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/istio/proxy/issues/1531&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;引用属性匹配&#34;&gt;引用属性匹配&lt;/h2&gt;
&lt;p&gt;先检查 absent key，这里要求请求中的属性，不能出现 absence&lt;em&gt;keys&lt;/em&gt; 保存的属性，否则就是不匹配：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Referenced&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckAbsentKeys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Attributes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes_map&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;absence_keys_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 检查每个 absence_key
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;absence_keys_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attributes_map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attributes_map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;// 如果在输入的属性中没有找到，就继续下一个
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果找到了，则直接返回不匹配
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 实际代码中还有特别的 StringMap 类型的属性需要额外处理，简单起见我们忽略它
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 只有 absence_key 都没有在输入的属性中出现，才表示匹配
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再检查 exact keys，这里要求 exact keys 中保存的每一个属性，必须在请求中出现，否则就是不匹配：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Referenced&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckExactKeys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Attributes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes_map&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exact_keys_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 检查每个 exact_key
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exact_keys_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attributes_map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果没有在请求中出现就返回不匹配
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attributes_map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;// 实际代码中还有特别的 StringMap 类型的属性需要额外处理，简单起见我们忽略它
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 只有 exact_key 都在输入的属性中出现，才表示匹配
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;简单说，引用属性匹配的要求就是：exact key 都必须出现，absence key 都不能出现。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;输入&lt;/th&gt;
&lt;th&gt;exact=“a,b,c”,absent=“”&lt;/th&gt;
&lt;th&gt;exact=“a,b”,absent=“c”&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;“a=1,b=2,c=3,e=4,f=5”&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“a=1,b=2,e=4,f=5”&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;计算签名&#34;&gt;计算签名&lt;/h2&gt;
&lt;p&gt;在 exact key 和 absent key 检查通过之后，就意味着请求中的属性满足当前 Referenced 的匹配要求。&lt;/p&gt;
&lt;p&gt;下一步就可以进行签名计算了，CalculateSignature() 方法的参数中 attributes 是输入的所有属性，extra_key 这个参数目前没有使用，忽略即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Referenced&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CalculateSignature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Attributes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;extra_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes_map&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;utils&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MD5&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 游历 exact_keys_ 中的每个属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exact_keys_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exact_keys_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 在输入的属性中通过属性名找到包含值的属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attributes_map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;it&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;first&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kDelimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kDelimiterLength&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 根据属性值的不同类型，调用 hasher.Update() 方法进行计算
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Attributes_AttributeValue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value_case&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Attributes_AttributeValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;kStringValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;......&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 忽略其他类型的处理代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Attributes_AttributeValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;VALUE_NOT_SET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kDelimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kDelimiterLength&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;extra_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 完成签名计算的最后一步，得到签名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signature&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Digest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即 CalculateSignature() 方法会将 exact&lt;em&gt;keys&lt;/em&gt; 指定的请求属性进行签名，注意只对 exact&lt;em&gt;keys&lt;/em&gt; 的属性进行签名，absent key 反正没有出现自然无需也无法对它们进行计算。&lt;/p&gt;
&lt;p&gt;形象起见，以我们前面介绍基础概念和工作原理时的例子做讲解，假设 referenced_map 保存的引用属性组合为 &lt;code&gt;{“k1”: “a,b,c”, “k2”: “a,b,c不存在” }&lt;/code&gt; ，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;请求&lt;/th&gt;
&lt;th&gt;和请求匹配的引用属性&lt;/th&gt;
&lt;th&gt;进行签名计算的实际属性值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;“a=1,b=2,c=3,e=4,f=5”&lt;/td&gt;
&lt;td&gt;exact=“a,b,c”, absent=“”&lt;/td&gt;
&lt;td&gt;a=1,b=2,c=3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“a=1,b=2,e=4,f=5”&lt;/td&gt;
&lt;td&gt;exact=“a,b”, absent=“c”&lt;/td&gt;
&lt;td&gt;a=1,b=2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;签名算法的关键在于需要先匹配 exact key 和 absent key，然后再计算。和主流程代码一样，只要理解了引用属性和 absent key 的概念，就容易理解了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Istio Mixer Cache 工作原理与源码分析 part3—主流程</title>
      <link>https://cloudnative.to/blog/istio-mixer-cache-part3-main/</link>
      <pubDate>Mon, 11 Jun 2018 13:43:10 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-mixer-cache-part3-main/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文转载自&lt;a href=&#34;https://skyao.io/post/201806-istio-mixer-cache-main/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;敖小剑的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过前面基本概念和实现原理的介绍，大家对 mixer check cache 应该有了基本的了解，下面我们开始展开源代码来细细研读。&lt;/p&gt;
&lt;h2 id=&#34;check-cache-的主要流程&#34;&gt;Check Cache 的主要流程&lt;/h2&gt;
&lt;h3 id=&#34;check-cache-的调用入口&#34;&gt;Check Cache 的调用入口&lt;/h3&gt;
&lt;p&gt;对 mixer cache 的调用在代码 &lt;code&gt;proxy/src/istio/mixerclient/client_impl.cc&lt;/code&gt;中的方法 Check() 中，此处跳过 quota cache 的内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;CancelFunc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MixerClientImpl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Check&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Attributes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;quota_config&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Requirement&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;quotas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;TransportCheckFunc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;transport&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CheckDoneFunc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;on_done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;total_check_calls_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unique_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckResult&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;check_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CheckCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckResult&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 在这里调用了 CheckCache.Check() 方法，进行检查
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;check_cache_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Check&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;check_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;CheckResponseInfo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;check_response_info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;check_response_info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_check_cache_hit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;check_result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IsCacheHit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;check_response_info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response_status&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;check_result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果 check cache 命中，并且结果不 OK，则直接结束处理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;check_result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IsCacheHit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;check_result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ok&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;on_done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;check_response_info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;CheckCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckResult&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;raw_check_result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;check_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果 check cache 没有命中，则需要发起请求到 mixer 得到 response
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 然后将 response 加入 check cache 中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;transport&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;request_copy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;raw_check_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;raw_quota_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;n&#34;&gt;on_done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;raw_check_result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;request_copy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们先来看看缓存的保存方式，再返回来看 Check() 方法的具体实现，这样方便理解。&lt;/p&gt;
&lt;p&gt;这里的 transport 是一个 TransportCheckFunc，具体定义在&lt;code&gt;include/istio/mixerclient/environment.h&lt;/code&gt; 头文件中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Defines a function prototype to make an asynchronous Check call
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TransportCheckFunc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CancelFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mixer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mixer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DoneFunc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;on_done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 DoneFunc 的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Defines a function prototype used when an asynchronous transport call
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// is completed.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Uses UNAVAILABLE status code to indicate network failure.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DoneFunc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;google&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;protobuf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;util&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;总结说，Check() 方法会通过 TransportCheckFunc 对 mixer 发起请求，在得到 response 之后，再调用 DoneFunc。&lt;/p&gt;
&lt;p&gt;在这个匿名的 DoneFunc 中，最关键的代码是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;raw_check_result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;request_copy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 raw_check_result 类型是 CheckCache::CheckResult。&lt;/p&gt;
&lt;h2 id=&#34;保存-check-结果&#34;&gt;保存 Check 结果&lt;/h2&gt;
&lt;p&gt;CheckResult.SetResponse() 方法的源代码在 istio/proxy 项目， &lt;code&gt;src/istio/mixerclient/check_cache.h&lt;/code&gt; 文件中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;SetResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;google&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;protobuf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;util&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mixer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Attributes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mixer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on_response_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 调用 on_response_这个 Func
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;status_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;on_response_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// The function to set check response.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OnResponseFunc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;google&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;protobuf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;util&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;google&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;protobuf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;util&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mixer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Attributes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mixer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;OnResponseFunc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;on_response_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// on_response_在此定义
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;on_response_这个 OnResponseFunc 的设定在 &lt;code&gt;src/istio/mixerclient/check_cache.cc&lt;/code&gt; 文件中的 CheckCache::Check() 方法中设置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on_response_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                              &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Attributes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                              &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CheckResponse&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ok&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// status 表示对 mixer 的远程调用的结果
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 如果调用都没有成功，则没有 check 结果可言，自然不必缓存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;options_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;network_fail_open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// 注意这里有个选项，如果打开，则在 mixer 调用没有成功时视为 check 成功
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;OK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 如果对 mixer 调用成功，拿到了 response，则进行缓存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;CacheResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;system_clock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面是保存缓存的关键代码了，CacheResponse() 方法，清晰起见，忽略分支处理和错误处理代码，日志打印等：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CheckCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CacheResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Attributes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                 &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CheckResponse&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Tick&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;time_now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 类 Referenced 用来保存引用属性，也就是哪些属性被 mixer adapter 使用了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 记得前面讲述实现原理时的例子吗？这里的 Referenced 就是&amp;#34;a,b,c&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;Referenced&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;referenced&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// Fill() 方法解析 response 的 precondition 的 referenced_attributes 并填充到 referenced
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;referenced&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Fill&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                       &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;precondition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;referenced_attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 调用 Signature() 方法进行签名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;referenced&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;......&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 进行第一层缓存的保存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// referenced_map 用于保存各种引用属性的组合
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 在实现原理中的例子，就是&amp;#34;a,b,c&amp;#34;和带 absence key 的&amp;#34;a,b&amp;#34;,&amp;#34;a,c&amp;#34;等
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;referenced&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Hash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 计算当前引用属性的 hash 值，比如&amp;#34;a,b,c&amp;#34;的 hash 值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 然后保存进 referenced_map
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;referenced_map_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;referenced_map_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;referenced_map_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;referenced&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 进行第二层缓存的保存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 用计算而来的签名来在第二层缓存中查找
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;CheckLRUCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ScopedLookup&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lookup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cache_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lookup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Found&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果已经存在则更新 CacheElem
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;lookup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SetResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;time_now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lookup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 如果不存在则插入新的 CacheElem
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;CacheElem&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cache_elem&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CacheElem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;time_now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;cache_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Insert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache_elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache_elem&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;缓存的结构和保存方式&#34;&gt;缓存的结构和保存方式&lt;/h3&gt;
&lt;p&gt;我们现在可以结合代码来详细的展开缓存的结构和保存方式了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 第一层缓存，用于保存引用属性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 这个 map 中，value 是 Referenced 对象，key 是 Referenced 的 hash 值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unordered_map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Referenced&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;referenced_map_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 第二层缓存，用于保存 check 的结果
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 这是一个 LRU Cache，key 是请求的签名，value 是 check 的结果，封装为 CacheElem
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CheckLRUCache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;utils&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SimpleLRUCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CacheElem&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unique_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckLRUCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Referenced 中保存使用的属性，包括 absence 的属性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// The keys should be absence.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AttributeRef&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;absence_keys_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// The keys should match exactly.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AttributeRef&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exact_keys_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以前面的例子为例，”a,b,c 不存在”这种引用属性组合，在保存时就是 a/b 保存在 exact_keys 中，而 c 保存在 absence_keys 中。&lt;/p&gt;
&lt;p&gt;CacheElem 中保存的是检查结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;google&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;protobuf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;util&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;status_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chrono&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time_point&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chrono&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;system_clock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expire_time_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;use_count_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 status 字段是结果，而 expire_time 和 use_count 是这个缓存项的过期时间和使用次数，这个细节后面再展开。&lt;/p&gt;
&lt;p&gt;两层缓存 key 值的计算，会比较有意思，我们会在下一节中详细展开，这一节我们先关注在缓存的主要流程。我们继续看缓存的 check() 方法是如何实现的，即怎么匹配请求和缓存。&lt;/p&gt;
&lt;h2 id=&#34;匹配请求和缓存&#34;&gt;匹配请求和缓存&lt;/h2&gt;
&lt;p&gt;每一个请求，都要和 mixer check cache 匹配一下，看是否可以命中缓存从而避免对 mixer 的远程调用。有了前面的铺垫，再来看缓存是如何匹配就简单了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;check_cache_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Check&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;check_result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;源代码在 &lt;code&gt;src/istio/mixerclient/check_cache.cc&lt;/code&gt; 中，去除错误处理和细节处理代码之外，主要代码为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CheckCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Check&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Attributes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Tick&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;time_now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 游历第一层缓存，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// referenced_map 中保存的是所有保存的引用属性组合中
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 在我们前面的例子中，这里保存有 {“k1”: “a,b,c”, “k2”: “a,b,c 不存在” } 等
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;auto&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;referenced_map_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Referenced&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reference&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 在所有保存的引用属性组合中，逐个匹配看请求是否具备保存的引用属性结合
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 如果引用属性和请求中的属性匹配，则计算签名
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reference&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// 进行第二层缓存的查找
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 第二层缓存的 key 是签名，因此简单通过 key 查找就 OK
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;CheckLRUCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ScopedLookup&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lookup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cache_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;signature&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lookup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Found&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;n&#34;&gt;CacheElem&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elem&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lookup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elem&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 如果游历完第一层缓存，也没能找到匹配的引用属性，则只能返回 NOT_FOUND
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Code&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NOT_FOUND&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意在 Signature() 方法中实际做了两个事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 referenced_map 查找看是否有匹配的引用属性组合&lt;/li&gt;
&lt;li&gt;如果有，则计算签名，以便通过签名来进行第二层缓存的查找&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个 Signature() 方法的实现是整个 mixer check cache 的重中之重，核心所在。&lt;/p&gt;
&lt;p&gt;篇幅原因，我们将在下一节中详细展开 Signature() 方法实现的源代码解析。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Mixer Check Cache 的主流程代码，在了解了基本概念和工作原理之后，理解起来并不困难。代码本身并没有特别费解的地方，麻烦之处在于对 Referenced Attribute / 引用属性这个概念的理解。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Istio Mixer Cache 工作原理与源码分析 part2－工作原理</title>
      <link>https://cloudnative.to/blog/istio-mixer-cache-part2-principle/</link>
      <pubDate>Thu, 07 Jun 2018 19:19:44 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-mixer-cache-part2-principle/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;转载自&lt;a href=&#34;https://skyao.io/post/201806-istio-mixer-cache-principle/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;敖小剑的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;经过前面的基础概念的介绍，我们现在已经可以勾勒出一个 mixer cache 的实现轮廓，当然实际代码实现时会有很多细节。但是为了方便理解，我们在深入细节之前，先给出一个简化版本，让大家快速了解 mixer cache 的实现原理。后面的章节我们再逐渐深入。&lt;/p&gt;
&lt;p&gt;Mixer Cache 分为两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;check cache&lt;/li&gt;
&lt;li&gt;quota cache&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单起见，我们先关注 check cache，在 check cache 讲述清楚之后，我们再继续看 quota cache。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：istio 一直在持续更新，以下代码来源于 istio 0.8 版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;mixer-check-cache-的构造&#34;&gt;Mixer Check Cache 的构造&lt;/h2&gt;
&lt;p&gt;Mixer Cache 在实现时，在 envoy 的内存中，保存有两个数据结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CheckCache&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unordered_map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Referenced&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;referenced_map_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CheckLRUCache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;utils&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SimpleLRUCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CacheElem&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unique_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckLRUCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cache_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;具体代码：见istio/proxy项目，文件&lt;code&gt;src/istio/mixerclient/check_cache.h&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;referenced_map：保存的是引用属性&lt;/li&gt;
&lt;li&gt;cache：保存的是 check 的结果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里和一般缓存不一样，有两个 map，也就是存在两套 key/value 两层缓存，为什么要这样设计？&lt;/p&gt;
&lt;h2 id=&#34;mixer-check-cache-的核心设计&#34;&gt;Mixer Check Cache 的核心设计&lt;/h2&gt;
&lt;p&gt;缓存在设计上，最核心的内容就是如何设计缓存的 key，这个问题在 mixer check cache 中尤其突出。&lt;/p&gt;
&lt;h3 id=&#34;为什么要有两层-map&#34;&gt;为什么要有两层 Map？&lt;/h3&gt;
&lt;p&gt;我们继续以这个最基本的场景为例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201804-istio-mixer-cache-concepts/images/referenced-attributes.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;注意这个场景下属性的使用情况是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;envoy 提交的请求中有 5 个属性，”a=1,b=2,c=3,e=0,f=0”&lt;/li&gt;
&lt;li&gt;mixer 中有三个 adapter，每个 adapter 只使用提交属性中的一个属性 a/b/c&lt;/li&gt;
&lt;li&gt;在 CheckResponse 中返回 referencedAttributes 字段的内容为”a,b,c”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要怎么设计这个 Mixer check cache？先分析缓存的逻辑语义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;返回的 referencedAttributes 字段的内容为”a,b,c”，说明这三个属性被使用&lt;/li&gt;
&lt;li&gt;结合输入的”a=1,b=2,c=3,e=0,f=0”，就可以得知”a=1,b=2,c=3”这个属性和属性的值的组合，代表一个输入，结果是固定而可以缓存的&lt;/li&gt;
&lt;li&gt;如果下一个请求，同样提供”a,b,c”三个属性，并且三个属性的值是”a=1,b=2,c=3”，则可以直接使用这个缓存的结果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：由于哪些属性可能会被使用是取决于运行时实际部署的 adapter，因此 mixer check cache 的 key 计算时是无法直接指定要计算哪些属性的，也就无法简单的对输入属性做简单计算得到 key。这是 mixer cache 和一般场景下的缓存的关键差异。&lt;/p&gt;
&lt;p&gt;mixer check cache 在工作时，如果要命中缓存，就必须带有两层匹配逻辑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求中是否携带有匹配的属性，在上面的例子中，就是要有”a,b,c”三个属性&lt;/li&gt;
&lt;li&gt;这些属性是否具备匹配的值，在上面的例子中，就是要”a=1,b=2,c=3”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在具体实现上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;referenced_map 是第一层缓存，用来保存引用属性的组合，注意只有属性名，这里不保存属性值&lt;/li&gt;
&lt;li&gt;cache 是第二层缓存，用来保存输入的签名（根据引用属性的值计算而来）/value（check 的检查结果）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;两层-cache-是如何工作的&#34;&gt;两层 cache 是如何工作的？&lt;/h3&gt;
&lt;p&gt;为了避免陷入代码细节，我们先不看代码具体实现（这是下一章的内容），先只看工作原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;referenced_map 用来保存哪些属性组合已经被缓存，比如 &lt;code&gt;{&amp;quot;k1&amp;quot;: &amp;quot;a,b,c&amp;quot;}&lt;/code&gt; 这样表示当前只有一个属性组合”a,b,c”被保存，为了简单我们先忽略 key 的计算方式。&lt;/li&gt;
&lt;li&gt;cache 用来保存输入的签名 (简单理解为有效输入内容”a=1,b=2,c=3”的 hash 结果) 和 check 结果（简化为 true/false 表示是否通过），比如 &lt;code&gt;{ &amp;quot;a=1,b=2,c=3&amp;quot;: &amp;quot;true&amp;quot; }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来看各种场景下的请求和缓存的匹配请求，先看最理想的缓存命中的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;请求为：”a=1,b=2,c=3,e=0,f=0”&lt;/p&gt;
&lt;p&gt;这个请求和被缓存的请求是一模一样的，我们期待可以命中缓存。&lt;/p&gt;
&lt;p&gt;匹配时，先进行第一层匹配：输入的”a=1,b=2,c=3,e=0,f=0”和 referenced_map {“k1”: “a,b,c”} 进行检查，发现输入的”a=1,b=2,c=3,e=0,f=0”可以和保存的”a,b,c”属性组合匹配。&lt;/p&gt;
&lt;p&gt;然后继续，第二层缓存就可以简单通过 key 来匹配了。注意在对输入进行签名时，只需要计算引用属性的 hash 值，即只需要计算”a=1,b=2,c=3”，再通过这个签名在 cache 中找到缓存结果。&lt;/p&gt;
&lt;p&gt;这便是标准的 mixer check cache 的匹配姿势。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求为：”a=1,b=2,c=3,e=1,f=2”&lt;/p&gt;
&lt;p&gt;差异在于e/f属性的值有所不同，考虑到e/f两个属性没有adapter使用，和”a=1,b=2,c=3,e=0,f=0”等效，我们期待可以命中缓存。&lt;/p&gt;
&lt;p&gt;第一层匹配，输入的”a=1,b=2,c=3,e=1,f=2”和{“k1”: “a,b,c”} 命中，由于属性组合是”a,b,c”，因此计算签名时还是计算”a=1,b=2,c=3”，因此可以命中第二层缓存。&lt;/p&gt;
&lt;p&gt;通过这种在签名时忽略未被 adapter 使用的属性的方式，mixer check cache 做到了只检查被 adapter 使用的属性，而其他属性的值不会影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们再来看缓存不命中的典型场景，此时会多一个保存新结果到缓存的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新请求：”a=1,b=2,c=10,e=0,f=0”&lt;/p&gt;
&lt;p&gt;不同在于 c 的取值有变化，这是一个新的有效输入，和已经缓存的”a=1,b=2,c=3”不同，应该无法命中。&lt;/p&gt;
&lt;p&gt;匹配时，第一层匹配命中，计算签名时计算的输入是”a=1,b=2,c=10”，得到的签名结果自然和缓存的”a=1,b=2,c=3”的签名不同，因此第二层缓存没有命中。&lt;/p&gt;
&lt;p&gt;这是典型的属性组合匹配但是属性具体值不匹配的场景，我们看 mixer check cache 的后续处理。&lt;/p&gt;
&lt;p&gt;缓存不命中，就需要向 mixer 发起远程，得到应答，应答中给出 adapter 使用的属性情况，此时依然是”a,b,c”，和检查的结果，我们假定这次是 false。即此时我们得到了一个新的输入和结果的对应关系，我们将这个结果保存起来：referenced_map 中现有的值是 {“k1”: “a,b,c”}，无需改变。cache 从 { “a=1,b=2,c=3”: “true” } 增加新结果，变为 { “a=1,b=2,c=3”: “true”, “a=1,b=2,c=10”: “false”}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继续发送请求：”a=1,b=2,c=10,e=0,f=0”/”a=1,b=2,c=3,e=0,f=0”&lt;/p&gt;
&lt;p&gt;如果继续有这样的请求进来，则继续命中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新请求：”a=1,b=20,c=10,e=0,f=0”&lt;/p&gt;
&lt;p&gt;如果属性a/b/c的值继续变化，则继续重复前面的不命中后更新缓存的步骤。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;absence-key&#34;&gt;absence key&lt;/h3&gt;
&lt;p&gt;通过上面稍显枯燥的描述，我想大家基本可以了解 mixer check cache 的工作原理，但是注意这个是经过简化的最简单版本，我们现在来加上 &lt;code&gt;absence key&lt;/code&gt; 这个极其重要的概念。&lt;/p&gt;
&lt;p&gt;什么叫做 absence key？我们需要继续看回这个图片，注意 mixer adapter使用的属性是a/b/c三个：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201804-istio-mixer-cache-concepts/images/referenced-attributes.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;前面我们列出来的所有场景中，每个输入中都包含有 a/b/c 三个属性，考虑到其他不使用的属性在匹配过程中会被忽略而不影响，我们来将关注点放在 a/b/c 三个属性上。需要考虑这种可能：如果 a/b/c 三个属性不是每次都同时提供，而是少一个或者多个，结果会怎么样？&lt;/p&gt;
&lt;p&gt;此时两层缓存的数据为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;referenced_map = {“k1”: “a,b,c”}&lt;/li&gt;
&lt;li&gt;cache = { “a=1,b=2,c=3”: “true”, “a=1,b=2,c=10”: “false”}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们有一个输入”a=1,b=2,c 不存在，e=0,f=0” ，注意在这个输入中 c 没有出现的。此时肯定缓存无法匹配，需要发送请求到 mixer，我们再假设 mixer adapter 的处理逻辑在输入为”a=1,b=2,c 不存在”的结果为”false”(这样可以和输入为”a=1,b=2,c=3”的结果”true”区分开)。&lt;/p&gt;
&lt;p&gt;设计上有个问题：mixer 该怎么返回引用属性来让 mixer check cache 可以正确的保存这个结果并用于后续的请求？&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;输入&lt;/th&gt;
&lt;th&gt;输出&lt;/th&gt;
&lt;th&gt;引用属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;”a=1,b=2,c=3,e=0,f=0”&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;“a,b,c”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;”a=1,b=2,c 不存在，e=0,f=0”&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;“a,b”还是”a,b,c”？&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关键点：当输入中 c 不存在时，mixer 的 response 中 referenced attribute 应该返回“a,b”还是“a,b,c”？&lt;/p&gt;
&lt;p&gt;先回顾一下 referenced attribute 的概念：按照我们之前介绍的逻辑，referenced attribute 返回的是 mixer adapter 使用到的属性。换句话说，这些属性之外的其他属性，是不会影响 mixer adapter 处理结果的，因此在缓存保存和匹配时都可以忽略。&lt;/p&gt;
&lt;p&gt;首先来看，如果返回“a,b”会如何？这表示 c/e/f 属性可以被忽略，也就是不管 c 取值如何，是否出现，都不影响 check 的结果。即如果”a=1,b=2,c 不存在，e=0,f=0”的结果为 false，按照引用属性为”a,b”进行缓存，后面的”a=1,b=2,c=3,e=0,f=0”的请求，会被忽略 c 属性而命中”a=1,b=2”的缓存结果，导致返回 false。&lt;/p&gt;
&lt;p&gt;因此 mixer check cache 在设计中，引入了 &lt;code&gt;absence key&lt;/code&gt; 的概念，mixer 的 reponse 里面，会明确指出：在输入为”a=1,b=2,c 不存在，e=0,f=0”，输出为 false 这个场景下，referenced attribute 不仅仅包括出现在输入中的 a/b 两个属性，还有 c 这个虽然在输入中没有出现但是 mixer adapter 实际也使用了的属性的（属性 c 没有出现可以视为属性 c 的一个特别值）。这个没出现的属性 c 被称为 &lt;code&gt;absence key&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此时 mixer check cache 在做缓存时，要处理“a/b/c 不存在”这种特别的属性组合，具体步骤为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一层缓存 referenced_map = {“k1”: “a,b,c”} 和输入”a=1,b=2,c 不存在，e=0,f=0”因为 c 的缺席而无法匹配&lt;/li&gt;
&lt;li&gt;发起对 mixer 的请求，获取新的应答，结果为 false，引用属性为”a,b”和 absence key c，我们简写为”a,b,c 不存在”。&lt;/li&gt;
&lt;li&gt;保存结果到第一层缓存 referenced_map 更新为 {“k1”: “a,b,c”, “k2”: “a,b,c 不存在” }&lt;/li&gt;
&lt;li&gt;保存结果到第二层缓存 cache 更新为“a=1,b=2,c=3”: “true”, “a=1,b=2,c=10”: “false”, “a=1,b=2”: “false”}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之后的请求匹配缓存的过程，会稍 is 有不同，体现在第一层缓存的匹配上，注意此时有两个属性组合 {“k1”: “a,b,c”, “k2”: “a,b,c 不存在” }：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是”a=1,b=2,c=3,e=0,f=0”这种a/b/c三个属性都提供的输入，则会匹配到“k1”: “a,b,c”&lt;/li&gt;
&lt;li&gt;如果是”a=1,b=2,c 不存在，e=0,f=0”这种提供了a/b属性而c没有提供的输入，则会匹配到“k2”: “a,b,c 不存在”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二层缓存的匹配方式没有变化，注意由于属性 c 不存在，因此在计算”a=1,b=2,c 不存在，e=0,f=0”这个输入的签名时，只需要计算”a=1,b=2”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要额外指出的是，当有多个属性被 mixer adapter 使用，而出现某个或者某几个属性不存在的场景，是可能有多种的，以上面”a,b,c”三个属性为例，会有”a,b”/“a,c”/“b,c”/“a”/“b”/“c”/“”(即 abc 都不存在)7 种情况，加上”a,b,c”都出现的情况，referenced_map 中会需要保存最多 8 种属性组合。而且，mixer adapter 使用的属性越多，这个数量还会急剧增加。&lt;/p&gt;
&lt;p&gt;备注：这个地方 istio 有一个 bug，在研读代码时发现的，后来提交 fix 给了 istio，后面我会结合代码给大家讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Mixer check Cache 的设计，由于受限于无法得知 mixer adaper 会使用哪些属性，因此在设计上和普通缓存差异极大，必须明确引用属性和 absence key 的概念，才能正确理解 mixer check cache。&lt;/p&gt;
&lt;p&gt;下一节，我们终于可以展开源码了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Istio Mixer Cache 工作原理与源码分析 part1－基本概念</title>
      <link>https://cloudnative.to/blog/istio-mixer-cache-part1-concepts/</link>
      <pubDate>Thu, 07 Jun 2018 19:16:21 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-mixer-cache-part1-concepts/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本系列文章将详细介绍 Istio 中 Mixer Cache 的工作原理，为了避免空谈，将引入广大程序员同学喜闻乐见的源码分析环节，并结合 Mixer 的接口 API，详细展现 Mixer Cache 的各种细节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;预警：Mixer Cache 系列文章除了本文讲述概念比较简单外，其它文章会包含大量复杂和繁琐的细节，包括设计／实现／API 等，适合追求深度的同学。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;阅读本系列文章前，请确保对 Service Mesh 和 Istio 有基本的认知，临时上车的同学请自觉补课：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://skyao.io/publication/service-mesh-next-generation-microservice/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh：下一代微服务&lt;/a&gt;: Service Mesh 介绍&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://skyao.io/publication/istio-introduction/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格新生代-Istio&lt;/a&gt;：Istio 介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外如果对 Mixer 职责和设计不熟悉的同学，请先阅读下文（本文可以理解为是此文的番外篇）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://skyao.io/post/201804-servicemesh-architecture-introspection/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh 架构反思：数据平面和控制平面的界线该如何划定？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这篇文章中，出于对 Istio 性能的担忧和疑虑，我们探讨了 Mixer 的架构设计，工作原理，并猜测了 Mixer 的设计初衷。期间，我们介绍到，为了保证运行时性能，避免每次请求都远程访问 Mixer，Istio 特意为 Mixer 增加了缓存。当时出于篇幅考虑，我们没有深入到缓存的细节，现在将在这个系列文章中就这一点深入展开。&lt;/p&gt;
&lt;p&gt;在展开代码实现细节之前，我们先介绍和 Mixer Cache 相关的基本概念。&lt;/p&gt;
&lt;h2 id=&#34;属性&#34;&gt;属性&lt;/h2&gt;
&lt;p&gt;属性（attribute）是 Istio 中非常一个关键设计，对于 Mixer 更是特别重要，可以说 Mixer 的所有功能都是建立在属性这个核心概念之上。&lt;/p&gt;
&lt;p&gt;搬运一段官方文档的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Istio 使用 &lt;em&gt;属性&lt;/em&gt; 来控制在服务网格中运行的服务的运行时行为。属性是具有名称和类型的元数据片段，用以描述入口和出口流量，以及这些流量所属的环境。Istio 属性携带特定信息片段，例如 API 请求的错误代码，API 请求的延迟或 TCP 连接的原始 IP 地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;属性的形式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;request.path: xyz/abc&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;request.size: 234&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;request.time: 12:34:56.789 04/17/2017&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;source.ip: 192.168.0.1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;target.service: example&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;属性词汇&#34;&gt;属性词汇&lt;/h2&gt;
&lt;p&gt;需要特别强调的是：&lt;strong&gt;Istio 中可以使用的属性是固定的&lt;/strong&gt;，而不是随意设定的，在这一点上，和一般系统中的类似设计有根本性的差异。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每个给定的 Istio 部署有固定的能够理解的属性词汇。这个特定的词汇由当前部署中正在使用的属性生产者集合决定。Istio 中首要的属性生产者是 Envoy，然后特定的 Mixer 适配器和服务也会产生属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些将被 Istio 使用的属性集合，被称为属性词汇，总数大概是 50 个，详细列表可以参看文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/docs/reference/config/mixer/attribute-vocabulary.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Attribute Vocabulary&lt;/a&gt;：来自 Istio 官方文档中的 Reference&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;引用属性&#34;&gt;引用属性&lt;/h2&gt;
&lt;p&gt;引用属性（Referenced Attributes）是在 Mixer Cache 的设计和实现中引入的一个非常特别的概念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;特别提醒：要理解 Mixer Cache，必须深刻理解 Referenced Attritutes。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;什么是引用属性&#34;&gt;什么是引用属性？&lt;/h3&gt;
&lt;p&gt;这个需要从 Envoy 和 Mixer 之间的 Check 方法说起：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Check&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CheckResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 CheckRequest 中，Envoy 会提交所有的 Attribute，而在 CheckResponse 的应答中，PreconditionResult 表示前置条件检查的结果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;status&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://skyao.io/post/201804-istio-mixer-cache-concepts/#google.rpc.Status&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;google.rpc.Status&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;状态码 OK 表示所有前置条件均满足。任何其它状态码表示不是所有的前置条件都满足，并且在 detail 中描述为什么。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;validDuration&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;google.protobuf.Duration&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;时间量，在此期间这个结果可以认为是有效的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;validUseCount&lt;/td&gt;
&lt;td&gt;int32&lt;/td&gt;
&lt;td&gt;可使用的次数，在此期间这个结果可以认为是有效的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;attributes&lt;/td&gt;
&lt;td&gt;CompressedAttributes&lt;/td&gt;
&lt;td&gt;mixer 返回的属性。返回的切确属性集合由 mixer 配置的 adapter 决定。这些属性用于传送新属性，这些新属性是 Mixer 根据输入的属性集合和它的配置派生的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;referencedAttributes&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;ReferencedAttributes&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;在匹配条件并生成结果的过程中使用到的全部属性集合。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;“在匹配条件并生成结果的过程中使用到的全部属性集合”是什么意思呢？我们给个例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假定 envoy 提交的请求中有 5 个属性，”a=1,b=2,c=3,e=0,f=0”&lt;/li&gt;
&lt;li&gt;假定 mixer 中有三个 adapter，每个 adapter 只使用提交属性中的一个属性 a/b/c&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图所示，mixer 会在 CheckResponse 中返回 referencedAttributes 字段，内容为”a,b,c”，以此表明这三个属性是 mixer 的 adapter 在实际的处理过程中使用到的属性：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201804-istio-mixer-cache-concepts/images/referenced-attributes.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Envoy 在收到 CheckResponse 时，就可以从 referencedAttributes 字段的值中得知：原来提交上去的”a=1,b=2,c=3,e=0,f=0”这样一个 5 个属性的集合，实际 adapter 使用到的只有”a,b,c”。&lt;/p&gt;
&lt;h3 id=&#34;引用属性的作用&#34;&gt;引用属性的作用&lt;/h3&gt;
&lt;p&gt;为什么 envoy 要这么关心哪些属性被 adapter 使用了？以至于需要在交互的过程中，特意让 mixer 收集这些使用过的属性并明确在 CheckResponse 中返回给 Envoy？&lt;/p&gt;
&lt;p&gt;这是因为 Mixer Cache 的需要。为了缓存 Mixer 的结果，避免每次请求都发起一次 envoy 对 mixer 的调用，istio 在 envoy 中增加了 mixer cache。而要让缓存工作，则必须在每次请求中想办法得到一个有效的 key，将调用结果作为 value 存放起来。&lt;/p&gt;
&lt;p&gt;现在关键点就来了：key 要如何设计？&lt;/p&gt;
&lt;p&gt;最简单的方式，自然是将请求中所有的属性都作为 key 的组成部分，直接做一个简单的 hash，得到的值作为 key。但是这个方案不可行的地方在于，请求中可能提交的属性大概有二十个上下，有些属性的值变化非常频繁，取值范围也很大，典型如 request.id 这样每次请求都会给出一个全局唯一值。如果直接将所有属性都作为 key 的组成部分，那么很可能每次算出来的 key 都是一个唯一值，这样缓存也就失去意义了。&lt;/p&gt;
&lt;p&gt;因此，不能将全部属性都作为 key，那么，挑选部分属性如何？只计算部分我们判断为有必要被 adapter 使用的属性来计算 key。但是，等等，我们会立马反应出来：这违背了 mixer adapter 的设计原则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;adapter 是独立于 envoy&lt;/li&gt;
&lt;li&gt;envoy 不应该知道有哪些 adapter 的存在&lt;/li&gt;
&lt;li&gt;更不应该知道这些 adapter 使用了哪些属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在 envoy 试图计算 key 时，就面临两难的境地：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;envoy 无法预计哪些属性是 adapter 需要的&lt;/li&gt;
&lt;li&gt;envoy 也不能将所有的属性都作为 key&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那怎么办，mixer cache 可是必须要加的。只能见招拆招了，思路倒是直白，容易理解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;谁可以切确的知道哪些属性被 adapter 使用过？&lt;/p&gt;
&lt;p&gt;当然是被调用过的 adapter 自己了，每个 adapter 在执行完成后，都可以给出自己使用属性集合，mixer 只要做一个简单收集就可以拿到这个信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mixer 知道了，怎么告之 envoy？&lt;/p&gt;
&lt;p&gt;不是有个现成的 response 嘛，将前面收集到的属性集合通过 response 传递回 envoy 就是了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;搞定！现在再重新看回前面给出的这个图片，就很容易理解了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201804-istio-mixer-cache-concepts/images/referenced-attributes.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;下一步&#34;&gt;下一步&lt;/h2&gt;
&lt;p&gt;在介绍完基本概念之后，我们将在下一篇文章中开始讲解 mixer cache 的工作原理，然后在更后面的章节中深入实现细节。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh：重塑微服务市场</title>
      <link>https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/</link>
      <pubDate>Mon, 21 May 2018 21:48:05 +0800</pubDate>
      <guid>https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/</guid>
      <description>&lt;p&gt;今天我们不谈技术，不谈架构，也不谈具体的产品，我们来聊一聊在未来一两年之内，Service Mesh 技术会在微服务相关的市场带来什么样的变化？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbyxih7bj31hc0u0whz_huf12a188f707a4497bfbf2ff2cd149fe4_126841_d385c0c706905433d66d4e07b752bd8e.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbyxih7bj31hc0u0whz_huf12a188f707a4497bfbf2ff2cd149fe4_126841_582dd8bbfc88f93de0d44fe136ee215c.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbyxih7bj31hc0u0whz_huf12a188f707a4497bfbf2ff2cd149fe4_126841_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbyxih7bj31hc0u0whz_huf12a188f707a4497bfbf2ff2cd149fe4_126841_d385c0c706905433d66d4e07b752bd8e.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，我是敖小剑，今天给大家带来的这个主题叫做“Service Mesh：重塑微服务市场”。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzaaju6j31hc0u0n3r_huf911331a762d95e0f775f6c353f0192e_240330_6e81781ac39851560a7541cfd0820d62.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzaaju6j31hc0u0n3r_huf911331a762d95e0f775f6c353f0192e_240330_9558c2c85976b137fcd936ef42c4e893.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzaaju6j31hc0u0n3r_huf911331a762d95e0f775f6c353f0192e_240330_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzaaju6j31hc0u0n3r_huf911331a762d95e0f775f6c353f0192e_240330_6e81781ac39851560a7541cfd0820d62.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;刚才主持人张亮提到说，过去一年 Service Mesh 成为一个热词。基本上，在国内的话，我差不多是 Service Mesh 最早的布道师。可能如果大家之前有看相关的资料的话，应该会看到一些我的资料。我先后做过几场的演讲，做过一些技术的分享，也写过很多文章。但在此之前，这些内容可能更多的都是集中在技术领域。那今天我们会特殊一点，我们今天不谈详细的技术，不谈具体的架构，我们也不谈具体的产品。后面的这些名词，Istio/Conduit/Envoy/Linkerd/Nginmesh，这些词可能听过，可能没听过，但没问题，今天这些我们统统都不讲。我们今天要讲另外一个东西：我们会聊一聊在未来一两年之内，Service Mesh 技术会在微服务相关的市场带来什么样的变化？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzn8375j31hc0u0dj5_hu0db1683a7becf2d159ae9c199f65d3b8_121670_5464e3ba5b10bf7374c014629b0757c6.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzn8375j31hc0u0dj5_hu0db1683a7becf2d159ae9c199f65d3b8_121670_3c3a5bd28d96823c82125828bf02c9ba.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzn8375j31hc0u0dj5_hu0db1683a7becf2d159ae9c199f65d3b8_121670_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzn8375j31hc0u0dj5_hu0db1683a7becf2d159ae9c199f65d3b8_121670_5464e3ba5b10bf7374c014629b0757c6.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;主要内容会是三大块：首先我们会看一下目前微服务的市场的一些现状，然后接下来我们会探讨一下它的商业模式，在第三块，我们会重点讲一下 Service Mesh 对 PaaS 的意义。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzsa5poj31hc0u0mzc_hue002d75972d275eb9e923d41ee519292_76054_7e75f2f13cf9aa81309673aff00db897.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzsa5poj31hc0u0mzc_hue002d75972d275eb9e923d41ee519292_76054_21bfa2295ef52a4cfe05bf3b0c203956.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzsa5poj31hc0u0mzc_hue002d75972d275eb9e923d41ee519292_76054_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzsa5poj31hc0u0mzc_hue002d75972d275eb9e923d41ee519292_76054_7e75f2f13cf9aa81309673aff00db897.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，第一块，微服务的现状。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzy0bbnj31hc0u0jxf_hubb5ed0c900a91ec0bb14eda7ac23be14_221540_9b75b6682e01f503632d73a53a404460.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzy0bbnj31hc0u0jxf_hubb5ed0c900a91ec0bb14eda7ac23be14_221540_8096aefafcb289224d59e796bd05c96c.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzy0bbnj31hc0u0jxf_hubb5ed0c900a91ec0bb14eda7ac23be14_221540_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzy0bbnj31hc0u0jxf_hubb5ed0c900a91ec0bb14eda7ac23be14_221540_9b75b6682e01f503632d73a53a404460.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们快速过一下。&lt;/p&gt;
&lt;p&gt;目前微服务的背景是这样，首先目前在市场上是有这么一个潮流：传统企业会慢慢向互联网技术转型，其中微服务和容器是这个技术转型的核心。这个市场比较大，大家也都看好这样一个方向，这是大的时代背景。&lt;/p&gt;
&lt;p&gt;简单回顾一下，微服务在国内，基本上是在 2015 年开始兴起。2016/2017 这两年在国内的基本上就是大热了。我们能看到的是，未来这一两年之内，这个热潮应该继续延续。主要还是因为微服务这个技术是用于解决实际问题的，另外它也同样适用于各种企业。这样的大背景之下，我们来看现在使用微服务的客户现状。&lt;/p&gt;
&lt;p&gt;实际上，我们之前在谈到 Service Mesh 技术为什么演进的时候，我们有提到，在 Service Mesh 之前，第一代的侵入式微服务框架，它的门槛相对稍微高一点，典型的代表的是 Dubbo，Spring Cloud。对于传统企业来说，传统企业其实缺乏一些互联网的技术基因，这些包括技术，人才，经验，还有开发流程。在实际的市场当中，我们可以看到，大多数企业，虽然他们试图在微服务方面有一些转变，但实际上，在落地的时候还是会遇到一些问题。目前第二代的 Service Mesh 技术其实主要是冲着解决这个问题来的。他的思路在于要想办法用 Service Mesh 这样一个技术来降低微服务落地的门槛，最后帮助传统企业完成整个技术转型。这是目前大的背景和现状，我们下面来详细聊一下在这个背景当中一些具体的东西。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0abo78j31hc0u0q8m_hu8c69c7ec3df3f9a4e1096c2fa71b515d_210472_ab73998c5a34b314f4b57e50820f1b6e.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0abo78j31hc0u0q8m_hu8c69c7ec3df3f9a4e1096c2fa71b515d_210472_2712a83d78d86300cccd005d709dec40.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0abo78j31hc0u0q8m_hu8c69c7ec3df3f9a4e1096c2fa71b515d_210472_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0abo78j31hc0u0q8m_hu8c69c7ec3df3f9a4e1096c2fa71b515d_210472_ab73998c5a34b314f4b57e50820f1b6e.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务的一个痛点：落地很难。&lt;/p&gt;
&lt;p&gt;在这个地方我放了一个冰山图，左边的有一个坐标，就是说要实现好一个微服务，技术要求大概是一个什么样子，我这边简单的画了一下。&lt;/p&gt;
&lt;p&gt;实际上我们可以看到，就是说如果以 60 分为及格线的话，那很遗憾的是，虽然这个冰山我们看它的体积非常的巨大，这个市场规模是非常大的，但实际上到目前真正能够落地的，能够浮在水面上的，其实并不多。这个问题在哪里？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为它落地太难了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0e9sr0j31hc0u011b_hud5e287273f163a628070789e1935afea_309934_9a3eb9b675731add0cf3ae9783de2447.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0e9sr0j31hc0u011b_hud5e287273f163a628070789e1935afea_309934_ed8b1b58c63c92640216e2e54d69a9d7.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0e9sr0j31hc0u011b_hud5e287273f163a628070789e1935afea_309934_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0e9sr0j31hc0u011b_hud5e287273f163a628070789e1935afea_309934_9a3eb9b675731add0cf3ae9783de2447.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;落地难的原因是门槛比较高。我们简单的罗列了一下，比如说典型的 Spring Cloud，他的技术栈，我们看到的这些特性的列表。大家可以看到非常多的东西，左边这个地方 Spring Cloud 的各个组件。大家如果用过 Spring Cloud 的都会比较熟悉。当然两边并不是严格对称，这只是一个示意。&lt;/p&gt;
&lt;p&gt;实际上在这样的一个巨大的特性列表和组件列表当中，比较头疼的是：如果你是一个新人的话，你要第一时间掌握的东西其实是非常多的。Hello Would 都很简单，但是你真的要掌握，这些东西是要一个一个吃透的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc25rkv7j31hc0u07d4_hu07594c2c48551894843a6943f320ec53_334261_22db7ff06ee9d542e95d931b66b1492d.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc25rkv7j31hc0u07d4_hu07594c2c48551894843a6943f320ec53_334261_fb4ec8b43838b669bfce4ab692e18a60.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc25rkv7j31hc0u07d4_hu07594c2c48551894843a6943f320ec53_334261_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc25rkv7j31hc0u07d4_hu07594c2c48551894843a6943f320ec53_334261_22db7ff06ee9d542e95d931b66b1492d.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为什么这个门槛会这么高？在这里面要指出一点，就是说：解决问题的思路有点不太对。&lt;/p&gt;
&lt;p&gt;我们先看左边这个图，我们现在如果是想要一辆汽车，那 OK，可以像左边这个图一样。我们看到一辆汽车分解之后是会有多少个零件？我们现在通过类库的方式，实际去组装辆汽车，我可以给你不同的组件，不同的类库，然后告诉你这个是发动机，这个是轮胎，这个是刹车……这确实会比自己从头到尾，从每一个螺丝钉开始制造，去组装整车要轻松的多，比如说至少有个成熟的发动机，至少方向盘可以不用自己做了。但是实际上，对用户而言，必须要对整体有非常深的认识：你知道每个组件能做什么，选择合适的组件，并把他们并拢起来。这样对一个系统的了解是需要比较深的。&lt;/p&gt;
&lt;p&gt;我们再看看右边：你组装出来的东西是什么样子？最上面这个跑车可能是所有人的梦想，对吧？但实际当中，不同的用户，他的能力是不一样的，他的投入也不一样。那他最终得到产出品，很有可能不是上面的这个让大家心动的跑车。很可能只是一个普通的大众，只能只一个 QQ，甚至，其实最后一张图非常凄惨：不知道出来的会是什么，很可能是接近无法使用的产品。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc62tu0aj31hc0u0111_huac6d32309274eeae0712ec1c37f020b2_299135_97ae7f63e9b1cda2254eafc24bfbc97f.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc62tu0aj31hc0u0111_huac6d32309274eeae0712ec1c37f020b2_299135_38e59a458f5d812608e378ea76ff0b25.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc62tu0aj31hc0u0111_huac6d32309274eeae0712ec1c37f020b2_299135_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc62tu0aj31hc0u0111_huac6d32309274eeae0712ec1c37f020b2_299135_97ae7f63e9b1cda2254eafc24bfbc97f.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在下一代的 Service Mesh 当中，会用其他的方式来完成这个事情。&lt;/p&gt;
&lt;p&gt;首先通过智能代理的方式，屏蔽掉大家对底层各个组件的认知。Service Mesh 会通过直接使用 Sidecar 的方式来完成这些功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc69bcrwj31hc0u0gsm_hufe4acf112714ef8e57a8e67e69e7b048_264478_938f00abef9ef16801227863ca962ca0.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc69bcrwj31hc0u0gsm_hufe4acf112714ef8e57a8e67e69e7b048_264478_7853c7946750829183d656936dedad89.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc69bcrwj31hc0u0gsm_hufe4acf112714ef8e57a8e67e69e7b048_264478_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc69bcrwj31hc0u0gsm_hufe4acf112714ef8e57a8e67e69e7b048_264478_938f00abef9ef16801227863ca962ca0.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从思路上说，在这个时候，最大的事情是&lt;strong&gt;调整战略&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们回到需求：客户用这些东西的需求是什么？它的目标是把这个车造出来，但造出这个车的下一步，是开着它上路，去该去的地方。造车，并不是他的最终的目标，对吧？我们回到现实的例子，大家学习 Spring Cloud 的目标是仅仅掌握 Spring Cloud 吗？我们说到，做微服务的实现，是把我们体系架构在微服务之上，然后让整个体系可以更快更好的运转。所以呢，客户真正的需求是用微服务做开发，做应用开发，应用是它的核心价值。这种情况下，对于微服务系统本身的掌握，要求其实不应该那么高。&lt;/p&gt;
&lt;p&gt;比如说我随便举个例子，我相信在座的各位，很多同学开过车对吧？你可能开车的驾驶技术很高，但是如果我们现在，举个例子说：我给你一堆组件给你组，你能不能组装成一辆车？我相信在坐的同学应该没有几个能办得到。&lt;/p&gt;
&lt;p&gt;所以，在这个地方，在 Service Mesh 里面，最重要的是：我们会做一个思路的转变。我们不再以组件的方式给客户提供服务，而且直接给客户成品，而且是精心打磨的成品。这个大家梦想中的跑车，开箱即用，直接呈现在客户面前。它非常的方便，可以非常快速地使用它。他的品质是经过打磨好之后的，然后客户只需要知道该怎么驾驶就好了。&lt;/p&gt;
&lt;p&gt;这是整个 Mesh 的思路。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6exb4jj31hc0u0gru_hu2d17b8c169582ddfb234062b3296c8b7_229063_b019c3295881385349797e87c4701d0d.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6exb4jj31hc0u0gru_hu2d17b8c169582ddfb234062b3296c8b7_229063_f953ad550ae8569f909a3a82dfea9c19.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6exb4jj31hc0u0gru_hu2d17b8c169582ddfb234062b3296c8b7_229063_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6exb4jj31hc0u0gru_hu2d17b8c169582ddfb234062b3296c8b7_229063_b019c3295881385349797e87c4701d0d.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个思路背后，代表了一个重要的核心理念。我们会看到，第一代的微服务将当时微服务开发的门槛降低了，在第一代微服务之前，你需要一切从零开始，你需要从每一行代码开始。换句话说，在你造整车的时候，你需要从每个螺丝钉开始，这必然是很难的。&lt;/p&gt;
&lt;p&gt;第一代微服务至少提供了一些成熟的组件，比如说发动机 OK 啦，这个门槛它降低了一部分。第二代微服务，我们是希望在这个基础上，将门槛进一步降低。60 分不再是及格线，我们希望将它降成 30 分。这个目标如果能够达成，对于期望用微服务来做技术革新的企业来说，他这个时候可以更容易地落地。大家可以想象，一场考试，及格线是 60 分和及格线是 30 分，这个时候及格率会发生质的变化，这个时候能释放出来的市场规模也会远远大于前者。&lt;/p&gt;
&lt;p&gt;OK，这个第一阶段我们讲好。&lt;/p&gt;
&lt;p&gt;嗯，在这个地方，我想问大家一个问题：在座的各位，有没有哪一位所在的企业是真正的将微服务落地在一线生产上的？张亮兄？OK，你这个没问题。还有没有哪一位？OK？好，这个属于冰山水面上的部分。后面还有没有其他同学？有没有同学做过尝试的？就是在你们的实际的生产当中，实际落地微服务的架构，OK，这边有些同学。&lt;/p&gt;
&lt;p&gt;好，实际上调查的和我们预期的还是有点像的。真正的大家能够把微服务落地的，就是冰山上面露出来的一小部分。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6nwbacj31hc0u0gnw_hue002d75972d275eb9e923d41ee519292_80648_c1dff60eb0769ba1c73fce7d417b0be4.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6nwbacj31hc0u0gnw_hue002d75972d275eb9e923d41ee519292_80648_e154248156bfe571367d25e40419f532.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6nwbacj31hc0u0gnw_hue002d75972d275eb9e923d41ee519292_80648_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6nwbacj31hc0u0gnw_hue002d75972d275eb9e923d41ee519292_80648_c1dff60eb0769ba1c73fce7d417b0be4.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，我们进行第二个探讨：Service Mesh 和微服务市场模式的探讨。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6w3auoj31hc0u0gor_hu1ac51915ac70a3ef6d24ef2562e551bc_109109_4f44b18be666100320a9c79f2c177f89.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6w3auoj31hc0u0gor_hu1ac51915ac70a3ef6d24ef2562e551bc_109109_f5bfb8020d2a546a82c5f3612097343f.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6w3auoj31hc0u0gor_hu1ac51915ac70a3ef6d24ef2562e551bc_109109_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6w3auoj31hc0u0gor_hu1ac51915ac70a3ef6d24ef2562e551bc_109109_4f44b18be666100320a9c79f2c177f89.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我先抛出一个问题：假设现在有一个公司，他要推微服务，但它确实之前没有这样的经验，它可能也缺乏这样的人才，所以在技术能力上它会有些欠缺。那这个时候怎么办？&lt;/p&gt;
&lt;p&gt;哪位同学能给我想一个办法？或者说如果现在你的领导和你说：我们要上微服务了，有什么办法？这个很现实的，领导明天就你定方案，然后你发现你的团队好像大家都没玩过，也都不会。请你告诉我怎么办？有没有哪个同学给我一个想法？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：现场互动，有同学回答说，需要领导重视。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，非常重视，我们明天就上！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：现场互动，有同学继续说，招人，外包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;恩，招人和外包，还有别的吗？OK，好，这位同学至少已经找到了明天早上开始推行微服务的一些方案了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc72nnp5j31hc0u0n1e_hue6b72015113c6d605dd1d1ec8a4d2c54_153088_401e4b716fb639816ef9f031386ca667.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc72nnp5j31hc0u0n1e_hue6b72015113c6d605dd1d1ec8a4d2c54_153088_4347edb31eaeb96980b44964e6190df1.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc72nnp5j31hc0u0n1e_hue6b72015113c6d605dd1d1ec8a4d2c54_153088_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc72nnp5j31hc0u0n1e_hue6b72015113c6d605dd1d1ec8a4d2c54_153088_401e4b716fb639816ef9f031386ca667.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，我们简单过一下，刚才这个同学这里有一个比较有意思的地方：招人。这个有个比较有意思的东西给大家轻松一下。&lt;/p&gt;
&lt;p&gt;这个是我个人的玩笑，用于区分互联网企业的一个简单方式：当发现有些事情自己不会做，也没有合适的人手，没能力的时候怎么办？一般互联网公司的习惯都是：挖！没人是吧，看一下业界谁会，挖！挖不过来是吧，薪水乘 2？OK，互联网公司一般习惯这么干。但是传统企业一般不喜欢这么干，这里还包括伪装成互联网，大家应该懂这个意思吧？嗯，他的业务有可能是互联网业务，但他的工作方式，整个运作可能是传统企业的方式。但它的业务模式可能是互联网产品。这种企业的通常情况下它的习惯是买！拿钱去买，但他能买到什么？&lt;/p&gt;
&lt;p&gt;当然这是个玩笑，但是有时候还是挺准确的，大家可以私底下去验证一下。&lt;/p&gt;
&lt;p&gt;那我们现在说说，能买什么？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc78y0hwj31hc0u0tcp_hucf7970a9512a5a9a5ca06a00956bc0fc_143185_d92c19743c544cd87f901f8205744bd5.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc78y0hwj31hc0u0tcp_hucf7970a9512a5a9a5ca06a00956bc0fc_143185_1771a04a760d1e374f0e23d317ba952b.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc78y0hwj31hc0u0tcp_hucf7970a9512a5a9a5ca06a00956bc0fc_143185_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc78y0hwj31hc0u0tcp_hucf7970a9512a5a9a5ca06a00956bc0fc_143185_d92c19743c544cd87f901f8205744bd5.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个市场，能为微服务的开发提供什么样的产品，什么样的服务吗？刚才同学说了一个：外包。是的，这个很正常。确实有非常之多的外包，但还有两个，一个是咨询，教你怎么做；一个是培训，包括出书也是一种培训，现场培训是另一种。还有一种就是卖产品，微服务相关的各种产品。整个市场会提供这些产品，但我们会注意到：前三者是不一样的。咨询、培训、外包本质上是要提升客户的能力，就是让你的能力更强。如果大家记得前面的那条线的话，现在就是在你考试的时候，让你的考试能力更强。产品是帮你稍微降低一下门槛。比如我告诉你，第五道题的答案是 B，你填上就好了。最终达到大家及格的目标，至少起码及格。&lt;/p&gt;
&lt;p&gt;整个市场提供的产品，大概是这个样子。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc7ggf0vj31hc0u044g_hu79bf5715fc531ec3613850e194bbcb9a_221363_7a3f2e9b2f59798b9a3ecddb91a42c82.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc7ggf0vj31hc0u044g_hu79bf5715fc531ec3613850e194bbcb9a_221363_bd44c62e9e16dc7dab0ce2cf181066ab.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc7ggf0vj31hc0u044g_hu79bf5715fc531ec3613850e194bbcb9a_221363_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc7ggf0vj31hc0u044g_hu79bf5715fc531ec3613850e194bbcb9a_221363_7a3f2e9b2f59798b9a3ecddb91a42c82.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们聊另外一个话题，可能更有意思：为什么大家想用微服务？尤其在参加技术大会之后。平时大家苦日子过习惯了，后来某人参加了某个技术大会之后，回来就觉得：平时这苦日子过得有点惨。旁边的这个是麦粒，不知道大家有没有吃过？晒干之后脱皮直接煮着可以吃的，甚至也可以生吃。然后是非常难吃的，很难下咽，但古代，我们的祖先原来就是这么吃下来的。后来发现参加了一场大会之后，发现这个受不了，为什么呢？发现别人吃的是右边的东西。&lt;/p&gt;
&lt;p&gt;这个叫什么？不患贫而患不均，对吧？左边这个其实也不是过不下去，但是当你看到右边之后，通常一般人都受不了了。别人告诉你说要去皮，你要磨成粉，之后你要和面，发酵，蒸，然后就有这个吃了。大家一看，开完大会之后就发现，对啊，左边这个麦粒确实没必要这么吃，对不对？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9igauij31hc0u0ag1_huab72fd28eee2a625f206e058014af0bc_220417_577268a7a945feb62b8a8935b3bb1828.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9igauij31hc0u0ag1_huab72fd28eee2a625f206e058014af0bc_220417_44252b375589d63cef3f551f36bfec26.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9igauij31hc0u0ag1_huab72fd28eee2a625f206e058014af0bc_220417_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9igauij31hc0u0ag1_huab72fd28eee2a625f206e058014af0bc_220417_577268a7a945feb62b8a8935b3bb1828.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们现在回到刚才的这个话题：咨询、培训、外包的本质是什么？&lt;/p&gt;
&lt;p&gt;咨询是告诉你，看个例子，咨询告诉你什么品种的小麦口感好，或者说告诉你微服务 12 要素。嗯，然后告诉你，Spring Cloud 是个不错的选择。&lt;/p&gt;
&lt;p&gt;培训是什么？告诉你，这个小麦怎么种，这个馒头要怎么蒸，对吧？接下来告诉你，什么三个星期或者三天快速掌握 Spring Cloud。&lt;/p&gt;
&lt;p&gt;外包是什么？就是这些东西，做咨询了，给方案了，也做了一些培训了，但是还是搞不定。可能技术不够，也可能人力不足。那怎么办？上门帮你。对吧？我直接帮你蒸一屉馒头，客户就会问了：今天搞定了，明天怎么办，是吧？这个问题肯定是现成的，今年的这个目标搞定了，但是馒头明天还是想吃，不想明天再搞回去的，是吧？OK，好开心的告诉客户，二期合同，签二期合同，轻松帮你搞定。&lt;/p&gt;
&lt;p&gt;那我们可以看到说：这三个本质是什么？是客户变得更强大，对吧？咨询、培训是让你变得更强大的；外包，让你变得假装更强大：其实没这个能力，但是在别人帮助的情况下，可以在短时间之内达到这个能力。&lt;/p&gt;
&lt;p&gt;但是别忘了：整个事情还是在客户这边的，这个还是自己的事情，如果能力不够，明天的事情还是做不好。今天让别人帮忙蒸好了馒头，明天没人蒸的话，还是得回去啃麦粒。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9nspdhj31hc0u07ae_hufacfce059286e7b069a53eca68a1ce50_226051_2126c3a62fe358fcc796c3a2bf06cee7.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9nspdhj31hc0u07ae_hufacfce059286e7b069a53eca68a1ce50_226051_82407a4aaa3edd5a39a6d342b17e86f9.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9nspdhj31hc0u07ae_hufacfce059286e7b069a53eca68a1ce50_226051_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9nspdhj31hc0u07ae_hufacfce059286e7b069a53eca68a1ce50_226051_2126c3a62fe358fcc796c3a2bf06cee7.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然后我们可以看到，买到的产品也是不同层次的。&lt;/p&gt;
&lt;p&gt;我们做个简单的类比，初级产品是提供一些原材料，不能直接达到目标。但是不管如何，它会给你基石。至少在有小麦的情况下，还有机会煮一煮，对吧？类比各种类库，给一些基本的类库，至少还有机会不要从零开始。当肚子饿的时候，你说我没有吃的，我现在今天开始种地，对吧？等到半年之后，开始有收成，这不现实。所以，不管如何，初期产品至少让你有一个比较好的起点。&lt;/p&gt;
&lt;p&gt;再往后，中级的产品，比如说面粉，这个时候离馒头已经不是很遥远了。但是你还是需要一些比较重要的工具，类比就是各种的框架。基本上有面粉之后，起码不会饿死对吧？不管做的有多难吃。但是呢，有多好吃就是另外一回事，后面还有很多工序需要自己去完成。&lt;/p&gt;
&lt;p&gt;相比之下，大部分同学可能还会选择：这个自己做的不太好，我们还是选最高级，开箱即用。直接下单，那边马上给你端上一笼馒头，马上就搞定。这肯定是比前面自己种地或者买面粉要快的多，类比的话就是 Service Mesh。在这里我加了一个问号，后面大家会了解这个问号是什么。&lt;/p&gt;
&lt;p&gt;实际上，在市场上能买到的产品，是不同层次的。市场的规律通常是这样，在满足需求的前提之下，最初期的产品都会在第一时间出现，然后逐渐的开始演变，开始向高级产品来演变。对于微服务市场来说，现在的高级产品就是 Service Mesh。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9w0q0oj31hc0u0q87_hu231ea75666469b6057eb0fc3cacd67a2_191837_18913e02a84fc5e8c6bb771364eaa1d5.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9w0q0oj31hc0u0q87_hu231ea75666469b6057eb0fc3cacd67a2_191837_1345d50eab8d647abc76335c22674d5b.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9w0q0oj31hc0u0q87_hu231ea75666469b6057eb0fc3cacd67a2_191837_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9w0q0oj31hc0u0q87_hu231ea75666469b6057eb0fc3cacd67a2_191837_18913e02a84fc5e8c6bb771364eaa1d5.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们回到第二个痛点。前面我们说微服务落地的重点在哪里，第一个是门槛，微服务的门槛高实在是有点高。这里我们看第二个痛点：微服务的市场模式是不太对的。&lt;/p&gt;
&lt;p&gt;我们现在细细看，就是说，咨询、培训、外包，对于市场来说，有能力提供微服务相关服务的这些公司，大多数是技术型的公司。不管是创业公司，还是大一点像阿里腾讯这种比较大的。这些公司有个问题：它其实不是太擅长咨询培训外包的，毕竟这个不是它的主业。同样在这几个领域当中，市场存在大量的竞争对手，比如咨询公司，大家熟悉的，培训公司，还有各种外包。这些对于做技术型的公司来说通常不擅长，而且即使他可以来做，也会占用大量的人手。一旦占用人手的话，就没有能力去开发产品。&lt;/p&gt;
&lt;p&gt;我们看第四个，会发现：这个产品麻烦了。客户的资金，他的预算，一般来说是有固定的。当他的预算大部分投入到咨询、培训和外包之后，还有多少钱来买产品？他不买产品，技术公司就没有办法得到利润，没有利润，就没有足够的财力去开发更好的产品。&lt;/p&gt;
&lt;p&gt;没有更好的产品，就不能靠产品解决问题。&lt;/p&gt;
&lt;p&gt;那客户就要回答说：产品不能解决我的问题，我就继续回到咨询、培训、外包的这个主流上来。这个地方形成一个很要命的恶性循坏。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca471y2j31hc0u0wk5_hu669f1bca27017fca8952675f9e8e688f_209041_f6f79f880a2b9d175349c9f40384295e.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca471y2j31hc0u0wk5_hu669f1bca27017fca8952675f9e8e688f_209041_1d444724af535ad3dca1662de909fddd.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca471y2j31hc0u0wk5_hu669f1bca27017fca8952675f9e8e688f_209041_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca471y2j31hc0u0wk5_hu669f1bca27017fca8952675f9e8e688f_209041_f6f79f880a2b9d175349c9f40384295e.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在我之前的经历当中，我是在这个市场的乙方公司做过事情。我们当时其实是面临一个比较难受的事情，就是说：如何在产品和项目之间平衡。我相信这对于所有在微服务市场提供服务的乙方公司来说，都是一个非常非常现实的话题。&lt;/p&gt;
&lt;p&gt;产品是个什么概念？大家最熟悉的，左边这个图，office 系列，或者说它背后的 windows 操作系统。差不多是过去十几年，软件行业我感觉应该是最成功的所谓”产品”。产品的概念：难度非常大。你看 windows、office 出了这么多年，有谁超过了？然后它的周期非常长，开发一个产品，好几年。几千个人，甚至更多的人堆在上面。它的风险非常大，一次投资就是几亿几十亿。然后来钱其实挺慢的，因为他要慢慢铺开。这个产品铺上去可能几年之后陆陆续续回本。但是，有个极大的优点：非常低成本的大规模复制。Office 2019，它的第一份拷贝成本可能高到几十亿美元，但它的第二份拷贝的成本是多少？第两千份拷贝的成本是多少？第 1000 万份，它的成本又是多少？&lt;/p&gt;
&lt;p&gt;所以我们就发现针对于技术公司而言，对于大部分技术公司而言，其实最理想的是做产品，对吧？产品做好了，然后再卖给更多的客户。&lt;/p&gt;
&lt;p&gt;但是很多时候，事情往往没这么简单。很多时候我们遇到一个事情：会有一个“项目”的概念。有个客户，他有一大堆的东西，这些东西无法形成一个通用的需求，也没办法由简单的产品去覆盖它。然后可能就会用咨询、培训加外包的方式帮他搞定。OK，好处是说有一单是一单，客户的需求是摆在面前的，风险很小，基本上技术上肯定可以搞定，半年一年之后就能把这个项目的钱结回来。但是它的缺点是：陷入卖人头的境地。因为项目的可重复性是比较差的，当你接到第二个项目的时候，你会发现它其实需要重头来过，很难把两个项目之间的东西去积累成产品。&lt;/p&gt;
&lt;p&gt;我相信在座的如果有做乙方的，包括做内部乙方的，给其他人提供服务、产品来解决问题时，应该都会遇到这两个问题。这个平衡是相当麻烦。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca9k9nuj31hc0u0ter_hu30a3fa5d28c42e12d05d0b959a05bbbd_218149_5a4979cd6d7946d9c6c4b39af149cd31.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca9k9nuj31hc0u0ter_hu30a3fa5d28c42e12d05d0b959a05bbbd_218149_6a374df205860736dbf3cccb23a2994e.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca9k9nuj31hc0u0ter_hu30a3fa5d28c42e12d05d0b959a05bbbd_218149_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca9k9nuj31hc0u0ter_hu30a3fa5d28c42e12d05d0b959a05bbbd_218149_5a4979cd6d7946d9c6c4b39af149cd31.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;路在哪里？Service Mesh 给出几个答案。&lt;/p&gt;
&lt;p&gt;左边这个是在之前曾经做过的分享，从技术上来说，因为我们今天没讲技术，所以没有提过。从技术上说，Service Mesh 提供了一个方案，就是说将整个服务间通讯的解决方式，整个技术栈全部下移。从应用当中下移到底层的基础设施，通过加强基础设施的方式提供一个统一的解决方案，这是从技术的角度。&lt;/p&gt;
&lt;p&gt;在前面我们提到，从理念的角度上说，Service Mesh 是希望将微服务市场的门槛降低，然后形成整个市场的规模增大。&lt;/p&gt;
&lt;p&gt;我们在前面也提供了一个产品的思路：解决问题的思路要发生变化。要实现产品的升级，不能卖初级产品，要想办法提供最终的成型的成熟的产品。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaj01bxj31hc0u0wiw_hu9cabfe809e2db4cd448ff72a0e9d5fef_159839_df97ca1933a97c8cf5dabe5b0691ae11.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaj01bxj31hc0u0wiw_hu9cabfe809e2db4cd448ff72a0e9d5fef_159839_487ac4f65aa41a340e46ae18f7e22287.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaj01bxj31hc0u0wiw_hu9cabfe809e2db4cd448ff72a0e9d5fef_159839_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaj01bxj31hc0u0wiw_hu9cabfe809e2db4cd448ff72a0e9d5fef_159839_df97ca1933a97c8cf5dabe5b0691ae11.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，这是 Service Mesh 在这个时候非常重要的一件事情，就是：可以重建微服务市场的市场模式。&lt;/p&gt;
&lt;p&gt;将整个模式牵回到一个正统的&lt;strong&gt;重产品重技术&lt;/strong&gt;的途径，也就是说，我们会通过提供更好的产品，然后这个产品可以更多的更普遍地满足客户的需求，从而降低客户的门槛。当客户入门的门槛降低的时候，他对于咨询、培训、外包的需求就会降低。那他会有更多的资金预算投到产品的采购当中，这样会让提供产品的技术公司有更多的利润，然后继续加强产品，形成这样一个良性的循环。这是 Service Mesh 在整个微服务市场当中非常非常重要的一环，必须要让原来的恶性循环的场景开始向现在这样一个良性循环做转变。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaq8jkgj31hc0u0gr9_hu795f97e5d9772ecddbdb1f07616e3875_207177_ff5195e4d5c82fbaf8dc7a7e793ec2b0.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaq8jkgj31hc0u0gr9_hu795f97e5d9772ecddbdb1f07616e3875_207177_e5a0677a52e790211ad9fce605f1d778.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaq8jkgj31hc0u0gr9_hu795f97e5d9772ecddbdb1f07616e3875_207177_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaq8jkgj31hc0u0gr9_hu795f97e5d9772ecddbdb1f07616e3875_207177_ff5195e4d5c82fbaf8dc7a7e793ec2b0.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们来详细的过一下，Service Mesh 对于微服务市场的核心价值，主要是四块：&lt;/p&gt;
&lt;p&gt;第一是对使用者更加的友好，体现在技术栈下移，降低了整个微服务入门的门槛。最终达到扩大市场规模的目标，这主要是体现它的易用性上。&lt;/p&gt;
&lt;p&gt;然后，第二个核心价值体现在标准。从类库，到框架，再到平台，整个生态是越来越大的。&lt;/p&gt;
&lt;p&gt;而一旦到了 Service Mesh 这个领域，就不会拘泥于细节，而是通盘考虑，考虑生态如何做。整个体系，所有组件，这些组件之间的交互是什么？这有个好处，它会自然而然的去统一，去集中化这些模块，然后在上面再制定一个标准。&lt;/p&gt;
&lt;p&gt;第三个价值在于 Service Mesh 提供专业化的解决方案。大家常说的，“专业的人做专业的事情”。在这个领域，微服务之间的通讯，这是一个专业度非常高的领域，这个领域应该出现工业级成熟度的制成品。而不应该让每一家公司都以小作坊的方式去各自完成。我们期待的是一个工业级的产品，它应该有非常非常高的完成度，功能齐全，以此来提升业界的整体水准。随便举个例子，今天大家能拿到的任何一个哪怕微不足道的小螺丝钉。你就想想，如果用人工的方式去做，他们开发成本会有多大？工业制成品的概念就是在这个地方，通过大量的标准化，通过工业制造，可以做到非常好的精度，同时成本降到极低。&lt;/p&gt;
&lt;p&gt;这在整个市场上体现为规模效应。为什么？如果一天的时间只做一个螺丝，这个成本非常的高，如果开一台机器，一天制造了 100 万个螺丝，成本在哪里？所以，在这个点上有个非常重要的事情，就是：一定要可以低成本的大面积的使用。&lt;/p&gt;
&lt;p&gt;如果你的螺丝不标准，你在某个地方一定要需要一个特殊的螺丝，这个螺丝的规格跟其他都不相同，一定要手工制作。那这种情况下，你是没有办法去降低成本。你只有通过前面的易用性，标准，专业来实现。这些事情最终的目标，都是让这个产品最终实现可以低成本的大面积使用。这个时候可以做到一个事情，就是说你最终总的利润可以增加，但是你的单价是降低的。&lt;/p&gt;
&lt;p&gt;Service Mesh 这样的一个技术，对于市场有一个比较好的事情，是说它适合&lt;strong&gt;把规模做大&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb1l92jj31hc0u0wgu_hu4a11ff2619bc86342b84cf54860add3c_83654_f8b5b57200ab293cbd3ed36efc36970b.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb1l92jj31hc0u0wgu_hu4a11ff2619bc86342b84cf54860add3c_83654_c992a0ff6c451d8d6a7f2c2c6ba5543e.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb1l92jj31hc0u0wgu_hu4a11ff2619bc86342b84cf54860add3c_83654_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb1l92jj31hc0u0wgu_hu4a11ff2619bc86342b84cf54860add3c_83654_f8b5b57200ab293cbd3ed36efc36970b.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，我们探讨了 service mesh 对微服务市场模式的重新塑造。我们现在进入第三段，Service Mesh 对于 PaaS 平台的价值和意义。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb7blbrj31hc0u0dlz_hu4477cd74a1eab8b351a64730568e40b8_225126_1e5c2d85254df88b22ffd394e0b9fc75.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb7blbrj31hc0u0dlz_hu4477cd74a1eab8b351a64730568e40b8_225126_c661a076793e945f8571508e1addac0e.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb7blbrj31hc0u0dlz_hu4477cd74a1eab8b351a64730568e40b8_225126_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb7blbrj31hc0u0dlz_hu4477cd74a1eab8b351a64730568e40b8_225126_1e5c2d85254df88b22ffd394e0b9fc75.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在开始这个话题之前，我们先简单过一下，PaaS 的核心价值是什么？它跟 Service Mesh 又有什么相通的地方？大家记得前面列了四个东西，第一个是易用，对使用者友好，大家会发现 PaaS 提供的价值也是如此，PaaS 也是让大家可以更轻易的更简单的实现整个平台。标准，这个不用说了。专业，大家会发现，其实现在 PaaS 平台会慢慢的向少数的解决方案集中。基本上已经很少有小公司自己再去做一个自己的 PaaS 平台了。大规模，大家都有联系到，目前 PaaS 市场上比较大的一些公有云，会发现这个规模其实是非常可怕。&lt;/p&gt;
&lt;p&gt;大部分公有云，如果体积规模发展比较迅速的话，每年乘 2 是很正常的。我们发现 PaaS 其实和我们之前谈到的 Service Mesh，几乎是一脉相承。为什么？殊路而同归。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbdvljfj31hc0u07ax_hu927307e286b6320d7d35972a6de4d87d_242294_cbe5f5ac9960a7b1ca3a7680e7056426.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbdvljfj31hc0u07ax_hu927307e286b6320d7d35972a6de4d87d_242294_9b7a6f26d0ae1a26d59ef66fb7475ec6.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbdvljfj31hc0u07ax_hu927307e286b6320d7d35972a6de4d87d_242294_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbdvljfj31hc0u07ax_hu927307e286b6320d7d35972a6de4d87d_242294_cbe5f5ac9960a7b1ca3a7680e7056426.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;PaaS 和 Service Mesh 成功的基础，其实就是在这几个关键的点上。&lt;/p&gt;
&lt;p&gt;一个是一定要简单易用。这个轮子大家有没有印象，有小朋友的就会知道，这个是自行车后轮的平衡轮。有这个平衡轮之后，没有任何基础的小朋友也可以骑上自行车了，就叫易用性：非常非常简单，让你的入门门槛瞬间降低，客户做的事情及其简单。&lt;/p&gt;
&lt;p&gt;第二个事情是一定要有规模效应，产品要好，价格要低，怎么做到？只能把规模做大。要把规模做大，还有一个事情，就是一定要想办法把蛋糕做大。因为就算你把市场百分百占了，如果这个市场本身不大，那这种情况下其实就算占了百分百，也就一小块。所以接下来一个事情就是一定要去把这个蛋糕做大。&lt;/p&gt;
&lt;p&gt;整个 PaaS 和 Service Mesh 的生存之道（大家如果有留意到，我们一路下来这个脉络）是说它做了一个重要的事情，就是它实际上是在帮客户做事情：这些事情是客户必须要做的，但是他又不太容易做好。我们的生存之道是帮助客户从这些细节里面解脱出来。客户大多数情况下是业务驱动的，我们要做的就是把所有的他要做又不好做的这些事情都下沉下来，我们帮他做好。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbjsz50j31hc0u00zq_hud5614fba9da880cd13956871380e95a3_257429_4a5989428069b5a13f12f14c11306dd1.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbjsz50j31hc0u00zq_hud5614fba9da880cd13956871380e95a3_257429_037a6f5676fb87ac0a108c86986e4455.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbjsz50j31hc0u00zq_hud5614fba9da880cd13956871380e95a3_257429_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbjsz50j31hc0u00zq_hud5614fba9da880cd13956871380e95a3_257429_4a5989428069b5a13f12f14c11306dd1.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Service Mesh 和 PaaS 在理念上是相通的，Service Mesh 对 PaaS 的价值体现在下面的几个方面：&lt;/p&gt;
&lt;p&gt;第一个是标准化和规模化，那这个我们讲的挺多。&lt;/p&gt;
&lt;p&gt;第二个，会涉及到跟技术相关的一些内容，它可以让开发和运维分离。Service Mesh 会接管整个应用的部署、运维和对应用的管理，它独立于应用的开发和业务实现。这样的好处是可以将大家熟悉的一些比如说服务治理的各种功能，让它独立应用的开发之外，而这些功能通过 Service Mesh 来实现。当 Service Mesh 变成 PaaS 的一部分之后，PaaS 和业务之间的这个界限会变得特别的清晰。应用集中在业务语义，而剩下的所有的部署、运维、管理、监控通通放在 PaaS，这样两者之间的界限清晰。&lt;/p&gt;
&lt;p&gt;另外一个就是提高竞争力，因为 Service Mesh 代表着技术先进性，提供了一些非常强大的功能，同时它会降低客户的门槛和客户易于使用，这个对于客户而言吸引力是非常高的。&lt;/p&gt;
&lt;p&gt;然后可以帮助 PaaS 平台更好的去整合资源，因为 PaaS 天生是提供各种能力的。这些能力，原来是以单个单个的方式提供给客户，大家如果有注意到的话，所有 PaaS 平台都卖各种产品各种能力，然后可以自己选择去用。Mesh 有个好处是说它本身就可以天然地把这些能力组合起来，变成一个统一的全套方案，直接覆盖监控、告警、故障排查，变成整个基础能力的一部分，变成 PaaS 平台的一部分，通过这样的方式来发挥 PaaS 平台的威力。&lt;/p&gt;
&lt;p&gt;另外就是引入了可控性。因为 Service Mesh 的控制平面，是可以对整个服务间通讯、对服务治理做到集中式的管理。这些控制的能力，如果为 PaaS 所用，那 PaaS 就会平添一种能力，去对整个应用做统一的控制。在此之前 PaaS 平台对应用的控制更多是集中在非常粗的层面，比如说启动、关闭，但是内部其实没办法干预。可以给它分配资源，但是你实际上没有办法去管控，比如说一些服务治理的功能。那通过整合 Service Mesh 之后，PaaS 就开始有能力对服务进行管控，而且这个能力会变得非常强大。而强大的服务治理功能，会变成 PaaS 平台的重要的卖点。&lt;/p&gt;
&lt;p&gt;这是整个 Service Mesh 对于 PaaS 的帮助。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbrvq35j31hc0u0ad0_hu7cb2b7525bab1c56db2de567bf42b3a8_99284_a96db5d597469e1b4bf3079ab30591b5.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbrvq35j31hc0u0ad0_hu7cb2b7525bab1c56db2de567bf42b3a8_99284_37005f012b86812c972a12f79bbc03f7.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbrvq35j31hc0u0ad0_hu7cb2b7525bab1c56db2de567bf42b3a8_99284_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbrvq35j31hc0u0ad0_hu7cb2b7525bab1c56db2de567bf42b3a8_99284_a96db5d597469e1b4bf3079ab30591b5.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们简单总结一下：Service Mesh 技术为 PaaS 平台提供了一个非常好的应用落地方案。&lt;/p&gt;
&lt;p&gt;底层是 PaaS，PaaS 如果直接接业务的话，通常是比较累的。客户选择用微服务之后，就会选择 Spring Cloud 之类的东西，还是要自己做一层比较厚的框架层。有 Service Mesh 技术之后 PaaS 会更好的对接微服务，对接业务。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcby2p8mj31hc0u0jvg_hu30177ba579b67327c65bae22bd4955f3_148132_ef117bca249ae2d36ebc6f71ce208e6c.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcby2p8mj31hc0u0jvg_hu30177ba579b67327c65bae22bd4955f3_148132_bcfca8f2b799d8538c64231cd084d5f7.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcby2p8mj31hc0u0jvg_hu30177ba579b67327c65bae22bd4955f3_148132_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcby2p8mj31hc0u0jvg_hu30177ba579b67327c65bae22bd4955f3_148132_ef117bca249ae2d36ebc6f71ce208e6c.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们会提到，Service Mesh 和 PaaS，我们称之为&lt;strong&gt;绝配&lt;/strong&gt;。所谓绝配，是说这样一个搭档相互之间是非常的舒服：让彼此的能力互补，然后增强对方的优点。&lt;/p&gt;
&lt;p&gt;在最早的微服务时代，微服务和容器被认为是一对绝配。应该说这两个技术的互补性是非常强的。微服务已经进展到 Service Mesh 阶段了，而容器经过市场淘汰已经开始向 K8S 靠拢了。接下来，在这样一个基础上如果能再走一步，当 k8s 逐步向 PaaS 平台靠拢，也就说 PaaS 实际上是一个基于 K8S 的 PaaS。那它和 Service Mesh 之间的搭档会成为一个新的市场主流，成为一个更好的客户基础。当然现在还没有实现，目前市场上暂时还没有这样的产品，但我相信在未来一两年中这会成为市场的主流。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcc61wwhj31hc0u0q4i_hu1800b6a36a98bbcbbe28e9938bf9fdc5_46172_e64f2b04ee0fc4ce1997224fdeefd394.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcc61wwhj31hc0u0q4i_hu1800b6a36a98bbcbbe28e9938bf9fdc5_46172_cecbca43057daa65a31823df69dfa06f.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcc61wwhj31hc0u0q4i_hu1800b6a36a98bbcbbe28e9938bf9fdc5_46172_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcc61wwhj31hc0u0q4i_hu1800b6a36a98bbcbbe28e9938bf9fdc5_46172_e64f2b04ee0fc4ce1997224fdeefd394.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，我们今天的内容到这里结束，非常感谢大家，谢谢。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
