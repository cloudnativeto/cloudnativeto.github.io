<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>马若飞 | 云原生社区</title>
    <link>https://cloudnative.to/author/%E9%A9%AC%E8%8B%A5%E9%A3%9E/</link>
      <atom:link href="https://cloudnative.to/author/%E9%A9%AC%E8%8B%A5%E9%A3%9E/index.xml" rel="self" type="application/rss+xml" />
    <description>马若飞</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 25 Aug 2020 11:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/author/%E9%A9%AC%E8%8B%A5%E9%A3%9E/avatar_hue38add62c87b7486d80c9f3fda25dfc1_12220_270x270_fill_q75_lanczos_center.jpg</url>
      <title>马若飞</title>
      <link>https://cloudnative.to/author/%E9%A9%AC%E8%8B%A5%E9%A3%9E/</link>
    </image>
    
    <item>
      <title>Istio 1.7 发布——进击的追风少年</title>
      <link>https://cloudnative.to/blog/istio-1-7-explanation/</link>
      <pubDate>Tue, 25 Aug 2020 11:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-1-7-explanation/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;2020 年 8 月 21 日，Istio 发布了 1.7 版本。除了介绍新版本的主要更新内容外，本文会重点分析 Istio 团队在产品更新策略上的激进态度和举措。是稳扎稳打做好向后兼容，带给用户所承诺的易用性；还是快刀斩乱麻，做进击的追风少年，且听笔者慢慢道来。&lt;/p&gt;
&lt;h2 id=&#34;如约而至istio-170-发布&#34;&gt;如约而至——Istio 1.7.0 发布&lt;/h2&gt;
&lt;p&gt;就在几天前，Istio 发布了 1.7 版本，和 1.6 版本的发布时间正好间隔三个月，完美的实现了季度发布的诺言。本次发布的口号是 “伟大的 Istio 社区（Istio’s great community）”，因为有来自 40 多个公司的 200 多个开发者做出了贡献。Istio 官方是这样描述的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正是因为有如此令人惊羡（amazing）的社区，才让 Istio 能够在每个季度有如此多的改进。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Istio 团队已经从上个月倒卖商标的麻烦中走了出来，看上去是想通过强调 &lt;code&gt;Istio&#39;s great community&lt;/code&gt; 这个理念来抚平社区开发者受伤的心灵？笔者认为，作为开发者和用户不必太在意 Google 的商业行为，至少现阶段 Istio 还在以开源的身份持续演进，还能为我所用，这就足够了。&lt;/p&gt;
&lt;p&gt;1.7 版本中重要的更新主要有以下四个方面。&lt;/p&gt;
&lt;h3 id=&#34;安全增强&#34;&gt;安全增强&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;确认了使用安全发现服务（SDS）作为证书分发的优势，并把它作为一个重要的安全最佳实践。现在这一特性也被使用在出口网关上。&lt;/li&gt;
&lt;li&gt;信任域验证除了支持 HTTP，现在也可以验证 TCP 流量了，并且还支持在 MeshConfig 中进行配置，提供了更多灵活性。&lt;/li&gt;
&lt;li&gt;可以使用 &lt;a href=&#34;https://en.wikipedia.org/wiki/Elliptic-curve_cryptography&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ECC&lt;/a&gt; 进行 CA 通信，提高了安全性和效率。&lt;/li&gt;
&lt;li&gt;网关默认使用非根（non-root）用户部署，这主要是基于一条最佳实践：不要让运行的进程有多于它所需的权限，这会导致不必要的混淆。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;提升易用性&#34;&gt;提升易用性&lt;/h3&gt;
&lt;p&gt;在易用性方面主要的改进依然是对 &lt;code&gt;istioctl&lt;/code&gt; 命令行工具的增强：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;analysis 支持
&lt;ul&gt;
&lt;li&gt;对可能不安全的 &lt;code&gt;DestinationRule&lt;/code&gt; 配置发出警告&lt;/li&gt;
&lt;li&gt;对使用废弃的 Mixer 资源发出警告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以使用 &lt;code&gt;ISTIOCONFIG&lt;/code&gt; 设置自定义配置&lt;/li&gt;
&lt;li&gt;使用助记符来标识端口号&lt;/li&gt;
&lt;li&gt;添加了 &lt;code&gt;istioctl x uninstall&lt;/code&gt; 来方便卸载 Istio&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生产运维改进&#34;&gt;生产运维改进&lt;/h3&gt;
&lt;p&gt;在运维方面也有些许改进，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以支持让 Sidecar 启动后才启动你的应用容器。如果你的应用需要在启动时通过 Sidecar 代理来访问资源，这项修改可以让部署变的更稳定（避免因为 Sidecar 没启动而应用访问不到资源的情况）。&lt;/li&gt;
&lt;li&gt;Istio Operator 作为最佳安装方式。Operator 在之前的版本就已经提供了，看上去 Istio 想主推 Operator 以替代其他的安装形式。但笔者必须要吐槽一下官方发布文档对这一条的描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;a href=&#34;https://istio.io/latest/docs/setup/install/operator/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Operator&lt;/a&gt; is a great way to install Istio, as it automates a fair amount of toil. Canary control plane deployments are also important; they allow ultra-safe upgrades of Istio. Unfortunately, you couldn’t use them together - &lt;a href=&#34;https://istio.io/latest/docs/setup/upgrade/#canary-upgrades&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;until now&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;吹了一大堆，其实翻译成人话就是：Operator 目前还不支持金丝雀更新。真是佩服这段文案编写者拐弯抹角的能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供了 istio-agent 的指标，可以观察它的运行情况&lt;/li&gt;
&lt;li&gt;Prometheus 指标收集方面的改进&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vm-安全性&#34;&gt;VM 安全性&lt;/h3&gt;
&lt;p&gt;持续对虚拟机相关功能的开发是本年度的重点，这是 Istio 多次强调的。这是因为目前客户应用部署环境的复杂性和混合性，VM 依然是一种主要的部署选择。和一些托管的竞品（比如 AWS APP Mesh ）相比，Istio 缺失了这方面的能力，使得这些客户不得不观望而无法落地。对 VM 的支持就成为了重中之重，这也是商业上的考量。&lt;/p&gt;
&lt;p&gt;然而本次更新没有太多的重量级功能发布，只是做了小的改进，且还在 alpha 阶段。比如为 VM 也增加了安全特性，支持证书自动轮转；&lt;code&gt;istioctl&lt;/code&gt; 现在可以验证 VM 的代理状态；增加了 RPM 安装包等。&lt;/p&gt;
&lt;h2 id=&#34;温柔一刀升级的伤痛&#34;&gt;温柔一刀——升级的伤痛&lt;/h2&gt;
&lt;p&gt;客观的讲，以上官方的发布文档大部分内容都不痛不痒，对使用层面的用户影响不大。而真正和用户息息相关是安装和升级的变化。Istio 团队并没有在发布首页强调这一点，这引起了笔者的强烈不适并严重怀疑 Istio 有刻意规避问题的嫌疑。我们先来看笔者认为最重要的一条变更：&lt;/p&gt;
&lt;h3 id=&#34;过分严格的平台版本限制&#34;&gt;过分严格的平台版本限制&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Require Kubernetes 1.16+&lt;/p&gt;
&lt;p&gt;Kubernetes 1.16+ is now required for installation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是 Istio 官方第一次在新版本的 Release Note 中明确的说明了 Kubernetes 的版本限制问题。尽管以前老版本的 Istio 也会对平台版本有要求，但通常是这样的口吻：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Istio 1.5 has been tested with these Kubernetes releases: 1.14, 1.15, 1.16.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种描述隐含的意思就是：我们在这几个版本测试过兼容性，但我们并没有说 Istio 不兼容其他版本，可能、也许、大概是兼容的，我们只是没有测试过而已。而这一次是描述是 “required”，请仔细体会这两种说法的区别。&lt;/p&gt;
&lt;p&gt;为了验证 1.7 真实的兼容性（ required 只是骇人听闻？），笔者做了一次安装测试，测试环境为 Docker 桌面版内置的 Kubernetes，版本 v1.15.5。&lt;/p&gt;
&lt;p&gt;首先，使用预检命令验证集群环境是否合法（新版本已经取消了 &lt;code&gt;istioctl verify-install&lt;/code&gt; 命令）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bin/istioctl x precheck
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Error: &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; error occurred:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; * The Kubernetes API version: v1.15.5 is lower than the minimum version: 1.16
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;果然，预检没有通过，出现了版本过低的错误。笔者忽略预检结果，尝试强行安装，想看看预检是否也只是吓唬人而已：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bin/istioctl install
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;This will install the default Istio profile into the cluster. Proceed? &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;y/N&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; y
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;The Kubernetes version v1.15.5 is not supported by Istio 1.7.0. The minimum supported Kubernetes version is 1.16.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Proceeding with the installation, but you might experience problems. See https://istio.io/latest/docs/setup/platform-setup/ &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; a list of supported versions.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;✘ Istio core encountered an error: failed to &lt;span class=&#34;nb&#34;&gt;wait&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; resource: failed to verify CRD creation: the server could not find the requested resource
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;验证结果被现实啪啪打脸。除了对版本限制的说明，Istio 还非常严谨的告知安装过程会继续，但你可能会遇到各种问题。果然，在 Istio core 的安装步骤中就报了错，安装过程被卡住无法继续进行。看来这一次 Istio 的 required 是来真的了。&lt;/p&gt;
&lt;p&gt;为什么说这个强制性的版本限制会对用户造成最大的困扰？其根本原因就是当前绝大部分企业和用户所使用的 Kubernetes 根本没有达到 1.16+ 版本，大部分都是基于 1.14、1.12，甚至更低。目前两大云厂商的 Kubernetes 服务（AWS EKS 和 GCloud GKE）也都是兼容 1.14+，这也能从一个侧面说明有一大批老用户很可能都使用的是 1.14 版本。然而 Istio 并没有遵循这一规则，这等于直接将很大一部分用户踢出了场外，Istio 1.7 不带你们玩了。&lt;/p&gt;
&lt;p&gt;另一个潜在的问题是为想要升级的用户带来了极大的困惑。举一个例子：某企业的运维团队正在打算将 1.14 版本的 Kubernetes 升级到 1.16，而架构团队正打算将安装在其上的 Istio 1.2 升级到 1.7。这个团队所面临的问题是，要升级到 Istio 1.7 必须先升级 Kubernetes 到 1.16；但是一旦升级了 1.16，原本的 1.2 版本很可能有兼容问题，因为 Istio 1.2 宣称只在 Kubernetes 1.12~1.14 测试过。Istio 1.7 过分严格的的平台版本限制给了这些用户致命一刀，升级之路充满荆棘。他们只能退而求其次选择老版本进行升级。&lt;/p&gt;
&lt;p&gt;从 1.5 版本开始，Istio 一方面不断的强调易用性和用户体验，一方面又武断的放弃向下兼容，将大量用户拒之门外。其自相矛盾的行为令人匪夷所思。&lt;/p&gt;
&lt;h3 id=&#34;资源版本号的变更&#34;&gt;资源版本号的变更&lt;/h3&gt;
&lt;p&gt;这一问题出现在 Change Note 安装部分的一条，很可能成为升级用户新的痛点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Upgraded the CRD and Webhook versions to v1. (&lt;a href=&#34;https://github.com/istio/istio/issues/18771&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Issue #18771&lt;/a&gt;),(&lt;a href=&#34;https://github.com/istio/istio/issues/18838&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Issue #18838&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从 Issue 可以看出，因为 Kubernetes 在 1.16 中将 webhook 的 API 版本改为 v1，并会在 1.19 版本中删除老的 v1beta 版本。这一激进行为导致 Istio 不得不在自己的 1.8 版本之前完成对应的迁移。笔者在 Istio 官方 Slack 中也验证了这一问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Yes this is a hard requirement. Most specifically CRDs, and other apis use APIs that were promoted to v1 in 1.16 are being used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Istio 开发团队也在 Issue 中抱怨对方太激进（aggressive），留给他们的开发周期太短（pretty tight window），有很多工作要做（probably a lot of work），一副巧妇难为无米之炊的委屈样。笔者不由得感叹：本是同门师兄弟，相煎太急！&lt;/p&gt;
&lt;p&gt;而对于用户而言，意味着你不得不将自己的 mesh 配置文件的版本号进行更新，如果集群比较庞大，很可能有不少的工作量（主要是测试、验证方面）。你很可能还需要通过金丝雀升级的方式进行，因为无论是先升级 Istio，还是先修改配置，都可能出现兼容问题（说好的易用性和用户体验呢？）。&lt;/p&gt;
&lt;h3 id=&#34;短暂的-lts&#34;&gt;短暂的 LTS&lt;/h3&gt;
&lt;p&gt;在 Istio 的&lt;a href=&#34;https://istio.io/latest/news/support/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;版本支持公告页面&lt;/a&gt;，你可以发现以前的老版本都逐渐的停止了维护，特别是具有里程碑意义的 1.5 版本，在发布 6 个月后即停止维护，几乎成为了 Istio 史上最短命的版本。Istio 在&lt;a href=&#34;https://istio.io/latest/about/release-cadence/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构建和发布节奏页面&lt;/a&gt;中这样定义 LTS（long term support）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Support is provided until 3 months after the next LTS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即上一个版本会在新版本发布后的 3 个月就停止维护（包括更新、修复 bug 等），算上它自己的发布日期，也只有半年时间。我们再来对比一下 Ubuntu 对 LTS 的定义，下面是 Ubuntu 20.04 LTS 的一段说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下载专为桌面 PC 和笔记本精心打造的 Ubuntu 长期支持 (LTS) 版本。LTS 意为 “长期支持”，一般为 5 年。LTS 版本将提供免费安全和维护更新至 2025 年 4 月。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5 年对 3 个月。对于操作系统来说，因为处在整个软件架构的最底层，理应保证长期稳定的维护。Service Mesh 比不了操作系统，但好歹也是基础设施，也应该对上层建筑提供更多稳定性。这个所谓的长期是不是有点过于短暂？追风少年你是要赶着去投胎吗？Istio 对 LTS 的定义让我开始怀疑人生。&lt;/p&gt;
&lt;h2 id=&#34;路在何方稳定是永恒的童话&#34;&gt;路在何方——稳定是永恒的童话？&lt;/h2&gt;
&lt;p&gt;Service Mesh 领域的权威人士 Christian Posta 在公开采访中表示：Istio 1.7 将会是真正意义上的稳定、可用于生产环境的版本。笔者对此不敢苟同。本次更新表现平平，并无亮点，反倒是对 Kubernetes 的版本限制会导致用户在安装、升级环节增加成本和不确定性，是一次用户体验上的倒退。Istio 1.0 版本就宣称是生成环境可用（Production ready），恐怕这一次也依然会变成川建国金句的翻版：Make Istio production ready again!&lt;/p&gt;
&lt;p&gt;经过了 3 年多的迭代，Istio 依然像个毛头小子，随性而为。稳定和可靠，在这里成了骗人的童话故事。笔者曾分析 Istio 1.8 将会是第一个稳定版本，希望下一次不要让我们失望。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AWS App Mesh - 云应用的服务网格</title>
      <link>https://cloudnative.to/blog/aws-app-mesh-application-level-networking-for-cloud-applications/</link>
      <pubDate>Fri, 06 Sep 2019 18:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/aws-app-mesh-application-level-networking-for-cloud-applications/</guid>
      <description>&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;本文简要介绍了AWS App Mesh的基本概念，并通过一个示例演示了如何在AWS的控制台创建一个App Mesh的服务网格。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/app-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS App Mesh&lt;/a&gt; 可以帮助你运行和监控大规模的HTTP和TCP服务。你可以用一致的方式来路由和监控流量，获得发现问题的能力，并在失败或代码更改后重新路由流量。App Mesh使用开源的&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;代理，让你可以使用来自AWS合作伙伴和开源社区的各种工具。&lt;/p&gt;
&lt;p&gt;服务可以运行在&lt;a href=&#34;https://aws.amazon.com/fargate/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS Fargate&lt;/a&gt;， &lt;a href=&#34;https://aws.amazon.com/ec2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon EC2&lt;/a&gt;，&lt;a href=&#34;https://aws.amazon.com/ecs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon ECS&lt;/a&gt;， &lt;a href=&#34;https://aws.amazon.com/eks/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon Elastic Container Service for Kubernetes&lt;/a&gt; 或 &lt;a href=&#34;https://aws.amazon.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;上。每个服务的所有进出流量都经过Envoy代理，以便对其进行路由、可视化、测量和记录。这种额外的间接层让你可以用任何想要的语言构建服务，而不必使用一组公共的通信库。&lt;/p&gt;
&lt;h2 id=&#34;app-mesh基本概念&#34;&gt;App Mesh基本概念&lt;/h2&gt;
&lt;p&gt;在深入了解之前，让我们先来回顾一下App Mesh里的重要概念和组件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/meshes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;服务网格&lt;/strong&gt;&lt;/a&gt; – 网络流量在其服务之间的逻辑边界。网格可以包含虚拟服务、虚拟节点、虚拟路由器和路由。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_services.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;虚拟服务&lt;/strong&gt;&lt;/a&gt; – 直接（由虚拟节点）或间接（通过虚拟路由器）提供的服务的抽象（逻辑名称）。网格中的服务使用逻辑名称引用和使用其他服务。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_nodes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;虚拟节点&lt;/strong&gt;&lt;/a&gt; – 特定任务组（如ECS服务或Kubernetes部署）或运行在一个或多个EC2实例上的逻辑指针。每个虚拟节点可以通过&lt;strong&gt;侦听器&lt;/strong&gt;接受入流量，并通过&lt;strong&gt;后端&lt;/strong&gt;连接到其他虚拟节点。此外，每个节点都有一个服务发现配置（当前是DNS名称），允许其他节点发现任务、pod或实例的IP地址。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_routers.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;虚拟路由器&lt;/strong&gt;&lt;/a&gt; – 网格中一个或多个虚拟服务的处理器。每个虚拟路由器监听特定端口上的HTTP通信。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/routes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;路由&lt;/strong&gt;&lt;/a&gt; – 路由使用基于URL的前缀匹配将流量路由到虚拟节点，每个节点都有可选的权重。权重可用于测试生产环境中的新服务，同时逐渐增加它们处理的流量。&lt;/p&gt;
&lt;p&gt;把它们放在一起，每个服务网格包含一组服务，可以通过路由指定的URL路径访问这些服务。网格中，服务通过名称相互引用。&lt;/p&gt;
&lt;p&gt;可以从App Mesh控制台、App Mesh CLI或App Mesh API访问App Mesh。我将展示如何使用控制台创建网格，并对CLI做简要的介绍。&lt;/p&gt;
&lt;h2 id=&#34;使用app-mesh控制台&#34;&gt;使用App Mesh控制台&lt;/h2&gt;
&lt;p&gt;在控制台创建服务网格和组件。打开&lt;a href=&#34;https://console.aws.amazon.com/appmesh/landing-page&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;App Mesh Console&lt;/a&gt; 并点击开始使用：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_console_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;输入我的网格和第一个虚拟服务（以后可以添加多个）的名称，点击下一步：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_step1_2.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;定义第一个虚拟节点：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_step2_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;点击额外配置来设置特定的服务后端（其他服务是指一个可以调用的服务）和日志记录：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_step2_p2_2.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过协议（HTTP或TCP）和端口来定义节点的监听器，设置健康检查选项，点击下一步：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_step2_p3_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然后，定义虚拟路由器和它的路由：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_step3_p1_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可以按百分比在多个虚拟节点（目标）之间分配流量，还可以对入流量使用基于前缀的路由：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_step3_p2_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后再检查一下我的设置并点击创建网格服务：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_review_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;组件很快被创建并且可以准备使用了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_ready_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后一步，如&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/getting_started.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;App Mesh 使用手册&lt;/a&gt;中所描述，更新我的任务定义（Amazon ECS或AWS Fargate）或pod规范（Amazon EKS或Kubernetes），以引用Envoy容器映像和代理容器映像。如果我的服务运行在EC2实例上，需要在那里部署Envoy。&lt;/p&gt;
&lt;h2 id=&#34;使用aws-app-mesh命令行&#34;&gt;使用AWS App Mesh命令行&lt;/h2&gt;
&lt;p&gt;App Mesh可以让你以一个简单的JSON形式描述每个类型的组件，并提供了&lt;a href=&#34;https://docs.aws.amazon.com/cli/latest/reference/appmesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;命令行工具&lt;/a&gt;来创建每一个组件（&lt;code&gt;create-mesh&lt;/code&gt;, &lt;code&gt;create-virtual-service&lt;/code&gt;, &lt;code&gt;create-virtual-node&lt;/code&gt;, and &lt;code&gt;create-virtual-router&lt;/code&gt;）。例如，可以像这样定义一个虚拟路由：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;meshName&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;mymesh&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;spec&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;listeners&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;nt&#34;&gt;&amp;#34;portMapping&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;port&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;protocol&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;http&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualRouterName&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;serviceA&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并使用一条命令创建它：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ aws appmesh create-virtual-router --cli-input-json file://serviceA-router.json
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;当前可用&#34;&gt;当前可用&lt;/h2&gt;
&lt;p&gt;AWS App Mesh现在是可用的，你可以现在就开始使用它，包括的区域有美国东部（维吉尼亚），美国东部（俄亥俄州），美国西部（俄勒冈州），美国西部（加利福尼亚），加拿大（中央）、欧洲（爱尔兰），欧洲（法兰克福），欧洲（伦敦），亚太（孟买），亚太（东京），亚太（悉尼），亚太（新加坡）和亚太（首尔）。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
