<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>马若飞 | 云原生社区（中国）</title>
    <link>https://cloudnative.to/author/%E9%A9%AC%E8%8B%A5%E9%A3%9E/</link>
      <atom:link href="https://cloudnative.to/author/%E9%A9%AC%E8%8B%A5%E9%A3%9E/index.xml" rel="self" type="application/rss+xml" />
    <description>马若飞</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 25 Aug 2020 11:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/author/%E9%A9%AC%E8%8B%A5%E9%A3%9E/avatar_hue38add62c87b7486d80c9f3fda25dfc1_12220_270x270_fill_q75_lanczos_center.jpg</url>
      <title>马若飞</title>
      <link>https://cloudnative.to/author/%E9%A9%AC%E8%8B%A5%E9%A3%9E/</link>
    </image>
    
    <item>
      <title>Istio 1.7 发布——进击的追风少年</title>
      <link>https://cloudnative.to/blog/istio-1-7-explanation/</link>
      <pubDate>Tue, 25 Aug 2020 11:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-1-7-explanation/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;2020 年 8 月 21 日，Istio 发布了 1.7 版本。除了介绍新版本的主要更新内容外，本文会重点分析 Istio 团队在产品更新策略上的激进态度和举措。是稳扎稳打做好向后兼容，带给用户所承诺的易用性；还是快刀斩乱麻，做进击的追风少年，且听笔者慢慢道来。&lt;/p&gt;
&lt;h2 id=&#34;如约而至istio-170-发布&#34;&gt;如约而至——Istio 1.7.0 发布&lt;/h2&gt;
&lt;p&gt;就在几天前，Istio 发布了 1.7 版本，和 1.6 版本的发布时间正好间隔三个月，完美的实现了季度发布的诺言。本次发布的口号是“伟大的 Istio 社区（Istio’s great community）”，因为有来自 40 多个公司的 200 多个开发者做出了贡献。Istio 官方是这样描述的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正是因为有如此令人惊羡（amazing）的社区，才让 Istio 能够在每个季度有如此多的改进。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Istio 团队已经从上个月倒卖商标的麻烦中走了出来，看上去是想通过强调 &lt;code&gt;Istio&#39;s great community&lt;/code&gt; 这个理念来抚平社区开发者受伤的心灵？笔者认为，作为开发者和用户不必太在意 Google 的商业行为，至少现阶段 Istio 还在以开源的身份持续演进，还能为我所用，这就足够了。&lt;/p&gt;
&lt;p&gt;1.7 版本中重要的更新主要有以下四个方面。&lt;/p&gt;
&lt;h3 id=&#34;安全增强&#34;&gt;安全增强&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;确认了使用安全发现服务（SDS）作为证书分发的优势，并把它作为一个重要的安全最佳实践。现在这一特性也被使用在出口网关上。&lt;/li&gt;
&lt;li&gt;信任域验证除了支持 HTTP，现在也可以验证 TCP 流量了，并且还支持在 MeshConfig 中进行配置，提供了更多灵活性。&lt;/li&gt;
&lt;li&gt;可以使用 &lt;a href=&#34;https://en.wikipedia.org/wiki/Elliptic-curve_cryptography&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ECC&lt;/a&gt; 进行 CA 通信，提高了安全性和效率。&lt;/li&gt;
&lt;li&gt;网关默认使用非根（non-root）用户部署，这主要是基于一条最佳实践：不要让运行的进程有多于它所需的权限，这会导致不必要的混淆。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;提升易用性&#34;&gt;提升易用性&lt;/h3&gt;
&lt;p&gt;在易用性方面主要的改进依然是对 &lt;code&gt;istioctl&lt;/code&gt; 命令行工具的增强：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;analysis 支持
&lt;ul&gt;
&lt;li&gt;对可能不安全的 &lt;code&gt;DestinationRule&lt;/code&gt; 配置发出警告&lt;/li&gt;
&lt;li&gt;对使用废弃的 Mixer 资源发出警告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以使用 &lt;code&gt;ISTIOCONFIG&lt;/code&gt; 设置自定义配置&lt;/li&gt;
&lt;li&gt;使用助记符来标识端口号&lt;/li&gt;
&lt;li&gt;添加了 &lt;code&gt;istioctl x uninstall&lt;/code&gt; 来方便卸载 Istio&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生产运维改进&#34;&gt;生产运维改进&lt;/h3&gt;
&lt;p&gt;在运维方面也有些许改进，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以支持让 Sidecar 启动后才启动你的应用容器。如果你的应用需要在启动时通过 Sidecar 代理来访问资源，这项修改可以让部署变的更稳定（避免因为 Sidecar 没启动而应用访问不到资源的情况）。&lt;/li&gt;
&lt;li&gt;Istio Operator 作为最佳安装方式。Operator 在之前的版本就已经提供了，看上去 Istio 想主推 Operator 以替代其他的安装形式。但笔者必须要吐槽一下官方发布文档对这一条的描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;a href=&#34;https://istio.io/latest/docs/setup/install/operator/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Operator&lt;/a&gt; is a great way to install Istio, as it automates a fair amount of toil. Canary control plane deployments are also important; they allow ultra-safe upgrades of Istio. Unfortunately, you couldn’t use them together - &lt;a href=&#34;https://istio.io/latest/docs/setup/upgrade/#canary-upgrades&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;until now&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;吹了一大堆，其实翻译成人话就是：Operator 目前还不支持金丝雀更新。真是佩服这段文案编写者拐弯抹角的能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供了 istio-agent 的指标，可以观察它的运行情况&lt;/li&gt;
&lt;li&gt;Prometheus 指标收集方面的改进&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vm-安全性&#34;&gt;VM 安全性&lt;/h3&gt;
&lt;p&gt;持续对虚拟机相关功能的开发是本年度的重点，这是 Istio 多次强调的。这是因为目前客户应用部署环境的复杂性和混合性，VM 依然是一种主要的部署选择。和一些托管的竞品（比如 AWS APP Mesh）相比，Istio 缺失了这方面的能力，使得这些客户不得不观望而无法落地。对 VM 的支持就成为了重中之重，这也是商业上的考量。&lt;/p&gt;
&lt;p&gt;然而本次更新没有太多的重量级功能发布，只是做了小的改进，且还在 alpha 阶段。比如为 VM 也增加了安全特性，支持证书自动轮转；&lt;code&gt;istioctl&lt;/code&gt; 现在可以验证 VM 的代理状态；增加了 RPM 安装包等。&lt;/p&gt;
&lt;h2 id=&#34;温柔一刀升级的伤痛&#34;&gt;温柔一刀——升级的伤痛&lt;/h2&gt;
&lt;p&gt;客观的讲，以上官方的发布文档大部分内容都不痛不痒，对使用层面的用户影响不大。而真正和用户息息相关是安装和升级的变化。Istio 团队并没有在发布首页强调这一点，这引起了笔者的强烈不适并严重怀疑 Istio 有刻意规避问题的嫌疑。我们先来看笔者认为最重要的一条变更：&lt;/p&gt;
&lt;h3 id=&#34;过分严格的平台版本限制&#34;&gt;过分严格的平台版本限制&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Require Kubernetes 1.16+&lt;/p&gt;
&lt;p&gt;Kubernetes 1.16+ is now required for installation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是 Istio 官方第一次在新版本的 Release Note 中明确的说明了 Kubernetes 的版本限制问题。尽管以前老版本的 Istio 也会对平台版本有要求，但通常是这样的口吻：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Istio 1.5 has been tested with these Kubernetes releases: 1.14, 1.15, 1.16.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种描述隐含的意思就是：我们在这几个版本测试过兼容性，但我们并没有说 Istio 不兼容其他版本，可能、也许、大概是兼容的，我们只是没有测试过而已。而这一次是描述是“required”，请仔细体会这两种说法的区别。&lt;/p&gt;
&lt;p&gt;为了验证 1.7 真实的兼容性（required 只是骇人听闻？），笔者做了一次安装测试，测试环境为 Docker 桌面版内置的 Kubernetes，版本 v1.15.5。&lt;/p&gt;
&lt;p&gt;首先，使用预检命令验证集群环境是否合法（新版本已经取消了 &lt;code&gt;istioctl verify-install&lt;/code&gt; 命令）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bin/istioctl x precheck
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Error: &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; error occurred:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; * The Kubernetes API version: v1.15.5 is lower than the minimum version: 1.16
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;果然，预检没有通过，出现了版本过低的错误。笔者忽略预检结果，尝试强行安装，想看看预检是否也只是吓唬人而已：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ bin/istioctl install
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;This will install the default Istio profile into the cluster. Proceed? &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;y/N&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; y
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;The Kubernetes version v1.15.5 is not supported by Istio 1.7.0. The minimum supported Kubernetes version is 1.16.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Proceeding with the installation, but you might experience problems. See https://istio.io/latest/docs/setup/platform-setup/ &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; a list of supported versions.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;✘ Istio core encountered an error: failed to &lt;span class=&#34;nb&#34;&gt;wait&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; resource: failed to verify CRD creation: the server could not find the requested resource
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;验证结果被现实啪啪打脸。除了对版本限制的说明，Istio 还非常严谨的告知安装过程会继续，但你可能会遇到各种问题。果然，在 Istio core 的安装步骤中就报了错，安装过程被卡住无法继续进行。看来这一次 Istio 的 required 是来真的了。&lt;/p&gt;
&lt;p&gt;为什么说这个强制性的版本限制会对用户造成最大的困扰？其根本原因就是当前绝大部分企业和用户所使用的 Kubernetes 根本没有达到 1.16+ 版本，大部分都是基于 1.14、1.12，甚至更低。目前两大云厂商的 Kubernetes 服务（AWS EKS 和 GCloud GKE）也都是兼容 1.14+，这也能从一个侧面说明有一大批老用户很可能都使用的是 1.14 版本。然而 Istio 并没有遵循这一规则，这等于直接将很大一部分用户踢出了场外，Istio 1.7 不带你们玩了。&lt;/p&gt;
&lt;p&gt;另一个潜在的问题是为想要升级的用户带来了极大的困惑。举一个例子：某企业的运维团队正在打算将 1.14 版本的 Kubernetes 升级到 1.16，而架构团队正打算将安装在其上的 Istio 1.2 升级到 1.7。这个团队所面临的问题是，要升级到 Istio 1.7 必须先升级 Kubernetes 到 1.16；但是一旦升级了 1.16，原本的 1.2 版本很可能有兼容问题，因为 Istio 1.2 宣称只在 Kubernetes 1.12~1.14 测试过。Istio 1.7 过分严格的的平台版本限制给了这些用户致命一刀，升级之路充满荆棘。他们只能退而求其次选择老版本进行升级。&lt;/p&gt;
&lt;p&gt;从 1.5 版本开始，Istio 一方面不断的强调易用性和用户体验，一方面又武断的放弃向下兼容，将大量用户拒之门外。其自相矛盾的行为令人匪夷所思。&lt;/p&gt;
&lt;h3 id=&#34;资源版本号的变更&#34;&gt;资源版本号的变更&lt;/h3&gt;
&lt;p&gt;这一问题出现在 Change Note 安装部分的一条，很可能成为升级用户新的痛点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Upgraded the CRD and Webhook versions to v1. (&lt;a href=&#34;https://github.com/istio/istio/issues/18771&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Issue #18771&lt;/a&gt;),(&lt;a href=&#34;https://github.com/istio/istio/issues/18838&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Issue #18838&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从 Issue 可以看出，因为 Kubernetes 在 1.16 中将 webhook 的 API 版本改为 v1，并会在 1.19 版本中删除老的 v1beta 版本。这一激进行为导致 Istio 不得不在自己的 1.8 版本之前完成对应的迁移。笔者在 Istio 官方 Slack 中也验证了这一问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Yes this is a hard requirement. Most specifically CRDs, and other apis use APIs that were promoted to v1 in 1.16 are being used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Istio 开发团队也在 Issue 中抱怨对方太激进（aggressive），留给他们的开发周期太短（pretty tight window），有很多工作要做（probably a lot of work），一副巧妇难为无米之炊的委屈样。笔者不由得感叹：本是同门师兄弟，相煎太急！&lt;/p&gt;
&lt;p&gt;而对于用户而言，意味着你不得不将自己的 mesh 配置文件的版本号进行更新，如果集群比较庞大，很可能有不少的工作量（主要是测试、验证方面）。你很可能还需要通过金丝雀升级的方式进行，因为无论是先升级 Istio，还是先修改配置，都可能出现兼容问题（说好的易用性和用户体验呢？）。&lt;/p&gt;
&lt;h3 id=&#34;短暂的-lts&#34;&gt;短暂的 LTS&lt;/h3&gt;
&lt;p&gt;在 Istio 的&lt;a href=&#34;https://istio.io/latest/news/support/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;版本支持公告页面&lt;/a&gt;，你可以发现以前的老版本都逐渐的停止了维护，特别是具有里程碑意义的 1.5 版本，在发布 6 个月后即停止维护，几乎成为了 Istio 史上最短命的版本。Istio 在&lt;a href=&#34;https://istio.io/latest/about/release-cadence/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构建和发布节奏页面&lt;/a&gt;中这样定义 LTS（long term support）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Support is provided until 3 months after the next LTS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即上一个版本会在新版本发布后的 3 个月就停止维护（包括更新、修复 bug 等），算上它自己的发布日期，也只有半年时间。我们再来对比一下 Ubuntu 对 LTS 的定义，下面是 Ubuntu 20.04 LTS 的一段说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下载专为桌面 PC 和笔记本精心打造的 Ubuntu 长期支持 (LTS) 版本。LTS 意为“长期支持”，一般为 5 年。LTS 版本将提供免费安全和维护更新至 2025 年 4 月。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5 年对 3 个月。对于操作系统来说，因为处在整个软件架构的最底层，理应保证长期稳定的维护。Service Mesh 比不了操作系统，但好歹也是基础设施，也应该对上层建筑提供更多稳定性。这个所谓的长期是不是有点过于短暂？追风少年你是要赶着去投胎吗？Istio 对 LTS 的定义让我开始怀疑人生。&lt;/p&gt;
&lt;h2 id=&#34;路在何方稳定是永恒的童话&#34;&gt;路在何方——稳定是永恒的童话？&lt;/h2&gt;
&lt;p&gt;Service Mesh 领域的权威人士 Christian Posta 在公开采访中表示：Istio 1.7 将会是真正意义上的稳定、可用于生产环境的版本。笔者对此不敢苟同。本次更新表现平平，并无亮点，反倒是对 Kubernetes 的版本限制会导致用户在安装、升级环节增加成本和不确定性，是一次用户体验上的倒退。Istio 1.0 版本就宣称是生成环境可用（Production ready），恐怕这一次也依然会变成川建国金句的翻版：Make Istio production ready again!&lt;/p&gt;
&lt;p&gt;经过了 3 年多的迭代，Istio 依然像个毛头小子，随性而为。稳定和可靠，在这里成了骗人的童话故事。笔者曾分析 Istio 1.8 将会是第一个稳定版本，希望下一次不要让我们失望。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>迈向极简主义 - Istio 1.6 发布</title>
      <link>https://cloudnative.to/blog/istio-16-explain/</link>
      <pubDate>Thu, 28 May 2020 17:00:10 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-16-explain/</guid>
      <description>&lt;p&gt;内容摘要：从 1.2 版本开始，Istio 进入季度发布的节奏。5 月 21 日发布的 1.6 版本可以说是最准时的一次。我们是否可以理解 Istio 架构简化后的开发工作已经步入了正轨？这次的更新是否会带给我们惊喜？亦或是还有遗憾？让我们一一道来。
（感谢&lt;a href=&#34;https://github.com/GuangmingLuo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;罗广明&lt;/a&gt;同学的审校和修改建议）&lt;/p&gt;
&lt;h2 id=&#34;加法和减法&#34;&gt;加法和减法&lt;/h2&gt;
&lt;p&gt;Istio 1.6 的 Release note 开篇的标题用三个巨大的 Simplify 来表明态度：我们要把极简主义进行到底！其中最大的简化就是将原有组件的功能完全整合入 &lt;strong&gt;Istiod&lt;/strong&gt; ，完成了悟天克斯们的合体过程，让 Istiod 更加完整，也彻底移除了 Citadel、Sidecar Injector 和 Galley。当然，你也可以理解为，这其实是对 1.5 版本未完成工作的收尾。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-龙珠-z&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;龙珠 Z&#34; srcset=&#34;
               /blog/istio-16-explain/007S8ZIlly1gf88vqhcgij307e08w0v2_hu25ca7e2cbfdad187686b7eafc41f4d9d_20893_141eb315c77785f87c8b476bd78ea8c9.webp 400w,
               /blog/istio-16-explain/007S8ZIlly1gf88vqhcgij307e08w0v2_hu25ca7e2cbfdad187686b7eafc41f4d9d_20893_0696535cb808231fa83a931ee2177d2c.webp 760w,
               /blog/istio-16-explain/007S8ZIlly1gf88vqhcgij307e08w0v2_hu25ca7e2cbfdad187686b7eafc41f4d9d_20893_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-16-explain/007S8ZIlly1gf88vqhcgij307e08w0v2_hu25ca7e2cbfdad187686b7eafc41f4d9d_20893_141eb315c77785f87c8b476bd78ea8c9.webp&#34;
               width=&#34;266&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      龙珠 Z
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第二项简化工作是添加 &lt;code&gt;istioctl install&lt;/code&gt; 命令来替代 &lt;code&gt;manifest apply&lt;/code&gt; 的安装过程，用更直观、更精简的命令改善安装过程的体验。当然，&lt;code&gt;manifest&lt;/code&gt; 子命令依然保留，你还是可以通过清单方式进行部署。在 Change Notes 的三十多项更新中，有七个是&lt;code&gt;removed&lt;/code&gt;，基本上都和安装有关，比如移除已经废弃的 Helm charts、&lt;code&gt;istio-pilot&lt;/code&gt;的配置等。可以看出，Istio 团队在极力的通过优化安装流程和部署形态来提升用户的体验。互联网产品有一个很重要的指标叫留存率，安装过程导致的用户流失是非常不值得的，需要花大力气进行流程的优化和调整。毕竟，第一印象的重要性毋庸置疑，以一个干练清爽的年轻人形象去相亲，还是扮演一个拖泥带水的油腻大叔？成功率高下立判。看来 Istio 团队终于醍醐灌顶，要努力做一个干练的奶油小生了。&lt;/p&gt;
&lt;p&gt;再来说说加法。Change Note 中的新增项主要来自四个方面：虚拟机的支持，遥测（Telemetry）的改进，升级，&lt;code&gt;istioctl&lt;/code&gt; 命令行。&lt;/p&gt;
&lt;p&gt;Istio 通过添加了一个叫 &lt;code&gt;WorkloadEntry&lt;/code&gt;  的自定义资源完成了对虚拟机的支持。它可以将非 Kubernetes 的工作负载添加到网格中，这使得你有能力为 VM 定义和 Pod 同级的 Service。而在以前，你不得不通过 ServiceEntry 里的 address 等字段，以曲线救国的方式去实现对非 Pod 工作负载的支持，丑陋又低效。&lt;code&gt;WorkloadEntry&lt;/code&gt; 的引入让非 Kubernetes 服务接入网格成为现实。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;WorkloadEntry&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;details-svc&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceAccount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;details-legacy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;vm1.vpc01.corp.net&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;details-legacy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;instance-id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;vm1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;遥测方面，增加了两个实验性的功能，一个是请求类别过滤器，主要用来对不同 API 方法的请求进行标记和分类；另一个是追踪配置 API，可以控制采用率等。除此之前，添加了 Prometheus 标准的抓取标注（annotation），提升了集成的体验。Grafana 的 Dashboard 也有&lt;a href=&#34;https://grafana.com/orgs/istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;更新&lt;/a&gt;，对终端用户来说这倒是可以期待一下。然而，我们最关心的 WASM 只字未提！笔者猜测它在可用性方面还有很多问题。ServiceMesher 社区有成员对 Istio 各个版本的遥测做了 benchmark，横向对比的结果是 WASM 方式下性能垫底！甚至还不如 1.3 版本。这让人不禁感慨，WASM 之于 Envoy，会不会只是一次看上去很美好的邂逅呢？&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-envoy-wasm&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;envoy-wasm&#34; srcset=&#34;
               /blog/istio-16-explain/007S8ZIlly1gf88kaci9ij31ha0lmgrm_hud0509abd08c7dde72414a0c387d6a80f_31798_76c1a56bbb97012f8d8a9c5de1ffdfb6.webp 400w,
               /blog/istio-16-explain/007S8ZIlly1gf88kaci9ij31ha0lmgrm_hud0509abd08c7dde72414a0c387d6a80f_31798_091da1a92e30f2bd74710b9152def2da.webp 760w,
               /blog/istio-16-explain/007S8ZIlly1gf88kaci9ij31ha0lmgrm_hud0509abd08c7dde72414a0c387d6a80f_31798_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-16-explain/007S8ZIlly1gf88kaci9ij31ha0lmgrm_hud0509abd08c7dde72414a0c387d6a80f_31798_76c1a56bbb97012f8d8a9c5de1ffdfb6.webp&#34;
               width=&#34;760&#34;
               height=&#34;309&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      envoy-wasm
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;center&gt;（图片引自几米漫画《向左走向右走》）&lt;/center&gt;
&lt;p&gt;为了能让升级过程更平滑，Istio 提供了一种叫金丝雀升级（Canary upgrades）的策略，可以安装一个金丝雀版本的控制平面，与老版本同时存在。金丝雀升级可以让你逐渐的切换流量以验证新版本的可用性，同时也保留了回滚的能力。当然，如果你足够自信，依然可以原地升级（In place upgrade)。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ istioctl install --set &lt;span class=&#34;nv&#34;&gt;revision&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;canary
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods -n istio-system
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                                    READY   STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istiod-786779888b-p9s5n                 1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          114m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istiod-canary-6956db645c-vwhsk          1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          1m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;令笔者惊奇的是，Istio 居然提供了降级（Downgrade）功能！这是因为开发团队对新版本不自信吗？如果说金丝雀升级已经提供了回滚的能力，那又何必为原地升级提供降级能力呢？而且降级也是有限制条件的：必须是 1.5 以上的版本；必须是使用 &lt;code&gt;istioctl&lt;/code&gt;安装的；必须使用老版本的 &lt;code&gt;istioctl&lt;/code&gt; 执行降级操作。笔者很难想象出它的适用场景，如果你知道，请一定告知我。&lt;/p&gt;
&lt;h2 id=&#34;向市场妥协&#34;&gt;向市场妥协&lt;/h2&gt;
&lt;p&gt;在虚拟机支持方面，Release Note 中有这样一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Expanding our support for workloads not running in Kubernetes was one of the our major areas of investment for 2020&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Istio 为什么要花大力气支持 VM 这种即将过气的部署载体？而且要作为 2020 年开发的重中之重？在理解这一举措之前，让我们先来看看 Google 的老对手 Amazon，在自家产品 AWS App Mesh 上的布局。&lt;/p&gt;
&lt;p&gt;从下图可以看出，AWS App Mesh 支持了自家的各种工作负载，当然也包括虚拟机和实体机。Amazon CTO Werner Vogers 在&lt;a href=&#34;https://www.allthingsdistributed.com/2019/03/redefining-application-communications-with-aws-app-mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 AWS App Mesh 重新定义服务通信&lt;/a&gt; 一文中写到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Our goal is to remove the undifferentiated heavy lifting of operating complex applications. We provide the tools, services, and observability to ensure that you can maintain high standards for your own architectures.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-appmesh&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;appmesh&#34; srcset=&#34;
               /blog/istio-16-explain/007S8ZIlly1gf804aiie4j30oz0dntaj_hufd2a4f0afd7da4b3cb5ea2469c2d7e42_53909_90d2e9313717bd39e6128b6549d4c73e.webp 400w,
               /blog/istio-16-explain/007S8ZIlly1gf804aiie4j30oz0dntaj_hufd2a4f0afd7da4b3cb5ea2469c2d7e42_53909_e568bd9bcf6f4d57d6f7a23bf7f7ca0f.webp 760w,
               /blog/istio-16-explain/007S8ZIlly1gf804aiie4j30oz0dntaj_hufd2a4f0afd7da4b3cb5ea2469c2d7e42_53909_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-16-explain/007S8ZIlly1gf804aiie4j30oz0dntaj_hufd2a4f0afd7da4b3cb5ea2469c2d7e42_53909_90d2e9313717bd39e6128b6549d4c73e.webp&#34;
               width=&#34;760&#34;
               height=&#34;415&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      appmesh
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种全方位部署形态的支持，其主要目的就是消除不同，给用户统一的接入体验。而这种不得已为之的策略，其实本质上是云原生应用落地的现状造成的。如果你多了解下身边不同公司的情况，你就会发现现实远比我们想象的要骨感。大量的中小企业都刚刚把上云提上日程，还有很多是实体机 / VM 和部分迁移到云的业务组成的混合体，其部署形态的复杂性可想而知。而 App Mesh 这种远瞻性的策略就是通过覆盖用户现有的各种部署形态，提前将未来全面上云的市场揽入怀中。当你的网格接入层无需变更时，只需要将 VM 之类的负载一一替换即可，最终完成云上的纯粹形态。&lt;/p&gt;
&lt;p&gt;我们再来看看 Istio 的同门师弟，Google Cloud Traffic Director 的情况。其&lt;a href=&#34;https://cloud.google.com/traffic-director/docs/traffic-director-concepts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;中有如下描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;按您的节奏进行现代化改造&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Traffic Director 既适用于基于虚拟机 (Compute Engine) 的应用，也适用于容器化应用（Google Kubernetes Engine 或自行管理的 Kubernetes），并能分阶段逐步运用于您的服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到这里我想你应该很清楚了，两大云厂商的网格产品无一例外地选择对 VM 支持，主要原因就是综合 Kubernetes、Service Mesh 落地现状，以及市场策略的考量。Istio 选择跟进无可厚非，且可以和自家产品互取所长，共享资源。我们是否可以大胆猜测一下：未来 Istio 可能会和 Traffic Director 兼容甚至合并？&lt;/p&gt;
&lt;p&gt;1.6 版本的最大变化，就是提供对虚拟机的支持，也是本年度的重点，其原因我们梳理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于云原生落地现状的考虑：无论是 Kubernetes、Service Mesh，还是云迁移，整个业界依然处于参差不齐的状态，部署形态复杂多变。对 VM 的支持可以为用户提供统一的接入体验，并平滑接入网格技术。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对抗（蚕食）竞争对手的市场：在收费的云平台，两大高手的策略旗鼓相当；而在开源方面，Istio 无疑是绝对的主角。同时在付费和免费两个层面统一战线，Istio 的这一神补刀，可以说击中了 AWS 的要害，这可能让本来摇摆不定的技术选型者改变主意。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回归平台中立的理念：Istio 一经推出就宣称具有多平台支持的能力，但两年下来大家都心照不宣，知道它对 Kubernetes 的强依赖性。提供 VM 支持正是去平台化的良机，为自己曾经立的 Flag 正名。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一个很可能属于市场宣传的行为就是高调宣称支持 Kubernetes Service APIs。对于一个还处于 alpha 版本的功能，如此大力地进行支持，再想想 Istio 与 Kubernetes 网络组的关系，不得不让人感觉有广告嫌疑。都是老熟人，互推一下也是应该的。不过亮相的略显刺眼，些许尴尬。&lt;/p&gt;
&lt;p&gt;第三个值得一说的是：开始提供新特性预览。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Added&lt;/strong&gt; a new profile, called &lt;code&gt;preview&lt;/code&gt;, allowing users to try out new experimental features that include WASM enabled telemetry v2.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;笔者看到这一项的第一反应：这不就是 AWS Preview 吗？AWS 通过这种方式把新功能提前释放给用户使用，以收集使用数据和建议，来改进功能，可以认为是一种 alpha 测试。Istio 的这一举动可以理解为终于要开始践行 MVP（最小化可行产品）理论了，毕竟从前脱离市场和用户，闭门造车的跟头栽得有点大，痛定思痛，终于选择和用户站在一边。&lt;/p&gt;
&lt;h2 id=&#34;重要的生态圈&#34;&gt;重要的生态圈&lt;/h2&gt;
&lt;p&gt;就在 1.6 发布不久前，一直致力于 Service Mesh 生态链产品开发的 solo.io 公司推出了第一个 Istio 开发者门户（&lt;a href=&#34;https://www.solo.io/blog/introducing-the-first-developer-portal-for-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Developer portal&lt;/a&gt;）。它可以对网格中运行的 API 进行分类，通过 webUI 提供 API 管理的可视化用户体验，同时还能自动地生成 Istio Gateway、VirtualService 这些自定义资源。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-portal&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;portal&#34; srcset=&#34;
               /blog/istio-16-explain/007S8ZIlly1gf86rih40pj31560fsdl5_hu6485f23e60e2e8e9568294bae27898e8_32970_08e559e7ecb78851641181d421eac9f6.webp 400w,
               /blog/istio-16-explain/007S8ZIlly1gf86rih40pj31560fsdl5_hu6485f23e60e2e8e9568294bae27898e8_32970_dfb740e0d8373a811c0bdcbe8b4a8494.webp 760w,
               /blog/istio-16-explain/007S8ZIlly1gf86rih40pj31560fsdl5_hu6485f23e60e2e8e9568294bae27898e8_32970_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-16-explain/007S8ZIlly1gf86rih40pj31560fsdl5_hu6485f23e60e2e8e9568294bae27898e8_32970_08e559e7ecb78851641181d421eac9f6.webp&#34;
               width=&#34;760&#34;
               height=&#34;291&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      portal
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;solo.io 和 Google Cloud 是&lt;a href=&#34;https://www.solo.io/company/partners/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;商业伙伴&lt;/a&gt;关系，旗下的产品 Gloo 和 Service Mesh Hub 都已经整合进了 GCP 和 GKE 中。而这一次发布 Portal 无疑又是一次双赢。&lt;/p&gt;
&lt;p&gt;Service Mesh 目前的市场格局并不明朗，依然是硝烟弥漫，产品都尚未定型，更不要说生态圈了。对 Goolge 而言，能提前将 solo.io 这样有实力的小弟招入麾下，围绕 Istio 打造一整套生态链产品，无疑会让 Istio 如虎添翼，也极有可能在市场竞争中增加重量级的砝码。&lt;/p&gt;
&lt;p&gt;而对于 solo.io 而言，作为初创公司，能和 Envoy 一样抱着 Service Mesh 头号网红的粗腿，既能持续地获得大量的曝光机会，又能为自己的产品带来持续增长的用户群体。这又让我想起在当年在游戏行业的一对 CP，Facebook 和 Zynga。Facebook 为 Zynga 输送了大量的用户，而 Zynga 的社交游戏又为 Facebook 的用户留存和黏性做出了贡献。至于后来的相爱相杀，那又是另外的故事了。我们回归正题，别说是 solo，换做是笔者本人，估计早都高喊着“土豪求做友”跪舔着不放手了。无论如何，solo.io 的一步妙棋，很可能会搅动整个棋局的变化，让我们拭目以待。&lt;/p&gt;
&lt;p&gt;生态圈的重要性无需多言，即便如 AWS 这种闭环生态的巨鳄，每年 Summit 也会把最大的展台留给众多 vendor，所谓一个好汉三个帮，谁都不会拒绝有实力的伙伴补强你的实力，玩 LOL 的的朋友会感慨，辅助是多么的重要！Java 叱咤风云二十五年，全靠以 Spring 为首的大将们强力补刀；Golang 若不是没有一个强大的、统一的标准化的生态，估计早把 Java 按在地上摩擦了。再反观日本的动漫产业，再优秀的作品，如果没有丰富的周边和产业链，GDP 要小上几个数量级，恐怕二次元的小弟弟小妹妹们都会少了很多精神寄托吧。&lt;/p&gt;
&lt;h2 id=&#34;期许和无奈&#34;&gt;期许和无奈&lt;/h2&gt;
&lt;p&gt;在 InfoQ 最新发布的“技术采用生命周期”调查报告中，将 Istio、Service Mesh 放入了早期采用者这一列，这其实也从应用和市场层面反映出了它们仍处在产品发展的前期，任重道远。产品有限的成熟度制约了技术选型的空间，反过来市场的谨小慎微又让产品缺少了来自实践端的经验和积累。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-infoq&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;infoq&#34; srcset=&#34;
               /blog/istio-16-explain/007S8ZIlly1gf87rq8kvfj31ec0ow777_hubb8d351d67428cfd06adf516aa00fb19_37283_cb6f849166e37ee74948612997cf3a62.webp 400w,
               /blog/istio-16-explain/007S8ZIlly1gf87rq8kvfj31ec0ow777_hubb8d351d67428cfd06adf516aa00fb19_37283_0f3ac554c5ca0146c1ba1850272453e0.webp 760w,
               /blog/istio-16-explain/007S8ZIlly1gf87rq8kvfj31ec0ow777_hubb8d351d67428cfd06adf516aa00fb19_37283_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-16-explain/007S8ZIlly1gf87rq8kvfj31ec0ow777_hubb8d351d67428cfd06adf516aa00fb19_37283_cb6f849166e37ee74948612997cf3a62.webp&#34;
               width=&#34;760&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      infoq
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本次 1.6 版本的发布我个人认为是惊喜不足，失望有余。Mixer 的寿终正寝让中心化的限流、黑白名单这样有用的功能也跟着陪了葬，还未看到要弥补它们的打算。而期待的 Envoy 与 WebAssembly 的强强联手也在本次更新中只字未提。当然了，产品迭代哪能一蹴而就，时间、成本、质量三要素缺一不可。一统江山的 Kubernetes 到了 1.8 才算是稳定版本，何况现在的 1.18，而我们的 Istio 才刚刚到 1.6 而已，还需要更多的时间来沉淀。&lt;/p&gt;
&lt;p&gt;前路漫长，但仍可期许，让我们未来见分晓。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>拥抱变化 —— Istio 1.5 新特性解读</title>
      <link>https://cloudnative.to/blog/istio-1-5-explanation/</link>
      <pubDate>Tue, 03 Mar 2020 10:00:06 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-1-5-explanation/</guid>
      <description>&lt;h2 id=&#34;引子&#34;&gt;引子&lt;/h2&gt;
&lt;p&gt;Istio 1.5 是一个具有重大变革的版本。长久以来，面对社区对 Istio 的性能和易用性的诟病，Istio 团队终于正视自身的问题，在当前版本中彻底推翻了原有控制平面的架构，完成了重建。正如 &lt;a href=&#34;https://docs.google.com/document/d/1v8BxI07u-mby5f5rCruwF7odSXgb9G8-C9W5hQtSIAg/edit#heading=h.xw1gqgyqs5b&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Simplified Istio&lt;/a&gt; 文中所说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;复杂是万恶之源，让我们停止焦虑，爱上单体。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Istio 1.5 回归单体，无论架构和使用方式都发生了巨大变化。因此笔者决定对 1.5 的变化内容做深入解读，以便开发者可以更好的理解和学习新版本，为使用和升级提供参考。&lt;/p&gt;
&lt;h2 id=&#34;架构调整&#34;&gt;架构调整&lt;/h2&gt;
&lt;p&gt;这部分主要分析 Istio 1.5 在架构上的调整，这也是该版本最核心的变化。主要包括重建了控制平面，将原有的多个组件整合为一个单体结构 &lt;code&gt;istiod&lt;/code&gt;；同时废弃了被诟病已久的 Mixer 组件。还对是否向后兼容的部分也做了说明，如果你要从 1.4.x 版本升级到 1.5 必须知道这些变化。&lt;/p&gt;
&lt;h3 id=&#34;重建控制平面&#34;&gt;重建控制平面&lt;/h3&gt;
&lt;p&gt;官方使用的是重建（Restructuring）而不是重构（Refactoring）一词，可见其变化之大。在 Istio 1.5 中，控制平面将使用新的部署模式，将原有的各个组件整合在一起。&lt;/p&gt;
&lt;h4 id=&#34;istiod&#34;&gt;Istiod&lt;/h4&gt;
&lt;p&gt;Istio 1.5 中会使用一个全新的部署模式：&lt;code&gt;istiod&lt;/code&gt;。这个组件是控制平面的核心，负责处理配置、证书分发、sidecar 注入等各种功能。&lt;code&gt;istiod&lt;/code&gt; 是新版本中最大的变化，以一个单体组件替代了原有的架构，在降低复杂度和维护难度的同时，也让易用性得到提升。需要注意的一点是，原有的多组件并不是被完全移除，而是在重构后以模块的形式整合在一起组成了 &lt;code&gt;istiod&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;sidecar-注入&#34;&gt;Sidecar 注入&lt;/h4&gt;
&lt;p&gt;以前版本的 sidecar 注入是由 &lt;code&gt;istio-sidecar-injector&lt;/code&gt; webhook 实现的。在新版本中 webhook 保留了下来，但整合进了 &lt;code&gt;istiod&lt;/code&gt; 中，注入逻辑保持不变。&lt;/p&gt;
&lt;h4 id=&#34;galley&#34;&gt;Galley&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;配置验证 - 功能保留，并入 &lt;code&gt;istiod&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;MCP Server - 改为默认关闭。对于大多数用户来说只是一个实现细节。如果确定依赖它，需要部署 &lt;code&gt;istio-galley&lt;/code&gt; 并启动其进程。&lt;/li&gt;
&lt;li&gt;实验特性（例如配置分析）- 也需要部署 &lt;code&gt;istio-galley&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;citadel&#34;&gt;Citadel&lt;/h4&gt;
&lt;p&gt;以前 Citadel 的 2 个功能是生成证书以及 SDS 开启时以 &lt;code&gt;gRPC&lt;/code&gt; 方式向 &lt;code&gt;nodeagent&lt;/code&gt; 提供密钥。1.5 版本中密钥不再写入每个命名空间，只通过 gRPC 提供。这一功能也被并入 &lt;code&gt;istiod&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;sds-节点代理&#34;&gt;SDS 节点代理&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;nodeagent&lt;/code&gt; 被移除。&lt;/p&gt;
&lt;h4 id=&#34;sidecar&#34;&gt;Sidecar&lt;/h4&gt;
&lt;p&gt;以前，sidecar 能以两种方式访问证书：以文件挂载的密钥；SDS。新版本中所有密钥都存在本地运行的 SDS 服务器上。对绝大部分用户来说只需要从 &lt;code&gt;istiod&lt;/code&gt; 中获取。对于自定义 CA 的用户，仍然可以挂载文件密钥，不过仍然由本地 SDS 服务器提供。这意味着证书轮询将不再需要 Envoy 重启。&lt;/p&gt;
&lt;h4 id=&#34;cni&#34;&gt;CNI&lt;/h4&gt;
&lt;p&gt;CNI 没有改变，仍在 &lt;code&gt;istio-cni&lt;/code&gt; 中。&lt;/p&gt;
&lt;h4 id=&#34;pilot&#34;&gt;Pilot&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;istio-pilot&lt;/code&gt; 的独立组件和进程被移除，由包含了它全部功能的 &lt;code&gt;istiod&lt;/code&gt; 取而代之。为了向后兼容，仍有少许对 Pilot 的引用。&lt;/p&gt;
&lt;h3 id=&#34;废弃-mixer&#34;&gt;废弃 Mixer&lt;/h3&gt;
&lt;p&gt;在 Istio 1.5 中 Mixer 被废弃了。默认情况下 &lt;code&gt;mixer&lt;/code&gt; 完全关闭。遥测的 V2 版本在新版本中是默认特性且不需要 &lt;code&gt;mixer&lt;/code&gt;。如果你对 Mixer 的特殊功能有依赖，比如进程外适配器，需要重新开启 Mixer。Mixer 还会持续修复 bug 和安全漏洞直到 Istio 1.7 版本。&lt;code&gt;mixer&lt;/code&gt; 的许多功能在 &lt;a href=&#34;https://tinyurl.com/mixer-deprecation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mixer Deprecation&lt;/a&gt; 文档中都描述了替代方案，包括基于 Wasm sandbox API 的 &lt;a href=&#34;https://github.com/istio/proxy/tree/master/extensions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;in-proxy 扩展&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;新版本中 HTTP 遥测默认基于 in-proxy Stats filter。这节省了 50% 的 CPU 使用量。1.5 中的遥测 V2 和老版本主要有以下几点不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量的来源和目标如果没有注入 sidecar，部分遥测信息将无法收集。&lt;/li&gt;
&lt;li&gt;Egress 遥测不再支持。&lt;/li&gt;
&lt;li&gt;Histogram bucketization 和 V1 版本有很大不同。&lt;/li&gt;
&lt;li&gt;TCP 遥测只支持 mTLS。&lt;/li&gt;
&lt;li&gt;需要更多的 Prometheus 实例来收集所有代理的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果开发者之前使用的是 Istio 默认的 HTTP 遥测，迁移到新版本是没问题的。可以直接通过 &lt;code&gt;istioctl upgrade&lt;/code&gt; 自动升级到 V2。&lt;/p&gt;
&lt;p&gt;最被社区开发者唾弃的 Mixer 终于被废弃，可以说它是影响老版本性能的罪魁祸首。现在皆大欢喜，甚至呼声最高的 Wasm 方案也提上日程。当然我们也能看出 Istio 团队为了保证老版本的升级依赖并没有一刀切的干掉 Mixer，持续修复 bug 到 1.7 版本的深层含义是它会在 1.7 的时候被彻底移除？&lt;/p&gt;
&lt;h3 id=&#34;控制平面安全&#34;&gt;控制平面安全&lt;/h3&gt;
&lt;p&gt;老版本中，当设置了 &lt;code&gt;values.global.controlPlaneSecurityEnabled=true&lt;/code&gt; 时，代理将安全地与控制平面交互，这是 1.4 版本的默认配置。每个控制平面组件都有一个带有 Citadel 证书的 sidecar，代理通过端口 15011 连接到 Pilot。&lt;/p&gt;
&lt;p&gt;新版本中，不再推荐或以默认方式将代理连接到控制平面。作为替代，使用由 Kubernetes 或 Istiod 签发的 DNS 证书。代理通过端口 15012 连接到 Pilot。&lt;/p&gt;
&lt;h2 id=&#34;功能更新&#34;&gt;功能更新&lt;/h2&gt;
&lt;p&gt;Istio 1.5 不仅仅做了减法，也做了很多加法，包括添加了新的功能，性能优化和 Bug 修复。这一部分列举了新版本中在流量管理、安全、遥测等多个功能方面的改进。&lt;/p&gt;
&lt;h3 id=&#34;流量管理&#34;&gt;流量管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提升了 &lt;code&gt;ServiceEntry&lt;/code&gt; 的性能。&lt;/li&gt;
&lt;li&gt;修复了 readiness 探针不一致问题。&lt;/li&gt;
&lt;li&gt;通过定向局部更新的方式改善了配置更新的性能。&lt;/li&gt;
&lt;li&gt;添加了为 host 设置所在负载均衡器设置的选项。&lt;/li&gt;
&lt;li&gt;修复了 Pod 崩溃会触发过度配置推送的问题。&lt;/li&gt;
&lt;li&gt;修复了应用调用自己的问题。&lt;/li&gt;
&lt;li&gt;添加了使用 Istio CNI 时对 &lt;code&gt;iptables&lt;/code&gt; 的探测。&lt;/li&gt;
&lt;li&gt;添加了 &lt;code&gt;consecutive_5xx&lt;/code&gt; 和 &lt;code&gt;gateway_errors&lt;/code&gt; 作为离群值探测选项。&lt;/li&gt;
&lt;li&gt;提升了 &lt;code&gt;EnvoyFilter&lt;/code&gt; 匹配性能优化。&lt;/li&gt;
&lt;li&gt;添加了对 &lt;code&gt;HTTP_PROXY&lt;/code&gt; 协议的支持。&lt;/li&gt;
&lt;li&gt;改进了 &lt;code&gt;iptables&lt;/code&gt; 设置，默认使用 &lt;code&gt;iptables-restore&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;默认开启&lt;a href=&#34;https://istio.io/docs/ops/configuration/traffic-management/protocol-selection/#automatic-protocol-selection-experimental&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自动协议探测&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;安全&#34;&gt;安全&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;添加 Beta 认证 API。新 API 分为 &lt;code&gt;PeerAuthentication&lt;/code&gt; 和 &lt;code&gt;RequestAuthenticaiton&lt;/code&gt;，面向工作负载。&lt;/li&gt;
&lt;li&gt;添加认证策略，支持 deny 操作和语义排除。&lt;/li&gt;
&lt;li&gt;Beta 版本默认开启自动 mTLS。&lt;/li&gt;
&lt;li&gt;稳定版添加 SDS。&lt;/li&gt;
&lt;li&gt;Node agent 和 Pilot agent 合并，移除了 Pod 安全策略的需要，提升了安全性。&lt;/li&gt;
&lt;li&gt;合并 Citadel 证书发放功能到 Pilot。&lt;/li&gt;
&lt;li&gt;支持 Kubernetes &lt;code&gt;first-party-jwt&lt;/code&gt; 作为集群中 CSR 认证的备用 token。&lt;/li&gt;
&lt;li&gt;通过 Istio Agent 向 Prometheus 提供密钥和证书。&lt;/li&gt;
&lt;li&gt;支持 Citadel 提供证书给控制平面。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;遥测&#34;&gt;遥测&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为 v2 版本的遥测添加 TCP 协议支持。&lt;/li&gt;
&lt;li&gt;在指标和日志中支持添加 gRPC 响应状态码。&lt;/li&gt;
&lt;li&gt;支持 Istio Canonical Service&lt;/li&gt;
&lt;li&gt;改进 v2 遥测流程的稳定性。&lt;/li&gt;
&lt;li&gt;为 v2 遥测的可配置性提供 alpha 级别的支持。&lt;/li&gt;
&lt;li&gt;支持在 Envoy 节点的元数据中添加 AWS 平台的元数据。&lt;/li&gt;
&lt;li&gt;更新了 Mixer 的 Stackdriver 适配器，以支持可配置的刷新间隔来跟踪数据。&lt;/li&gt;
&lt;li&gt;支持对 Jaeger 插件的 headless 收集服务。&lt;/li&gt;
&lt;li&gt;修复了 &lt;code&gt;kubernetesenv&lt;/code&gt; 适配器以提供对名字中有&lt;code&gt;.&lt;/code&gt;的 Pod 的支持。&lt;/li&gt;
&lt;li&gt;改进了 Fluentd 适配器，在导出的时间戳中提供毫秒级输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;operator&#34;&gt;Operator&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用 &lt;code&gt;IstioOperator&lt;/code&gt; API 替代了 &lt;code&gt;IstioControlPlane&lt;/code&gt; API。&lt;/li&gt;
&lt;li&gt;添加了 &lt;code&gt;istioctl operator init&lt;/code&gt; 和 &lt;code&gt;istioctl operator remove&lt;/code&gt; 命令。&lt;/li&gt;
&lt;li&gt;添加缓存改善了调和速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;性能和扩展性&#34;&gt;性能和扩展性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为网关生成集群时忽略没用的服务。&lt;/li&gt;
&lt;li&gt;为 headless 服务略过调用 &lt;code&gt;updateEDS&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 ingress 网关中默认关闭 &lt;code&gt;SNI-DNAT&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;错误覆盖声明。&lt;/li&gt;
&lt;li&gt;容量已知时，基于容量创建切片。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;测试和发布&#34;&gt;测试和发布&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为 &lt;code&gt;istioctl&lt;/code&gt; 创建了 Docker 镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;istioctl&#34;&gt;istioctl&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;添加 mTLS 分析器。&lt;/li&gt;
&lt;li&gt;添加 JwtAnalyzer。&lt;/li&gt;
&lt;li&gt;添加 ServiceAssociationAnalyzer。&lt;/li&gt;
&lt;li&gt;添加 SercretAnalyaer。&lt;/li&gt;
&lt;li&gt;添加 sidecar ImageAnalyzer。&lt;/li&gt;
&lt;li&gt;添加 PortNameAnalyzer。&lt;/li&gt;
&lt;li&gt;添加 Policy DeprecatedAnalyzer。&lt;/li&gt;
&lt;li&gt;为 &lt;code&gt;RequestAuthentication&lt;/code&gt; 添加了更多的验证规则。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;istioctl analyze&lt;/code&gt; 从实验特性转为正式特性。&lt;/li&gt;
&lt;li&gt;添加新标记 &lt;code&gt;-A|--all-namespaces&lt;/code&gt; 给 &lt;code&gt;istioctl analyze&lt;/code&gt;，来分析整个集群。&lt;/li&gt;
&lt;li&gt;添加通过 &lt;code&gt;stdin&lt;/code&gt; 到 &lt;code&gt;istioctl analyze&lt;/code&gt; 的内容分析。&lt;/li&gt;
&lt;li&gt;添加 &lt;code&gt;istioctl analyze -L&lt;/code&gt; 显示所有可用分析列表。&lt;/li&gt;
&lt;li&gt;添加从 &lt;code&gt;istioctl analyze&lt;/code&gt; 抑制信息的能力。&lt;/li&gt;
&lt;li&gt;为 &lt;code&gt;istioctl analyze&lt;/code&gt; 添加结构化格式选项。&lt;/li&gt;
&lt;li&gt;为 &lt;code&gt;istioctl analyze&lt;/code&gt; 的输出添加对应的文档链接。&lt;/li&gt;
&lt;li&gt;通过 Istio API 在分析器中提供标注方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;istioctl analyze&lt;/code&gt; 可以基于目录加载文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;istioctl analyze&lt;/code&gt; 尝试将消息与它们的源文件名关联。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;istioctl analyze&lt;/code&gt; 可打印命名空间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;istioctl analyze&lt;/code&gt; 默认分析集群内资源。&lt;/li&gt;
&lt;li&gt;修复分析器抑制集群级别资源消息的 bug。&lt;/li&gt;
&lt;li&gt;为 &lt;code&gt;istioctl manifest&lt;/code&gt; 添加多文件支持。&lt;/li&gt;
&lt;li&gt;替换 &lt;code&gt;IstioControlPlane&lt;/code&gt; API 为 &lt;code&gt;IstioOperator&lt;/code&gt; API。&lt;/li&gt;
&lt;li&gt;为 &lt;code&gt;istioctl dashboard&lt;/code&gt; 添加选择器。&lt;/li&gt;
&lt;li&gt;为 &lt;code&gt;istioctl manifest --set&lt;/code&gt; 标记添加切片和列表支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Istio 1.5 是全面拥抱变化的一个版本。重建整个控制平面，打造了全新的部署模式 &lt;code&gt;istiod&lt;/code&gt;；摒弃了拖累系统性能的 Mixer；保证兼容性也不忘持续优化和引入新的功能。在彻底抛弃历史包袱的同时，Istio 团队也用他们的勇气践行了敏捷开发的真谛。随着稳定的季度发布，相信未来的 Istio 会越加成熟。让我们拭目以待。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>回归单体 —— Istio 的自我救赎？</title>
      <link>https://cloudnative.to/blog/istio-self-salvation/</link>
      <pubDate>Thu, 23 Jan 2020 10:00:06 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-self-salvation/</guid>
      <description>&lt;h2 id=&#34;引子&#34;&gt;引子&lt;/h2&gt;
&lt;p&gt;早在 2019 年底的 KubeConNA 中，Google API 基础设施的架构师 Louis Ryan 就透露了 Istio 控制平面架构将要进行调整的消息。从即将发布的 1.5 版本开始，原本多个独立的组件将会整合在一起，成为一个单体结构。相信每个开发者都能意识到架构调整会带来什么样的后果。这一重磅消息也促使笔者决定著成此文，以告天下拥趸：变化有风险，落地需谨慎！&lt;/p&gt;
&lt;h2 id=&#34;原罪&#34;&gt;原罪&lt;/h2&gt;
&lt;h3 id=&#34;解耦是罪&#34;&gt;解耦是罪？&lt;/h3&gt;
&lt;p&gt;这并不是 Istio 第一次调整架构了。号称 Production ready 的 1.0 版本在后续的 1.1 版本就进行了比较大的调整，分离了 Pilot 的配置下发功能到新的 Galley 组件中，将 Mixer 组件中原本进程内运行的 Plugin 改为了进程外运行的 adapter，进一步加剧了 Mixer 组件的性能问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-arch1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;arch1&#34; srcset=&#34;
               /blog/istio-self-salvation/006tNbRwly1gb5pmk8xe4j32140og102_hu7cef7e87138396e87f931b07857a96c0_42189_c84837ff690ac5b73b15fb7269e751fe.webp 400w,
               /blog/istio-self-salvation/006tNbRwly1gb5pmk8xe4j32140og102_hu7cef7e87138396e87f931b07857a96c0_42189_872e57891a3e8cd0b2a84a96ac83e4f3.webp 760w,
               /blog/istio-self-salvation/006tNbRwly1gb5pmk8xe4j32140og102_hu7cef7e87138396e87f931b07857a96c0_42189_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-self-salvation/006tNbRwly1gb5pmk8xe4j32140og102_hu7cef7e87138396e87f931b07857a96c0_42189_c84837ff690ac5b73b15fb7269e751fe.webp&#34;
               width=&#34;760&#34;
               height=&#34;254&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      arch1
    &lt;/figcaption&gt;&lt;/figure&gt;

坦白讲，如果抛开性能问题，笔者个人非常喜欢 Istio 1.1 的架构设计。它是贯彻解耦原则的典范，各个组件职责清晰，界限分明，所谓真正的设计优雅。1.1 版本的控制平面包括了下面几个组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pilot：数据平面配置中心；&lt;/li&gt;
&lt;li&gt;Mixer: 负责 Telemetry，聚合指标信息到多种后端（Back-end Adapter）；实现策略支持；&lt;/li&gt;
&lt;li&gt;Galley: 配置的监听、验证和转发；&lt;/li&gt;
&lt;li&gt;Citadel: 安全相关，证书签发、Secret 生成、CA 集成等；&lt;/li&gt;
&lt;li&gt;Injector：数据平面的注册和初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些组件分工且协作，共同组成了完整的控制平面。&lt;/p&gt;
&lt;p&gt;但是，银弹效应再次应验，在软件的设计与开发过程中我们从来就不可能在天平的一端站稳脚跟。选择极致的代价就是掀翻这一平衡。你唯一能做的就是在设计天平的横杆上来来回回的验证并找到最佳的平衡点。但必须承认，对于一个追求完美的架构师来讲，这一过程是异常痛苦的。Istio 在构建完美架构的同时忽略了易用性和性能问题。本是后起之秀却能完美开局，如今正是要酣畅淋漓地开疆拓土之时，却似乎有流局的风险，令人唏嘘不已。&lt;/p&gt;
&lt;p&gt;解耦当然不是原罪，它是推动软件架构变革的原动力。从单体到分层，再到服务化，每一次进化都是解耦思想的印证。但是，我们一定不能忘记，在软件设计领域中，解耦充其量只能是第二原则，它必须为第一原则让步，而这第一原则，就是设计的本质：取舍（trade off）。&lt;/p&gt;
&lt;p&gt;Istio 取舍不利是造成现在这种状况的首要原因。&lt;/p&gt;
&lt;h3 id=&#34;设计的取舍&#34;&gt;设计的取舍&lt;/h3&gt;
&lt;p&gt;我们经常说系统要具有可扩展性；另一方面，我们又要小心矫枉过正，以免出现过度设计。既要有预知变化的宽容度，又得避免写出永远也不会运行到的“dead code”。取舍，在设计阶段贯穿始终。&lt;/p&gt;
&lt;p&gt;任何一个系统都是由一粒种子成长为参天大树的，Istio 也不例外。唯一不同的是，它从 0.1 版本刚刚问世就已经枝繁叶茂，功能强大，胸怀宇宙。我们现在很难评断当初的设计是不正确的。但 2 年的市场检验已然说明了问题，完善和强大在某种程度上就是复杂和易用性的缺失，Istio 的落地项目少的可怜。Envoy（Istio 的御用数据平面）的缔造者 Matt Keiln 在自己的 Twitter 上评价了 Service Mesh 的落地情况，他用带引号的反语表达了自己的无奈：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-self-salvation/006tNbRwly1gb35aom737j30wi0ca41b_huc814bee01faf02d4ac51e2759da463b6_77515_6caefb4c4cbc53b55ae68623b715ff9b.webp 400w,
               /blog/istio-self-salvation/006tNbRwly1gb35aom737j30wi0ca41b_huc814bee01faf02d4ac51e2759da463b6_77515_974a32de38affc1f249fe66f2f8fb709.webp 760w,
               /blog/istio-self-salvation/006tNbRwly1gb35aom737j30wi0ca41b_huc814bee01faf02d4ac51e2759da463b6_77515_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-self-salvation/006tNbRwly1gb35aom737j30wi0ca41b_huc814bee01faf02d4ac51e2759da463b6_77515_6caefb4c4cbc53b55ae68623b715ff9b.webp&#34;
               width=&#34;760&#34;
               height=&#34;287&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;实践是检验真理的唯一标准，没人用的背后，很可能就是不易使用，设计与实现脱节。关于复杂难用这一点，读者可以自行通过接入一个 Mixer 的 adapter 就能深刻的体会到了（挂载一个 backend 居然要定义 instance，handler，rule 等一系列繁复的配置信息）。&lt;/p&gt;
&lt;p&gt;软件设计之初的原型一定是简洁甚至简陋的，仅仅包含基本的用例和愿景。这就好比一个交通工具的核心是出行能力，那么我们可以选择从最便捷的自行车开始设计并不断完善。而 Istio 一经问世便能力非凡，俨然是一辆保时捷 911，马力强大配置豪华，其结果就是，大部分人都买不起。&lt;/p&gt;
&lt;p&gt;笔者依然相信 Istio 团队的设计初衷是好的，其愿景是尽可能的去诠释出 Service Mesh 的最终形态。但很可惜，这种高瞻远瞩脱离现实太远，反而成了空中楼阁。&lt;/p&gt;
&lt;h3 id=&#34;复杂是万恶之源&#34;&gt;复杂是万恶之源&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Complexity is the root of all evil or: How I Learned to Stop Worrying and Love the Monolith.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Istiod 的 design 文档 &lt;a href=&#34;https://docs.google.com/document/d/1v8BxI07u-mby5f5rCruwF7odSXgb9G8-C9W5hQtSIAg/edit#heading=h.xw1gqgyqs5b&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Simplified Istio (istiod)&lt;/a&gt; 的卷首，设计团队就喊出了上面的口号：&lt;strong&gt;复杂是万恶之源，停止焦虑，学会爱上单体&lt;/strong&gt;。可见 Istio 开发团队下定决心要进行变革，其根本目标就是消除现有架构的复杂性。&lt;/p&gt;
&lt;p&gt;多组件架构带来的复杂性最直接的体现就是部署和维护上。1.4 版本的 CRD 有 24 个之多，远大于 AWS App Mesh 这种托管产品（只有 3 个）。&lt;code&gt;istio-system&lt;/code&gt; 部署后的 Deployment 也是数量惊人。简化部署和提升可维护性的方式，就是构建一个单一的 istiod，将原有各个核心组件的功能整合在一起。&lt;/p&gt;
&lt;p&gt;另外，还会以 JWT 等方式简化数据平面到控制平面的身份验证，构建一个独立的 istio-agent，使得 istiod 可以运行在集群、VM 或本地服务器而不需要 RBAC 权限。很明显，Istio 终于开始认真考虑用户生产环境的复杂性，并和现有的托管产品（App Mesh, Traffic director）靠拢，开始提供对 VM 的支持。&lt;/p&gt;
&lt;p&gt;Istio 架构的复杂性主要表现在以下几方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从维护的角度看，架构中的多个组件如果交由不同的团队（个人）去维护的确是合理的。但实际情况是，整个 Istio 的搭建通常都是由一个团队甚至一个人去完成的，分离的组件变的毫无必要，且增加了部署和维护复杂性；&lt;/li&gt;
&lt;li&gt;Istio 的各个组件是否支持单独部署？恐怕单独部署的组件并不能工作。版本变更也需要对全部组件一起更新，那分离的意义何在？&lt;/li&gt;
&lt;li&gt;从伸缩（scaling）的角度讲，分离的组件会更加有效，可以让成本更低。但在 Istio 的架构中，控制平面的成本受单一的因素（服务于 xDS）影响，致使分离的价值很小。&lt;/li&gt;
&lt;li&gt;不同的组件如果在部署中具有不同的安全角色，那么这种隔离是有意义的。但实际上这些组件在默认安装中具有相同的地位，用户几乎不会修改其权限，所有组件都统一安装在 &lt;code&gt;istio-system&lt;/code&gt; 这一命名空间下。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此以外，更新维护也会涉及到大量的修改。这些因素大大增加了用户对 Istio 的刻板印象：安装和管理复杂，维护成本高。&lt;/p&gt;
&lt;h2 id=&#34;救赎&#34;&gt;救赎&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;istiod&lt;/code&gt; 是即将发布的 1.5 版本中出现的一个单体应用（单一二进制文件），它整合了现有架构中各组件的功能，使开发者可以获得更好的运维体验。Istio 的自我救赎之路即将开始。&lt;/p&gt;
&lt;h3 id=&#34;目标&#34;&gt;目标&lt;/h3&gt;
&lt;p&gt;重构的愿景是提升易用性和降低复杂性，设计文档中给出了以下具体的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低安装复杂性&lt;/li&gt;
&lt;li&gt;降低配置复杂性&lt;/li&gt;
&lt;li&gt;提升控制平面可维护性&lt;/li&gt;
&lt;li&gt;问题诊断更容易&lt;/li&gt;
&lt;li&gt;提高效率和响应速度&lt;/li&gt;
&lt;li&gt;消除不必要的耦合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;聚合并不意味着耦合，组件化依然会在单体中继续维护。所以我们无需担心泥球（Mud ball）状的系统，系统会高内聚但内部低耦合，对用户透明。同时，实验性的功能也不再提供（果然有过度设计），保证 istiod 的高度可用。&lt;/p&gt;
&lt;p&gt;文档中提到新的设计和最初在实验阶段实现的 &lt;code&gt;hyperistio&lt;/code&gt; 非常类似。可见笔者上文所述原型阶段的种子是真实存在的。恭喜 Istio，轮回转生。&lt;/p&gt;
&lt;h3 id=&#34;功能和形态&#34;&gt;功能和形态&lt;/h3&gt;
&lt;p&gt;原有组件的功能会整合为如下 2 部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;istiod：合并了除 Mixer 之外的大部分组件功能，成为新的控制平面；&lt;/li&gt;
&lt;li&gt;istio-agent：私钥生成，本地 SDS 服务器，启动 Envoy 等；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时也删除了部分功能，单体形态也消除了大量的配置项，以及组件通信带来的复杂性。未来大概率情况下，用户只需要维护一个 &lt;code&gt;mesh.yaml&lt;/code&gt; 的配置文件来定义自己的 mesh，而不是现在要组合各种繁复的自定义资源。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-self-salvation/006tNbRwly1gb5rbulcsxj30jk0c2gmd_hu6fdc2a2da7984ae62a2c2d83aa427013_37955_69150bcd4252bbda1cf8c0533a2669ce.webp 400w,
               /blog/istio-self-salvation/006tNbRwly1gb5rbulcsxj30jk0c2gmd_hu6fdc2a2da7984ae62a2c2d83aa427013_37955_111c4ddccb36007580756e3e5115f05a.webp 760w,
               /blog/istio-self-salvation/006tNbRwly1gb5rbulcsxj30jk0c2gmd_hu6fdc2a2da7984ae62a2c2d83aa427013_37955_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-self-salvation/006tNbRwly1gb5rbulcsxj30jk0c2gmd_hu6fdc2a2da7984ae62a2c2d83aa427013_37955_69150bcd4252bbda1cf8c0533a2669ce.webp&#34;
               width=&#34;704&#34;
               height=&#34;434&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在运行层面，新架构提供了更多的选择方式，以应对不同的开发环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Kubernetes 集群中运行；&lt;/li&gt;
&lt;li&gt;在 Kubernetes 集群中运行，对单独的 namespace 生效；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minion&lt;/code&gt; 集群代理模式 - 这种模式是指安装在当前集群的 istiod 会作为远程 istiod 的代理，为本地集群提供相应的控制平面功能。也可以反向的推送到远端集群。这使得将新集群接入到已有的 mesh 更加方便；&lt;/li&gt;
&lt;li&gt;集群外运行；&lt;/li&gt;
&lt;li&gt;静态配置运行；&lt;/li&gt;
&lt;li&gt;在 Pod 中运行代理；&lt;/li&gt;
&lt;li&gt;本地运行代理；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多运行方式的提供是向现有生产环境多样化的妥协。通过多种方式适配环境，从而降低接入难度。同时和托管的云产品保持一致的体验。&lt;/p&gt;
&lt;h3 id=&#34;再谈设计&#34;&gt;再谈设计&lt;/h3&gt;
&lt;h4 id=&#34;重构阶段&#34;&gt;重构阶段&lt;/h4&gt;
&lt;p&gt;愿景清晰，目标明确。这一次，Istio 在设计上的取舍会是怎样的呢？文档中将其划分为 3 个阶段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阶段 1：科学怪人的怪兽（Frankenstein&amp;rsquo;s Monster）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;科学怪人是一部著名的美国电影，讲述了一个天才科学家创造了一个怪物最终被其毁灭的故事。Istio 团队为何要以它来自嘲呢？笔者在豆瓣的电影介绍中看到这样一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;弗兰肯斯坦（科林·克利夫 Colin Clive 饰）是一个天才科学家，他想像上帝一样创造生命&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用如此极端的类比来比喻 Istio，笔者武断的认为其本意是：Istio 本想扮演上帝一般的角色（统一 Service Mesh 江湖，成为微服务架构的事实标准），却因为过度设计与现实脱离，成为了一个怪兽（monster）。因此，重构的第一阶段，就是从肢解怪兽开始。&lt;/p&gt;
&lt;p&gt;在旧的架构中，Istio 启动过程复杂且依赖于顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Citadel 要先启动为其他组件生成证书；&lt;/li&gt;
&lt;li&gt;Galley 要先监控 apiserver；&lt;/li&gt;
&lt;li&gt;Pilot 要 Galley 准备好才能启动；&lt;/li&gt;
&lt;li&gt;autoinject 需要 Pilot 启动完成；&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本来是解耦合的组件，却因为启动过程耦合在了一起，维护性可想而知。合并后将消除这些启动依赖，并支持多版本同时运行，以满足升级或者灰度部署的需要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阶段 2：深度清理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一阶段将会着重清除不必要的相互依赖和不支持的用例，以便系统更加的高效和干净。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阶段 3：管道（pipeline）重构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此阶段的工作可以大致分为工程卫生，效率和可维护性工作。&lt;/p&gt;
&lt;h4 id=&#34;安装配置的影响&#34;&gt;安装、配置的影响&lt;/h4&gt;
&lt;p&gt;简化后的控制平面单元将由：mesh.yaml，CRD，集群 role 和 binding，istio-system 命名空间这几部分组成。安装过程不再有顺序上的依赖。配置也精练到 mesh.yaml 中，整体操作会简单的多。&lt;/p&gt;
&lt;p&gt;升级也变得简单，金丝雀部署（canarying）成为一种可选的部署方式；安装过程中对权限的需求也大大减少；对于 VM 这样的非 Kubernetes 环境，只需要安装一个单一的二进制文件即可。&lt;/p&gt;
&lt;h4 id=&#34;构建测试和发布的影响&#34;&gt;构建、测试和发布的影响&lt;/h4&gt;
&lt;p&gt;集成测试变得简单，因为只需要协调 istiod、istio-agent 和 Envoy 以及下游组件；配置的精简使得端到端测试也变得容易；测试和构建的时间也会大幅降低，另外，Istio 的启动时间也会大大减少。&lt;/p&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;
&lt;p&gt;系统的精练必然能够提高其可靠性。特别是改善复杂性导致的问题。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;组件将只依赖于 apiserver，不再受启动顺序或其他组件的影响；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件之间的网络/证书问题和对 Citadel 的依赖都被消除了；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于内存使用，单一组件消除了重复的缓存、序列化和延迟；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消除了跨组件通信，避免了通信问题；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能提升方面，原本被诟病的 Mixer 组件将被取消，在未来版本中，其功能将会被合并到 sidecar 中。这其实变相的实现了 &lt;a href=&#34;https://docs.google.com/document/d/1QKmtem5jU_2F3Lh5SqLp0IuPb80_70J7aJEYu4_gS-s/edit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mixer V2&lt;/a&gt; 版本，解决了进程外调用的性能问题；多组件合并为 istiod 也解决了原来重复的序列化和延迟问题。这一次，Istio 在经过社区长期的灵魂拷问下，终于卸下优雅架构的包袱，全面拥抱性能和易用性。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;Service Mesh 概念的缔造者，Linkerd 的作者 William Morgan 曾说过这样一段话：“今天的服务网格处于不幸的状态：虽然有真实和重要的价值，但市场营销已经超过了技术本身”。Istio 的高调登场，加上 3 家顶尖厂商的背书，让众多拥趸失去理性思考的能力，盲目的追捧正是这种恶性营销的表现。今天的 Istio 终于放低姿态，以回归单体的方式完成自我救赎，来重新融入社区的怀抱。笔者仍然相信，未来 Istio 依然有能力成为一个成熟而优秀的产品，深耕于社区，服务于大众。让我们拭目以待。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AWS App Mesh vs Istio</title>
      <link>https://cloudnative.to/blog/compare-appmesh-with-istio/</link>
      <pubDate>Tue, 15 Oct 2019 16:58:27 +0800</pubDate>
      <guid>https://cloudnative.to/blog/compare-appmesh-with-istio/</guid>
      <description>&lt;p&gt;作者：马若飞，lead software engineer in FreeWheel，《Istio 实战指南》作者，ServiceMesher 社区管委会成员。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;近两年随着微服务架构的流行，服务网格（Service Mesh）技术受到了越来越多的人关注，并拥有了大批的拥趸。目前市面上比较成熟的开源服务网格主要有下面几个：Linkerd，这是第一个出现在公众视野的服务网格产品，由 Twitter 的 finagle 库衍生而来，目前由 Buoyant 公司负责开发和维护；Envoy，Lyft 开发并且是第一个从 CNCF 孵化的服务网格产品，定位于通用的数据平面或者单独作为 Sidecar 代理使用；Istio，由 Google、IBM、Lyft 联合开发的所谓第二代服务网格产品，控制平面的加入使得服务网格产品的形态更加完整。&lt;/p&gt;
&lt;p&gt;服务网格技术作为构建云原生应用的重要一环，逐渐的被越来越多的人和厂商认可，并看好它的发展前景。在 Istio 大红大紫的今天，作为和 Google 在云服务市场竞争的 Amazon 来说，自然不愿错失这块巨大的蛋糕。他们在今年 4 月份发布了自己的服务网格产品：AWS App Mesh。本文会聚焦于 Istio 和 App Mesh 这两个产品，通过横向的对比分析让大家对它们有一个更深入的认识。&lt;/p&gt;
&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;h3 id=&#34;产品定位&#34;&gt;产品定位&lt;/h3&gt;
&lt;p&gt;从官方的介绍来看，Istio 和 App Mesh 都比较明确的表示自己是一种服务网格产品。Istio 强调了自己在连接、安全、控制和可视化 4 个方面的能力；而 App Mesh 主要强调了一致的可见性和流量控制这两方面能力，当然也少不了强调作为云平台下的产品的好处：托管服务，无需自己维护。&lt;/p&gt;
&lt;p&gt;从某种程度上讲，Istio 是一个相对重一点的解决方案，提供了不限于流量管理的各个方面的能力；而 App Mesh 是更加纯粹的服务于运行在 AWS 之上的应用并提供流控功能。笔者认为这和它目前的产品形态还不完善有关（后面会具体提到）。从与 AWS 内部开发人员的沟通中可以感觉到，App Mesh 应该是一盘很大的棋，目前只是初期阶段而已。&lt;/p&gt;
&lt;h3 id=&#34;核心术语&#34;&gt;核心术语&lt;/h3&gt;
&lt;p&gt;和 AWS 里很多产品一样，App Mesh 也不是独创，而是基于 Envoy 开发的。AWS 这样的闭环生态必然要对其进行改进和整合。同时，也为了把它封装成一个对外的服务，提供适当的 API 接口，在 App Mesh 这个产品中提出了下面几个重要的技术术语，我们来一一介绍一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务网格（Service mesh）：服务间网络流量的逻辑边界。这个概念比较好理解，就是为使用 App mesh 的服务圈一个虚拟的边界。&lt;/li&gt;
&lt;li&gt;虚拟服务（Virtual services）：是真实服务的抽象。真实服务可以是部署于抽象节点的服务，也可以是间接的通过路由指向的服务。&lt;/li&gt;
&lt;li&gt;虚拟节点（Virtual nodes）：虚拟节点是指向特殊工作组（task group）的逻辑指针。例如 AWS 的 ECS 服务，或者 Kubernetes 的 Deployment。可以简单的把它理解为是物理节点或逻辑节点的抽象。&lt;/li&gt;
&lt;li&gt;Envoy：AWS 改造后的 Envoy（未来会合并到 Envoy 的官方版本），作为 App Mesh 里的数据平面，Sidecar 代理。&lt;/li&gt;
&lt;li&gt;虚拟路由器（Virtual routers）：用来处理来自虚拟服务的流量。可以理解为它是一组路由规则的封装。&lt;/li&gt;
&lt;li&gt;路由（Routes）：就是路由规则，用来根据这个规则分发请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-appmesh&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;appmesh&#34; srcset=&#34;
               /blog/compare-appmesh-with-istio/appmesh_hud89eca1ee755583bbdf54c06e717bc73_78614_6683cef3f28f30f7c4762d49f786e84f.webp 400w,
               /blog/compare-appmesh-with-istio/appmesh_hud89eca1ee755583bbdf54c06e717bc73_78614_9d33f0cfb336bd83b90b3a5bc7e43d50.webp 760w,
               /blog/compare-appmesh-with-istio/appmesh_hud89eca1ee755583bbdf54c06e717bc73_78614_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/compare-appmesh-with-istio/appmesh_hud89eca1ee755583bbdf54c06e717bc73_78614_6683cef3f28f30f7c4762d49f786e84f.webp&#34;
               width=&#34;760&#34;
               height=&#34;304&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      appmesh
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上面的图展示了这几个概念的关系：当用户请求一个虚拟服务时，服务配置的路由器根据路由策略将请求指向对应的虚拟节点，这些节点本质上是 AWS 里的 EKS 或者 ECS 的节点。&lt;/p&gt;
&lt;p&gt;那么这些 App Mesh 自创的术语是否能在 Istio 中找到相似甚至相同的对象呢？我归纳了下面的表格来做一个对比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;App Mesh&lt;/th&gt;
&lt;th&gt;Istio&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;服务网格（Service mesh）&lt;/td&gt;
&lt;td&gt;Istio 并未显示的定义这一概念，我们可以认为在一个集群中，由 Istio 管理的服务集合，它们组成的网络拓扑即是服务网格。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;虚拟服务（Virtual services）&lt;/td&gt;
&lt;td&gt;Istio 中也存在虚拟服务的概念。它的主要功能是定义路由规则，使请求可以根据这些规则被分发到对应的服务。从这一点来说，它和 App Mesh 的虚拟服务的概念基本上是一致的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;虚拟节点（Virtual nodes）&lt;/td&gt;
&lt;td&gt;Istio 没有虚拟节点的概念，可以认为类似 Kubernetes 里的 Deployment。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;虚拟路由器（Virtual routers）&lt;/td&gt;
&lt;td&gt;Istio 也没有虚拟路由器的概念。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路由（Routes）&lt;/td&gt;
&lt;td&gt;Istio 中的目标规则（DestinationRule）和路由的概念类似，为路由设置一些策略。从配置层面讲，其中的子集（subset）和 App Mesh 路由里选择的目标即虚拟节点对应。但 Istio 的目标规则更加灵活，也支持更多的路由策略。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从上面的对比看出，App Mesh 目前基本上实现了最主要的流量控制（路由）的功能，但像超时重试、熔断、流量复制等高级一些的功能还没有提供，有待进一步完善。&lt;/p&gt;
&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;
&lt;p&gt;AWS App Mesh 是一个商业产品，目前还没有找到架构上的技术细节，不过我们依然可以从现有的、公开的文档或介绍中发现一些有用的信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-arch1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;arch1&#34; srcset=&#34;
               /blog/compare-appmesh-with-istio/arch_hu4bd17c1212b47c5ec0758ba9c48e29f3_25305_676b139458ddf320d491874e93671a69.webp 400w,
               /blog/compare-appmesh-with-istio/arch_hu4bd17c1212b47c5ec0758ba9c48e29f3_25305_48c8adf85234a4d2eee7c1a4e78b406f.webp 760w,
               /blog/compare-appmesh-with-istio/arch_hu4bd17c1212b47c5ec0758ba9c48e29f3_25305_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/compare-appmesh-with-istio/arch_hu4bd17c1212b47c5ec0758ba9c48e29f3_25305_676b139458ddf320d491874e93671a69.webp&#34;
               width=&#34;580&#34;
               height=&#34;350&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      arch1
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从这张官网的结构图中可以看出，每个服务的橙色部分就是 Sidecar 代理：Envoy。而中间的 AWS App Mesh 其实就是控制平面，用来控制服务间的交互。那么这个控制平面具体的功能是什么呢？我们可以从今年的 AWS Summit 的一篇 PPT 中看到这样的字样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;控制平面用来把逻辑意图转换成代理配置，并进行分发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-arch2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./aws-summit-appmesh.png&#34; alt=&#34;arch2&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      arch2
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;熟悉 Istio 架构的朋友有没有觉得似曾相识？没错，这个控制平面的职责和 Pilot 基本一致。由此可见，不管什么产品的控制平面，也必须具备这些核心的功能。&lt;/p&gt;
&lt;p&gt;那么在平台的支持方面呢？下面这张图展示了 App Mesh 可以被运行在如下的基础设施中，包括 EKS、ECS、EC2 等等。当然，这些都必须存在于 AWS 这个闭环生态中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-arch3&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://www.allthingsdistributed.com/images/appmesh.png&#34; alt=&#34;arch3&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      arch3
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而 Istio 这方面就相对弱一些。尽管 Istio 宣称是支持多平台的，但目前来看和 Kubernetes 还是强依赖。不过它并不受限于单一的云平台，这一点有较大的优势。&lt;/p&gt;
&lt;p&gt;从可观测性来看，App Mesh 依然发挥了自家生态的优势，可以方便的接入 CloudWatch、X-Ray 对服务进行观测。另外，App Mesh 也提供了更大的灵活性，可以在虚拟节点里配置服务后端（可以是虚拟服务或者 ARN），流量可以出站到这些配置的服务。这一点来说，和 Istio 的 Mixer 又有了异曲同工之妙。Mixer 通过插件方式为 Istio 提供了极大的可扩展性，App Mesh 在这一点上也不算落下风。&lt;/p&gt;
&lt;p&gt;Istio 的架构大家都非常熟悉了，这里就不再赘述了，感兴趣的同学可以直接去&lt;a href=&#34;https://istio.io/docs/concepts/what-is-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官网&lt;/a&gt;查看。&lt;/p&gt;
&lt;h2 id=&#34;功能与实现方式&#34;&gt;功能与实现方式&lt;/h2&gt;
&lt;h3 id=&#34;部署&#34;&gt;部署&lt;/h3&gt;
&lt;p&gt;Istio 部署后类似一个网一样附着在你的 Kubernetes 集群上，控制平面会使用你设置的资源；而 App Mesh 是一种托管方式，只会使用 Envoy 代理。完整安装后的 Istio 需要添加 50 个左右的 CRD，而 App Mesh 只添加了 3 个 CRD：&lt;code&gt;meshes.appmesh.k8s.aws&lt;/code&gt;，&lt;code&gt;virtualnodes.appmesh.k8s.aws&lt;/code&gt;和&lt;code&gt;virtualservices.appmesh.k8s.aws&lt;/code&gt;。这一点也反映出了功能上的区别。&lt;/p&gt;
&lt;h3 id=&#34;流量控制&#34;&gt;流量控制&lt;/h3&gt;
&lt;p&gt;尽管两者的数据平面都是基于 Envoy，但它们提供的流量控制能力目前还是有比较大的差距的。在路由的设置方面，App Mesh 提供了相对比较丰富的匹配策略，基本能满足大部分使用场景。下面是 App Mesh 控制台里的路由配置截图，可以看出，除了基本的 URI 前缀、HTTP Method 和 Scheme 外，也支持请求头的匹配。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-appmesh-route&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;appmesh-route&#34; srcset=&#34;
               /blog/compare-appmesh-with-istio/appmeshroute_huce353b29593d78993b54d9ac2f65b97d_138770_b7bfdaa66ad0de1c95514b3c1453b61c.webp 400w,
               /blog/compare-appmesh-with-istio/appmeshroute_huce353b29593d78993b54d9ac2f65b97d_138770_5ee2ef4df2a26145467ae1b6129a5dd1.webp 760w,
               /blog/compare-appmesh-with-istio/appmeshroute_huce353b29593d78993b54d9ac2f65b97d_138770_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/compare-appmesh-with-istio/appmeshroute_huce353b29593d78993b54d9ac2f65b97d_138770_b7bfdaa66ad0de1c95514b3c1453b61c.webp&#34;
               width=&#34;760&#34;
               height=&#34;638&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      appmesh-route
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Istio 的匹配策略更加完善，除了上面提到的，还包括 HTTP Authority，端口匹配，请求参数匹配等，具体信息可以从官方文档的虚拟服务&lt;a href=&#34;https://istio.io/docs/reference/config/networking/v1alpha3/virtual-service/#HTTPMatchRequest&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;设置&lt;/a&gt;查看。下面两段 yaml 分别展示了两个产品在虚拟服务配置上的差异。&lt;/p&gt;
&lt;p&gt;App Mesh 配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;appmesh.k8s.aws/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;VirtualService&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-svc-a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-namespace&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;meshName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-mesh&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;route-to-svc-a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weightedTargets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;virtualNodeName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my-app-a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Istio 配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;VirtualService&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ratings-route&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;ratings.prod.svc.cluster.local&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;end-user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exact&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;jason&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/ratings/v2/&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ignoreUriCase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ratings.prod.svc.cluster.local&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外一个比较大的不同是，App Mesh 需要你对不同版本的服务分开定义（即定义成不同的虚拟服务），而 Istio 是通过目标规则 &lt;code&gt;DestinationRule&lt;/code&gt; 里的子集 &lt;code&gt;subsets&lt;/code&gt; 和路由配置做的关联。本质上它们没有太大区别。&lt;/p&gt;
&lt;p&gt;除了路由功能外，App Mesh 就显得捉襟见肘了。就在笔者撰写本文时，AWS 刚刚添加了重试功能。而 Istio 借助于强大的 Envoy，提供了全面的流量控制能力，如超时重试、故障注入、熔断、流量镜像等。&lt;/p&gt;
&lt;h3 id=&#34;安全&#34;&gt;安全&lt;/h3&gt;
&lt;p&gt;在安全方面，两者的实现方式具有较大区别。默认情况下，一个用户不能直接访问 App Mesh 的资源，需要通过 AWS 的&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/IAM_policies.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IAM 策略&lt;/a&gt;给用户授权。比如下面的配置是容许用户用任意行为去操作网格内的任意资源：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;Version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2012-10-17&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;Statement&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;Effect&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Allow&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;Action&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s2&#34;&gt;&amp;#34;appmesh:*&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;Resource&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而虚拟节点间的授权方面，App Mesh 目前只有 TLS 访问的支持，且仅仅是预览版（Preview）并未正式发布。下面的配置展示了一个虚拟节点只容许&lt;code&gt;tls&lt;/code&gt;方式的访问：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;nt&#34;&gt;&amp;#34;meshName&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;app1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;nt&#34;&gt;&amp;#34;spec&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;listeners&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;portMapping&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;nt&#34;&gt;&amp;#34;port&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;nt&#34;&gt;&amp;#34;protocol&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;http&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;tls&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;nt&#34;&gt;&amp;#34;mode&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;STRICT&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;nt&#34;&gt;&amp;#34;certificate&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  &lt;span class=&#34;nt&#34;&gt;&amp;#34;acm&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;nt&#34;&gt;&amp;#34;certificateArn&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;arn:aws:acm:us-west-2:123456789012:certificate/12345678-1234-1234-1234-123456789012&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;serviceDiscovery&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;nt&#34;&gt;&amp;#34;dns&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;hostname&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;serviceBv1.mesh.local&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualNodeName&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;serviceBv1&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而 Istio 中端到端的认证是支持 mTLS 的，同时还支持 JWT 的用户身份认证。下面的配置分别展示了这两种认证方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;authentication.istio.io/v1alpha1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Policy&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;reviews&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reviews&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;peers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;mtls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;origins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;jwt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;issuer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;https://accounts.google.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;jwksUri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;https://www.googleapis.com/oauth2/v3/certs&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;trigger_rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;excluded_paths&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;exact&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/health&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Istio 的授权是通过 RBAC 实现的，可以提供基于命名空间、服务和 HTTP 方法级别的访问控制。这里就不具体展示了，大家可以通过官网&lt;a href=&#34;https://istio.io/docs/concepts/security/#authorization-policy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;来查看。&lt;/p&gt;
&lt;h3 id=&#34;可观察性&#34;&gt;可观察性&lt;/h3&gt;
&lt;p&gt;一般来说，可以通过三种方式来观察你的应用：指标数据、分布式追踪、日志。Istio 在这三个方面都有比较完整的支持。指标方面，可以通过 Envoy 获取请求相关的数据，同时还提供了服务级别的指标，以及控制平面的指标来检测各个组件的运行情况。通过内置的 Prometheus 来收集指标，并使用 Grafana 展示出来。分布式追踪也支持各种主流的 OpenTracing 工具，如 Jaeger、Zipkin 等。访问日志一般都通过 ELK 去完成收集、分析和展示。另外，Istio 还拥有 Kiali 这样的可视化工具，给你提供整个网格以及微服务应用的拓扑视图。总体来说，Istio 在可观察方面的能力是非常强大的，这主要是因为 Mixer 组件的插件特性带来了巨大的灵活性。&lt;/p&gt;
&lt;p&gt;App Mesh 在这方面做的也不错。在如下图虚拟节点的配置中可以看到，你可以配置服务的后端基础设施，这样流量就可以出站到这些服务。同时，在日志收集方面，也可以配置到本地日志，或者是其他的日志系统。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-amob&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;amob&#34; srcset=&#34;
               /blog/compare-appmesh-with-istio/appmeshob_hu608793e84293b53116ab1213cf474554_84280_7643fb4d72897c06ea3413e2049a72f5.webp 400w,
               /blog/compare-appmesh-with-istio/appmeshob_hu608793e84293b53116ab1213cf474554_84280_e13d8b7bcde5a9dccbdddfa2e1a63cb5.webp 760w,
               /blog/compare-appmesh-with-istio/appmeshob_hu608793e84293b53116ab1213cf474554_84280_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/compare-appmesh-with-istio/appmeshob_hu608793e84293b53116ab1213cf474554_84280_7643fb4d72897c06ea3413e2049a72f5.webp&#34;
               width=&#34;760&#34;
               height=&#34;267&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      amob
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;另一方面，AWS 又一次发挥了自己闭环生态的优势，提供了 App Mesh 与自家的 CloudWatch、X-Ray 这两个监控工具的整合。总的来说，App Mesh 在可观察性上也不落下风。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;AWS App Mesh 作为一个今年 4 月份才发布的产品，在功能的完整性上和 Istio 有差距也是情有可原的。从 App Mesh 的&lt;a href=&#34;https://github.com/aws/aws-app-mesh-roadmap/projects/1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Roadmap&lt;/a&gt;可以看出，很多重要的功能，比如熔断已经在开发计划中。以笔者与 AWS 的开发人员了解的信息来看，他们还是相当重视这个产品，优先级很高，进度也比较快，之前还在预览阶段的重试功能在上个月也正式发布了。另外，App Mesh 是可以免费使用的，用户只需要对其中的实例资源付费即可，没有额外费用。App Mesh 一部分的开发重点是和现有产品的整合，比如 Roadmap 列出的使用 AWS Gateway 作为 App Mesh 的 Ingress。借助着自己的生态优势，这种整合即方便快捷的完善了 App Mesh，同时又让生态内的产品结合的更紧密，使得闭环更加的牢固，不得不说是一步好棋。&lt;/p&gt;
&lt;p&gt;和 App Mesh 目前只强调流控能力不同，Istio 更多的是把自己打造成一个更加完善的、全面的服务网格系统。架构优雅，功能强大，但性能上受到质疑。在产品的更迭上貌似也做的不尽如人意（不过近期接连发布了 1.3 到 1.3.3 版本，让我们对它的未来发展又有了期待）。Istio 的优势在于 3 大顶级技术公司加持的强大资源，加上开源社区的反哺，控制好的话容易形成可持续发展的局面，并成为下一个明星级产品。但目前各大厂商都意识到了网格的重要性并推出自己的产品（AWS App Mesh，Kong 的 Kuma 等），竞争也会逐渐激烈。未来是三分天下还是一统山河，让我们拭目以待。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/what-is-app-mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;what is app mesh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/aws/aws-app-mesh-roadmap/projects/1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;aws app mesh roadmap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.allthingsdistributed.com/2019/03/redefining-application-communications-with-aws-app-mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Redefining application communications with AWS App Mesh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;istio offical&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AWS App Mesh - 云应用的服务网格</title>
      <link>https://cloudnative.to/blog/aws-app-mesh-application-level-networking-for-cloud-applications/</link>
      <pubDate>Fri, 06 Sep 2019 18:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/aws-app-mesh-application-level-networking-for-cloud-applications/</guid>
      <description>&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;本文简要介绍了 AWS App Mesh 的基本概念，并通过一个示例演示了如何在 AWS 的控制台创建一个 App Mesh 的服务网格。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/app-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS App Mesh&lt;/a&gt; 可以帮助你运行和监控大规模的 HTTP 和 TCP 服务。你可以用一致的方式来路由和监控流量，获得发现问题的能力，并在失败或代码更改后重新路由流量。App Mesh 使用开源的&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;代理，让你可以使用来自 AWS 合作伙伴和开源社区的各种工具。&lt;/p&gt;
&lt;p&gt;服务可以运行在&lt;a href=&#34;https://aws.amazon.com/fargate/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS Fargate&lt;/a&gt;， &lt;a href=&#34;https://aws.amazon.com/ec2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon EC2&lt;/a&gt;，&lt;a href=&#34;https://aws.amazon.com/ecs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon ECS&lt;/a&gt;， &lt;a href=&#34;https://aws.amazon.com/eks/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon Elastic Container Service for Kubernetes&lt;/a&gt; 或 &lt;a href=&#34;https://aws.amazon.com/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;上。每个服务的所有进出流量都经过 Envoy 代理，以便对其进行路由、可视化、测量和记录。这种额外的间接层让你可以用任何想要的语言构建服务，而不必使用一组公共的通信库。&lt;/p&gt;
&lt;h2 id=&#34;app-mesh-基本概念&#34;&gt;App Mesh 基本概念&lt;/h2&gt;
&lt;p&gt;在深入了解之前，让我们先来回顾一下 App Mesh 里的重要概念和组件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/meshes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;服务网格&lt;/strong&gt;&lt;/a&gt; – 网络流量在其服务之间的逻辑边界。网格可以包含虚拟服务、虚拟节点、虚拟路由器和路由。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_services.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;虚拟服务&lt;/strong&gt;&lt;/a&gt; – 直接（由虚拟节点）或间接（通过虚拟路由器）提供的服务的抽象（逻辑名称）。网格中的服务使用逻辑名称引用和使用其他服务。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_nodes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;虚拟节点&lt;/strong&gt;&lt;/a&gt; – 特定任务组（如 ECS 服务或 Kubernetes 部署）或运行在一个或多个 EC2 实例上的逻辑指针。每个虚拟节点可以通过&lt;strong&gt;侦听器&lt;/strong&gt;接受入流量，并通过&lt;strong&gt;后端&lt;/strong&gt;连接到其他虚拟节点。此外，每个节点都有一个服务发现配置（当前是 DNS 名称），允许其他节点发现任务、pod 或实例的 IP 地址。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_routers.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;虚拟路由器&lt;/strong&gt;&lt;/a&gt; – 网格中一个或多个虚拟服务的处理器。每个虚拟路由器监听特定端口上的 HTTP 通信。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/routes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;路由&lt;/strong&gt;&lt;/a&gt; – 路由使用基于 URL 的前缀匹配将流量路由到虚拟节点，每个节点都有可选的权重。权重可用于测试生产环境中的新服务，同时逐渐增加它们处理的流量。&lt;/p&gt;
&lt;p&gt;把它们放在一起，每个服务网格包含一组服务，可以通过路由指定的 URL 路径访问这些服务。网格中，服务通过名称相互引用。&lt;/p&gt;
&lt;p&gt;可以从 App Mesh 控制台、App Mesh CLI 或 App Mesh API 访问 App Mesh。我将展示如何使用控制台创建网格，并对 CLI 做简要的介绍。&lt;/p&gt;
&lt;h2 id=&#34;使用-app-mesh-控制台&#34;&gt;使用 App Mesh 控制台&lt;/h2&gt;
&lt;p&gt;在控制台创建服务网格和组件。打开&lt;a href=&#34;https://console.aws.amazon.com/appmesh/landing-page&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;App Mesh Console&lt;/a&gt; 并点击开始使用：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_console_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;输入我的网格和第一个虚拟服务（以后可以添加多个）的名称，点击下一步：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_step1_2.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;定义第一个虚拟节点：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_step2_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;点击额外配置来设置特定的服务后端（其他服务是指一个可以调用的服务）和日志记录：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_step2_p2_2.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过协议（HTTP 或 TCP）和端口来定义节点的监听器，设置健康检查选项，点击下一步：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_step2_p3_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然后，定义虚拟路由器和它的路由：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_step3_p1_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可以按百分比在多个虚拟节点（目标）之间分配流量，还可以对入流量使用基于前缀的路由：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_step3_p2_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后再检查一下我的设置并点击创建网格服务：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_review_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;组件很快被创建并且可以准备使用了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2019/am_ready_1.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后一步，如&lt;a href=&#34;https://docs.aws.amazon.com/app-mesh/latest/userguide/getting_started.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;App Mesh 使用手册&lt;/a&gt;中所描述，更新我的任务定义（Amazon ECS 或 AWS Fargate）或 pod 规范（Amazon EKS 或 Kubernetes），以引用 Envoy 容器映像和代理容器映像。如果我的服务运行在 EC2 实例上，需要在那里部署 Envoy。&lt;/p&gt;
&lt;h2 id=&#34;使用-aws-app-mesh-命令行&#34;&gt;使用 AWS App Mesh 命令行&lt;/h2&gt;
&lt;p&gt;App Mesh 可以让你以一个简单的 JSON 形式描述每个类型的组件，并提供了&lt;a href=&#34;https://docs.aws.amazon.com/cli/latest/reference/appmesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;命令行工具&lt;/a&gt;来创建每一个组件（&lt;code&gt;create-mesh&lt;/code&gt;, &lt;code&gt;create-virtual-service&lt;/code&gt;, &lt;code&gt;create-virtual-node&lt;/code&gt;, and &lt;code&gt;create-virtual-router&lt;/code&gt;）。例如，可以像这样定义一个虚拟路由：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;meshName&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;mymesh&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;spec&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;listeners&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;nt&#34;&gt;&amp;#34;portMapping&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;port&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;nt&#34;&gt;&amp;#34;protocol&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;http&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualRouterName&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;serviceA&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并使用一条命令创建它：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ aws appmesh create-virtual-router --cli-input-json file://serviceA-router.json
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;当前可用&#34;&gt;当前可用&lt;/h2&gt;
&lt;p&gt;AWS App Mesh 现在是可用的，你可以现在就开始使用它，包括的区域有美国东部（维吉尼亚），美国东部（俄亥俄州），美国西部（俄勒冈州），美国西部（加利福尼亚），加拿大（中央）、欧洲（爱尔兰），欧洲（法兰克福），欧洲（伦敦），亚太（孟买），亚太（东京），亚太（悉尼），亚太（新加坡）和亚太（首尔）。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
