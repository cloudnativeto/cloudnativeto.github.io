<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>丁轶群 | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/author/%E4%B8%81%E8%BD%B6%E7%BE%A4/</link>
      <atom:link href="https://cloudnativecn.com/author/%E4%B8%81%E8%BD%B6%E7%BE%A4/index.xml" rel="self" type="application/rss+xml" />
    <description>丁轶群</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Sat, 28 Jul 2018 17:49:21 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/author/%E4%B8%81%E8%BD%B6%E7%BE%A4/avatar_hu3801682002625739492.jpg</url>
      <title>丁轶群</title>
      <link>https://cloudnativecn.com/author/%E4%B8%81%E8%BD%B6%E7%BE%A4/</link>
    </image>
    
    <item>
      <title>Service Mesh 深度学习系列 part3—istio 源码分析之 pilot-discovery 模块分析（续）</title>
      <link>https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2/</link>
      <pubDate>Sat, 28 Jul 2018 17:49:21 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2/</guid>
      <description>&lt;p&gt;本文为&lt;code&gt;Service Mesh深度学习系列&lt;/code&gt;之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-agent-deepin&#34;&gt;Service Mesh 深度学习系列 part1—istio 源码分析之 pilot-agent 模块分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin&#34;&gt;Service Mesh 深度学习系列 part2—istio 源码分析之 pilot-discovery 模块分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2&#34;&gt;Service Mesh 深度学习系列 part3—istio 源码分析之 pilot-discovery 模块分析（续）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文分析的 istio 代码版本为 0.8.0，commit 为 0cd8d67，commit 时间为 2018 年 6 月 18 日。&lt;/p&gt;
&lt;h2 id=&#34;pilot-总体架构&#34;&gt;pilot 总体架构&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2/006tKfTcgy1ftppxdcmwvj31kw0vvtdl_hu6613531650394495837.webp 400w,
               /blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2/006tKfTcgy1ftppxdcmwvj31kw0vvtdl_hu17684332673434384355.webp 760w,
               /blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2/006tKfTcgy1ftppxdcmwvj31kw0vvtdl_hu3538420849296039055.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2/006tKfTcgy1ftppxdcmwvj31kw0vvtdl_hu6613531650394495837.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先我们回顾一下 pilot 总体架构，上面是&lt;a href=&#34;https://github.com/istio/old_pilot_repo/blob/master/doc/design.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方关于 pilot 的架构图&lt;/a&gt;，因为是 old_pilot_repo 目录下，可能与最新架构有出入，仅供参考。所谓的 pilot 包含两个组件：pilot-agent 和 pilot-discovery。图里的 agent 对应 pilot-agent 二进制，proxy 对应 Envoy 二进制，它们两个在同一个容器中，discovery service 对应 pilot-discovery 二进制，在另外一个跟应用分开部署的单独的 deployment 中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;discovery service&lt;/strong&gt;：从 Kubernetes API Server list/watch &lt;code&gt;service&lt;/code&gt;、&lt;code&gt;endpoint&lt;/code&gt;、&lt;code&gt;pod&lt;/code&gt;、&lt;code&gt;node&lt;/code&gt;等资源信息，监听 istio 控制平面配置信息（如 VirtualService、DestinationRule 等），翻译为 Envoy 可以直接理解的配置格式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;proxy&lt;/strong&gt;：也就是 Envoy，直接连接 discovery service，间接地从 Kubernetes 等服务注册中心获取集群中微服务的注册情况&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;agent&lt;/strong&gt;：生成 Envoy 配置文件，管理 Envoy 生命周期&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;service A/B&lt;/strong&gt;：使用了 istio 的应用，如 Service A/B，的进出网络流量会被proxy接管&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;对于模块的命名方法，本文采用模块对应源码 main.go 所在包名称命名法。其他 istio 分析文章有其他命名方法。比如 pilot-agent 也被称为 istio pilot，因为它在 Kubernetes 上的部署形式为一个叫 istio-pilot 的 deployment。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;pilot-discovery-的统一存储模型abstract-model&#34;&gt;pilot-discovery 的统一存储模型（Abstract Model）&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2/006tKfTcgy1ftppyenvgyj30la0fudhb_hu2981895258527807315.webp 400w,
               /blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2/006tKfTcgy1ftppyenvgyj30la0fudhb_hu1135926880668237947.webp 760w,
               /blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2/006tKfTcgy1ftppyenvgyj30la0fudhb_hu17538884970976196012.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2/006tKfTcgy1ftppyenvgyj30la0fudhb_hu2981895258527807315.webp&#34;
               width=&#34;760&#34;
               height=&#34;566&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;根据上面官方的 pilot-discovery 架构图，pilot-discovery 有两个输入信息（黄色部分）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;来自 istioctl 的控制面信息，也就是图中的 Rules API，如 route rule、virtual service 等，这些信息以 Kubernetes CRD 资源形式保存&lt;/li&gt;
&lt;li&gt;来自服务注册中心的服务注册信息，也就是图上的 Kubernetes、Mesos、Cloud Foundry 等。在 Kubernetes 环境下包括&lt;code&gt;pod&lt;/code&gt; 、&lt;code&gt;service&lt;/code&gt;、&lt;code&gt;node&lt;/code&gt;、&lt;code&gt;endpoint&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了实现 istio 对不同服务注册中心的支持，如 Kubernetes、consul、Cloud Foundry 等，pilot-discovery 需要对以上两个输入来源的数据有一个统一的存储格式，也就是图中的 Abstract Model，这种格式就定义在 pilot/pkg/model 包下。&lt;/p&gt;
&lt;p&gt;举例，下面列表罗列了 istio Abstract Model 中 service 的一些成员如何跟根据 Kubernetes 服务注册信息中的 service 对象转化得到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;HostName&lt;/code&gt;：&lt;code&gt;&amp;lt;name&amp;gt;.&amp;lt;namespace&amp;gt;.svc.cluster.local&lt;/code&gt;
其中&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;namespace&lt;/code&gt;分别为 Kubernetes service 对象的 name 和所属的 namespace。cluster.local 为默认 domain suffix，可以通过 proxy-discovery &lt;code&gt;discovery&lt;/code&gt;命令的&lt;code&gt;domain&lt;/code&gt; flag 提供自定义值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ports&lt;/code&gt;：对应 Kubernetes service 的 spec.ports。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Address&lt;/code&gt;: 对应 Kubernetes service 的 spec.ClusterIP。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ExternalName&lt;/code&gt;: 对应 Kubernetes service 的 spec.ExternalName。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServiceAccounts&lt;/code&gt;: 对应 Kubernetes service 的 annotation 中 key 值为 alpha.istio.io/kubernetes-serviceaccounts 和 alpha.istio.io/canonical-serviceaccounts 的 annotation 信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Resolution&lt;/code&gt;: 根据情况可以设置为 client side LB、DNS Lb 和 Passthrough。比如对于 ClusterIP 类型的 Kubernetes service，Resolution 设置为 client side LB，表示应用发出的请求由 sidecar（也就是 Envoy）负责做负载均衡，而对于 Kubernetes 中的 headless service 则设置为 Passthrough。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面 pilot-discovery 架构图中的 Platform Adaptor 负责实现服务注册中心数据到 Abstract Model 之间的数据转换，在代码里，Platform Adaptor 包含两部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;pilot/pkg/serviceregistry/kube/conversion.go里包括一系列将Kubernetes服务注册中心中的&lt;code&gt;label&lt;/code&gt;、&lt;code&gt;pod&lt;/code&gt;、&lt;code&gt;service&lt;/code&gt;、&lt;code&gt;service port&lt;/code&gt;等 Kubernetes 资源对象转换为 Abstract Model 中的对应资源对象的函数&lt;/li&gt;
&lt;li&gt;pilot/pkg/config/kube/crd/conversion.go里包括将&lt;code&gt;DestinationRule&lt;/code&gt;等 CRD 转换为 Abstract Model 中的&lt;code&gt;Config&lt;/code&gt;对象的函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在&lt;code&gt;pilot/pkg/bootstrap&lt;/code&gt;包下的&lt;code&gt;Server&lt;/code&gt;结构体代表 pilot-discovery，其中包含 3 个重要成员负责这两类信息的获取、格式转换、以及构建数据变更事件的处理框架：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ConfigStoreCache&lt;/code&gt; &lt;code&gt;ConfigStoreCache&lt;/code&gt;对象中 embed 了&lt;code&gt;ConfigStore&lt;/code&gt;对象。&lt;code&gt;ConfigStore&lt;/code&gt;对象利用 client-go 库从 Kubernetes 获取 route rule、virtual service 等 CRD 形式存在控制面信息，转换为 model 包下的&lt;code&gt;Config&lt;/code&gt;对象，对外提供&lt;code&gt;Get&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Create&lt;/code&gt;、&lt;code&gt;Update、Delete&lt;/code&gt;等 CRUD 服务。而&lt;code&gt;ConfigStoreCache&lt;/code&gt;在此基础之上还允许注册控制面信息变更处理函数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IstioConfigStore&lt;/code&gt;
IstioConfigStore 封装了 embed 在 ConfigStoreCache 中的同一个 ConfigStore 对象。其主要目的是为访问 route rule、virtual service 等数据提供更加方便的接口。相对于 ConfigStore 提供的&lt;code&gt;Get&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Create&lt;/code&gt;、&lt;code&gt;Update、Delete&lt;/code&gt;接口，IstioConfigStore 直接提供更为方便的 RouteRules、VirtualServices 接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServiceController&lt;/code&gt;
利用 client-go 库从 Kubernetes 获取&lt;code&gt;pod&lt;/code&gt; 、&lt;code&gt;service&lt;/code&gt;、&lt;code&gt;node&lt;/code&gt;、&lt;code&gt;endpoint&lt;/code&gt;，并将这些 CRD 转换为 model 包下的 Service、ServiceInstance 对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;在 istio 中，使用 istioctl 配置的 VirtualService、DestinationRule 等被称为 configuration，而从 Kubernetes 等服务注册中心获取的信息被称为 service 信息。所以从名称看&lt;code&gt;ConfigStoreCache&lt;/code&gt;、&lt;code&gt;IstioConfigStore&lt;/code&gt;负责处理第一类信息，&lt;code&gt;ServiceController&lt;/code&gt;负责第二类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;pilot-discovery-为-envoy-提供的xds服务&#34;&gt;pilot-discovery 为 Envoy 提供的&lt;code&gt;xds&lt;/code&gt;服务&lt;/h2&gt;
&lt;h3 id=&#34;所谓xds&#34;&gt;所谓&lt;code&gt;xds&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;基于上面介绍的统一数据存储格式 Abstract Model，pilot-discovery 为数据面（运行在 sidecar 中的 Envoy 等 proxy 组件）提供控制信息服务，也就是所谓的 discovery service 或者&lt;code&gt;xds&lt;/code&gt;服务。这里的 x 是一个代词，类似云计算里的 XaaS 可以指代 IaaS、PaaS、SaaS 等。在 istio 中，&lt;code&gt;xds&lt;/code&gt;包括&lt;code&gt;cds&lt;/code&gt;(cluster discovery service)、&lt;code&gt;lds&lt;/code&gt;(listener discovery service)、&lt;code&gt;rds&lt;/code&gt;(route discovery service)、&lt;code&gt;eds&lt;/code&gt;(endpoint discovery service)，而&lt;code&gt;ads&lt;/code&gt;(aggregated discovery service) 是对这些服务的一个统一封装。&lt;/p&gt;
&lt;p&gt;以上 cluster、endpoint、route 等概念的详细介绍和实现细节可以参考 Envoy 在社区推广的 data plane api（&lt;a href=&#34;https://github.com/envoyproxy/data-plane-api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/envoyproxy/data-plane-api&lt;/a&gt;），这里只做简单介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;endpoint：一个具体的“应用实例”，对应 ip 和端口号，类似 Kubernetes 中的一个 pod。&lt;/li&gt;
&lt;li&gt;cluster：一个 cluster 是一个“应用集群”，它对应提供相同服务的一个或多个 endpoint。cluster 类似 Kubernetes 中 service 的概念，即一个 Kubernetes service 对应一个或多个用同一镜像启动，提供相同服务的 pod。&lt;/li&gt;
&lt;li&gt;route：当我们做灰度发布、金丝雀发布时，同一个服务会同时运行多个版本，每个版本对应一个 cluster。这时需要通过 route 规则规定请求如何路由到其中的某个版本的 cluster 上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上这些内容实际上都是对 Envoy 等 proxy 的配置信息，而所谓的 cluster discovery service、route discovery service 等 xxx discovery service 就是 Envoy 等从 pilot-discovery 动态获取 endpoint、cluster 等配置信息的协议和实现。为什么要做动态配置加载，自然是为了使用&lt;code&gt;istioctl&lt;/code&gt;等工具统一、灵活地配置 service mesh。&lt;/p&gt;
&lt;p&gt;而为什么要用&lt;code&gt;ads&lt;/code&gt;来“聚合”一系列&lt;code&gt;xds&lt;/code&gt;，并非仅为了在同一个 gRPC 连接上实现多种&lt;code&gt;xds&lt;/code&gt;来省下几个网络连接，&lt;code&gt;ads&lt;/code&gt;还有一个非常重要的作用是解决&lt;code&gt;cds&lt;/code&gt;、&lt;code&gt;rds&lt;/code&gt;信息更新顺序依赖的问题，从而保证以一定的顺序同步各类配置信息，这方面的讨论可以详见&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/v2_overview#aggregated-discovery-service&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 官网&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Envoy 有篇博客叫 The universal data plane API。按照 Envoy 的设想，社区中无论是是实现控制面的团队（比如 istio 自己），还是实现数据面的团队（比如 Envoy、nginx 等），大家都能参与并采用 github.com/envoyproxy/data-plane-api 上规定的这套控制面与数据面之间的 data plane api 接口。所以虽然 repo 叫 data plane api，但博客的名字加上了 universal 这个形容词。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;xds在-pilot-discovery-中的实现框架&#34;&gt;&lt;code&gt;xds&lt;/code&gt;在 pilot-discovery 中的实现框架&lt;/h3&gt;
&lt;p&gt;pilot-discovery 在初始化 discovery service（&lt;code&gt;xds&lt;/code&gt;服务）的过程中（&lt;code&gt;initDiscoveryService&lt;/code&gt;方法），创建了 discovery server 对象，由它负责启动了两个 gRPC 服务：&lt;code&gt;eds&lt;/code&gt;（endpoint discovery service）和&lt;code&gt;ads&lt;/code&gt;（aggregated discovery service）。其中单独存在的&lt;code&gt;eds&lt;/code&gt; gRPC 服务仅仅是为了向后兼容老版本 istio 而存在，0.8 版本的 istio 主要对外的 discovery service 就是指&lt;code&gt;ads&lt;/code&gt;，而其中已经整合了&lt;code&gt;eds&lt;/code&gt;。本文主要的分析的&lt;code&gt;xds&lt;/code&gt;就是指&lt;code&gt;ads&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列文章的上一篇中说明，pilot-discovery 在初始化 discovery service 的过程中创建了两个服务对象，其中第一个 discovery server 对象负责为 Envoy 提供 gRPC 协议的 discovery service，而第二个 discovery service 对象则负责为 Envoy 提供 REST 协议的 discovery service。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据 Envoy 的 data plane api 定义，&lt;code&gt;ads&lt;/code&gt;需要对外提供的 gRPC 接口&lt;code&gt;AggregatedDiscoveryServiceServer&lt;/code&gt;只有&lt;code&gt;StreamAggregatedResources&lt;/code&gt;一个方法。在 discovery service初始化过程中创建的pilot/pkg/proxy/envoy/v2包下的&lt;code&gt;DiscoveryServer&lt;/code&gt;对象实现了 gRPC server 端接口。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;envoy 为方便第三方开发者开发控制面，提供了 go-control-plane 库。基于 go-control-plane 库，开发者可以方便地实现基于 gRPC 协议的 discovery service。istio 0.8 版使用的 go-control-plane 版本 commit 号为&lt;code&gt;bc01fbf&lt;/code&gt;，在这个版本中&lt;code&gt;AggregatedDiscoveryServiceServer&lt;/code&gt;接口就只有&lt;code&gt;StreamAggregatedResources&lt;/code&gt;一个方法。但是在 go-control-plane 2018 年 7 月的一次 commit 中又为&lt;code&gt;AggregatedDiscoveryServiceServer&lt;/code&gt;接口增加了&lt;code&gt;IncrementalAggregatedResources&lt;/code&gt;方法，支持更为灵活的 discovery service 和 Envoy 之间的交互。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;discovery server 的主要逻辑，就是在与每一个 Envoy 建立一个双向 streaming 的 gRPC 连接（Bidirectional streaming RPC）之后：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动一个协程从 gRPC 连接中读取来自 Envoy 的请求&lt;/li&gt;
&lt;li&gt;在原来的协程中处理来自各 gRPC 连接的请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;discovery server 从 Envoy 收到的请求类型为 go-control-plane 库下的&lt;code&gt;DiscoveryRequest&lt;/code&gt;。&lt;code&gt;DiscoveryRequest&lt;/code&gt;几个相对重要的成员如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;VersionInfo&lt;/code&gt;
Envoy 在收到一个&lt;code&gt;DiscoveryResponse&lt;/code&gt;之后会马上再发送一个&lt;code&gt;DiscoveryRequest&lt;/code&gt;作为ACK/NACK，从而告诉discovery service 消息是否成功处理。&lt;code&gt;VersionInfo&lt;/code&gt;用来表示 Envoy 端到目前为止成功处理的最新的消息版本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Node.Id&lt;/code&gt;
连上 discovery service 的 Envoy 的唯一标识。标识符当 istio 部署在不同的服务注册中心（service registry）时会有不同的形式。在 Kubernetes 作为服务注册中心时，一个可能的 Id 值为&lt;code&gt;sidecar~172.00.00.000~sleep-55b5877479-rwcct.default~default.svc.cluster.local&lt;/code&gt;。以“~”为分割符，可以将&lt;code&gt;Node.Id&lt;/code&gt;解析为 4 部分：
&lt;ol&gt;
&lt;li&gt;Type：表示 Envoy sidecar 扮演的角色，如 Sidecar，Ingress，Router 等&lt;/li&gt;
&lt;li&gt;IPAddress：Envoy sidecar 所在 pod 的 IP 地址&lt;/li&gt;
&lt;li&gt;ID：Envoy sidecar 所在 pod 的 name 和 namespace，中间用&amp;quot;.&amp;ldquo;连接，也就是上面例子中的 sleep-55b5877479-rwcct.default&lt;/li&gt;
&lt;li&gt;Domain：Envoy sidecar 所在 pod 的 namespace 加 svc.cluster.local，中间用“.”连接，也就是上面例子中的&lt;code&gt;default.svc.cluster.local&lt;/code&gt;
关于这四个域的说明的更多信息，详见本系列文章第一篇中关于pilot-agent中role的说明。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ResourceName&lt;/code&gt;
Envoy sidecar 关注的资源列表，对于&lt;code&gt;cds&lt;/code&gt;、&lt;code&gt;lds&lt;/code&gt;来说，&lt;code&gt;ResourceName&lt;/code&gt;通常是空的，因为 Envoy 总是需要知道所有的相关数据。而对于&lt;code&gt;eds&lt;/code&gt;，&lt;code&gt;rds&lt;/code&gt;来讲，Envoy 则可以选择性的指明需要监控的资源对象列表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TypeUrl&lt;/code&gt;
&lt;code&gt;ads&lt;/code&gt;服务将原来分开的单独&lt;code&gt;xds&lt;/code&gt;服务，如&lt;code&gt;cds&lt;/code&gt;、&lt;code&gt;lds&lt;/code&gt;等，合并在同一个双向 streaming 的 gRPC 连接上。所以当 Envoy 向 discovery server 发送&lt;code&gt;DiscoveryRequest&lt;/code&gt;时，需要使用&lt;code&gt;TypeUrl&lt;/code&gt;来指明当前请求的服务类型。&lt;code&gt;TypeUrl&lt;/code&gt;值可以是&lt;code&gt;cds&lt;/code&gt;、&lt;code&gt;lds&lt;/code&gt;等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReponseNonce&lt;/code&gt;
discovery service 的&lt;code&gt;StreamAggregatedResources&lt;/code&gt;方法提供的双向 streaming &lt;code&gt;ads&lt;/code&gt;服务中，discovery service 可以连续向 Envoy 发送多个&lt;code&gt;DiscoveryResponse&lt;/code&gt;。当 Envoy 收到&lt;code&gt;DiscoveryResponse&lt;/code&gt;后，会发送&lt;code&gt;DiscoveryRequest&lt;/code&gt;来 ACK 之前的&lt;code&gt;DiscoveryResponse&lt;/code&gt;。为了减少歧义，Envoy 使用&lt;code&gt;ReponseNonce&lt;/code&gt;指定当前&lt;code&gt;DiscoveryRequest&lt;/code&gt;ACK 的是之前的哪个&lt;code&gt;DiscoveryResponse&lt;/code&gt;。具体设置方式就是把&lt;code&gt;ReponseNonce&lt;/code&gt;指定为需要 ACK 的&lt;code&gt;DiscoveryResponse&lt;/code&gt;中的&lt;code&gt;Nonce&lt;/code&gt;值，关于 discovery server 如何在&lt;code&gt;DiscoveryResponse&lt;/code&gt;中设置&lt;code&gt;Nonce&lt;/code&gt;，详见下文的分析。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ErrorDetail&lt;/code&gt;
当 Envoy 处理来自 discovery server 的&lt;code&gt;DiscoveryResponse&lt;/code&gt;的过程中发生错误时，会在 ACK/NACK 的&lt;code&gt;DiscoveryRequest&lt;/code&gt;中带上具体错误信息&lt;code&gt;ErrorDetail&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据 discovery server 收到的&lt;code&gt;DiscoveryRequest&lt;/code&gt;中指定的请求服务类型（&lt;code&gt;TypeUrl&lt;/code&gt;），istio 的&lt;code&gt;ads&lt;/code&gt;服务统一封装了&lt;code&gt;cds&lt;/code&gt;、&lt;code&gt;lds&lt;/code&gt;、&lt;code&gt;rds&lt;/code&gt;和&lt;code&gt;eds&lt;/code&gt;4 种服务，即在同一个双向 streaming 的 gRPC 连接上提供这 4 种服务。&lt;/p&gt;
&lt;p&gt;接下来本文按照&lt;code&gt;ads&lt;/code&gt;在配置发生变更时对外的 push &lt;code&gt;xds&lt;/code&gt;信息的顺序，分别描述&lt;code&gt;cds&lt;/code&gt;、&lt;code&gt;eds&lt;/code&gt;。由于篇幅限制，&lt;code&gt;rds&lt;/code&gt;和&lt;code&gt;lds&lt;/code&gt;且听下回分解。&lt;/p&gt;
&lt;h3 id=&#34;cds服务&#34;&gt;&lt;code&gt;cds&lt;/code&gt;服务&lt;/h3&gt;
&lt;p&gt;如本文前面介绍，&lt;code&gt;cds&lt;/code&gt;，即 cluster discovery service，是 pilot-discovery 为 Envoy 动态提供 cluster 相关信息的协议。Envoy 可以向 pilot-discovery 的 gRPC server 发送一个&lt;code&gt;DiscoveryRequest&lt;/code&gt;，并将需要获取的配置信息类型（&lt;code&gt;TypeUrl&lt;/code&gt;）设置为&lt;code&gt;cds&lt;/code&gt;。discovery server，即&lt;code&gt;ads&lt;/code&gt;服务的实现类，在收到&lt;code&gt;DiscoveryRequest&lt;/code&gt;后，将 Abstract Model 中保存的相关信息组装成 cluster，然后封装在&lt;code&gt;DiscoveryResponse&lt;/code&gt;返回给 Envoy。&lt;/p&gt;
&lt;p&gt;discovery server 为了组装出 cluster 信息，需要从 Abstract Model 中提取以下两类信息类型；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务注册信息：如从 Kubernetes 中的服务注册信息转化而来的 service&lt;/li&gt;
&lt;li&gt;通过 istioctl 提供的配置信息，如&lt;code&gt;DestinationRule&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;discovery server 将这两类信息组装成 cluster 信息的流程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取 abstract model 中保存的 service 信息，为每个 service 创建一个“空白”的 cluster 对象
以 Kubernetes 作为服务注册中心的情况为例，abstract model 中的 service 信息主要有两个来源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Kubernetes 中定义的 service 资源对象&lt;/li&gt;
&lt;li&gt;通过 istioctl 配置的&lt;code&gt;ServiceEntry&lt;/code&gt; 资源对象，用来代表那些没有注册在服务注册中心的服务，比如运行在 Kubernetes 之外的一个数据库。这些资源对象也保存在 Kubernetes 中，以 CRD 的形式存在。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 cluster 名称，形式为：&lt;code&gt;outbound|service端口号||Hostname&lt;/code&gt;
其中的 service 端口号对应 Kubernetes 中 service 对象的端口号，而 Hostname 就是 service mesh 中客户端方用来访问服务方的地址，形式为&lt;code&gt;&amp;lt;name&amp;gt;.&amp;lt;namespace&amp;gt;.svc.cluster.local&lt;/code&gt;。其中&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;namespace&lt;/code&gt;分别为 Kubernetes service 对象的 name 和所属的 namespace，&lt;code&gt;cluster.local&lt;/code&gt;为默认 domain suffix。其中第三项对 cluster 来说是空白信息，只对 subcluster 有效，详见下面的分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 cluster 的默认流量控制策略，如：默认的负载均衡策略为 round robin，默认的 timeout 时间等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置与该 cluster 相关的&lt;code&gt;eds&lt;/code&gt;更新方式。istio 中每个 cluster 都可以&lt;a href=&#34;https://groups.google.com/forum/#!topic/envoy-users/DDn_R6Tfiks&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;单独配置相关&lt;code&gt;eds&lt;/code&gt;的更新方式&lt;/a&gt;，即告诉 Envoy 下次请求&lt;code&gt;eds&lt;/code&gt;信息时，应该采用何种方式。从 istio 2018 年 4 月的一个 commit（67be0412）开始统一使用&lt;code&gt;ads&lt;/code&gt;作为&lt;code&gt;eds&lt;/code&gt;更新方法，而不是单独与 discovery server 建立 gRPC 连接来更新&lt;code&gt;eds&lt;/code&gt;信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据 service 的&lt;code&gt;HostName&lt;/code&gt;属性查找对应的&lt;code&gt;DestinationRule&lt;/code&gt;。根据&lt;code&gt;DestinationRule&lt;/code&gt;中定义的&lt;code&gt;subset&lt;/code&gt;创建 subcluster。
使用 istioctl 创建的&lt;code&gt;DestinationRule&lt;/code&gt;资源可以用来表达同一个服务的多个版本。比如下面的 DestinationRule 定义了&lt;code&gt;reviews&lt;/code&gt;服务的 3 个&lt;code&gt;subset&lt;/code&gt;，每个&lt;code&gt;subset&lt;/code&gt;对应&lt;code&gt;reviews&lt;/code&gt;服务的一个版本：v1、v2 和 v3。在 Kubernetes 环境下翻译过来就是具有 label version=v1 的 service 是 v1 版本的 reviews 服务，具有 label version=v2 的 service 是 v2 版本的 reviews 服务，以此类推。
针对这里的每个版本（subset），需要创建一个单独的 subcluster（其实就是一个独立的 cluster），subcluster 具有跟前面创建的 cluster 有类似的名称，形式为&lt;code&gt;outbound|service端口号|subset名称|Hostname&lt;/code&gt;，注意这里的第三项不再是空白。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DestinationRule&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reviews&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reviews&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;trafficPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;loadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RANDOM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subsets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;trafficPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;loadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;simple&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ROUND_ROBIN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;6&lt;/em&gt;.   根据 DestinationRule 里定义的 traffic policy，为 cluster、subcluster 配置流量控制策略，包括 connection pool、outlier detection、负载均衡策略，upstream tls 设置等。
仔细看上面定义的叫&lt;code&gt;reviews&lt;/code&gt;的&lt;code&gt;DestinationRule&lt;/code&gt;，我们可以看到里面定义了 2 个 traffic policy，第一个 traffic policy 定义了整体负载均衡策略为&lt;code&gt;RANDOM&lt;/code&gt;，第二个 traffic policy 专门针对 subset v2，设置负载均衡为 ROUND_ROBIN。定义在顶层的&lt;code&gt;RANDOM&lt;/code&gt;整体负载均衡策略会影响到每个 subcluster。&lt;/p&gt;
&lt;p&gt;discovery server 在组装完成上述 cluster 对象之后，将得到的所有 cluster 封装在一个&lt;code&gt;DiscoveryResponse&lt;/code&gt;中，将&lt;code&gt;DiscoveryResponse&lt;/code&gt;的类型（即&lt;code&gt;TypeUrl&lt;/code&gt;）设置为&lt;code&gt;type.googleapis.com/envoy.api.v2.Cluster&lt;/code&gt;， &lt;code&gt;Nonce&lt;/code&gt;设置为当前时间（nonce 的解释见本文前面部分）, 启动单独的协程通过与 Envoy 建立的双向 stream gRPC 连接发送给 Envoy，发送超时为 5 秒。&lt;/p&gt;
&lt;h3 id=&#34;eds服务&#34;&gt;&lt;code&gt;eds&lt;/code&gt;服务&lt;/h3&gt;
&lt;p&gt;Envoy 通过&lt;code&gt;cds&lt;/code&gt;服务获取 service mesh 中的 cluster（应用集群）信息之后，还需要知道每个 cluster 所代表的应用集群中的成员信息，即 endpoint。因此，Envoy 可以在向 discovery server 调用&lt;code&gt;cds&lt;/code&gt;服务之后，继续向 discovery server 发送&lt;code&gt;TypeUrl&lt;/code&gt;为&lt;code&gt;eds&lt;/code&gt;的&lt;code&gt;DiscoveryRequest&lt;/code&gt;，从而请求 endpoint 信息。&lt;/p&gt;
&lt;p&gt;Envoy 发给 discovery server 的&lt;code&gt;DiscoveryRequest&lt;/code&gt;中会在&lt;code&gt;ResourceNames&lt;/code&gt;成员中包含它所关注的 cluster 的名称列表，当前 istio 支持两种 cluster 命名方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;outbound|&amp;lt;port&amp;gt;|&amp;lt;subset name&amp;gt;|&amp;lt;name&amp;gt;.&amp;lt;namespace&amp;gt;&lt;/code&gt;
其中&lt;code&gt;port&lt;/code&gt;为 int 型的服务端口号，subset name 来自对应的 DestinationRule 中定义的 subset 的名称，&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;namespace&lt;/code&gt;分别为 service 的名称和所属的 namespace。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;name&amp;gt;.&amp;lt;namespace&amp;gt;.svc.cluster.local|&amp;lt;port name&amp;gt;|&amp;lt;label&amp;gt;&lt;/code&gt;
这是被 deprecated 的 cluster 命名方法，在代码中被戏称为是来自古希腊时代的命名方式。其中&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;namespace&lt;/code&gt;是对应 service 的 name 和所属的 namespace，&lt;code&gt;cluster.local&lt;/code&gt;是 domain suffix，&lt;code&gt;port name&lt;/code&gt;是用“,”分隔的一个或多个端口名称，&lt;code&gt;label&lt;/code&gt;是用“;”分隔的&lt;code&gt;key=value&lt;/code&gt;形式的一个或多个键值对。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Discovery server 处理&lt;code&gt;eds&lt;/code&gt;类型的&lt;code&gt;DiscoveryRequest&lt;/code&gt;的逻辑相对简单，流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据 cluster 的名称，把对应 Kubernetes 中 service 对象的 name 和所属的 namespace 解析出来。使用 Kubernetes 的 client-go 库中的&lt;code&gt;SharedIndexInformer&lt;/code&gt;获取 Kubernetes 中的 service 对象。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;SharedIndexInformer&lt;/code&gt;获取 Kubernetes 中的 endpoint 所有对象（&lt;code&gt;SharedIndexInformer&lt;/code&gt;包含了本地缓机制，所以并非每次处理&lt;code&gt;eds&lt;/code&gt;类型的&lt;code&gt;DiscoveryRequest&lt;/code&gt;都需要从 Kubernetes 同步大量数据），选择其中 name 和 namespace 匹配的 endpoint。&lt;/li&gt;
&lt;li&gt;使用 subset 中的 label（不知道 subset 中的 label 代表什么意思的同学，请回忆前面分析&lt;code&gt;cds&lt;/code&gt;中关于 subcluster 构建过程），比如&lt;code&gt;version=v1&lt;/code&gt;，再次过滤上步被筛选过的 endpoint。&lt;/li&gt;
&lt;li&gt;获取 endpoint 的 ip、端口和可用域（availability zone）等信息。其中的可用域由 endpoint 对应的 pod 所运行的 node 上的两个“著名”label 的 value 构成（中间用&amp;rdquo;/&amp;ldquo;分隔），label 的 key 分别为：&lt;code&gt;&amp;quot;failure-domain.beta.kubernetes.io/region&amp;quot;&lt;/code&gt;和&lt;code&gt;&amp;quot;failure-domain.beta.kubernetes.io/zone&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;根据可用域信息（locality）将 endpoint 分组，每个 locality 对应一个&lt;code&gt;LocalityLbEndpoints&lt;/code&gt;对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Discovery server 在获取 endpoint 之后，将他们封装在&lt;code&gt;DiscoveryResponse&lt;/code&gt;中，将&lt;code&gt;DiscoveryResponse&lt;/code&gt;的类型（即&lt;code&gt;TypeUrl&lt;/code&gt;）设置为&lt;code&gt;type.googleapis.com/envoy.api.v2.ClusterLoadAssignment&lt;/code&gt;，&lt;code&gt;Nonce&lt;/code&gt;设置为当前时间（nonce 的解释见本文前面部分）, 启动单独的协程通过与 Envoy 建立的双向 stream gRPC 连接发送给 Envoy，发送超时为 5 秒。&lt;/p&gt;
&lt;h2 id=&#34;本文作者&#34;&gt;本文作者&lt;/h2&gt;
&lt;p&gt;丁轶群博士&lt;/p&gt;
&lt;p&gt;谐云科技 CTO&lt;/p&gt;
&lt;p&gt;2004 年作为高级技术顾问加入美国道富银行 (浙江) 技术中心，负责分布式大型金融系统的设计与研发。2011 年开始领导浙江大学开源云计算平台的研发工作，是浙江大学 SEL 实验室负责人，2013 年获得浙江省第一批青年科学家称号，CNCF 会员，多次受邀在 Cloud Foundry, Docker 大会上发表演讲，《Docker：容器与容器云》主要作者之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原创文章，未经允许，不得转载！&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh 深度学习系列 part2—istio 源码分析之 pilot-discovery 模块分析</title>
      <link>https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin/</link>
      <pubDate>Tue, 17 Jul 2018 17:32:31 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin/</guid>
      <description>&lt;p&gt;本文分析的 istio 代码版本为 0.8.0，commit 为 0cd8d67，commit 时间为 2018 年 6 月 18 日。&lt;/p&gt;
&lt;p&gt;本文为&lt;code&gt;Service Mesh深度学习系列&lt;/code&gt;之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-agent-deepin&#34;&gt;Service Mesh 深度学习系列 part1—istio 源码分析之 pilot-agent 模块分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin&#34;&gt;Service Mesh 深度学习系列 part2—istio 源码分析之 pilot-discovery 模块分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2&#34;&gt;Service Mesh 深度学习系列 part3—istio 源码分析之 pilot-discovery 模块分析（续）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pilot-总体架构&#34;&gt;pilot 总体架构&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-pilot-总体架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio pilot 总体架构图&#34; srcset=&#34;
               /blog/istio-service-mesh-source-code-pilot-discovery-module-deepin/006tKfTcgy1ftczrqzgw5j31kw0t1q7o_hu13589011800751434761.webp 400w,
               /blog/istio-service-mesh-source-code-pilot-discovery-module-deepin/006tKfTcgy1ftczrqzgw5j31kw0t1q7o_hu12973656052981333752.webp 760w,
               /blog/istio-service-mesh-source-code-pilot-discovery-module-deepin/006tKfTcgy1ftczrqzgw5j31kw0t1q7o_hu12495048747309803761.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin/006tKfTcgy1ftczrqzgw5j31kw0t1q7o_hu13589011800751434761.webp&#34;
               width=&#34;760&#34;
               height=&#34;388&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio pilot 总体架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先我们回顾一下 pilot 总体架构，上面是&lt;a href=&#34;https://github.com/istio/old_pilot_repo/blob/master/doc/design.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方关于 pilot 的架构图&lt;/a&gt;，因为是 old_pilot_repo 目录下，可能与最新架构有出入，仅供参考。所谓的 pilot 包含两个组件：pilot-agent 和 pilot-discovery。图里的 agent 对应 pilot-agent 二进制，proxy 对应 Envoy 二进制，它们两个在同一个容器中，discovery service 对应 pilot-discovery 二进制，在另外一个跟应用分开部署的单独的 deployment 中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;discovery service&lt;/strong&gt;：从 Kubernetes apiserver list/watch &lt;code&gt;service&lt;/code&gt;、&lt;code&gt;endpoint&lt;/code&gt;、&lt;code&gt;pod&lt;/code&gt;、&lt;code&gt;node&lt;/code&gt;等资源信息，监听 istio 控制平面配置信息（Kubernetes CRD），翻译为 Envoy 可以直接理解的配置格式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;proxy&lt;/strong&gt;：也就是 Envoy，直接连接 discovery service，间接地从 Kubernetes apiserver 等服务注册中心获取集群中微服务的注册情况&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;agent&lt;/strong&gt;：本文分析对象 pilot-agent，生成 Envoy 配置文件，管理 Envoy 生命周期&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;service A/B&lt;/strong&gt;：使用了 istio 的应用，如 Service A/B的进出网络流量会被proxy接管&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;对于模块的命名方法，本文采用模块对应源码 main.go 所在包名称命名法。其他 istio 分析文章有其他命名方法。比如 pilot-agent 也被称为 istio pilot，因为它在 Kubernetes 上的部署形式为一个叫 istio-pilot 的 deployment。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;pilot-discovery-的部署存在形式&#34;&gt;pilot-discovery 的部署存在形式&lt;/h2&gt;
&lt;p&gt;pilot-discovery 是单独二进制，被封装在&lt;code&gt;Dockerfile.pilot&lt;/code&gt;里，在&lt;code&gt;istio-docker.mk&lt;/code&gt;里被 build 成&lt;code&gt;$(HUB)/pilot:$(TAG)&lt;/code&gt;镜像。&lt;/p&gt;
&lt;p&gt;根据&lt;code&gt;istio-pilot.yaml.tmpl&lt;/code&gt;，在 Kubernetes 环境下，pilot 镜像并非 sidecar 的一部分，也不是 daemonset 在每个机器上都有，而是单独部署成一个 replica=1 的 deployment。&lt;/p&gt;
&lt;h2 id=&#34;pilot-discovery-的功能简述&#34;&gt;pilot-discovery 的功能简述&lt;/h2&gt;
&lt;p&gt;pilot-discovery 扮演服务注册中心、istio 控制平面到 Envoy 之间的桥梁作用。pilot-discovery 的主要功能包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;监控服务注册中心（如 Kubernetes）的服务注册情况。在 Kubernetes 环境下，会监控&lt;code&gt;service&lt;/code&gt;、&lt;code&gt;endpoint&lt;/code&gt;、&lt;code&gt;pod&lt;/code&gt;、&lt;code&gt;node&lt;/code&gt;等资源信息。监控 istio 控制面信息变化，在 Kubernetes 环境下，会监控包括&lt;code&gt;RouteRule&lt;/code&gt;、&lt;code&gt;VirtualService&lt;/code&gt;、&lt;code&gt;Gateway&lt;/code&gt;、&lt;code&gt;EgressRule&lt;/code&gt;、&lt;code&gt;ServiceEntry&lt;/code&gt;等以 Kubernetes CRD 形式存在的 istio 控制面配置信息。&lt;/li&gt;
&lt;li&gt;将上述两类信息合并组合为 Envoy 可以理解的（即遵循 Envoy data plane api 的）配置信息，并将这些信息以 gRPC 协议提供给 Envoy&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;pilot-discovery-主要功能分析之一初始化&#34;&gt;pilot-discovery 主要功能分析之一：初始化&lt;/h2&gt;
&lt;p&gt;pilot-discovery 的初始化主要在 pilot-discovery 的&lt;code&gt;init&lt;/code&gt;方法和在&lt;code&gt;discovery&lt;/code&gt;命令处理流程中调用的&lt;code&gt;bootstrap.NewServer&lt;/code&gt;完成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;pilot-discovery 的&lt;code&gt;init&lt;/code&gt;方法为 pilot-discovery 的&lt;code&gt;discovery&lt;/code&gt;命令配置一系列 flag 及其默认值。flag 值被保存在 bootstrap 包的&lt;code&gt;PilotArgs&lt;/code&gt;对象中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bootstrap.NewServer&lt;/code&gt;利用&lt;code&gt;PilotArgs&lt;/code&gt;构建 bootstrap 包下的&lt;code&gt;server&lt;/code&gt;对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;bootstrap.NewServer&lt;/code&gt;工作流程如下。&lt;/p&gt;
&lt;h3 id=&#34;1-创建-kubernetes-apiserver-clientinitkubeclient-方法&#34;&gt;1. 创建 Kubernetes apiserver client（initKubeClient 方法）&lt;/h3&gt;
&lt;p&gt;根据服务注册中心配置是否包含 Kubernetes（一个 istio service mesh 可以连接多个服务注册中心）创建&lt;code&gt;kubeClient&lt;/code&gt;，保存在&lt;code&gt;Server.kubeClient&lt;/code&gt;成员中。&lt;code&gt;kubeClient&lt;/code&gt;有两种创建方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户提供 kubeConfig 文件，可以在 pilot-discovery 的&lt;code&gt;discovery&lt;/code&gt;命令的&lt;code&gt;kubeconfig&lt;/code&gt; flag 中提供文件路径，默认为空。&lt;/li&gt;
&lt;li&gt;当用户没有提供 kubeConfig 配置文件时，使用 in cluster config 配置方式，也就是让 pilot-discovery 通过所在的运行环境，也就是运行着的 Kubernetes pod 环境，感知集群上下文，自动完成配置。client-go 库的注释说这种方式可能有问题：Using the inClusterConfig.  This might not work&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-多集群-kubernetes-配置initclusterregistryies-方法&#34;&gt;2. 多集群 Kubernetes 配置（initClusterRegistryies 方法）&lt;/h3&gt;
&lt;p&gt;istio 支持使用一个 istio control plane 来管理跨多个 Kubernetes 集群上的 service mesh。这个叫“multicluster”功能的具体描述参考&lt;a href=&#34;https://istio.io/docs/setup/Kubernetes/multicluster-install/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;，当前此特性成熟度仅是&lt;a href=&#34;https://istio.io/about/feature-stages/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;alpha 水平&lt;/a&gt;。Istio 的控制平面组件（如 pilot-discovery）运行所在的 Kubernetes 集群叫本地集群，通过这个 istio 控制面板连接的其他 Kubernetes 集群叫远程集群（remote cluster）。remote cluster 信息被保存在&lt;code&gt;Server.clusterStore&lt;/code&gt;成员中，里面包含一个 map，将&lt;code&gt;Metadata&lt;/code&gt;映射成&lt;code&gt;RemoteCluster&lt;/code&gt;对象。&lt;code&gt;clusterStore&lt;/code&gt;的具体创建流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检测上一步骤是否创建好&lt;code&gt;kubeClient&lt;/code&gt;。否，则直接报错返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检测服务注册中心中是否包含 Mock 类型，是的话直接返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 pilot-discovery &lt;code&gt;discovery&lt;/code&gt;命令的 flag &lt;code&gt;clusterRegistriesConfigMap&lt;/code&gt;不为空，则从本地 Kubernetes 集群中读取一个包含远程 Kubernetes 集群访问信息的 configmap（configmap 所在的默认命名空间为&lt;code&gt;“istio-system”&lt;/code&gt;，名字通过 discovery 命令 flag &lt;code&gt;clusterRegistriesConfigMap&lt;/code&gt;设定）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个 configmap 包含 Kubernetes 远程集群的访问信息，其形式为键值对。其 key 为 cluster 唯一标识符，value 为一个使用 yaml 或 json 编码的&lt;code&gt;Cluster&lt;/code&gt;对象。  &lt;code&gt;Cluster&lt;/code&gt;对象的 Annotations 指定一个本地 Kubernetes 集群中的 secret（secret 所在命名空间对应的 annotation key 为&lt;code&gt;config.istio.io/accessConfigSecret&lt;/code&gt;，默认为&lt;code&gt;istio-system&lt;/code&gt;，secret 名称对应 annotation key 为&lt;code&gt;config.istio.io/accessConfigSecretNamespace&lt;/code&gt;）。
到本地 Kubernetes 集群中读取 secret 内容，根据这个内容构建保存在&lt;code&gt;clusterStore&lt;/code&gt;中的 RemoteCluster 对象，对应一个远程 Kubernetes 集群。&lt;/p&gt;
&lt;h3 id=&#34;3-读取-mesh-配置initmesh-方法&#34;&gt;3. 读取 mesh 配置（initMesh 方法）&lt;/h3&gt;
&lt;p&gt;mesh 配置由&lt;code&gt;MeshConfig&lt;/code&gt;结构体定义，包含&lt;code&gt;MixerCheckServer&lt;/code&gt;、&lt;code&gt;MixerReportServer&lt;/code&gt;、&lt;code&gt;ProxyListenPort&lt;/code&gt;、&lt;code&gt;RdsRefreshDelay&lt;/code&gt;、&lt;code&gt;MixerAddress&lt;/code&gt;等一些列配置。这里读取默认 mesh 配置文件&amp;quot;/etc/istio/config/mesh&amp;quot;（用户可以通过 discovery 命令的 flag &lt;code&gt;meshConfig&lt;/code&gt;提供自定义值）。如果配置文件读取失败，也可以从 Kubernetes 集群中读取 configmap 获得默认的配置。作为测试，这里也读取 flag 来覆盖 mesh 配置的&lt;code&gt;MixerCheckServer&lt;/code&gt;和&lt;code&gt;MixerReportServer&lt;/code&gt;（但是这两个 flag 在 pilot-discovery 的 init 方法中并没有配置）&lt;/p&gt;
&lt;h3 id=&#34;4-配置-mixersaninitmixersan-方法&#34;&gt;4. 配置 MixerSan（initMixerSan 方法）&lt;/h3&gt;
&lt;p&gt;如果 mesh 配置中的控制平面认证策略为 mutual TLS(默认为 none)，则配置 mixerSan&lt;/p&gt;
&lt;h3 id=&#34;5-初始化与配置存储中心的连接initconfigcontroller-方法&#34;&gt;5. 初始化与配置存储中心的连接（initConfigController 方法）&lt;/h3&gt;
&lt;p&gt;对 istio 做出的各种配置，比如 route rule、virtualservice 等，需要保存在配置存储中心（config store）内，istio 当前支持 2 种形式的 config store:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;i) 文件存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 pilot-discovery &lt;code&gt;discovery&lt;/code&gt;命令的&lt;code&gt;configDir&lt;/code&gt; flag 来设置配置文件的文件系统路径，默认为&lt;code&gt;“configDir”&lt;/code&gt;。后续使用 pilot/pkg/config/memory 包下的 controller 和 pilot/pkg/config/monitor 持续监控配置文件的变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ii) Kubernetes CRD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以 Kubernetes apiserver 作为 config store 的情况下，config store 的初始化流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;读取 pilot-discovery &lt;code&gt;discovery&lt;/code&gt;命令的&lt;code&gt;kubeconfig&lt;/code&gt; flag 配置的 kubeconfig 配置文件，flag 默认为空。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注册 Kubernetes CRD 资源。注册的资源类型定义在 bootstrap 包下的全局变量&lt;code&gt;ConfigDescriptor&lt;/code&gt;变量里，包括：&lt;code&gt;RouteRule&lt;/code&gt;、 &lt;code&gt;VirtualService&lt;/code&gt;、 &lt;code&gt;Gateway&lt;/code&gt;、
&lt;code&gt;EgressRule&lt;/code&gt;、 &lt;code&gt;ServiceEntry&lt;/code&gt;、 &lt;code&gt;DestinationPolicy&lt;/code&gt;、 &lt;code&gt;DestinationRule&lt;/code&gt;、 &lt;code&gt;HTTPAPISpec&lt;/code&gt;、 &lt;code&gt;HTTPAPISpecBinding&lt;/code&gt;、 &lt;code&gt;QuotaSpec&lt;/code&gt;、 &lt;code&gt;QuotaSpecBinding&lt;/code&gt;、 &lt;code&gt;AuthenticationPolicy&lt;/code&gt;,
&lt;code&gt;AuthenticationMeshPolicy&lt;/code&gt;、 &lt;code&gt;ServiceRole&lt;/code&gt;、 &lt;code&gt;ServiceRoleBinding&lt;/code&gt;、 &lt;code&gt;RbacConfig&lt;/code&gt;。其中&lt;code&gt;RouteRule&lt;/code&gt;、 &lt;code&gt;EgressRule&lt;/code&gt;、 &lt;code&gt;DestinationPolicy&lt;/code&gt;、 &lt;code&gt;HTTPAPISpec&lt;/code&gt;、 &lt;code&gt;HTTPAPISpecBinding&lt;/code&gt;、 &lt;code&gt;QuotaSpec&lt;/code&gt;、 &lt;code&gt;QuotaSpecBinding&lt;/code&gt;、 &lt;code&gt;ServiceRole&lt;/code&gt;、 &lt;code&gt;ServiceRoleBinding&lt;/code&gt;、 &lt;code&gt;RbacConfig&lt;/code&gt;对应 istio v1alpha2 版本 api，&lt;code&gt;VirtualService&lt;/code&gt;、&lt;code&gt;Gateway&lt;/code&gt;、&lt;code&gt;ServiceEntry&lt;/code&gt;、&lt;code&gt;DestinationRule&lt;/code&gt;对应 istio v1alpha3 版本 api&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以文件作为 config store 显然不灵活，所以我们可以说 istio 的流量管理策略等控制面信息存储依赖 Kubernetes 的 apiserver。那么当使用 cloud foundry 等其他非 Kubernetes 平台作为服务注册中心的时候，istio 就需要实现一个“假的”Kubernetes apiserver，不过目前这个工作并没完成，详见社区的一些&lt;a href=&#34;https://groups.google.com/forum/#!topic/istio-dev/bhMpHikwrp0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;相关讨论&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;CRD 资源注册完成之后将创建 config controller，搭建对 CRD 资源 Add、Update、Delete 事件的处理框架。对该框架的处理会在本文&amp;quot;pilot-discovery 主要功能分析之二：istio 控制面信息监控与处理&amp;quot;中描述。&lt;/p&gt;
&lt;h3 id=&#34;6-配置与服务注册中心service-registry的连接initservicecontrollers-方法&#34;&gt;6. 配置与服务注册中心（service registry）的连接（initServiceControllers 方法）&lt;/h3&gt;
&lt;p&gt;istio 需要从服务注册中心（service registry）获取服务注册的情况。代表 pilot-discovery 的 server 对象包含一个&lt;code&gt;ServiceController&lt;/code&gt;对象，一个&lt;code&gt;ServiceController&lt;/code&gt;对象包含一个或多个 service controller(是的，这两个名字只有大小写区别)。每个 service controller 负责连接服务注册中心并同步相关的服务注册信息。&lt;/p&gt;
&lt;p&gt;当前 istio 支持的服务注册中心类型包括 ConfigRegistry, MockRegistry, Kubernetes, Consul, Eureka 和 CloudFoundry。不过仅对 Kubernetes 服务注册中心的支持成熟度达到 stable 水平，其他服务注册中心的集成工作成熟度还都处于 alpha 水平。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ServiceController&lt;/code&gt;对象的结构体定义在 aggregate 包下，从包名可以看出一个&lt;code&gt;ServiceController&lt;/code&gt;对象是对多个 service controller 的聚合。所谓聚合，也就是当对&lt;code&gt;ServiceController&lt;/code&gt;操作时，会影响到其聚合的所有 service controller。比如，当我们向&lt;code&gt;ServiceController&lt;/code&gt;注册一个服务注册信息变更事件处理 handler 时，实际上会将 handler 注册到所有的 service controller 上。&lt;/p&gt;
&lt;p&gt;具体 service controller 对服务注册信息的变更处理流程框架将在本文“pilot-discovery 主要功能分析之三：服务注册信息监控与处理”中描述。&lt;/p&gt;
&lt;h3 id=&#34;7-初始化-discovery-服务initdiscoveryservice&#34;&gt;7. 初始化 discovery 服务（initDiscoveryService）&lt;/h3&gt;
&lt;p&gt;istio service mesh 中的 envoy sidecar 通过连接 pilot-discovery 的 discovery 服务获取服务注册情况、流量控制策略等控制面的控制信息。discovery 服务的初始化主要包括如下几步：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;i) 创建对外提供 REST 协议的 discovery 服务的 discovery service 对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;istio 代码在 2018 年 6 月的一次 commit（e99cad5）中删除了大量与 Envoy v1 版本的 data plane api 相关代码。当前版本的 istio 中，作为 sidecar 的 Envoy 已经不再使用 REST 协议获取控制面信息。与 v1 版本 Envoy data plane api 相关的&lt;code&gt;cds&lt;/code&gt;、&lt;code&gt;rds&lt;/code&gt;、&lt;code&gt;lds&lt;/code&gt;相关代码都已被删除，仅残留&lt;code&gt;sds&lt;/code&gt;部分代码。因此作为&lt;code&gt;sds&lt;/code&gt;的残留功能，用户依然可以访问&lt;code&gt;&amp;quot;/v1/registration&amp;quot;&lt;/code&gt;URL 访问与服务&lt;code&gt;endpoint&lt;/code&gt;相关的信息，但 Envoy 并不会访问这个 URL。discovery service 默认通过 8080 端口对外提供服务，可以通过 pilot-discovery 的&lt;code&gt;discovery&lt;/code&gt;命令的&lt;code&gt;httpAddr&lt;/code&gt; flag 自定义端口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ii) 创建对外提供 gRPC 协议 discovery 服务的 Envoy xds server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓的&lt;code&gt;xds&lt;/code&gt;代表 Envoy v2 data plane api 中的&lt;code&gt;eds&lt;/code&gt;、 &lt;code&gt;cds&lt;/code&gt;、 &lt;code&gt;rds&lt;/code&gt;、 &lt;code&gt;lds&lt;/code&gt;、 &lt;code&gt;hds&lt;/code&gt;、 &lt;code&gt;ads&lt;/code&gt;、 &lt;code&gt;kds&lt;/code&gt;等一系列 api。Envoy xds server 默认通过 15010 和 15012 端口对外提供服务，可以通过 pilot-discovery 的&lt;code&gt;discovery&lt;/code&gt;命令的&lt;code&gt;grpcAddr&lt;/code&gt; 、&lt;code&gt;secureGrpcAddr&lt;/code&gt;flag 自定义端口。&lt;/p&gt;
&lt;p&gt;与 Envoy xds server 相关代码分析我们将在系列文章的下一篇分析。&lt;/p&gt;
&lt;h3 id=&#34;8-打开运行情况检查端口initmonitor-方法&#34;&gt;8. 打开运行情况检查端口（initMonitor 方法）&lt;/h3&gt;
&lt;p&gt;pilot-discovery 默认打开 9093 端口（端口号可以通过 pilot-discovery discovery 命令的&lt;code&gt;monitoringAddr&lt;/code&gt; flag 自定义），对外提供 HTTP 协议的自身运行状态检查监控功能。当前提供&lt;code&gt;/metrics&lt;/code&gt;和&lt;code&gt;/version&lt;/code&gt;两个运行状况和基本信息查询 URL。&lt;/p&gt;
&lt;h3 id=&#34;9-监控多-kubernetes-集群中远程集群访问信息变化initmulticlustercontroller-方法&#34;&gt;9. 监控多 Kubernetes 集群中远程集群访问信息变化（initMultiClusterController 方法）&lt;/h3&gt;
&lt;p&gt;当使用一个 istio 控制面构建跨多个 Kubernetes 集群的 service mesh 时，远程 Kubernetes 集群的访问信息保存在 secret 中，此处使用 list/watch 监控 secret 资源的变化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于上面第五点说的两种 config store，代码里实际上还有第三种，通过&lt;code&gt;PilotArgs.Config.Controller&lt;/code&gt;配置。但 pilot-discovery 的&lt;code&gt;init&lt;/code&gt;函数里没找到对应 flag。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上一系列初始化不候通过 bootstrap 包的&lt;code&gt;NewServer&lt;/code&gt;函数带起，在此过程中 pilot-discovery 已经启动一部分协程，开始一些控制逻辑的循环执行。比如在上述第九步中的多 Kubernetes 集群访问信息（secret 资源）的监控，在&lt;code&gt;initMonitor&lt;/code&gt;方法中，实际上已经启动协程，利用 client-go 库开始对 secret 信息的监控（list/watch）与处理。&lt;/p&gt;
&lt;p&gt;而 pilot-discovery 的其他控制逻辑则要在 bootstrap 包下的&lt;code&gt;Server.Start&lt;/code&gt;方法启动，而&lt;code&gt;Start&lt;/code&gt;方法的逻辑是顺序执行之前初始化过程中在&lt;code&gt;server&lt;/code&gt;对象上注册的一系列启动函数（&lt;code&gt;startFunc&lt;/code&gt;）。本文接下来分析 pilot-discovery 的其他主要控制逻辑。TODO 整理有哪些 startfunc&lt;/p&gt;
&lt;h2 id=&#34;pilot-discovery-主要功能分析之二istio-控制面信息监控与处理&#34;&gt;pilot-discovery 主要功能分析之二：istio 控制面信息监控与处理&lt;/h2&gt;
&lt;p&gt;istio 的用户可以通过 istioctl 创建&lt;code&gt;route rule&lt;/code&gt;、&lt;code&gt;virtualservice&lt;/code&gt;等实现对服务网络中的流量管理等配置建。而这些配置需要保存在 config store 中。在当前的 istio 实现中，config store 以 Kubernetes CRD 的形式将&lt;code&gt;virtualservice&lt;/code&gt;等存储在 Kubernetes apiserver 之后的 etcd 中。&lt;/p&gt;
&lt;p&gt;在前面 pilot-discovery 初始化第五步骤中 pilot-discovery 已经完成了&lt;code&gt;RouteRule&lt;/code&gt;、&lt;code&gt;VirtualService&lt;/code&gt;等 CRD 资源在 Kubernetes apiserver 上的注册，接下来 pilot-discovery 还需要在 initConfigController 方法中通过 config controller 搭建 CRD 资源对象处理的框架。config controller 包含以下 3 个部分：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. client&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;client 是一个 rest client 集合，用于连接 Kubernetes apiserver，实现对 istio CRD资源的list/watch。具体而言，为每个CRD资源的group version (如&lt;code&gt;config.istio.io/v1alpha2&lt;/code&gt;、&lt;code&gt;networking.istio.io/v1alpha3&lt;/code&gt;) 创建一个 rest client。该 rest client 里包含了连接 Kubernetes apiserver 需要用到的&lt;code&gt;apimachinary&lt;/code&gt;、&lt;code&gt;client-go&lt;/code&gt;等库里的对象，如&lt;code&gt;GroupVersion&lt;/code&gt;、&lt;code&gt;RESTClient&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. queue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于缓存 istio CRD 资源对象（如&lt;code&gt;virtual-service&lt;/code&gt;、&lt;code&gt;route-rule&lt;/code&gt;等）的 Add、Update、Delete 事件的队列，等待后续由 config controller 处理。详见本文后续描述&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. kinds&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为每种 CRD 资源（如&lt;code&gt;virtual-service&lt;/code&gt;、&lt;code&gt;route-rule&lt;/code&gt;等）创建一个用于 list/watch 的 SharedIndexInformer（Kubernetes client-go 库里的概念）。&lt;/p&gt;
&lt;p&gt;pilot-discovery 在完成 config controller 的创建之后，向 server 对象注册&lt;code&gt;startFunc&lt;/code&gt;，从而在后续 server start 的时候启动 config controller 的主循环逻辑（config controller 的 Run 方法），完成与 istio 控制面信息相关的监控与处理。config controller 主循环主要包括两方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用&lt;code&gt;client-go&lt;/code&gt;库里的SharedIndexInformer实现对CRD资源的list/watch，为每种CRD资源的Add、Update、Delete事件创建处理统一的流程框架。这个流程将 Add、Update、Delete 事件涉及到的 CRD 资源对象封装为一个 Task 对象，并将之 push 到 config controller 的 queue 成员里。Task 对象除了包含 CRD 资源对象之外，还包含事件类型（如 Add、Update、Delete 等），以及处理函数 ChainHandler。ChainHandler 支持多个处理函数的串联。&lt;/li&gt;
&lt;li&gt;启动协程逐一处理 CRD 资源事件（queue.run），处理方法是调用每个从 queue 中取出的 Task 对象上的 ChainHandler&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个流程执行结束之后，只是搭建了 CRD 资源对象变更事件的处理框架，真正 CRD 变更事件的处理逻辑要等到下面在 discovery service 中将相应的 handler 注册到 ChainHandler 当中。&lt;/p&gt;
&lt;h2 id=&#34;pilot-discovery-主要功能分析之三服务注册信息监控与处理&#34;&gt;pilot-discovery 主要功能分析之三：服务注册信息监控与处理&lt;/h2&gt;
&lt;p&gt;istio 需要从服务注册中心（service registry）获取服务注册的情况。当前版本中 istio 可以对接的服务注册中心类型包括 Kubernetes、Consul 等。本小节以 Kubernetes 服务注册中心为例，分析 istio 对服务注册信息的变更处理流程框架。&lt;/p&gt;
&lt;p&gt;pilot-discovery 初始化第六步中通过构建 service controller 实现对 Kubernetes 服务注册信息的监控。pilot-discovery 在完成 service controller 的创建之后，会向 server 对象（server 对象代表 pilot-discovery 组件）注册&lt;code&gt;startFunc&lt;/code&gt;，从而在后续 server start 的时候启动 service controller 的主循环逻辑（service controller 的 Run 方法），完成服务注册信息的监控与处理。service controller 主循环主要包括两方面：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 利用&lt;code&gt;client-go&lt;/code&gt;库里的&lt;code&gt;SharedIndexInformer&lt;/code&gt;监控 Kubernetes 中的&lt;code&gt;service&lt;/code&gt;，&lt;code&gt;endpoints&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;和&lt;code&gt;pod&lt;/code&gt;资源（默认 resync 间隔为 60 秒，可以通过 pilot-discovery discovery 命令的&lt;code&gt;resync&lt;/code&gt; flag 配置）。与 config controller 对于 CRD 资源的处理方式类似，所有&lt;code&gt;service&lt;/code&gt;，&lt;code&gt;endpoints&lt;/code&gt;等资源的 Add，Update 和 Delete 事件都采用统一处理框架。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;i) 将事件封装为 Task 对象，包含：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	a) 事件涉及的资源对象&lt;/p&gt;
&lt;p&gt;​	b) 事件类型：Add、Update 和 Delete&lt;/p&gt;
&lt;p&gt;​	c) Handler：ChainHandler。ChainHandler 支持多个处理函数的串联&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ii) 将 Task 对象 push 到 service controller 的 queue 成员里。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 启动协程逐一处理服务注册信息变更事件（queue.run），处理方法是调用每个从 queue 中取出的 Task 对象上的 ChainHandler&lt;/p&gt;
&lt;p&gt;这个流程执行结束之后，只是搭建了服务注册信息变更事件的处理框架，真正服务注册变更事件的处理逻辑要等到下面在 discovery service 中将相应的 handler 注册到 ChainHandler 当中。&lt;/p&gt;
&lt;h2 id=&#34;pilot-discovery-主要功能分析之四envoy-控制面信息服务&#34;&gt;pilot-discovery 主要功能分析之四：Envoy 控制面信息服务&lt;/h2&gt;
&lt;p&gt;pilot-discovery 创建 Envoy xds server 对外提供 gRPC 协议 discovery 服务。所谓的&lt;code&gt;xds&lt;/code&gt;代表 Envoy v2 data plane api 中的&lt;code&gt;eds&lt;/code&gt;、 &lt;code&gt;cds&lt;/code&gt;、 &lt;code&gt;rds&lt;/code&gt;、 &lt;code&gt;lds&lt;/code&gt;、 &lt;code&gt;hds&lt;/code&gt;、 &lt;code&gt;ads&lt;/code&gt;、 &lt;code&gt;kds&lt;/code&gt;等 api。与 Envoy xds server 相关代码分析我们将在系列文章的下一篇分析。&lt;/p&gt;
&lt;h2 id=&#34;本文作者&#34;&gt;本文作者&lt;/h2&gt;
&lt;p&gt;丁轶群博士&lt;/p&gt;
&lt;p&gt;谐云科技 CTO&lt;/p&gt;
&lt;p&gt;2004 年作为高级技术顾问加入美国道富银行 (浙江) 技术中心，负责分布式大型金融系统的设计与研发。2011 年开始领导浙江大学开源云计算平台的研发工作，是浙江大学 SEL 实验室负责人，2013 年获得浙江省第一批青年科学家称号，CNCF 会员，多次受邀在 Cloud Foundry, Docker 大会上发表演讲，《Docker：容器与容器云》主要作者之一。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh 深度学习系列 part1—istio 源码分析之 pilot-agent 模块分析</title>
      <link>https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-agent-deepin/</link>
      <pubDate>Wed, 11 Jul 2018 14:24:24 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-agent-deepin/</guid>
      <description>&lt;p&gt;本文分析的 istio 代码版本为 0.8.0，commit 为 0cd8d67，commit 时间为 2018 年 6 月 18 日。&lt;/p&gt;
&lt;p&gt;本文为&lt;code&gt;Service Mesh深度学习系列&lt;/code&gt;之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-agent-deepin&#34;&gt;Service Mesh 深度学习系列 part1—istio 源码分析之 pilot-agent 模块分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin&#34;&gt;Service Mesh 深度学习系列 part2—istio 源码分析之 pilot-discovery 模块分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-discovery-module-deepin-part2&#34;&gt;Service Mesh 深度学习系列 part3—istio 源码分析之 pilot-discovery 模块分析（续）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pilot-总体架构&#34;&gt;pilot 总体架构&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-service-mesh-source-code-pilot-agent-deepin/006tKfTcly1ft5wnmvat9j31kw0tu116_hu10694916743365346941.webp 400w,
               /blog/istio-service-mesh-source-code-pilot-agent-deepin/006tKfTcly1ft5wnmvat9j31kw0tu116_hu16420169570023220144.webp 760w,
               /blog/istio-service-mesh-source-code-pilot-agent-deepin/006tKfTcly1ft5wnmvat9j31kw0tu116_hu14390614268239822942.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/istio-service-mesh-source-code-pilot-agent-deepin/006tKfTcly1ft5wnmvat9j31kw0tu116_hu10694916743365346941.webp&#34;
               width=&#34;760&#34;
               height=&#34;398&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

上面是&lt;a href=&#34;https://github.com/istio/old_pilot_repo/blob/master/doc/design.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方关于 pilot 的架构图&lt;/a&gt;，因为是 old_pilot_repo 目录下，可能与最新架构有出入，仅供参考。所谓的 pilot 包含两个组件：pilot-agent 和 pilot-discovery。图里的 agent 对应 pilot-agent 二进制，proxy 对应 envoy 二进制，它们两个在同一个容器中，discovery service 对应 pilot-discovery 二进制，在另外一个跟应用分开部署的单独的 deployment 中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;discovery service&lt;/strong&gt;：从 Kubernetes apiserver list/watch service/endpoint/pod/node等资源信息，监听istio控制平面配置信息（Kubernetes CRD），翻译为 envoy 可以直接理解的配置格式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;proxy&lt;/strong&gt;：也就是 envoy，直接连接 discovery service，间接地从 Kubernetes apiserver 等服务注册中心获取集群中微服务的注册情况&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;agent&lt;/strong&gt;：本文分析对象 pilot-agent，生成 envoy 配置文件，管理 envoy 生命周期&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;service A/B&lt;/strong&gt;：使用了 istio 的应用，如 Service A/B的进出网络流量会被proxy接管&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;对于模块的命名方法，本文采用模块对应源码 main.go 所在包名称命名法。其他 istio 分析文章有其他命名方法。比如 pilot-agent 也被称为 istio pilot，因为它在 Kubernetes 上的部署形式为一个叫 istio-pilot 的 deployment。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;pilot-agent-的部署存在形式&#34;&gt;pilot-agent 的部署存在形式&lt;/h2&gt;
&lt;p&gt;pilot-agent在pilot/cmd包下面，是个单独的二进制。&lt;/p&gt;
&lt;p&gt;pilot-agent 跟 envoy 打包在同一个 docker 镜像里，镜像由 Dockerfile.proxy 定义。Makefile（include 了 tools/istio-docker.mk）把这个 dockerfile build 成了&lt;code&gt;${HUB}/proxy:${TAG}&lt;/code&gt;镜像，也就是 Kubernetes 里跟应用放在同一个 pod 下的 sidecar。非 Kubernetes 情况下需要把 pilot-agent、envoy 跟应用部署在一起，这个就有点“污染”应用的意思了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持 v2 api 的 sidecar 镜像为 proxyv2，镜像中包含的 pilot-agent 和 envoy 二进制文件和 proxy 镜像中的完全相同，只是使用不同的 envoy bootstrap 配置（envoy_bootstrap_tmpl.json vs. envoy_bootstrap_v2.json）。但是当前仅完成部分开发工作，makefile 中 build proxyv2 镜像的 target 默认也不会自动执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以上的 HUB 和 TAG 是编译 istio 源码过程中 makefile 中的一些变量，HUB 对应镜像保存的仓库，TAG 默认为 istio 版本号，如 0.8.0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;pilot-agent-功能简述&#34;&gt;pilot-agent 功能简述&lt;/h2&gt;
&lt;p&gt;在 proxy 镜像中，pilot-agent 负责的工作包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成 envoy 的配置&lt;/li&gt;
&lt;li&gt;启动 envoy&lt;/li&gt;
&lt;li&gt;监控并管理 envoy 的运行状况，比如 envoy 出错时 pilot-agent 负责重启 envoy，或者 envoy 配置变更后 reload envoy&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而 envoy 负责接受所有发往该 pod 的网络流量，分发所有从 pod 中发出的网络流量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据代码中的 sidecar-injector-configmap.yaml（用来配置如何自动化地 inject istio sidecar），inject 过程中，除了 proxy 镜像作为 sidecar 之外，每个 pod 还会带上 initcontainer（Kubernetes 中的概念），具体镜像为 proxy_init。proxy_init 通过注入 iptables 规则改写流入流出 pod 的网络流量规则，使得流入流出 pod 的网络流量重定向到 proxy 的监听端口，而应用对此无感。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;pilot-agent-主要功能分析之一生成-envoy-配置&#34;&gt;pilot-agent 主要功能分析之一：生成 envoy 配置&lt;/h2&gt;
&lt;p&gt;envoy 的配置主要在 pilot-agent 的 init 方法与 proxy 命令处理流程的前半部分生成。其中 init 方法为 pilot-agent 二进制的命令行配置大量的 flag 与 flag 默认值，而 proxy 命令处理流程的前半部分负责将这些 flag 组装成为 envoy 的配置 ProxyConfig 对象。下面分析几个相对重要的配置。&lt;/p&gt;
&lt;h3 id=&#34;role&#34;&gt;role&lt;/h3&gt;
&lt;p&gt;pilot-agent 的 role 类型为 model 包下的 Proxy，决定了 pilot-agent 的“角色”，role 包括以下属性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Type
pilot-agent 有三种运行模式。根据 role.Type 变量定义，类型为 model.Proxy，定义在 context.go 文件中，允许的 3 个取值范围为：
&lt;ol&gt;
&lt;li&gt;&amp;ldquo;sidecar&amp;rdquo;
默认值，可以在启动 pilot-agent，调用 proxy 命令时覆盖。Sidecar type is used for sidecar proxies in the application containers&lt;/li&gt;
&lt;li&gt;&amp;ldquo;ingress&amp;rdquo;
Ingress type is used for cluster ingress proxies&lt;/li&gt;
&lt;li&gt;&amp;ldquo;router&amp;rdquo;
Router type is used for standalone proxies acting as L7/L4 routers&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;IPAddress, ID, Domain
它们都可以通过 pilot-agent 的 proxy 命令的对应 flag 来提供用户自定义值。如果用户不提供，则会在 proxy 命令执行时，根据 istio 连接的服务注册中心（service registry）类型的不同，会采用不同的配置方式。agent 当前使用的服务注册中心类型保存在 pilot-agent 的 registry 变量里，在 init 函数中初始化为默认值 Kubernetes。当前只处理以下三种情况：
&lt;ol&gt;
&lt;li&gt;Kubernetes&lt;/li&gt;
&lt;li&gt;Consul&lt;/li&gt;
&lt;li&gt;Other&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;registry 值&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;role.IPAddress&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;rule.ID&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;role.Domain&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Kubernetes&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;环境变量 INSTANCE_IP&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;环境变量 POD_NAME.环境变量 POD_NAMESPACE&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;环境变量 POD_NAMESPACE.svc.cluster.local&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Consul&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;private IP，默认 127.0.0.1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;IPAddress.service.consul&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;service.consul&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Other&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;private IP，默认 127.0.0.1&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;IPAddress&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;“”&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中的 private ip 通过&lt;code&gt;WaitForPrivateNetwork&lt;/code&gt;函数获得。&lt;/p&gt;
&lt;p&gt;Istio 需要从服务注册中心（service registry）获取微服务注册的情况。当前版本中 istio 可以对接的服务注册中心类型包括：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mock&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MockRegistry is a service registry that contains 2 hard-coded test services&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Config&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ConfigRegistry is a service registry that listens for service entries in a backing ConfigStore&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;KubernetesRegistry is a service registry backed by k8s API server&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Consul&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ConsulRegistry is a service registry backed by Consul&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Eureka&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;EurekaRegistry is a service registry backed by Eureka&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CloudFoundry&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CloudFoundryRegistry is a service registry backed by Cloud Foundry.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://istio.io/zh/docs/concepts/what-is-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;说当前支持 Kubernetes、Nomad with Consul，未来准备支持 Cloud Foundry、Apache Mesos。另外根据&lt;a href=&#34;https://istio.io/zh/about/feature-stages/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方的 feature 成熟度文档&lt;/a&gt;，当前只有 Kubernetes 的集成达到 stable 程度，Consul、Eureka 和 Cloud Foundry 都还是 alpha 水平。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;envoy-配置文件及命令行参数&#34;&gt;envoy 配置文件及命令行参数&lt;/h3&gt;
&lt;p&gt;agent.waitForExit 会调用 envoy.Run 方法启动 envoy 进程，为此需要获取 envoy 二进制所在文件系统路径和 flag 两部分信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;envoy 二进制所在文件系统路径：evony.Run 通过 proxy.config.BinaryPath 变量得知 envoy 二进制所在的文件系统位置，proxy 就是 envoy 对象，config 就是 pilot-agent 的 main 方法在一开始初始化的 proxyConfig 对象。里面的 BinaryPath 在 pilot-agent 的 init 方法中被初始化，初始值来自&lt;code&gt;pilot/pkg/model/context.go&lt;/code&gt;的&lt;code&gt;DefaultProxyConfig&lt;/code&gt;函数，值是&lt;code&gt;/usr/local/bin/envoy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;envoy 的启动 flag 形式为下面的 startupArgs，包含一个&lt;code&gt;-c&lt;/code&gt;指定的配置文件，还有一些 flag。除了下面代码片段中展示的这些 flag，还可以根据启动 agent 时的 flag，再加上&lt;code&gt;--concurrency&lt;/code&gt;, &lt;code&gt;--service-zone&lt;/code&gt;等 flag。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;startupArgs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;-c&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;s&#34;&gt;&amp;#34;--restart-epoch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;epoch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;s&#34;&gt;&amp;#34;--drain-time-s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;convertDuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;DrainDuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;s&#34;&gt;&amp;#34;--parent-shutdown-time-s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;convertDuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ParentShutdownDuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;s&#34;&gt;&amp;#34;--service-cluster&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ServiceCluster&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;s&#34;&gt;&amp;#34;--service-node&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;s&#34;&gt;&amp;#34;--max-obj-name-len&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;MaxClusterNameLength&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关于以上启动 envoy 的 flag 及其值的解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;--restart-epoch&lt;/code&gt;：epoch 决定了 envoy hot restart 的顺序，在后面会有详细描述，第一个 envoy 进程对应的 epoch 为 0，后面新建的 envoy 进程对应 epoch 顺序递增 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--drain-time-s&lt;/code&gt;：在 pilot-agent init 函数中指定默认值为 2 秒，可通过 pilot-agent proxy 命令的 drainDuration flag 指定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--parent-shutdown-time-s&lt;/code&gt;：在 pilot-agent init 函数中指定默认值为 3 秒，可通过 pilot-agent proxy 命令的 parentShutdownDuration flag 指定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--service-cluster&lt;/code&gt;：在 pilot-agent init 函数中指定默认值为”istio-proxy&amp;quot;，可通过 pilot-agent proxy 命令的 serviceCluster flag 指定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--service-node&lt;/code&gt;：将 agent.role 的 Type,IPAddress,ID 和 Domain 用”~&amp;ldquo;连接起来&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而上面的&lt;code&gt;-c&lt;/code&gt;指定的 envoy 配置文件有几种生成的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;运行 pilot-agent 时，用户不指定 customConfigFile 参数（agent init 时默认为空），但是制定了 templateFile 参数（agent init 时默认为空），这时 agent 的 main 方法会根据 templateFile 帮用户生成一个 customConfigFile，后面就视作用户制定了 customConfigFile。这个流程在 agent 的 main 方法里&lt;/li&gt;
&lt;li&gt;如果用户制定了 customConfigFile，那么就用 customConfigFile&lt;/li&gt;
&lt;li&gt;如果用户 customConfigFile 和 templateFile 都没指定，则调用 pilot/pkg 包下的 bootstrap_config.go 中的 WriteBootstrap 自动生成一个配置文件，默认将生成的配置文件放在&lt;code&gt;/etc/istio/proxy/envoy-rev%d.json&lt;/code&gt;，这里的&lt;code&gt;%d&lt;/code&gt;会用 epoch 序列号代替。WriteBootstrap 在 envoy.Run 方法中被调用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;举个例子的话，根据参考文献中某人实验，第一个 envoy 进程启动参数为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-c /etc/istio/proxy/envoy-rev0.json --restart-epoch &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--drain-time-s &lt;span class=&#34;m&#34;&gt;45&lt;/span&gt; --parent-shutdown-time-s &lt;span class=&#34;m&#34;&gt;60&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--service-cluster sleep 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--service-node sidecar~172.00.00.000~sleep-55b5877479-rwcct.default~default.svc.cluster.local 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;--max-obj-name-len &lt;span class=&#34;m&#34;&gt;189&lt;/span&gt; -l info --v2-config-only
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果使用第三种方式自动生成默认的 envoy 配置文件，如上面例子中的 envoy-rev0.json，那么 pilot-agent 的 proxy 命令处理流程中前半部分整理的大量 envoy 参数中的一部分会被写入这个配置文件中，比如&lt;code&gt;DiscoveryAddress&lt;/code&gt;，&lt;code&gt;DiscoveryRefreshDelay&lt;/code&gt;，&lt;code&gt;ZipkinAddress&lt;/code&gt;，&lt;code&gt;StatsdUdpAddress&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;证书文件&#34;&gt;证书文件&lt;/h3&gt;
&lt;p&gt;agent 会监控 chainfile，keyfile 和 rootcert 三个证书文件的变化，如果是 Ingress 工作模式，则还会加入 ingresscert、ingress key 这两个证书文件。&lt;/p&gt;
&lt;h2 id=&#34;pilot-agent-主要功能分析之二envoy-监控与管理&#34;&gt;pilot-agent 主要功能分析之二：envoy 监控与管理&lt;/h2&gt;
&lt;p&gt;为 envoy 生成好配置文件之后，pilot-agent 还要负责 envoy 进程的监控与管理工作，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建 envoy 对象，结构体包含 proxyConfig（前面步骤中为 envoy 生成的配置信息），role.serviceNode(似乎是 agent 唯一标识符），loglevel 和 pilotsan（service account name）&lt;/li&gt;
&lt;li&gt;创建 agent 对象，包含前面创建的 envoy 结构体，一个 epochs 的 map，3 个 channel：configCh, statusCh 和 abortCh&lt;/li&gt;
&lt;li&gt;创建 watcher 并启动协程执行 watcher.Run
watcher.Run 首先启动协程执行 agent.Run（&lt;strong&gt;agent 的主循环&lt;/strong&gt;），然后调用 watcher.Reload(kickstart the proxy with partial state (in case there are no notifications coming))，&lt;strong&gt;Reload 会调用 agent.ScheduleConfigUpdate，并最终导致第一个 envoy 进程启动，见后面分析&lt;/strong&gt;。然后监控各种证书，如果证书文件发生变化，则调用 ScheduleConfigUpdate 来 reload envoy，然后 watcher.retrieveAZ(TODO)&lt;/li&gt;
&lt;li&gt;创建 context，调用 cmd.WaitSignal 以等待进程接收到 SIGINT, SIGTERM 信号，接受到信号之后通过 context 通知 agent，agent 接到通知后调用 terminate 来 kill 所有 envoy 进程，并退出 agent 进程&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;上面的pilot/pkg/proxy包下的agent中采用Proxy接口管理pilot/pkg/proxy/envoy包下的envoy对象，从理论上来说也可以把envoy换成其他proxy实现管理。不过此事还牵扯discovery service 等其他组件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面第三步启动协程执行的 agent.Run 是 agent 的主循环，会一直通过监听以下几个 channel 来监控 envoy 进程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;agent 的 configCh:如果配置文件，主要是那些证书文件发生变化，则调用 agent.reconcile 来 reload envoy&lt;/li&gt;
&lt;li&gt;statusCh:这里的 status 其实就是 exitStatus，处理 envoy 进程退出状态，处理流程如下：
0. 把刚刚退出的 epoch 从 agent 维护的两个 map 里删了，后面会讲到这两个 map。把 agent.currentConfig 置为 agent.latestEpoch 对应的 config，因为 agent 在 reconcile 的过程中只有在 desired config 和 current config 不同的时候才会创建新的 epoch，所以这里把 currentConfig 设置为上一个 config 之后，必然会造成下一次 reconcile 的时候 current 与 desired 不等，从而创建新的 envoy
&lt;ol&gt;
&lt;li&gt;如果 exitStatus.err 是 errAbort，表示是 agent 让 envoy 退出的（这个 error 是调用 agent.abortAll 时发出的），这时只要 log 记录 epoch 序列号为 xxx 的 envoy 进程退出了&lt;/li&gt;
&lt;li&gt;如果 exitStatus.err 并非 errAbort，则 log 记录 epoch 异常退出，并给所有当前正在运行的其他 epoch 进程对应的 abortCh 发出 errAbort，所以后续其他 envoy 进程也都会被 kill 掉，并全都往 agent.statusCh 写入 exitStatus，当前的流程会全部再为每个 epoch 进程走一遍&lt;/li&gt;
&lt;li&gt;如果是其他 exitStatus（什么时候会进入这个否则情况？比如 exitStatus.err 是 wait epoch 进程得到的正常退出信息，即 nil），则 log 记录 envoy 正常退出&lt;/li&gt;
&lt;li&gt;调用 envoy.Cleanup，删除刚刚退出的 envoy 进程对应的配置文件，文件路径由 ConfigPath 和 epoch 序列号串起来得到&lt;/li&gt;
&lt;li&gt;如果 envoy 进程为非正常退出，也就是除了“否则”描述的 case 之外的 2 中情况，则试图恢复刚刚退出的 envoy 进程（可见前面向所有其他进程发出 errAbort 消息的意思，并非永远停止 envoy，pilot-agent 接下来马上就会重启被 abort 的 envoy）。恢复方式并不是当场启动新的 envoy，而是 schedule 一次 reconcile。如果启动不成功，可以在得到 exitStatus 之后再次 schedule（每次间隔时间为 $2^n*200$ 毫秒），最多重试 10 次（budget），如果 10 次都失败，则退出整个 golang 的进程（os.Exit）,由容器环境决定如何恢复 pilot-agent。所谓的 schedule，就是往 agent.retry.restart 写入一个预定的未来的某个时刻，并扣掉一次 budget（budget 在每次 reconcile 之前都会被重置为 10），然后就结束当前循环。在下一个开始的时候，会检测 agent.retry.restart，如果非空，则计算距离 reconcile 的时间 delay&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;time.After（delay）:监听是否到时间执行 schedule 的 reconcile 了，到了则执行 agent.reconcile&lt;/li&gt;
&lt;li&gt;ctx.Done:执行 agent.terminate
terminate 方法比较简单，向所有的 envoy 进程的 abortCh 发出 errAbort 消息，造成他们全体被 kill（Cmd.Kill），然后 agent 自己 return，退出当前的循环，这样就不会有人再去重启 envoy&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;pilot-agent-主要功能分析之三envoy-启动流程&#34;&gt;pilot-agent 主要功能分析之三：envoy 启动流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;前面 pilot-agent proxy 命令处理流程中，watcher.Run 会调用 agent.ScheduleConfigUpdate，这个方法只是简单地往 configCh 里写一个新的配置，所谓的配置是所有 certificate 算出的 sha256 哈希值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;configCh 的这个事件会被 agent.Run 监控到，然后调用 agent.reconcile。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reconcile 方法会&lt;strong&gt;启动协程执行 agent.waitForExit 从而启动 envoy&lt;/strong&gt;
看 reconcile 方法名就知道是用来保证 desired config 和 current config 保持一致的。reconcile 首先会检查 desired config 和 current config 是否一致，如果是的话，就不用启动新的 envoy 进程。否则就启动新的 envoy。在启动过程中，agent 维护两个 map 来管理一堆 envoy 进程，在调用 waitForExit 之前会将 desiredConfig 赋值给 currentConfig，表示 reconcile 工作完成：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一个 map 是 agent.epochs，它将整数 epoch 序列号映射到 agent.desiredConfig。这个序列号从 0 开始计数，也就是第一个 envoy 进程对应 epoch 0，后面递增 1。但是如果有 envoy 进程异常退出，它对应的序列号并非是最大的情况下，这个空出来的序列号不会在计算下一个新的 epoch 序列号时（agent.latestEpoch 方法负责计算当前最大的 epoch 序列号）被优先使用。所以从理论上来说序列号是会被用光的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个 map 是 agent.abortCh，它将 epoch 序列号映射到与 envoy 进程一一对应的 abortCh。abortCh 使得 pilot-agent 可以在必要时通知对应的 envoy 进程推出。这个 channel 初始化 buffer 大小为常量 10，至于为什么需要 10 个 buffer，代码中的注释说 buffer aborts to prevent blocking on failing proxy，也就是万一想要 abort 某个 envoy 进程，但是 envoy 卡住了 abort 不了，有 buffer 的话，就不会使得管理进程也卡住。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;waitForExit 会调用 agent.proxy.Run，也就是&lt;strong&gt;envoy 的 Run 方法&lt;/strong&gt;，&lt;strong&gt;这里会启动 envoy&lt;/strong&gt;。envoy 的 Run 方法流程如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 exec.Cmd.Start 方法 (启动了一个新进程)，并将 envoy 的标准输出和标准错误置为 os.Stdout 和 Stderr。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;持续监听前面说到由 agent 创建并管理的，并与 envoy 进程一一对应的 abortCh，如果收到 abort 事件通知，则会调用 Cmd.Process.Kill 方法杀掉 envoy，如果杀进程的过程中发生错误，也会把错误信息 log 一下，然后把从 abortCh 读到的事件返回给 waitForExit。waitForExit 会把该错误再封装一下，加入 epoch 序列号，然后作为 envoy 的 exitStatus，并写入到 agent.statusCh 里&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动一个新的协程来 wait 刚刚启动的 envoy 进程，并把得到的结果写到 done channel 里，envoy 结构体的 Run 方法也会监听 done channel，并把得到的结果返回给 waitForExit&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我们总结启动 envoy 过程中的协程关系：agent 是全局唯一一个 agent 协程，它在启动每个 envoy 的时候，会再启动一个 waitForExit 协程，waitForExit 会调用 Command.Start 启动另外一个进程运行 envoy，然后 waitForExit 负责监听 abortCh 和 envoy 进程执行结果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cmd.Wait 只能用于等待由 Cmd.Start 启动的进程，如果进程结束并范围值为 0，则返回 nil，如果返回其他值则返回 ExitError，也可能在其他情况下返回 IO 错误等，Wait 会释放 Cmd 所占用的所有资源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每次配置发生变化，都会调用 agent.reconcile，也就会启动新的 envoy，这样 envoy 越来越多，老的 envoy 进程怎么办？agent 代码的注释里已经解释了这问题，原来 agent 不用关闭老的 envoy，同一台机器上的多个 envoy 进程会通过 unix domain socket 互相通讯，即使不同 envoy 进程运行在不同容器里，也一样能够通讯。而借助这种通讯机制，可以自动实现新 envoy 进程替换之前的老进程，也就是所谓的 envoy hot restart。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码注释原文：Hot restarts are performed by launching a new proxy process with a strictly incremented restart epoch. It is up to the proxy to ensure that older epochs gracefully shutdown and carry over all the necessary state to the latest epoch.  The agent does not terminate older epochs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而为了触发这种 hot restart 的机制，让新 envoy 进程替换之前所有的 envoy 进程，新启动的 envoy 进程的 epoch 序列号必须比之前所有 envoy 进程的最大 epoch 序列号大 1。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码注释原文：The restart protocol matches Envoy semantics for restart epochs: to successfully launch a new Envoy process that will replace the running Envoy processes, the restart epoch of the new process must be exactly 1 greater than the highest restart epoch of the currently running Envoy processes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5afad93ef265da0b7e0c6cfb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;下一代 Service Mesh &amp;ndash; istio 架构分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000015171622&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;istio 源码分析——pilot-agent 如何管理 envoy 生命周期&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;本文作者&#34;&gt;本文作者&lt;/h2&gt;
&lt;p&gt;丁轶群博士，谐云科技 CTO&lt;/p&gt;
&lt;p&gt;2004 年作为高级技术顾问加入美国道富银行 (浙江) 技术中心，负责分布式大型金融系统的设计与研发。2011 年开始领导浙江大学开源云计算平台的研发工作，是浙江大学 SEL 实验室负责人，2013 年获得浙江省第一批青年科学家称号，CNCF 会员，多次受邀在 Cloud Foundry, Docker 大会上发表演讲，《Docker：容器与容器云》主要作者之一。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
