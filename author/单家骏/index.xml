<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>单家骏 | 云原生社区</title>
    <link>https://cloudnative.to/author/%E5%8D%95%E5%AE%B6%E9%AA%8F/</link>
      <atom:link href="https://cloudnative.to/author/%E5%8D%95%E5%AE%B6%E9%AA%8F/index.xml" rel="self" type="application/rss+xml" />
    <description>单家骏</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Fri, 15 Feb 2019 10:35:59 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/author/%E5%8D%95%E5%AE%B6%E9%AA%8F/avatar_hue38add62c87b7486d80c9f3fda25dfc1_12220_270x270_fill_q75_lanczos_center.jpg</url>
      <title>单家骏</title>
      <link>https://cloudnative.to/author/%E5%8D%95%E5%AE%B6%E9%AA%8F/</link>
    </image>
    
    <item>
      <title>Kong mesh深度分析报告</title>
      <link>https://cloudnative.to/blog/kong-mesh-analyse-report/</link>
      <pubDate>Fri, 15 Feb 2019 10:35:59 +0800</pubDate>
      <guid>https://cloudnative.to/blog/kong-mesh-analyse-report/</guid>
      <description>&lt;p&gt;Kong是一个基于OpenResty (Nginx) 封装的微服务中间件产品，在微服务架构体系中，作为API网关以及API中间件（kubernetes ingress）提供服务。由于其天生具备Nginx的高性能、nginx-lua插件的可定制性，再加上完善的社区以及齐全的文档，在中小企业用户群非常受欢迎，拥有较好的群众基础。&lt;/p&gt;
&lt;p&gt;2018年8月，kong发布了1.0 GA版本，正式宣布其支持service mesh，并提供社区版以及企业版2个版本。下面我们从Demo、配置、功能这3方面，对kong mesh进行体验及分析。&lt;/p&gt;
&lt;h2 id=&#34;demo体验&#34;&gt;Demo体验&lt;/h2&gt;
&lt;p&gt;Kong社区提供了kong mesh的demo (&lt;a href=&#34;https://github.com/Kong/kong-mesh-dist-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/Kong/kong-mesh-dist-kubernetes&lt;/a&gt;），该demo是实现的是tcp四层透明代理转发业务。&lt;/p&gt;
&lt;p&gt;该demo主要做的事情是：提供两个服务servicea以及serviceb，serviceb作为服务端，通过ncat监听8080端口，接受外部的TCP消息；servicea作为client端，通过ncat将当前server的时间发往serviceb。Demo的运行效果如下：&lt;/p&gt;
&lt;p&gt;在客户端节点，每隔两秒会发送一次时间戳到服务端。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kong-mesh-analyse-report/006tNc79ly1g03s98m3duj30mw06r3ze_hu5ee7b2ef4a2cf720cbf322adadaf130b_33313_cef4875c59027c822bf1e0b491eef4c7.webp 400w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03s98m3duj30mw06r3ze_hu5ee7b2ef4a2cf720cbf322adadaf130b_33313_8c79b6178393c183cae6ba86ad449676.webp 760w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03s98m3duj30mw06r3ze_hu5ee7b2ef4a2cf720cbf322adadaf130b_33313_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kong-mesh-analyse-report/006tNc79ly1g03s98m3duj30mw06r3ze_hu5ee7b2ef4a2cf720cbf322adadaf130b_33313_cef4875c59027c822bf1e0b491eef4c7.webp&#34;
               width=&#34;760&#34;
               height=&#34;224&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;服务端节点，每隔两秒打印一次时间戳。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kong-mesh-analyse-report/006tNc79ly1g03s9ijom2j30b305baae_hub4743a454a527a32a08bd2a52719c25d_24606_bf993874612277e6e6894d9779ffd32f.webp 400w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03s9ijom2j30b305baae_hub4743a454a527a32a08bd2a52719c25d_24606_3f753b4ecabd26237e373922a8d2e03c.webp 760w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03s9ijom2j30b305baae_hub4743a454a527a32a08bd2a52719c25d_24606_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kong-mesh-analyse-report/006tNc79ly1g03s9ijom2j30b305baae_hub4743a454a527a32a08bd2a52719c25d_24606_bf993874612277e6e6894d9779ffd32f.webp&#34;
               width=&#34;399&#34;
               height=&#34;191&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来，我们详细了解一下该demo背后的技术原理。&lt;/p&gt;
&lt;p&gt;首先，我们来分析一下kong-mesh业务整体组网：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kong-mesh-analyse-report/006tNc79ly1g03s9r1zjnj30hv0fz756_hu47359b15608899be5ae22b7ce4f4df88_66733_733d6e0c6a8d16dd75ada69f9f31b002.webp 400w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03s9r1zjnj30hv0fz756_hu47359b15608899be5ae22b7ce4f4df88_66733_493d26c0c38ac65f7551d872f2177a8b.webp 760w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03s9r1zjnj30hv0fz756_hu47359b15608899be5ae22b7ce4f4df88_66733_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kong-mesh-analyse-report/006tNc79ly1g03s9r1zjnj30hv0fz756_hu47359b15608899be5ae22b7ce4f4df88_66733_733d6e0c6a8d16dd75ada69f9f31b002.webp&#34;
               width=&#34;643&#34;
               height=&#34;575&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

从组网中可以看出，kong mesh也分控制面与数据面。&lt;/p&gt;
&lt;p&gt;控制面为图中kong-admin的POD，3副本实例独立部署，对外提供Admin API供用户设置各种规则配置。&lt;/p&gt;
&lt;p&gt;数据面为图中servicea及serviceb的POD，每个POD中会启动一个kong容器作为sidecar，通过iptables规则将外发以及到达的流量劫持到kong容器中，然后kong会根据路由规则将流量转发到对应的实例。下面我们看看POD的部署配置：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kong-mesh-analyse-report/006tNc79ly1g03s9vlkd8j30nl0fiq3e_huac041c2a282093795bdcae89eff3d8e7_109771_cc846d8da50d3d0c0bceec8e9d476704.webp 400w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03s9vlkd8j30nl0fiq3e_huac041c2a282093795bdcae89eff3d8e7_109771_77ccd8646d0a7e3dd43662899525d242.webp 760w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03s9vlkd8j30nl0fiq3e_huac041c2a282093795bdcae89eff3d8e7_109771_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kong-mesh-analyse-report/006tNc79ly1g03s9vlkd8j30nl0fiq3e_huac041c2a282093795bdcae89eff3d8e7_109771_cc846d8da50d3d0c0bceec8e9d476704.webp&#34;
               width=&#34;760&#34;
               height=&#34;500&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;部署配置关键点在于流量接管的设置，POD在启动应用前，会使用istio/proxy_init镜像来初始化环境，图中的参数的含义是，使用TProxy（透明代理）的流量接管模式，将发往8080端口（业务serviceb监听端口）的流量通过7000端口（kong监听端口）来进行代理。&lt;/p&gt;
&lt;p&gt;了解清楚该部署配置后，我们就可以比较容易地使用kong来代理http服务了。主要改动点还是在于POD的部署配置的修改。如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kong-mesh-analyse-report/006tNc79ly1g03sa4pef2j30oc0g4jru_hu41702dc87dcbd9b3615a033004392c8f_113559_1c0df66181daa92ccedc94359f1270a1.webp 400w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03sa4pef2j30oc0g4jru_hu41702dc87dcbd9b3615a033004392c8f_113559_8bd94f260ef3149e3409b7fe431476c3.webp 760w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03sa4pef2j30oc0g4jru_hu41702dc87dcbd9b3615a033004392c8f_113559_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kong-mesh-analyse-report/006tNc79ly1g03sa4pef2j30oc0g4jru_hu41702dc87dcbd9b3615a033004392c8f_113559_1c0df66181daa92ccedc94359f1270a1.webp&#34;
               width=&#34;760&#34;
               height=&#34;503&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;值得注意的是，代理HTTP服务和代替TCP不一样，属于7层转发，不能使用上文的透明代理方式来进行接管。因此在setup_network的启动参数中，需要指定流量接管模式为REDIRECT，通过iptables显式将报文导入到kong，kong再根据报文内容进行匹配后，再路由到目标服务（大家如果需要http demo的代码，可以到&lt;a href=&#34;https://github.com/andrewshan/kong-mesh-http-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/andrewshan/kong-mesh-http-demo&lt;/a&gt;下载）。&lt;/p&gt;
&lt;p&gt;那么，kong又是根据什么规则去路由的呢？下面我们会继续体验kong mesh的配置规则。&lt;/p&gt;
&lt;h2 id=&#34;配置分析&#34;&gt;配置分析&lt;/h2&gt;
&lt;p&gt;kong mesh的配置集中存储在DB中，当前仅支持Postgre以及cassandra。控制面kong-admin会把配置规则写入到DB中，数据面的Kong会定期从数据库读取配置规则并更新缓存。&lt;/p&gt;
&lt;p&gt;在demo中，我们通过k8s Job向kong-admin写入了两条数据：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;http --ignore-stdin put kong-admin:8001/services/service-b &lt;span class=&#34;nv&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;serviceb &lt;span class=&#34;nv&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;tcp -f  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;http --ignore-stdin post kong-admin:8001/services/service-b/routes &lt;span class=&#34;nv&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;service-b sources&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;.ip&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0.0.0.0/0 &lt;span class=&#34;nv&#34;&gt;protocols&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;tcp -f 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一条语句是添加一个名字叫service-b的服务；&lt;/p&gt;
&lt;p&gt;第二条语句是为service-b的服务添加路由规则，允许源ip在0.0.0.0/0网段的tcp包可以转发到service-b。&lt;/p&gt;
&lt;p&gt;规则添加后，分别在services和routes表中可以查询到相关的记录：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kong-mesh-analyse-report/006tNc79ly1g03sal2gn3j319m057js4_hu841f4842e851084626f60ddd3ed9e61a_49637_c8b4350cb5ee97160db4e1980635ad29.webp 400w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03sal2gn3j319m057js4_hu841f4842e851084626f60ddd3ed9e61a_49637_6ba1c402edf41db8defb9db35485e27e.webp 760w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03sal2gn3j319m057js4_hu841f4842e851084626f60ddd3ed9e61a_49637_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kong-mesh-analyse-report/006tNc79ly1g03sal2gn3j319m057js4_hu841f4842e851084626f60ddd3ed9e61a_49637_c8b4350cb5ee97160db4e1980635ad29.webp&#34;
               width=&#34;760&#34;
               height=&#34;87&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;那么问题来了，kong的规则模型具体是什么含义？这些规则是怎么组合工作的呢？
首先，我们先看看kong的规则模型：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image&#34; srcset=&#34;
               /blog/kong-mesh-analyse-report/0060lm7Tly1g03qgd8vt3j30ih0e93z7_hu0b8dce62546374d589970e62609d5fea_50813_2247a49d8cfbb3b856b53ecae5af3bcb.webp 400w,
               /blog/kong-mesh-analyse-report/0060lm7Tly1g03qgd8vt3j30ih0e93z7_hu0b8dce62546374d589970e62609d5fea_50813_f78e653fec4e8a29efb5b788a8077931.webp 760w,
               /blog/kong-mesh-analyse-report/0060lm7Tly1g03qgd8vt3j30ih0e93z7_hu0b8dce62546374d589970e62609d5fea_50813_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kong-mesh-analyse-report/0060lm7Tly1g03qgd8vt3j30ih0e93z7_hu0b8dce62546374d589970e62609d5fea_50813_2247a49d8cfbb3b856b53ecae5af3bcb.webp&#34;
               width=&#34;665&#34;
               height=&#34;513&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从图上可见，Service是规则模型的核心，一个Service代表一个目标服务URL。&lt;/p&gt;
&lt;p&gt;Route代表的是Service的细粒度路由规则，定义了根据不同的客户端请求属性来选择目标端Service，一个Service可关联多个Route规则。可类比istio中的VirtualService。&lt;/p&gt;
&lt;p&gt;Upstream定义的是针对具体的目标Service，所采取的负载均衡策略，以及健康检查相关配置，一个Service可关联0-1个Upstream。可类比istio中的DestinationRule。&lt;/p&gt;
&lt;p&gt;Target定义的是具体的服务节点实例，可定义权重，一个target关联一个upstream。
具体的详细规则描述，可参考kong的官方文档：&lt;a href=&#34;https://docs.konghq.com/?_ga=2.44328420.1762329551.1548210642-1561229614.1544407768&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://docs.konghq.com/?_ga=2.44328420.1762329551.1548210642-1561229614.1544407768&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在k8s环境下部署，如果直接使用k8s平台所提供的kube-dns的域名解析能力以及ClusterIP/NodePort的负载均衡的话，那么原则上只需要配置Service以及Route规则就可以进行工作。Upstream和Target属于可选配置。&lt;/p&gt;
&lt;p&gt;我们继续看看，kong-mesh本身如何根据这些规则进行路由。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kong-mesh-analyse-report/006tNc79ly1g03sayaju0j30wz09dgm2_hu47bc1b402705cd5cc1a0f20ef0ac75c7_79369_97eaf290dfbe30e55a059fe43a35ab4f.webp 400w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03sayaju0j30wz09dgm2_hu47bc1b402705cd5cc1a0f20ef0ac75c7_79369_ea6cb2663b810eaed553382daf277396.webp 760w,
               /blog/kong-mesh-analyse-report/006tNc79ly1g03sayaju0j30wz09dgm2_hu47bc1b402705cd5cc1a0f20ef0ac75c7_79369_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kong-mesh-analyse-report/006tNc79ly1g03sayaju0j30wz09dgm2_hu47bc1b402705cd5cc1a0f20ef0ac75c7_79369_97eaf290dfbe30e55a059fe43a35ab4f.webp&#34;
               width=&#34;760&#34;
               height=&#34;216&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kong的路由及负载均衡能力是构建于openresty的access_by_lua以及balancer_by_lua这2个phase之上的。Servicea发送的请求通过iptables将流量导入到客户端侧（servicea-kong），kong收到后，根据请求消息进行route_match，找出匹配的目标service，然后再根据service的可用target进行负载均衡，找到目标serviceb节点实例进行发送。&lt;/p&gt;
&lt;p&gt;服务端serviceb-kong收到请求后，由于启动前通过环境变量配置好了本地路由规则:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;KONG_ORIGINS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;tcp://serviceb:8080=tcp://127.0.0.1:8080&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据该规则，kong直接把target为serviceb:8080的请求直接投递给serviceb。最终完成整个请求路由过程。&lt;/p&gt;
&lt;p&gt;接下来，我们再看看，kong基于上述的配置模型，可以提供什么样的功能，以及与其他mesh产品的差异点。&lt;/p&gt;
&lt;h2 id=&#34;功能对比&#34;&gt;功能对比&lt;/h2&gt;
&lt;p&gt;下表将kong mesh (community）与当下热门的istio+envoy组合进行功能比较，大家可以了解一下相关的差异（相关数据来源于kong官网）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能点&lt;/th&gt;
&lt;th&gt;kong-mesh (community)&lt;/th&gt;
&lt;th&gt;istio + envoy&lt;/th&gt;
&lt;th&gt;分析&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;服务发现&lt;/td&gt;
&lt;td&gt;通过admin api添加服务，并只能发现通过api添加的服务&lt;/td&gt;
&lt;td&gt;支持对接k8s, consul等注册中心进行服务发现&lt;/td&gt;
&lt;td&gt;从平台独立性来看，kong mesh占优; 从服务接管易用性来看，istio占优&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务协议&lt;/td&gt;
&lt;td&gt;支持http, http2, websocket, stream&lt;/td&gt;
&lt;td&gt;支持http, http2, grpc, websocket, stream&lt;/td&gt;
&lt;td&gt;istio+envoy占优&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务路由&lt;/td&gt;
&lt;td&gt;支持根据源、目标地址，method、host、path、protocol等细粒度的路由&lt;/td&gt;
&lt;td&gt;支持除左侧列举的所有能力外，还支持按header以及subset（标签）的路由&lt;/td&gt;
&lt;td&gt;istio+envoy占优&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;负载均衡&lt;/td&gt;
&lt;td&gt;支持轮询、权重、一致性hash的负载均衡模式&lt;/td&gt;
&lt;td&gt;支持除左侧列举的所有负载均衡模式外，还支持随机、最低负载等模式&lt;/td&gt;
&lt;td&gt;istio+envoy占优&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;健康检查&lt;/td&gt;
&lt;td&gt;支持主动健康检查以及被动健康检查（熔断）&lt;/td&gt;
&lt;td&gt;支持主动健康检查以及被动健康检查（熔断）&lt;/td&gt;
&lt;td&gt;基本对等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;安全&lt;/td&gt;
&lt;td&gt;支持Certificate证书管理，支持JWT+TLS加密传输&lt;/td&gt;
&lt;td&gt;支持证书下发及更新，JWT+mTLS加密传输&lt;/td&gt;
&lt;td&gt;基本对等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;多用户&lt;/td&gt;
&lt;td&gt;支持按consumer授权&lt;/td&gt;
&lt;td&gt;支持RBAC用户-角色授权&lt;/td&gt;
&lt;td&gt;istio+envoy占优&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;故障注入&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;istio+envoy占优&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;监控统计&lt;/td&gt;
&lt;td&gt;继承nginx的统计能力，支持按请求、连接、健康状态等维度的统计&lt;/td&gt;
&lt;td&gt;支持更细粒度的比如按协议、Zone的统计&lt;/td&gt;
&lt;td&gt;istio+envoy占优&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可扩展性&lt;/td&gt;
&lt;td&gt;背靠openresty，提供强大的自定义插件能力，使用lua进行开发&lt;/td&gt;
&lt;td&gt;提供lua插件开发能力，但能力比较基础&lt;/td&gt;
&lt;td&gt;kong mesh占优&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;学习曲线&lt;/td&gt;
&lt;td&gt;kong自身提供控制面和数据面能力，组网简单，纯lua语言上手较轻松&lt;/td&gt;
&lt;td&gt;istio+envoy一起至少4个组件，跨两种语言，上手较难&lt;/td&gt;
&lt;td&gt;kong mesh占优&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;总体上来看，kong mesh相对istio+envy在功能满足度上略占劣势，不过胜在简单、可扩展性强，社区活跃度高（stars稍多于istio），未来结合社区将功能补齐也不是难事。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Kong作为一个从API网关演变而来的service mesh产品，背靠成熟的OpenResty，拥有不输istio+envoy的功能满足度、且社区活跃，版本更新较快（平均2周一个release），比较适合中小型团队以及以前kong的老用户试水service mesh。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
