<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>朵晓东 | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/author/%E6%9C%B5%E6%99%93%E4%B8%9C/</link>
      <atom:link href="https://cloudnativecn.com/author/%E6%9C%B5%E6%99%93%E4%B8%9C/index.xml" rel="self" type="application/rss+xml" />
    <description>朵晓东</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 04 Dec 2018 17:32:44 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/author/%E6%9C%B5%E6%99%93%E4%B8%9C/avatar_hu3801682002625739492.jpg</url>
      <title>朵晓东</title>
      <link>https://cloudnativecn.com/author/%E6%9C%B5%E6%99%93%E4%B8%9C/</link>
    </image>
    
    <item>
      <title>蚂蚁金服 Service Mesh 新型网络代理的思考与实践</title>
      <link>https://cloudnativecn.com/blog/microservice-with-service-mesh-at-ant-financial/</link>
      <pubDate>Tue, 04 Dec 2018 17:32:44 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/microservice-with-service-mesh-at-ant-financial/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(136, 136, 136)&#34;&gt;&lt;strong&gt;朵晓东&lt;/strong&gt;&lt;/span&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(62, 58, 57)&#34;&gt;，&lt;/span&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(62, 58, 57)&#34;&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(49, 70, 89)&#34;&gt;花名奕杉，蚂蚁金服高级技术专家。专注企业云计算技术及产品，蚂蚁金融云 PaaS 创始团队核心成员，Antstack 网络产品负责人。开源爱好者，Apache Kylin 创始团队核心成员；SOFAMesh 创始团队核心成员，SOFAMosn 项目负责人。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(62, 58, 57)&#34;&gt;本文根据晓东在 GIAC 上海站的&lt;/span&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(25, 31, 37)&#34;&gt;演讲内容整理&lt;/span&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(62, 58, 57)&#34;&gt;，完整的分享 PPT 获取方式见文章底部。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng--left--720x4811881188118812&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2018/png/156645/1543544928743-c397c665-a542-490e-9a13-9ccf4b468d5f.png&#34; alt=&#34;image.png | left | 720x481.1881188118812&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png | left | 720x481.1881188118812
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，我是蚂蚁金服系统部的高级技术专家奕杉，今天分享的内容是：《蚂蚁金服在 ServiceMesh 推进落地过程中对新型网络代理的思考和实践》&lt;/p&gt;
&lt;h2 id=&#34;内容结构&#34;&gt;内容结构：&lt;/h2&gt;
&lt;p&gt;主要的分享顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;背景概述&lt;/li&gt;
&lt;li&gt;架构设计及功能特性&lt;/li&gt;
&lt;li&gt;技术案例&lt;/li&gt;
&lt;li&gt;总结展望&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1背景概览&#34;&gt;1、背景、概览：&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218438360-fd1bb4df-7b7f-45b1-a84e-b124fad9eebd.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;ServiceMesh 作为云原生之上的服务网格技术在今年引起了业界的广泛关注，首先我们来看一下目前 ServiceMesh 数据平面的一些方案。&lt;/p&gt;
&lt;p&gt;最为大家熟知的是老牌七层代理 Nginx 和 ISTIO 原生的数据平面 Envoy。Nginx 早已在国内外广泛使用，近两年积极探索 K8S、ServiceMesh 微服务场景，并推出了与  ISTIO 集成的微服务解决方案，试图扩展其场景边界，拿下新的领域，从单纯的 7 层流量代理到云原生时代的智能数据平面转型。但目前看“NgMesh”研发不够活跃，已知的使用方也不多。Envoy 作为 Google 和 Lyft 联合开发的 ISTIO 原生数据平面产品，近两年借助 ServiceMesh 微服务场景快速打开了市场，并在一些互联网公司推广使用，同时引入了一批开发者进行 API 网关等功能网关的开发，发展势头非常好。&lt;/p&gt;
&lt;p&gt;其次 LINKERD 是基于 Rust 的一种高性能数据平面，但其发展空间受到了 Envoy 挤压，业界使用的公司也比较有限。&lt;/p&gt;
&lt;p&gt;蚂蚁金服基于自身诉求自研了基于 Golang 的数据平面 SOFAMosn（后简称 MOSN），并在蚂蚁、UC 等公司落地使用。&lt;/p&gt;
&lt;p&gt;同时对业界开源，提供了一种新的数据平面产品选择。&lt;/p&gt;
&lt;p&gt;此外国内的华为、新浪等公司都基于自身场景提出了数据平面方案并先后进行了开源，数据平面竞争已经从独霸业界的基于 Nginx 二开方案逐步转变为目前的多样化产品同场竞技的局面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218443233-7b74f903-c3e6-4bf4-b5c5-b56d427cc9f0.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么众多大厂纷纷投入研发数据平面呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我个人认为新生技术栈、云原生、微服务快速发展等契机对数据平面提出了场景多样化、功能服务化、云原生亲和等多重挑战。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以往从未像现在这样对数据平面提出过如此多的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据平面需要执行部署运维中的流量切换；&lt;/li&gt;
&lt;li&gt;需要提供云亲和的细粒度流量调度功能；&lt;/li&gt;
&lt;li&gt;需要提供微服务亲和的服务发现、路由组网特性；&lt;/li&gt;
&lt;li&gt;需要以云原生的方式感知资源；&lt;/li&gt;
&lt;li&gt;需要支撑服务粒度、高度自定义的压测、故障测试、线上灰度流量管理；&lt;/li&gt;
&lt;li&gt;需要提供链路级、服务级的安全隔离保护，需要支持多种语言、多种协议的转换分发能力；&lt;/li&gt;
&lt;li&gt;需要能享受系统层面、硬件层面的红利；&lt;/li&gt;
&lt;li&gt;需要为复杂的运维架构（如蚂蚁的 LDC 等）提供可扩展的流量调拨能力等等；&lt;/li&gt;
&lt;li&gt;当然根据每个公司的业务场景可能还有其他的因素。
最后，如何要将这些能力都汇聚在统一的数据平面产品上，弥合南北向、东西向数据平面由于技术栈、团队等差异带来的鸿沟，变成了另一个更为复杂的问题。这里所提到的问题中任何一点扩展开来都可以是一个丰富独立的 Topic，受限于篇幅本次分享只能介绍我们在解决这些问题中的一小部分思考和实践。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2sofamesh-架构--重点特性&#34;&gt;2、SOFAMesh 架构 &amp;amp; 重点特性&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218452941-9329810d-b6a7-484e-a493-a549c70a6181.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先，蚂蚁已经将基于 ISTIO 的 ServiceMesh 方案 &amp;ldquo;SOFAMesh&amp;rdquo; 开源，在控制面我们选择克隆 ISTIO 官方版本并研发符合蚂蚁需求的控制面，在数据面我们选择使用 Golang 研发数据平面 MOSN，目前已经支持了微服务场景所需的大量常用功能。&lt;/p&gt;
&lt;p&gt;这里我根据 ISTIO 的 Task 文档总结了目前 SOFAMesh 支持的一些能力，如：透明拦截适配，细粒度的流控，故障注入，双向链路加密等。对于一些暂时存疑的功能，如 Mixer Check 等，暂时没有支持。目前 SOFAMesh 已在 UC 生产环境落地使用，满足了 Sidecar、Ingress、Egress 多种场景的使用需求。在这里附上  SOFAMesh，SOFAMosn 的 Github 地址，也欢迎大家使用交流。
SOFAMesh：&lt;a href=&#34;https://github.com/alipay/sofa-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/alipay/sofa-mesh&lt;/a&gt;
SOFAMosn：&lt;a href=&#34;https://github.com/alipay/sofa-mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/alipay/sofa-mosn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218458578-9f7bd036-eb1d-489a-bbb8-5c40031def35.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;再来看看蚂蚁内部，由于目前蚂蚁生产环境尚未大量铺开 K8S，并且已经存在一套完善的管控技术体系，加上目前 ISTIO 的性能和稳定性还不满足大规模微服务场景等原因，我们暂时没有选择直接升级到 ISTIO，而是通过优先落地 Sidecar 的方式来赢得 ServiceMesh 解决方案带来的红利。在蚂蚁内部，MOSN 接管了 SOFABoot 应用，代理了服务发现、路由/负载均衡、通信等工作，构成了微服务网格，通过自有的中间件及管控平面进行微服务的管理、治理。同时，我们积极的推进 MOSN 与  SOFA 中间件，网络接入层，安全防护及监控体系的整合，以提供更统一更强大的数据平面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218465864-1a4c61d2-6b0e-45b8-8252-a49d0409bd6e.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来我将介绍 MOSN 支持多协议的方案。&lt;/p&gt;
&lt;p&gt;为了在内部快速落地试错，我们首先支持了内部使用最广泛的 SOFARPC 协议，并对其进行了深度优化。随后我们根据 UC Mesh 化推进遇到的普遍问题提出了 XProtocol 方案，以在不解包的场景下提供路由能力。最后我们深度改造了三方 HTTP/1.1 实现及官方 HTTP/2.0 实现。到目前为止，MOSN 已提供了多种协议的支持。同时 MOSN 提供了两种自定义协议的能力支持使用者通过扩展的方式自定义协议实现，满足需要解包、不需要解包的协议扩展需求。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218470502-0ddf8529-a953-4f5b-a19d-0c8e0940934d.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除协议之外，性能是大家比较关心的另一个问题。为了提供满足生产要求的 7 层转发性能，我们在 IO、协议、内存、协程、网络处理等方面进行了优化，从目前通过 SOFARPC 通信应用的上线情况来看可以满足生产使用要求，在案例分析中我将展示一些性能数据，后续我们也将继续推进性能优化，以达到更好的性能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218475631-74f2953b-9687-4269-bc2f-429f80247dbe.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在安全能力上，SOFAMesh 支持 mTLS，并在蚂蚁内部集成蚂蚁内部的 KMS 完成了 mTLS 落地，同时 RBAC 功能在研发中，此外 WAF、流量镜像能功能也在规划中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218480670-4d7ace4c-7eac-40a7-9a9d-6143c02ddb4e.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在蚂蚁内部基于 MOSN 的网关产品正在研发中，将会在稳定验证后开源。网关场景相对于 Sidecar 场景有一些特性需求，比如说一般会 Hold 住大量长链接，比如说会根据请求内容动态选择后端应用，由于网关可能代理了不同的后端应用，就会需要动态选择后端协议。此外还有一些网关类的通用能力需求，如签名，授权，限流等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218485802-9e65b38f-40fa-4feb-9563-ba068c8da594.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了能基于开源版建设蚂蚁内部的 Sidecar 及网关产品，我们充分考虑了开源版 MOSN 的扩展性，在路由、后端管理、TLS、网络、流处理等各方面提供了扩展性支持。对于其他使用 MOSN 的场景，也可以通过类似的方式来满足自身业务定制需求。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218492236-d4608e03-9513-4267-9067-46276b86c093.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218496748-cd4ed37c-c654-4f3d-ba1b-f0631c268588.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218501467-8d454bcd-9f6b-4803-8fed-fcfd0e692020.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218505963-16adc24e-25b9-4dfa-a481-a5916133664d.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218511973-3e79c724-03b8-43b8-8a01-b994f5a017b9.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了更清晰的展示 MOSN 功能特性，这里将 MOSN 0.4.0 的功能特性通过表格的方式展示出来。可以说 0.4.0 版本已经初步具备了生产所需的大部分功能点，支持云原生场景下的多协议、路由&amp;amp;LB、后端管理、TLS、遥感监测、XDS 对接等功能，并充分优化了性能，目前已经在蚂蚁、UC 生产环境进行了验证。同时在蚂蚁内部我们通过扩展的方式支持了&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(25, 31, 37)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;灰度路由、&lt;/span&gt;&lt;/span&gt; LDC 路由、弹性路由，支持了配置中心等定制需求。后续我们会继续完善功能点，如果有发现未支持的功能可以在 Github 给我们提 Issue，或者直接加入我们 commit code。由于 MOSN 在扩展性上提供了比较好的能力支持，在特定的场景都可以通过扩展的方式来满足需求。&lt;/p&gt;
&lt;h2 id=&#34;3技术案例解析&#34;&gt;3、技术案例解析&lt;/h2&gt;
&lt;p&gt;在介绍了架构、功能特性以后，我将介绍一些落地过程中的技术案例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218522468-7fa7d941-96ee-42e5-afcf-0b1f63ba0c51.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先我们来看在蚂蚁在非 K8S 场景下将 MOSN 作为 Sidecar 接入应用的姿势。
在我们推进落地初期，需要接入 MOSN 的 SOA 应用还没有通过原生 K8S 的方式运行起来，服务发现是基于典型的服务发现中间件来做，也没有直接使用 ISTIO 来落地。在这种情况下，我们通过扩展开源版 MOSN 支持服务发现，将 MOSN 作为服务代理，由其完成服务 Pub/Sub，并代理服务完成 RPC 通信。这里有几个要点，首先由于内核限制我们没有第一时间使用 Iptables 拦截请求，而是通过升级 SOFA 的方式来支持应用切换访问地址，这里需要应用方升级 SOFA 依赖，但不需要改业务代码。&lt;/p&gt;
&lt;p&gt;其次，我们通过扩展开源版服务发现实现的方式支持从蚂蚁配置中心获取后端服务列表。在路由生成上，MOSN 基于完善的服务间依赖关系生成服务路由，由于 SOFA 应用在编码阶段已明确定义了服务依赖并在服务启动时由 MOSN 代理完成 Pub/Sub，MOSN 感知所需的服务依赖关系，并动态生成了出向/入向路由。如果你的使用场景服务之间没有明确的依赖关系，则需要扩展路由机制支持基于完全请求内容的动态路由机制。其次，SOFA 服务寻址基于明确的 id:version 信息，所以这样的服务发现、路由方案同时也适用于类似的 SOA 服务，同时也可以支持标准微服务寻址。这样的扩展方式可以实现基于服务发现中间件的非 K8S 的 Sidecar 注入，来享受 Mesh 思路落地的便利。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218528415-f554183c-9756-43d5-94e6-88bda76fb9b5.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了通过以上方式支持 SOA 化服务外，__SOFAMesh 标准方案提供了一种基于 DNS 的寻址方案，__以在不修改应用的情况下支持标准微服务寻址。
首先通过 DNS 将服务名转化为 IP，同时在 MOSN 路由的 Virtual Host 中配置服务 IP，以及与后端的匹配关系。Client 请求被 Iptables 拦截并转发给 MOSN，MOSN 在处理请求时通过 Tcp Option 的 Original Destination 项拿到目标 IP，并作为 Host 与 Virtual Host 匹配寻址到 Cluster 并做后端 LB 及转发。这样在不进行微服务化改造的情况下就可以进行服务名完成寻址通信了。这里更多细节可以参考敖小剑老师写的 XProtocol 完整&lt;a href=&#34;https://yq.aliyun.com/articles/650936&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;方案&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218533752-5a8d4702-2360-4de0-b636-9d6647849c65.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来我们一起分析另一个在生产环境非常有用的特性，无损平滑升级。
大部分 7 层流量代理，包括 Nginx、Envoy 等，在升级过程中通常会让老进程静默等待一段时间后再退出、或等待时机由新进程控制退出，通过这种方式来保证老进程不再处理到请求。这种方式对于 HTTP/1.x 短链接是比较有用的，但对于 HTTP/1.1长链接、RPC 长链接最终不得不通过暴力断链的方式让 Client 重连、重试，对业务是有一定影响的。凡会造成业务抖动一般都会造成业务方紧张，这会导致新功能升级推动困难。针对这个问题，MOSN 提出了自己的解决方案，在升级过程中无损迁移存量链接，目前支持 HTTP/1.1、无状态 RPC、TLS，后续将基于 Goaway 帧支持 HTTP/2.0。下面我们来看看MOSN 是怎么实现这样能力的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218539299-6752b969-ff5e-4a05-b603-984def368d41.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里我把典型场景抽象成 Client 请求处理和 Server 回复处理两部分，我们先来看看 Client 请求处理。在升级阶段，同时存在新老两个 MOSN 进程，此时可能存在 Client 正在访问老进程的情况，此时老进程会通过 Domian Socket 将 &lt;span data-type=&#34;color&#34; style=&#34;color:rgb(38, 38, 38)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;TCP1 的 FD 及链接状态数据&lt;/span&gt;&lt;/span&gt;传递给新进程，由新进程&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(38, 38, 38)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;创建 TCP3 链接&lt;/span&gt;&lt;/span&gt;并将数据发送到后端 Server 并接收 Server 响应，新进程在收到响应后不再转发给老进程，直接转发给 Client 完成本次请求。此后老进程退出 &lt;span data-type=&#34;color&#34; style=&#34;color:rgb(38, 38, 38)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;Read 流程，不再接受该 TCP1 连接上的数据，同时新进程开始 Read 流程，接受该 TCP1 连接上的数据，完成 Reload 过程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218544265-94ef075e-e737-49c5-9f29-509ae5d57369.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;再来看看第二种情况，在第一步链接迁移完成后仍然可能出现 Server  通过 TCP2 将残留响应发送到老进程的情况，此时老进程会通过 Domian Socket 将请求数据传递给新进程，由新进程回复到 Client。这样就避免了两个 MOSN 进程同时写到 Client 造成乱序的问题。延伸一下，未来基于这样的思考可以与容器 fork 结合提供容器、Pod 层面的无损迁移方案。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218550949-a623f6d9-7082-4c57-a917-34dc4b4760d5.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在迁移过程中我们发现，对于无状态的 HTTP/1.1 长链接，RPC 长链接迁移较为简单，但对于有多回合握手的 TLS 迁移则比较麻烦，这里主要涉及到 TLS 的状态数据迁移，如&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(38, 38, 38)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;加密秘钥，Seq 序列，读缓存数据，Cipher 类型等状态数据都需要做特殊的处理以保证迁移过程不会破坏握手过程。此外，MOSN 还支持对请求链接做明、密文检测，来保证上游可以灰度的开启链路加密。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218555173-754e294d-96e7-4f98-b87a-be20d6e8625e.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我将介绍一下我们在性能优化方面的一些实践。数据来源于 2018 年 8 月份的 0.2.1 开源版。
先介绍一下在 Sidecar 模式下的性能数据，测试场景是一个典型的服务间通信场景，服务 A 通过 MOSN 访问服务 B。这里选用的机型是蚂蚁内部的测试机器。我们测试的场景包括了  SOFARPC、HTTP/1.1、HTTP/2.0 三种协议，测试的工具分别是蚂蚁内部的压测平台、ab、h2load，其中 HTTP/2.0 压测 5 条链接的场景，并且是 H2C，无 TLS 加密。数据场景是 1K 的请求、响应。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218559351-a0af582a-e7a9-4786-9bd5-6ff4bbc38d45.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们来看一下测试结果，可以看到 SOFARPC 性能远好于其他两个协议。需要说明的是，HTTP/1.1 在 0.2.1 版本中直接使用了开源的 FastHTTP，MOSN 没有接管 IO 处理，协议解析等工作，未做任何优化；HTTP/2.0 直接使用了官方实现，MOSN 没有接管 IO 处理，协议解析等工作，未做任何优化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218563811-b588d066-772e-4815-9c54-645552f18d09.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 SOFARPC 的优化上我们从 IO，协议到上层处理做了不少优化，这里简单介绍一些优化经验。首先分享一个踩过的坑，在基于 Golang Connection API 编写读数据代码时，一个常用的方式是通过 SetReadDeadline 来设置读超时，我们发现在读超时很短的情况下，在 2.6.2 内核会比 4.13.0 内核性能下降 30%，而通过绑核可以解决此问题。此外，有很多有用的手段可以用来优化性能，比如说读合并减少协议处理次数，writev 减少系统调用写的次数可以有效提升整体吞吐量。我们通过对比 Golang 和 OS 的 perf 数据发现 Golang 系统调用耗时比 OS 系统调用耗时要多（原因还需要进一步明确），减少 Golang 系统调度总是有效的优化手段。在内存优化方案，首先可以尽量减少内存入堆，对于 100K 以下的内存入栈比入堆更快，并且不会影响 GC，对于不得不入堆的内存，可以通过有效的内存回收复用减少内存创建，减少 GC 压力。其次，在可控的范围内池化协议可以减少 Golang runtime 调度，并减少为了 Golang 为了保证连续栈而调用 morestack 造成的开销。对于单核的场景，需要关注协程数量及协程使用率，避免协程饥饿的情况。对于 perf 发现的热点，需要有针对性的进行优化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218567975-bb82422c-f9b4-4e65-b8a1-f75aa9ea2299.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来看看网关的场景，Client 通过 MOSN 访问 Server，测试条件与单核类似，不过没有限制 MOSN 的 P，也没有绑核。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218573591-604a2ef8-6d26-4a70-b964-6602a0933b03.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从实验结果上看，SOFARPC，HTTP/1.1 的结果基本在预期内，但 HTTP/2.0 性能远低于预期。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218583099-2b7d3d27-4ce1-4fb2-9d60-4e91675ae25d.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们看到 Golang 官方的 HTTP/2.0 实现在多核场景下性能不佳，在 0.4.0 中对官方 HTTP/2.0 进行了性能优化，我们将在 0.4.0 正式发布后更新性能数据。在多核场景下我们仍然选择了单进程模型，根据连接数、负载等变化可以压到 4-8 核。我们也尝试了多进程绑核+reuse port 的方案，多核吞吐量高于单进程 15% 以上，但从容器的适配性，进程模型简单等角度考虑我们仍然选择了单进程模型。在多核场景下需要特别关注全局锁的性能和 IO 的优化，这也是官方 Golang HTTP/2.0 实现性能不佳的重要原因。此外，需要在压测时关注 G 是否频繁切换，P 是否有饥饿等问题，有针对性的进行多核性能优化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218587543-7fecc16f-8a8c-4495-9f8b-f2c9c64ce894.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们再来看看长链接的模式，在这种模式下会有大量链接，但不会出现同时有大量流量的情况。MOSN 针对这种场景提供了基于 NetPoll 的使用模式，我们重点压测了在 10K 链接场景下 SOFARPC 的性能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218592084-9d0ed763-f275-4cf5-a1a8-ed48a3c444ec.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从压测结果上可以看看到，基于 Raw Epoll 的 NetPoll 模式在资源消耗上明显少于原生 Golang IO 的模式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218598786-a27aa543-967c-49ec-b4f8-a0765b53e5bf.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从结果上看，原生  IO 模式还无法高性能的满足 C10K  场景的要求，针对高性能网关场景还是需要通过更有针对性的方案来支持。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218603100-d08d0a74-86a7-4d27-921d-dea4ee8f45c7.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我将介绍 TLS 性能数据，这里通过 Nginx+OpenSSL，Caddy，Caddy+BoringSSL 三种实现来测试 SSL 处理的性能数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218606522-539145be-913f-49c3-a3c4-8a94db917157.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从测试结果可以看到，对于 RSA 加密，使用了 Golang 原生支持的 Caddy 性能明显弱与 OpenSSL 及 Caddy+BoringSSL，但对于 ECDSA 来说 Caddy 弱于 OpenSSL，但明显略好于通过 cgo 调用 BoringSSL 的方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218610013-d5ceba6c-eb5b-455a-95e2-0b9d9e1f01a6.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过进一步分析发现，Golang 对 RSA 的实现是基于 Golang 的，但对 ECDSA 等现代加密算法有汇编优化，比如说对 p256 的一些重点实现方法是移植了 OpenSSL 实现。同时 Golang 对 AES-GCM，SHA，MD 等算法都有汇编优化。如果你需要使用的算法正好在 Golang 的优化范围内，那么完全可以直接使用 Golang 原生实现，可以省去对接 OpenSSL、BoringSSL 的麻烦。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218613994-4ba290e3-8237-4640-8360-71a08e0b23be.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最终总结一些性能优化的结果，到目前为止，在 SOFARPC 协议上对 0.1.0 版本 QPS 提升了 50%，内存使用减少了 40%；HTTP/2.0 经过一轮优化，QPS 提升了一倍，后续会继续推进优化；HTTP/1.1 也有 30%  以上的性能提升。&lt;/p&gt;
&lt;p&gt;此外，Golang 性能优化与 C/C++ 还是有比较大的区别，在 C/C++ 优化过程中，重点观察系统 perf 进行优化，但 Golang 的话需要既需要了解、观察 Golang runtime 的 perf、调度数据，也需要观察 OS 层面 的 perf 数据，并且需要进行结合分析。一些 C/C++ 常用的方式在 Golang 也无法直接使用，比如说在 C 中做无锁替换经常通过整块内存替换指针的方式来保证原子性，但在 Golang 里指针替换并不是原子的，如果分析汇编会发现实际上执行了多条汇编，在实现层面就需要一些特殊的处理。&lt;/p&gt;
&lt;p&gt;由于 Golang 从编译到运行时，从运行单元到系统调用都是一个非常独立并且自包含的体系，他并没有基于 C  的开发套件建立，可以说是非常自成一体了，所以在系统层面的集成上仍然有不少问题需要克服，比如说 cgo  性能，但是由于他的优点也是非常明显的，可以在更多系统软件场景去探索挖掘，完善实现，建立出基于 Golang 世界的系统软件体系。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218618062-dfebd151-3d05-4cb5-b61c-e3cceeef9b37.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，在解决具体问题的过程中我们积累了不少有值得分享的案例，比如说在大流量场景下动态更新存量链接的配置风险策略，Metrics 平滑迁移，支持多层路由判断的可扩展链式路由等，受限于篇幅无法一一展开，后续我们将通过 blog 或 meetup 的方式与大家分享。&lt;/p&gt;
&lt;h2 id=&#34;4总结--展望&#34;&gt;4、总结 &amp;amp; 展望&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218626784-cec880b1-1ccd-447f-8cc6-96302681fd23.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们再看看微服务场景下 SOFAMosn 落地的方案，首先 SOFAMosn 作为 Sidecar 与 SOFABoot APP 融合代理服务、通信、配置等功能，与蚂蚁的 Control Plane 通信完成服务配置更新。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218632502-24c5e08f-cee2-48ae-a27d-744388ef0c7a.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们再从整体视角看看 MOSN、MOSNG 在蚂蚁架构中的位置。MOSN 作为蚂蚁全新的数据平面，会贯穿网络接入、微服务、安全、Serverless 等场景的落地中。我们将推进东西向，南北向技术架构的融合，形成统一的负载网络。在安全方向上，我们将会在微服务级别的安全保障上做更细致的工作，从 2、3、4、7 层做更多的安全隔离工作，例如做到微服务粒度的流量拦截、牵引。在 Serverless 场景，MOSN 将作为 Serving 的前置提供服务。最后 MOSN 将积极地与用户态加速技术，7 层流量拦截服务等基础能力集成，更好的服务于统一负载网络。
从蚂蚁技术栈演进的视角看，在下一代微服务架构、下一代接入网络、零可信微隔离的技术发展的萌芽之下，MOSN 的出现是必然也是偶然，最终将成为新生技术体系落地过程的重点环节，我们将继续探索，逐步形成适合蚂蚁业务场景的数据平面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218637610-ec08e4e0-420c-4f1f-af82-264c87076597.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我今天要介绍的内容就是这些，欢迎大家关注“金融级分布式架构”，“ServiceMesher”公众号，我们将会有更多技术干货发布在公众号中。同时这里有 SOFAMesh、SOFAMosn 的 Github 地址，欢迎大家 star，或试用，更欢迎大家为我们提出宝贵意见。谢谢大家。
地址：
SOFAMesh: &lt;a href=&#34;https://github.com/alipay/sofa-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/alipay/sofa-mesh&lt;/a&gt;
SOFAMosn: &lt;a href=&#34;https://github.com/alipay/sofa-mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/alipay/sofa-mosn&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ppt-下载&#34;&gt;PPT 下载&lt;/h2&gt;
&lt;p&gt;地址：
&lt;a href=&#34;http://www.sofastack.tech/posts/2018-12-04-01&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.sofastack.tech/posts/2018-12-04-01&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng--left--720x4811881188118812&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2018/png/156645/1543544969503-0a284b24-0a6f-4ff2-9706-093c0cc5cf6b.png&#34; alt=&#34;image.png | left | 720x481.1881188118812&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png | left | 720x481.1881188118812
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh 数据平面 SOFAMosn 深层揭秘</title>
      <link>https://cloudnativecn.com/blog/sofa-mosn-deep-dive/</link>
      <pubDate>Thu, 02 Aug 2018 14:31:43 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/sofa-mosn-deep-dive/</guid>
      <description>&lt;p&gt;MOSN GitHub 地址：https://github.com/sofastack/mosn&lt;/p&gt;
&lt;p&gt;本文作者：朵晓东，花名奕杉，蚂蚁金服高级技术专家，专注云计算技术及产品。Apache Kylin 创始团队核心成员，蚂蚁金融云 PaaS 创始团队核心成员，Antstack 网络产品负责人，SOFAMesh 创始团队核心成员。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-朵晓东-service-mesh-meetup&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;朵晓东 service mesh meetup&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvf883plij30sg0j0n1e_hu6242168963494692018.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvf883plij30sg0j0n1e_hu8009748751443730616.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvf883plij30sg0j0n1e_hu922402134037771932.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvf883plij30sg0j0n1e_hu6242168963494692018.webp&#34;
               width=&#34;760&#34;
               height=&#34;508&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      朵晓东 service mesh meetup
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本文是基于作者在第二届 Service Mesh Meetup 的主题分享《蚂蚁金服 Service Mesh 数据平面 SOFAMosn 深层解密》部分内容所整理，以下是具体内容。关于本次 meetup 的情况请访问&lt;a href=&#34;https://cloudnativecn.com/blog/beijing-meetup-20180729/&#34;&gt;第二届 Service Mesh Meetup 北京站回顾&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;今天给大家带来的分享内容是蚂蚁金服 Service Mesh 数据平面 SOFAMosn 深层揭秘。&lt;/p&gt;
&lt;p&gt;承接小剑老师月初《大规模微服务架构下的 ServiceMesh 探索之路》对 SOFAMosn 的分享，本次聚焦在数据平面在蚂蚁落地的思考和探索。&lt;/p&gt;
&lt;h3 id=&#34;背景&#34;&gt;背景&lt;/h3&gt;
&lt;p&gt;上一次分享小剑老师已经介绍了 SOFAMesh 的技术选型，以及我们在开源和自研方面的一些权衡。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;呼应这个话题我们首先来看一下为什么蚂蚁会选择 Service Mesh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;重点归纳为-4-个方面&#34;&gt;重点归纳为 4 个方面：&lt;/h4&gt;
&lt;p&gt;蚂蚁正在全面拥抱微服务，云原生，不管是 SOFA5，还是兼容 K8S 的容器平台 Sigma 落地，Service Mesh 都是不可获取的重要组件。&lt;/p&gt;
&lt;p&gt;其次，蚂蚁的运维体系在服务层面基于流量调度工作，比如说 LDC 架构在逻辑 zone 间的调度流量，再比如弹性伸缩，本质上也是在异构机房间调度流量，此外还有像逻辑 zone 蓝绿发布，机房容灾等都需要在流量调度能力上更健壮，更灵活，更具扩展性。&lt;/p&gt;
&lt;p&gt;此外，由于蚂蚁的金融属性，我们在服务鉴权等方面有更严格的要求，比如说国密的落地，加密卡内的证书管理，加解密等方面，不止要求更高的安全级别，还要有承载大流量的能力。同时我们看到，zero trust 网络架构也在加速发展，这与我们的诉求不谋而合。&lt;/p&gt;
&lt;p&gt;最后，蚂蚁内部技术栈多样，但多种语言体系融合仍然成本很高。举个例子，非 SOFA 语言与 SOFA 互通要理解配置中心，SOFARPC 的序列化等逻辑，如果在生产环境部署还要理解 LDC 路由规则，而这些共性需求都可以通过下沉到 Mesh 体系来解决。&lt;/p&gt;
&lt;p&gt;了解 SOFAMesh 的同学应该知道，蚂蚁选择了使用 Golang 自研数据平面，做这个决定我们重点考虑了未来的技术选型，跨团队研发效率，蚂蚁现有技术体系，运维体系等因素；同时通过调研和验证，Golang 版本的性能也是我们可以接受的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接下来，我会向大家介绍由蚂蚁和 UC 联合研发的 Mesh 数据平面，我们为它取名 &lt;strong&gt;SOFAMosn&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;架构设计&#34;&gt;架构设计&lt;/h3&gt;
&lt;p&gt;首先我们由浅入深看一下 &lt;strong&gt;SOFAMosn&lt;/strong&gt; 的架构设计&lt;/p&gt;
&lt;h4 id=&#34;1-sofamesh-的整体架构&#34;&gt;1. SOFAMesh 的整体架构&lt;/h4&gt;
&lt;p&gt;大家看到的图示是基于 Istio 的架构，在数据平面我们使用 SOFAMosn 替代了 Envoy，同时加入了一些蚂蚁实践中摸索的改进，比如说 Mixer 的位置，我们考虑把 Mixer 下沉到 SOFAMosn，比如说对 SOFA，DUBBO 协议的支持等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcgxiw5cj31kw0zk45v_hu18098472500891371317.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcgxiw5cj31kw0zk45v_hu2583400818598488899.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcgxiw5cj31kw0zk45v_hu1894932208068549724.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcgxiw5cj31kw0zk45v_hu18098472500891371317.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;0.1.0 版本的 SOFAMosn 支持了 xDS V0.4 api 核心能力，重点支持了 SOFARPC 协议，并在蚂蚁内部在生产环境使用；同时支持了 HTTP/1.1，HTTP/2.0 的基本功能，但目前暂未在生产环境使用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchc91q9j31kw0zkgs2_hu9578178937322324276.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchc91q9j31kw0zkgs2_hu10394852240535598213.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchc91q9j31kw0zkgs2_hu18165818015230543494.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchc91q9j31kw0zkgs2_hu9578178937322324276.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;2-sofamosn-的核心设计思路&#34;&gt;2. SOFAMosn 的核心设计思路&lt;/h4&gt;
&lt;p&gt;首先，将 SOFAMosn 作为代理处理的数据流划分为 4 层，在入方向数据依次经过网络 IO 层，二进制协议处理层，协议流程处理层，转发路由处理层；出向与入向过程基本相反。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchpmtzoj31kw0zkq9h_hu10708909369678717538.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchpmtzoj31kw0zkq9h_hu4249286923747128654.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchpmtzoj31kw0zkq9h_hu13056512626564519203.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchpmtzoj31kw0zkq9h_hu10708909369678717538.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;了解了分层的基本思路，具体介绍一下各层的具体职能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IO 层&lt;/strong&gt;提供了 IO 读写的封装以及可扩展的 IO 事件订阅机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PROTOCOL 层&lt;/strong&gt;提供了根据不同协议对数据进行序列化/反序列化的处理能力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STREAMING 层&lt;/strong&gt;提供向上的协议一致性，负责 STREAM 生命周期，管理 Client / Server 模式的请求流行为，对 Client 端 stream 提供池化机制等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Proxy 层&lt;/strong&gt;提供路由选择，负载均衡等的能力，让前后端 stream 流转起来。大家可以从这张图清晰的看到单向请求流转的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcj3iaa9j31kw0zkn5w_hu16617897863525435079.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcj3iaa9j31kw0zkn5w_hu2451777179279780049.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcj3iaa9j31kw0zkn5w_hu17053003911829703678.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcj3iaa9j31kw0zkn5w_hu16617897863525435079.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;3-了解了分层设计及转发流程我们再看一下线程模型&#34;&gt;3. 了解了分层设计及转发流程，我们再看一下线程模型&lt;/h4&gt;
&lt;p&gt;我们先看看 0.1.0 版本的线程模型，可以看到每个链接的 IO 协程是成对出现的，读协程负责读取，事件机制及 Codec 逻辑，数据上升到 steam 层，具体的 stream 事件由独立的常驻 worker 协程池负责处理。在 0.2.0 版本中我们将会进行多核优化，读协程将不再负责 codec 逻辑，将转发由 codec worker pool 来进行。从发展方向上看，我们会借鉴 SEDA 的思路，将转发流程中每一阶段的处理抽象为一个 stage，通过 task queue，worker 协程池，controller 的机制来对每一个阶段进行处理。从技术实现上看，Golang 实现 SEDA 机制的组件也更简单。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjbqg8zj31kw0zkn5c_hu10350450550900637399.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjbqg8zj31kw0zkn5c_hu5801734796829727921.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjbqg8zj31kw0zkn5c_hu2357041168925447899.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjbqg8zj31kw0zkn5c_hu10350450550900637399.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjhuyiuj31kw0zkgu6_hu1657740405236911433.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjhuyiuj31kw0zkgu6_hu17566035800523799376.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjhuyiuj31kw0zkgu6_hu491309615219245674.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjhuyiuj31kw0zkgu6_hu1657740405236911433.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;4-sofamosn-的模块划分&#34;&gt;4. SOFAMosn 的模块划分&lt;/h4&gt;
&lt;p&gt;除了刚才介绍了 4 个核心模块，还有如路由模块负责请求的路由寻址，后端管理模块负责管理后端的生命周期，健康度等。其中蓝色的框是 SOFAMosn 0.1.0 会涉及到的功能模块，红色的虚线框是我们规划去实现，或实验的一些 topic。这方面也欢迎大家加入我们一起来建设。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjr017oj31kw0zkqju_hu6900901711139304089.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjr017oj31kw0zkqju_hu12220287180586625008.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjr017oj31kw0zkqju_hu5838007405200783066.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjr017oj31kw0zkqju_hu6900901711139304089.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后总结一下，模块化，分层解耦是 SOFAMosn 设计的初衷，此外可编程性，事件机制，扩展性，高吞吐量，都是设计中的重要考量因素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;sofamosn-核心能力&#34;&gt;SOFAMosn 核心能力&lt;/h3&gt;
&lt;p&gt;介绍完结构设计方面的一些思路，我们来看看 SOFAMosn 0.1.0 的核心能力。&lt;/p&gt;
&lt;p&gt;在网络核心能力方面，我们将 IO 处理相关能力封装抽象成可编程接口，这部分我们已经做过性能优化，可以单独使用；SOFAMosn 提供了内置的 TCP 代理功能，也做过性能优化，可单独使用；此外 SOFAMosn 支持 TLS 链路加密，目前复用了 Golang 的实现，后面的章节会介绍 Golang TLS 性能实验。SOFAMosn 可以配合 iptables 透明转发支持 TProxy 模式。同时，MOSN 支持平滑 reload，平滑升级。&lt;/p&gt;
&lt;p&gt;在多协议方面，0.1.0 版本中 SOFAMosn 重点支持 SOFARPC，并已运用在蚂蚁生产环境中。同时 SOFAMosn 支持HTTP/1.1，HTTP/2.0 的基本功能，实现方式是使用开源的 HTTP/1.1实现 FastHTTP 和 Golang 自带的 HTTP2 实现。由于 FastHTTP 和 HTTP2 都自带了 IO，链接池等功能，所以这两个协议的支持暂时是脱离 SOFAMosn 整体设计的，性能等方面也还没有做优化，我们会在后续版本迭代考虑将其纳入到 SOFAMosn 的框架体系，并进行性能优化。此外，我们正在研发 Dubbo，HSF 的支持，会在后续版本中推出。同时，目前已支持的 SOFARPC，HTTP/1.1，HTTP/2.0 都支持 Mes h 间的 TLS 链路加密。&lt;/p&gt;
&lt;p&gt;此处，在核心路由方面，0.1.0 版本 SOFAMosn 在核心功能上对齐 Envoy，支持 virtual host 匹配，支持 route match 匹配，支持 subset 路由匹配/负载均衡。&lt;/p&gt;
&lt;p&gt;在后端管理功能方面，支持基础负载均衡算法，支持主动健康检查等必须功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvck8jjfgj31kw0zkgu4_hu12066339168969462893.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvck8jjfgj31kw0zkgu4_hu5239803965960529371.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvck8jjfgj31kw0zkgu4_hu8809168948492953733.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvck8jjfgj31kw0zkgu4_hu12066339168969462893.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除核心功能外，SOFAMosn 根据我们落地的一些经验提供了一些亮点功能。&lt;/p&gt;
&lt;p&gt;首先，SOFAMosn 支持 X-PROTOCOL，一种更轻量级的方式支持自定义 RPC 协议，对于无需解包的相对简单的场景，将 RPC 数据作为 TCP 或者 HTTP/2.0 的 payload 进行转发，同时支持所有无需解包的路由负载策略。&lt;/p&gt;
&lt;p&gt;同时我们计划在 X-PROTOCOL 中加入编解码扩展点，支持需要解包的场景。在平滑升级的支持上，除了经典的传递 listener fd+ 协议层等待方式，SOFAMosn 支持对存量链接进行协议无关的迁移。同时为了部署升级，SOFAMosn 支持指定 / 更新前后端通信协议。&lt;/p&gt;
&lt;p&gt;在 Istio 集成方案上，SOFAMosn 0.1.0 支持 Istio 0.8 版本 Pilot V0.4API 全动态配置运行，支持 xDS on ADS 核心功能，后续版本会不断补齐功能。SOFAMosn 同时支持静态配置模型运行。&lt;/p&gt;
&lt;p&gt;除了能力支持，SOFAMosn 在网络层，协议处理层，基于 TCP 的私有协议层都提供了可扩展的能力，使得自定义业务可以优雅集成。在蚂蚁落地的过程中我们内部的 SOFAMosn 依赖于开源版本，通过可扩展的方式来实现蚂蚁内部的自有业务，在工程落地上提供了可行的方案。&lt;/p&gt;
&lt;h3 id=&#34;性能&#34;&gt;性能&lt;/h3&gt;
&lt;p&gt;在介绍了核心功能以后，我们再看另一个大家非常关注的问题，性能，这也是目前关注度较高的问题之一。&lt;/p&gt;
&lt;p&gt;在 SOFAMosn 0.1.0 版本，我们重点优化了基于 SOFAMosn 整体框架的协议在 Sidecar 模式下单核转发的性能，即 TCP，SOFARPC 的单核转发性能。&lt;/p&gt;
&lt;p&gt;首先我们分享一下我们在单核场景下优化的一些手段和经验。我们使用的方式主要是独占绑核，内存，IO，调度等方面进行优化。&lt;/p&gt;
&lt;p&gt;首先看绑核，在指定 P=1 的情况下，独占绑核不论在系统调用执行效率，cache locality affinity 两个方面都比更表现更好，整体吞吐量提升大约 30%。其次是内存优化，我们采样了 SLAB-style 的回收机制来提高复用，减少内存 copy；&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckkrfijj31kw0zkam1_hu7827382368799083324.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckkrfijj31kw0zkam1_hu12305420187729447814.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckkrfijj31kw0zkam1_hu2805476789601602024.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckkrfijj31kw0zkam1_hu7827382368799083324.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;同时在内存分配上需要考虑 Golang 内存模型的亲和性，尽量减少 arena 区内存申请；最后，大家都知道 Golang 的 GC 需要是你要去熟悉并适应他的，很多细节需要关注，尽量减少 GC scanobject 的压力。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckray2rj31kw0zk7ek_hu13166811526249963553.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckray2rj31kw0zk7ek_hu2668977473407394653.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckray2rj31kw0zk7ek_hu17981241682463726296.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckray2rj31kw0zk7ek_hu13166811526249963553.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 IO 方案，Golang 的 IO 模型是同步化的，在读方面既要尽可能多读，又要避免频繁调用 SetReadDeadline 造成的的影响，在我们压测下面频繁调用 SetReadDeadline 会对吞吐量有一定影响。在写方面需要适度 buffer，例如由多 worker 协程驱动造成某个 IO 协程频繁写系统 IO 也会造成吞吐量下降。另一个需要注意的方面是，在多协程场景下需要避免读写频率不均衡，这也是造成整体吞吐量下降的一个潜在原因。另外，如果读或写大量触发，会造成大量系统调用，这会引起 Golang runtime 调度成本升高。在 Golang runtime 调度方面，首先会触发协程调度造成时间消耗，同时 runtime 调度本身没有 OS 线程调度灵敏，也会有一定的时间损耗。同时 OS 系统调用本身也有会耗时，会造成性能下降。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里我分享一些我们在性能优化过程中遇到的真实的 case&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;除了 IO 方面的思考，还要关注一下调度均衡方面的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们利用协程池化来避免 runtime.morestack 的问题，其次在单核场景下需要重点关注 G 是否在饥饿状态，造成资源浪费。&lt;/p&gt;
&lt;p&gt;介绍完性能优化的一些过程，我们来看一下目前我们在性能优化上的一些结果，即单核 TCP 转发的性能，和单核 SOFARPC 转发的性能。可以看到，在单核 TCP 转发场景，SOFAMosn 0.1.0 版本和 Envoy 1.7 版本转发性能差距可控，后续版本我们会继续优化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcl25xaej31kw0zkdmu_hu18090935774821982131.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcl25xaej31kw0zkdmu_hu1292977998135530810.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcl25xaej31kw0zkdmu_hu1632212800982697429.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcl25xaej31kw0zkdmu_hu18090935774821982131.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclh0lu9j31kw0zktgn_hu13876980465614908623.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclh0lu9j31kw0zktgn_hu14558319777267219653.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclh0lu9j31kw0zktgn_hu16489833130773119366.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclh0lu9j31kw0zktgn_hu13876980465614908623.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，前面提到过 TLS 的实现，我们再来看一下性能方面的一些探索。首先介绍了一下测试的场景。在这个场景下，我们发现对于 ECDHE 算法，Golang 原生的实现性能虽然低于 Ningx（使用 OpenSSL），但是高于 Golang with boring SSL。通过对具体算法和协议的性能压测，代码调研我们得出如下结论。可以看出对于 ECDHE-P256 加密套件，Golang 原生实现的性能是很不错的，可以放心使用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclp075yj31kw0zkdm4_hu11168591108216843221.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclp075yj31kw0zkdm4_hu6777181870359558538.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclp075yj31kw0zkdm4_hu13308726128602543069.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclp075yj31kw0zkdm4_hu11168591108216843221.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了这些优化点以后，我们会在后续版本持续进行性能优化，多核优化，内存优化，同时利用用户态，内核态的加速技术来提升 SOFAMosn 的转发性能。在 TLS 加解密方面，我们将会尝试基于本地加速卡和 Keyless 架构的 Offload 加速，这也是我们在蚂蚁网络从中已经落地的一些技术手段。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclv2763j31kw0zkn4s_hu16457416032041821258.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclv2763j31kw0zkn4s_hu3872326076786011173.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclv2763j31kw0zkn4s_hu16335960443483736136.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclv2763j31kw0zkn4s_hu16457416032041821258.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;roadmap&#34;&gt;RoadMap&lt;/h3&gt;
&lt;p&gt;最后我介绍一下 SOFAMosn 的 RoadMap（时间为大体范围，具体发布请关注本公众号）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcm43sg5j31kw0sp1kx_hu17396866437187217410.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcm43sg5j31kw0sp1kx_hu16224828891650852280.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcm43sg5j31kw0sp1kx_hu16587062960677746521.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcm43sg5j31kw0sp1kx_hu17396866437187217410.webp&#34;
               width=&#34;760&#34;
               height=&#34;383&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;8 月第一周我们将发布 SOFAMesh 0.1.0 版本，这个版本重点支持 Proxy 核心能力，支持 xDS V0.4 API 核心功能，支持 SOFARPC 等通信协议。&lt;/p&gt;
&lt;p&gt;8 月底我们将发布 0.2.0 版本，在不断完善提升核心能力的基础上，我们会完善 X-Protocol 的功能和扩展性，以支持私有 RPC 协议扩展；同时我们将支持 Dubbo/HSF 通讯协议，并接入基于 ZK 的服务注册中心。同时我们将重点加强 HTTP/2.0 的功能，性能优化。我们还将支持 K8S operator，使得 SOFA Mesh 可以接入 K8S 资源。&lt;/p&gt;
&lt;p&gt;除功能性补强以外，我们会持续优进行性能优化，重点在多核性能，整体内存优化。此外，我们会持续推进代码优化，完善测试等基础性工作。&lt;/p&gt;
&lt;p&gt;9 月底我们将发布 0.3.0，重点提供 Mixer 集成，提供 precondition，quota，report 功能。同时在 9 月提供熔断和限流的能力。&lt;/p&gt;
&lt;p&gt;目前 SOFAMosn 仍然是一个初级版本，我们将持续投入补充，改进，优化，也欢迎开源社区感兴趣的朋友一起加入 SOFAMesh 开源版的建设。&lt;/p&gt;
&lt;h3 id=&#34;补充&#34;&gt;补充&lt;/h3&gt;
&lt;p&gt;本文基于作者在 Service Mesh Meetup #2 分享的部分内容所整理，现场分享的 PPT 以及视频，可以在 &lt;a href=&#34;https://www.itdks.com/eventlist/detail/2455&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IT 大咖说&lt;/a&gt;观看；&lt;/p&gt;
&lt;p&gt;PPT 下载地址：https://github.com/servicemesher/meetup-slides&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #2 北京站</title>
      <link>https://cloudnativecn.com/event/service-mesh-meetup-02/</link>
      <pubDate>Sun, 29 Jul 2018 13:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/event/service-mesh-meetup-02/</guid>
      <description>&lt;h2 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;张亮（京东金融数据研发负责人）：Service Mesh 的延伸 —— 论道 Database Mesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人简介：张亮，京东金融数据研发负责人。热爱开源，目前主导两个开源项目 Elastic-Job 和 Sharding-Sphere(Sharding-JDBC)。擅长以 java 为主分布式架构以及以 Kubernetes 和 Mesos 为主的云平台方向，推崇优雅代码，对如何写出具有展现力的代码有较多研究。2018 年初加入京东金融，现担任数据研发负责人。目前主要精力投入在将 Sharding-Sphere 打造为业界一流的金融级数据解决方案之上。&lt;/p&gt;
&lt;p&gt;随着 Service Mesh 概念的推广与普及，云原生、低接入成本以及分布式组件下移等理念，已逐渐被认可。在 Service Mesh 依旧处于高速迭代的发展期的同时，以它的理念为参考，其他的 Mesh 思想也在崭露萌芽。Database Mesh 即是 Service Mesh 的其中一种延伸，虽然理念与 Service Mesh 相近，但数据库与无状态的服务却有着巨大的差别。Database Mesh 与分布式数据库（如 NoSQL 和 NewSQL）的功能范畴并非重叠而是互补，它更加关注数据库之上的中间啮合层。本次将与您一起交流 Database Mesh 的一些思考，以及探讨如何与现有产品相结合，实现更加强大与优雅的云原生数据库解决方案。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;吴晟（Apache SkyWalking 创始人）：Observability on Service Mesh —— Apache SkyWalking 6.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人简介：Apache SkyWalking 创始人，PPMC 和 Committer，比特大陆资深技术专家，&lt;a href=&#34;http://tetrate.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate.io&lt;/a&gt; Founding Engineer，专注 APM 和自动化运维相关领域。Microsoft MVP。CNCF OpenTracing 标准化委员会成员。Sharding-Sphere PMC 成员。&lt;/p&gt;
&lt;p&gt;APM 在传统意义上，都是通过语言探针，对应用性能进行整体分析。但随着 Cloud Native, K8s 容器化之后，以 Istio 为代表的 Service Mesh 的出现，为可观测性和 APM 提供了一种新的选择。SkyWalking 作为传统上提供多语言自动探针的 Apache 开源项目，在 service mesh 的大背景下，也开始从新的角度提供可观测性支持。&lt;/p&gt;
&lt;p&gt;SkyWalking 和 Tetrate Inc. Istio 核心团队合作，从 Mixer 接口提取遥感数据，提供 SkyWalking 语言探针一样的功能，展现 service mesh 风格探针的强大力量。之后，也会和更多的 mesh 实现进行合作，深入在此领域的运用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;朵晓东（蚂蚁集团，高级技术专家）：蚂蚁集团开源的 Service Mesh 数据平面 SOFA MOSN 深层揭秘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人简介：蚂蚁集团高级技术专家，专注云计算技术及产品。Apache Kylin 创始团队核心成员；蚂蚁金融云 PaaS 创始团队核心成员，Antstack 网络产品负责人；SOFAMesh 创始团队核心成员。&lt;/p&gt;
&lt;p&gt;Service Mesh 技术体系在蚂蚁落地过程中，我们意识到 Mesh 结合云原生在多语言，流量调度等各方面的优势，同时面对蚂蚁内部语言体系与运维构架深度融合，7 层流量调度规则方式复杂多样，金融级安全要求等诸多特征带来的问题和挑战，最终选择结合蚂蚁自身情况自研 Golang 版本数据平面 MOSN，同时拥抱开源社区，支持作为 Envoy 替代方案与 Istio 集成工作。本次 session 将从功能、构架、跨语言、安全、性能、开源等多方面分享 Service Mesh 在蚂蚁落地过程中在数据平面的思考和阶段成果。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;丁振凯（新浪微博，微博搜索架构师）：微博 Service Mesh 实践 - WeiboMesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人简介：微博搜索架构师，主要负责搜索泛前端架构工作。主导搜索结果和热搜榜峰值应对及稳定性解决方案，以及微服务化方案落地。在 Web 系统架构方面拥有比较丰富的实践和积累。喜欢思考，深究技术本质。去年十一鹿晗关晓彤事件中一不小心成为网红工程师，并成功登上自家热搜榜。&lt;/p&gt;
&lt;p&gt;WeiboMesh 源自于微博内部对异构体系服务化的强烈需求以及对历史沉淀的取舍权衡，它没有把历史作为包袱，而是巧妙的结合自身实际情况完成了对 Service Mesh 规范的实现。目前 WeiboMesh 在公司内部已经大规模落地，并且已经开源，WeiboMesh 是非常接地气的 Service Mesh 实现。本次分享主要介绍微博在跨语言服务化面临的问题及 WeiboMesh 方案介绍，并结合业务实例分析 WeiboMesh 的独到之处。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
