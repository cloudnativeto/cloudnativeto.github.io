<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Holly Commins | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/author/holly-commins/</link>
      <atom:link href="https://cloudnativecn.com/author/holly-commins/index.xml" rel="self" type="application/rss+xml" />
    <description>Holly Commins</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://cloudnativecn.com/author/holly-commins/avatar_hu_76ac3954f0540338.jpg</url>
      <title>Holly Commins</title>
      <link>https://cloudnativecn.com/author/holly-commins/</link>
    </image>
    
    <item>
      <title>避免在微服务上失败的 7 个关注点</title>
      <link>https://cloudnativecn.com/blog/7-ways-to-fail-at-microservices/</link>
      <pubDate>Fri, 18 Feb 2022 16:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/7-ways-to-fail-at-microservices/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://www.infoq.com/articles/microservices-seven-fail/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;7 Ways to Fail at Microservices&lt;/a&gt;，作者总结了她见过的导致微服务落地失败的一些情况，并提出了 7 个重要的关注点以引导大家来尽量避免。译者是在工作闲暇时间完成的翻译，其中难免有不当之处，请读者指正。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文主要观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务是一种手段，而不是目标&lt;/li&gt;
&lt;li&gt;分布式并不能保证解耦性&lt;/li&gt;
&lt;li&gt;合约测试（Contract Testing）是任何微服务架构的重要组成部分&lt;/li&gt;
&lt;li&gt;分解（Decomposition）需要发生在前端、后端和集成层，以及业务逻辑中&lt;/li&gt;
&lt;li&gt;如果企业没有能力快速、独立地发布微服务，那么微服务的许多好处就会丧失&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我（Holly Cummins）是 IBM 的一名 &lt;a href=&#34;https://www.linkedin.com/in/holly-k-cummins&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;技术顾问&lt;/a&gt;，我的一部分工作是帮助企业实现云原生。在去年 11 月的 QCon Plus 上，我介绍了 &lt;a href=&#34;https://plus.qconferences.com/plus2021/presentation/7-ways-fail-microservices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一些不正确的微服务使用方式&lt;/a&gt;。这些问题是基于我的经验来整理的，它们是我在客户现场反复看到的一些问题。&lt;/p&gt;
&lt;p&gt;我看到的第一个问题是，我们有时甚至不知道问题出在哪里。人们觉得我们应该做 &lt;a href=&#34;https://microservices.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务&lt;/a&gt;，但我们并没有真正花足够的时间来定义我们为什么要做微服务。&lt;/p&gt;
&lt;p&gt;我们要解决的是什么问题？现在是什么问题在困扰我们？我们做了微服务之后，什么会更好？这是一个很自然的本能问题，尤其是对于我们这些技术人员来说。我们想直接开始用微服务去解决问题，同时想玩一些这样新的酷炫的技术。尽管这些也非常重要，但更应该清楚我们要通过微服务去解决什么问题。&lt;/p&gt;
&lt;p&gt;容器技术使这种“直接开始用微服务去解决问题”的情况变得更糟：因为容器是一种近乎神奇的技术，这使得它本身就是一个伟大的解决方案 —— 它是如此轻巧，它是如此的便携，它使许多事情变得更好。于是我们最终决定：“因为我已经有了这些容器，如果只在一个容器中运行我的应用程序，那将是对容器能力的严重浪费。我应该在尽可能多的容器中运行它！”不幸的是，“没有足够的容器（来发挥伟大的容器技术的能力）”并不是一个合理（分辨为什么我们需要微服务）的问题陈述。&lt;/p&gt;
&lt;h2 id=&#34;简历驱动的开发&#34;&gt;简历驱动的开发&lt;/h2&gt;
&lt;p&gt;我看到的另一个问题是 &lt;a href=&#34;http://radar.oreilly.com/2014/10/resume-driven-development.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;简历驱动的开发&lt;/a&gt;。我们在看自己的简历时，有时会觉得在应该在“微服务”这部分写点什么。既然什么都不写肯定是不好的，所以我们会想：“我可以通过重新架构我公司的技术架构来让我的个人简历变得更漂亮啊”。读到这里时你可能在想，“不会吧，这也太功利了吧。应该没有人真的会为了完善他们的个人简历来做公司的架构决策吧？”然而事实证明 &amp;hellip;&amp;hellip; 确实是有人会这么做的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/cv-driven-development_hu_b8603d3dab858e86.webp 400w,
               /blog/7-ways-to-fail-at-microservices/cv-driven-development_hu_5d8b52427ee962f2.webp 760w,
               /blog/7-ways-to-fail-at-microservices/cv-driven-development_hu_d7fb767c049462fb.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/7-ways-to-fail-at-microservices/cv-driven-development_hu_b8603d3dab858e86.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.redhat.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat&lt;/a&gt; 公司最近做了一项调查，调查了 &lt;a href=&#34;https://www.redhat.com/en/blog/red-hat-survey-reveals-career-progression-driving-developer-hunger-containers-and-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于容器的开发的主要驱动因素&lt;/a&gt;。职业发展是头号驱动力。职业发展是简历驱动发展的一种更好的说法。&lt;/p&gt;
&lt;p&gt;避免在简历上出现微服务部分的缺口是一件重要的事，因为目前微服务几乎是一种新的主流技术理念。即使我们此刻没有寻找新的工作，我们也不希望成为异类 —— 当我们环顾四周，似乎其 TA 人都在做微服务。于是一种很自然的想法是，如果 TA 们都在做微服务，那我为什么不去做做微服务呢？我把这称为“微服务嫉妒”（Microservice Envy）。&lt;/p&gt;
&lt;h2 id=&#34;微服务不是目标&#34;&gt;微服务不是目标&lt;/h2&gt;
&lt;p&gt;“微服务嫉妒”是一个问题，因为微服务并不是我们应该羡慕的那种东西。我们的一位技术顾问同事有一个讲法，如果一个客户一直在谈论 Netflix 的技术并要求使用微服务，他就知道这个合作可能有问题了。几乎可以肯定的是，他们转向微服务的原因并不正确。如果对话更深入一些，涵盖了耦合和聚合等内容，那么他就知道客户他们转向微服务的原因确实存在问题。&lt;/p&gt;
&lt;p&gt;微服务转型的出发点不应该是微服务本身。微服务是实现业务敏捷性或弹性或同等的更高层次目标的手段。实际上，微服务甚至不是唯一的手段；它只是一种手段而已。&lt;/p&gt;
&lt;h3 id=&#34;分布式单体&#34;&gt;分布式单体&lt;/h3&gt;
&lt;p&gt;重要的是要问：“你是有微服务，还是有一个分布在数百个 Git 仓库的单体？”不幸的是，这就是我们经常看到的情况。一个分布式的单体是一个可怕的东西 —— 很难说它到底怎样，它比纯粹单体更容易出错。在传统的单体中，所有的东西都包含在一个单一的开发环境中，你可以得到一些好处，如编译时检查和 IDE 重构支持。因为你总是在一个进程中执行，你可以得到有保障的函数执行。你不必担心记住分布式计算的谬误和服务发现，以及处理你试图调用的东西已经停止存在的情况，事情是比较安全的。另一方面，如果我们去掉了单体的安全性，但保留了耦合性，我们最终会得到“云原生意大利面条”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;术语“意大利面条架构”（Spaghetti Architecture）可以被定义为一个信息技术问题，它阻碍了企业快速解码和转换其应用程序和数据以满足不断变化的需求的能力。“意大利面条架构”是一个源自一盘意大利面条外观的比喻。每根意大利面条代表每个业务工具，它们被纠结成无限的复杂线。—— 摘自《 &lt;a href=&#34;https://data-sleek.com/what-is-spaghetti-architecture-and-how-to-avoid-it/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;什么是“意大利面架构”和如何避免它&lt;/a&gt; 》。&lt;/p&gt;
&lt;p&gt;【编者按】“意大利面条”这个比喻似乎可以理解为：各个服务虽然看似分离了，但却各种层面上耦合、混合在一起，同时还容易断裂、崩坏。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;分布式不等同于解耦&#34;&gt;分布式不等同于解耦&lt;/h2&gt;
&lt;p&gt;几年前，我被邀请到一个陷入困境的项目中去提供援助。当我进入项目时，团队对我说的第一件事就是“每当我们改变一个微服务时，另一个服务就会出现故障”。如果你一直在关注微服务的优势，你就会知道，这与应该发生的事情完全相反。微服务应该是相互独立的，解耦的。然而，如果你把你的系统做成分布式，&lt;a href=&#34;https://en.wikipedia.org/wiki/Decoupling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;解耦&lt;/a&gt; 就变得不那么容易了（它是有代价的）。虽然“分布式”（Distributed）和“解耦”（Decoupled）都以 D 开头，但它们本身不是一回事。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu_92f5b383da988e98.webp 400w,
               /blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu_c6ad3d96da0cb630.webp 760w,
               /blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu_e8c81256848179e4.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu_92f5b383da988e98.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;拥有一个高度分布式的系统是很有可能既具有分布式所带来的所有痛苦，同时又仍然是完全纠缠和耦合的。上面提到的困境就是在这种情况下发生的事情。当我开始探索代码库的时候，我不断地在每个代码仓库中看到相同的代码。这个应用程序的对象模型是相当复杂的，有大约 20 个类，其中一些类有 70 个字段。这是一个非常复杂的结构体。&lt;/p&gt;
&lt;p&gt;微服务开发的原则之一是充分的 DRY（Don&amp;rsquo;t Repeat Yourself），避开公共库，因为它们是耦合的来源。在这种情况下，为了避免中央对象库的耦合，每个微服务在其代码中都有一个剪切和粘贴的对象模型副本。但如果领域结构体（Domain Schema）仍然是共享的，就仍然存在耦合。复制对象代码并不能消除耦合，它只是消除了编译时检查的可能性。如果一个字段名改变了，它仍然会破坏所有人，但这种破坏直到运行时才会发生。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hu_8a2ca6b9ccd47a6a.webp 400w,
               /blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hu_e124ac72e68ed678.webp 760w,
               /blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hu_bae7a123fd1815f2.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hu_8a2ca6b9ccd47a6a.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个悲伤的故事表明了领域驱动设计（Domain-Driven Design）原则在微服务中的重要性。我们要实现的理想情况是，每个微服务都能整齐地映射到一个领域。这样做的一个副作用，也是你做得对的一个标志，就是你的微服务的接口粒度很小。如果我们沿着技术边界而不是领域边界划分，我们最终会出现像我看到的情况；每个微服务都有一个巨大的、脆弱的接口。其结果是一个支离破碎的“意大利面条”式的混乱状态。&lt;/p&gt;
&lt;h3 id=&#34;火星气候轨道飞行器&#34;&gt;火星气候轨道飞行器&lt;/h3&gt;
&lt;p&gt;虽然从技术上讲它是一个航天器，而不是一个微服务平台，但 &lt;a href=&#34;https://en.wikipedia.org/wiki/Mars_Climate_Orbiter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;火星气候轨道器&lt;/a&gt; 很好地展示了分布式和解耦之间的区别。NASA 在 1998 年发射了火星气候轨道器，其任务是研究火星气候。遗憾的是，轨道器没有成功绕过火星；相反，探测器坠入火星。NASA 的事后调查发现，问题源于两个不同的控制系统之间的关系，这两个系统由不同的团队建造。大多数时候，转向是由探测器本身的一个系统完成的。每隔几天，当轨道飞行器进入地球的视野时，佛罗里达州的监督控制系统就会发出航线修正。这大约是一个系统可以做到的分布式；它的一部分在太空中。但这两个系统之间的领域实际上是相似的：都在处理发动机推力的计算。这两个团队在沟通中对界面的样子还不够清楚，所以他们最终使用了不同的单位。太空中的部分使用公制单位，地球上的部分使用英制单位，所以灾难发生了。我们可以肯定地说，在这种情况下，系统是非常分布式的，然而这种分布式并没有帮助。&lt;/p&gt;
&lt;h2 id=&#34;以消费者为导向的合约测试&#34;&gt;以消费者为导向的合约测试&lt;/h2&gt;
&lt;p&gt;这种微妙的沟通问题在有多个团队参与的时候经常发生。令人高兴的是，有一个很好的缓解措施：&lt;a href=&#34;https://pactflow.io/what-is-consumer-driven-contract-testing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;消费者驱动的合约测试&lt;/a&gt;。在 IDE 没有帮助我们进行类型检查的系统中，我们需要测试我们的集成，但我们希望尽量减少全面的集成测试。集成测试很重，运行成本很高，而且本身就是耦合的。如果我们已经投资开发了微服务，我们不想在测试时倒退并制造一个大的集成单体。那么，我们如何让自己得到信心，让我们确信我们正在建立一个真正有效的东西呢？&lt;/p&gt;
&lt;p&gt;数据模拟（Mock）是一种常见的解决方案，但数据模拟本身也有一个问题。为了建立数据模拟，生产团队和消费团队在开发之初就会就接口的情况进行对话。他们达成了一个协议，然后消费团队就去尝试写一个数据模拟，这个模拟看起来就像他们对生产团队所说的代码的理解。在理想的情况下，他们会做得很好。问题是，消费团队经常会把自己的假设也写进了模拟中，而他们也许不是知道其他代码是什么样子的，是否是合适这部分模拟的，毕竟不是消费团队编写的代码。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/problems-with-mocks_hu_7b99b938d7d7f601.webp 400w,
               /blog/7-ways-to-fail-at-microservices/problems-with-mocks_hu_3ca926f31ff30b75.webp 760w,
               /blog/7-ways-to-fail-at-microservices/problems-with-mocks_hu_1bb48f476c1d2ff0.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/7-ways-to-fail-at-microservices/problems-with-mocks_hu_7b99b938d7d7f601.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在顺利的情况下，他们得到了正确的结果。单元测试全部通过，而且在集成阶段也继续通过，一切都很好。不幸的是，这并不总是发生。有时，实际的实现与消费团队所理解的不同，要么是因为生产团队改变了他们的想法，要么是因为某个地方的人做了一个不正确的假设。在这种情况下，测试仍然会通过。然而，当我们真正整合真实的服务时，它就会失败。问题是，模拟的行为没有经过真实服务的验证。生产团队很可能甚至从未见过已经创建的模拟。&lt;/p&gt;
&lt;p&gt;一个更好的选择是有一个消费者驱动的合约测试。合约测试的美妙之处，以及为什么它与模拟不同，是双方都与合约测试互动。对于消费者来说，合约测试就像一个方便的模拟。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/contract-testing_hu_16262ffdacae75c2.webp 400w,
               /blog/7-ways-to-fail-at-microservices/contract-testing_hu_3c7e61e2acbab727.webp 760w,
               /blog/7-ways-to-fail-at-microservices/contract-testing_hu_888967e286a02e70.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/7-ways-to-fail-at-microservices/contract-testing_hu_16262ffdacae75c2.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在另一方面，合约测试对于生产团队也是一个方便的功能测试。它是一个更深刻的验证，而不仅仅是像 &lt;a href=&#34;https://swagger.io/specification/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenAPI&lt;/a&gt; 的语法检查。合约测试实际上也会检查语义和行为，这节省了生产团队编写功能测试的时间。&lt;/p&gt;
&lt;p&gt;如果所有的东西都是兼容的并且工作的，所有的合约测试都会通过。这是一个快速的信心提升，因为它们运行起来成本很低、也很轻便。如果生产团队破坏了什么，他们的测试将失败，并提供早期警报，在破坏性变化逃逸到集成环境之前。如果 API 发生变化，新版本的合约就会被双方（或连接的中间人）提出。&lt;/p&gt;
&lt;p&gt;现在有几个不同的合约测试系统。如果你在 Spring 的生态系统中，&lt;a href=&#34;https://spring.io/projects/spring-cloud-contract&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud Contract&lt;/a&gt; 工作得非常好。如果你是一个多面手，那么我非常喜欢 &lt;a href=&#34;https://pact.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pact&lt;/a&gt;。它有几乎所有你可能使用的语言的绑定。&lt;/p&gt;
&lt;h2 id=&#34;企业的毛球&#34;&gt;企业的毛球&lt;/h2&gt;
&lt;p&gt;当然，即使我们理清了所有的测试，即使我们在业务逻辑层有一套漂亮的解耦微服务，也不能保证成功。在我们的系统中还会有许多其他的元素，这些元素可能是我们在制定真正干净的微服务架构时没有考虑到的。我们对业务逻辑的开发非常投入，而忘记了前台和后台，以及所有的胶水层。在企业架构中，胶水层是非常可能存在的，而且是粘性的。我们的一位架构师把这称为“企业毛球”（Enterprise Hairball）。&lt;/p&gt;
&lt;p&gt;如果我们把所有的功能分解工作都集中在业务层，我们最终往往会得到一堆整齐的解耦的微服务，夹在一个单体的前端和一个单体的数据库层之间。在这些类型的系统中，变革将是一个挑战。然而，作为一个行业，我们正在更好地分解数据库，以便将其映射到各个微服务上，并且我们正在开发微前端。&lt;/p&gt;
&lt;p&gt;但我们还没有完成分解。如果系统不是很复杂，我们将有一个集成层。这可能是消息传递系统，也可能是一些其他的集成解决方案，将复杂的系统拉到一起。即使在架构的其他部分实现现代化架构之后，集成层往往仍然是单体的，不灵活的。团队本身可能处于重大的负荷之下 —— 正如我的同事所称呼的“恐慌的三明治”。因为集成层是单体的，他们必须小心翼翼地安排所有的变化，这就阻碍了其他所有人。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hu_ebde0badc35463aa.webp 400w,
               /blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hu_74465ce295828f76.webp 760w,
               /blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hu_15f9bf77213704cd.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hu_ebde0badc35463aa.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这可能会带来很多挫折感，特别是对集成团队来说。在外界看来，他们似乎反应迟钝，速度缓慢，尽管他们正在努力工作。为了理清这种耦合，我们需要采用模块化的集成模式。&lt;/p&gt;
&lt;p&gt;如果我们不把集成层、数据库和前端层分割开来，会发生什么？几乎可以肯定的是，我们的微服务不会达到我们想要的效果。“毛球”各部分之间的依赖关系将使任何部分都无法快速移动。业务层的微服务将不能独立部署，部署的速度将明显地不连续。&lt;/p&gt;
&lt;h3 id=&#34;阻碍发布的拖累&#34;&gt;阻碍发布的拖累&lt;/h3&gt;
&lt;p&gt;你们有多少人经历过这种情况？你非常努力地工作，你创造了一些惊人的东西；你知道用户会喜欢它，但它还没有到他们手中。价值被摆在台面上了，但你那令人惊奇的东西却不能被发布。即使你有一个微服务架构，你也会有一个发布看板。所有其它的微服务都需要同时发布，因为它们需要一起测试，这样做的成本太高，除非正好是大批量服务同时发布。即使填写发布清单也很昂贵。大家时常会害怕发布，因为可能在过去曾被低劣的发布所深深地伤害。发布检查表、发布委员会、单线程测试和其它发布方法都是为了减少那些已知的风险。因为整个组织的发布期限是共同的，所以我们最终不得不争分夺秒地在最后期限前把功能塞进去。当然，这也使得发布的风险更大。某个人正在跟踪一个电子表格，上面有所有微服务之间的依赖关系，这些微服务的耦合度比它们应该的要高。然而，发布还是得按期执行。当我们选择微服务时，这并不是我们所希望发生的！所有这些用心良苦设计的流程都成为了拖累，阻碍了价值到达用户手中，而且往往实际上又增加了风险。&lt;/p&gt;
&lt;h2 id=&#34;测试自动化&#34;&gt;测试自动化&lt;/h2&gt;
&lt;p&gt;通常情况下，我们如此害怕发布的原因是在发布中涉及到大量的手工工作。特别是，真正能给我们带来信心的测试并不是自动化的，所以我们需要做大量的工作来弄清楚我们的应用程序是否能工作。当我访问一个客户，听到“我们的测试没有自动化”时，我听到的是“我们不知道我们的代码目前是否工作，它可能工作。上次我们做人工 QA 的时候它是有效的；我们希望它仍然有效”。这是一个可悲的情况。&lt;/p&gt;
&lt;p&gt;如果你关心你们的测试，就把它自动化 —— 质量是你应该关心的东西。特别是如果架构已经偏向于“意大利面条”，并且耦合性已经悄然出现，那么就很可能出现断裂。去“意大利面条化”是很困难的，所以我们要在一个快速反馈的地方，尽可能早地发现断裂。如果你要成为“意大利面条”，至少要成为经过测试的“意大利面条”。&lt;/p&gt;
&lt;h2 id=&#34;发布周期&#34;&gt;发布周期&lt;/h2&gt;
&lt;p&gt;手动测试只是发布过程中涉及的手动流程的一部分。在受监管或以合规性为重点的行业，几乎总是有一堆人工合规性工作。合规性是我们非常关心的事情 —— 所以我们应该把它自动化。&lt;/p&gt;
&lt;p&gt;有了所有这些手工流程和所有这些造成减速的流程，这意味着即使我们正在上云，但我们没有实际得到上云的红利。我们在使用云，但它好像又不是云。讽刺的是，在云中，我们曾经做过的事情、曾经是一个好主意的东西、曾经让我们更安全的事情，实际上正在伤害我们。旧式的治理在云中是行不通的，它不能实现我们所希望的商业结果，而且它失去了很多上云应得的商业利益。&lt;/p&gt;
&lt;p&gt;通过观察发布周期，很容易发现一个企业是否实现了上云的目标。几年前，我的一位同事与一家大型的传统银行进行了一次销售会谈。他们的市场被金融科技公司和新兴的挑战者银行吃掉了，这个企业明白他们为什么会输 —— 他们无法快速地跟上。他们来找我们，解释说他们有大量的 COBOL 资产，而这正是拖累他们的原因（很可能确实如此）。然后他们补充说，他们显然需要摆脱所有的 COBOL 并转向微服务，因为其他人都在做微服务。然后他们又说，他们的发布委员会一年只开两次会。讲到这里的时候，我的同事感觉不妙。如果你的发布委员会每六个月才开一次会，你就知道你的发布节奏将是每六个月一次。你有多少个可独立部署的微服务并不重要，你不可能在这种情况下获得敏捷性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hu_dc927bafe7c3708f.webp 400w,
               /blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hu_38d64c3574a078f3.webp 760w,
               /blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hu_a2029247d7d250a7.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hu_dc927bafe7c3708f.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这家银行需要的帮助并不是真正的技术帮助；他们需要改变他们对风险的思考方式，以及他们的运营方式，他们的发布计划需要进行彻底的改革，他们需要一大堆的自动化。缺乏持续交付的纪律性是阻碍他们获取敏捷的原因，而不是 COBOL。&lt;/p&gt;
&lt;p&gt;“我想进行分解”是一个常见的客户要求，但分解有不止一个意思。当我们希望有一个分解的应用服务时，这并不能保证模块化 —— 有时它只是意味着乱七八糟的东西被分散得更广。如果有一些外部约束，比如发布看板和陈旧的工作流程，让我们总是被限制住，那在我们解决这些问题之前，我们如何分解都可能是徒劳无功的。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Holly Cummins&lt;/strong&gt; 是 IBM 企业战略部的创新领导者，并在 IBM Garage 担任顾问多年。作为 Garage 的一员，她为各行各业的客户提供技术驱动的创新，从银行业到餐饮业，从零售业到非政府组织。Holly 是 Oracle Java 冠军、IBM Q 大使和 JavaOne Rock Star。她与人合著了 Manning 的《Enterprise OSGi in Action》。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生关乎文化，而不是容器</title>
      <link>https://cloudnativecn.com/blog/cloud-native-culture-not-container/</link>
      <pubDate>Thu, 18 Mar 2021 11:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/cloud-native-culture-not-container/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://www.infoq.com/articles/cloud-native-culture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud-Native Is about Culture, Not Containers&lt;/a&gt;，文章洋洋洒洒上万字，作者总结了她见过的云原生失败的各种经验教训，还用生动的示例说明了什么不是云原生。译者是在周末闲暇时间仓促间翻译的，其中难免有不当之处，请读者指正。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文主要观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要一味的微服务，就可以做到非常的云原生。&lt;/li&gt;
&lt;li&gt;在开始云原生转型之前，必须明确云原生对你的团队意味着什么，以及要解决的真正问题是什么。&lt;/li&gt;
&lt;li&gt;如果发布涉及繁琐的仪式，不经常发布，而且所有的微服务都必须同时发布，那么微服务架构的好处将无法得到落实。&lt;/li&gt;
&lt;li&gt;持续集成和部署是你要做的事情，而不是你买的工具。&lt;/li&gt;
&lt;li&gt;过度的治理扼杀了云的效率，但如果你对消耗的东西不够重视，就会造成严重的浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在去年的伦敦 QCon 大会上，我提供了一个关于文化而非容器的云原生会议。让我开始思考文化在云原生中的作用的是 &lt;a href=&#34;https://www.infoq.com/articles/microservices-post-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bilgin Ibryam&lt;/a&gt; 一篇很棒的 &lt;a href=&#34;https://www.infoq.com/articles/microservices-post-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfoQ 文章&lt;/a&gt;。Bilgin 做的其中一件事是将云原生架构定义为很多微服务，通过智能管道连接。我看了之后，觉得它看起来完全不像我写的应用，尽管我认为我在写云原生应用。我是 IBM Garage 的一员，帮助客户实现云原生，然而我很少在我的应用中使用微服务。我创建的应用大多看起来和 Bilgin 的图完全不一样。这是否意味着我做错了，或者说云原生的定义可能有点复杂？&lt;/p&gt;
&lt;p&gt;我不想把 Bilgin 单列出来，因为 Bilgin 的文章叫《后 Kubernetes 时代的微服务》，所以如果他在那篇文章中不是经常说到微服务，那就有点可笑了。事实也是如此，几乎所有关于云原生的定义都把它等同于微服务。无论在哪里，我都不断看到这样的假设：微服务等于云原生，云原生等于微服务。就连云原生计算基金会（CNCF）也曾经把云原生定义为：都是微服务，都是容器，还有一点动态编排在里面。说云原生并不总是涉及微服务，这让我陷入了这个特殊的境地，因为我不仅说 Bilgin 错了，我还说云原生计算基金会错了 —— 他们对云原生了解过什么？我相信我知道的比他们多得多吧？&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_hu_a31302c2c7b47d90.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_hu_d989643cfd2f47b9.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_hu_229d46e1014edd14.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_hu_a31302c2c7b47d90.webp&#34;
               width=&#34;760&#34;
               height=&#34;510&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;显然我不知道在这个问题上，我站在了历史的错误一边。我承认这一点。虽然我站错了历史的一边，但我注意到 CNCF 已经更新了他们对云原生的定义，虽然微服务和容器仍然存在，但它们似乎不像以前那样必须，所以这一点历史可能在我这边！）。不管对不对，我还是要死在我的小山头上，那个 Cloud Native 是关于比微服务更大的东西。微服务是一种方式。它们不是唯一的方式。&lt;/p&gt;
&lt;p&gt;事实上，在我们的社区中，你确实看到了一系列的定义。如果你问一堆人 Cloud Native 是什么意思，有些人会说 &amp;ldquo;生长在云上&amp;rdquo;。这是非常原始的 Cloud Native 定义，早在微服务还没有出现的时候就已经有了。有人会说这是微服务。&lt;/p&gt;
&lt;p&gt;有人会说，&amp;ldquo;哦，不对，不只是微服务，是 Kubernetes 上的微服务，这样才有 Cloud Native&amp;rdquo;。这个我不喜欢，因为在我看来，Cloud Native 不应该是一个技术选择的问题。有时候我看到 Cloud Native 被当做 DevOps 的同义词，因为很多云原生的原则和实践和 DevOps 教的东西很相似。&lt;/p&gt;
&lt;p&gt;有时，我看到云原生的用法只是作为一种说 &amp;ldquo;我们正在开发现代软件&amp;rdquo; 的方式。&amp;ldquo;我们将使用最佳实践；它将是可观察的；它将是健壮的；我们将经常发布，并使一切自动化；简而言之，我们将采用过去 20 年所学到的一切，并以这种方式开发软件，这就是云原生的原因&amp;rdquo;。在这个定义中，云只是一种必然 —— 当然是在云上，因为我们是在 2021 年开发的。&lt;/p&gt;
&lt;p&gt;有时候我看到 Cloud Native 只是用来指云。我们听惯了 Cloud Native，以至于每次说到 Cloud 的时候，都觉得要在后面加上一个 &amp;ldquo;Native&amp;rdquo;，但其实我们只是在说 Cloud。最后，当人们说 Cloud Native 的时候，有时候他们的意思是 idempotent（幂等的）。这个问题是，如果你说 Cloud Native 的意思是 idempotent，其他人就会说：&amp;quot; 什么？我们说的 idempotent 真正的意思是可复用？如果我把它拿去，把它关了，然后再启动，运行结果跟之前也是一样的。这是对云上服务的一个基本要求。”&lt;/p&gt;
&lt;p&gt;有了这些不同的定义，难怪我们在做 Cloud Native 的时候，并不能完全确定我们要做的是什么。&lt;/p&gt;
&lt;h2 id=&#34;为什么&#34;&gt;为什么？&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;我们到底想实现什么？&amp;rdquo; 这是一个非常重要的问题。当我们在思考技术选择和技术风格的时候，我们要从 &amp;ldquo;我做 Cloud Native 是因为别人都在做退到思考我到底想解决什么问题？&amp;rdquo; 为了公平对待 CNCF，他们在对云原生的定义前面就有这个 &amp;ldquo;为什么&amp;rdquo;。他们说：&amp;quot; 云原生就是使用微服务来更快地构建伟大的产品。我们使用微服务不仅仅是因为我们想使用，我们使用微服务是因为微服务帮助我们更快地构建伟大的产品。”&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_hu_805836cd5a7cf49e.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_hu_633f1bd93519c955.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_hu_98048233674a04d6.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_hu_805836cd5a7cf49e.webp&#34;
               width=&#34;760&#34;
               height=&#34;674&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们退一步确保我们理解要解决的问题。为什么我们之前不能更快地打造出优秀的产品？很容易跳过这一步，我想我们所有人有时候都会犯这样的毛病。有时候我们真正要解决的问题是，别人都在做，所以我们害怕错过，除非我们开始做。一旦我们这样说，FOMO（错失恐惧症）就不是一个很好的决策标准。更糟糕的是，&amp;ldquo;我的简历看起来很沉闷&amp;rdquo; 绝对不是选择技术的正确理由。&lt;/p&gt;
&lt;h2 id=&#34;为什么是云&#34;&gt;为什么是云？&lt;/h2&gt;
&lt;p&gt;我认为要想知道为什么我们应该以云原生的方式来做事情；我们要退一步说：&amp;ldquo;为什么我们在云上做事情？&amp;rdquo; 以下是原因。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;成本&lt;/strong&gt;：当我们刚开始把东西放在云上的时候，价格是主要的动机。我们说：&amp;ldquo;我有这个数据中心，我必须支付电费，我必须支付人员维护它。而且我必须购买所有的硬件。当我可以使用别人的数据中心时，我为什么要这么做呢？&amp;rdquo; 在自己的数据中心和别人的数据中心之间形成成本节约的原因是，自己的数据中心必须为最大需求储备足够的硬件。这有可能是大量的容量，而这些容量在大部分时间是没有使用的。如果是别人的数据中心，你可以集中资源。当需求低迷时，你不会为额外的容量付费。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;弹性&lt;/strong&gt;。云计算为你省钱的原因就是因为它的弹性。你可以扩大规模；你可以缩小规模。当然，这已经是旧闻了。我们都认为弹性是理所当然的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;速度&lt;/strong&gt;：我们现在之所以对云感兴趣，是因为速度。不一定是硬件的速度，虽然有些云硬件的速度可以快得让人眼花缭乱。云是使用 GPU 的一个很好的方式，这多少也是使用量子计算机的唯一方式。不过，更普遍的是，我们可以通过云端将一些东西以某种方式、某种方式更快地推向市场，这比我们不得不将软件打印到光盘上，然后邮寄给人们，甚至比我们不得不在自己的数据中心站立实例的时候还要快。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-因素&#34;&gt;12 因素&lt;/h2&gt;
&lt;p&gt;节约成本、弹性和交付速度都很好，但我们只要在云端就能得到这些。为什么我们需要云原生？我们需要云原生的原因是，很多公司发现他们试图上云，结果被电死了。&lt;/p&gt;
&lt;p&gt;事实证明，云上的东西需要用不同的方式来编写和管理。把这些不同的地方阐述出来，就形成了 12 因素。这 12 个因素是对你应该如何编写云应用的一系列规定，这样你就不会被电死。&lt;/p&gt;
&lt;p&gt;你可以说这 12 个因素描述了如何编写云原生应用 —— 但这 12 个因素与微服务完全没有关系。它们都是关于你如何管理应用的状态。它们是关于如何管理你的日志。12 个因素帮助应用程序变得幂等化，但 &amp;ldquo;12 因素&amp;rdquo; 比 &amp;ldquo;幂等化因素&amp;rdquo; 更吸引人。&lt;/p&gt;
&lt;p&gt;这 12 个因素是在 Docker 进入市场前两年发布的。Docker 容器彻底改变了云的使用方式。容器如此之好，很难夸大其重要性。它们解决了很多问题，创造了新的架构可能性。因为容器是如此的简单，所以可以将一个应用分布在许多容器上。有些公司在 100、200、300、400 或 500 个不同的容器上运行单个应用。与这样的工程实力相比，一个应用如果仅仅分布在 6 个容器上，似乎有点不够用。面对如此少的复杂性，人们很容易想到 &amp;ldquo;我一定是做错了。我还不如那边的开发者呢&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_hu_47178619577cd051.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_hu_fb350a8257ea309d.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_hu_80e51211119d0f18.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_hu_47178619577cd051.webp&#34;
               width=&#34;760&#34;
               height=&#34;534&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;事实上，这不是比拼你能拥有多少个容器。容器是很好的，但你拥有的容器数量应该根据你的需求进行调整。&lt;/p&gt;
&lt;h2 id=&#34;速度&#34;&gt;速度&lt;/h2&gt;
&lt;p&gt;让我们试着回忆一下 —— 你的需求又是什么？当我们想到云的时候，我们通常要考虑的是速度。我们之所以想要大量的容器，是因为我们想要更快地将新的东西推向市场。如果我们有很多容器，我们要么把完全一样的东西推向市场，要么以同样的速度推向市场，那么突然之间，这些容器只是一种成本。它们并没有帮助我们，我们正在消耗周期来管理将应用分散在基础设施上的小块应用所带来的复杂性。如果我们有这个神奇的架构，可以让我们对市场做出反应，但我们没有做出反应，那就是一种浪费。如果我们有这个架构，意味着我们可以快速发展，但是我们没有快速发展，那么这也是一种浪费。&lt;/p&gt;
&lt;h2 id=&#34;如何在云原生中失败&#34;&gt;如何在云原生中失败&lt;/h2&gt;
&lt;p&gt;这让我想到了如何在云原生中失败。关于我的背景，我是一个顾问。我是 IBM Garage 的全栈开发人员。我们与初创公司和大公司合作，帮助他们上云，并从云中获得最大的好处。作为其中的一部分，我们帮助他们解决有趣的、艰难的问题，我们帮助他们以比以前更快的速度做软件。为了确保我们真的能从云端获得最大的收益，我们做了精益创业、极限编程、设计思维、DevOps；以及云原生。因为我是一个顾问，所以我看到很多客户都在云计算的旅程中。有时候很顺利，有时候也会有这些陷阱。以下是我看到聪明的客户掉进的一些陷阱。那么，什么是云原生？&lt;/p&gt;
&lt;p&gt;最早的一个陷阱就是关于云原生的意思。如果我说云原生，我是一个意思，而你说云原生，又是另一个意思，我们的沟通就会有问题&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;有时候这并不重要，但有时候却有很大的不同。如果一个人认为目标是微服务，然后另一个人觉得目标是拥有一个幂等的系统，呃哦。或者说，如果一个组织的一部分人想上云，因为他们认为云可以让他们更快地进入市场，但另一部分人上云只是为了和以前完全一样的速度，但更具成本效益，那么我们可能会在以后的道路上发生一些冲突。&lt;/p&gt;
&lt;h2 id=&#34;微服务环境&#34;&gt;微服务环境&lt;/h2&gt;
&lt;p&gt;通常情况下，促使人们对目标产生一些困惑的原因之一是，我们有一种自然的倾向，即看到其他人做着奇妙的事情，并想效仿他们。我们想自己去做那些奇妙的事情，而没有真正思考我们的环境和它们是否适合。我们的一位 IBM 研究员在去和客户谈微服务的时候，有一个启发式的方法。他说：&amp;ldquo;如果他们开始谈论 Netflix，而他们只是一直在谈论 Netflix，他们从来没有提到连贯性，也没有提到耦合，那么可能他们做这件事的原因并不正确。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;有时候我们和客户聊天，他们说：&amp;ldquo;对，我想现代化到微服务。&amp;rdquo; 好吧，微服务不是目标。没有客户会看着你的网站说，&amp;ldquo;哦，微服务。这很好。&amp;rdquo; 客户会看你的网站，并根据它是否满足他们的需求，是否简单和令人愉快，以及，所有这些其他事情来判断它。微服务可以是达到这个目的的一个很好的手段，但它们本身并不是一个目标。我还应该说：微服务是一种手段。它们不一定是实现这一目标的唯一手段。&lt;/p&gt;
&lt;p&gt;我在 IBM Garage 的一位同事与亚太地区的一家银行进行了一些对话。这家银行在响应客户时遇到了问题，因为他们的软件都很老旧、沉重和钙化。他们也遇到了人员问题，因为他们所有的 COBOL 开发人员都老了，而且都要离开工作岗位。因此，银行知道他们必须进行现代化改造。在这个案例中，主要的驱动力不是劳动力的老化，而是竞争力和灵活性。他们被竞争对手打败了，因为他们拥有大量的 COBOL 代码，而每次改变都是昂贵而缓慢的。他们说：&amp;ldquo;好吧，为了解决这个问题，我们需要摆脱所有的 COBOL，我们需要切换到现代微服务架构。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;到目前为止，还不错。我们正准备跳进一些云原生的好东西时，银行又说他们的发布板一年只开两次会。这时，我们又收手了。不管银行的新架构会有多少微服务，这些微服务都会被组装成一个大的单体发布包，每年部署两次。这就是拿了微服务的开销，却没有好处。因为这不是一场看你有多少容器的比赛，大量的容器和缓慢的发布将是一个绝对没有人赢的堆栈。&lt;/p&gt;
&lt;p&gt;大量的微服务被锁定在一个迟缓的发布节奏中，不仅不会是一种胜利，还可能是一种糟糕的损失。当组织尝试微服务时，他们并不总是像图片中的那样，最终得到一个美丽的解耦微服务架构。相反，他们最终得到的是一个分布式单体。这就像一个普通的单体，但要糟糕得多。之所以说这是格外可怕的坏事，是因为一个正常的、非分布式的单体有诸如编译时检查类型和同步的、有保证的内部通信。在单进程中运行会损害你的可扩展性，但这意味着你不能被分布式计算的谬误所困扰。如果你把同样的应用程序，然后只是在互联网上涂抹，不投入任何类型检查或投资于网络问题的错误处理，你不会有更好的客户体验，你会有更糟糕的客户体验。&lt;/p&gt;
&lt;p&gt;在很多情况下，微服务是错误的答案。如果你是一个小团队，你不需要有很多自主的团队，因为每个独立的团队会有大约四分之一的人。假设你没有任何计划，也不希望独立发布部分应用，那么你不会从微服务的独立性中获益。&lt;/p&gt;
&lt;p&gt;为了在你的应用程序的所有这些组件之间提供安全和可靠的通信和可发现性，你刚刚抹过云的一部分，你将需要类似服务网格的东西。你可能在技术曲线上很先进，或者对这个技术曲线有点陌生。你要么不知道服务网格是什么，要么你说：&amp;ldquo;我都知道服务网格是什么。那么复杂，那么夸张。我不需要服务网格。我只想自己搞一个服务网格。&amp;rdquo; 这不一定会给你带来你所希望的结果。你最终还是会得到一个服务网格，但你必须维护它，因为它是你写的！不做微服务的另一个很好的理由是，有时候领域模型就是没有那些天然的断裂点，让你得到漂亮整洁的微服务。在这种情况下，完全有理由说：&amp;ldquo;你知道吗？我就不做了。&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;云原生面条&#34;&gt;云原生面条&lt;/h2&gt;
&lt;p&gt;如果你不从杂乱中走出来，那么你最终会遇到下一个问题，那就是云原生面条。当我看 Netflix 微服务的通信图时，我总觉得有些恐慌。我确信他们知道自己在做什么，而且他们已经想好了，但在我眼里，它看起来完全像意大利面条。让它发挥作用需要很多真正扎实的工程和专门的技能。如果你不具备这种专业性，那么你最终会陷入混乱的局面。&lt;/p&gt;
&lt;p&gt;我被邀请去给一个正在苦苦挣扎的客户做一些支持工作。他们正在开发一个绿地应用，所以他们当然选择了微服务，以尽可能的现代化。他们对我说的第一句话就是：&amp;ldquo;只要我们修改任何代码，其他的东西就会坏掉。&amp;rdquo; 这不是微服务应该发生的事情。事实上，这与我们都被告知如果我们实现微服务会发生的情况完全相反。微服务的梦想是它们是解耦的。遗憾的是，解耦并不是免费的。它当然不会因为你分布式的东西而神奇地发生。当你分布式的东西时，所发生的是你有两个问题而不是一个问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hu_48cdeafe421310fb.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hu_7ec2932d637d8061.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hu_97a07f2594e786c5.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hu_48cdeafe421310fb.webp&#34;
               width=&#34;760&#34;
               height=&#34;549&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生面条还是面条。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的客户的代码之所以这么脆弱，耦合性这么强，其中一个原因是他们的对象模型相当复杂，大约有 20 个类，部分类中有 70 个字段。在微服务系统中处理这种复杂的对象模型是很难的。在这种情况下，他们看了看他们复杂的对象模型，决定：&amp;ldquo;我们知道在我们的微服务之间有共同的代码是非常不好的，因为这样我们就没有解耦。相反，我们要在我们所有的六个微服务中复制和粘贴这个共同的对象模型。因为我们剪切和粘贴它，而不是链接到它，所以我们是解耦的。&amp;rdquo; 嗯，不，你不是解耦的。如果当一件事情发生变化的时候，不管是链接还是复制代码，事情就会中断，这就是耦合。&lt;/p&gt;
&lt;p&gt;在这种情况下，什么是 &amp;ldquo;正确&amp;rdquo; 的做法？在理想的情况下，每个微服务都会整齐地映射到一个域上，而且它们很有区别。如果你有一个大域和很多微小的微服务，那就会有问题了。解决的办法是，要么决定领域真的很大，然后合并微服务，要么做更深层次的领域建模，尝试把对象模型解开，变成不同的边界上下文。&lt;/p&gt;
&lt;p&gt;即使是最干净的域分离，在任何系统中，组件之间总会有一些接触点 —— 这才是系统的本质。这些接触点很容易出错，即使它们是最小的，尤其是当它们是隐藏的。你还记得 &amp;ldquo;火星气候轨道器&amp;rdquo; 吗？与 &amp;ldquo;毅力号&amp;rdquo; 不同的是，它被设计为在安全距离内绕着火星运行，而不是在火星上着陆。遗憾的是，它离火星太近了，被火星的引力拉了进去，然后坠毁了。探测器的失利令人惋惜，根本原因就是个悲剧。轨道器由两个模块控制，一个是探测器，一个是地球上的模块。探测模块是半自主的，因为从地球上大部分时间看不到轨道器。大约每隔三天，行星就会对准，它就会出现在视野中，地球上的团队就会微调它的运行轨迹我猜想当时的指令是这样的：&amp;ldquo;哦，我想你需要向左移动一点，哦，如果你不向右移动一点，你就会错过火星。&amp;rdquo; 除了数字。&lt;/p&gt;
&lt;p&gt;数字是导致问题的原因。地球模块和探测模块是由两个不同的团队建造的两个不同的系统。探测器使用的是英制单位，而 JPL 地面团队使用的是公制单位。尽管这两个系统看起来是独立的，但它们之间有一个非常重要的耦合点。每次地面团队传送指令时，他们发送的指令都会以一种谁也想不到的方式进行解释。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu_fed0cb5405059820.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu_d725aff48d5d60a6.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu_7a668ac2dad4c75f.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu_fed0cb5405059820.webp&#34;
               width=&#34;760&#34;
               height=&#34;568&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个故事的寓意是，分布式系统没有帮助。一部分系统在火星上，一部分系统在地球上，你不能比这更分散。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;微服务需要消费者驱动的接触测试&#34;&gt;微服务需要消费者驱动的接触测试&lt;/h2&gt;
&lt;p&gt;在这种情况下，解决方案，正确的做法是真正明确耦合点是什么，双方各自的期望值是什么。一个很好的方法就是消费者协议驱动的测试（Contract-driven Test）。尽管接触测试（Contract Test）是解决一个大问题的干净利落的办法，但在我们这个行业还没有被广泛使用。我认为部分问题是，它们可能有点棘手，难以学习，这减缓了采用的速度。关于测试的跨团队谈判也会很复杂 —— 尽管如果关于测试的谈判太难，关于实际交互参数的谈判会更难。如果你正在考虑探索接触测试，Spring Contract 或 Pact 是不错的起点。哪一个适合你，取决于你的环境。Spring Contract 很好地集成到了 Spring 生态系统中，而 Pact 是框架无关的，并且支持大量的语言，包括 Java 和 Javascript。&lt;/p&gt;
&lt;p&gt;接触测试远远超出了 OpenAPI 验证的作用，因为它检查的是 API 的语义，而不仅仅是语法。它比 &amp;ldquo;好吧，两边的字段都有相同的名字，所以我们很好。&amp;rdquo; 这是个更有用的检查，它允许你检查，&amp;ldquo;当我得到这些输入时，我的行为是否是预期的行为？我在那边命名的关于那个 API 的假设是否仍然有效？&amp;rdquo; 这些都是你需要检查的东西，因为如果它们不是真的，事情就会变得非常糟糕。&lt;/p&gt;
&lt;p&gt;很多公司都意识到了这个风险，也意识到做微服务的时候系统有不稳定的地方。为了有信心这些东西能一起工作，他们在发布之前会施加一个 UAT 阶段。在任何微服务发布之前，需要有人花几周时间测试它在更广泛的系统中是否正常工作。有了这样的开销，发布不会经常发生。那么这就引出了经典的反模式，那就是不连续的持续集成和持续部署，或者说 I/D。&lt;/p&gt;
&lt;h3 id=&#34;为什么持续集成而不持续部署&#34;&gt;为什么持续集成而不持续部署&lt;/h3&gt;
&lt;p&gt;我和很多客户交流，他们会说：&amp;ldquo;我们有一个 CI/CD。&amp;rdquo; 这给我们敲响了警钟，因为 CI/CD，不应该是你买了一个工具，放在服务器上，然后欣赏，说 &amp;ldquo;有 CI/CD。&amp;ldquo;CD/CD 是你必须要做的事情。这两个字母分别代表持续集成和持续部署或交付。连续在这里意味着 &amp;ldquo;真的经常集成&amp;rdquo; 和 &amp;ldquo;真的经常部署&amp;rdquo;，如果你没有做到这一点，那么根本就不是连续。&lt;/p&gt;
&lt;p&gt;有时候我会无意中听到这样的评论：&amp;ldquo;下周我就把我的分支合并到我们的 CI 系统中&amp;rdquo;。这完全忽略了 &amp;ldquo;CI&amp;rdquo; 中的 &amp;ldquo;C&amp;rdquo;，它代表的是持续。如果你每周合并一次，那就不是连续。这几乎是连续的反义词。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;D&amp;rdquo; 部分可能会更加困难。如果软件每半年才部署一次，CI/CD 服务器可能很有用，但是没有人做 CD。可能有 &amp;ldquo;D&amp;rdquo;，但大家都忘记了 &amp;ldquo;C&amp;rdquo; 的部分。&lt;/p&gt;
&lt;p&gt;到底多长时间推送一次才是合理的？连续性得有多连续？甚至我也承认，一些严格定义的连续会是一个团队中写软件的可笑方式。如果你把每一个角色都推到 main，这在技术上是连续的，但它会在团队中造成混乱。如果你每次提交都集成，并且目标是每小时提交几次，这可能是一个很好的节奏。如果你经常提交，每隔几次提交就集成一次，那么你每天推送几次，这样也是很好的。如果你做的是测试驱动的开发，那么当你得到一个合格的测试时，集成是一个很好的模式。我很提倡基于主干的开发（TBD）。TBD 在调试、实现机会主义重构、避免同事出现大的意外等方面有很多好处。基于主干的开发的技术定义是，你需要每天至少集成一次才算。我有时会听到 &amp;ldquo;每天一次&amp;rdquo; 被描述为 &amp;ldquo;还好&amp;rdquo; 和 &amp;ldquo;就是不连续&amp;rdquo; 之类的。一周一次就真的很成问题了。&lt;/p&gt;
&lt;p&gt;一旦你每个月一次，那就太可怕了。当我加入 IBM 的时候，我们用的是一个构建系统和一个代码仓库，叫 CMVC。对于背景来说，这大概是二十年前的事情，我们整个行业都比较年轻，比较愚蠢。我在 IBM 的第一份工作是帮助构建 WebSphere 应用服务器。我们有一个大型的多站点构建，团队每周有六天开会，包括周六，讨论任何构建失败的问题。那个电话有很多重点，你不希望在 WebSphere 构建电话中被叫起来。我刚从大学毕业，对团队中的软件开发一窍不通，所以一些资深的开发人员把我收在了他们的手下。我至今还记得的一个建议是，避免被 WebSphere 构建调用的方法是将你所有的修改在本地机器上保存半年，然后全部批量推送。&lt;/p&gt;
&lt;p&gt;在这个项目上，我还小，我想，好吧，这似乎不是很正确的建议，但我想你最清楚。事后看来，我意识到 WebSphere 的构建破坏得很严重，因为人们将他们的变化保存了六个月，然后才试图与他们的同事进行整合。很明显，那是行不通的，我们改变了做事的方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_hu_b550fe57dd60a5c2.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_hu_4d4a4b49350744ae.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_hu_e685726989ae801f.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_hu_b550fe57dd60a5c2.webp&#34;
               width=&#34;760&#34;
               height=&#34;480&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你应该多久整合一次？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下一个更难的问题是，你应该多久发布一次？和集成一样，有一个合理的选择范围。你可以每次推送都发布。许多技术公司都这样做。如果你每次迭代部署一次，你还是很有优势的。一个季度发布一次就有点悲哀了。你可以每两年发布一次。现在看来慢得荒唐，但在糟糕的过去，这是我们行业的标准模式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hu_672dc0c4743ec70c.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hu_8da72d6190f4e465.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hu_2aedd26398376ef3.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hu_672dc0c4743ec70c.webp&#34;
               width=&#34;760&#34;
               height=&#34;392&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多久应该部署到生产中一次？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之所以每次推送都能部署到生产中，是因为部署不等于发布。如果我们的新代码太不完整或者太吓人，无法真正展示给用户，我们仍然可以部署它，但要把它隐藏起来。我们可以让代码实际存在于生产代码库中，但没有任何东西与之相连。这样就很安全了。如果我们已经有点太纠结了，我们可以使用功能标志来翻开和关闭功能。如果我们感觉更冒险，我们可以做 A/B 或亲朋好友测试，这样只有一小部分用户看到我们可怕的代码。金丝雀部署是另一种变化，用于预先检测噩梦，在它们进入主流使用之前。&lt;/p&gt;
&lt;p&gt;不发布有两个不好的后果。它延长了反馈周期，这会影响决策，并使工程师感到悲伤。从经济上讲，这也意味着有库存（工作软件）坐在货架上，而不是送到客户手中。精益原则告诉我们，有库存放在那里，不产生退货，就是浪费。&lt;/p&gt;
&lt;p&gt;那么话题就是，为什么我们不能发布这个？是什么阻止了更频繁的部署？很多组织害怕他们的微服务，他们希望对整个组件进行集成测试，通常是手动集成测试。有一个客户，有大约 60 个微服务，他们希望确保不存在某个聪明的工程师火花可以发布一个微服务而不发布其他 59 个微服务的可能性。为了强制执行这一点，他们为所有的微服务大批量地设置了一个单一的管道。这显然不是微服务的价值取向，即微服务是可以独立部署的。可悲的是，这是他们觉得最安全的方式。&lt;/p&gt;
&lt;p&gt;我们也看到了因为对质量和完整性的担忧，实际上不愿意交付。当然，这些并不荒唐。你不想激怒你的客户。另一方面，就像里德・霍夫曼所说的那样，如果你没有因为第一次发布而感到尴尬，那就太晚了。持续改进是有价值的，让东西被使用也是有价值的。&lt;/p&gt;
&lt;p&gt;如果发布的频率不高，而且是单体的，你就有了这些漂亮的微服务架构，可以让你走得更快，然而你走得很慢。这是坏的业务，也是坏的工程。&lt;/p&gt;
&lt;p&gt;假设你选择了频繁部署。所有保护你的用户不受半成品功能影响的东西，比如自动测试、功能标志、A/B 测试、SRE，都需要大量的自动化。通常当我开始与客户合作时，我们有一个关于测试的问题，他们说：&amp;ldquo;哦，我们的测试不是自动化的。&amp;rdquo; 这意味着他们实际上不知道代码是否在任何特定的点上工作。他们希望它能工作，而且上次检查时可能已经工作了，但我们没有任何办法在不运行手动测试的情况下知道它现在是否工作。&lt;/p&gt;
&lt;p&gt;问题是，退步是会发生的。即使所有的工程师都是最完美的工程师，也有一个不那么完美的外部世界。他们所依赖的系统可能会有意想不到的行为。如果一个依赖更新改变了行为，即使没有人做错任何事情，也会有一些东西被破坏。这就回到了 &amp;ldquo;我们不能交付是因为我们对质量没有信心&amp;rdquo; 的问题上。好吧，让我们解决对质量的信心问题，然后我们就可以交付了。&lt;/p&gt;
&lt;p&gt;我谈到了合同测试。这很便宜，也很简单，可以在单元测试层面进行，当然，你也需要自动化集成测试。你不希望依赖手动集成测试，否则它们会成为瓶颈。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;CI/CD&amp;rdquo; 似乎已经取代了我们词汇中的 &amp;ldquo;构建&amp;rdquo;，但在这两种情况下，它都是你作为一个工程组织所拥有的最有价值的东西之一。它应该是你的朋友，它应该是这种无处不在的存在。有时候构建的方式是，它在某个地方的 Jenkins 系统上被关闭了。稍微勤快一点的人时不时去检查一下网页，发现是红色的，就去告诉同事，最后有人把问题解决了。更好的是只是一个被动的构建指标，大家都可以看到，而不需要单独打开一个页面来查看。如果显示器红了，真的很明显，那就是有变化了，而且很容易看最近的变化。如果你有一个项目，红绿灯就可以用。如果你有微服务，你可能会需要类似一组磁贴的东西。即使你没有微服务，你可能会有好几个项目，所以你需要比红绿灯更完整一点的东西，尽管红绿灯很可爱。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu_ddda1741ca41556e.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu_48368833cbc1861c.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu_b386050186b21248.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu_ddda1741ca41556e.webp&#34;
               width=&#34;760&#34;
               height=&#34;572&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们不知道什么时候构建好了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你投资你的构建监控，那么你最终会出现破窗的情况。我到了客户那里，第一件事就是看了一下构建，我说：&amp;ldquo;哦，这个构建好像坏了。&amp;rdquo; 他们说：&amp;ldquo;是啊，已经坏了几个星期了。&amp;rdquo; 这时，我就知道我有很多工作要做了！&lt;/p&gt;
&lt;p&gt;为什么一个“破窗”的构建是不好的？这意味着你无法进行自动化集成测试，因为没有任何东西能从构建中做出来。事实上，你甚至无法进行手动集成测试，所以服务间的兼容性可能会恶化，而且没有人会知道。&lt;/p&gt;
&lt;p&gt;新的回归没有被发现，因为这个构建已经红了。也许最糟糕的是，它创造了一种文化，所以当其他构建中的一个红色时，人们并不那么担心，因为它更多的是相同的：&amp;ldquo;现在我们有两个红色。也许我们可以弄到整套的，然后如果我们把它们都弄红了，就能匹配了。&amp;rdquo; 嗯，不，不应该是这样的。&lt;/p&gt;
&lt;h2 id=&#34;锁定的完全僵化的不灵活的云雾缭绕的云端&#34;&gt;锁定的完全僵化的、不灵活的、云雾缭绕的云端&lt;/h2&gt;
&lt;p&gt;这些都是发生在团队层面的挑战。它们是关于我们作为工程师如何管理自己和我们的代码。但当然，尤其是当你到了一定规模的组织，你最终会面临另一系列的挑战，那就是组织如何使用云。我注意到，有些组织喜欢把云，变成一个锁定的、完全僵化的、灵活的、没有云的云。&lt;/p&gt;
&lt;p&gt;如何让一个云端不云端？你说：&amp;ldquo;好吧，我知道你可以走得很快，我知道你所有的自动化支持都走得很快，但是我们有一个流程。我们有一个架构评审委员会，它的会议相当不频繁。&amp;rdquo; 它将在项目准备交付后一个月开会，或者在最坏的情况下，它将在项目已经交付后一个月开会。虽然东西已经交付了，但我们还是在走流程。架构将在已经在现场验证后进行纸面审查，这是愚蠢的。&lt;/p&gt;
&lt;p&gt;有人曾经给我讲过一个故事。一个客户向他们抱怨说，IBM 卖给他们的一些配置软件不能用。当时我们承诺我们的精巧的配置软件可以让他们在十分钟内创建虚拟机。这是几年前的事了，当时 &amp;ldquo;10 分钟创建一个虚拟机&amp;rdquo; 是很先进很酷的。我们向他们承诺，这将是美好的。&lt;/p&gt;
&lt;p&gt;当客户安装好它并开始使用时，他们并没有发现它的美妙。他们以为他们会得到 10 分钟的供应时间，但他们看到的是，他们花了三个月的时间来供应一个云实例。他们回来找我们，他们说：&amp;ldquo;你们的软件完全坏了。你卖错了。你看，花了三个月的时间。&amp;rdquo; 我们对此感到疑惑，于是我们进去做了一些调查。事实证明，发生了什么事，他们创建了一个 84 步的预批准程序，以获得其中的一个实例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_hu_218607d70d6a884c.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_hu_e908e7ede93a601b.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_hu_31f77c894d86b598.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_hu_218607d70d6a884c.webp&#34;
               width=&#34;760&#34;
               height=&#34;612&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这款供应软件已经坏了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术有了，但文化没有，所以技术没有用。这是可悲的。我们把这个云，这是一个美丽的云，它有所有这些神奇的属性，它让一切都变得非常简单，然后组织的另一部分人说，&amp;ldquo;哦，这有点可怕。我们不会希望人们真的能够做事情。让我们把它关进笼子里吧！&amp;rdquo; 那种老式的重文案的治理方式是行不通的 —— 同时也是真的让大家很烦。它不会给出结果。更糟糕的是，它实际上不会让事情变得更安全。它可能会使他们更不安全。它肯定会让事情变得更慢，而且要花钱。我们不应该这样做。&lt;/p&gt;
&lt;p&gt;我和另一个客户聊过，那是一家大型汽车公司，他们在云计算供应方面遇到了真正的问题。他们花了很长的时间来获得实例。他们认为，&amp;ldquo;我们要解决这个问题的方法是我们要从供应商 A 转移到供应商 B。&amp;rdquo; 这可能会奏效，但实际上缓慢的问题是他们的内部采购。切换供应商会绕过他们既定的采购流程，所以可能会加快一段时间，但最终，他们的治理团队会注意到新的供应商，并实施控制。一旦发生这种情况，他们就会将监管落实到位，然后恢复现状。他们所有的成本会改变，但实际上没有任何的好处。这有点像，我很抱歉地说，我有时会受到这样的诱惑 —— 如果你看着你的炉子，你决定，&amp;ldquo;哦，那个烤箱很脏。清理很困难，所以我要搬家，所以我没有清洁烤箱。&amp;rdquo; 但后来，当然，同样的事情发生在其他房子，和新的烤箱变得肮脏。你需要一个更可持续的过程，而不是仅仅更换供应商来试图超越自己的采购。&lt;/p&gt;
&lt;p&gt;如果只有开发者在改变，如果只有开发者在走 Cloud Native 的道路，那么就是行不通的。这并不意味着开发者驱动的自由竞争是正确的模式。如果周围没有一些治理，那么云就会变成一个神秘的钱坑。我们很多人都遇到过这样的问题：看着云账单，觉得 &amp;ldquo;嗯。是啊，这么多，我也不明白钱都花到了哪里，也不明白是谁花的。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;用云端配置硬件是如此简单，但这并不意味着硬件是免费的。还是要有人为它付费。硬件很容易配置，也不能保证硬件有用。&lt;/p&gt;
&lt;p&gt;当我刚开始学习 Kubernetes 的时候，我当然也尝试过。我创建了一个集群，但后来我就偏离了轨道，因为我有太多的工作在进行。过了两个月，我又回到我的集群，发现这个集群一个月大约 1000 英镑&amp;hellip;&amp;hellip; 而且是完全没有价值的。太浪费了，我现在想起来还觉得恶心。&lt;/p&gt;
&lt;p&gt;我们的技术使我们能够做的很多事情都是为了提高效率。伟大的管理顾问彼得・德鲁克说过：&amp;ldquo;没有什么比高效地做那些根本不应该做的事情更无用的了。&amp;rdquo; 高效地创建没有价值的 Kubernetes 集群，这不是好事。除了成本高，还有对生态环境的影响。让一个 Kubernetes 集群消耗价值 1000 英镑的电力，什么都不做，对地球不是很好。&lt;/p&gt;
&lt;p&gt;对于我说的很多问题，最初看起来是技术问题，其实是人的问题。我觉得这个有点不一样，因为这个看似是人的问题，其实是技术问题。这个领域其实工具可以帮助我们。比如说，工具可以帮助我们管理浪费，可以检测到闲置的服务器，帮助我们把服务器追溯到发起人。这方面的工具还没有，但已经越来越成熟了。&lt;/p&gt;
&lt;h2 id=&#34;云管理你的云&#34;&gt;云管理你的云&lt;/h2&gt;
&lt;p&gt;这个云管理的工具化最后是在云上，所以你最后是在递归的情况下，要有一些云来管理你的云。我的公司有一个多云管理器，它会看你的工作负载，找出工作负载的形状，从财务上来说，你能让它上的最优化的供应商是什么，然后自动进行这种迁移。我预计我们可能会开始看到越来越多这样的软件，它在看它，然后说：&amp;ldquo;顺便说一下，我可以告诉他的 Kubernetes 集群其实没有流量，它已经在那里待了两个月了。你为什么不去和 Holly 说几句话呢？&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;微服务运维混乱&#34;&gt;微服务运维混乱&lt;/h2&gt;
&lt;p&gt;管理云成本越来越复杂，这反映了一个更普遍的事情，就是云运维越来越复杂。我们正在使用越来越多的云供应商。有越来越多的云实例涌现出来。我们到处都有集群，那么我们到底该如何为这些集群做运维呢？这就是 SRE (Site Reliability Engineering) 的作用。&lt;/p&gt;
&lt;p&gt;网站可靠性工程的目的是使操作更加可重复，减少繁琐，以使服务更加可靠。它实现这一目标的方法之一是将一切自动化，我认为这是一个令人钦佩的目标。像发布这样的事情，我们越是自动化，我们就越能做到，这对工程师和消费者来说都是好事。最终的目标应该是，发布不是一个事件，而是一切照旧。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu_b91dcb94eff964f4.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu_d3330569afcd4dc5.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu_6b067b43c96efbef.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu_b91dcb94eff964f4.webp&#34;
               width=&#34;760&#34;
               height=&#34;711&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使发布深感无聊。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之所以能够有这种无聊的感觉，是我们对可回收性有信心，是 SRE 让我们对可回收性有信心。&lt;/p&gt;
&lt;p&gt;我有另一个悲伤的太空故事，这次是来自苏联。在 80 年代，一位工程师想对苏联一个叫 &amp;ldquo;Phobos&amp;rdquo; 的太空探测器的代码进行更新。当时，它是机器代码，都是 0 和 1，而且都是手写的。很显然，你不想用手写的机器代码对一个绕着地球飞驰的航天器进行实时更新，而不进行一些检查。在任何推送之前，代码都会经过验证器，验证器相当于机器代码的 linter。&lt;/p&gt;
&lt;p&gt;这样做很好，直到自动检查器坏了，这时需要进行更改。一位工程师说：&amp;ldquo;哦，但我真的想做这个改动。我就绕过自动检查器，直接把我的代码推送给空间探测器，因为，我的代码当然是完美的。&amp;rdquo; 于是，他们用手写的机器代码，在没有检查的情况下，对绕着地球飞驰的航天器进行了实时更新。能出什么问题呢？&lt;/p&gt;
&lt;p&gt;发生的是一个非常微妙的 bug。一切似乎都在正常工作。不幸的是，工程师忘记了其中一个指令的零点。这就改变了指令，从原来的指令变成了停止探测器的充电鳍旋转的指令。Phobos 号的翅片会转向太阳方向，这样无论它朝向哪个方向，都能收集太阳能。两天来一切都很好，直到电池没电了。一旦探测器没电了，他们就没办法恢复它，因为整个东西都死了。&lt;/p&gt;
&lt;p&gt;这就是一个完全无法恢复的系统的例子。一旦它死了，你就再也找不回来了。你不能只是做一些事情，然后把它恢复到一个干净的空间探测代码副本，因为它在太空中。&lt;/p&gt;
&lt;p&gt;这样的系统是真正无法恢复的。我们很多人认为，我们所有的系统几乎都和空间探测器一样无法恢复，但事实上，只有极少数系统可以恢复。&lt;/p&gt;
&lt;p&gt;我们真正想做的是在这个频谱的顶端，我们可以在几毫秒内恢复，没有数据丢失。如果有任何问题，只是，&amp;ldquo;ping，它被修复&amp;rdquo;。如果有什么问题，它只是，&amp;ldquo;ping，它的固定&amp;rdquo;。这真的很难达到，但有一大堆中间点是现实的目标。&lt;/p&gt;
&lt;p&gt;如果我们恢复的速度很快，但是数据丢失了，那就不太好了，但是我们可以接受。如果我们有交接和人工干预，那对于恢复的速度会慢很多。当我们在考虑频繁部署和部署的时候，非常无聊 —— 我们要有信心，我们在那个上端。我们到达那里的方式，交接不好，自动化，好。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu_ca10b67a3ba666.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu_6393f85d8fc0be49.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu_5c86490004cc2cf1.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu_ca10b67a3ba666.webp&#34;
               width=&#34;760&#34;
               height=&#34;610&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;云原生成功的方法&#34;&gt;云原生成功的方法&lt;/h2&gt;
&lt;p&gt;这篇文章包含了一大堆关于我所看到的可能出错的事情的悲惨故事。我不想给你留下一个印象，即所有的事情都会出错，因为很多时候，事情确实非常正确。云原生是一种奇妙的软件开发方式，它可以让团队感觉更好，降低成本，让用户更快乐。作为工程师，我们可以把更少的时间花在辛苦和繁琐的事情上，而把更多的时间花在真正想做的事情上&amp;hellip;&amp;hellip; 我们可以更快地进入市场。&lt;/p&gt;
&lt;p&gt;要想达到这种快乐的状态，我们必须在整个组织中保持一致。我们不能让一群人说微服务，一群人说快，一群人说老式治理。这几乎肯定是行不通的，会有很多脾气暴躁的工程师和委屈的财务人员。相反，一个组织应该在整体层面上达成共识，它要实现的目标是什么。一旦同意了这个目标，就应该对反馈进行优化，确保反馈回路尽可能短，因为这才是合理的工程。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu_21d7d30ae2baf3b0.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu_79e646b86e267a2a.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu_7486447e4a281976.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu_21d7d30ae2baf3b0.webp&#34;
               width=&#34;177&#34;
               height=&#34;208&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Holly Cummins&lt;/strong&gt; 是 IBM 企业战略部的创新领导者，并在 IBM Garage 担任顾问多年。作为 Garage 的一员，她为各行各业的客户提供技术驱动的创新，从银行业到餐饮业，从零售业到非政府组织。Holly 是 Oracle Java 冠军、IBM Q 大使和 JavaOne Rock Star。她与人合著了 Manning 的《Enterprise OSGi in Action》。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
