<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>John Howard | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/author/john-howard/</link>
      <atom:link href="https://cloudnativecn.com/author/john-howard/index.xml" rel="self" type="application/rss+xml" />
    <description>John Howard</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Wed, 09 Apr 2025 11:15:24 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/media/sharing.png</url>
      <title>John Howard</title>
      <link>https://cloudnativecn.com/author/john-howard/</link>
    </image>
    
    <item>
      <title>Istio Egress Gateway 简化指南</title>
      <link>https://cloudnativecn.com/blog/egress-gateway-made-easy/</link>
      <pubDate>Wed, 09 Apr 2025 11:15:24 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/egress-gateway-made-easy/</guid>
      <description>&lt;p&gt;多年来，Istio 一直提供一种可选方案来部署 “&lt;a href=&#34;https://istio.io/latest/docs/tasks/traffic-management/egress/egress-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Egress Gateway&lt;/a&gt;”，这是一种功能强大的机制，可将出站流量经由一个 Gateway 统一转发，以便对其实施各类策略，包括授权、审计、可观测性等等。&lt;/p&gt;
&lt;p&gt;尽管功能强大，但长期以来，设置 egress gateway 一直相当复杂。即便只是最基本的场景：将来自特定域名的流量通过 egress gateway 转发，都需要先后配置 5 个不同的 Istio 对象（参见 &lt;a href=&#34;https://istio.io/latest/docs/tasks/traffic-management/egress/egress-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;），更不用说后续还要为流量添加各种高级策略了。&lt;/p&gt;
&lt;p&gt;凭借 Istio 的 Ambient 模式与 Gloo Mesh，现在配置 egress gateway 的过程变得更加轻松，同时还能为网格中的流量提供更优的功能与管理。让我们在这篇博客中深入探讨一下。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图片-1为每个目的地配置-egress-gateway-所需的对象&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图片 1：为每个目的地配置 Egress Gateway 所需的对象&#34; srcset=&#34;
               /blog/egress-gateway-made-easy/6724f6a4cde1d33ee0765206_Egress-1-2048x548_hu_8eba11926a05a3a5.webp 400w,
               /blog/egress-gateway-made-easy/6724f6a4cde1d33ee0765206_Egress-1-2048x548_hu_1cc2b3daa610be01.webp 760w,
               /blog/egress-gateway-made-easy/6724f6a4cde1d33ee0765206_Egress-1-2048x548_hu_28536b1e89091148.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/egress-gateway-made-easy/6724f6a4cde1d33ee0765206_Egress-1-2048x548_hu_8eba11926a05a3a5.webp&#34;
               width=&#34;760&#34;
               height=&#34;203&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图片 1：为每个目的地配置 Egress Gateway 所需的对象
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;istio-ambient-模式与-gloo-mesh-带来的简化&#34;&gt;Istio Ambient 模式与 Gloo Mesh 带来的简化&lt;/h2&gt;
&lt;p&gt;借助 &lt;a href=&#34;https://www.solo.io/blog/istio-ambient-revolution/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambient 模式&lt;/a&gt;，管理 egress 流量变得非常轻松。在 Ambient 模式下，不再使用传统的 Sidecar 代理，而是使用独立部署的 “waypoint” 代理来代理服务的流量。整体示意如下所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-wayproxy&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Wayproxy&#34; srcset=&#34;
               /blog/egress-gateway-made-easy/6724f6cb94d57f82bf0548d5_Egress-2_hu_1177a52740960df4.webp 400w,
               /blog/egress-gateway-made-easy/6724f6cb94d57f82bf0548d5_Egress-2_hu_29ca7a452b5c2e0b.webp 760w,
               /blog/egress-gateway-made-easy/6724f6cb94d57f82bf0548d5_Egress-2_hu_f5688967e07b09ef.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/egress-gateway-made-easy/6724f6cb94d57f82bf0548d5_Egress-2_hu_1177a52740960df4.webp&#34;
               width=&#34;760&#34;
               height=&#34;316&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Wayproxy
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;各个服务可以绑定到一个 waypoint 上，然后 Istio 会自动将访问这些服务的流量都通过该 waypoint。&lt;/p&gt;
&lt;p&gt;有趣的是，我们也可以像对待内部服务一样，把 &lt;em&gt;外部域名&lt;/em&gt;（通过 ServiceEntry 定义）绑定到某个 waypoint。只要像对待 Service 那样，将这些域名映射到 waypoint，访问这些域名的流量也能自动经由该 waypoint 代理转发。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2在-istio-ambient-模式下为每个目的地配置-egress-gateway-所需的对象&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 2：在 Istio Ambient 模式下为每个目的地配置 Egress Gateway 所需的对象&#34; srcset=&#34;
               /blog/egress-gateway-made-easy/6724f6ebe547d443658fd5d1_Egress-3-2048x727_hu_5c453830cc6b608d.webp 400w,
               /blog/egress-gateway-made-easy/6724f6ebe547d443658fd5d1_Egress-3-2048x727_hu_dc704405026c26f3.webp 760w,
               /blog/egress-gateway-made-easy/6724f6ebe547d443658fd5d1_Egress-3-2048x727_hu_ed5fcfa7e7a9b74a.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/egress-gateway-made-easy/6724f6ebe547d443658fd5d1_Egress-3-2048x727_hu_5c453830cc6b608d.webp&#34;
               width=&#34;760&#34;
               height=&#34;270&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2：在 Istio Ambient 模式下为每个目的地配置 Egress Gateway 所需的对象
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过这种方式，即使保持同样的丰富功能，配置 egress gateway 的过程也被极大简化。此后，流量可观测性还可以通过 Gloo Mesh 进行可视化。&lt;/p&gt;
&lt;h2 id=&#34;实践体验&#34;&gt;实践体验&lt;/h2&gt;
&lt;p&gt;首先，在已安装 Istio Ambient 模式的集群上，我们部署一个测试应用并将其所在的 Namespace 加入 Ambient 网格：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f shell.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl label namespace default istio.io/dataplane-mode&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ambient
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，我们可以验证测试应用依然可以正常发送出站流量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl httpbin.org/get
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;headers&amp;#34;&lt;/span&gt;: &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;Host&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;httpbin.org&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;http://httpbin.org/get&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们的目标是让这部分流量走过一个 egress gateway，从而统一对其进行策略和访问控制。在 Istio Ambient 模式中，这比在 Sidecar 模式要简单得多。&lt;/p&gt;
&lt;p&gt;首先，我们需要部署一个 waypoint 代理来充当 egress gateway。只需部署一次即可，后续可以共享给要捕获流量的其他域名。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl create namespace istio-egress
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ istioctl waypoint apply --enroll-namespace --namespace istio-egress
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，为 &lt;strong&gt;httpbin.org&lt;/strong&gt; 创建一个 &lt;strong&gt;ServiceEntry&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ServiceEntry&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin.org&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-egress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;httpbin.org&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resolution&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DNS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就是全部所需！因为部署 waypoint 时使用了 &lt;strong&gt;&amp;ndash;enroll-namespace&lt;/strong&gt; 参数，该命名空间（&lt;code&gt;istio-egress&lt;/code&gt;）中的所有服务都会自动绑定到此 waypoint。如果我们只想在单个 Service/ServiceEntry 级别进行绑定，也可以在每个对象上显式添加标签 &lt;strong&gt;istio.io/use-waypoint: waypoint&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在，这个 ServiceEntry 已经绑定到我们之前部署的 waypoint 代理上，原先的请求无需任何改动就会自动穿过该 waypoint，并由 Istio 自动进行 mTLS 加密：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$curl&lt;/span&gt; httpbin.org/get -v
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;* Request completely sent off
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt; HTTP/1.1 &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt; server: istio-envoy
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后，我们就可以从 waypoint 中收集日志、追踪信息以及指标来观察流量。例如，从 waypoint 的日志就能看到刚刚发出的请求：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl logs waypoint-6c6b888f4f-wmnr2 --tail&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;2024-07-18T16:13:58.198Z&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;GET /get HTTP/1.1&amp;#34;&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; - via_upstream - &lt;span class=&#34;s2&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;252&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;260&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;259&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;curl/8.7.1&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;8d80cec6-8fc1-40de-8bc7-19716f173bbd&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;httpbin.org&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;3.234.9.11:80&amp;#34;&lt;/span&gt; inbound-vip&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;80&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;http&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;httpbin.org&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 10.244.0.24:41160 240.240.0.2:80 10.244.0.18:41548 - default
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;策略管理&#34;&gt;策略管理&lt;/h2&gt;
&lt;p&gt;Egress gateway 最强大的特性之一就是能够对所有出站流量强制执行访问控制策略。策略范围可以很简单——比如基于域名的白名单，也可以非常复杂，比如 &lt;a href=&#34;https://docs.solo.io/gloo-mesh-gateway/main/security/dlp/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据丢失防护（DLP）&lt;/a&gt; 等。&lt;/p&gt;
&lt;p&gt;举个例子，我们可以限制低权限应用只能访问 &lt;code&gt;/get&lt;/code&gt; 接口，而高权限应用可以访问 httpbin.org 的所有接口。要实现这一点，只需在我们创建的 ServiceEntry 上附加一条 AuthorizationPolicy 即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;security.istio.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;AuthorizationPolicy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-egress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetRefs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ServiceEntry&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin.org&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ALLOW&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# admin 应用可以访问任意接口&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;source&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;principals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;cluster.local/ns/default/sa/admin&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 其他应用只允许访问 /get&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;operation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;methods&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;GET&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;paths&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/get&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，从低权限应用发出的 POST 请求就会被拒绝：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl httpbin.org/get
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;headers&amp;#34;&lt;/span&gt;: &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;Host&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;httpbin.org&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;http://httpbin.org/get&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl -X POST httpbin.org/post
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;RBAC: access denied
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而在高权限应用（admin）中，POST 请求可以正常执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl httpbin.org/post -X POST
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;headers&amp;#34;&lt;/span&gt;: &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;Host&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;httpbin.org&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;http://httpbin.org/post&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;tls-origination&#34;&gt;TLS Origination&lt;/h2&gt;
&lt;p&gt;另一个在 egress gateway 上经常使用的策略是进行 TLS Origination。在上面的例子中，我们虽然在网格 &lt;em&gt;内部&lt;/em&gt; 使用了 Istio 自动加密，但流量一旦离开集群，就会以明文形式通过公共网络传输——这显然存在严重的安全风险。&lt;/p&gt;
&lt;p&gt;幸运的是，我们可以在 egress waypoint 中为请求启用 TLS，让请求在离开集群前就被加密。这个功能在对需要客户端身份认证的服务进行访问时尤为有用，可以集中地对访问进行控制；但在这里，我们仅演示最简单的 TLS。&lt;/p&gt;
&lt;p&gt;对此，我们只需要在 ServiceEntry 中做一点小改动，并添加一个 DestinationRule：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ServiceEntry&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin.org&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-egress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;httpbin.org&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;443&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 新增：把发往 80 端口的流量转发到 443 端口&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resolution&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DNS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 新增：为发往 `httpbin.org` 的请求启用 TLS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DestinationRule&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin.org-tls&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-egress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin.org&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;trafficPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;tls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;SIMPLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样一来，所有的请求都会被自动升级为 HTTPS，而应用自身无需做任何改动：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl httpbin.org/get
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;headers&amp;#34;&lt;/span&gt;: &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;Host&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;httpbin.org&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://httpbin.org/get&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>在 Kubernetes 中实现 mTLS：选项与推荐</title>
      <link>https://cloudnativecn.com/blog/mtls-kubernetes/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://cloudnativecn.com/blog/mtls-kubernetes/</guid>
      <description>&lt;p&gt;在与 Kubernetes 用户的对话中，经常会听到这样一句话：“我只想让我的所有流量在 Kubernetes 中实现 mTLS 加密。”有时，这种要求还会加上一些附加条件，比如“……但不要涉及服务网格的复杂性。”&lt;/p&gt;
&lt;p&gt;这是一个合理的需求，市面上有很多解决方案，各自有不同的取舍。在本文中，我将介绍几种选择，并提供一些建议。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么要求是“mTLS”，而不是更广泛的“加密”？原因有很多。有些人可能已经对各种加密机制进行了研究，并决定使用 mTLS，而有些人可能对其他选项不了解。在本文中，我将主要关注 mTLS。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;为什么选择-mtls&#34;&gt;为什么选择 mTLS&lt;/h2&gt;
&lt;p&gt;在深入探讨 mTLS 的最佳方案之前，我们有必要先理解为什么要使用它。&lt;/p&gt;
&lt;p&gt;mTLS 代表双向 TLS，这与互联网上大多数使用的加密（如 &lt;code&gt;https://&lt;/code&gt;）类似，但它是双向的。&lt;/p&gt;
&lt;p&gt;在标准的互联网场景中，浏览器会验证目标网站的 TLS 证书，以确认 &lt;code&gt;bank.com&lt;/code&gt; 确实由 &lt;code&gt;bank.com&lt;/code&gt; 操作，而不是遭遇&lt;a href=&#34;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;中间人攻击（MITM）&lt;/a&gt;。网站也可能会验证用户，但通常是在应用层进行，而不是通过 TLS。&lt;/p&gt;
&lt;p&gt;双向 TLS 则是类似的机制，但&lt;strong&gt;客户端&lt;/strong&gt;也会提供一个证书，该证书需要被服务器验证。浏览器技术上也支持这种方式，但由于操作上的复杂性，实际应用非常少。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 集群（或其他基础设施）内部使用双向 TLS 的好处与在互联网上的应用类似。它提供了&lt;strong&gt;身份验证&lt;/strong&gt;（双方都能证明自己的身份）、&lt;strong&gt;机密性&lt;/strong&gt;（窃听者无法看到交换的数据）、以及&lt;strong&gt;完整性&lt;/strong&gt;（数据在传输中不会被篡改）。&lt;/p&gt;
&lt;p&gt;这些属性是实现[零信任](&lt;a href=&#34;https://www.cloudflare.com/learning/security/glossary/what-is-zero-trust/#:~:text=Zero&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cloudflare.com/learning/security/glossary/what-is-zero-trust/#:~:text=Zero&lt;/a&gt; Trust security is an,outside of the network perimeter.)安全策略的重要一步。此外，它们也是满足各种合规要求（无论是公司内部政策还是政府标准，如&lt;a href=&#34;https://www.nist.gov/standardsgov/compliance-faqs-federal-information-processing-standards-fips&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FIPS&lt;/a&gt;）的常见要求。&lt;/p&gt;
&lt;h2 id=&#34;实现-mtls-的选项&#34;&gt;实现 mTLS 的选项&lt;/h2&gt;
&lt;p&gt;一旦你决定要使用 mTLS，你需要选择如何去实现它。这里有几种不同的方法。&lt;/p&gt;
&lt;h3 id=&#34;自行实现&#34;&gt;自行实现&lt;/h3&gt;
&lt;p&gt;传统的方法是为所有应用程序配置证书，并修改应用程序以使用这些证书。这在小规模环境中可能还算简单，但在大规模环境中则极具挑战性。主要问题如下：&lt;/p&gt;
&lt;p&gt;首先，需要管理证书的配置。这包括命名方案的制定、信任根的分发、证书的签发、确保证书的轮换和更新等。工具如 &lt;a href=&#34;https://cert-manager.io/docs/usage/csi-driver/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;cert-manager&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&#34;https://spiffe.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;SPIRE&lt;/code&gt;&lt;/a&gt; 可以帮助解决部分问题。但根据我的经验，许多用户在采用这种方法时，往往需要修改已有的证书基础设施以适应 Kubernetes。&lt;/p&gt;
&lt;p&gt;在管理好证书后，还需要修改应用程序以开始使用 TLS，并正确发送和验证对等证书。对于大型的多语言部署来说，这可能是一个挑战。虽然让一个应用程序开始使用 TLS 通常是相对简单的，但往往会遇到各种棘手的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你无法原子性地更改整个集群。在部分状态下如何处理？&lt;/li&gt;
&lt;li&gt;如何确保所有流量都在使用 TLS，而不仅仅是某些子集？应用程序可能有多个入口和出口点，是否全部覆盖？&lt;/li&gt;
&lt;li&gt;如何验证对等证书？是否有跨应用程序的通用逻辑？是否支持所有使用的语言？是否在所有应用中保持更新？&lt;/li&gt;
&lt;li&gt;所有应用程序是否都支持 TLS？是否支持&lt;strong&gt;双向&lt;/strong&gt; TLS？是否支持你的&lt;a href=&#34;https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#spiffe-id&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;证书方案&lt;/a&gt;？&lt;/li&gt;
&lt;li&gt;公司范围内的每个应用程序代码更改的开发和推出需要多长时间？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，常常会使用一些更高层的选项来处理这些问题。&lt;/p&gt;
&lt;h3 id=&#34;基于-sidecar-的服务网格&#34;&gt;基于 Sidecar 的服务网格&lt;/h3&gt;
&lt;p&gt;采用双向 TLS 的最常见方法之一是基于 Sidecar 的服务网格架构。&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt; 和 &lt;a href=&#34;https://linkerd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt; 是其中最受欢迎的两个选项。&lt;/p&gt;
&lt;p&gt;从高层次上来说，与其修改应用程序以在代码中处理 TLS，不如在每个应用程序旁边部署一个小型网络代理。这个代理可以做很多事情（请查看相关项目的文档！），但对于本文而言，重要的是它们可以自动为你处理双向 TLS。这意味着你可以在不更改应用程序的情况下自动为网格中的所有工作负载之间的流量启用双向 TLS。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-sidecar-架构概述&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio Sidecar 架构概述&#34;
           src=&#34;https://cloudnativecn.com/blog/mtls-kubernetes/arch.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio Sidecar 架构概述
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;至少从我熟悉的 Istio 和 Linkerd 的角度来看，这些解决方案都能处理上面列出的&lt;a href=&#34;https://blog.howardjohn.info/posts/mtls-kubernetes/#do-it-yourself&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;棘手问题&lt;/a&gt;。特别值得注意的是迁移案例。这两个项目都会根据对等方是否支持 TLS，自动支持发送和接受明文和 TLS。完成迁移（如果可能的话）后，可以严格限定只使用双向 TLS。&lt;/p&gt;
&lt;p&gt;这种方法是 Kubernetes 中广泛部署双向 TLS 的最常见选择；我估计在生产环境中的使用率超过95%。&lt;/p&gt;
&lt;p&gt;尽管它成功地解决了很多问题，但也存在一些摩擦点。有时服务网格被认为过于复杂或资源消耗过高（CPU/内存或延迟）。许多这些担忧与服务网格的功能超出 mTLS 的范围有关；如果你只需要 mTLS，这种方法可能会显得大材小用。&lt;/p&gt;
&lt;h3 id=&#34;基于节点的-ambient-模式&#34;&gt;基于节点的 Ambient 模式&lt;/h3&gt;
&lt;p&gt;Sidecar 方法为提供与 mTLS 无关的功能增加了额外的复杂性，这促使了服务网格新架构的开发： &lt;a href=&#34;https://istio.io/latest/docs/ambient/overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambient 模式&lt;/a&gt;。在这种架构中，部署了一个每节点代理来自动处理双向 TLS。目前，只有 Istio 提供这种方法，所以我将重点介绍它。&lt;/p&gt;
&lt;p&gt;Istio Ambient 专门设计来满足“我只想要 Kubernetes 上的 mTLS”这一用例。几乎每一个设计决策都源于这一初始目标。虽然服务网格的全套功能仍然存在，但它提供了一个从“原始 Kubernetes”到“全局 mTLS”再到“全功能服务网格”的平滑过渡，详细内容可以参阅&lt;a href=&#34;https://blog.howardjohn.info/posts/flattening-curve/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我之前的文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;由于这种模式针对双向 TLS 用例的特殊化设计，Ambient 模式往往更适合并能减轻 Sidecar 方法的一些顾虑。仅使用 Ambient 模式下的 mTLS 功能时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成本大幅降低：在某些部署中，Ambient 方法的 CPU 和内存消耗可能仅为 Sidecar 方法的 1%。&lt;/li&gt;
&lt;li&gt;性能有所提高：尽管这取决于应用程序，但在某些情况下，服务网格的延迟开销可能会&lt;a href=&#34;https://a-cup-of.coffee/blog/istio/#http-benchmark&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;减少约 20 倍&lt;/a&gt;。需要注意的是，这并不意味着你的应用程序会快 20 倍，而只是减少了开销；这可能意味着你的应用程序从 1000ms 应用延迟 + 1ms 网格延迟，变为 1000ms 应用延迟 + 0.05ms 网格延迟。因此，这可能只在你的应用程序已经非常高效时才更为重要。&lt;/li&gt;
&lt;li&gt;兼容性增强：服务网格的主要优势之一是 &lt;a href=&#34;https://istio.io/latest/blog/2021/zero-config-istio/#traffic-management&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTP 流量管理&lt;/a&gt;。虽然这通常是一个很好的功能，但它也从根本上改变了功能。Ambient 模式默认不执行此操作（但允许用户选择加入）。&lt;/li&gt;
&lt;li&gt;复杂性降低：由于节点代理是为提供 mTLS 而专门设计的，因此不会有其他功能带来的附带复杂性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体而言，Ambient 模式提供了一种简单的方法，可以在不带来太多负面影响的情况下部署全局 mTLS。对于那些只想要 mTLS 的用户来说，这是一个最好的起点，同时也提供了&lt;a href=&#34;https://istio.io/latest/docs/ambient/usage/waypoint/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;逐步采用其他网格功能&lt;/a&gt;的可能性。&lt;/p&gt;
&lt;h3 id=&#34;基于-cni-的方法&#34;&gt;基于 CNI 的方法&lt;/h3&gt;
&lt;p&gt;在这些讨论中偶尔会提到的一种选项是使用基于 CNI（容器网络接口）的方法。问题是：&lt;strong&gt;目前没有 CNI 支持双向 TLS！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么为什么会提到这种方法呢？原因有以下几点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CNI（通常）实现了 &lt;code&gt;NetworkPolicy&lt;/code&gt;。虽然这不提供 TLS 的大部分特性（包括加密、身份验证、完整性和机密性），但它通常是零信任网络架构的一部分，因此经常被提及。我在另一篇文章中也强调了&lt;a href=&#34;https://blog.howardjohn.info/posts/netpol-api/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NetworkPolicy 的一些问题&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CNI 通常实现其他网络加密机制。例如，&lt;a href=&#34;https://docs.tigera.io/calico/latest/network-policy/encrypt-cluster-pod-traffic&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Calico 提供了 WireGuard&lt;/a&gt;，而 Cilium 提供了 &lt;a href=&#34;https://docs.cilium.io/en/latest/security/network/encryption-wireguard/#encryption-wg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WireGuard&lt;/a&gt; 和 &lt;a href=&#34;https://docs.cilium.io/en/latest/security/network/encryption-ipsec/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IPSec&lt;/a&gt;。虽然这些不是双向 TLS，但它们在功能上有一些重叠。虽然我认为这些往往被认为比实际更等同，但这已经超出了本文的范围——或许可以考虑写一篇文章对这些进行逐一比较。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cilium 提供了一项名为&lt;a href=&#34;https://docs.cilium.io/en/latest/network/servicemesh/mutual-authentication/mutual-authentication&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;双向认证&lt;/a&gt;的功能。这通常被称为 mTLS，因为它受到了 mTLS 的启发，并有一些重叠的想法。然而，&lt;strong&gt;这并不是双向 TLS&lt;/strong&gt;。这并不是一个语义上的细微差别：它根本不提供 TLS。因此，它属于上述非 mTLS 的选项，需要进行评估。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你的需求是“Mutual TLS”，这种方法不可行。如果你的需求更灵活，这些选项中的一些可能会满足你的需求。&lt;/p&gt;
&lt;h2 id=&#34;建议&#34;&gt;建议&lt;/h2&gt;
&lt;p&gt;总结一下：“我只想在 Kubernetes 上实现 mTLS”，我该怎么办？&lt;/p&gt;
&lt;p&gt;对于大多数用户，&lt;a href=&#34;https://blog.howardjohn.info/posts/mtls-kubernetes/#node-basedambient-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambient 模式&lt;/a&gt;可能是最合适的。这是以最小的成本、复杂度和开销，在整个集群上部署 mTLS 的最快方法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.howardjohn.info/posts/mtls-kubernetes/#sidecar-based-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Sidecar 的&lt;/a&gt;方法也是一个不错的选择，并且在业界得到了广泛应用。请记住，这些方法提供了大量超出 mTLS 的功能，这取决于你的使用场景，可能会显得大材小用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.howardjohn.info/posts/mtls-kubernetes/#do-it-yourself&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自行实现&lt;/a&gt;极具挑战性。虽然这可能适合拥有非常精确的要求和极其健壮的操作实践的组织，但这是最后的选择。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无需 Kubernetes 测试 Kubernetes 网络实现</title>
      <link>https://cloudnativecn.com/blog/ztunnel-testing/</link>
      <pubDate>Mon, 22 Jul 2024 18:46:32 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/ztunnel-testing/</guid>
      <description>&lt;p&gt;由于在开发过程中我&lt;a href=&#34;https://blog.howardjohn.info/posts/ideal-ci/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;真的不喜欢等待&lt;/a&gt;，所以在构建 Ztunnel（一个为 Istio 的新&lt;a href=&#34;https://istio.io/latest/blog/2022/introducing-ambient-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambient 模式&lt;/a&gt;设计的底层网络代理）时，我的首要任务之一便是确保测试的快速进行（包括运行和编写测试），并且易于调试。&lt;/p&gt;
&lt;p&gt;这一任务颇为棘手，因为在大多数真实场景中，Ztunnel 高度依赖 Kubernetes。虽然它能够完全独立于 Kubernetes 运行，但许多关键代码路径的行为完全不同，使得仅通过这种方式进行测试变得不可行。&lt;/p&gt;
&lt;p&gt;下图为典型的 Ztunnel 部署架构：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ztunnel-架构概览&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Ztunnel 架构概览&#34;
           src=&#34;https://cloudnativecn.com/blog/ztunnel-testing/ztunnel-architecture.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Ztunnel 架构概览
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在此架构中，用户将运行一个包含多个节点的 Kubernetes 集群。每个节点上都运行着一个 Ztunnel，配置了宿主机和每个 pod 的网络栈。&lt;/p&gt;
&lt;p&gt;此外，Ztunnel 实际上进入了每个 pod 的网络命名空间，并代表其发送/接收流量。这一点非常奇特且酷炫，但也大大增加了测试的难度！（&lt;a href=&#34;https://www.youtube.com/watch?v=cuMeEhpyH5s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;详细信息&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;加速测试&#34;&gt;加速测试&lt;/h2&gt;
&lt;p&gt;启动完整的 Kubernetes 环境、重建镜像、部署到每个节点的过程非常缓慢且难以调试。&lt;/p&gt;
&lt;p&gt;黄金标准应该是将所有操作运行在一个简单的单一二进制文件中——仅需执行 &lt;code&gt;cargo test&lt;/code&gt;。这种方式避开了复杂的设置和缓慢的重建，并使调试变得轻而易举（当然，你可以将调试器连接到正在运行的 pod，但这很麻烦）。&lt;/p&gt;
&lt;h2 id=&#34;设置网络&#34;&gt;设置网络&lt;/h2&gt;
&lt;p&gt;如果我们去除无尽的抽象层，Kubernetes pods 实际上只是几个 Linux 命名空间和挂载的组合。Docker 在这方面管理得很好，&lt;a href=&#34;https://github.com/p8952/bocker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bash&lt;/a&gt;也可以。&lt;/p&gt;
&lt;p&gt;我们特别关注的是&lt;a href=&#34;https://man7.org/linux/man-pages/man7/network_namespaces.7.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络命名空间&lt;/a&gt;，它可以实现网络栈的隔离。每个 pod 都有自己的网络命名空间，通过各种机制连接，允许与同一节点上的其他 pod、其他节点以及外部目的地通信。&lt;/p&gt;
&lt;p&gt;好消息是创建网络命名空间非常简单。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns add testing
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们的最终目标是设置一系列的网络命名空间，外观与我们在 Kubernetes 上的真实架构类似：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-所需的网络命名空间设置&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;所需的网络命名空间设置&#34;
           src=&#34;https://cloudnativecn.com/blog/ztunnel-testing/ztunnel-network-namespaces.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      所需的网络命名空间设置
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在网络命名空间之间建立连接稍微复杂一些。像 &lt;a href=&#34;https://www.cni.dev/docs/cnitool/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;cnitool&lt;/code&gt;&lt;/a&gt; 这样的工具可以帮助我们完成（它实际上执行了一些 Kubernetes 环境中用于设置网络的相同逻辑，但作为 CLI 工具），但你也可以完全手动操作。我们选择了后者。&lt;/p&gt;
&lt;p&gt;最终，我们的设置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个测试都拥有自己的网络命名空间，通过一个桥接设备（&lt;code&gt;br0&lt;/code&gt;）来促进节点之间的流量。&lt;/li&gt;
&lt;li&gt;每个节点配置了一个 &lt;code&gt;veth&lt;/code&gt; 设备。一端成为节点上的 &lt;code&gt;eth0&lt;/code&gt;，另一端连接到根命名空间中的 &lt;code&gt;br0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;每个 pod 都配置了一个 &lt;code&gt;veth&lt;/code&gt; 设备。一端成为 pod 上的 &lt;code&gt;eth0&lt;/code&gt;，另一端位于节点网络命名空间中。&lt;/li&gt;
&lt;li&gt;为每个 pod 设置路由以将流量发送到节点。&lt;/li&gt;
&lt;li&gt;为每对节点设置路由，以实现跨节点流量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-所需的网络连接设置&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;所需的网络连接设置&#34;
           src=&#34;https://cloudnativecn.com/blog/ztunnel-testing/ztunnel-network-devices.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      所需的网络连接设置
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了根命名空间/桥接设备外，这与许多现实世界中的 Kubernetes 集群的运行方式相同（在现实世界中，根命名空间是两台机器之间的物理网络）。&lt;/p&gt;
&lt;p&gt;你可以在&lt;a href=&#34;https://github.com/istio/ztunnel/blob/34fce85a6a2b2a85eb170a04096731e2ea4e0e9f/src/test_helpers/netns.rs#L194&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;找到所有细节。&lt;/p&gt;
&lt;h2 id=&#34;运行测试&#34;&gt;运行测试&lt;/h2&gt;
&lt;p&gt;一旦我们有了这些命名空间，我们仍然需要一种实际使用它们的方法。幸运的是，Linux 允许在运行时更改当前命名空间线程（这是接下来重要的内容）。这让我们建立了一个基本的帮助函数（真实的代码稍微更复杂）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;run_in_namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;namespace&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;Fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;original_namespace&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_current_namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;enter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;original_namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;enter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有了这个，我们可以轻松地从任意的“pods”或“nodes”执行代码。&lt;/p&gt;
&lt;p&gt;然而，我们仍然面临一个问题。我们的所有代码都运行在 &lt;a href=&#34;https://tokio.rs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tokio&lt;/a&gt; 异步运行时中，它会根据需要将我们的各种任务安排到物理操作系统线程上（类似于 Go 运行时的工作方式）。由于网络命名空间是线程相关的，所以当我们的任务在线程之间跳转时，这一切都会崩溃。&lt;/p&gt;
&lt;p&gt;幸运的是，Rust 给了我们比 Go 更多的关于异步运行时的灵活性——我们可以同时拥有多个！借此，我们能够构建一个能够异步执行 &lt;code&gt;run_in_namespace&lt;/code&gt;。对于我们想要执行的每个函数，我们启动一个新线程并构建一个专用的单线程异步运行时来处理它：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;async&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;async_run_in_namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;namespace&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;async&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thread&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;spawn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;||&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run_in_namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;||&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rt&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tokio&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;runtime&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Builder&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;new_current_thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;enable_all&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;block_on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们为每个命名空间运行一次这个函数，因此这里的开销是最小的。如果我们想要运行许多小函数，可以在顶层构建一个抽象来发送工作到线程以执行。&lt;/p&gt;
&lt;p&gt;我们需要的最后一件事是一种合理的方法来识别如何调用每个目的地。虽然它们都会被分配一个 IP（基于我们代码中的简单 IPAM 策略），但我们不希望每个测试都必须猜测 IP。为了处理这个问题，我们构建了一个简单的名称解析器。这就像 DNS，但简单得多：对于我们创建的每个“pod”，我们记录一个&lt;code&gt;name -&amp;gt; IP&lt;/code&gt;的映射，并允许查找 IP。&lt;/p&gt;
&lt;p&gt;将所有这些放在一起，一个简单的测试启动了3个 pods（客户端、服务器和 ztunnel）在一个单一节点上看起来像这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#[tokio::test]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;async&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simple_test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ztunnel&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;manager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;deploy_ztunnel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;DEFAULT_NODE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;await&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;manager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;workload_builder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;server&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;no&#34;&gt;DEFAULT_NODE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;await&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run_tcp_server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;manager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;workload_builder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;client&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;no&#34;&gt;DEFAULT_NODE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;await&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run_tcp_client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;manager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resolve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;server&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ... some assertions here }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;放弃权限&#34;&gt;放弃权限&lt;/h2&gt;
&lt;p&gt;上述设置效果很好，但也带来了一些问题。&lt;/p&gt;
&lt;p&gt;基本上设置的每一步都需要提升的 root 权限；这让简单的 &lt;code&gt;cargo test&lt;/code&gt; 案例的开箱即用变得乏味，通常也不可取。&lt;/p&gt;
&lt;p&gt;此外，这会在主机环境中污染大量的命名空间。虽然我们有一些清理过程，但这些并不是100%可靠，可能会导致悬挂的命名空间阻碍未来的执行。&lt;/p&gt;
&lt;p&gt;解决拥有太多命名空间的问题的方法？更多的命名空间！为此，我们需要的不仅仅是网络命名空间。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://man7.org/linux/man-pages/man7/user_namespaces.7.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;用户命名空间&lt;/a&gt; 允许我们实质上假装是 UID 0 (root)，同时实际上将其映射回我们原始的 UID。这里的力量在于，在该命名空间中，我们可以做一些本来需要 root 权限的事情——特别是创建新的网络命名空间。&lt;/p&gt;
&lt;p&gt;然而，我们不能做的一件事是修改主机-root 拥有的文件（这将是明显的权限违规）。尽管我们可能可以绕过它们，但我们在测试中使用的很多工具喜欢触摸 root 文件。这再次可以通过 &lt;a href=&#34;https://man7.org/linux/man-pages/man7/mount_namespaces.7.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mount 命名空间&lt;/a&gt; 解决，它允许我们将我们拥有的文件绑定挂载到主机-root 拥有的文件上，而不会影响命名空间外的事物。&lt;/p&gt;
&lt;p&gt;将所有这些放在一起，我们有这样的东西：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;original_uid&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 首先，进入一个新的用户命名空间。 unshare(CloneFlags::CLONE_NEWUSER).unwrap(); // 将用户命名空间中的 root 映射到我们原始的 UID File::create(&amp;#34;/proc/self/uid_map&amp;#34;).write(format!(&amp;#34;0 {original_uid} 1&amp;#34;)); // 设置一个新的网络命名空间 unshare(CloneFlags::CLONE_NEWNET).unwrap(); // 设置一个新的挂载命名空间 unshare(CloneFlags::CLONE_NEWNS).unwrap(); // 将一个文件夹在我们的每个测试目录中挂载到 /var/run/netns mount(tmp_dir.join(&amp;#34;netns&amp;#34;), &amp;#34;/var/run/netns&amp;#34;, MS_BIND); // 一个方便手动调试的好帮手信息，如果需要的话。 let pid = get_pid(); eprintln!(&amp;#34;Starting test in {tmp_dir}. Debug with `sudo nsenter --mount --net -t {pid}`&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上所述，一个技巧是，进入命名空间是按线程进行的。我们需要在生成任何额外线程之前设置这一点。&lt;/p&gt;
&lt;p&gt;Rust 实际上为我们提供了这样做的能力，但这意味着我们失去了 &lt;code&gt;#[tokio::test]&lt;/code&gt; 宏帮助。我们可以写自己的宏，但这有点痛苦。幸运的是，通过 &lt;a href=&#34;https://crates.io/crates/ctor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;链接器的花招&lt;/a&gt; 我们可以迫使我们的代码在进程执行的非常早期运行。&lt;/p&gt;
&lt;p&gt;Go 中的类似方法也有效（请参见 &lt;a href=&#34;https://github.com/howardjohn/unshare-go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我写的帮助库&lt;/a&gt;），实际上在那里是必需的，因为设置必须在 Go 运行时启动之前完成（这通常在任何用户代码运行之前很久）。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;有了所有这些设备，一个完整的测试只需要大约 200 毫秒。一切都在一个单一进程中运行，使调试变得轻而易举。所有的测试也都是完全隔离的，因此可以完全并行运行测试（包括相同的测试，用于压力测试以消除测试缺陷）。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
