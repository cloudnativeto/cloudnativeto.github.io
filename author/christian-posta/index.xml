<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Christian Posta | 云原生社区（中国）</title>
    <link>https://cloudnative.to/author/christian-posta/</link>
      <atom:link href="https://cloudnative.to/author/christian-posta/index.xml" rel="self" type="application/rss+xml" />
    <description>Christian Posta</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://cloudnative.to/author/christian-posta/avatar_hue67472dd98732a00bee80fc7b3322e12_24561_270x270_fill_q75_lanczos_center.jpg</url>
      <title>Christian Posta</title>
      <link>https://cloudnative.to/author/christian-posta/</link>
    </image>
    
    <item>
      <title>如何为 Envoy 构建一个控制面来管理集群网络流量</title>
      <link>https://cloudnative.to/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/</link>
      <pubDate>Sat, 21 Nov 2020 08:45:20 +0800</pubDate>
      <guid>https://cloudnative.to/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Guidance for Building a Control Plane to Manage Envoy Proxy at the edge, as a gateway, or in a mesh&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这篇文章我看了之后非常想翻译，为什么呢？一方面我也在学习 Envoy，并且在公司的实际项目中使用 Envoy，另一方面，我确实也在设计一个控制管理端来统一管控多个集群的所有流量，没错我说的是所有的流量管控。目前这个管理系统在内部已经在逐步使用起来了。所以翻译这篇文章，即学习 Envoy 技术，也是想做一个参考，印证我的想法是不是 OK 的，取长补短。&lt;/p&gt;
&lt;h2 id=&#34;指导在服务边缘构建控制面来管理-envoy-proxy让它作为服务网关或者在服务网格中使用&#34;&gt;指导在服务边缘构建控制面来管理 Envoy Proxy，让它作为服务网关或者在服务网格中使用&lt;/h2&gt;
&lt;p&gt;Envoy 已经成为了一个非常流行的网络组件了。Matt Klein &lt;a href=&#34;https://blog.envoyproxy.io/the-universal-data-plane-api-d15cec7a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;几年前写过一篇博文&lt;/a&gt;，就在讨论 Envoy 的动态配置 API 和它如何成为 Envoy 被采用越来越多的原因之一。他在博文中说这是“统一数据面板 API”（UDPA）。随着很多其它项目都采用 Envoy 作为其核心组件，可以毫不夸张的说 Envoy 不仅仅建立了标准 API，而且对于应用 7 层的网络解决方案来说：“Envoy 已经变成了在云原生架构下的统一数据平面”。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vlafpmj30dm07f74o_hu3616e9bfdb0d17aaf1c980a75942f7ec_15411_a7c8d0b410df016eb4219eaaa9c41d03.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vlafpmj30dm07f74o_hu3616e9bfdb0d17aaf1c980a75942f7ec_15411_714771d51150d4bf2d5cc7ed31a83221.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vlafpmj30dm07f74o_hu3616e9bfdb0d17aaf1c980a75942f7ec_15411_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vlafpmj30dm07f74o_hu3616e9bfdb0d17aaf1c980a75942f7ec_15411_a7c8d0b410df016eb4219eaaa9c41d03.webp&#34;
               width=&#34;490&#34;
               height=&#34;267&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而且，由于 Envoy 的统一数据平面 API，我们可以看到业界开发了很多针对基于 Envoy 技术设施进行配置管理的管理系统。本文将会深入讨论为 Envoy 构建一个控制平面需要什么，大家可以通过这些信息来评估什么样的基础设施最适合你的组织和场景。因为这个是一个很大的话题，作者会出一个系列文章来对此进行详细说明（后面我也会挑一些我感兴趣的文章进行翻译学习）。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://blog.envoyproxy.io/envoycon-recap-579d53576511&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EnvoyCon/KubeCon 论坛有很多非常好的讨论&lt;/a&gt;，这里好多组织都分享了他们采用 Envoy 的经验，也包括了如何构建他们自己的控制平面。下面是一些他们为什么选择自建控制平面的原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;现有的解决方案构建在不同的数据平面上，而且已经有了控制平面，需要在这里兼容 Envoy。&lt;/li&gt;
&lt;li&gt;为不包含任何开源基础设施来构建，或者使用其它的 Envoy 控制平面（比如：VMs， AWS，ECS 等）。&lt;/li&gt;
&lt;li&gt;不需要使用所有 Envoy 的特性，只是需要一部分。&lt;/li&gt;
&lt;li&gt;为了更好适配自己的工作流和工作视图而需要为 Envoy 配置开发专属领域的 API 对象模型。&lt;/li&gt;
&lt;li&gt;要线上使用，但是发现其它的控制平面并不够成熟。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vmv5i7j30go0di7a5_hu27a8aee5179c83a88e9d719b7a147aa0_24313_949277edc4b1bc2310dc6fe0b6885b37.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vmv5i7j30go0di7a5_hu27a8aee5179c83a88e9d719b7a147aa0_24313_18289fd7fdf0d0599d815cea1fc9f372.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vmv5i7j30go0di7a5_hu27a8aee5179c83a88e9d719b7a147aa0_24313_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vmv5i7j30go0di7a5_hu27a8aee5179c83a88e9d719b7a147aa0_24313_949277edc4b1bc2310dc6fe0b6885b37.webp&#34;
               width=&#34;600&#34;
               height=&#34;486&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然而，仅仅因为有些早期使用者构建了他们自己的控制平面，这并不意味着你也应该做这样的事情。首先在去年中很多为 Envoy 开发的控制平面已经相当成熟了，所以你应该在决定要重新开发另外一个控制平面之前先来研究一下这些已经存在的。其次，正如 Datawire 的人们发现，并且 Daniel Bryant 最近也发文章说，为 Envoy 构建一个控制平面并不是那么容易的。&lt;/p&gt;
&lt;p&gt;我参与开发几个为 Enovy 构建控制平面的开源项目。比如，Gloo 是一个功能性网关，它可以作为强大的 Kubernetes 接入服务，API 网关，或者作为从单体服务到微服务过度的功能网关。Gloo 有一个针对 Envoy 的控制平面，它可以作为我这个系列文章的例子，来说明如何在控制平面上按照需求来抽象设计，以实现插件管理和扩展性管理。其它可以参考的已经实现的控制平面如 istio 和 &lt;a href=&#34;https://github.com/heptio/contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heptio Contour&lt;/a&gt;，这些也是贯穿我这个系列文章中的好例子。如果你确定要自己开发控制平面，那么除了这些，你还可以参考其它一些已经存在的控制平面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vly994j31200a875u_hu166d8c69cfacf573deb3d9da866b69e2_48218_0dd4e56181f4403bb8b5aea30b4b064c.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vly994j31200a875u_hu166d8c69cfacf573deb3d9da866b69e2_48218_f3c4774eb24a1224d6e7e2750d0e9837.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vly994j31200a875u_hu166d8c69cfacf573deb3d9da866b69e2_48218_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vly994j31200a875u_hu166d8c69cfacf573deb3d9da866b69e2_48218_0dd4e56181f4403bb8b5aea30b4b064c.webp&#34;
               width=&#34;760&#34;
               height=&#34;205&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个系列文章中，我们将会关注以下一些关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用一种机制可以动态更新 Envoy 的路由，服务发现和其它配置。&lt;/li&gt;
&lt;li&gt;识别使用哪些组件来构成你的控制平面，包括了后端存储，服务发现 API，安全组件等等。&lt;/li&gt;
&lt;li&gt;根据场景和团队组织以最合适的方式建立任意制定区域的配置对象和 API。&lt;/li&gt;
&lt;li&gt;思考如何在需要的地方以最好方式嵌入控制平面。&lt;/li&gt;
&lt;li&gt;部署各种控制平面组件的方式。&lt;/li&gt;
&lt;li&gt;思考如何测试控制平面。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要开始这一系列的讨论，我们首先来看看如何在 Envoy 运行时，使用 Envoy 的动态配置 API 来更新 Envoy，以处理拓扑和部署中的变更。&lt;/p&gt;
&lt;h2 id=&#34;使用-envoy-的-xds-api-动态配置-envoy&#34;&gt;使用 Envoy 的 xDS API 动态配置 Envoy&lt;/h2&gt;
&lt;p&gt;在 Envoy 之上构建构控制平面的主要方便支持处在于它的数据平面 API。有了数据平面 API，我们可就可以动态的配置 Envoy 的大多数重要运行时设置。通过 xDS API 进行的 Envoy 配置是被设计为最终一致性的，没有一种方法可以对集群中的所有代理进行原子性的更新。当控制平面上有配置更新时，它就通过 xDS API 让数据平面代理都可以获取到，每个代理都是相互独立的来获取应用这些配置。&lt;/p&gt;
&lt;p&gt;下面是我们可以通过 xDS 动态配置 Envoy 的部分运行时模型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/listeners/lds#config-listeners-lds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;监听发现服务（LDS）API&lt;/a&gt; - LDS 用于下发服务监听的端口。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/api-v2/api/v2/eds.proto#envoy-api-file-envoy-api-v2-eds-proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;终端发现服务（EDS）API&lt;/a&gt;- EDS 用户服务发现。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/http_conn_man/rds#config-http-conn-man-rds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;路由发现服务（RDS）API&lt;/a&gt;- RDS 用于流量路由决策。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/cluster_manager/cds#config-cluster-manager-cds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;集群发现服务（CDS）&lt;/a&gt;- CDS 用于可以路由流量过去的后端服务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/secret&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;密钥发现服务（SDS）&lt;/a&gt; - SDS 用户分发密钥（证书和密钥）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vnd41kj30p00gmjwe_huba43c03e627f7eba547a3ce827b9cfa2_47289_8dc9ed2f916d2a6a5ac718e84ebd1d35.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vnd41kj30p00gmjwe_huba43c03e627f7eba547a3ce827b9cfa2_47289_46801a894460f2556c36691879f4af90.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vnd41kj30p00gmjwe_huba43c03e627f7eba547a3ce827b9cfa2_47289_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vnd41kj30p00gmjwe_huba43c03e627f7eba547a3ce827b9cfa2_47289_8dc9ed2f916d2a6a5ac718e84ebd1d35.webp&#34;
               width=&#34;760&#34;
               height=&#34;505&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些 API 使用 proto3 的 Protocol Buffer 来定义的，并且已经有一些相关实现了，可以提供大家在构建自己的控制平面时参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/envoyproxy/go-control-plane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go-control-plane&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/envoyproxy/java-control-plane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;java-control-plane&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然每个 xDS（LDS/EDS/RDS/CDS/SDS，这些统称xDS）都是可以动态可配置的，但是这并不意味着你必须动态配置所有内容。你可以组合适应，区分静态配置和动态配置。例如，要通过配置实现一种类型的服务发现：希望终端是动态的，但是集群在部署的时候就是已经知道路由信息了，所以你可以使用 Envoy 中的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/api-v2/api/v2/eds.proto#envoy-api-file-envoy-api-v2-eds-proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Endpoint Discovery Service&lt;/a&gt; 来静态的定义集群的配置。如果在部署的时候你不确定是那个上游集群，那你可以使用&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/cluster_manager/cds#config-cluster-manager-cds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cluster Discovery Service&lt;/a&gt;来动态的配置发现上游。关键是你可以构建一个工作流和处理流程来静态的配置你需要的部分，而且可以使用动态 xDS 服务在运行时发现你需要的部分。为什么有不同的控制平面实现，其中一个原因就是并不是所有人都有一个完全动态和可替代的环境（这个环境下所有的配置都应该是动态的），这点几乎不可能。根据现有条件的约束和可用工作流，要为你的系统采取合适级别的动态配置，而不是全动态配置。&lt;/p&gt;
&lt;p&gt;在 Gloo 的实现中，我们基于 go-control-plane 的实现来构建控制平面，实现了 xDS API 到 Envoy 的动态配置。Istio 和 Heptio Contour 也是使用这种方式。这个控制平面的 API 使用 gRPC streaming 实现，并且留了实现接口，所以我们在实现的时候只需要实现这些接口就可以了。这种方式可以以非常高效的方式把 Envoy 数据平面 API 集成到控制平面中。&lt;/p&gt;
&lt;p&gt;gRPC streaming 方式并不是唯一的更新 Envoy 配置的方法。在&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.5.0/api-v1/api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 早期版本中的 xDS API&lt;/a&gt;，轮询是唯一检测是否有新配置可用的方式。虽然这也是接受的，并且也符合配置更新最终一致性的原则，但是在网络和计算使用上还是不够高效。也比较困难去调整优化轮询配置以减少资源浪费。&lt;/p&gt;
&lt;p&gt;最后，一些 Envoy 管理系统的实现采取生成&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/v2_overview#static&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;静态 Envoy 配置文件&lt;/a&gt;和给 Envoy 周期性的覆盖写入磁盘上的配置文件，再执行&lt;a href=&#34;https://blog.envoyproxy.io/envoy-hot-restart-1d16b14555b5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 进程的热重启&lt;/a&gt;。在高度动态环境中（像 Kubernetes，实际上任何短暂的计算平台都算），管理这种文件的生成，传递，热重启等等会显得非常笨重。Envoy 最初就是在这样操作的（Lyft公司创建这个项目是就是这样），但是它逐步发展到现在的 xDS API了。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Gloo 团队相信使用 gRPC streaming 和 xDS API 来实现对 Envoy 的动态配置和控制是一种比较好的方式。同样，并不是所有的 Envoy 配置都应该是动态的，尤其是你不需要动态配置的内容。但是如果你是在一个高度动态的环境（比如在 Kubernetes 中），动态配置 Envoy 就很关键了。其它的环境或许也有这样的需要。不管怎么样，动态配置使用 gRPC streaming API 是最理想的，主要有以下一些好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事件驱动配置更新；在控制平面中配置会在可用的时候下发到 Envoy。&lt;/li&gt;
&lt;li&gt;不需要轮询配置变化了。&lt;/li&gt;
&lt;li&gt;不需要热重启 Envoy。&lt;/li&gt;
&lt;li&gt;不会中断流量。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;下一步&#34;&gt;下一步&lt;/h2&gt;
&lt;p&gt;这是系列文章的第一部分，我们只是建立了为 Envoy 构建控制平面的基本概念，简述了 xDS API 和对 Envoy 动态配置不同的考虑。在下一节，会在几天后发布，将会把控制面分解成为可部署的组件，确定你需要的组件，特定领域对象会是什么样子？以及对控制平面扩展插件的思考。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用了 Service Mesh 后我还需要 API 网关吗</title>
      <link>https://cloudnative.to/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/</link>
      <pubDate>Fri, 07 Feb 2020 10:42:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.christianposta.com/microservices/do-i-need-an-api-gateway-if-i-have-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;如文章标题所示，本文通过对 Service Mesh 技术和 API 网关的对比，着重分析了两者的功能重合点和分歧点，解答了开发者的困惑，为如果进行技术选型和落地提供了指导思路。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;这篇文章也许无法打破缠绕在 API 网关和服务网格周围的喧嚣。即便已经是 2020 年了，围绕这些话题仍然会存在大量的疑虑。我撰写此文是为了给出真实而具体的解释，以帮助大家理清它们之间的差异、重叠以及适用场景。如果你不同意我觉得我在添乱，或者想请我喝杯啤酒，欢迎随时在 Twitter 上@我（@christianposta）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;第一个曝光：&lt;/strong&gt; 我在 &lt;a href=&#34;https://solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt; 这家公司工作，公司的业务聚焦于今天我们要讨论的主题。我提前说明一下以免你会有“你的观点是有偏见的”的反应。每个人的观点都有偏见。但可以肯定的是，我在 Solo.io 工作是因为我想看到这些想法被付诸实施并推向市场，而不是与之相反。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个曝光：&lt;/strong&gt; 我正在写一本有关服务网格的书，名为《Istio in Action》，这花了我很多时间。在本文中，不可否认我是站在 Istio 的角度来讨论“服务网格”的，但如果我指的是更普遍的服务网格的概念时，我会特别指出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;为什么会有另一个关于此话题的博客&#34;&gt;为什么会有另一个关于此话题的博客？&lt;/h2&gt;
&lt;p&gt;有大量关于当前主题的文章。我们看过&lt;a href=&#34;https://aspenmesh.io/api-gateway-vs-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;“API 网关用于南北流量，而服务网格用于东西流量”&lt;/a&gt;。还有人写了&lt;a href=&#34;https://medium.com/microservices-in-practice/service-mesh-vs-api-gateway-a6d814b9bf56&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;“API 网关用于管理业务功能，而服务网格用于服务到服务通信”&lt;/a&gt;。&lt;a href=&#34;https://blog.getambassador.io/api-gateway-vs-service-mesh-104c01fa4784&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 网关具有服务网格不具备的特定功能&lt;/a&gt;，其中一些可能不再适用。另一方面，有些人&lt;a href=&#34;https://developer.ibm.com/apiconnect/2018/11/13/service-mesh-vs-api-management/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;更接近我的思考方式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;然而，市场中仍存在明显的困惑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我也希望看到人们如何看待不同方法之间权衡的严肃讨论。例如，服务网格和 API 网关之间的职责/主张存在重叠。人们对选择感到困惑和不知所措。&lt;/p&gt;
&lt;p&gt;— Andrew Clay Shafer 雷启理 （@littleidea）&lt;/p&gt;
&lt;p&gt;June 12, 2019&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;困惑是什么&#34;&gt;困惑是什么&lt;/h2&gt;
&lt;p&gt;大约一年前，我写了一篇&lt;a href=&#34;https://blog.christianposta.com/microservices/api-gateways-are-going-through-an-identity-crisis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关于 API 网关身份危机&lt;/a&gt;的文章，评估了 API 管理 Kubernetes Ingress 和 API 网关（带有相关定义）的差异。在那篇文章的最后，我试图解释服务网格是如何应对这些功能的，但是没有详细说明它们如何不同，以及什么时候使用它们。我强烈推荐&lt;a href=&#34;https://blog.christianposta.com/microservices/api-gateways-are-going-through-an-identity-crisis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;阅读这篇文章&lt;/a&gt;，因为在某些方面，它是“第一部分”，本文作为“第二部分”。&lt;/p&gt;
&lt;p&gt;我认为产生混淆的原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术使用上存在重叠（代理）&lt;/li&gt;
&lt;li&gt;功能上存在重叠（流量控制，路由，指标收集，安全/策略增强等）&lt;/li&gt;
&lt;li&gt;“服务网格”可替代 API 管理的理念&lt;/li&gt;
&lt;li&gt;服务网格能力的误解&lt;/li&gt;
&lt;li&gt;一些服务网格有自己的网关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后一点尤其使人困惑。&lt;/p&gt;
&lt;p&gt;如果服务网格仅仅是针对东西流量（边界内），那么为什么有一些服务网格，如 Istio 所说，&lt;a href=&#34;https://istio.io/docs/reference/config/networking/gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;有一个 Ingress 网关&lt;/a&gt;针对南北流量（并且是网格的一部分）？例如下面来自 Istio Ingress 网关的文档：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网关描述了一个运行在网格边缘的负载均衡器，它接收传入或传出的 HTTP/TCP 连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们的 API 不是 HTTP 吗？如果我们通过 Istio 的网关将 HTTP 请求引入集群/网格中（顺便说一句，这基于强大的 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 代理&lt;/a&gt; 项目），这还不够吗？&lt;/p&gt;
&lt;h2 id=&#34;假设&#34;&gt;假设&lt;/h2&gt;
&lt;p&gt;当我们提到“服务网格”时，将假定是指 Istio 和 Istio 的网关。选择这个场景是因为它最能说明重叠和混淆。其他服务网格&lt;a href=&#34;https://www.consul.io/docs/connect/mesh_gateway.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;也有网关&lt;/a&gt;，而有些还&lt;a href=&#34;https://linkerd.io/2/tasks/using-ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;没有显式网关&lt;/a&gt;。当然你的情况也许会有所不同。&lt;/p&gt;
&lt;h2 id=&#34;它们的重叠在哪里&#34;&gt;它们的重叠在哪里&lt;/h2&gt;
&lt;p&gt;业务的第一个步骤是识别 API 网关和服务网格功能看上去重叠的区域。两者都处理应用程序流量，所以重叠应该不足为奇。下面的清单列举了一些重叠的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遥测数据收集&lt;/li&gt;
&lt;li&gt;分布式追踪&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;TLS 终止/开始&lt;/li&gt;
&lt;li&gt;JWT 校验&lt;/li&gt;
&lt;li&gt;请求路由&lt;/li&gt;
&lt;li&gt;流量切分&lt;/li&gt;
&lt;li&gt;金丝雀发布&lt;/li&gt;
&lt;li&gt;流量镜像&lt;/li&gt;
&lt;li&gt;速率控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好吧，它们确实有重叠。那么你需要一个？还是两个？还是都不需要？&lt;/p&gt;
&lt;h2 id=&#34;它们的分叉点在哪里&#34;&gt;它们的分叉点在哪里&lt;/h2&gt;
&lt;p&gt;服务网格运行在比 API 网关更低的级别，并在架构中所有单个服务上运行。服务网格为服务客户提供关于架构拓扑的“更多细节”（包括客户端负载均衡、服务发现、请求路由），应该实现的弹性机制（超时、重试、熔断），应该收集的遥测（度量、跟踪）和参与的安全流（mTLS、RBAC）。所有这些实现细节通常由某个 sidecar（请考虑 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;）提供给应用程序，但它们不必这样做。请参阅我在 ServiceMeshCon 有关服务网格数据平面演化的演讲。&lt;/p&gt;
&lt;p&gt;下面的话引自 &lt;a href=&#34;https://blog.christianposta.com/microservices/api-gateways-are-going-through-an-identity-crisis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 身份危机&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务网格的目标是通过在 L7 上透明地操作来解决任何服务/应用程序中列举的问题。换句话说，服务网格希望接入到服务中（而不是到服务中编写代码）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt; 服务网格为服务/客户端提供了更多关于架构其余部分实现的细节/保真度。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/mesh-details.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;另一方面，API 网关则扮演着不同的角色：“抽象细节”和解耦实现。API 网关提供了跨应用程序架构中所有服务的内聚抽象——作为一个整体，为特定的 API 解决了一些边缘/边界问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/abstract-api.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;无论服务网格是否存在，API 网关都存在于应用程序/服务之上，并为其他部分提供抽象。它们做的事情包括聚合 API、抽象 API 和用不同的实现方式暴露它们，并基于用户在边缘添加更复杂的零信任安全策略。应用程序架构边界上的问题与边界内的问题不同。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/infra-layers.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;边界问题与服务到服务的挑战不同&#34;&gt;边界问题与服务到服务的挑战不同&lt;/h2&gt;
&lt;p&gt;在微服务/云原生架构的边界上，API 网关提供了服务网格无法在同等程度上解决的三个主要能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;边界解耦&lt;/li&gt;
&lt;li&gt;严格控制数据的进出&lt;/li&gt;
&lt;li&gt;桥接安全信任域&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们看看：&lt;/p&gt;
&lt;h3 id=&#34;边界解耦&#34;&gt;边界解耦&lt;/h3&gt;
&lt;p&gt;API 网关的核心功能是为边界外的客户端提供稳定的 API 接口。从 &lt;a href=&#34;https://microservices.io/book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chris Richardson 的微服务模式一书&lt;/a&gt;中，我们可以将“API 网关模式”改写为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;显式地简化一组 API / 微服务的调用&lt;/p&gt;
&lt;p&gt;为一组特定的用户、客户端或消费者模拟“应用程序”的内聚 API。&lt;/p&gt;
&lt;p&gt;这里的关键是 API 网关，当它实现时，它将作为应用程序架构的单一入口点，成为客户端的 API&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来自 &lt;a href=&#34;https://blog.christianposta.com/microservices/api-gateways-are-going-through-an-identity-crisis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 网关身份危机&lt;/a&gt; 一文中 API 网关的实现案例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io Gloo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://spring.io/projects/spring-cloud-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud Gateway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Netflix/zuul&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix Zuul&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://strongloop.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM-Strongloop Loopback/Microgateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从功能上看，API 网关需要支持什么？企业在现实的用例中会看到哪些需要 API 网关（服务网格不太适合）的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求/响应转换&lt;/li&gt;
&lt;li&gt;应用协议转换如 REST/SOAP/XSLT&lt;/li&gt;
&lt;li&gt;错误/速率定制响应&lt;/li&gt;
&lt;li&gt;直接响应&lt;/li&gt;
&lt;li&gt;对 API/代理管道的精确控制&lt;/li&gt;
&lt;li&gt;API 聚合/分组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们挨个来看。&lt;/p&gt;
&lt;h4 id=&#34;请求响应传输&#34;&gt;请求/响应传输&lt;/h4&gt;
&lt;p&gt;作为在 API 网关上暴露 API 的一部分，您可能希望隐藏后端 API 实现的细节。这可能是改变请求内容、删除/添加标头、将标头放入正文的一些组合，反之亦然。当后端服务对 API 进行更改时，或者当客户端不能像提供方那样快速更新时，这提供了一个很好的从客户端解耦的点。&lt;/p&gt;
&lt;h4 id=&#34;应用协议转换&#34;&gt;应用协议转换&lt;/h4&gt;
&lt;p&gt;许多企业在技术上进行了投入，如基于 HTTP、SOAP 的 XML，或基于 HTTP 的 JSON。他们可能希望使用更严格的、特定于客户端的 API 来公开这些 API，并继续保持互操作性。此外，服务提供者可能希望利用新的 RPC 机制（如 gRPC）或流协议（如 rSocket）。&lt;/p&gt;
&lt;h4 id=&#34;错误速率定制响应&#34;&gt;错误/速率定制响应&lt;/h4&gt;
&lt;p&gt;转换来自上游服务的请求是 API 网关的一项重要功能，定制来自网关本身的响应也是如此。采用 API 网关的虚拟 API 进行请求/响应/错误处理的客户端也希望网关自定义其响应以适应该模型。&lt;/p&gt;
&lt;h4 id=&#34;直接响应&#34;&gt;直接响应&lt;/h4&gt;
&lt;p&gt;当客户端（受信任的或恶意的）请求不可用的资源，或由于某种原因被阻止上行时，最好能够终止代理并使用预先屏蔽的响应返回。&lt;/p&gt;
&lt;h4 id=&#34;对-api代理管道的精确控制&#34;&gt;对 API/代理管道的精确控制&lt;/h4&gt;
&lt;p&gt;没有一种方法可以满足所有代理的期望。API 网关应该能够改变应用其功能的顺序（速率限制、authz/n、路由、转换等），并在出现问题时提供一种调试方法。&lt;/p&gt;
&lt;h4 id=&#34;api-聚合&#34;&gt;API 聚合&lt;/h4&gt;
&lt;p&gt;在多个服务上公开一个抽象常常伴随着将多个 API 混合成一个 API 的期望。类似于 GraphQL 的东西可以满足这个需求。&lt;/p&gt;
&lt;p&gt;正如您所看到的，在客户端和提供服务者之间提供一个强大的解耦点涉及的不仅仅是允许 HTTP 通信进入集群这么简单。&lt;/p&gt;
&lt;h2 id=&#34;严格控制什么可以进入离开服务&#34;&gt;严格控制什么可以进入/离开服务&lt;/h2&gt;
&lt;p&gt;API 网关的另一个重要功能是“控制”哪些数据/请求允许进入应用架构，哪些数据/响应允许流出。这意味着，网关需要对进入或发出的请求有深入的理解。例如，一个常见的场景是 Web 应用程序防火墙防止 SQL 注入攻击。另一种是“数据丢失预防”技术，用于在请求 PCI-DSS/HIPPA/GDPR 时阻止 SSN 或 PII 被返回。边界是帮助实现这些策略的天然位置。&lt;/p&gt;
&lt;p&gt;同样，定义和实施这些功能并不像允许 HTTP 通信流进入集群那么简单。&lt;/p&gt;
&lt;h2 id=&#34;定制安全桥接信任域&#34;&gt;定制安全/桥接信任域&lt;/h2&gt;
&lt;p&gt;API 网关提供的最后一个主要功能是边缘安全性。这涉及到向存在于应用程序架构之外的用户和服务提供身份和范围策略，从而限制对特定服务和业务功能的访问。这与前面的部分相关。&lt;/p&gt;
&lt;p&gt;一个常见的例子是能够绑定到 OAuth/SSO 流，包括 Open ID Connect。这些“标准”的挑战在于，它们可能没有得到充分实施，也可能没有得到正确实施。API 网关需要一种方法来灵活地适应这些环境以及提供定制。&lt;/p&gt;
&lt;p&gt;在许多企业中，已经存在身份/信任/认证机制，API 网关的很大一部分是为了向后兼容而进行本地集成。虽然出现了 &lt;a href=&#34;https://spiffe.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFEE&lt;/a&gt; 这样的新标准，但企业需要一段时间才能落地，与此同时，API 网关（甚至是针对在其下一代架构上运行的应用程序的网关）是一个艰难的要求。同样，你可以检视并说这也和上面提到的变换/解耦点有关。&lt;/p&gt;
&lt;h2 id=&#34;怎样落地其中一个另一个两者两者都不&#34;&gt;怎样落地其中一个/另一个/两者/两者都不？&lt;/h2&gt;
&lt;p&gt;在之前的一篇博客中，我概述了一些&lt;a href=&#34;https://blog.christianposta.com/challenges-of-adopting-service-mesh-in-enterprise-organizations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;采用这种技术的挑战（API 网关和服务网格）&lt;/a&gt;，并给出了关于如何最好地应用这种技术的提示。&lt;/p&gt;
&lt;p&gt;重申一下：从边缘开始。这是架构中熟悉的一部分。也要考虑选择最合适的。自从我们引入了云基础设施和云原生应用架构以来，假设（编者注：文章开始所说的假设）已经发生了变化。例如，如果您打算采用 Kubernetes，我强烈建议您考虑使用从头开始构建的应用程序网络技术（例如，检查 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 代理&lt;/a&gt;和已经被提升和转移的应用程序网络技术）。例如，在 &lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;，我们已经为此建立了一个名为 Gloo 的开源项目。&lt;/p&gt;
&lt;p&gt;你需要一个服务网格吗？如果您正在部署到云平台，有多种类型的语言/框架来实现您的工作负载，并构建一个微服务架构，那么您可能需要一个。选择也很多。我做过各种比较和对比的演讲，最近的是 &lt;a href=&#34;https://www.slideshare.net/ceposta/navigating-mesh-istio-connect-and-linkerd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OSCON 演讲&lt;/a&gt;。请随意&lt;a href=&#34;http://twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参考&lt;/a&gt;并找到最合适你的。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;是的，API 网关在功能上与服务网格有重叠。它们在使用的技术方面也可能有重叠（例如，Envoy）。但是，它们的角色有很大的不同，理解这一点可以在部署微服务架构和发现无意的假设时为您省去很多麻烦。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>企业组织中采用服务网格的挑战</title>
      <link>https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/</link>
      <pubDate>Tue, 22 Oct 2019 19:25:19 +0800</pubDate>
      <guid>https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.christianposta.com/challenges-of-adopting-service-mesh-in-enterprise-organizations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;本文作者介绍了企业组织采用服务网格面临的哪些挑战，建议企业应该从数据平面开始逐步推进，从了解它、熟悉它、再到扩大规模使用它，并且以介绍其演讲的幻灯片为切入点介绍了架构演进的步骤。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;最近，我写了&lt;a href=&#34;https://dzone.com/trendreports/migrating-to-microservices-2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一篇&lt;/a&gt;关于在企业组织中采用服务网格的具有哪些挑战的文章，这篇文章是为DZone及其迁移到微服务的报告撰写的。在这篇文章中，我们首先要解决的问题之一是“你是否应该沿着采用服务网格的道路走下去”，我是这么说的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先回答“不”。如果您刚刚开始使用微服务架构和少量的服务，请确保您首先准备好了基础部分。微服务及其相关的基础设施是一种优化方式，可以让您更快的变更应用程序。在没有服务网格的情况下，您可以朝着更快的方向前进。你甚至可能想要一些服务网格带来的好处，而不是去关注它所有的复杂性。那么，请看看类似Gloo的产品，一个建立在Envoy代理上的API网关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为在当前时刻，这是一个非常重要的考虑，有以下两大原因:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总的来看，服务网格的实现还没有准备好投入生产。&lt;/li&gt;
&lt;li&gt;全部投入(all-in)到一个服务网络的复杂性仍然很高。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这并不意味着没有团队成功地使用了服务网格，或者您应该远离它。但是，我确实认为您应该建立这样的能力，当您真正准备好了并且可以从中获益的时候，最终能成功地将服务网格引入。例如，在报告中，我列出了您&lt;strong&gt;可能想要使用&lt;/strong&gt;服务网格的原因:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨多个集群部署大量微服务&lt;/li&gt;
&lt;li&gt;容器/k8s和虚拟机的混合部署&lt;/li&gt;
&lt;li&gt;用于构建服务的语言的异构部署&lt;/li&gt;
&lt;li&gt;网络可观测性的不完整和不一致视图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即使有了以上这些理由，你依然会面临这些挑战:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择哪一个服务网格产品？&lt;/li&gt;
&lt;li&gt;谁来做技术支持？&lt;/li&gt;
&lt;li&gt;单集群的多租户问题&lt;/li&gt;
&lt;li&gt;缺乏多集群的管理方法&lt;/li&gt;
&lt;li&gt;已有服务如何适配（sidecar的生命周期、竞态条件等等）&lt;/li&gt;
&lt;li&gt;开发人员与运维人员的界限在哪里&lt;/li&gt;
&lt;li&gt;非容器环境/混合环境&lt;/li&gt;
&lt;li&gt;中心化 vs 去中心化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过我在&lt;a href=&#34;https://blog.christianposta.com/moving-on-from-red-hat/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat&lt;/a&gt;和现在&lt;a href=&#34;https://blog.christianposta.com/career/new-adventure-starts-at-solo-io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;加起来两年以上的工作，我一直在帮助人们解决那些棘手的问题(顺便说一句，如果你想交谈/需要这些方面的帮助，可以通过&lt;a href=&#34;http://twitter.com/christianposta?lang=en&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt;联系我)。但有一件我从我们的客户/用户一直观察到，并且持续一段时间提出建议，那就是你采用服务网格的第一步，应该总是先使用在一定程度上（自行）隔离的数据平面技术，要了解它是如何工作的，如何实施，如何调试等等。&lt;/p&gt;
&lt;p&gt;例如，在我最近做的一次演讲中，我说过要从Envoy（Envoy是许多服务网格实现的底层数据平面技术）开始。PPT如下:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-start-slow-slide&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;start-slow-slide&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/start-slow-slide_hu41c7057337bdf8947651db183d6af729_314126_f08e1a94e7fbede4768690d136c6e59c.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/start-slow-slide_hu41c7057337bdf8947651db183d6af729_314126_287b5dddfe44dc31432b27f3bbffce53.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/start-slow-slide_hu41c7057337bdf8947651db183d6af729_314126_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/start-slow-slide_hu41c7057337bdf8947651db183d6af729_314126_f08e1a94e7fbede4768690d136c6e59c.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      start-slow-slide
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从架构的角度来看，它可能是这样的:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-single-gateway&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;single-gateway&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/single-gateway_huae96d8327c213fa8a8d0a4bbc67dab51_440393_70af179684f223dd0f426c52cf0f2cbd.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/single-gateway_huae96d8327c213fa8a8d0a4bbc67dab51_440393_2abc4f92a40725efa7bb66d42edff4e0.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/single-gateway_huae96d8327c213fa8a8d0a4bbc67dab51_440393_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/single-gateway_huae96d8327c213fa8a8d0a4bbc67dab51_440393_70af179684f223dd0f426c52cf0f2cbd.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      single-gateway
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当然，如果你要使用Envoy，我&lt;a href=&#34;https://medium.com/solo-io/getting-started-with-a-service-mesh-starts-with-a-gateway-96384deedca2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;建议从Gloo&lt;/a&gt;开始，这基本上是一个&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;具有edge与API网关能力的企业版Envoy&lt;/a&gt;，并且很好地植入了服务网格。一旦你有了它，对它熟练使用，那么你就会准备好增加它的使用，甚至可能通过代理的分层引入一些隔离:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-multi-tier-gw&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;multi-tier-gw&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/multi-tier-gw_hu48e3294b012b96a9599800021aa9a1bc_515191_240a6b31d05afd00d64c89ac5e7f2b8a.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/multi-tier-gw_hu48e3294b012b96a9599800021aa9a1bc_515191_09149a77fbf2dff50528dcc7e4f855d2.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/multi-tier-gw_hu48e3294b012b96a9599800021aa9a1bc_515191_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/multi-tier-gw_hu48e3294b012b96a9599800021aa9a1bc_515191_240a6b31d05afd00d64c89ac5e7f2b8a.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      multi-tier-gw
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来的方法是将网关推入到应用架构中。我们看到我们的用户在每个应用程序边界采用一个网关的方法，开始有了一个网格的“感觉”，但在应用程序引入了一些结构(例如，&lt;a href=&#34;https://medium.com/solo-io/api-gateways-are-going-through-an-identity-crisis-d1d833a313d7&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API网关模式&lt;/a&gt;)。我开始称之为“waypoints”架构。就像飞行员使用航路点（waypoints）来指导他们的飞行计划一样，这些网关为您的应用架构增加了结构，同时解决了诸如安全性和API解耦的南北通信问题，同时为成功采用服务网格奠定了基础。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-bc-gw&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;bc-gw&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/bc-gw_hua2b7641dacb412fc60d8a4f5ba249d94_532778_73290757d39d4e2f998b402f3c1dd54f.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/bc-gw_hua2b7641dacb412fc60d8a4f5ba249d94_532778_39ce87fd69dc3a86b8688329a9ab9083.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/bc-gw_hua2b7641dacb412fc60d8a4f5ba249d94_532778_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/bc-gw_hua2b7641dacb412fc60d8a4f5ba249d94_532778_73290757d39d4e2f998b402f3c1dd54f.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      bc-gw
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，您可以开始在应用程序中引入独立于边界的服务网格代理，以解决棘手的但恰恰是服务网格技术最擅长解决的service-to-service通信挑战:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-push-down-gw&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;push-down-gw&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/push-down-gw_hu9d6a7c9431c187f2ad5e0e5d61658726_608097_e8fa79452386cd054ac5c95cce7d311c.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/push-down-gw_hu9d6a7c9431c187f2ad5e0e5d61658726_608097_3596b05dceb062b4d1f227b433314054.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/push-down-gw_hu9d6a7c9431c187f2ad5e0e5d61658726_608097_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/push-down-gw_hu9d6a7c9431c187f2ad5e0e5d61658726_608097_e8fa79452386cd054ac5c95cce7d311c.webp&#34;
               width=&#34;760&#34;
               height=&#34;433&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      push-down-gw
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里重要的部分是网关，并且仍然有非常有用的用途！它们向应用架构中添加结构和路径点，同时在需要的地方将某些实现细节与其他服务分离并隐藏起来。在很多方面，这都遵循了DDD有界上下文模型，网关提供了一个“反腐败”层。否则，如果你只是把所有的服务都当作“伙伴”，你就会开始坚定地迈向死星:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deathstar&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;deathstar&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/deathstar_hu2d45f23c61ea6542ffc656140423a2ca_1068805_54a216ce336a4adc096dbf896adb76e9.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/deathstar_hu2d45f23c61ea6542ffc656140423a2ca_1068805_8fb8c1c32c67b380429d5f774ee4c888.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/deathstar_hu2d45f23c61ea6542ffc656140423a2ca_1068805_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/deathstar_hu2d45f23c61ea6542ffc656140423a2ca_1068805_54a216ce336a4adc096dbf896adb76e9.webp&#34;
               width=&#34;760&#34;
               height=&#34;433&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      deathstar
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;希望这篇文章有助于您奠定一个成功的方法，通过小范围使用服务网格，然后逐渐缓慢扩展有意义的各个地方，并且你的应用程序可以从服务网格架构中获益。否则，您将承担同时引入太多复杂性的风险，这将违背您实现应用程序和基础设施现代化的意图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为Envoy构建控制面指南第2部分：识别组件</title>
      <link>https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/</link>
      <pubDate>Fri, 28 Jun 2019 10:41:16 +0800</pubDate>
      <guid>https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-for-envoy-identify-components/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;编者按&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文介绍如何为 Envoy 构建控制面指南的第2部分：识别控制平面的各个组件。对实施Envoy控制平面需要了解的基础知识很有帮助。也算是Envoy的概念介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这个系列文章的前一篇&lt;/a&gt;中，我们浏览了Envoy动态配置对于在云原生环境中运行Envoy是多么的重要。在这篇文章中，我们来一起看看为了支持控制平面，我们需要如何协调各个组件。&lt;/p&gt;
&lt;p&gt;由于操作环境的变化很大，因此为Envoy实施控制平面所需的组件也是如此。例如，在一个极端情况下，如果你需要构建时静态生成Envoy文件并发送给Envoy的需求，你需要以下组件来满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模板引擎&lt;/li&gt;
&lt;li&gt;数据存储/ VCS，用于输入模板的值&lt;/li&gt;
&lt;li&gt;任何特定于服务的配置，可能/可能不与服务/应用程序一起存储&lt;/li&gt;
&lt;li&gt;一个将各个部分组合在一起的编排器&lt;/li&gt;
&lt;li&gt;一种将这些传递给Envoy的方法&lt;/li&gt;
&lt;li&gt;一种触发配置文件重新加载/热重启的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一方面，如果您选择使用gRPC流式xDS实现，则需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心xDS服务接口和实现&lt;/li&gt;
&lt;li&gt;用于处理向服务注册表注册/取消注册服务的组件&lt;/li&gt;
&lt;li&gt;服务注册表&lt;/li&gt;
&lt;li&gt;描述您的Envoy配置的抽象对象模型（可选）&lt;/li&gt;
&lt;li&gt;用于保存配置的数据存储&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;您最有可能需要支持Envoy操作的其他辅助组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;证书/ CA存储&lt;/li&gt;
&lt;li&gt;统计收集引擎&lt;/li&gt;
&lt;li&gt;分布式跟踪后端/引擎&lt;/li&gt;
&lt;li&gt;外部认证&lt;/li&gt;
&lt;li&gt;限速服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，您需要考虑构建控制平面，以便组件独立运行，并且可以松散协作以满足控制平面的需求。您要做的最后一件事是通过部署整体控制平面来支持Envoy的微服务部署。例如，在&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开源Gloo项目&lt;/a&gt; 中，我们有以下驱动控制平面的组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Gloo&lt;/code&gt; - 一个事件驱动的组件，负责为核心xDS服务生成配置并为其提供服务，并配置自定义Envoy过滤器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Discovery&lt;/code&gt; - 一个可选组件，知道如何使用服务发现服务（Consul，Kubernetes等）来发现和通告上游集群和端点。 它还可以发现REST端点（通过swagger），gRPC功能（基于gRPC反射）和AWS / GCP / Azure云功能。 该组件创建配置（在Kubernetes上，用&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CustomResourceDefinitions&lt;/a&gt;表示）&lt;code&gt;Gloo&lt;/code&gt;组件可用于 构建通过xDS表示的规范Envoy配置。 我们将在本系列博客的后续部分中看到更多内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Gateway&lt;/code&gt; - 该组件允许用户使用更舒适的对象模型来根据其角色（即边缘网关，共享代理，knative群集入口等）配置Envoy代理。 控制平面的这一部分还生成“Gloo”控制平面可用于通过xDS生成Envoy配置的配置。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/gloo-control-plane_huf9a4583338679be33bb1f87ca6d83396_125219_53a706a1b99715c923f5bd9af64bbe91.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/gloo-control-plane_huf9a4583338679be33bb1f87ca6d83396_125219_4f8e0c8c337f73195425c64d23dc3306.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/gloo-control-plane_huf9a4583338679be33bb1f87ca6d83396_125219_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/gloo-control-plane_huf9a4583338679be33bb1f87ca6d83396_125219_53a706a1b99715c923f5bd9af64bbe91.webp&#34;
               width=&#34;522&#34;
               height=&#34;373&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正如您所看到的，这些基本组件被部署为协同工作的服务，以构建通过xDS提供的相应Envoy配置。 Gloo通过使用这些松散协调的控制平面组件来实现其强大的发现功能，对函数的语义理解等，这些组件可用于服务Envoy配置。当Gloo部署到Kubernetes时，存储和配置非常具有“kube-native”的感觉：所有内容都由&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自定义资源定义&lt;/a&gt;表示。具体而言，所有面向用户的配置以及驱动xDS端点的核心配置都是CRDs。您可以使用Kubernetes API和kubectl与Gloo进行交互。但是，我们还提供了一个&lt;code&gt;glooctl&lt;/code&gt; &lt;a href=&#34;https://gloo.solo.io/cli/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CLI工具来简化与Gloo控制平面的交互&lt;/a&gt; - 特别是如果你不想的话，你不必为了YAML而烦恼。通过这种方式，Gloo非常注重开发人员的体验和简化YAML的配置，对开发人员（或任何人？）来说这些可能非常繁琐。&lt;/p&gt;
&lt;p&gt;Istio也采用类似的方法来使用通过Kubernetes CRDs配置的松散协调的控制平面组件。 Istio的控制平面由以下部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Istio Pilot&lt;/code&gt;  - 核心xDS服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Istio Galley&lt;/code&gt;  - 配置/存储抽象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Istio Citadel&lt;/code&gt;  -  CA /证书引擎&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Istio Telemetry&lt;/code&gt; - 遥测信号的接收器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Istio Policy&lt;/code&gt; - 一个可插拔的策略引擎&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/istio-control-plane_hud2540a37c6b85d4dab535e516aa66b7a_338382_6b34bed9fd8534417c1c3acd997317d6.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/istio-control-plane_hud2540a37c6b85d4dab535e516aa66b7a_338382_63d17ce0a2ea63db715a02bf596b71a8.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/istio-control-plane_hud2540a37c6b85d4dab535e516aa66b7a_338382_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/istio-control-plane_hud2540a37c6b85d4dab535e516aa66b7a_338382_6b34bed9fd8534417c1c3acd997317d6.webp&#34;
               width=&#34;760&#34;
               height=&#34;249&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Heptio Contour实际上只有两个组件组成了它的控制平面，但是，由于它完全基于Kubernetes，它实际上利用了很多内置的Kubernetes工具，如Kubernetes API / Storage和CRDs来驱动配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;contour&lt;/code&gt;服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init-container&lt;/code&gt; 启动引导&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/contour-control-plane_hu2a057ba7226cc62cf6679e317e980f10_121148_58280002d969bdca6c437464e0d99853.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/contour-control-plane_hu2a057ba7226cc62cf6679e317e980f10_121148_de1f33742309890cbfb2c1a3588b15be.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/contour-control-plane_hu2a057ba7226cc62cf6679e317e980f10_121148_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/contour-control-plane_hu2a057ba7226cc62cf6679e317e980f10_121148_58280002d969bdca6c437464e0d99853.webp&#34;
               width=&#34;760&#34;
               height=&#34;181&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Contour使用&lt;code&gt;init-container&lt;/code&gt;为Envoy生成一个静态引导配置文件，告诉它在哪里找到xDS服务。 xDS服务器是控制平面中的第二个组件，默认情况下与数据平面一起部署，并提供单独部署的选项。 我们将在本系列“部署控制平面组件”的第5部分中介绍这种架构及其权衡。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;确定控制平面所需的核心组件。不要试图构建一个单体的控制平面抽象，因为这将成为维护和更新的噩梦。在松散耦合的体系结构中构建控制平面所需的组件。如果您可以构建在Kubernetes之上，那么这样做：&lt;a href=&#34;https://medium.com/@allingeek/kubernetes-as-a-common-ops-data-plane-f8f2cf40cd59&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes提供了一个非常强大的集成数据平面&lt;/a&gt;用于操作分布式系统，例如Envoy控制平面。如果你在Kubernetes之上构建一个控制平面，你应该利用&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自定义资源定义&lt;/a&gt;来驱动配置你的控制平面。有些人选择使用&lt;a href=&#34;https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;入口定义&lt;/a&gt;，&lt;a href=&#34;https://www.getambassador.io/reference/configuration/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务注释&lt;/a&gt;，或&lt;a href=&#34;https://www.youtube.com/watch?v=a1tXFUrqt5M&amp;amp;list=PLj6h78yzYM2PF_iYEBntfR0m4KAZET18Q&amp;amp;index=14&amp;amp;t=0s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;配置映射&lt;/a&gt;来构建他们的控制平面。在Kubernetes CRDs可用之前，这些可能是适当的解决方法，但此时你应该避免这些方法并坚持使用CRDs。就像&lt;a href=&#34;https://kubernetespodcast.com/episode/041-ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tim Hockin（Kubernetes的创始人）在最近的播客中所说的那样&lt;/a&gt;，用于驱动Ingress Gateway资源的注释是一个糟糕的选择。&lt;/p&gt;
&lt;p&gt;本系列的下一篇文章实际上已经发布：&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-for-envoy-domain-specific-configuration-api/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为Envoy构建控制平面的指南第3部分 - 域特定配置API&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>构建Envoy的控制平面手册第5部分 - 部署的权衡</title>
      <link>https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/</link>
      <pubDate>Fri, 14 Jun 2019 10:30:32 +0800</pubDate>
      <guid>https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.christianposta.com/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;作为探索为Envoy构建控制平面系列文章的第5部分，本文介绍了部署控制平面的选项与权衡，着重阐述了保持控制平面与数据平面解耦的几大好处，并且在文章结尾建议构建一个可拔插的控制平面以支持各种新特性、拓展和适配。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;这是探索为Envoy构建控制平面&lt;a href=&#34;https://blog.christianposta.com/envoy/guidfor-build-a-control-plane-to-management-Envoy-Proxy-based-infrastructure/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;系列文章&lt;/a&gt;的第5部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;采用一种机制来动态更新Enovy的路由、服务发现和其他配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-for-envoy-identify-components/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;识别构成控制平面的组件，包括支持存储、服务发现api、安全组件等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-for-envoy-domain-specific-configuration-api/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构建最适合你的使用场景和组织架构的特定域的配置对象和api&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/guidance-for-building-a-control-plane-for-envoy-build-for-pluggability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;考虑如何最好地使你的控制平面可插在你需要它的地方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;部署各种控制平面组件的选项 (本文)&lt;/li&gt;
&lt;li&gt;基于控制平面的测试工具的思考&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上一篇文章中，我们探讨了为什么可拔插控制平面对于跟上快速迭代的Envoy API以及与组织可能采用的不同工作流集成至关重要。在本文中，我们将讨论部署各种控制平面组件时的权衡。&lt;/p&gt;
&lt;h2 id=&#34;部署控制平面组件&#34;&gt;部署控制平面组件&lt;/h2&gt;
&lt;p&gt;一旦您构建并设计了控制平面及其各种支持组件，您就需要准确地决定如何部署它的组件。在确定最适合您的实现时，您需要权衡各种安全性、可伸缩性和可用性问题。这些选项里包括将控制平面组件与数据平面一起部署，以及将控制平面与数据平面完全解耦。这里也有一个折中方案：部署一些与控制平面共存的组件，并保持一些集中。让我们来看看。&lt;/p&gt;
&lt;p&gt;在Istio service-mesh项目中，控制平面组件与数据平面分别部署和运行。这在服务网格实现中非常常见。也就是说，数据平面与应用程序一起运行，处理所有的应用程序流量，并通过gRPC流上的xDS API与控制平面通信。控制平面组件通常在它们自己的命名空间中运行，并且在理想情况下，不当操作或者意外使用将导致组件被锁定。&lt;/p&gt;
&lt;p&gt;Gloo项目作为一个API网关，遵循类似的部署模型。控制平面组件与数据平面解耦，Envoy数据平面使用xDS gRPC流来收集关于监听器、路由、端点和集群等的配置。您可以使用Gloo部署与数据平面代理共存的控制面板组件，但不建议这样做。我们稍后会看一些权衡。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-separatecontrolplane&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;separatecontrolplane&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_a651071f50eaa71ceb37c3e28b1e2568.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_120b92ca1f1516fda4abe3a7aac586ac.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_a651071f50eaa71ceb37c3e28b1e2568.webp&#34;
               width=&#34;760&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      separatecontrolplane
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，我们研究了控制平面组件与数据平面的协同部署。在Contour项目中，默认情况下，控制平面组件是与数据平面一起部署的，尽管&lt;a href=&#34;https://github.com/heptio/contour/blob/master/docs/deploy-seperate-pods.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;存在一个拆分部署的选项&lt;/a&gt;。Contour实际上利用CRD或Ingress资源进行配置，所以所有的配置文件处理和监控都发生在Kubernetes中。然而，xDS服务却是与数据平面共同部署(同样，这是默认情况—您依然可以将它们拆分)。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-codeployed&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;codeployed&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/codeployed_hu2e5f4d5fbc8d87f9c2d950e759df9c70_8897_4600f5795ce4ab7b0321764abfd91021.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/codeployed_hu2e5f4d5fbc8d87f9c2d950e759df9c70_8897_d100aca9c02191713b3068cc33463e30.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/codeployed_hu2e5f4d5fbc8d87f9c2d950e759df9c70_8897_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/codeployed_hu2e5f4d5fbc8d87f9c2d950e759df9c70_8897_4600f5795ce4ab7b0321764abfd91021.webp&#34;
               width=&#34;231&#34;
               height=&#34;174&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      codeployed
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当&lt;a href=&#34;https://www.youtube.com/watch?v=a1tXFUrqt5M&amp;amp;list=PLj6h78yzYM2PF_iYEBntfR0m4KAZET18Q&amp;amp;index=14&amp;amp;t=0s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBay为他们的Envoy部署构建了控制平面&lt;/a&gt;时，他们还将控制平面(discovery pieces)的&lt;em&gt;部分组件&lt;/em&gt;与数据平面联合部署。他们基本上自己实现了一个控制器来监视CRD、Ingress和服务资源，并且生成配置映射。然后，这些配置映射将由与Pod一起运行的&lt;code&gt;discovery&lt;/code&gt;容器使用，并随着改动重新热启动，以及更新Envoy。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/ebay-control-plane_hu20d9f643d17bb9560af9b322a623721a_343064_5df639fb9b4e9f28a9ed5d7949974d16.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/ebay-control-plane_hu20d9f643d17bb9560af9b322a623721a_343064_1d55db1a70d1b864ef0295ae0f2c52d6.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/ebay-control-plane_hu20d9f643d17bb9560af9b322a623721a_343064_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/ebay-control-plane_hu20d9f643d17bb9560af9b322a623721a_343064_5df639fb9b4e9f28a9ed5d7949974d16.webp&#34;
               width=&#34;760&#34;
               height=&#34;220&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/double-click-ebay-control-plane_hub16ca4b77d7d4ef34eeecd11f5e28575_475483_28ced7fab1aefdac2b95193054e22b49.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/double-click-ebay-control-plane_hub16ca4b77d7d4ef34eeecd11f5e28575_475483_efef68d3d8f151fd763584f98d8901d0.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/double-click-ebay-control-plane_hub16ca4b77d7d4ef34eeecd11f5e28575_475483_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/double-click-ebay-control-plane_hub16ca4b77d7d4ef34eeecd11f5e28575_475483_28ced7fab1aefdac2b95193054e22b49.webp&#34;
               width=&#34;760&#34;
               height=&#34;239&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在Ebay的案例中，我们看到了一种“混合”的方法，并且深受其架构其余部分的具体影响。那么，在为Envoy评估控制平面时，或者考虑自己构建控制平面时，应该如何部署控制平面组件?&lt;/p&gt;
&lt;h3 id=&#34;我应该将控制平面与数据平面分开吗&#34;&gt;我应该将控制平面与数据平面分开吗?&lt;/h3&gt;
&lt;p&gt;各种方法都有优缺点。&lt;a href=&#34;https://github.com/solo-io/gloo/graphs/contributor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo团队&lt;/a&gt;认为，对于大多数应用场景来说，保持控制平面独立是正确的选择，应该避免将控制平面与数据平面完全部署在一起。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_a651071f50eaa71ceb37c3e28b1e2568.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_120b92ca1f1516fda4abe3a7aac586ac.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hue97d3de236d7a671560014c079e9f5fb_34730_a651071f50eaa71ceb37c3e28b1e2568.webp&#34;
               width=&#34;760&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果Envoy是L7网络的核心和灵魂，那么控制平面就是大脑。部署与数据平面分离的控制平面非常重要，原因如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全性—如果您的数据平面中的某个节点受到攻击，您肯定不希望因为允许您的控制平面受到攻击而放弃对其他应用程序和网络的控制，从而加剧您的情况。此外，控制平面可以处理密钥、证书或其他机密的分发，这些机密信息应该与数据平面分开保存。&lt;/li&gt;
&lt;li&gt;伸缩性—您可能最终会以不同的方式伸缩数据平面和控制平面。例如，如果您的控制平面正在轮询Kubernetes中的服务/端点等，那么您肯定不希望将这些组件与您的数据平面放在一起—您将扼杀任何可伸缩性的机会。&lt;/li&gt;
&lt;li&gt;分组—您的数据平面可能具有不同的角色和职责；例如，您可能在边缘有数据平面Envoy，这将需要不同的安全性和网络状态，而不是用于微服务的共享代理池与您可能部署的任何sidecar代理。将控制平面与数据平面放在一起会使数据和配置分开变得更加困难。&lt;/li&gt;
&lt;li&gt;资源利用—您可能希望根据组件分配或限制某些资源使用。例如，您的数据平面可能比控制平面更需要计算(控制平面可能更需要内存)，并且您将使用不同的资源限制来满足这些角色的需求。将它们分开可以让您获得更多细粒度的资源池选项，而不只是将它们集中在一起。此外，如果控制平面和数据平面被配置在一起，并且争夺相同的资源，您可能会得到难以诊断的奇怪的尾延迟(Tail Latency)。&lt;/li&gt;
&lt;li&gt;部署/生命周期—您可能希望独立于数据平面对控制平面进行补丁、升级或其他服务。&lt;/li&gt;
&lt;li&gt;存储—如果您的控制平面需要任何类型的存储，那么您可以单独配置它，如果您将组件分离出来，则不需要涉及数据平面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于这些原因，我们建议保持控制平面与数据平面解耦。&lt;/p&gt;
&lt;h2 id=&#34;要点&#34;&gt;要点&lt;/h2&gt;
&lt;p&gt;为Envoy构建控制平面并不容易，一旦您了解了工作流需要从控制平面得到什么，您就需要了解如何最好地部署它。Gloo团队建议构建一个可拔插的控制平面，并将其与数据平面分开，原因如上所述。Gloo的体系结构是这样构建的，它使&lt;a href=&#34;https://github.com/solo-io/gloo/graphs/contributor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo团队&lt;/a&gt;能够快速添加任何新特性和扩展，以支持任何平台、配置、过滤器，以及更多。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway的身份认同危机</title>
      <link>https://cloudnative.to/blog/api-gateways-are-going-through-an-identity-crisis/</link>
      <pubDate>Mon, 13 May 2019 20:08:37 +0800</pubDate>
      <guid>https://cloudnative.to/blog/api-gateways-are-going-through-an-identity-crisis/</guid>
      <description>&lt;p&gt;如今，API网关经历了一系列&lt;a href=&#34;https://en.wikipedia.org/wiki/Identity_crisis&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;身份认同危机&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们是集中式共享资源，有助于将API暴露和维护到外部实体吗？&lt;/li&gt;
&lt;li&gt;它们是否为集群的ingress哨兵，严格控制用户流量在集群的进出？&lt;/li&gt;
&lt;li&gt;或它们是否为某类API的集成，以便更简洁地表达API，具体取决于它所具有的客户端类型？&lt;/li&gt;
&lt;li&gt;当然还有不愿多谈但我经常听到的一个问题：&amp;ldquo;服务网格是否会使API网关过时？&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;有关背景&#34;&gt;有关背景&lt;/h2&gt;
&lt;p&gt;随着技术的快速发展，以及行业在技术和架构模式中的快速发展，你会想到&amp;quot;这一切都让我头晕目眩&amp;quot;。在这篇文章中，我希望简化&amp;quot;API网关&amp;quot;的不同身份，澄清组织中哪些组可能使用API网关（他们试图解决的问题），并重新关注第一原则。理想情况下，在本文结束时，您将更好地了解不同团队在不同层面的API架构的作用，以及如何从每个层面中获取最大价值。&lt;/p&gt;
&lt;p&gt;在我们深入研究之前，让我们对API这个术语非常清楚。&lt;/p&gt;
&lt;h2 id=&#34;我对api的定义&#34;&gt;我对API的定义：&lt;/h2&gt;
&lt;p&gt;一种明确且有目的地定义的接口，旨在通过网络调用，使软件开发人员能够以受控且舒适的方式对组织内的数据和功能进行编程访问。&lt;/p&gt;
&lt;p&gt;这些接口抽象了实现它们的技术基础结构的细节。对于这些设计好的端点，我们期望能有些一定程度的文档，例如使用指南，稳定性报告和向后兼容性。&lt;/p&gt;
&lt;p&gt;相反，仅仅因为我们可以通过网络与另一个软件通信并不一定意味着远程端点是这个定义好的API。许多系统彼此通信，往往这种通信更加随意地发生，并且通过耦合和其他因素进行实时交互。&lt;/p&gt;
&lt;p&gt;我们创建API以提供对业务部分的深思熟虑的抽象，并实现新的业务功能以及偶发创新。&lt;/p&gt;
&lt;p&gt;在讨论API网关时首先列出的是API管理。&lt;/p&gt;
&lt;h2 id=&#34;api管理&#34;&gt;API管理&lt;/h2&gt;
&lt;p&gt;很多人都在API管理方面考虑API网关。这是合理的。但是让我们快速了解一下API网关到底是做什么的。&lt;/p&gt;
&lt;p&gt;通过&lt;a href=&#34;https://en.wikipedia.org/wiki/API_management&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Management&lt;/a&gt;，我们希望解决：当我们希望公开现有API以供其他人使用时，如何跟踪谁使用这些API，实施允许谁使用这些API的策略，建立安全流以进行身份​​验证和授权允许，使用并构建可在设计时使用的服务目录，以促进API使用并为有效治理奠定基础。&lt;/p&gt;
&lt;p&gt;我们希望解决：现有的，规划好的API，我们希望按照我们的条款分享给他人的问题。&lt;/p&gt;
&lt;p&gt;API管理还可以很好地允许用户（潜在API消费者）自助服务，注册不同的API消费计划（想一想：指定价格点在给定时间范围内每个端点的每个用户的呼叫数）。我们能够实施这些管理功能的基础设施是我们的API流量通过的网关。在这一点上，我们可以执行诸如身份认证，流量限速，指标采集，以及其他策略执行操作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-management-sketch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;利用API网关的API管理软件示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://apigee.com/api-management/#/homepage&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Apigee&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.3scale.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat 3Scale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mulesoft.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mulesoft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://konghq.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个层面上，我们考虑API（如上所述）以及如何最好地管理和允许访问它们。我们没有考虑服务器，主机，端口，容器甚至服务（另一个定义不明确的词，但你理解我的！）。&lt;/p&gt;
&lt;p&gt;API管理（以及它们相应的网关）通常实现为由&amp;quot;平台团队&amp;quot;，&amp;ldquo;集成团队&amp;quot;或其他API基础架构团队拥有的严格控制的共享基础架构。通常这样做是为了强制执行一定程度的治理，变更管理和策略。在某些情况下，即使这些基础架构集中部署和管理，它们也可能支持更分散的物理部署。例如，Kong的首席技术官Marco Palladino在评论中指出，Kong可以选择部署的组件来支持集中式或分布式模型。&lt;/p&gt;
&lt;p&gt;有一点需要注意：我们要注意不要让任何业务逻辑进入这一层。如前一段所述，API管理是共享基础架构，但由于我们的API流量通过它，它倾向于重造&amp;quot;全知全能&amp;rdquo;（思考企业服务总线）治理门户，为通过它，我们必须全盘改造我们的服务。理论上这听起来很棒。实际上，这可能最终成为组织瓶颈。有关更多信息，请参阅此文章：&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Network Functions with ESBs, API Management, and Now… Service Mesh?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;集群入口&#34;&gt;集群入口&lt;/h2&gt;
&lt;p&gt;为了构建和实现API，我们专注于代码，数据，业务框架等方面。但是，要让这些的东西提供价值，必须对它们进行测试，部署到生产环境中并进行监控。当我们开始部署到云原生平台时，我们开始基于部署，容器，服务，主机，端口等考虑，以便构建我们的应用程序适应该环境。我们大概还需要制作工作流程（CI）和管道（CD），以利用云平台快速迭代，将其提供给客户等。&lt;/p&gt;
&lt;p&gt;在这种环境中，我们可以构建和维护多个集群来托管我们的应用程序，并需要某种方式来访问这些集群内的应用程序和服务。以Kubernetes为例。我们可以使用&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Ingress controller&lt;/a&gt;来允许访问Kubernetes集群（集群中的其他所有内容都无法从外部访问）。通过这种方式，我们可以非常严格地控制流量可能进入（甚至离开）我们的集群，具有明确定义的入口点，如域名/虚拟hosts，端口，协议等。&lt;/p&gt;
&lt;p&gt;在这个层面中，我们可能希望某种&amp;quot;&lt;a href=&#34;https://istio.io/docs/tasks/traffic-management/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ingress gateway&lt;/a&gt;&amp;ldquo;成为允许请求和消息进入集群的流量哨兵。在这个层面中，你需要更多考虑的是：&amp;ldquo;我在我的集​​群中有这项服务，我需要集群外部的人能够调用它&amp;rdquo;。这可能是一个服务（暴露API），一个系统整体，一个gRPC服务，一个缓存，一个消息队列，一个数据库等。有些人选择将其称为API网关，其中的一些可能实际上做得比流量入口/出口更多，但重点是问题存在于集群级操作上。由于我们倾向于部署更多集群（相对于单个高度多租户集群），我们最终会有更多网络入口点和彼此交互的需求。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/cluster-ingress-sketch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些类型的入口实现的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Envoy Proxy and projects that build upon it including：
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.getambassador.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Datawire Ambassador&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io Gloo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/heptio/contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heptio Contour&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HAProxy
&lt;ul&gt;
&lt;li&gt;Including &lt;a href=&#34;https://docs.openshift.com/container-platform/3.9/install_config/router/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenShift’s Router&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/ingress-nginx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NGINX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://traefik.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Kong/kubernetes-ingress-controller&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此层面的集群入口控制器由平台团队管理，但是这个基础架构通常与更分散的自助服务工作流程相关联（正如您期望从云原生平台那样）。请参阅&lt;a href=&#34;https://www.weave.works/blog/gitops-operations-by-pull-request&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;See the &amp;ldquo;GitOps&amp;rdquo; workflow as described by the good folks at Weaveworks&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;api-gateway模式&#34;&gt;API Gateway模式&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;API网关&amp;quot;这一术语的另一重意思才是我最开始理解的，即它是最接近API Gateway模式的那个。 &lt;a href=&#34;https://www.chrisrichardson.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chris Richardson&lt;/a&gt;在第8章的&amp;rdquo;&amp;quot;&lt;a href=&#34;https://microservices.io/book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务设计模式&lt;/a&gt;&amp;ldquo;&amp;ldquo;一书中做了很好的工作。我强烈建议将该书用作本文和其他微服务模式的教学。在他的&lt;a href=&#34;https://microservices.io/patterns/apigateway.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;microservices.io&lt;/a&gt;网站可以上略扫一下即可知，API Gateway模式，简而言之，是关于策划API以便更好地使用不同类别的消费者。此策略涉及API间接级别。您可能听到的代表API Gateway模式的另一个术语是&amp;quot;服务于前端的后端&amp;rdquo;，其中&amp;quot;前端&amp;quot;可以是单纯前端界面（UI），移动客户端，物联网客户端，甚至是其他服务/应用开发人员。&lt;/p&gt;
&lt;p&gt;在API Gateway模式中，我们明确简化了一组API的调用，以模拟特定用户，客户或消费者的&amp;quot;应用程序&amp;quot;的内聚API。回想一下，当我们使用微服务来构建我们的系统时，&amp;ldquo;应用程序&amp;quot;的概念就会消失。 API Gateway模式有助于重塑此概念。这里的关键在于API网关，当它实现时，它成为客户端和应用程序的API，并负责与任何后端API和其他应用程序网络端点（那些不符合上述API定义的端点）进行通信。&lt;/p&gt;
&lt;p&gt;与上一节中的Ingress控制器不同，此API网关更接近于开发人员的全局视图，并且不太关注为集群外消耗而暴露的端口或服务。这个&amp;quot;API Gateway&amp;quot;也不同于我们对已有API的进行管理所用的API管理观念。这个API网关掩盖了对可能暴露API的后端的调用，但是也可能会谈到较少描述为API的事情，例如对旧系统的RPC调用，使用不符合&amp;quot;REST&amp;quot;式优雅的协议调用，例如JSON over HTTP，gRPC，SOAP，GraphQL，websockets和消息队列这些黑科技。还可以调用这种类型的网关来进行消息级转换，复杂路由，网络负载均衡/回调以及响应的集成。&lt;/p&gt;
&lt;p&gt;如果您熟悉&lt;a href=&#34;https://www.crummy.com/writing/speaking/2008-QCon/act3.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Richardson的REST API的成熟度模型&lt;/a&gt;，那么实现API Gateway模式的API网关会被要求集成更多的Level 0请求（以及介于两者之间的所有内容）而不是Level 1-3实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/richardson-model.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://martinfowler.com/articles/richardsonMaturityModel.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://martinfowler.com/articles/richardsonMaturityModel.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这些类型的网关实现仍然需要解决诸如速率限制，认证/授权，熔断，指标采集，流量路由等一类的事情。 这些类型的网关可以在集群的边缘用作集群入口控制器，也可以在集群的深处用作应用程序网关。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-gateway-pattern.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此类API网关的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://spring.io/projects/spring-cloud-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud Gateway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io Gloo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Netflix/zuul&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix Zuul&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://strongloop.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM-Strongloop Loopback/Microgateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种类型的网关也可以使用更通用的编程或集成语言/框架来构建，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache Camel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io/projects/spring-integration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Integration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ballerina.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ballerina.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://vertx.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Eclipse Vert.x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/en/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NodeJS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于这种类型的API网关与应用程序和服务的开发密切相关，我们希望开发人员能够参与、帮助指定API网关公开的API，了解所涉及的任何mashup逻辑以及需要能够快速测试和更改此API基础结构。我们还希望操作或SRE对API网关的安全性，弹性和可观察性配置有一些看法。此级别的基础架构还必须适应不断发展的按需自助服务开发人员工作流程。再次参见GitOps模型以获取更多信息。&lt;/p&gt;
&lt;h2 id=&#34;谈到服务网格&#34;&gt;谈到服务网格&lt;/h2&gt;
&lt;p&gt;在云基础架构上运行服务架构的一部分包括难以在网络中构建适当级别的可观察性和控制。在解决此问题的先前迭代中，&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们使用应用程序库和有希望的开发人员治理来实现此目的&lt;/a&gt;。然而，在规模和多语言环境中，&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格技术的出现提供了更好的解决方案&lt;/a&gt;。服务网格通过透明实现为平台及其组成服务带来以下功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务到服务（即东西流量）的恢复能力&lt;/li&gt;
&lt;li&gt;安全性包括最终用户验证，双向TLS，服务到服务RBAC / ABAC&lt;/li&gt;
&lt;li&gt;黑盒服务可观察性（专注于网络通信），用于请求/秒，请求延迟，请求失败，熔断事件，分布式跟踪等&lt;/li&gt;
&lt;li&gt;服务到服务速率限制，配额执行等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;精明的读者会认识到，&lt;a href=&#34;https://dzone.com/articles/api-gateway-vs-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API网关和服务网格的功能似乎有些重叠&lt;/a&gt;。服务网格的目标是通过在L7上透明地解决任何服务/应用程序来解决这些问题。换句话说，服务网格希望融入服务（实际上没有被编码到服务的代码中）。另一方面，API网关位于服务网格和应用程序之上（L8？）。服务网格为服务，主机，端口，协议等（东/西流量）之间的请求流带来价值。它们还可以提供基本的集群入口功能，以便为北/南流量带来一些此功能。但是，这不应与API网关可以为南北向流量带来的功能相混淆（如在集群的北/南和向应用程序或应用程序组的北/南）。&lt;/p&gt;
&lt;p&gt;服务网格和API网关在某些领域的功能上重叠，但它们是互补的，因为它们生活在不同的层次并解决不同的问题。理想的解决方案是将每个组件（API Management，API Gateway，Service Mesh）即插即用，并在需要时在组件之间保持良好的界限（或者在不需要它们时将其排除）。同样重要的是找到&lt;a href=&#34;https://developer.ibm.com/apiconnect/2018/12/10/api-management-centralized-or-decentralized/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;适合您的分散开发人员和操作工作流程&lt;/a&gt;的这些工具的实现。尽管这些不同组成部分的术语和身份存在混淆，但我们应该依赖于第一原则并理解我们的架构中这些组件在何处带来价值以及它们如何独立存在并共存互补性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-layers.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;我们很乐意帮忙&#34;&gt;我们很乐意帮忙！&lt;/h2&gt;
&lt;p&gt;一些读者可能知道我热衷于帮助人们，特别是在云，微服务，事件驱动架构和服务网络领域。 在我的公司,&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;，我们正在帮助IT组织认识并成功采用适当级别的网关和服务网格等API技术，以及他们成功优化它们的速度（更重要的是，他们确实需要这些技术！！）。 我们在&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Proxy&lt;/a&gt;，&lt;a href=&#34;https://graphql.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GraphQL&lt;/a&gt;和&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;等技术的基础上构建了&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;，&lt;a href=&#34;https://sqoop.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Scoop&lt;/a&gt;和&lt;a href=&#34;https://supergloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SuperGloo&lt;/a&gt;等工具，以帮助实现API网关和服务网格管理。 请直接联系我们（&lt;a href=&#34;https://twitter.com/soloio_inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@soloio_inc&lt;/a&gt;，&lt;a href=&#34;http://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http：//solo.io&lt;/a&gt;）或直接与我联系（&lt;a href=&#34;http://www.twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt;，&lt;a href=&#34;http://blog.christianposta.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;），深入了解我们的愿景以及我们的技术如何为您的组织提供帮助。 在下一系列博客中，我们将深入探讨API Gateway模式，多集群场景的难点，多服务网格的难点等！ 敬请关注！&lt;/p&gt;
&lt;h2 id=&#34;相关阅读&#34;&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>为 Envoy 构建控制面指南第4部分：构建的可扩展性</title>
      <link>https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/</link>
      <pubDate>Mon, 22 Apr 2019 10:41:16 +0800</pubDate>
      <guid>https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility-40f8ac8e48e&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编者按&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文介绍如何为 Envoy 构建控制面指南的第4部分：构建的可扩展性。Gloo团队建议将重点放在控制平面的简单核心上，然后通过插件和微服务控制器的可组合性扩展它。Gloo的体系结构是这样构建的，它使Gloo团队能够快速添加任何新特性，以支持任何平台、配置、过滤器，以及更多的新特性。这就是为什么，尽管Gloo是非常kubernets原生的，但它是为在任何云上的任何平台上运行而构建的。核心控制平面的设计允许这样做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是探究为 Envoy 代理构建控制平面系列文章的第4部分。请关注&lt;a href=&#34;https://twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt;和&lt;a href=&#34;https://twitter.com/soloio_inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@soloio_inc&lt;/a&gt;将在一周内推出下一部分内容。&lt;/p&gt;
&lt;p&gt;在本系列博客中，我们将关注以下领域:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh-badb6c36a2af&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;采用一种机制来动态更新 Envoy 的路由、服务发现和其他配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-proxy-part-2-identify-components-2d0731b0d8a4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;确定控制平面由哪些组件组成，包括支持存储、服务发现 API、安全组件等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./Guidance-for-Building-a-Control-Plane-for-Envoy-Part-3-Domain-Specific-Configuration.md&#34;&gt;建立最适合您的使用场景和组织架构的特定于域的配置对象和 API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;考虑如何让控制平面支持可拔插(本博客)&lt;/li&gt;
&lt;li&gt;部署各种控制平面组件的选项&lt;/li&gt;
&lt;li&gt;为你的控制平面考虑测试套件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;a href=&#34;./Guidance-for-Building-a-Control-Plane-for-Envoy-Part-3-Domain-Specific-Configuration.md&#34;&gt;上一篇文章&lt;/a&gt;中，我们探讨了为您的控制平面构建一个特定于领域的API，使得该API最适合您的组织和工作流并满足首选条件/约束。&lt;/p&gt;
&lt;h2 id=&#34;构建可插拔的控制平面引擎&#34;&gt;构建可插拔的控制平面引擎&lt;/h2&gt;
&lt;p&gt;Envoy是一个非常强大的软件，每天都有&lt;a href=&#34;https://github.com/envoyproxy/envoy/pull/4950&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;新的用例和贡献被提交给社区&lt;/a&gt;。尽管Envoy的核心非常稳定，但它建立在&lt;a href=&#34;https://github.com/envoyproxy/envoy-filter-example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可插拔的过滤器架构&lt;/a&gt;之上，因此人们可以为不同的L7协议编写新的编解码器或添加新的功能。目前，Envoy过滤器是用C++编写的，可以选择使用&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/http_filters/lua_filter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lua&lt;/a&gt;扩展Envoy，但是也有&lt;a href=&#34;https://github.com/envoyproxy/envoy/issues/4272&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一些讨论支持Web Assembly实现&lt;/a&gt;可扩展性。同样值得注意的是，&lt;a href=&#34;https://cilium.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium&lt;/a&gt;社区的很多人正在围绕一个&lt;a href=&#34;https://cilium.io/blog/2018/10/23/cilium-13-envoy-go/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于Go的Envoy可扩展机制&lt;/a&gt;开展工作。伴随着Envoy社区的快速发展和需要配置这些新功能，还需要新的特定于领域的对象模型来支持想利用Envoy新平台的需求。在本节中，我们将探索沿着这两个维度扩展Envoy控制平面。&lt;/p&gt;
&lt;p&gt;通过编写C++过滤器，扩展Envoy非常简单。我们在&lt;a href=&#34;https://github.com/solo-io/envoy-gloo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo项目&lt;/a&gt;上创建的Envoy过滤器包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/solo-io/squash&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Squash&lt;/a&gt;调试器
(&lt;a href=&#34;https://github.com/envoyproxy/envoy/tree/master/api/envoy/config/filter/http/squash&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/envoyproxy/envoy/tree/master/api/envoy/config/filter/http/squash&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Caching(目前为封闭源码;应该在不久的将来开放源代码)&lt;/li&gt;
&lt;li&gt;Request/Response 传输 (&lt;a href=&#34;https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/transformation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/transformation&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;AWS lambda (&lt;a href=&#34;https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/aws_lambda&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/aws_lambda&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;NATS streaming (&lt;a href=&#34;https://github.com/solo-io/envoy-nats-streaming&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/solo-io/envoy-nats-streaming&lt;/a&gt;, &lt;a href=&#34;https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/nats/streaming&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/nats/streaming&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Google Cloud Functions (&lt;a href=&#34;https://github.com/solo-io/envoy-google-function&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/solo-io/envoy-google-function&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Azure function (&lt;a href=&#34;https://github.com/solo-io/envoy-azure-functions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/solo-io/envoy-azure-functions&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34;
           src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLgy1g202enyhmsg30q10iajsu.gif&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在上面的图示中，您可以看到请求是如果通过Envoy并经过一些过滤器的，这些过滤器具有应用于请求和响应的特定任务。你可以在&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;首席执行官/创始人&lt;a href=&#34;https://medium.com/@idit.levine_92620&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Idit Levine&lt;/a&gt;和Solo.io首席架构师&lt;a href=&#34;https://medium.com/@yuval.kohavi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Yuval Kohavi&lt;/a&gt;写的一篇博客文章中读到更多关于&lt;a href=&#34;https://medium.com/solo-io/building-a-control-plane-for-envoy-7524ceb09876&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy的功能和构建Gloo的控制平面所做的权衡&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因为Envoy功能非常多，而且一直在添加新特性，所以值得花一些时间来考虑是否要将控制平面构建为可扩展的，以便能够使用这些新特性。在Gloo项目中，选择在以下几个层次上进行扩展：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在核心Gloo配置对象的基础上构建更容易进行自定义特定域的配置对象&lt;/li&gt;
&lt;li&gt;控制平面插件化以增强控制平面的现有行为&lt;/li&gt;
&lt;li&gt;创建工具来加速前面两点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们来看看每一个层次，以及它们是如何构建可扩展和灵活的控制平面的。&lt;/p&gt;
&lt;h2 id=&#34;核心api对象构建时要考虑灵活性&#34;&gt;核心API对象，构建时要考虑灵活性&lt;/h2&gt;
&lt;p&gt;在上一节中，我们重点讨论了用于配置控制平面的特定于域的配置对象。在Gloo中，我们有&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最低级别的配置对象&lt;/a&gt;，称为&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy&lt;/a&gt;和&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstream&lt;/a&gt;。&lt;code&gt;Proxy&lt;/code&gt;定义了我们可以对底层代理(在本例中是Envoy)进行的最低级别配置。使用&lt;code&gt;Proxy&lt;/code&gt;对象，我们定义请求如何路由到&lt;code&gt;Upstream&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面是Proxy对象的一个例子(在Kubernetes中是CRD)：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo.solo.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Proxy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;clusterName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2019-02-15T13:27:39Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;generation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;created_by&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway-proxy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo-system&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resourceVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;5209108&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selfLink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/apis/gloo.solo.io/v1/namespaces/gloo-system/proxies/gateway-proxy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;771377f2-3125-11e9-8523-42010aa800e0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;bindAddress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;::&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;bindPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;httpListener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;virtualHosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;domains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;s1&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo-system.default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;matcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exact&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/petstore/findPet&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routeAction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;single&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;destinationSpec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;functionName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;findPetById&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;parameters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;upstream&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default-petstore-8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo-system&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;matcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exact&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/sample-route-1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routeAction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;single&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;upstream&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default-petstore-8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo-system&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routePlugins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefixRewrite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefixRewrite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/api/pets&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;reported_by&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您可以看到&lt;code&gt;Proxy&lt;/code&gt;对象指定监听器、类型以及路由信息。如果您仔细观察，您会发现它在一定程度上遵循Envoy的配置，但在支持附加功能方面有所不同。在路由中，您可以看到请求被发送到“Upstream”。Gloo知道如何路由到&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstream&lt;/a&gt;，您可以在上面的&lt;code&gt;Proxy&lt;/code&gt;对象中看到这些定义。&lt;code&gt;Proxy&lt;/code&gt;对象是由Gloo的控制平面转换为Envoy xDS API的对象。您会看到如下的Gloo的组件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                             READY   STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;discovery-676bcc49f8-n55jt       1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          8m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gateway-d8598c78c-425hz          1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          8m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gateway-proxy-6b4b86b4fb-cm2cr   1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          8m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gloo-565659747c-x7lvf            1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          8m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;gateway-proxy&lt;/code&gt;组件是Envoy代理。控制平面由以下组件组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gateway&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;discovery&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gloo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;负责此&lt;code&gt;Proxy&lt;/code&gt;-&amp;gt;Envoy xDS转换的组件是&lt;code&gt;gloo&lt;/code&gt;，它是一个事件驱动组件，通过将&lt;code&gt;Proxy&lt;/code&gt;对象转换为Envoy的LDS/RDS/CDS/EDS API，负责核心xDS服务和自定义Envoy过滤器的配置。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222c27h5dj30ht06174i_hu1778a6c6262e4e8bd0c8540046891d07_32272_ba6e37969e66affc7747bbfac14bb030.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222c27h5dj30ht06174i_hu1778a6c6262e4e8bd0c8540046891d07_32272_7a33cd03c7ca78b8c11060bc2ad15929.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222c27h5dj30ht06174i_hu1778a6c6262e4e8bd0c8540046891d07_32272_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222c27h5dj30ht06174i_hu1778a6c6262e4e8bd0c8540046891d07_32272_ba6e37969e66affc7747bbfac14bb030.webp&#34;
               width=&#34;641&#34;
               height=&#34;217&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Gloo知道如何路由到&lt;code&gt;Upstream&lt;/code&gt;和它上面的函数。&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstream&lt;/a&gt;也是Gloo的核心配置对象。我们需要这个&lt;code&gt;Upstream&lt;/code&gt;对象的原因是，它封装了上游集群功能的更多实现，而不是Envoy所知道的开箱即用的功能。Envoy知道“集群”，但是Gloo(位于Envoy之上)知道其上的函数。此功能支持&lt;a href=&#34;https://medium.com/solo-io/announcing-gloo-the-function-gateway-3f0860ef6600&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;功能级路由&lt;/a&gt;，功能级路由是用于组合新应用程序和API的更强大的路由结构。Envoy从“host:port”端点方面了解集群，但是使用Gloo，我们可以为这些集群附加额外的上下文，以便它们理解“函数”，这些函数可以是REST方法/路径、gRPC操作或Lambda之类的云函数。例如，这里有一个名为&lt;code&gt;default-petstore-8080&lt;/code&gt;的Gloo上游：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;discoveryMetadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;discovered_by&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubernetesplugin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;petstore&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sevice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;petstore&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default-petstore-8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo-system&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;reportedBy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Accepted&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;upstreamSpec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kube&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;petstore&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;petstore&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servicePort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceSpec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;swaggerInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http://petstore.default.svc.cluster.local:8080/swagger.json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transformations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;addPet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;id&amp;#34;: {{ default(id, &amp;#34;&amp;#34;) }},&amp;#34;name&amp;#34;: &amp;#34;{{ default(name, &amp;#34;&amp;#34;)}}&amp;#34;,&amp;#34;tag&amp;#34;:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;                &amp;#34;{{ default(tag, &amp;#34;&amp;#34;)}}&amp;#34;}&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;POST&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/api/pets&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;content-type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;application/json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;deletePet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DELETE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/api/pets/{{ default(id, &amp;#34;&amp;#34;) }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;content-type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;application/json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;findPetById&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;GET&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/api/pets/{{ default(id, &amp;#34;&amp;#34;) }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;content-length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;content-type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transfer-encoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;findPets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;GET&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/api/pets?tags={{default(tags, &amp;#34;&amp;#34;)}}&amp;amp;limit={{default(limit,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;)}}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;content-length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;content-type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transfer-encoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意，我们有更多责任来确定upstream的函数要公开哪些部分。在这种情况下，上游恰好是一个REST服务，它公开了一个&lt;a href=&#34;https://github.com/OAI/OpenAPI-Specification&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open API Spec/Swagger&lt;/a&gt;文档。Gloo自动发现这些信息，并用这些信息丰富这个Upstream对象，然后可以在代理对象中使用这些信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222ij2oucj30ht0ep0ti_hu198615d58dfc80fe09193f13f6604b29_59586_262a217785b47c713a4315a354512809.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222ij2oucj30ht0ep0ti_hu198615d58dfc80fe09193f13f6604b29_59586_28d1b15c08cbb5586a5a9683a52b0d91.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222ij2oucj30ht0ep0ti_hu198615d58dfc80fe09193f13f6604b29_59586_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222ij2oucj30ht0ep0ti_hu198615d58dfc80fe09193f13f6604b29_59586_262a217785b47c713a4315a354512809.webp&#34;
               width=&#34;641&#34;
               height=&#34;529&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;回到Gloo控制平面的组件，您将看到一个&lt;code&gt;discovery&lt;/code&gt;组件，它通过添加“Upstream Discovery Service”(UDS)和“Function Discovery Service”(FDS)来增强Envoy的服务发现API。UDS使用一组插件(参见下一节)自动地从各自的运行时目录中发现&lt;code&gt;Upstream&lt;/code&gt;。最简单的例子是在Kubernetes中运行时，我们可以自动发现&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Services&lt;/a&gt;。Gloo还可以发现来自Consul、AWS和&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/plugins.proto.sk/#a-name-upstreamspec-upstreamspec-a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;其他&lt;/a&gt;的&lt;code&gt;Upstream&lt;/code&gt;。函数发现服务(FDS)评估已经发现的每个&lt;code&gt;Upstream&lt;/code&gt;，并尝试发现它们的类型(REST、gRPC、GraphQL、AWS Lambda等)。如果FDS能够发现关于上游的这些附加属性，它就会用这些“函数”丰富upstream元数据。&lt;/p&gt;
&lt;p&gt;Gloo控制平面中的&lt;code&gt;discovery&lt;/code&gt;组件仅使用其UDS和FDS服务来发现&lt;code&gt;Upstream&lt;/code&gt;对象并将其写入Kuberentes CRDs。从这里，用户可以创建从Envoy代理上的特定API路径到&lt;code&gt;Upstream&lt;/code&gt;上的特定函数的路由规则。Envoy代理不直接与这个控制平面组件交互(请回忆一下，Envoy只使用&lt;code&gt;gloo&lt;/code&gt;组件公开的xDS API)。相反，&lt;code&gt;discovery&lt;/code&gt;组件促进了向&lt;code&gt;Upstream&lt;/code&gt;的创建，然后可以由&lt;code&gt;Proxy&lt;/code&gt;对象使用。这是一个使用支持微服务(本例中的&lt;code&gt;discovery&lt;/code&gt;服务)来为控制平面的整体功能做出贡献的好例子。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Proxy&lt;/code&gt;和&lt;code&gt;Upstream&lt;/code&gt;是上一节中提到的较底层特定于域的配置对象。更有趣的是，我们如何在此之上分层一组配置对象，以满足具有更自定义工作流的用户特定用例。&lt;/p&gt;
&lt;h2 id=&#34;扩展特定于域的配置层&#34;&gt;扩展特定于域的配置层&lt;/h2&gt;
&lt;p&gt;在Gloo的控制平面中，还有另一个组件称为&lt;code&gt;gateway&lt;/code&gt;。该组件实现更高级别的特定于域的配置，用户最终将与之交互(直接通过YAML文件或通过&lt;code&gt;glooctl&lt;/code&gt; CLI工具间接地交互)。&lt;code&gt;gateway&lt;/code&gt;组件涉及两个特定于域的对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gateway/api/v1/gateway.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway&lt;/a&gt; — 指定特定监听器端口上可用的路由和API端点，以及每个API的安全性&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gateway/api/v1/virtual_service.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VirtualService&lt;/a&gt; — 将API路由分组到一组“虚拟API”中，这些“虚拟API”可以路由到支持的函数(gRPC、http/1、http/2、lambda等)；让开发人员控制路由如何处理&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/plugins/transformation/transformation.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不同的转换&lt;/a&gt;，以便将前端API与后端API(以及后端可能引入的任何破坏性更改)分离开来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g223285hajj30o20dxabd_hu28d5638a97c2c893b74c2247b2177cd1_91343_1320fce50b96e47d6c5c20a038c11b5a.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g223285hajj30o20dxabd_hu28d5638a97c2c893b74c2247b2177cd1_91343_700cfaa0b12c2538df14bdb10e0cea98.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g223285hajj30o20dxabd_hu28d5638a97c2c893b74c2247b2177cd1_91343_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g223285hajj30o20dxabd_hu28d5638a97c2c893b74c2247b2177cd1_91343_1320fce50b96e47d6c5c20a038c11b5a.webp&#34;
               width=&#34;760&#34;
               height=&#34;440&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些对象允许与&lt;code&gt;Proxy&lt;/code&gt;对象解耦。当用户使用符合标准的API或是不标准的API创建新的&lt;code&gt;Gateway&lt;/code&gt;或&lt;code&gt;VirtualService&lt;/code&gt;对象时，Gloo的&lt;code&gt;Gateway&lt;/code&gt;组件将接受这些对象(Kubernetes中的crd、Consul中的配置)并更新底层&lt;code&gt;Proxy&lt;/code&gt;对象。这是扩展Gloo的一种常见模式：首选控件平面组件的可组合性。这允许我们为主观的领域特定对象构建更专门化的控制器，以支持不同的使用。比如&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;团队还为Gloo构建了一个名为&lt;a href=&#34;https://sqoop.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sqoop&lt;/a&gt;的开源控制器，该控制器遵循相同的模式，并扩展了Gloo API，用于声明基于&lt;a href=&#34;https://graphql.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GraphQL引擎&lt;/a&gt;的路由规则。在Sqoop中，我们引入&lt;a href=&#34;https://sqoop.solo.io/introduction/concepts/api_objects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Schema和ResolverMap&lt;/a&gt;对象，它们最终组合进Proxy对象，然后将代理对象转换为Envoy xDS。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g2235n0elij30m80i5jsa_hu441c4b56517a61a6e554bdc3e4f748e9_86833_ffe6210b028a3757dcd18151d247f676.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g2235n0elij30m80i5jsa_hu441c4b56517a61a6e554bdc3e4f748e9_86833_ce13d02e2cbe2737525470ac71864c73.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g2235n0elij30m80i5jsa_hu441c4b56517a61a6e554bdc3e4f748e9_86833_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g2235n0elij30m80i5jsa_hu441c4b56517a61a6e554bdc3e4f748e9_86833_ffe6210b028a3757dcd18151d247f676.webp&#34;
               width=&#34;760&#34;
               height=&#34;620&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;构建在基本Gloo对象上的领域特定配置分层的另一个例子是，我们最近在&lt;a href=&#34;https://medium.com/solo-io/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-324753586f3a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative中使用Gloo代理作为Istio的替代方案&lt;/a&gt;。Knative有一个用来声明集群入口资源的特定对象，称为&lt;a href=&#34;https://github.com/knative/serving/blob/master/pkg/client/clientset/versioned/typed/networking/v1alpha1/clusteringress.go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ClusterIngress&lt;/a&gt;对象，如下图所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.internal.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterIngress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serving.knative.dev/route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serving.knative.dev/routeNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld-go-txrqt&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;generation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;helloworld-go.default.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;helloworld-go.default.svc.cluster.local&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;helloworld-go.default.svc&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;helloworld-go.default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;paths&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;appendHeaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;knative-serving-namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;knative-serving-revision&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld-go-00001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;retries&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;attempts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;perTryTimeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;10m0s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;splits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;percent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;activator-service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-serving&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servicePort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;10m0s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;visibility&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ExternalIP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了支持Gloo中的这个用例，我们所做的就是&lt;a href=&#34;https://github.com/solo-io/gloo/blob/ac3bddf202423b297fb909eb6eff498745a8c015/projects/clusteringress/pkg/translator/translate.go#L19&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构建一个新的控制器&lt;/a&gt;，用于监视和将&lt;a href=&#34;https://github.com/knative/serving/blob/master/pkg/client/clientset/versioned/typed/networking/v1alpha1/clusteringress.go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ClusterIngress&lt;/a&gt;对象转换为Gloo的&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy&lt;/a&gt;。有关在Knative中使用Gloo以简化&lt;a href=&#34;https://github.com/knative/serving&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Serving&lt;/a&gt;安装以使用Gloo作为集群入口的更多信息，请参阅&lt;a href=&#34;https://blog.christianposta.com/guidance-for-building-a-control-plane-for-envoy-build-for-pluggability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;本博客&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;控制平面插件化以增强现有行为&#34;&gt;控制平面插件化以增强现有行为&lt;/h2&gt;
&lt;p&gt;在上一节中，我们讨论了通过在核心对象之上分层特定于域的配置对象来扩展控制平面的功能。另一个扩展点直接位于控件平面核心对象本身中。在Istio中是&lt;code&gt;VirtualService&lt;/code&gt;和&lt;code&gt;DestinationRule&lt;/code&gt;，在Contour中是&lt;code&gt;IngressRoute&lt;/code&gt;，在Gloo中是&lt;code&gt;Proxy&lt;/code&gt;和&lt;code&gt;Upstream&lt;/code&gt;对象。例如，Gloo的&lt;a href=&#34;https://github.com/solo-io/gloo/blob/7a5c3a9a7a060841a7047efce79e5b7b3ed981be/projects/gloo/api/v1/proxy.proto#L30&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy对象&lt;/a&gt;包含&lt;a href=&#34;https://github.com/solo-io/gloo/blob/7a5c3a9a7a060841a7047efce79e5b7b3ed981be/projects/gloo/api/v1/proxy.proto#L90&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Listeners&lt;/a&gt;、&lt;a href=&#34;https://github.com/solo-io/gloo/blob/7a5c3a9a7a060841a7047efce79e5b7b3ed981be/projects/gloo/api/v1/proxy.proto#L124&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VirtualHosts&lt;/a&gt;和&lt;a href=&#34;https://github.com/solo-io/gloo/blob/7a5c3a9a7a060841a7047efce79e5b7b3ed981be/projects/gloo/api/v1/proxy.proto#L154&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Routes&lt;/a&gt;的扩展点。这意味着在Proxy配置中有一些定义良好的点，我们可以以最小的修改代价将新功能引入到我们的配置中(例如，如果我们希望公开新的Envoy功能，或者为我们希望公开配置的Envoy编写新的过滤器等)。例如，我们&lt;a href=&#34;https://github.com/solo-io/gloo/blob/a27e1018640c46f7a25e4c1a0dc1f4cadf1773f5/projects/gloo/api/v1/plugins.proto#L44&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;编写了一些插件丰富了Envoy的路由和转换功能&lt;/a&gt;。例如，要将一个请求转换为Envoy并发送到一个名为&lt;code&gt;foo-service&lt;/code&gt;的服务，我们可以使用&lt;a href=&#34;https://github.com/pantor/inja&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Inja template&lt;/a&gt;手工插入头或正文。有关更多信息，请参见&lt;a href=&#34;https://gloo.solo.io/user_guides/function_routing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo文档中的函数路由指南&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;routes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;matcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routeAction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;single&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;upstream&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foo-service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routePlugins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transformations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;requestTransformation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transformationTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;x-canary-foo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foo-bar-v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/v2/canary/feature&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;passthrough&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要查看Gloo &lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy&lt;/a&gt;和&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstream&lt;/a&gt;对象上可用插件的完整列表，请参阅这里的&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/plugins.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;一旦向控制平面添加了新的插件，就可以扩展面向用户的特定于域的配置对象，以利用这些新功能。您可以增强现有的控制器来实现这一点，或者添加新的控制器(遵循微服务松散协调的原则)。我们已经编写了&lt;a href=&#34;https://gloo.solo.io/dev/example-proxy-controller/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大量的例子来帮助您编写控制器&lt;/a&gt;来增强您的控制平面功能，或者在&lt;a href=&#34;https://slack.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slack&lt;/a&gt;上寻找更多关于这方面的指南。&lt;/p&gt;
&lt;h2 id=&#34;利用工具加快前面两个工作的实施&#34;&gt;利用工具加快前面两个工作的实施&lt;/h2&gt;
&lt;p&gt;在前几节中，我们了解了如何考虑控制平面的可扩展性和灵活性。我们了解了如何使用多层特定于域的配置对象，通过添加新对象和控制器来实现可扩展性。在&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;我们创建了一个名为&lt;a href=&#34;https://github.com/solo-io/solo-kit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;solo-kit&lt;/a&gt;的开源项目，它通过从&lt;a href=&#34;https://developers.google.com/protocol-buffers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protobuf&lt;/a&gt;对象开始，并通过代码生成正确的类型安全客户机，以便在平台上与这些对象交互，从而加快为您的控制平面构建新的、声明性的、自定义的API对象。例如，在Kubernetes上，&lt;a href=&#34;https://github.com/solo-io/solo-kit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;solo-kit&lt;/a&gt;将这些原型转换为&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CustomResourceDefinitions&lt;/a&gt;，并生成Golang Kubernetes客户机，用于监视和与这些资源交互。如果不在Kubernetes上，还可以使用Consul、Vault和其他组件作为后端存储。&lt;/p&gt;
&lt;p&gt;一旦您创建了资源并生成了类型安全的客户端，您就需要检测用户何时创建新资源或更改现有资源。使用&lt;a href=&#34;https://github.com/solo-io/solo-kit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;solo-kit&lt;/a&gt;，您只需指定希望查看哪些资源，或者称为“快照”的资源组合，客户端运行一个事件循环来处理任何通知。在事件循环中，可以更新协作对象或核心对象。事实上，这就是Gloo分层的特定于域的配置对象的工作方式。有关更多信息，请参见&lt;a href=&#34;https://gloo.solo.io/operator_guide/gloo_declarative_model/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo声明性模型文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;控制平面可以简单到您需要的程度，也可以复杂到您需要的程度。Gloo团队建议将重点放在控制平面的简单核心上，然后通过插件和微服务控制器的可组合性扩展它。Gloo的体系结构是这样构建的，它使&lt;a href=&#34;https://github.com/solo-io/gloo/graphs/contributors&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo团队&lt;/a&gt;能够快速添加任何新特性，以支持任何平台、配置、过滤器，以及更多的新特性。这就是为什么，尽管Gloo是非常kubernets原生的，但它是为在任何云上的任何平台上运行而构建的。核心控制平面的设计允许这样做。&lt;/p&gt;
&lt;p&gt;在本系列的下一篇文章中，我们将讨论部署控制平面组件的优缺点，包括可伸缩性、容错、独立性和安全性。请&lt;a href=&#34;https://twitter.com/soloio_inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;继续关注！&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>选择FaaS还是微服务？</title>
      <link>https://cloudnative.to/blog/faas-vs-microservices/</link>
      <pubDate>Tue, 09 Apr 2019 22:42:29 +0800</pubDate>
      <guid>https://cloudnative.to/blog/faas-vs-microservices/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://dzone.com/articles/faas-vs-microservices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在做项目的云原生改造时我们可以采用微服务架构。DevOps和自动化构建两方面的成功经验对微服务的实践很有帮助。经过一段时间的实践，你可能会有将微服务架构推广到其他部门的想法。而你担心微服务本身的复杂性和分布式系统的高维护成本会让其他部门难以接受它。可能在我们想方设法解决微服务带来的问题时，总会有些人觉得这样做毫无意义。因为现在技术发展如此之快，总会出现更好的技术方案，你能保证自己在微服务领域所做的工作最后没有白费吗？&lt;/p&gt;
&lt;p&gt;我认为不会白费！&lt;/p&gt;
&lt;p&gt;现在“serverless”和“functions-as-a-service”（FAAS）还处于早期的炒作阶段。有些人觉得serverless就是下一代的微服务，所以我们应该跳过当前的微服务模式而直接采用serverless。其实这种说法是有点夸大其词。作为架构师或开发者，我们通过学习新技术来提升自身能力让自己变得更&amp;quot;值钱&amp;quot;并没有错。但我们也要以务实态度来判断是否应该采用新技术。虽然持续跟进最新技术是我们作为架构师的职责所在，但掌握在之前的产品和IT部门引用新技术的时机也很重要。我们可以通过下面的模块来理解微服务架构和serverless，从而让它们可以更好的融入我们的技术栈。&lt;/p&gt;
&lt;p&gt;首先，我们需要知道为什么我们需要微服务。选用微服务架构的主要原因就是避免项目的体量阻碍产品的迭代，所有微服务其他的优势都是基于这点。更快的迭代速度意味着可以更快的为客户交付新功能/修改，从而更快的验证这些改动能够带来的效果。我们需要快速的知道自己所做的努力是否能够带来好的效果，如果不能就要马上调整方向。快速迭代就是微服务架构的核心优势。&lt;/p&gt;
&lt;p&gt;对于大多数的团队而言，至少有一部分应用能从微服务的迭代过程中获益。因此作为架构师或开发者，我们不要因为采用微服务有门槛就对其失去信心。实践微服务的重要步骤就是确定和测量改进指标。改进指标一般可以为每天迭代应用的次数、保证迭代应用稳定性的方法等。&lt;/p&gt;
&lt;p&gt;另一方面，不是所有的应用都需要用这种松散而复杂的方式来保证服务的迭代速度。如果只想简单做个应用来验证自己创意的商业价值，那你完全可以选择更加适合的架构。这时采用MVP测试（最小可行性测试）就是个很好的方案。如果你因为商业价值很低而打算放弃的话，那也只是放弃了一个MVP应用。你可以非常快的迭代它并从潜在的用户中获得反馈。在这种情况下，你可能需要根据反馈反复修改API、功能边界、组件等。所以过早就将组件功能做成分布式的服务也会拖慢产品的发布速度。你想修改分布式组件和它的api就必须在各个团队间进行协调。&lt;/p&gt;
&lt;p&gt;上述观点能够反映出微服务架构和单体架构适用不同的场景。而事实上并没有所谓&amp;quot;一招鲜吃遍天“的方案。当我们在微服务架构和单体架构之间纠结时，还需要考虑到所需服务是否已经存在以及它提供服务的方式（第三方服务/公司内部服务）。我们完全可以充分利用当前已有服务来构建我们的应用，不必重新购买硬件、安装和修补操作系统，以及优化服务从而达到最高吞吐量，而这也正是云及其服务存在的意义。云供应商和他们的合作伙伴能提供数据库、消息队列、缓存、CDN和其他更高级的功能： 例如语言翻译、地图/地理空间地图、天气等。我们可以组合各种按量付费的服务来构建自己的应用。如果在使用某个服务的时候无需关心安装、参数和容量等问题，其实我们就已经在采用serverless架构了。serverless架构的特点就是可以重用已经存在的service，而无需关心运行服务需要消耗些什么。&lt;/p&gt;
&lt;p&gt;函数即服务和serverless具有某种联系，因为它利用了缩小到单个应用程序函数的范围的计算模型，而这有助于将各种服务组合在一起构建应用。在这种模型下，功能按需分解，你只需为使用的功能付费。它特别适合对我们使用的服务进行按需计费和按量付费。这样一来我们能够构建弹性应用，而不需要考虑复杂的技术问题。将这些复杂的技术问题外包给别人可以让你更专注于为客户提供商业价值。&lt;/p&gt;
&lt;p&gt;但是将这部分能力外包不总是可行的。如果选择云服务，我们就丧失了对程序运行时、具体功能、bug修复和接受监管的控制力。这也是需要考虑的一部分。&lt;/p&gt;
&lt;p&gt;serverless不一定是完整的“公有云或无云”方案。如果以单个组织的角度来看，&amp;ldquo;serverless&amp;quot;可能只是代表整个体系的其他部分。例如：零售业务可以为组织内部其他服务或第三方提供“购买“服务以支持诸如分析、推荐以及其他使用“购买”服务的应用。利用定义良好的API和订阅并消费API的工作负载，你可以在自己的基础设施为微服务应用或单体应用提供serverless能力。在很多时候这其实就是服务向SOA架构进化的方向。但它们之间最大的不同就是在你将组织看作一个整体时，自己给自己的其他部分提供服务并不算serverless。因为此时还是需要自己手动的去安装、管理和更新应用。&lt;/p&gt;
&lt;p&gt;最终采用哪种方案其实取决于很多因素，例如：业务、商业目标、软件部门对该技术的熟练度和历史遗留问题等。如果你觉得应该采用微服务架构，那就不要因为其他新技术而分心。我们可以持续跟进最新技术，从而保证适时的采用它们。总的来讲，不管是微服务架构、单体架构还是serverless架构，它们都有自己的应用场景。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为 Envoy 构建控制平面指南第3部分：领域特定配置</title>
      <link>https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/</link>
      <pubDate>Thu, 04 Apr 2019 18:00:43 +0800</pubDate>
      <guid>https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration-c97e8124b9d1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这是探索为 Envoy 代理构建控制平面系列文章的第3部分。&lt;/p&gt;
&lt;p&gt;在本系列博客中，我们将关注以下领域:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh-badb6c36a2af&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;采用一种机制来动态更新 Envoy 的路由、服务发现和其他配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-proxy-part-2-identify-components-2d0731b0d8a4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;确定控制平面由哪些组件组成，包括支持存储、服务发现 api、安全组件等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;建立最适合您的使用场景和组织架构的特定于域的配置对象和 api（本博客）&lt;/li&gt;
&lt;li&gt;考虑如何最好地使您的控制平面可插在您需要它的地方&lt;/li&gt;
&lt;li&gt;部署各种控制平面组件的选项&lt;/li&gt;
&lt;li&gt;通过控制平面的测试工具来思考&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在前面的&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-proxy-part-2-identify-components-2d0731b0d8a4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客部分&lt;/a&gt;中，我们评估了控制平面可能需要的组件。在本节中，我们将探索特定于域的 API 在您的控制平面上可能是什么样子的。&lt;/p&gt;
&lt;h2 id=&#34;建立您的控制平面交互点和-api-面&#34;&gt;建立您的控制平面交互点和 API 面&lt;/h2&gt;
&lt;p&gt;一旦您考虑了哪些组件可能构成您的控制平面体系结构(请参阅前面的部分)，您就需要考虑您的用户将如何与控制平面交互，甚至更重要的是，您的用户将是谁?要回答这个问题，您必须决定基于 Envoy 的基础设施将扮演什么角色，以及流量将如何通过体系结构。它可以是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 管理网关（南北向流量）&lt;/li&gt;
&lt;li&gt;简单 Kubernetes 边缘负载均衡器/反向代理/入口控制（南北向流量）&lt;/li&gt;
&lt;li&gt;共享服务代理（东西向流量）&lt;/li&gt;
&lt;li&gt;每个服务的 sidecar（东西向流量）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio 项目旨在成为服务网格平台，用户通过平台，可以在此基础上构建工具来驱动服务和应用程序之间的网络控制。Istio 用于配置 Envoy 的领域特定配置对象主要围绕以下对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/docs/reference/config/networking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway&lt;/a&gt;：定义一个共享代理组件（能够集群进入），该组件指定可用于负载均衡和路由流量的协议、TLS、端口和主机/权限&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/docs/reference/config/networking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VirtualService&lt;/a&gt;：如何与特定服务交互的规则；可以指定诸如路由匹配、超时、重试等内容&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/docs/reference/config/networking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DestinationRule&lt;/a&gt;：如何与特定服务进行交互的规则，包括熔断、负载均衡、mTLS 策略、服务的子集定义等&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/docs/reference/config/networking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ServiceEntry&lt;/a&gt;：显式地将服务添加到 Istio 的服务注册中心&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocpfgj5dj30ma09dq3j_hudaab214a10b5ea8220dc49e672fe0b46_62667_91e8d0cb20aa4a7720f8e925ed5a689f.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocpfgj5dj30ma09dq3j_hudaab214a10b5ea8220dc49e672fe0b46_62667_a4d93c0189fd038ac1e500769e166193.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocpfgj5dj30ma09dq3j_hudaab214a10b5ea8220dc49e672fe0b46_62667_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocpfgj5dj30ma09dq3j_hudaab214a10b5ea8220dc49e672fe0b46_62667_91e8d0cb20aa4a7720f8e925ed5a689f.webp&#34;
               width=&#34;760&#34;
               height=&#34;319&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;运行在 Kubernetes 中的所有这些配置对象都实现为 &lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CustomResourceDefinitions&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/heptio/contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heptio/VMWare Contour&lt;/a&gt; 旨在作为 Kubernetes ingress 网关，并具有一个简化的特定于域的配置模型，具有 CustomResourceDefinition （CRD）风格和 &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes ingress 资源&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/heptio/contour/blob/master/docs/ingressroute.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IngressRoute&lt;/a&gt; 是一个 Kubernetes CRD，它提供一个位置来指定 Contour 代理的配置&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/heptio/contour/blob/master/docs/annotations.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ingress 资源支持&lt;/a&gt;，允许你在你的 Kubernetes Ingress 资源上指定注解。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLly1g1oao8vmp8j30hc05gaa8_hu3ba9dec43ea0a7f5fcff8f4fd2a9600e_31278_a23fae49f0a45d8aaab84750256a0009.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLly1g1oao8vmp8j30hc05gaa8_hu3ba9dec43ea0a7f5fcff8f4fd2a9600e_31278_12ae9e5a219d2616492b3e2578e06fe7.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLly1g1oao8vmp8j30hc05gaa8_hu3ba9dec43ea0a7f5fcff8f4fd2a9600e_31278_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLly1g1oao8vmp8j30hc05gaa8_hu3ba9dec43ea0a7f5fcff8f4fd2a9600e_31278_a23fae49f0a45d8aaab84750256a0009.webp&#34;
               width=&#34;624&#34;
               height=&#34;196&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 项目&lt;/a&gt;中，将可用的配置对象分成两个级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为用户提供最佳符合人机工程学的面向用户的配置，并为可扩展性留下选项（下一节将详细介绍）&lt;/li&gt;
&lt;li&gt;抽象 Envoy 但不明确用于直接用户操作的低层配置。较高级别的对象被转换为这种较低级别的表示形式，最终用于转换为 Envoy xDS api。这样设计的原因将在下一节中说明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于用户，Gloo 关注拥有路由配置的团队，因为路由的语义（以及可用的转换/聚合功能）受到 API 和微服务开发人员的严重影响。对于面向用户的 API 对象，我们使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gateway/api/v1/gateway.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway&lt;/a&gt;：指定特定监听器端口上可用的路由和 API 端点，以及每个 API 的安全性&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gateway/api/v1/virtual_service.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VirtualService &lt;/a&gt;：将 API 路由分组到一组“虚拟 API”中，这些“虚拟 API”可以路由到支持的函数（gRPC、http/1、http/2、lambda 等）；使开发人员能够控制路由如何处理&lt;a href=&#34;&#34;&gt;不同的转换&lt;/a&gt;，从而尝试将前端 API 与后端 API（以及后端可能引入的任何破坏性更改）分离开来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，这些对象与这些对象的 Istio 变体不同。&lt;/p&gt;
&lt;p&gt;Gloo 中的面向用户的 API 对象驱动较低层的对象，这些对象最终用于派生 Envoy xDS 配置。例如，Gloo 的底层核心 API 对象是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstream&lt;/a&gt;：获取关于后端集群和在此上公开的函数的详细信息。您可以将 Gloo 上游与 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/cds.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 集群&lt;/a&gt;松散地关联起来，但有一个很大的区别:上游可以理解特定端点上可用的实际服务功能（换句话说，了解 &lt;code&gt;/foo/bar&lt;/code&gt; 和 &lt;code&gt;/bar/wine&lt;/code&gt;，包括它们的预期参数和参数结构，而不仅仅是 &lt;code&gt;hostname:port&lt;/code&gt;），后文会详细解释。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy&lt;/a&gt;：代理是抽象我们可以应用于 Envoy 的所有配置的主要对象。这包括监听器、虚拟主机、路由和上行流。高级对象（VirtualService，Gateway等）用于驱动这个低级代理对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocrrdccrj30o20dxabd_hu28d5638a97c2c893b74c2247b2177cd1_91343_acde3b42ae9fabf47c546978209d85aa.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocrrdccrj30o20dxabd_hu28d5638a97c2c893b74c2247b2177cd1_91343_612291cfac4c3e0af71580f9425ce74a.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocrrdccrj30o20dxabd_hu28d5638a97c2c893b74c2247b2177cd1_91343_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocrrdccrj30o20dxabd_hu28d5638a97c2c893b74c2247b2177cd1_91343_acde3b42ae9fabf47c546978209d85aa.webp&#34;
               width=&#34;760&#34;
               height=&#34;440&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Gloo 控件的两层配置之间的分离允许我们在保持配置 Envoy 的简单抽象的同时扩展 Gloo 控制平面功能。本系列的第 4 部分将对此进行更详细的解释。&lt;/p&gt;
&lt;p&gt;在前面的三个示例中（Istio、Contour、Gloo），每个控制平面公开一组特定于域的配置对象，这些对象以用户为中心，但最终转换为 Envoy 配置，并通过 xDS 数据面 API 公开。这提供了 Envoy 与用户的工作方式及其工作流之间的解耦。尽管我们已经看到了一些为抽象 Envoy 创建更关注用户和工作流的领域特定配置的例子，但这并不是构建 Envoy 控制平面的唯一方法。&lt;a href=&#34;https://www.slideshare.net/IvanKruglov/ivan-kruglov-introducing-envoybased-service-mesh-at-bookingcom-version-7&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Booking.com 有一个很棒的演示&lt;/a&gt;，介绍了他们是如何与 Envoy 配置保持更紧密的联系，并使用一个引擎将所有不同团队的配置片段合并到实际的 Envoy 配置中。&lt;/p&gt;
&lt;p&gt;除了考虑特定于域的配置之外，还应该考虑 API/对象模型的特定接触点。例如，Kubernetes 非常关注 YAML 和资源文件。您可以构建一个更特定于领域的 CLI 工具（就像 &lt;a href=&#34;https://docs.openshift.com/enterprise/3.2/dev_guide/new_app.html#dev-guide-new-app&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenShift 对 oc CLI&lt;/a&gt; ，&lt;a href=&#34;https://istio.io/docs/reference/commands/istioctl/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 对 istioctl&lt;/a&gt; ， &lt;a href=&#34;https://gloo.solo.io/cli/glooctl/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 对 glooctl&lt;/a&gt; 所做的那样）。&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;当您构建一个 Envoy 控制平面时，您是带着一个特定的意图或一组架构/用户来做这件事的。您应该考虑到这一点，并构建适合您的用户并改进您的 Envoy 操作工作流使其符合人体工程学的、有主见的特定于领域的 API。&lt;a href=&#34;https://github.com/solo-io/gloo/graphs/contributors&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 团队&lt;/a&gt;建议研究现有的 Envoy 控制平面实现，只有在其他实现都不合适的情况下才构建自己的 Envoy 控制平面。Gloo 的控制为扩展和定制奠定了基础。我们将在下一篇文章中看到，可以构建一个完全可扩展的控制平面，以适应许多不同的用户、工作流和操作约束。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Envoy Proxy构建控制平面指南</title>
      <link>https://cloudnative.to/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/</link>
      <pubDate>Wed, 06 Mar 2019 12:17:02 +0800</pubDate>
      <guid>https://cloudnative.to/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh-badb6c36a2af&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编者案&#34;&gt;编者案&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Envoy 作为最受欢迎的早期网络组件，现在已经可以说是云原生架构中的通用数据平面。本文作者指引我们更方便的使用Envoy，及其定制控制平面，作者通过收集到的数据给出定制控制平面不同的意见，非常中肯，后续系列会更深入，欢迎关注该系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 最近成为一个受欢迎的网络组件。 几年前 Matt Klein &lt;a href=&#34;https://blog.envoyproxy.io/the-universal-data-plane-api-d15cec7a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;写了一篇博客&lt;/a&gt; ，讨论了Envoy的动态配置API，以及Envoy发展的历史和动机。 他称该博客为“通用数据平面API”。 由于许多其他项目采用&lt;a href=&#34;https://www.envoyproxy.io/community&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 作为其产品的核心组件，因此对于应用程序/L7网络解决方案而言，毫不夸张地说，“Envoy已成为云原生架构中的通用数据平面”，而不仅仅是简单建立了API标准。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfoc0c9yj20dm07faap_hu8ae9bc977729b1261c5488411d43efc6_45035_d73177a85f459e7e9ae645c9c638a24a.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfoc0c9yj20dm07faap_hu8ae9bc977729b1261c5488411d43efc6_45035_2e55f3eb8e7f29cf53d207262cf81594.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfoc0c9yj20dm07faap_hu8ae9bc977729b1261c5488411d43efc6_45035_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfoc0c9yj20dm07faap_hu8ae9bc977729b1261c5488411d43efc6_45035_d73177a85f459e7e9ae645c9c638a24a.webp&#34;
               width=&#34;490&#34;
               height=&#34;267&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，由于 &lt;a href=&#34;https://blog.envoyproxy.io/the-universal-data-plane-api-d15cec7a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy的通用数据平面API&lt;/a&gt; ，我们已经看到了许多 &lt;em&gt;管理层&lt;/em&gt; 的实现， 用于配置和驱动基于Envoy的基础架构。 我们将深入探讨为Envoy构建控制平面所需的内容，以便您可以使用此信息来评估哪种类型的基础架构最适合您的组织和使用情况。 因为这是一个广泛的主题，我们将在未来几天发布的多部系列博客中解决它。&lt;/p&gt;
&lt;p&gt;在EnvoyCon/KubeCon上 有一些 &lt;a href=&#34;https://blog.envoyproxy.io/envoycon-recap-579d53576511&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;精彩的演讲&lt;/a&gt; ，一些组织分享了他们采用Envoy的经验，包括他们如何构建自己的控制平面。 人们选择自己建立控制平面的一些原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现有的解决方案，建立在已有不同数据平面的控制平面，需要改造Envoy（与已有方案且冲突）&lt;/li&gt;
&lt;li&gt;为没有任何现有开源或其他Envoy控制平面（即VM，AWS ECS等）的基础架构构建（商业公司必须重新建方案）&lt;/li&gt;
&lt;li&gt;不需要使用Envoy的所有功能; 只是一个子集（功能太多，需要精简）&lt;/li&gt;
&lt;li&gt;首选适用于Envoy配置的特定于域的API/对象模型，以更好地适应其工作流程/世界观（与已有方案冲突）&lt;/li&gt;
&lt;li&gt;当其组织准备部署时，暂时没有成熟的控制平面（走的太快）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mforyrc1j20go0digsn_hue04fb6da5ae3907e79baa0948d49cfe2_109615_299b4200e7b50938d5e8b268bfc26bd9.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mforyrc1j20go0digsn_hue04fb6da5ae3907e79baa0948d49cfe2_109615_feae416aa92cd7eaa0dea21fc7cb0e50.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mforyrc1j20go0digsn_hue04fb6da5ae3907e79baa0948d49cfe2_109615_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mforyrc1j20go0digsn_hue04fb6da5ae3907e79baa0948d49cfe2_109615_299b4200e7b50938d5e8b268bfc26bd9.webp&#34;
               width=&#34;600&#34;
               height=&#34;486&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;若是因为一些早期采用者建立了他们自己的定制控制平面，并不意味着你现在也要自己重新开发控制平面。 因为Envoy构建控制平面的项目在去年已经成熟了很多，若你决定重新开发另一个控制平面前你应该探索使用它们。 其次，正如Datawire的人们发现的那样，&lt;a href=&#34;https://twitter.com/danielbryantuk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;丹尼尔·布莱恩特&lt;/a&gt; 最近明确表示， &lt;a href=&#34;https://www.infoq.com/articles/ambassador-api-gateway-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为Envoy建造一个控制平面并不适合胆小的人&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我参与&lt;/a&gt; 了 &lt;a href=&#34;https://github.com/istio/istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;几个&lt;/a&gt;为Envoy构建控制平面的&lt;a href=&#34;https://github.com/solo-io/gloo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开源项目&lt;/a&gt; 。 例如， &lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt; 是 &lt;a href=&#34;https://medium.com/solo-io/announcing-gloo-the-function-gateway-3f0860ef6600&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一个功能网关&lt;/a&gt; ，可以充当非常强大的Kubernetes入口，API网关或功能网关，以简化单体应用到微服务的过渡。 Gloo &lt;a href=&#34;https://gloo.solo.io/introduction/architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;有一个Envoy的控制平面&lt;/a&gt; ，我们可以在这一系列的帖子中作为一个例子来说明如何构建一个简单的抽象，允许在你需要的控制点上实现可插拔性和可扩展性。 您可以用作参考的其他可靠的控制平面实现是 &lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/heptio/contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heptio Contour&lt;/a&gt; 我们将在整个系列博客中使用这些作为很好的例子。 如果不出意外，您可以了解Envoy控制平面存在哪些选项，并使用它来指导您的实施，如果您必须走这条路。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpbj0hgj21200a840t_huee3c2bac1b3d2713ae16ec61b6c9df2a_124078_6aaf308f76bb1b435deb0087ecfe2110.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpbj0hgj21200a840t_huee3c2bac1b3d2713ae16ec61b6c9df2a_124078_b2e5f9814c349379607a6f32d75ebee2.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpbj0hgj21200a840t_huee3c2bac1b3d2713ae16ec61b6c9df2a_124078_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpbj0hgj21200a840t_huee3c2bac1b3d2713ae16ec61b6c9df2a_124078_6aaf308f76bb1b435deb0087ecfe2110.webp&#34;
               width=&#34;760&#34;
               height=&#34;205&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个博客系列中，我们将看看以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用动态更新机制的Envoy路由、服务发现和其他配置&lt;/li&gt;
&lt;li&gt;确定构成控制平面的组件，包括后端存储、服务发现API、安全组件等。&lt;/li&gt;
&lt;li&gt;为您和组织最适合的用例，建立任何特定于域的配置对象和API&lt;/li&gt;
&lt;li&gt;考虑如何最好地将控制平面插入您需要的地方&lt;/li&gt;
&lt;li&gt;部署各种控制平面组件的选项&lt;/li&gt;
&lt;li&gt;通过控制平面的测试工具进行思考&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了开始这个系列，我们来看看使用Envoy的动态配置API在运行时更新Envoy以处理拓扑和部署的变化。&lt;/p&gt;
&lt;h2 id=&#34;使用xds-api动态配置envoy&#34;&gt;使用xDS API动态配置Envoy&lt;/h2&gt;
&lt;p&gt;构建在Envoy之上的主要优势之一是它的数据平面API。 使用数据平面API，我们可以 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/intro/arch_overview/dynamic_configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;动态配置Envoy的大部分重要运行时设置&lt;/a&gt; 。 Envoy通过其xDS API的配置 &lt;a href=&#34;https://blog.envoyproxy.io/embracing-eventual-consistency-in-soa-networking-32a5ee5d443d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最终一致的&lt;/a&gt;  - 即无法影响集群中所有代理的“原子更新”。 当控制平面具有配置更新时，它通过xDS API使它们可用于数据平面代理，并且每个代理将彼此独立地应用这些更新。&lt;/p&gt;
&lt;p&gt;以下是我们可以通过xDS动态配置的Envoy运行时模型的部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/listeners/lds#config-listeners-lds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;监听器发现服务API -&lt;/a&gt; 用于发布监听流量的端口的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/listeners/lds#config-listeners-lds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LDS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/api-v2/api/v2/eds.proto#envoy-api-file-envoy-api-v2-eds-proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;端点发现服务API-&lt;/a&gt; 用于服务发现的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/api-v2/api/v2/eds.proto#envoy-api-file-envoy-api-v2-eds-proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EDS&lt;/a&gt; ，&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/http_conn_man/rds#config-http-conn-man-rds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;路由发现服务API-RDS&lt;/a&gt; 用于流量路由决策&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/cluster_manager/cds#config-cluster-manager-cds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;集群发现服务 -&lt;/a&gt; 用于后端服务的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/cluster_manager/cds#config-cluster-manager-cds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CDS&lt;/a&gt; ，我们可以将流量路由到该服务&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/secret&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;secret发现服务 -&lt;/a&gt; 用于分发Secret的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/secret&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SDS&lt;/a&gt; （证书和密钥）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpqxtkyj20p00gm0yz_hued01192646f9d6f8fd00edb2232ffb64_159416_0c1afe2df3b97beb6f7307a91377b67e.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpqxtkyj20p00gm0yz_hued01192646f9d6f8fd00edb2232ffb64_159416_38f347eb1be2ded7ed2a98ff57214ba7.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpqxtkyj20p00gm0yz_hued01192646f9d6f8fd00edb2232ffb64_159416_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpqxtkyj20p00gm0yz_hued01192646f9d6f8fd00edb2232ffb64_159416_0c1afe2df3b97beb6f7307a91377b67e.webp&#34;
               width=&#34;760&#34;
               height=&#34;505&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;API使用 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/overview/v2_overview#config-overview-v2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 Protocol Buffers&lt;/a&gt; 定义， 甚至还有一些参考实现可用于引导您自己的控制平面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/go-control-plane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go控制平面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/java-control-plane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;java的控制平面&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然这些领域（LDS/EDS/RDS/CDS/SDS，一起“xDS”）中的每一个都是动态可配置的，但这并不意味着您必须动态配置所有内容。 您可以拥有静态定义的部分组合以及动态更新的部分组合。 例如，要实现一种 &lt;code&gt;endpoints&lt;/code&gt; 预期为动态但 &lt;code&gt;clusters&lt;/code&gt; 在部署时众所周知 的服务发现类型 ，您可以静态定义 &lt;code&gt;clusters&lt;/code&gt; 并使用 Envoy中 的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/api-v2/api/v2/eds.proto#envoy-api-file-envoy-api-v2-eds-proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;端点发现服务&lt;/a&gt; 。 如果您不确定在部署时将使用哪些 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/intro/arch_overview/terminology&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;上游集群，&lt;/a&gt; 则可以使用 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/cluster_manager/cds#config-cluster-manager-cds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;集群发现服务&lt;/a&gt; 动态地找到那些。 关键是，您可以构建一个工作流程和流程，静态配置您需要的部分，同时使用动态xDS服务来发现运行时所需的部分。 您看到不同的控制平面实现的原因之一并不是每个人都有一个完全动态和可互换的环境，其中所有部分都应该是动态的。 在给定现有约束和可用工作流程的情况下，采用最适合您系统的动态级别。&lt;/p&gt;
&lt;p&gt;在Gloo的情况下，我们使用&lt;a href=&#34;https://github.com/solo-io/gloo/blob/ac3bddf202423b297fb909eb6eff498745a8c015/projects/gloo/pkg/xds/envoy.go#L76&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于go-control-plane的控制平面&lt;/a&gt; 来实现xDS API以服务Envoy的动态配置。 与Heptio Contour一样，Istio也使用此实现。 此控制平面API利用 &lt;a href=&#34;https://grpc.io/docs/guides/concepts.html#server-streaming-rpc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC流&lt;/a&gt; 调用和存根API，因此您可以使用实现填充它。 &lt;a href=&#34;https://github.com/turbinelabs/rotor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Turbine Labs’ Rotor项目&lt;/a&gt; 是另一个不幸被弃用但可以用来学习的&lt;a href=&#34;https://github.com/turbinelabs/rotor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;项目&lt;/a&gt; 。 这是将Envoy的数据平面API与控制平面集成的高效方法。&lt;/p&gt;
&lt;p&gt;gRPC流不是更新Envoy配置的唯一方式。 在&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.5.0/api-v1/api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以前版本的Envoy xDS API中&lt;/a&gt; ，轮询是确定新配置是否可用的唯一选项。 虽然这是可以接受的，并且符合“最终一致”配置更新的标准，但它在网络和计算使用方面效率都较低。 也可能难以适当地调整轮询配置以减少浪费的资源。&lt;/p&gt;
&lt;p&gt;最后，一些Envoy管理实施选择生成 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/v2_overview#static&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;静态Envoy配置文件，&lt;/a&gt; 并定期替换Envoy磁盘上的配置文件，然后执行 &lt;a href=&#34;https://blog.envoyproxy.io/envoy-hot-restart-1d16b14555b5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy进程&lt;/a&gt; 的 &lt;a href=&#34;https://blog.envoyproxy.io/envoy-hot-restart-1d16b14555b5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;热重新加载&lt;/a&gt; 。 在高度动态的环境中（如Kubernetes，但实际上是任何基于ephemeral-compute的平台），此文件生成，交付，热重启等的管理可能变得难以处理。 Envoy最初是在一个执行此类更新的环境中运行的（Lyft，它是在哪里创建的），但它们逐渐转向使用xDS API。&lt;/p&gt;
&lt;h2 id=&#34;takeaway&#34;&gt;Takeaway&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/solo-io/gloo/graphs/contributors&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo团队&lt;/a&gt; 认为使用gRPC流和xDS API是实现Envoy动态配置和控制的理想方式。 同样，如果您不需要，并非所有Envoy配置都应动态提供，但是如果您在高度动态的环境中运行（例如，Kubernetes），则动态配置Envoy的选项至关重要。 其他环境可能没有这种需求。 无论哪种方式，动态的g​​RPC流API都是理想的选择。 这种方法的一些好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件驱动的配置更新; 当配置在控制平面中可用时，配置被推送到Envoy&lt;/li&gt;
&lt;li&gt;无需轮询更改&lt;/li&gt;
&lt;li&gt;没有必要热加载Envoy&lt;/li&gt;
&lt;li&gt;没有中断流量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;下一步是什么&#34;&gt;下一步是什么&lt;/h2&gt;
&lt;p&gt;在第一部分中，我们通过介绍xDS API以及为Envoy提供动态配置的不同选项，为如何为Envoy构建控制平面建立了一些基本背景。 在接下来的部分中，将在几天内发布，将涵盖将您的控制平面分解为可部署组件，确定您需要哪些部分，特定于域的配置对象模型，以及如何考虑控件的可插拔性平面。 关注twitter（ &lt;a href=&#34;https://twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt; ， &lt;a href=&#34;https://twitter.com/soloio_inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@ solio_in&lt;/a&gt; ）或博客（ &lt;a href=&#34;https://medium.com/solo-io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://medium.com/solo-io&lt;/a&gt; ）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>应用程序安全性和正确性的责任不能推卸给Istio和任何服务网格</title>
      <link>https://cloudnative.to/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/</link>
      <pubDate>Thu, 23 Aug 2018 15:31:39 +0800</pubDate>
      <guid>https://cloudnative.to/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/</guid>
      <description>&lt;p&gt;我最近在讨论集成服务的演进以及服务网格的使用，特别是关于 Istio 。自从2017年1月我听说了 Istio 以来，我一直很兴奋，事实上我是为这种新技术感到兴奋，它可以帮助组织构建微服务以及原生云架构成为可能。也许你可以说，因为我已经写了很多关于它的文章（请关注 &lt;a href=&#34;https://twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt; 的动态)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/the-hardest-part-of-microservices-calling-your-services/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Hardest Part of Microservices: Calling Your Services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/00-microservices-patterns-with-envoy-proxy-series/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microservices Patterns With Envoy Sidecar Proxy: The series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Network Functions With ESBs, API Management, and Now.. Service Mesh?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/comparing-envoy-and-istio-circuit-breaking-with-netflix-hystrix/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Comparing Envoy and Istio Circuit Breaking With Netflix OSS Hystrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/traffic-shadowing-with-istio-reduce-the-risk-of-code-release/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traffic Shadowing With Istio: Reducing the Risk of Code Release&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/advanced-traffic-shadowing-patterns-for-microservices-with-istio-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Advanced Traffic-shadowing Patterns for Microservices With Istio Service Mesh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/how-a-service-mesh-can-help-with-microservices-security/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How a Service Mesh Can Help With Microservices Security&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio 建立在容器和 Kubernetes 的一些目标之上：提供有价值的分布式系统模式作为语言无关的习惯用法。例如：Kubernetes 通过执行启动/停止、健康检查、缩放/自动缩放等来管理容器，而不管容器中实际运行的是什么。类似的， Istio 可以通过在应用程序容器之外透明地解决可靠性、安全性、策略和通信方面的挑战。&lt;/p&gt;
&lt;p&gt;随着 &lt;a href=&#34;https://istio.io/blog/2018/announcing-1.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 1.0&lt;/a&gt; 版本在2018年7月31日的发布，我们看到 Istio 的使用和采纳有了很大的增加。我看到的一个问题是“如果 Istio 为我提供了可靠性，那么在应用程序中我还需要在担心它吗？”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的答案是：绝对要！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;就在前一年，我写了一篇文章&lt;/a&gt;，其中包含了这一区别，但并不是足够有力；这篇文章是我试图纠正这一点，&lt;a href=&#34;https://www.slideshare.net/ceposta/evolution-of-integration-and-microservices-patterns-with-service-mesh-107786281&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;并建立在前面提到的谈话的基础上&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因此，设置一些上下文：Istio 提供了应用程序网络的“可靠性”能力，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动重试（automatic retry）&lt;/li&gt;
&lt;li&gt;重试配额/预算（retry quota/budget）&lt;/li&gt;
&lt;li&gt;连接超时（connection timeout）&lt;/li&gt;
&lt;li&gt;请求超时（request timeout）&lt;/li&gt;
&lt;li&gt;客户端负载均衡（client-side load balancing）&lt;/li&gt;
&lt;li&gt;断路器（circuit breaking）&lt;/li&gt;
&lt;li&gt;隔离层（bulkheading）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在处理分布式系统时，这些功能是必不可少的。网络并不是可靠的，并且破坏了我们在一个整体中所拥有的很多好的安全假设/抽象。我们要么迫切的解决这些问题，要么遭受系统范围内不可预测的停机。&lt;/p&gt;
&lt;h2 id=&#34;退一步说&#34;&gt;退一步说&lt;/h2&gt;
&lt;p&gt;这里更大的问题实际上是让应用程序相互通信来解决一些业务的问题。这就是为什么我们编写软件的原因，最终用来提供某种商业价值。同时该软件也使用一些商业领域模型，例如：“客户”、“购物车”、“账户”等。从领域驱动的设计来看，每个服务可能在理解这些概念上都略微有不同。&lt;/p&gt;
&lt;p&gt;这里有一些不太明确的概念和更大的业务约束（例如：客户可以由名称和电子邮件来确认唯一性，或者客户只能拥有一种类型的支票账户等），以及不可靠的网络和整个不可预知的基础设施（假定可以构建这样的服务，可以或者失败）使构建正确是非常困难的。&lt;/p&gt;
&lt;h2 id=&#34;端到端的正确性和安全性&#34;&gt;端到端的正确性和安全性&lt;/h2&gt;
&lt;p&gt;然而，事实上是，在构建正确和安全的应用程序方面，这样的责任归属到了应用程序上（以及所有它支持的人）。我们可以尝试将更低级别的可靠性构建到系统的性能或优化的组件中，但总的责任还是在应用程序中。1984年 Saltzer、Reed 和 Clark 在“系统设计中的端到端论证”中提到了这一原则。具体地说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只有在对通信系统端点的应用程序足够了解的情况下，才能完全正确的实现所讨论的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里，“功能”是应用程序的需求之一，比如“预订”或“向购物车中添加商品”。这种功能不能概括为通信系统或其组件/基础设置（这里的通信系统指的是网络、中间件和任何为应用程序提供基础设施的工作）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因此，提供被质疑的功能作为通信系统本身的特质是不可能的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，我们可以做一些事情以保证通信系统的部分可靠，这样有助于实现更高层次的应用程序的需求。我们做这些事情后可以优化部分区域，这样不至于过于担心这样的问题，但应用程序不能完全忽略这些事情：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有时，通信系统提供的非完整的版本的功能，可能对于增强性能很有用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：在 Saltzer 的论文中，他们使用从应用程序 A 传输文件到应用程序 B 的示例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwgy1fuibtn8kvfj31fc0v2ju4.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们需要做什么（安全）来保证文件被正确的传送到？在图中的任何一点都有能出现错误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存储机制可能有失败的区域/移位的比特/损坏，所以当应用程序 A 读取一个文件时，读取的是一个错误的文件；&lt;/li&gt;
&lt;li&gt;应用程序在读取文件到内存中或者发送文件时存在 bug ；&lt;/li&gt;
&lt;li&gt;网络可能混淆字节的顺序，文件部分重复等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以进行优化，例如使用更可靠的传输，如 TCP 协议或消息队列，但是 TCP 不知道“正确传输文件”的语意，所以我们期望的最好结果至少是当我们在网络上处理事情时，网络是可靠的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwgy1fuiihqrv73j31es0eqjsf.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了完整的实现端到端的正确性，我们可能需要使用一些类似文件校验的东西，与文件一起在文件初始化时写入，然后在 B 接收文件时校验其校验和。然而，我们在校验传输的正确性（实现细节），其职责在于找出解决方案并使其正确，而不是使用 TCP 或者消息队列。&lt;/p&gt;
&lt;h2 id=&#34;典型的模式是什么样的&#34;&gt;典型的模式是什么样的？&lt;/h2&gt;
&lt;p&gt;为了解决分布式应用程序中应用程序的正确性和安全性，我们可以使用一些模式。在早些时候，我们提到了 Istio 提供给我们的一些可靠的模式，但这些并不是唯一的。通常，有两类模式可以帮助我们正确和安全的构建应用程序，并且这两类模式是相关的。我们称这类位“应用程序集成”和“应用程序网络”。两者都是应用程序的责任。让我们来看看：&lt;/p&gt;
&lt;h3 id=&#34;应用程序集成&#34;&gt;应用程序集成&lt;/h3&gt;
&lt;p&gt;这些模式以如下这样的形式出现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用排序、多播和编排 （Call sequencing, multicasting, and orchestration）&lt;/li&gt;
&lt;li&gt;聚合响应、转换消息语义、拆分消息等 （Aggregate responses, transforming message semantics, splitting messages, etc）&lt;/li&gt;
&lt;li&gt;原子性、一致性问题、saga模式 （Atomicity, consistency issues, saga pattern）&lt;/li&gt;
&lt;li&gt;反腐败层、适配器、边界转换 （Anti-corruption layers, adapters, boundary transformations）&lt;/li&gt;
&lt;li&gt;消息重试、排重/幂等性 （Message retries, de-duplication/idempotency）&lt;/li&gt;
&lt;li&gt;消息重新排序 （Message re-ordering）&lt;/li&gt;
&lt;li&gt;缓存 （Caching）&lt;/li&gt;
&lt;li&gt;消息级路由 （Message-level routing）&lt;/li&gt;
&lt;li&gt;重试、超时 （Retries, timeouts）&lt;/li&gt;
&lt;li&gt;后端/遗留系统集成 （Backend/legacy systems integration）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用一个简单的例子，”在购物车中添加一个项目“，我们可以来说明这个概念：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwgy1fuikdn3j02j31ks0oa77e.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当一个用户在点击“加入购物车”功能时，用户期望看到的是商品已经加入到他们的购物车中。在系统中，这可能涉及到对推荐引擎的协调、调用顺序（嘿，我们把它加入到购物车中了，想知道是否计算推荐报价来配合它）、库存服务和其他服务等，然后再调用服务插入购物车。我们需要能够将消息转换到不同的后端，处理失败（并回滚我们发起的任何更改），并且在每个服务中我们都需要可以处理重复。如果由于某种原因，调用变得很慢，但用户又再次点击了“加入购物车”时怎么办呢？如果用户这么做了，那么再多可靠的基础设施也拯救不了我们；我们需要在应用程序中检测和实现重复检查/幂等服务。&lt;/p&gt;
&lt;h3 id=&#34;应用程序网络&#34;&gt;应用程序网络&lt;/h3&gt;
&lt;p&gt;这些模式以如下这样的形式出现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动重试 （automatic retry）&lt;/li&gt;
&lt;li&gt;重试指标/预算 （retry quota/budget）&lt;/li&gt;
&lt;li&gt;连接超时 （connection timeout）&lt;/li&gt;
&lt;li&gt;请求超时 （request timeout）&lt;/li&gt;
&lt;li&gt;客户端负载均衡（client-side load balancing）&lt;/li&gt;
&lt;li&gt;熔断器 （circuit breaking）&lt;/li&gt;
&lt;li&gt;隔离层 （bulkheading）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但在通过网络进行通信的应用程序时，还存在其他复杂的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;金丝雀展示 （Canary rollout）&lt;/li&gt;
&lt;li&gt;流量路由 （Traffic routing）&lt;/li&gt;
&lt;li&gt;指标集合 （Metrics collection）&lt;/li&gt;
&lt;li&gt;分布式跟踪 （Distributed tracing）&lt;/li&gt;
&lt;li&gt;影子流量 （Traffic shadowing）&lt;/li&gt;
&lt;li&gt;故障注入 （Fault injection）&lt;/li&gt;
&lt;li&gt;健康检查 （Health checking）&lt;/li&gt;
&lt;li&gt;安全 （Security）&lt;/li&gt;
&lt;li&gt;组织策略 （Organizational policy）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何使用这么模式&#34;&gt;如何使用这么模式？&lt;/h2&gt;
&lt;p&gt;在过去，我们试图将这些领域中的职责混合在一起。我们会做一些事情，比如把所有东西都推入集中式基础设施中，这样它基本上就100%可用的（应用程序网络+应用系统集成）。我们将应用程序的关注点放在集中的基础设施中（它本应该使我们更加敏捷），但是当需要对应用程序做快速的更改时，却遇到了瓶颈和僵化的问题。这些动态体现在我们实现企业服务总线（ESB）的方式上：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwly1fuit5y2mn6j311g0x418y.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;或者，我认为大型云厂商（Netflix、Amazon、Twitter 等）以及认识到了这些模式的“应用程序职责”方面，并将应用程序网络代码混合到应用程序中。想想像 Netflix OSS ，有用于断路器、客户端负载均衡、服务发现等不同的库。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwly1fuitn6o25ij30yy0x0408.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如你所知，围绕应用程序网络的 Netflix OSS 库非常关注 Java。当组织开始采用 Netflix OSS 以及类似spring-cloud-netflix 这样的衍生产品时，他们就会遇到这样一个事实：一旦开始添加其他语言时，操作这样的架构就变的令人望而却步了。Netflix 已经非常成熟了并且实现了自动化，但其他公司并不是 Netflix 。在尝试操作应用程序库和框架来解决应用程序联网问题是遇到的一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每种语言/框架对于这些关注点都有自己的实现方式。&lt;/li&gt;
&lt;li&gt;实现不会完全相同，它们会变化、不同，有时会有错误。&lt;/li&gt;
&lt;li&gt;如何管理、更新以及修补这些库？也就是说，生命周期的管理。&lt;/li&gt;
&lt;li&gt;这些库混淆了应用程序的逻辑。&lt;/li&gt;
&lt;li&gt;对开发人员给与了极大的信任。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio 和服务网格的总体目标是解决应用程序网络类问题。将这些问题的解决方案迁移到服务网格中是可操作性的优化。但这并不意味着它不再是应用程序的责任，而是意味着这些功能的实现存在于进程之外了，并且必须是可配置的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwly1fuiuklgkjxj31060wyt9g.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过这样做，我们可以通过以下操作来优化可操作性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这些功能的单一实现随处可见。&lt;/li&gt;
&lt;li&gt;一致的功能。&lt;/li&gt;
&lt;li&gt;正确的功能。&lt;/li&gt;
&lt;li&gt;应用程序运维人员和应用程序开发人员都可编程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio 和服务网格不允许你将责任推给基础设施，它们只是增加了一定程度的可靠性和可操作性的优化。就像在端到端的参数中一样，TCP 允许卸载应用程序的责任。&lt;/p&gt;
&lt;p&gt;Istio 有助于解决应用程序网络类问题，但是应用程序集成类问题是什么呢？幸运的是，对于开发人员来说，有大量的框架可以帮助他们来实现应用程序的集成。对于 Java 开发者我最喜欢的 Apache Camel ，它提供了许多编写正确和安全的应用程序所需的组件，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Call sequencing, multicasting, and orchestration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/aggregate-eip.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aggregate responses, transforming message semantics, splitting messages, etc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/saga-eip.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Atomicity, consistency issues, saga pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;Anti-corruption layers, adapters, boundary transformations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/idempotentConsumer-eip.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Message retries, de-duplication/idempotency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/resequence-eip.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Message reordering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Caching&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/content-based-router-eip.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Message-level routing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Retries, timeouts&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel/blob/master/components/readme.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Backend/legacy systems integration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwly1fuiv4suzo8j316m0xataq.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其他框架包括 &lt;a href=&#34;https://spring.io/projects/spring-integration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Integration&lt;/a&gt;，甚至还有 WSO2 中一个有趣的新编程语言 &lt;a href=&#34;https://ballerina.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ballerina&lt;/a&gt; 。请注意，重用现有的模式和构造是非常好的，特别是当这些模式相对于您选择的语言来说成熟时，但是这些模式都不需要您使用框架。&lt;/p&gt;
&lt;h1 id=&#34;智能端点和dumb管道&#34;&gt;智能端点和dumb管道&lt;/h1&gt;
&lt;p&gt;关于微服务，我有一个朋友提出了一个问题，关于微服务的“智能端点和dumb pipe”这句话很吸引人，但很简单，“让基础设施智能化”是个前提：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwly1fuivligg5sj30g50cygmn.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;管道仍然是dumb的；我们不是通过使用服务网格将应用程序的正确性和安全性的应用程序逻辑强制加入基础设施中。我们只是使它更可靠，优化运维方面，并简化应用程序必须实现的内容（不必为此负责）。如果你不认同或者有其他想法，请随时在 Twitter 上留言或联系 &lt;a href=&#34;https://twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;如果您想了解更多关于 Istio 的信息，请查看 &lt;a href=&#34;http://istio.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://istio.io&lt;/a&gt; 或者&lt;a href=&#34;http://blog.christianposta.com/our-book-has-been-released-introducing-istio-service-mesh-for-microservices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我写的关于 Istio 的书&lt;/a&gt; 。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
