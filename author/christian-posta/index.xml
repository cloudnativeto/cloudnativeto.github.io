<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Christian Posta | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/author/christian-posta/</link>
      <atom:link href="https://cloudnativecn.com/author/christian-posta/index.xml" rel="self" type="application/rss+xml" />
    <description>Christian Posta</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://cloudnativecn.com/author/christian-posta/avatar_hu6339992652106609130.jpg</url>
      <title>Christian Posta</title>
      <link>https://cloudnativecn.com/author/christian-posta/</link>
    </image>
    
    <item>
      <title>平台工程师的 LLM 入门指南</title>
      <link>https://cloudnativecn.com/blog/a-gentle-introduction-to-llms-for-platform-engineers/</link>
      <pubDate>Tue, 15 Apr 2025 11:33:31 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/a-gentle-introduction-to-llms-for-platform-engineers/</guid>
      <description>&lt;p&gt;技术世界日新月异。如今最火的莫过于 AI。作为平台工程师，我们本身已经身处技术栈的洪流之中：容器、Kubernetes、Prometheus、Istio、ArgoCD、Zipkin、Backstage.io …… 技术名词一个接一个，每一个都复杂、抽象且需要深入理解。现在又来了个 AI，让人头大。大多数平台工程师根本没有时间或精力去琢磨什么是 LLM、大模型，更别说在系统中落地使用。&lt;/p&gt;
&lt;p&gt;但现实是：AI 正悄然渗透进平台工程的世界。我们终将需要理解和掌握它。本文尝试用通俗易懂的方式，帮助平台工程师快速建立起对 LLM（大语言模型）的基础认知，并思考它在云原生领域中的应用场景。&lt;/p&gt;
&lt;h2 id=&#34;1-ai-是智能助手而不是天外来物&#34;&gt;1. AI 是“智能助手”而不是“天外来物”&lt;/h2&gt;
&lt;p&gt;你可能用过 Siri，也可能在酒店网站上与机器人客服打过交道。大多数情况下，它们都让人失望——要么不理解你的问题，要么机械地回复固定答案。它们多数基于传统的机器学习或预设规则，无法真正理解你的意图。&lt;/p&gt;
&lt;p&gt;相比之下，现代的 LLM（如 ChatGPT）已经可以处理极为复杂的语言输入，甚至能根据上下文推理、总结信息，和人类进行近乎自然的对话。&lt;/p&gt;
&lt;p&gt;但问题来了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对平台工程师来说，LLM 到底是什么？它跟传统 API、控制器、CI/CD 流水线有什么关系？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;别急，我们从一个核心问题讲起——“它能做什么”。&lt;/p&gt;
&lt;h2 id=&#34;2-llm-能做什么像人一样理解文档和日志&#34;&gt;2. LLM 能做什么：像人一样理解文档和日志&lt;/h2&gt;
&lt;p&gt;设想一个企业内部的聊天助手，帮助员工快速了解公司的规范、流程、产品特点。当客户提出技术问题时，员工可以通过这个助手快速定位问题、给出答案。这种助手背后就是一个被企业文档、知识库、过往案例、甚至源码“喂养”过的 LLM。&lt;/p&gt;
&lt;p&gt;对比一下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;功能&lt;/th&gt;
          &lt;th&gt;人工&lt;/th&gt;
          &lt;th&gt;LLM&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;阅读全部文档&lt;/td&gt;
          &lt;td&gt;慢&lt;/td&gt;
          &lt;td&gt;快&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;理解概念&lt;/td&gt;
          &lt;td&gt;可&lt;/td&gt;
          &lt;td&gt;可&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;回答问题&lt;/td&gt;
          &lt;td&gt;慢&lt;/td&gt;
          &lt;td&gt;快&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;LLM 的强大之处，在于它可以“吞掉”TB 级别的数据，然后从中提炼出概念与模式。听起来是不是像搜索引擎？不，它远远超过了搜索引擎。&lt;/p&gt;
&lt;h2 id=&#34;3-不只是搜索是理解&#34;&gt;3. 不只是搜索，是“理解”&lt;/h2&gt;
&lt;p&gt;传统搜索引擎依赖关键词匹配，比如你搜索“database timeout”，它只会返回包含这些词的文档。如果真实错误日志写的是“SQL connection lost”，你就查不到了。&lt;/p&gt;
&lt;p&gt;而 LLM 能理解“database timeout”与“SQL连接丢失”、“查询超时”、“数据库网络延迟”之间的语义联系。它不仅能从日志、trace 和文档中抓出相关内容，还能像一个资深工程师一样，总结出可能原因。&lt;/p&gt;
&lt;p&gt;这才是 LLM 的本事：&lt;strong&gt;不仅能搜索，还能理解、总结、推理。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-使用自然语言交互甚至可以生成代码&#34;&gt;4. 使用自然语言交互（甚至可以生成代码）&lt;/h2&gt;
&lt;p&gt;LLM 可以像人类一样理解自然语言，还能用自然语言输出答案。例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;问：引擎故障灯亮了，启动时有咔哒声，怎么回事？
答：可能是电池电量不足或启动电机故障……（给出详细分析）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更惊人的是，它还能生成代码、撰写文档、总结聊天记录、处理用户请求……它甚至可以读懂老旧系统的接口文档，然后自动生成集成代码！&lt;/p&gt;
&lt;p&gt;对于平台工程师而言，LLM 可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮你总结应用日志&lt;/li&gt;
&lt;li&gt;快速生成 Kubernetes YAML 或 Terraform 模板&lt;/li&gt;
&lt;li&gt;自动生成 CI/CD 流水线步骤说明&lt;/li&gt;
&lt;li&gt;撰写插件或脚本（例如 ArgoCD 的 Plugin、Backstage 的 Template）&lt;/li&gt;
&lt;li&gt;甚至为 SRE 分析告警和异常根因&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-如何接入-llm熟悉的-http-接口&#34;&gt;5. 如何接入 LLM？熟悉的 HTTP 接口！&lt;/h2&gt;
&lt;p&gt;最棒的是，LLM 通常通过 HTTP API 暴露服务。&lt;/p&gt;
&lt;p&gt;平台工程师早就熟悉这个套路了：写一个 HTTP 请求，传入 JSON，接收 JSON 响应。&lt;/p&gt;
&lt;p&gt;来看个例子，调用 OpenAI API 查询 Siri 是如何工作的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl https://api.openai.com/v1/chat/completions &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Content-Type: application/json&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Authorization: Bearer &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$OPENAI_API_KEY&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  -d &lt;span class=&#34;s1&#34;&gt;&amp;#39;{
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;    &amp;#34;model&amp;#34;: &amp;#34;gpt-3.5-turbo&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;    &amp;#34;messages&amp;#34;: [
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;      {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;        &amp;#34;role&amp;#34;: &amp;#34;user&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;        &amp;#34;content&amp;#34;: &amp;#34;Do you know how Siri works?&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;    ]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;  }&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;返回内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;chatcmpl-Avpw5BwQ4HypBRJFpqg3pPeeqDRwS&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;model&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;gpt-3.5-turbo-0125&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;choices&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;message&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;role&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;assistant&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;content&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Um... I mean... does it though?&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;usage&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;prompt_tokens&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;completion_tokens&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;107&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;total_tokens&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;121&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你会注意到几个要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求是一个标准的 HTTP API 调用&lt;/li&gt;
&lt;li&gt;请求体是自然语言，响应也是自然语言&lt;/li&gt;
&lt;li&gt;响应中包含 token 数量（因为使用 LLM 通常按 token 计费）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，作为平台工程师，你可以用 API Gateway 做调用限流、配额管理、成本控制，还可以做安全网关。&lt;/p&gt;
&lt;h2 id=&#34;6-背后的原理其实很简单但也很神奇&#34;&gt;6. 背后的原理其实很简单（但也很神奇）&lt;/h2&gt;
&lt;p&gt;虽然 LLM 看起来很“神”，但它的核心原理其实很简单：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接收一串单词（tokens），然后预测下一个最可能的词。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“The cow jumped over the ___” → “moon”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是这么简单的过程，重复进行数百次，就组成了一个完整回答。&lt;/p&gt;
&lt;p&gt;这个过程背后依赖大量训练数据和昂贵的硬件，但核心机制就是概率预测。&lt;/p&gt;
&lt;p&gt;推荐阅读： 👉 &lt;a href=&#34;https://blog.miguelgrinberg.com/post/how-llms-work-explained-without-math&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How LLMs work explained without math&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;7-注意事项不是银弹也有风险&#34;&gt;7. 注意事项：不是银弹，也有风险&lt;/h2&gt;
&lt;p&gt;LLM 带来了新的能力，也伴随着新的风险，尤其在平台工程中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;准确性&lt;/strong&gt;：LLM 可能自信满满地说错话，在合规或运维场景中可能带来严重问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据隐私&lt;/strong&gt;：若使用的是 SaaS 模型，输入的数据可能泄露（例如 OpenAI）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成本控制&lt;/strong&gt;：token 计费方式容易产生隐性费用，建议用网关管理配额&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应质量&lt;/strong&gt;：LLM 的输出不是文档原文，可能偏离主题或引入“幻觉”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;品牌风险&lt;/strong&gt;：若未设置过滤机制，LLM 输出可能引发不当或带偏见内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依赖过重&lt;/strong&gt;：部分用户过度依赖模型输出，忽略人工判断与验证&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合规问题&lt;/strong&gt;：如 GDPR、HIPAA 等法规限制使用 AI 处理敏感数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;建议设立审计机制、明确边界、设定使用准则。&lt;/p&gt;
&lt;h2 id=&#34;结语llm-是平台工程师的又一个工具&#34;&gt;结语：LLM 是平台工程师的又一个工具&lt;/h2&gt;
&lt;p&gt;LLM 不是什么魔法，它是一个模式识别系统，用海量数据训练而成，具备强大的语义理解和生成能力。&lt;/p&gt;
&lt;p&gt;对平台工程师而言，它就像：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;另一种“自动化”&lt;/li&gt;
&lt;li&gt;一种“超能运维助手”&lt;/li&gt;
&lt;li&gt;一种“文档理解引擎”&lt;/li&gt;
&lt;li&gt;一种“智能 CI/CD 脚本生成器”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以用它来增强现有平台的能力，提高团队效率，提升用户支持体验。
但你也需要理性对待它的局限，持续试验、迭代和评估其在你平台中的最佳用法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AI 正在来到平台工程的世界——拥抱它，不如先理解它。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Cilium 的控制平面升级之路：xDS API 的引入与应用</title>
      <link>https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/</link>
      <pubDate>Mon, 29 Jan 2024 20:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/</guid>
      <description>&lt;p&gt;在这篇博客中，我们将探讨当前的 Cilium 控制平面设计，&lt;a href=&#34;https://github.com/cilium/cilium/issues/30283&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大规模部署可能出现的限制的位置和原因&lt;/a&gt;，以及社区如何使用 CNCF 的 &lt;a href=&#34;https://github.com/cncf/xds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通用数据平面 (xDS) API&lt;/a&gt; 推进这个架构。&lt;/p&gt;
&lt;h2 id=&#34;了解-cilium-的控制平面架构&#34;&gt;了解 Cilium 的控制平面架构&lt;/h2&gt;
&lt;p&gt;Cilium 遵循基于“数据平面”和“控制平面”的常见网络架构。在 Cilium 中，数据平面部署在每个主机（或 Kubernetes 节点）上，包括用于处理 L3/L4 连接和策略的 eBPF 程序。为了简化起见，对于完整性，Cilium 还在其数据平面中使用 Envoy 代理处理 L7 策略，但我们将省略这部分。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/scaling-cilium-to-new-heights-with-xds/f1_hu8194293115077673131.webp 400w,
               /blog/scaling-cilium-to-new-heights-with-xds/f1_hu8831944030708452875.webp 760w,
               /blog/scaling-cilium-to-new-heights-with-xds/f1_hu17330839197977540555.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/f1_hu8194293115077673131.webp&#34;
               width=&#34;523&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Cilium 控制平面以 cilium-agent 守护程序的形式实现，部署在每个 Kubernetes 节点上。每个 cilium-agent 都是控制平面的单独、独立的实例。&lt;/p&gt;
&lt;p&gt;cilium-agent 连接到 Kubernetes API 服务器，监视配置更改，然后使用它来配置数据平面。cilium-agent 还将配置写入 Kubernetes API，表示正在其各自节点上创建的端点或标识。&lt;/p&gt;
&lt;p&gt;例如，当在 Kubernetes 节点上启动一个 Pod 时，cilium-agent 负责编写一个 CiliumEndpoint 自定义资源（CR），并可能是一个表示 Pod 网络标识的 CiliumIdentity CR。cilium-agent 还会更新与标识和端点映射相关的节点上的 eBPF 映射。其他 Kubernetes 节点上的 cilium-agent 也会监视这些新的 CiliumEndpoint 和 CiliumIdentity CR 的创建，并更新其本地的 eBPF 数据平面以执行策略。这种机制能够协调每个节点上的全局策略执行配置，以便所有节点看到相同的执行行为。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/scaling-cilium-to-new-heights-with-xds/f2_hu2478068168075565223.webp 400w,
               /blog/scaling-cilium-to-new-heights-with-xds/f2_hu11461153252939566865.webp 760w,
               /blog/scaling-cilium-to-new-heights-with-xds/f2_hu4187788596575714484.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/f2_hu2478068168075565223.webp&#34;
               width=&#34;760&#34;
               height=&#34;501&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;构建控制平面的最佳实践&#34;&gt;构建控制平面的最佳实践&lt;/h2&gt;
&lt;p&gt;我们以前 &lt;a href=&#34;https://www.solo.io/blog/building-a-control-plane-for-envoy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;曾多次在博客中&lt;/a&gt; &lt;a href=&#34;https://www.solo.io/blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;讨论过构建&lt;/a&gt; &lt;a href=&#34;https://www.solo.io/blog/why-the-control-plane-matters/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可扩展、安全、高效的控制平面的最佳实践&lt;/a&gt;。在深入研究如何扩展 Cilium 的控制平面之前，我们应该回顾一些这些最佳实践。&lt;/p&gt;
&lt;p&gt;网络架构中的数据平面应该尽可能简单，性能高，以及高效完成它需要做的事情：在本例中，来回传输字节，实施策略，并执行安全性。控制平面的作用是保护数据平面免受复杂性的干扰，以及任何分散数据平面核心任务的事物。&lt;/p&gt;
&lt;p&gt;另一方面，用户需要能够以最适合他们用户体验的形式指定配置和策略。很多时候，通过某种 &lt;a href=&#34;https://www.solo.io/blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;特定领域的配置格式&lt;/a&gt; 来实现。然后需要将这种更高级别的用户配置与基础设施状态相结合，并将其转化为较低级别的数据平面格式。转译是一半的战斗。还需要将较低级别的配置分发到数据平面，并高效地执行。这就是控制平面出现在画面中的地方。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/scaling-cilium-to-new-heights-with-xds/f3_hu4261563001142846400.webp 400w,
               /blog/scaling-cilium-to-new-heights-with-xds/f3_hu2968728725743550823.webp 760w,
               /blog/scaling-cilium-to-new-heights-with-xds/f3_hu2886241438425704438.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/f3_hu4261563001142846400.webp&#34;
               width=&#34;529&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;控制平面允许配置解耦并与平台的其他部分集成，这些部分随后可以通知数据平面。在许多方面，这个图表与我们构建应用程序时使用的 &lt;a href=&#34;https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/n-tier&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;三层架构&lt;/a&gt; 类似：表示层，解耦的业务逻辑层和数据存储。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/scaling-cilium-to-new-heights-with-xds/f4_hu5427380226969187166.webp 400w,
               /blog/scaling-cilium-to-new-heights-with-xds/f4_hu16853436292085068589.webp 760w,
               /blog/scaling-cilium-to-new-heights-with-xds/f4_hu10660222131653048004.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/f4_hu5427380226969187166.webp&#34;
               width=&#34;533&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在网络架构的情况下，控制平面层将处理读取/写入 Kubernetes API 和创建网络标识等敏感数据。由于它是一个单独的层，我们可以对其进行安全和硬化处理，并消除数据平面需要执行这些任务的权限。在许多情况下，虽然开始时更简单，但合并一些层会导致效率低下、安全问题和扩展/耦合问题。&lt;/p&gt;
&lt;h2 id=&#34;cilium-控制平面架构的扩展考虑&#34;&gt;Cilium 控制平面架构的扩展考虑&lt;/h2&gt;
&lt;p&gt;集群中的每个 cilium-agent 负责将全局集群配置更新到其本地数据平面配置。每个 cilium-agent 可能会监视多达 15 种 CRD 类型。&lt;/p&gt;
&lt;p&gt;随着集群在节点、Pod、命名空间和网络策略方面的规模增长，每个 cilium-agent 需要执行的工作量也会增加。为了服务和更新所有这些状态，会对 Kubernetes apiserver 造成压力，可能导致 &lt;a href=&#34;https://github.com/cilium/cilium/issues/29127&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/scaling-cilium-to-new-heights-with-xds/f5_hu16030348651474974304.webp 400w,
               /blog/scaling-cilium-to-new-heights-with-xds/f5_hu54815831044306071.webp 760w,
               /blog/scaling-cilium-to-new-heights-with-xds/f5_hu9468284516964515973.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/f5_hu16030348651474974304.webp&#34;
               width=&#34;760&#34;
               height=&#34;478&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在大规模部署中，这种对 Kubernetes API 服务器的压力可能最终会减慢 &lt;em&gt;甚至导致&lt;/em&gt; 集群中的所有操作。&lt;/p&gt;
&lt;p&gt;在查看集群中的常见操作以及 cilium-agent 处理它的方式时，全局配置状态对每个节点的影响确实开始放大：工作负载和命名空间被标记、重新标记或取消标记。&lt;/p&gt;
&lt;p&gt;cilium-agent 负责为调度到其节点上的 Pod 编写 CiliumEndpoint 和 CiliumIdentity 资源。由于这些资源依赖于 Pod 和命名空间标签的组合，标签的更改将导致所有依赖资源的更新。这会导致大量的写操作和相应的读取操作，因为此状态随后会传播到所有 cilium-agent，它们必须做出反应并重新配置其本地数据平面。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;cilium.io/v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;CiliumIdentity&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;50568&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;io.cilium.k8s.policy.cluster&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;io.cilium.k8s.policy.serviceaccount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;sleep-v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;io.kubernetes.pod.namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;security-labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;k8s:app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;k8s:io.cilium.k8s.namespace.labels.team&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;loyalty&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;k8s:io.cilium.k8s.namespace.labels.version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v10.45&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;k8s:io.cilium.k8s.namespace.labels.kubernetes.io/metadata.name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;k8s:io.cilium.k8s.policy.cluster&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;k8s:io.cilium.k8s.policy.serviceaccount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;sleep-v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;k8s:io.kubernetes.pod.namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;k8s:version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;代码清单 1：&lt;code&gt;CiliumIdentity&lt;/code&gt; 资源结合了 &lt;em&gt;Pod&lt;/em&gt; 和 &lt;em&gt;命名空间&lt;/em&gt; 标签。对任一者的更改都会强制重新计算并生成新的 &lt;code&gt;CiliumIdentity&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对集群中的命名空间进行标记等操作对于 Cilium 可能非常昂贵，并且有可能导致 API 服务器操作减慢到爬行的程度（&lt;a href=&#34;https://docs.cilium.io/en/stable/operations/performance/scalability/identity-relevant-labels/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;请参阅用于标识目的包括/排除标签的建议&lt;/a&gt;）。例如，在中等规模集群中更改命名空间的标签可能会导致足够多的 cilium-agent 导致 Kubernetes API 服务器响应延迟约 &lt;strong&gt;4 分钟&lt;/strong&gt;。这将有效地使集群上的所有操作停滞不前。&lt;/p&gt;
&lt;p&gt;考虑以下环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 个节点的 Kubernetes 集群&lt;/li&gt;
&lt;li&gt;5 个命名空间&lt;/li&gt;
&lt;li&gt;每个命名空间有 50 个部署&lt;/li&gt;
&lt;li&gt;每个部署有 80 个副本（总共 20,000 个 Pod）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一次更新跨命名空间的标签的测试中，我们看到 CPU 利用率急剧上升，约为 150%，并且内存在整个集群的所有节点上升到约 1 GB。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1所有节点上的-cpu-和内存峰值&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1：所有节点上的 CPU 和内存峰值&#34; srcset=&#34;
               /blog/scaling-cilium-to-new-heights-with-xds/g1_hu17486889627407700744.webp 400w,
               /blog/scaling-cilium-to-new-heights-with-xds/g1_hu16263909123267190212.webp 760w,
               /blog/scaling-cilium-to-new-heights-with-xds/g1_hu1838474423053320396.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/g1_hu17486889627407700744.webp&#34;
               width=&#34;760&#34;
               height=&#34;210&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1：所有节点上的 CPU 和内存峰值
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在整个集群的所有节点上同时提高 CPU 和内存是不希望看到的行为，然而更严重的是 cilium-agent 事件的读写如何影响 Kubernetes API 服务器的延迟。在下图中，我们看到延迟增长到 3 到 4 &lt;em&gt;分钟&lt;/em&gt;。这肯定会导致各种类型的停机！不幸的是，由于这种控制平面架构，通过增加容量来处理扩展问题的典型方法不起作用；实际上，添加更多节点和/或更多工作负载会放大这种行为。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2kubernetes-api-服务器延迟增加到-3---4-分钟&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 2：Kubernetes API 服务器延迟增加到 3 - 4 分钟&#34; srcset=&#34;
               /blog/scaling-cilium-to-new-heights-with-xds/g2_hu7795722616314403305.webp 400w,
               /blog/scaling-cilium-to-new-heights-with-xds/g2_hu2191967409548707840.webp 760w,
               /blog/scaling-cilium-to-new-heights-with-xds/g2_hu10717639184421141124.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/g2_hu7795722616314403305.webp&#34;
               width=&#34;760&#34;
               height=&#34;312&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2：Kubernetes API 服务器延迟增加到 3 - 4 分钟
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;减轻-kubernetes-api-服务器的压力&#34;&gt;减轻 Kubernetes API 服务器的压力&lt;/h2&gt;
&lt;p&gt;对于较大的 Cilium 集群，您可以通过使用&lt;a href=&#34;https://docs.cilium.io/en/latest/kvstore/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;专用的键值存储&lt;/a&gt; 来减轻 Kubernetes API 服务器上的压力。键值存储用于存储工作负载标识、端点和 IP 到标识映射等内容。Cilium 不再将此信息存储在 Kubernetes 自定义资源（CRD）中，而是在其自己的数据库中直接监视、操作和写入对象。Cilium Helm 图表支持将 etcd 作为专用键值存储来进行安装，以满足此目的。&lt;/p&gt;
&lt;p&gt;随着集群的增长，使用 kv-store 来卸载 Cilium 对象的读/写操作可能是一个好主意，而不是给 Kubernetes API 服务器施加压力。&lt;/p&gt;
&lt;p&gt;注意：Cilium 还进行了其他优化，以减轻 Kubernetes API 服务器的压力，例如策略状态更新。有关更多信息，请参阅&lt;a href=&#34;https://docs.cilium.io/en/stable/internals/cilium_operator/#policy-status-update&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;k8s-events-handover 文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果我们在存在 kv-store 的情况下重新运行先前的测试，我们会看到对 Kubernetes API 服务器的压力减轻，尽管 CPU 可能没有减轻。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-3所有节点上的-cpu-峰值内存保持在-300-400-mb-范围内&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 3：所有节点上的 CPU 峰值，内存保持在 300-400 MB 范围内&#34; srcset=&#34;
               /blog/scaling-cilium-to-new-heights-with-xds/g3_hu8766193418619210519.webp 400w,
               /blog/scaling-cilium-to-new-heights-with-xds/g3_hu15609787638247514164.webp 760w,
               /blog/scaling-cilium-to-new-heights-with-xds/g3_hu15499874654379155262.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/g3_hu8766193418619210519.webp&#34;
               width=&#34;760&#34;
               height=&#34;174&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3：所有节点上的 CPU 峰值，内存保持在 300-400 MB 范围内
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;与先前情况下的 150% CPU 消耗不同，CPU 在大约 100% 左右波动，而内存保持在大约 300 到 400 MB 的范围内。这是因为对每个 Pod 和每个标识（Cilium 在更改标签时创建所有新标识，并且必须更新引用旧标识的所有 eBPF 映射的 CiliumEndpoint 和 CiliumIdentity 对象的重新计算和生成需要 CPU 计算资源来完成，无论使用何种后备存储（CRD、kv-store 等）。&lt;/p&gt;
&lt;p&gt;如果我们观察 kv-store，我们会看到在此命名空间标签事件期间，事件操作/秒和延迟会急剧上升：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-4kv-store-上的事件操作和延迟在此命名空间标签事件期间急剧上升&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 4：kv-store 上的事件操作和延迟在此命名空间标签事件期间急剧上升&#34; srcset=&#34;
               /blog/scaling-cilium-to-new-heights-with-xds/g4_hu5162100211635706179.webp 400w,
               /blog/scaling-cilium-to-new-heights-with-xds/g4_hu8027949023168315035.webp 760w,
               /blog/scaling-cilium-to-new-heights-with-xds/g4_hu17981861380060744388.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/g4_hu5162100211635706179.webp&#34;
               width=&#34;760&#34;
               height=&#34;183&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4：kv-store 上的事件操作和延迟在此命名空间标签事件期间急剧上升
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这种特殊情况下，我们看到 kv-store 承受了相当大的负载，通过事件 IO，我们看到 kv-store 调用的延迟降低到约 15 秒左右。总之，这对于整个集群操作而言要好得多，而不是用请求使 Kubernetes API 服务器饱和。事实上，在图 5 中，我们可以看到 Kubernetes API 服务器的延迟保持在 10 到 40 毫秒的可接受范围内，而在先前的示例中，延迟升高到 4 分钟。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5kubernetes-api-server-延迟在-10-到-40ms-之间&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 5：Kubernetes API Server 延迟在 10 到 40ms 之间&#34; srcset=&#34;
               /blog/scaling-cilium-to-new-heights-with-xds/g5_hu15786867033393857353.webp 400w,
               /blog/scaling-cilium-to-new-heights-with-xds/g5_hu5725239903038200334.webp 760w,
               /blog/scaling-cilium-to-new-heights-with-xds/g5_hu4960722962006109899.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/g5_hu15786867033393857353.webp&#34;
               width=&#34;760&#34;
               height=&#34;305&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5：Kubernetes API Server 延迟在 10 到 40ms 之间
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用 kv-store 后端来存储 Cilium 对象是一种缓解 Kubernetes API 服务器压力的好方法，但它也有其缺点。现在有两个持久存储需要维护，而且随着规模的增加，运维负担也增加。在生产环境中运行数据库或持久存储（总体来说）以支持规模化并非易事。如果失去一致性，恢复过程是必需的，因为现在有两个“真相源”。许多平台完全管理 Kubernetes API 服务器及其存储，但 kv-store 并不是如此。由于绝大多数负载是读取操作，缓存将在减少运维复杂性的同时产生相同的改进。&lt;/p&gt;
&lt;h2 id=&#34;使用-xds-改进-cilium-的控制平面扩展安全性和效率&#34;&gt;使用 xDS 改进 Cilium 的控制平面扩展、安全性和效率&lt;/h2&gt;
&lt;p&gt;如果我们可以兼顾两全呢？既减轻 Kubernetes API 服务器的压力，又消除维护单独数据存储的昂贵生产操作的需要？甚至可能解决一些其他尚未解决的 Cilium 扩展和安全性问题？&lt;/p&gt;
&lt;p&gt;在 Solo.io，我们很高兴为 Cilium 社区中更广泛的 xDS 工作作出贡献，并帮助推动该项目朝着可扩展、安全和高效的控制平面迈进。使用&lt;a href=&#34;https://github.com/cncf/xds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xDS 协议&lt;/a&gt;使我们能够在集群中扩展到数千甚至数万个节点。这种方法解决了上面讨论的许多问题，以及其他问题，如单节点妥协影响范围和规模上的 CiliumIdentity 重复。让我们看看它是如何工作的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/cncf/xds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xDS 协议&lt;/a&gt;最初是一种动态配置&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 代理&lt;/a&gt;的方式，但是它建立的理念是可以用来支持“通用数据平面”。该协议已成为在多个节点之间同步状态的有效方式，&lt;a href=&#34;https://github.com/cncf/xds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;现在由 CNCF 工作组管理&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最终，我们希望消除每个 cilium-agent 所做的冗余工作，将诸如标识创建之类的复杂且权限敏感的操作集中在一起，并以高效的方式为代理提供状态，同时不损害 Kubernetes 作为整体的可靠性。&lt;/p&gt;
&lt;p&gt;为了做到这一点，我们将不再让每个 cilium-agent 充当独立的控制平面，而是考虑让 cilium-agent 充当智能集中控制平面的简单只读客户端。控制平面将保护代理免受复杂和权限敏感的操作。&lt;/p&gt;
&lt;p&gt;cilium-agent（现在属于数据平面的一部分）与控制平面之间的通信将采用&lt;a href=&#34;https://github.com/cncf/xds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xDS 协议&lt;/a&gt;。数据平面不允许从数据平面到控制平面的写操作，因此 cilium-agent 不需要对后端存储（CRD/kv-store）具有写入访问权限。xDS 控制平面服务可以得到安全加固，是唯一需要支持对 Kubernetes API 服务器进行读/写操作的组件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/scaling-cilium-to-new-heights-with-xds/f6_hu18164745346281393999.webp 400w,
               /blog/scaling-cilium-to-new-heights-with-xds/f6_hu14878595511585962512.webp 760w,
               /blog/scaling-cilium-to-new-heights-with-xds/f6_hu7420436872122181644.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/f6_hu18164745346281393999.webp&#34;
               width=&#34;760&#34;
               height=&#34;562&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种架构减轻了 Kubernetes API 服务器的负载，并且不需要任何外部管理的数据存储。它看起来也更接近之前讨论的三层控制平面架构。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-6xds-实现的初始测试显示-cpu-和内存使用的预期行为&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 6：xDS 实现的初始测试显示 CPU 和内存使用的预期行为&#34; srcset=&#34;
               /blog/scaling-cilium-to-new-heights-with-xds/g6_hu17778559167326793251.webp 400w,
               /blog/scaling-cilium-to-new-heights-with-xds/g6_hu13540862992585216661.webp 760w,
               /blog/scaling-cilium-to-new-heights-with-xds/g6_hu387173476530170890.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/scaling-cilium-to-new-heights-with-xds/g6_hu17778559167326793251.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6：xDS 实现的初始测试显示 CPU 和内存使用的预期行为
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这种架构中，我们确实看到了 xDS 控制平面 pods 中的 CPU 和内存开销，正如预期的那样，每个节点仍然需要处理 eBPF 数据平面的一些 CPU/内存处理开销。&lt;/p&gt;
&lt;p&gt;这种模型带来的其他好处包括在节点受损时更小的影响范围，以及消除了 cilium-agent 创建的重复标识。在原始架构（CRD 或 kv-store）中，每个节点都有一个完整的控制平面，需要特殊权限来读取和写入&lt;code&gt;CiliumEndpoints&lt;/code&gt;和&lt;code&gt;CiliumIdentity&lt;/code&gt;。如果某个节点上的 cilium-agent 受到妥协，那么整个控制平面将受到威胁，并使攻击者能够影响其他节点。这可能导致整个集群妥协。在 xDS 模型中，cilium-agent 被允许从控制平面读取数据（不允许写入），单个 cilium-agent 的妥协不会给予对整个控制平面或集群的访问权限。正如前面提到的，xDS 控制平面被视为特权组件，可以进行锁定和安全设置，甚至可以完全在集群之外运行。&lt;/p&gt;
&lt;p&gt;xDS 方法的另一个好处是通过集中标识创建来消除 Cilium 中重复标识的生成。在现有模型中，每个 cilium-agent 都独立充当控制平面，与其他节点隔离，正如在现有模型中，它试图做出可能是重复的决策。例如，当 Pod 分配到节点时，CNI 负责设置网络端点，当 cilium-agent 识别到一个新的端点，它没有现有的&lt;code&gt;CiliumIdentity&lt;/code&gt;时，它将尝试创建它。如果命名空间标签发生更改并且需要重新计算所有标识，那么也会发生相同的情况。由于标识创建在多个节点上独立进行，因此有很大机会为相同标识创建多个&lt;code&gt;CiliumIdentity&lt;/code&gt;（在极端情况下，&lt;a href=&#34;https://docs.google.com/document/d/1Hcc_2mB9OOUxrqQgZ-gSYDPnLYE_If_TCzVbUGDOdGM/edit?pli=1#heading=h.yzvq0akbw7z9&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如此描述的易于重现&lt;/a&gt;）。在 xDS 方法中，&lt;code&gt;CiliumIdentity&lt;/code&gt;在集中创建，从而消除了这种情况。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;Cilium 在 eBPF 基础上构建了强大的数据平面，但要使 Cilium 在规模上有效运行，我们可以利用 xDS 协议来改进控制平面架构。xDS 是一种高效的协议，允许我们利用多年来学到的构建控制平面的最佳实践。事实上，如果我们将 xDS 控制平面 &lt;a href=&#34;https://docs.google.com/document/d/1U4pO_dTaHERKOtrneNA8njW19HSVbq3sBM3x8an4878/edit#heading=h.ghzkbpzc9oea&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;直接构建到 cilium-operator 中&lt;/a&gt;，那么从这个实施中不会增加新的复杂性。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JWT 在 API 网关中的角色：服务间认证的新视角</title>
      <link>https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/</link>
      <pubDate>Fri, 08 Dec 2023 12:30:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://www.solo.io/blog/jwts-authenticate-services-api-gateways/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.solo.io/blog/jwts-authenticate-services-api-gateways/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要：这篇博客探讨了在云原生架构中使用 JSON Web Tokens（JWTs）进行服务间通信的复杂性。它详细讨论了通过 API 网关和服务网格实现安全认证的两种方法，强调了使用 JWTs 的挑战，包括安全性、密钥管理和性能问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;云原生架构中的 API 网关组件至关重要，因为它将关键的 API 安全性和策略功能卸载到一个公共位置，使后端 API 和服务能够专注于业务逻辑。API 身份验证、授权、审计、限流等任务可能会非常复杂且难以正确实现，因此许多组织选择使用 API 网关来处理它们。&lt;/p&gt;
&lt;p&gt;那么对于服务与服务（S2S）或内部东/西流量呢？强制 S2S 流量“回头”通过 API 网关会引入额外的跳跃、更多的延迟、增加的流量以及效率降低。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-通过-api-网关的-s2s-流量回头示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;通过 API 网关的 S2S 流量“回头”示意图&#34; srcset=&#34;
               /blog/jwts-authenticate-services-api-gateways/hairpin-api-gateway-calls_hu1426462098848652707.webp 400w,
               /blog/jwts-authenticate-services-api-gateways/hairpin-api-gateway-calls_hu12297138726394611442.webp 760w,
               /blog/jwts-authenticate-services-api-gateways/hairpin-api-gateway-calls_hu17562096345058781978.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/hairpin-api-gateway-calls_hu1426462098848652707.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      通过 API 网关的 S2S 流量“回头”示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但是，如果您跳过 API 网关直接调用服务，如何确保流量的安全性？接收服务如何进行身份验证并知道是谁在调用它？&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-显示-service-b-需要对-service-a-进行身份验证的示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;显示 Service B 需要对 Service A 进行身份验证的示意图&#34; srcset=&#34;
               /blog/jwts-authenticate-services-api-gateways/service-a-b_hu3331557173496051898.webp 400w,
               /blog/jwts-authenticate-services-api-gateways/service-a-b_hu13480306152317070208.webp 760w,
               /blog/jwts-authenticate-services-api-gateways/service-a-b_hu13309169736882342115.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/service-a-b_hu3331557173496051898.webp&#34;
               width=&#34;760&#34;
               height=&#34;248&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      显示 Service B 需要对 Service A 进行身份验证的示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;保障 S2S 通信的两种常见方式是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用传输层安全性（TLS）和客户端证书（双向 TLS 或 mTLS）。&lt;/li&gt;
&lt;li&gt;使用签名的 JSON Web Tokens（JWT）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://www.solo.io/topics/service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格&lt;/a&gt;通过使用第一种方法自动化了许多最佳实践并减轻了与之相关的&lt;a href=&#34;https://istio.io/latest/blog/2023/secure-apps-with-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;开发人员可以选择使用 JWT 进行 S2S 身份验证，但这会“削弱”API 网关的预期功能。也就是说，您曾期望 API 网关处理的所有安全性复杂性和脆弱性必须在每个 S2S 通信的微服务中重新创建和复制。这是一个重大问题，因为使用 JWT 进行 S2S 身份验证会引入复杂性和对细节的严格要求。（有关此主题和下面的场景的更多信息，请观看 Hoot 第 59 集：“&lt;a href=&#34;https://youtu.be/Q2KfNUBfnjo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWT 与 Service-to-Service 身份验证的比较&lt;/a&gt;”。所有演示都可以在我们的&lt;a href=&#34;https://github.com/peterj/jwts-for-services/tree/main&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub 仓库&lt;/a&gt;中找到。）&lt;/p&gt;
&lt;p&gt;虽然有一些出色的处理 JWT 的框架和库，而 JWT 确实有其用武之地，但将 JWT 用于 S2S 流量的身份验证是复杂且繁重的，并且需要开发人员非常准确地完成工作。这种复杂性（或缺乏意识）可能会降低总体安全性，如果开发人员采取捷径或忽视关键属性，可能会降低总体安全性。开发人员还需要以特定于语言和框架的方式执行此操作（例如，使用 Java 解决此问题与使用 Go 或 Node.js 不同）。在所有代码库中维护、打补丁和审核每个实现都需要付出成本。&lt;/p&gt;
&lt;h2 id=&#34;如何使用-jwt-进行-s2s-通信身份验证&#34;&gt;如何使用 JWT 进行 S2S 通信身份验证&lt;/h2&gt;
&lt;p&gt;有两种方法可以创建 JWT 以进行 S2S 通信身份验证：使用身份提供者（IdP）（也称为安全令牌服务或 STS）或允许各个服务自行签署 JWT。（如果您对 JWT 概念不熟悉或需要复习，请查看 Auth0 提供的&lt;a href=&#34;https://auth0.com/docs/secure/tokens/json-web-tokens&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWT 概述&lt;/a&gt;。）&lt;/p&gt;
&lt;h3 id=&#34;选项-1使用-sts-发放令牌&#34;&gt;选项 1：使用 STS 发放令牌&lt;/h3&gt;
&lt;p&gt;第一种方法涉及使用安全令牌服务（STS），这是一个可信任的身份或令牌提供者，例如&lt;a href=&#34;https://www.keycloak.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Keycloak&lt;/a&gt;、&lt;a href=&#34;https://www.okta.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Okta&lt;/a&gt;或&lt;a href=&#34;https://auth0.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Auth0&lt;/a&gt;，用于发放代表特定服务的令牌。&lt;/p&gt;
&lt;p&gt;在此方法中，服务使用长期凭据（例如用户名和密码或 OAuth2.0 客户端凭据）与 STS 交换 JWT，表明“我是 Service A”。&lt;/p&gt;
&lt;p&gt;注意：长期凭据应安全存储并有限使用。例如，您可以在启动时使用它一次来引导身份，并且以后不再使用。此外，这些凭据应仅存储在内存中。&lt;/p&gt;
&lt;p&gt;STS 使用其私钥签署 JWT，可以使用其公钥验证 JWT。然后，Service A 将 JWT 附加到发送给 Service B 的请求中。从这里，Service B 可以通过使用 STS 的公钥验证 JWT 的签名来验证 JWT 是由 STS 签发的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-显示服务如何相互验证的示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;显示服务如何相互验证的示意图&#34; srcset=&#34;
               /blog/jwts-authenticate-services-api-gateways/authentication_hu18391638308049772176.webp 400w,
               /blog/jwts-authenticate-services-api-gateways/authentication_hu12369651219247502419.webp 760w,
               /blog/jwts-authenticate-services-api-gateways/authentication_hu5449802954201412187.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/authentication_hu18391638308049772176.webp&#34;
               width=&#34;760&#34;
               height=&#34;471&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      显示服务如何相互验证的示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了使此工作正常运行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流量必须加密。&lt;/li&gt;
&lt;li&gt;服务 B 必须检查 JWT 的&lt;code&gt;aud&lt;/code&gt;声明、过期时间、颁发时间以及不早于时间。&lt;/li&gt;
&lt;li&gt;当 STS 签发的 JWT 签名密钥轮换时，服务 B 必须准备好更新 STS 的公钥。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;加密流量至关重要，因为在这种情况下使用 JWT 时，它们代表了一个“承载令牌”，因此拥有令牌的任何人都可以冒充 Service A。在 Service A 和 Service B 之间加密流量（例如使用单向服务器 TLS）有助于减轻这个问题。&lt;/p&gt;
&lt;p&gt;Service B 还必须检查 JWT 的过期时间（&lt;code&gt;exp&lt;/code&gt;）、颁发时间（&lt;code&gt;iat&lt;/code&gt;）、不早于时间（&lt;code&gt;nbf&lt;/code&gt;）以及特别是&lt;code&gt;aud&lt;/code&gt;声明，以验证令牌是否有效（未过期，位于其时间窗口内并用于 Service B 的使用）。JWT 使用这个约定来防范重放攻击，其中攻击者冒充 Service B，从 Service A 获取令牌，然后冒充 Service A 来调用 Service C。有效的 Service C 会检查&lt;code&gt;aud&lt;/code&gt;声明，看到代表 Service A 的 JWT 是为 Service B 而设计的，然后拒绝它。&lt;/p&gt;
&lt;p&gt;每次调用服务 A 都必须使用不同的 JWT，因为&lt;code&gt;aud&lt;/code&gt;声明会不同。尝试使用没有&lt;code&gt;aud&lt;/code&gt;声明的 JWT 或使用通配符&lt;code&gt;aud&lt;/code&gt;声明会增加 JWT 被破坏的风险。避免这样做。&lt;/p&gt;
&lt;p&gt;最后，常常被忽略的是轮换 STS 的公钥。在计划的密钥轮换或计划的撤销 STS 用于签署 JWT 的密钥时，Service B（或任何依赖 STS 进行验证的服务）必须能够处理更新的签名公钥。&lt;/p&gt;
&lt;h3 id=&#34;选项-2让服务自行签署其令牌&#34;&gt;选项 2：让服务自行签署其令牌&lt;/h3&gt;
&lt;p&gt;第二种方法使用服务特定的密钥来签署 JWT。可以使用对称密钥或非对称密钥。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-使用特定于服务的密钥进行-s2s-身份验证的示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;使用特定于服务的密钥进行 S2S 身份验证的示意图&#34; srcset=&#34;
               /blog/jwts-authenticate-services-api-gateways/authentication-service-specific-keys_hu157616134395954412.webp 400w,
               /blog/jwts-authenticate-services-api-gateways/authentication-service-specific-keys_hu2756756592464593840.webp 760w,
               /blog/jwts-authenticate-services-api-gateways/authentication-service-specific-keys_hu5563519272958140492.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/authentication-service-specific-keys_hu157616134395954412.webp&#34;
               width=&#34;760&#34;
               height=&#34;518&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      使用特定于服务的密钥进行 S2S 身份验证的示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这种情况下，Service A 使用自己的密钥来签署发送给 Service B（或任何其他服务）的 JWT。Service B 将需要 Service A 的公钥（或对称密钥，由于密钥交换和冒充问题更加危险）来验证 Service A 发送的 JWT。实际上，Service B 将需要每个调用它的服务的公钥，这些服务使用 JWT 作为身份验证主体。&lt;/p&gt;
&lt;p&gt;与 STS 签发的 JWT 示例一样，服务之间的流量必须加密，Service B 还必须检查&lt;code&gt;aud&lt;/code&gt;声明，并且您需要一种签署公钥轮换的方法。您还必须为每个调用的服务使用不同的 JWT。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务-b-检查-aud-声明&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;服务 B 检查 aud 声明&#34; srcset=&#34;
               /blog/jwts-authenticate-services-api-gateways/different-jwt-dependent-services_hu3458119914455195249.webp 400w,
               /blog/jwts-authenticate-services-api-gateways/different-jwt-dependent-services_hu6440531814796546159.webp 760w,
               /blog/jwts-authenticate-services-api-gateways/different-jwt-dependent-services_hu7124902659432484959.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/different-jwt-dependent-services_hu3458119914455195249.webp&#34;
               width=&#34;760&#34;
               height=&#34;634&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务 B 检查 aud 声明
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;开发人员必须采取措施并跟踪许多内容，以确保一切正确。证书还必须至少分发给一半的服务（接收端的服务）以提供至少单向 TLS。此外，整个过程的关键是密钥管理、轮换和安全保管密钥。&lt;/p&gt;
&lt;h2 id=&#34;jwt-可能出现问题的地方&#34;&gt;JWT 可能出现问题的地方&lt;/h2&gt;
&lt;p&gt;我们已经介绍了 JWT 可用于表示服务身份的一些方式，并提出了关注的领域。在服务架构中，有几个需要密切关注的领域，以避免安全漏洞。如果这些不是牢不可破的，您将为攻击者提供机会来破坏您的系统。&lt;/p&gt;
&lt;p&gt;在使用客户端证书/mTLS（例如服务网格）和JWT进行身份验证之间最重要的区别之一是：JWT通过网络发送敏感的承载令牌材料，而mTLS不会。使用mTLS时，只会发送公钥，而不会发送私钥，会协商会话密钥。如果JWT泄露，JWT是私密材料，可以被重放。对于证书，只有公共证书被共享。&lt;/p&gt;
&lt;p&gt;为防止重播承载令牌，您必须通过设置短暂的到期时间，理想情况下只有几分钟，来限制其暴露。这会增加服务刷新其 JWT 以进行请求的责任。设置数小时、数天或数月的到期时间发生得太频繁。这是一个严重的安全隐患。&lt;/p&gt;
&lt;p&gt;另一个重大的安全漏洞是，在使用 STS 获取 JWT 材料时，您会多次通过网络发送长期凭据（例如客户端凭证流程）。这些长期凭据非常敏感，应谨慎使用（例如，在启动时使用），而不应连续使用。&lt;/p&gt;
&lt;p&gt;此外，使用通配符&lt;code&gt;aud&lt;/code&gt;声明或完全省略&lt;code&gt;aud&lt;/code&gt;声明也是一个重大问题。未能在服务之间一致使用这些约定以进行身份验证会导致严重问题。确保为&lt;em&gt;每个&lt;/em&gt;调用的服务创建具有正确&lt;code&gt;aud&lt;/code&gt;声明的 JWT。&lt;/p&gt;
&lt;p&gt;最后，密钥轮换与短暂到期时间和 aud 声明检查同样重要。在发生违规事件时，使密钥无效是最后的努力，应尽快且高效地处理。&lt;/p&gt;
&lt;h2 id=&#34;jwt-的复杂性是服务网格简化事物的地方&#34;&gt;JWT 的复杂性是服务网格简化事物的地方&lt;/h2&gt;
&lt;p&gt;服务网格简化了服务之间的身份验证，并允许开发人员专注于业务逻辑，而不是正确地处理 JWT 和秘密材料（希望如此）。就像 API 网关应用于处理北/南和入口流量的安全性一样，服务网格应用于处理东/西和 S2S 流量的安全性。保持服务和 API 专注于它们可以提供的不同 iating 业务价值，而不是模板（但极其重要的）的安全性代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ciilium 的相互认证如何危及安全</title>
      <link>https://cloudnativecn.com/blog/how-ciliums-mutual-authentication-can-compromise-security/</link>
      <pubDate>Fri, 01 Dec 2023 10:33:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/how-ciliums-mutual-authentication-can-compromise-security/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://thenewstack.io/how-ciliums-mutual-authentication-can-compromise-security/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://thenewstack.io/how-ciliums-mutual-authentication-can-compromise-security/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要：这篇文章是关于如何使用 Cilium 来实现 互相认证 (mTLS) 的，以及这种方法可能带来的安全问题。文章介绍了 Cilium 的特点和功能，以及如何使用 Cilium CLI 或 Hubble UI 来创建和管理证书和策略。文章还分析了 Cilium 的互相认证的局限和风险，例如证书过期，撤销，泄露和伪造等。文章的目的是帮助用户了解和使用 Cilium 来提高服务间的安全性。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最近，Cilium 项目宣布支持一种&lt;a href=&#34;https://docs.cilium.io/en/latest/network/servicemesh/mutual-authentication/mutual-authentication/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;新的双向认证机制&lt;/a&gt;，可以通过简单的配置标志透明地部署到应用程序中。从表面上看，这似乎是一种简单的方法，可以使用 Cilium 为 Kubernetes 工作负载实现服务之间的双向认证。然而，这种设计存在一个严重的缺陷，不容忽视：&lt;/p&gt;
&lt;p&gt;Cilium 中的双向认证的整个基础是&lt;em&gt;最终一致性&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;在安全实现的数据路径中，最终一致性可能导致意图中的安全属性失败，并且可能导致在不应该允许的情况下服务之间的流量继续传递。&lt;/p&gt;
&lt;h2 id=&#34;cilium-双向认证的工作原理&#34;&gt;Cilium 双向认证的工作原理&lt;/h2&gt;
&lt;p&gt;Cilium 的自定义双向认证机制会透明地对服务之间的流进行身份验证，并构建在 Cilium 的现有扩展伯克利数据包过滤器（&lt;a href=&#34;https://thenewstack.io/ebpf-offers-a-new-way-to-secure-cloud-native-systems/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt;）数据平面之上。Cilium 使用 eBPF 来实现诸如服务网络、网络策略和连接处理等功能。&lt;/p&gt;
&lt;p&gt;Cilium 使用“无双向传输层安全（mTLS-less）”（或 mTLess）来对服务进行身份验证。我称之为“less”，因为它没有使用 mTLS 来完成 mTLS 设计的任务：验证、加密和检查在两个对等方之间传输的数据的完整性。Cilium 的双向认证实现&lt;em&gt;不是 mTLS&lt;/em&gt;，我将在下面解释。&lt;/p&gt;
&lt;p&gt;当服务（或 Pod）A 想要与服务（或 Pod）B 通信时，Cilium 会尝试对这两个对等方进行身份验证，然后标记一个特殊的本地节点“身份验证缓存”，指示是否允许特定流。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1由于未经身份验证而丢弃的初始连接&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1：由于未经身份验证而丢弃的初始连接。&#34; srcset=&#34;
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f1_hu9728721819287716679.webp 400w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f1_hu8515282394999911504.webp 760w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f1_hu15339383418986846698.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-ciliums-mutual-authentication-can-compromise-security/f1_hu9728721819287716679.webp&#34;
               width=&#34;760&#34;
               height=&#34;293&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1：由于未经身份验证而丢弃的初始连接。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当 Pod A 想要与 Pod B 通信时，它会通过正常的 Cilium eBPF 数据平面流动，但 eBPF 代码会检查该连接是否已通过检查本地节点身份验证缓存进行身份验证。在第一次尝试时，该调用将不会得到身份验证，因此&lt;a href=&#34;https://github.com/cilium/cilium/issues/23808&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium 将丢弃数据包&lt;/a&gt;。但这将触发一个在幕后进行的机制，尝试对 Pod A 和 Pod B 之间的流进行身份验证。如果成功，它将更新本地节点身份验证缓存。&lt;/p&gt;
&lt;p&gt;期望的是，在幕后的机制能够快速进行 Pod A 呼叫 Pod B 的身份验证，以便最初丢弃的数据包将被重试，不会导致太多延迟。在幕后使用的机制是从运行在 Pod B 所在节点上的 cilium-agent（使用&lt;a href=&#34;https://roadmap.sh/golang&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go&lt;/a&gt;编写）到另一个 cilium-agent 的“mTLess”连接。所有这些都不会在 eBPF 数据平面中发生，而是在用户空间的 Cilium 代理中进行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2如果两个不同节点上运行的-cilium-agent-之间的-mtls-连接成功则认为流是经过身份验证的&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 2：如果两个不同节点上运行的 cilium-agent 之间的 mTLS 连接成功，则认为流是经过身份验证的。&#34; srcset=&#34;
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f2_hu10070661624759929293.webp 400w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f2_hu16286326383952627814.webp 760w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f2_hu17409430451658380993.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-ciliums-mutual-authentication-can-compromise-security/f2_hu10070661624759929293.webp&#34;
               width=&#34;760&#34;
               height=&#34;380&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2：如果两个不同节点上运行的 cilium-agent 之间的 mTLS 连接成功，则认为流是经过身份验证的。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我将这个连接称为“mTLess”，因为它用于测试身份验证并立即关闭，并且所有用于加密和完整性的协商的会话密钥都会被丢弃。也就是说，Cilium 不会在连接的整个生命周期内保留 mTLS 安全属性；它只使用握手的身份验证部分。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-3在握手后cilium-终止-mtless-连接&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 3：在握手后，Cilium 终止 mTLess 连接。&#34; srcset=&#34;
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f3_hu5450890929644243593.webp 400w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f3_hu5078158644050773506.webp 760w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f3_hu1911652993401268773.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-ciliums-mutual-authentication-can-compromise-security/f3_hu5450890929644243593.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3：在握手后，Cilium 终止 mTLess 连接。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果此 mTLess 连接成功（即握手成功），Cilium 将考虑将来自 Pod A 到 Pod B 的流程视为“已验证”。此时，本地节点身份验证缓存中的条目将被更新，以指示应允许来自 Pod A 到 Pod B 的流程。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-4cilium-更新身份验证缓存指示-pod-a-具有呼叫-pod-b-的身份验证&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 4：Cilium 更新身份验证缓存，指示 Pod A 具有呼叫 Pod B 的身份验证。&#34; srcset=&#34;
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f4_hu10284544887028446734.webp 400w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f4_hu8173082787676185549.webp 760w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f4_hu3459960760797016323.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-ciliums-mutual-authentication-can-compromise-security/f4_hu10284544887028446734.webp&#34;
               width=&#34;760&#34;
               height=&#34;329&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4：Cilium 更新身份验证缓存，指示 Pod A 具有呼叫 Pod B 的身份验证。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;现在，当它重试连接数据包时，身份验证缓存将指示流程已经通过身份验证，应允许连接并继续 eBPF 数据平面的其余部分（该部分强制执行网络和其他策略）。这个本地节点身份验证缓存确实表现出最终一致性的迹象，可能会失去同步，但这并不是最令人担忧的最终一致性属性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5一旦缓存已更新并重试数据包连接将会流动&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 5：一旦缓存已更新并重试数据包，连接将会流动。&#34; srcset=&#34;
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f5_hu8875700578379452926.webp 400w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f5_hu16400022754917321780.webp 760w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f5_hu8750530588956005851.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-ciliums-mutual-authentication-can-compromise-security/f5_hu8875700578379452926.webp&#34;
               width=&#34;760&#34;
               height=&#34;267&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5：一旦缓存已更新并重试数据包，连接将会流动。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;cilium-方法的主要问题&#34;&gt;Cilium 方法的主要问题&lt;/h2&gt;
&lt;p&gt;对于真正的 mTLS 连接，在成功握手之后，您希望使用在参与各方之间协商的密钥来加密剩余的数据。Cilium 中流的成功认证并不意味着它是加密的（它将是纯文本），也不保证流量以一种仅对相关方可见的方式进行加密。如果您需要加密，可以使用基于 WireGuard（或 IPSec）的 Cilium 加密选项，但这只是两个 Kubernetes 节点之间的加密，而不是特定的已认证的工作负载。在“mTLess”连接检查和将实际（敏感）数据放入线路之间，可能会发生很多事情。&lt;/p&gt;
&lt;p&gt;随着一些 Cilium 开发人员继续迭代这个实现，有关将 mTLS 连接中协商的某些密钥转移到底层节点到节点加密方法（例如 IPSec）的谈论。这个实现还有待观察。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-6具有不同会话密钥的流量&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 6：具有不同会话密钥的流量&#34; srcset=&#34;
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f6_hu1596331468209483764.webp 400w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f6_hu12770787854073781734.webp 760w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f6_hu7902297478813327711.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-ciliums-mutual-authentication-can-compromise-security/f6_hu1596331468209483764.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6：具有不同会话密钥的流量
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-7基于-wireguard-的加密&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 7：基于 WireGuard 的加密。&#34; srcset=&#34;
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f7_hu18406516341919106284.webp 400w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f7_hu17375687142356433346.webp 760w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f7_hu16409185980720703418.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-ciliums-mutual-authentication-can-compromise-security/f7_hu18406516341919106284.webp&#34;
               width=&#34;760&#34;
               height=&#34;423&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7：基于 WireGuard 的加密。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Cilium 最终一致性双向认证实现的真正问题出现在 Cilium 的核心身份模型周围。我在上面简要介绍了 TLS 握手，但如果您阅读 Cilium 文档，您会看到用于“mTLess”的 X509 证书具有可选基于&lt;a href=&#34;https://thenewstack.io/the-rise-of-workload-identity-in-cloud-native-with-spiffe-spire/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE&lt;/a&gt;（Secure Production Identity Framework For Everyone）的身份模型。实际上，在部署实现 Cilium 双向认证所需的组件时，您可以选择部署 SPIFFE Runtime Environment（SPIRE），这是 SPIFFE 的一个实现，Cilium 使用它来生成代表工作负载及其身份的证书。&lt;/p&gt;
&lt;p&gt;这个 SPIFFE 身份用于握手所使用的证书，&lt;em&gt;但 SPIFFE 不是 Cilium 中使用的基础通用工作负载身份&lt;/em&gt;。SPIFFE 用作独立的身份层，映射到 Cilium 现有身份实现。Cilium 在其&lt;a href=&#34;https://doc.crds.dev/github.com/cilium/cilium/cilium.io/CiliumIdentity/v2@1.9.3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;核心身份&lt;/a&gt;概念周围构建了所有的网络策略。CiliumIdentity 实现将一个整数映射到一组 IP 地址（与一组 Pod 关联的 Pod IP）。这个“整数”及其映射到 Pod IP 地址的方式代表了&lt;em&gt;Cilium 中的核心身份原语&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-8cilium-的核心身份原语基于在每个节点上的本地缓存中映射到-ip-地址的整数&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 8：Cilium 的核心身份原语基于在每个节点上的本地缓存中映射到 IP 地址的整数。&#34; srcset=&#34;
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f8_hu3533446481480882885.webp 400w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f8_hu1062786511443162722.webp 760w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f8_hu6217334345361474889.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-ciliums-mutual-authentication-can-compromise-security/f8_hu3533446481480882885.webp&#34;
               width=&#34;760&#34;
               height=&#34;371&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 8：Cilium 的核心身份原语基于在每个节点上的本地缓存中映射到 IP 地址的整数。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们在博客文章“&lt;a href=&#34;https://www.solo.io/blog/could-network-cache-based-identity-be-mistaken/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络基于缓存的身份可能会被误解吗？&lt;/a&gt;”中详细讨论了这个问题。由于这个问题，我们建议在考虑使用依赖身份到 IP 地址映射的容器网络接口（CNI）和&lt;a href=&#34;https://thenewstack.io/secure-your-service-mesh-a-13-item-checklist/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格&lt;/a&gt;进行网络安全时采取深度防御姿态。&lt;/p&gt;
&lt;p&gt;问题的关键在于：&lt;/p&gt;
&lt;p&gt;为集群中的每个身份的所有 IP 映射&lt;em&gt;都存在于集群中每个节点上的本地缓存中&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-9显示每个身份的-ip-的图表&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 9：显示每个身份的 IP 的图表&#34; srcset=&#34;
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f9_hu286766633997356943.webp 400w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f9_hu16074494618080885932.webp 760w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f9_hu8608529016465095533.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-ciliums-mutual-authentication-can-compromise-security/f9_hu286766633997356943.webp&#34;
               width=&#34;760&#34;
               height=&#34;461&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 9：显示每个身份的 IP 的图表
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-10最终一致性问题的图表&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 10：最终一致性问题的图表&#34; srcset=&#34;
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f10_hu10907965185694279089.webp 400w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f10_hu14619749360156476499.webp 760w,
               /blog/how-ciliums-mutual-authentication-can-compromise-security/f10_hu8374157354846843875.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-ciliums-mutual-authentication-can-compromise-security/f10_hu10907965185694279089.webp&#34;
               width=&#34;760&#34;
               height=&#34;452&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 10：最终一致性问题的图表
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了使 Cilium 的双向认证和策略执行正常工作，必须使用正确的 IP 到身份映射更新这些缓存。然而，在集群中的所有节点上更新单独的缓存&lt;em&gt;是一种最终一致性操作&lt;/em&gt;。当 Cilium 的 eBPF 数据平面尝试推理连接策略时，它将参考其节点本地缓存中的 IP 到身份映射。&lt;em&gt;如果该缓存过期或延迟&lt;/em&gt;，将导致不正确的网络策略（可能不符合要求，允许恶意活动，威胁数据等）。无论您是否使用 WireGuard 或 IPSec 来加密节点之间的流量，这都不会影响此身份混淆场景。&lt;/p&gt;
&lt;p&gt;这个演示说明了在使用 Cilium 的双向认证时可能导致违反网络策略的身份混淆：&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;因此，总结一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cilium 项目引入了一种新颖的 Kubernetes 工作负载的双向认证机制。&lt;/li&gt;
&lt;li&gt;Cilium 中的双向认证建立在最终一致性之上，可能会危及安全性。&lt;/li&gt;
&lt;li&gt;Cilium 使用“mTLess”进行身份验证，但不会维护整个连接的加密。&lt;/li&gt;
&lt;li&gt;Cilium 的身份模型包括 SPIFFE，但其核心身份是一个基于整数的单独身份层。&lt;/li&gt;
&lt;li&gt;核心问题在于，IP 到身份的映射存储在每个节点上的本地缓存中，这可能导致最终一致性的更新。&lt;/li&gt;
&lt;li&gt;在 Cilium 的双向认证中的最终一致性可能导致不正确的网络策略和安全漏洞。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要正确使用依赖身份到 IP 地址映射的 CNI，请考虑采用深度防御姿态，将一个服务网格（如 Istio Ambient）叠加在其上。Istio Ambient 实现了一种无 sidecar 的服务网格，在服务之间的数据路径上使用 mTLS（无论其 IP 地址如何）。在&lt;a href=&#34;https://thenewstack.io/solo-io-istio-is-winning-the-service-mesh-war/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;像 Istio 这样的服务网格&lt;/a&gt;中，身份模型是由 SPIFFE 定义的，并根据负责签署用于身份验证流量的证书的证书颁发机构建立的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何为 Envoy 构建一个控制面来管理集群网络流量</title>
      <link>https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/</link>
      <pubDate>Sat, 21 Nov 2020 08:45:20 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Guidance for Building a Control Plane to Manage Envoy Proxy at the edge, as a gateway, or in a mesh&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这篇文章我看了之后非常想翻译，为什么呢？一方面我也在学习 Envoy，并且在公司的实际项目中使用 Envoy，另一方面，我确实也在设计一个控制管理端来统一管控多个集群的所有流量，没错我说的是所有的流量管控。目前这个管理系统在内部已经在逐步使用起来了。所以翻译这篇文章，即学习 Envoy 技术，也是想做一个参考，印证我的想法是不是 OK 的，取长补短。&lt;/p&gt;
&lt;h2 id=&#34;指导在服务边缘构建控制面来管理-envoy-proxy让它作为服务网关或者在服务网格中使用&#34;&gt;指导在服务边缘构建控制面来管理 Envoy Proxy，让它作为服务网关或者在服务网格中使用&lt;/h2&gt;
&lt;p&gt;Envoy 已经成为了一个非常流行的网络组件了。Matt Klein &lt;a href=&#34;https://blog.envoyproxy.io/the-universal-data-plane-api-d15cec7a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;几年前写过一篇博文&lt;/a&gt;，就在讨论 Envoy 的动态配置 API 和它如何成为 Envoy 被采用越来越多的原因之一。他在博文中说这是“统一数据面板 API”（UDPA）。随着很多其它项目都采用 Envoy 作为其核心组件，可以毫不夸张的说 Envoy 不仅仅建立了标准 API，而且对于应用 7 层的网络解决方案来说：“Envoy 已经变成了在云原生架构下的统一数据平面”。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vlafpmj30dm07f74o_hu13373348109463116589.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vlafpmj30dm07f74o_hu8072620931324276507.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vlafpmj30dm07f74o_hu7621800770628589015.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vlafpmj30dm07f74o_hu13373348109463116589.webp&#34;
               width=&#34;490&#34;
               height=&#34;267&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而且，由于 Envoy 的统一数据平面 API，我们可以看到业界开发了很多针对基于 Envoy 技术设施进行配置管理的管理系统。本文将会深入讨论为 Envoy 构建一个控制平面需要什么，大家可以通过这些信息来评估什么样的基础设施最适合你的组织和场景。因为这个是一个很大的话题，作者会出一个系列文章来对此进行详细说明（后面我也会挑一些我感兴趣的文章进行翻译学习）。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://blog.envoyproxy.io/envoycon-recap-579d53576511&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EnvoyCon/KubeCon 论坛有很多非常好的讨论&lt;/a&gt;，这里好多组织都分享了他们采用 Envoy 的经验，也包括了如何构建他们自己的控制平面。下面是一些他们为什么选择自建控制平面的原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;现有的解决方案构建在不同的数据平面上，而且已经有了控制平面，需要在这里兼容 Envoy。&lt;/li&gt;
&lt;li&gt;为不包含任何开源基础设施来构建，或者使用其它的 Envoy 控制平面（比如：VMs，AWS，ECS 等）。&lt;/li&gt;
&lt;li&gt;不需要使用所有 Envoy 的特性，只是需要一部分。&lt;/li&gt;
&lt;li&gt;为了更好适配自己的工作流和工作视图而需要为 Envoy 配置开发专属领域的 API 对象模型。&lt;/li&gt;
&lt;li&gt;要线上使用，但是发现其它的控制平面并不够成熟。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vmv5i7j30go0di7a5_hu11870659217302186199.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vmv5i7j30go0di7a5_hu1907341945313452778.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vmv5i7j30go0di7a5_hu1019327531952406984.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vmv5i7j30go0di7a5_hu11870659217302186199.webp&#34;
               width=&#34;600&#34;
               height=&#34;486&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然而，仅仅因为有些早期使用者构建了他们自己的控制平面，这并不意味着你也应该做这样的事情。首先在去年中很多为 Envoy 开发的控制平面已经相当成熟了，所以你应该在决定要重新开发另外一个控制平面之前先来研究一下这些已经存在的。其次，正如 Datawire 的人们发现，并且 Daniel Bryant 最近也发文章说，为 Envoy 构建一个控制平面并不是那么容易的。&lt;/p&gt;
&lt;p&gt;我参与开发几个为 Enovy 构建控制平面的开源项目。比如，Gloo 是一个功能性网关，它可以作为强大的 Kubernetes 接入服务，API 网关，或者作为从单体服务到微服务过度的功能网关。Gloo 有一个针对 Envoy 的控制平面，它可以作为我这个系列文章的例子，来说明如何在控制平面上按照需求来抽象设计，以实现插件管理和扩展性管理。其它可以参考的已经实现的控制平面如 istio 和 &lt;a href=&#34;https://github.com/heptio/contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heptio Contour&lt;/a&gt;，这些也是贯穿我这个系列文章中的好例子。如果你确定要自己开发控制平面，那么除了这些，你还可以参考其它一些已经存在的控制平面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vly994j31200a875u_hu1214624163423222339.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vly994j31200a875u_hu2677776409840659152.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vly994j31200a875u_hu2845034642365716831.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vly994j31200a875u_hu1214624163423222339.webp&#34;
               width=&#34;760&#34;
               height=&#34;204&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个系列文章中，我们将会关注以下一些关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用一种机制可以动态更新 Envoy 的路由，服务发现和其它配置。&lt;/li&gt;
&lt;li&gt;识别使用哪些组件来构成你的控制平面，包括了后端存储，服务发现 API，安全组件等等。&lt;/li&gt;
&lt;li&gt;根据场景和团队组织以最合适的方式建立任意制定区域的配置对象和 API。&lt;/li&gt;
&lt;li&gt;思考如何在需要的地方以最好方式嵌入控制平面。&lt;/li&gt;
&lt;li&gt;部署各种控制平面组件的方式。&lt;/li&gt;
&lt;li&gt;思考如何测试控制平面。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要开始这一系列的讨论，我们首先来看看如何在 Envoy 运行时，使用 Envoy 的动态配置 API 来更新 Envoy，以处理拓扑和部署中的变更。&lt;/p&gt;
&lt;h2 id=&#34;使用-envoy-的-xds-api-动态配置-envoy&#34;&gt;使用 Envoy 的 xDS API 动态配置 Envoy&lt;/h2&gt;
&lt;p&gt;在 Envoy 之上构建构控制平面的主要方便支持处在于它的数据平面 API。有了数据平面 API，我们可就可以动态的配置 Envoy 的大多数重要运行时设置。通过 xDS API 进行的 Envoy 配置是被设计为最终一致性的，没有一种方法可以对集群中的所有代理进行原子性的更新。当控制平面上有配置更新时，它就通过 xDS API 让数据平面代理都可以获取到，每个代理都是相互独立的来获取应用这些配置。&lt;/p&gt;
&lt;p&gt;下面是我们可以通过 xDS 动态配置 Envoy 的部分运行时模型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/listeners/lds#config-listeners-lds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;监听发现服务（LDS）API&lt;/a&gt; - LDS 用于下发服务监听的端口。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/api-v2/api/v2/eds.proto#envoy-api-file-envoy-api-v2-eds-proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;终端发现服务（EDS）API&lt;/a&gt;- EDS 用户服务发现。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/http_conn_man/rds#config-http-conn-man-rds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;路由发现服务（RDS）API&lt;/a&gt;- RDS 用于流量路由决策。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/cluster_manager/cds#config-cluster-manager-cds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;集群发现服务（CDS）&lt;/a&gt;- CDS 用于可以路由流量过去的后端服务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/secret&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;密钥发现服务（SDS）&lt;/a&gt; - SDS 用户分发密钥（证书和密钥）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vnd41kj30p00gmjwe_hu3027481064060403977.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vnd41kj30p00gmjwe_hu9103891906210743332.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vnd41kj30p00gmjwe_hu4929486170653781220.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/0081Kckwly1gkx5vnd41kj30p00gmjwe_hu3027481064060403977.webp&#34;
               width=&#34;760&#34;
               height=&#34;505&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些 API 使用 proto3 的 Protocol Buffer 来定义的，并且已经有一些相关实现了，可以提供大家在构建自己的控制平面时参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/envoyproxy/go-control-plane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go-control-plane&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/envoyproxy/java-control-plane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;java-control-plane&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然每个 xDS（LDS/EDS/RDS/CDS/SDS，这些统称 xDS）都是可以动态可配置的，但是这并不意味着你必须动态配置所有内容。你可以组合适应，区分静态配置和动态配置。例如，要通过配置实现一种类型的服务发现：希望终端是动态的，但是集群在部署的时候就是已经知道路由信息了，所以你可以使用 Envoy 中的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/api-v2/api/v2/eds.proto#envoy-api-file-envoy-api-v2-eds-proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Endpoint Discovery Service&lt;/a&gt; 来静态的定义集群的配置。如果在部署的时候你不确定是那个上游集群，那你可以使用&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/cluster_manager/cds#config-cluster-manager-cds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cluster Discovery Service&lt;/a&gt;来动态的配置发现上游。关键是你可以构建一个工作流和处理流程来静态的配置你需要的部分，而且可以使用动态 xDS 服务在运行时发现你需要的部分。为什么有不同的控制平面实现，其中一个原因就是并不是所有人都有一个完全动态和可替代的环境（这个环境下所有的配置都应该是动态的），这点几乎不可能。根据现有条件的约束和可用工作流，要为你的系统采取合适级别的动态配置，而不是全动态配置。&lt;/p&gt;
&lt;p&gt;在 Gloo 的实现中，我们基于 go-control-plane 的实现来构建控制平面，实现了 xDS API 到 Envoy 的动态配置。Istio 和 Heptio Contour 也是使用这种方式。这个控制平面的 API 使用 gRPC streaming 实现，并且留了实现接口，所以我们在实现的时候只需要实现这些接口就可以了。这种方式可以以非常高效的方式把 Envoy 数据平面 API 集成到控制平面中。&lt;/p&gt;
&lt;p&gt;gRPC streaming 方式并不是唯一的更新 Envoy 配置的方法。在&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.5.0/api-v1/api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 早期版本中的 xDS API&lt;/a&gt;，轮询是唯一检测是否有新配置可用的方式。虽然这也是接受的，并且也符合配置更新最终一致性的原则，但是在网络和计算使用上还是不够高效。也比较困难去调整优化轮询配置以减少资源浪费。&lt;/p&gt;
&lt;p&gt;最后，一些 Envoy 管理系统的实现采取生成&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/v2_overview#static&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;静态 Envoy 配置文件&lt;/a&gt;和给 Envoy 周期性的覆盖写入磁盘上的配置文件，再执行&lt;a href=&#34;https://blog.envoyproxy.io/envoy-hot-restart-1d16b14555b5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 进程的热重启&lt;/a&gt;。在高度动态环境中（像 Kubernetes，实际上任何短暂的计算平台都算），管理这种文件的生成，传递，热重启等等会显得非常笨重。Envoy 最初就是在这样操作的（Lyft 公司创建这个项目是就是这样），但是它逐步发展到现在的 xDS API 了。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Gloo 团队相信使用 gRPC streaming 和 xDS API 来实现对 Envoy 的动态配置和控制是一种比较好的方式。同样，并不是所有的 Envoy 配置都应该是动态的，尤其是你不需要动态配置的内容。但是如果你是在一个高度动态的环境（比如在 Kubernetes 中），动态配置 Envoy 就很关键了。其它的环境或许也有这样的需要。不管怎么样，动态配置使用 gRPC streaming API 是最理想的，主要有以下一些好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事件驱动配置更新；在控制平面中配置会在可用的时候下发到 Envoy。&lt;/li&gt;
&lt;li&gt;不需要轮询配置变化了。&lt;/li&gt;
&lt;li&gt;不需要热重启 Envoy。&lt;/li&gt;
&lt;li&gt;不会中断流量。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;下一步&#34;&gt;下一步&lt;/h2&gt;
&lt;p&gt;这是系列文章的第一部分，我们只是建立了为 Envoy 构建控制平面的基本概念，简述了 xDS API 和对 Envoy 动态配置不同的考虑。在下一节，会在几天后发布，将会把控制面分解成为可部署的组件，确定你需要的组件，特定领域对象会是什么样子？以及对控制平面扩展插件的思考。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用了 Service Mesh 后我还需要 API 网关吗</title>
      <link>https://cloudnativecn.com/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/</link>
      <pubDate>Fri, 07 Feb 2020 10:42:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.christianposta.com/microservices/do-i-need-an-api-gateway-if-i-have-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;如文章标题所示，本文通过对 Service Mesh 技术和 API 网关的对比，着重分析了两者的功能重合点和分歧点，解答了开发者的困惑，为如果进行技术选型和落地提供了指导思路。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;这篇文章也许无法打破缠绕在 API 网关和服务网格周围的喧嚣。即便已经是 2020 年了，围绕这些话题仍然会存在大量的疑虑。我撰写此文是为了给出真实而具体的解释，以帮助大家理清它们之间的差异、重叠以及适用场景。如果你不同意我觉得我在添乱，或者想请我喝杯啤酒，欢迎随时在 Twitter 上@我（@christianposta）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;第一个曝光：&lt;/strong&gt; 我在 &lt;a href=&#34;https://solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt; 这家公司工作，公司的业务聚焦于今天我们要讨论的主题。我提前说明一下以免你会有“你的观点是有偏见的”的反应。每个人的观点都有偏见。但可以肯定的是，我在 Solo.io 工作是因为我想看到这些想法被付诸实施并推向市场，而不是与之相反。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个曝光：&lt;/strong&gt; 我正在写一本有关服务网格的书，名为《Istio in Action》，这花了我很多时间。在本文中，不可否认我是站在 Istio 的角度来讨论“服务网格”的，但如果我指的是更普遍的服务网格的概念时，我会特别指出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;为什么会有另一个关于此话题的博客&#34;&gt;为什么会有另一个关于此话题的博客？&lt;/h2&gt;
&lt;p&gt;有大量关于当前主题的文章。我们看过&lt;a href=&#34;https://aspenmesh.io/api-gateway-vs-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;“API 网关用于南北流量，而服务网格用于东西流量”&lt;/a&gt;。还有人写了&lt;a href=&#34;https://medium.com/microservices-in-practice/service-mesh-vs-api-gateway-a6d814b9bf56&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;“API 网关用于管理业务功能，而服务网格用于服务到服务通信”&lt;/a&gt;。&lt;a href=&#34;https://blog.getambassador.io/api-gateway-vs-service-mesh-104c01fa4784&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 网关具有服务网格不具备的特定功能&lt;/a&gt;，其中一些可能不再适用。另一方面，有些人&lt;a href=&#34;https://developer.ibm.com/apiconnect/2018/11/13/service-mesh-vs-api-management/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;更接近我的思考方式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;然而，市场中仍存在明显的困惑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我也希望看到人们如何看待不同方法之间权衡的严肃讨论。例如，服务网格和 API 网关之间的职责/主张存在重叠。人们对选择感到困惑和不知所措。&lt;/p&gt;
&lt;p&gt;— Andrew Clay Shafer 雷启理（@littleidea）&lt;/p&gt;
&lt;p&gt;June 12, 2019&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;困惑是什么&#34;&gt;困惑是什么&lt;/h2&gt;
&lt;p&gt;大约一年前，我写了一篇&lt;a href=&#34;https://blog.christianposta.com/microservices/api-gateways-are-going-through-an-identity-crisis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关于 API 网关身份危机&lt;/a&gt;的文章，评估了 API 管理 Kubernetes Ingress 和 API 网关（带有相关定义）的差异。在那篇文章的最后，我试图解释服务网格是如何应对这些功能的，但是没有详细说明它们如何不同，以及什么时候使用它们。我强烈推荐&lt;a href=&#34;https://blog.christianposta.com/microservices/api-gateways-are-going-through-an-identity-crisis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;阅读这篇文章&lt;/a&gt;，因为在某些方面，它是“第一部分”，本文作为“第二部分”。&lt;/p&gt;
&lt;p&gt;我认为产生混淆的原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术使用上存在重叠（代理）&lt;/li&gt;
&lt;li&gt;功能上存在重叠（流量控制，路由，指标收集，安全/策略增强等）&lt;/li&gt;
&lt;li&gt;“服务网格”可替代 API 管理的理念&lt;/li&gt;
&lt;li&gt;服务网格能力的误解&lt;/li&gt;
&lt;li&gt;一些服务网格有自己的网关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后一点尤其使人困惑。&lt;/p&gt;
&lt;p&gt;如果服务网格仅仅是针对东西流量（边界内），那么为什么有一些服务网格，如 Istio 所说，&lt;a href=&#34;https://istio.io/docs/reference/config/networking/gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;有一个 Ingress 网关&lt;/a&gt;针对南北流量（并且是网格的一部分）？例如下面来自 Istio Ingress 网关的文档：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网关描述了一个运行在网格边缘的负载均衡器，它接收传入或传出的 HTTP/TCP 连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们的 API 不是 HTTP 吗？如果我们通过 Istio 的网关将 HTTP 请求引入集群/网格中（顺便说一句，这基于强大的 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 代理&lt;/a&gt; 项目），这还不够吗？&lt;/p&gt;
&lt;h2 id=&#34;假设&#34;&gt;假设&lt;/h2&gt;
&lt;p&gt;当我们提到“服务网格”时，将假定是指 Istio 和 Istio 的网关。选择这个场景是因为它最能说明重叠和混淆。其他服务网格&lt;a href=&#34;https://www.consul.io/docs/connect/mesh_gateway.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;也有网关&lt;/a&gt;，而有些还&lt;a href=&#34;https://linkerd.io/2/tasks/using-ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;没有显式网关&lt;/a&gt;。当然你的情况也许会有所不同。&lt;/p&gt;
&lt;h2 id=&#34;它们的重叠在哪里&#34;&gt;它们的重叠在哪里&lt;/h2&gt;
&lt;p&gt;业务的第一个步骤是识别 API 网关和服务网格功能看上去重叠的区域。两者都处理应用程序流量，所以重叠应该不足为奇。下面的清单列举了一些重叠的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遥测数据收集&lt;/li&gt;
&lt;li&gt;分布式追踪&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;TLS 终止/开始&lt;/li&gt;
&lt;li&gt;JWT 校验&lt;/li&gt;
&lt;li&gt;请求路由&lt;/li&gt;
&lt;li&gt;流量切分&lt;/li&gt;
&lt;li&gt;金丝雀发布&lt;/li&gt;
&lt;li&gt;流量镜像&lt;/li&gt;
&lt;li&gt;速率控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好吧，它们确实有重叠。那么你需要一个？还是两个？还是都不需要？&lt;/p&gt;
&lt;h2 id=&#34;它们的分叉点在哪里&#34;&gt;它们的分叉点在哪里&lt;/h2&gt;
&lt;p&gt;服务网格运行在比 API 网关更低的级别，并在架构中所有单个服务上运行。服务网格为服务客户提供关于架构拓扑的“更多细节”（包括客户端负载均衡、服务发现、请求路由），应该实现的弹性机制（超时、重试、熔断），应该收集的遥测（度量、跟踪）和参与的安全流（mTLS、RBAC）。所有这些实现细节通常由某个 sidecar（请考虑 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;）提供给应用程序，但它们不必这样做。请参阅我在 ServiceMeshCon 有关服务网格数据平面演化的演讲。&lt;/p&gt;
&lt;p&gt;下面的话引自 &lt;a href=&#34;https://blog.christianposta.com/microservices/api-gateways-are-going-through-an-identity-crisis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 身份危机&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务网格的目标是通过在 L7 上透明地操作来解决任何服务/应用程序中列举的问题。换句话说，服务网格希望接入到服务中（而不是到服务中编写代码）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt; 服务网格为服务/客户端提供了更多关于架构其余部分实现的细节/保真度。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/mesh-details.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;另一方面，API 网关则扮演着不同的角色：“抽象细节”和解耦实现。API 网关提供了跨应用程序架构中所有服务的内聚抽象——作为一个整体，为特定的 API 解决了一些边缘/边界问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/abstract-api.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;无论服务网格是否存在，API 网关都存在于应用程序/服务之上，并为其他部分提供抽象。它们做的事情包括聚合 API、抽象 API 和用不同的实现方式暴露它们，并基于用户在边缘添加更复杂的零信任安全策略。应用程序架构边界上的问题与边界内的问题不同。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/infra-layers.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;边界问题与服务到服务的挑战不同&#34;&gt;边界问题与服务到服务的挑战不同&lt;/h2&gt;
&lt;p&gt;在微服务/云原生架构的边界上，API 网关提供了服务网格无法在同等程度上解决的三个主要能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;边界解耦&lt;/li&gt;
&lt;li&gt;严格控制数据的进出&lt;/li&gt;
&lt;li&gt;桥接安全信任域&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们看看：&lt;/p&gt;
&lt;h3 id=&#34;边界解耦&#34;&gt;边界解耦&lt;/h3&gt;
&lt;p&gt;API 网关的核心功能是为边界外的客户端提供稳定的 API 接口。从 &lt;a href=&#34;https://microservices.io/book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chris Richardson 的微服务模式一书&lt;/a&gt;中，我们可以将“API 网关模式”改写为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;显式地简化一组 API / 微服务的调用&lt;/p&gt;
&lt;p&gt;为一组特定的用户、客户端或消费者模拟“应用程序”的内聚 API。&lt;/p&gt;
&lt;p&gt;这里的关键是 API 网关，当它实现时，它将作为应用程序架构的单一入口点，成为客户端的 API&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来自 &lt;a href=&#34;https://blog.christianposta.com/microservices/api-gateways-are-going-through-an-identity-crisis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 网关身份危机&lt;/a&gt; 一文中 API 网关的实现案例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io Gloo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://spring.io/projects/spring-cloud-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud Gateway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Netflix/zuul&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix Zuul&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://strongloop.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM-Strongloop Loopback/Microgateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从功能上看，API 网关需要支持什么？企业在现实的用例中会看到哪些需要 API 网关（服务网格不太适合）的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求/响应转换&lt;/li&gt;
&lt;li&gt;应用协议转换如 REST/SOAP/XSLT&lt;/li&gt;
&lt;li&gt;错误/速率定制响应&lt;/li&gt;
&lt;li&gt;直接响应&lt;/li&gt;
&lt;li&gt;对 API/代理管道的精确控制&lt;/li&gt;
&lt;li&gt;API 聚合/分组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们挨个来看。&lt;/p&gt;
&lt;h4 id=&#34;请求响应传输&#34;&gt;请求/响应传输&lt;/h4&gt;
&lt;p&gt;作为在 API 网关上暴露 API 的一部分，您可能希望隐藏后端 API 实现的细节。这可能是改变请求内容、删除/添加标头、将标头放入正文的一些组合，反之亦然。当后端服务对 API 进行更改时，或者当客户端不能像提供方那样快速更新时，这提供了一个很好的从客户端解耦的点。&lt;/p&gt;
&lt;h4 id=&#34;应用协议转换&#34;&gt;应用协议转换&lt;/h4&gt;
&lt;p&gt;许多企业在技术上进行了投入，如基于 HTTP、SOAP 的 XML，或基于 HTTP 的 JSON。他们可能希望使用更严格的、特定于客户端的 API 来公开这些 API，并继续保持互操作性。此外，服务提供者可能希望利用新的 RPC 机制（如 gRPC）或流协议（如 rSocket）。&lt;/p&gt;
&lt;h4 id=&#34;错误速率定制响应&#34;&gt;错误/速率定制响应&lt;/h4&gt;
&lt;p&gt;转换来自上游服务的请求是 API 网关的一项重要功能，定制来自网关本身的响应也是如此。采用 API 网关的虚拟 API 进行请求/响应/错误处理的客户端也希望网关自定义其响应以适应该模型。&lt;/p&gt;
&lt;h4 id=&#34;直接响应&#34;&gt;直接响应&lt;/h4&gt;
&lt;p&gt;当客户端（受信任的或恶意的）请求不可用的资源，或由于某种原因被阻止上行时，最好能够终止代理并使用预先屏蔽的响应返回。&lt;/p&gt;
&lt;h4 id=&#34;对-api代理管道的精确控制&#34;&gt;对 API/代理管道的精确控制&lt;/h4&gt;
&lt;p&gt;没有一种方法可以满足所有代理的期望。API 网关应该能够改变应用其功能的顺序（速率限制、authz/n、路由、转换等），并在出现问题时提供一种调试方法。&lt;/p&gt;
&lt;h4 id=&#34;api-聚合&#34;&gt;API 聚合&lt;/h4&gt;
&lt;p&gt;在多个服务上公开一个抽象常常伴随着将多个 API 混合成一个 API 的期望。类似于 GraphQL 的东西可以满足这个需求。&lt;/p&gt;
&lt;p&gt;正如您所看到的，在客户端和提供服务者之间提供一个强大的解耦点涉及的不仅仅是允许 HTTP 通信进入集群这么简单。&lt;/p&gt;
&lt;h2 id=&#34;严格控制什么可以进入离开服务&#34;&gt;严格控制什么可以进入/离开服务&lt;/h2&gt;
&lt;p&gt;API 网关的另一个重要功能是“控制”哪些数据/请求允许进入应用架构，哪些数据/响应允许流出。这意味着，网关需要对进入或发出的请求有深入的理解。例如，一个常见的场景是 Web 应用程序防火墙防止 SQL 注入攻击。另一种是“数据丢失预防”技术，用于在请求 PCI-DSS/HIPPA/GDPR 时阻止 SSN 或 PII 被返回。边界是帮助实现这些策略的天然位置。&lt;/p&gt;
&lt;p&gt;同样，定义和实施这些功能并不像允许 HTTP 通信流进入集群那么简单。&lt;/p&gt;
&lt;h2 id=&#34;定制安全桥接信任域&#34;&gt;定制安全/桥接信任域&lt;/h2&gt;
&lt;p&gt;API 网关提供的最后一个主要功能是边缘安全性。这涉及到向存在于应用程序架构之外的用户和服务提供身份和范围策略，从而限制对特定服务和业务功能的访问。这与前面的部分相关。&lt;/p&gt;
&lt;p&gt;一个常见的例子是能够绑定到 OAuth/SSO 流，包括 Open ID Connect。这些“标准”的挑战在于，它们可能没有得到充分实施，也可能没有得到正确实施。API 网关需要一种方法来灵活地适应这些环境以及提供定制。&lt;/p&gt;
&lt;p&gt;在许多企业中，已经存在身份/信任/认证机制，API 网关的很大一部分是为了向后兼容而进行本地集成。虽然出现了 &lt;a href=&#34;https://spiffe.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFEE&lt;/a&gt; 这样的新标准，但企业需要一段时间才能落地，与此同时，API 网关（甚至是针对在其下一代架构上运行的应用程序的网关）是一个艰难的要求。同样，你可以检视并说这也和上面提到的变换/解耦点有关。&lt;/p&gt;
&lt;h2 id=&#34;怎样落地其中一个另一个两者两者都不&#34;&gt;怎样落地其中一个/另一个/两者/两者都不？&lt;/h2&gt;
&lt;p&gt;在之前的一篇博客中，我概述了一些&lt;a href=&#34;https://blog.christianposta.com/challenges-of-adopting-service-mesh-in-enterprise-organizations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;采用这种技术的挑战（API 网关和服务网格）&lt;/a&gt;，并给出了关于如何最好地应用这种技术的提示。&lt;/p&gt;
&lt;p&gt;重申一下：从边缘开始。这是架构中熟悉的一部分。也要考虑选择最合适的。自从我们引入了云基础设施和云原生应用架构以来，假设（编者注：文章开始所说的假设）已经发生了变化。例如，如果您打算采用 Kubernetes，我强烈建议您考虑使用从头开始构建的应用程序网络技术（例如，检查 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 代理&lt;/a&gt;和已经被提升和转移的应用程序网络技术）。例如，在 &lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;，我们已经为此建立了一个名为 Gloo 的开源项目。&lt;/p&gt;
&lt;p&gt;你需要一个服务网格吗？如果您正在部署到云平台，有多种类型的语言/框架来实现您的工作负载，并构建一个微服务架构，那么您可能需要一个。选择也很多。我做过各种比较和对比的演讲，最近的是 &lt;a href=&#34;https://www.slideshare.net/ceposta/navigating-mesh-istio-connect-and-linkerd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OSCON 演讲&lt;/a&gt;。请随意&lt;a href=&#34;http://twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参考&lt;/a&gt;并找到最合适你的。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;是的，API 网关在功能上与服务网格有重叠。它们在使用的技术方面也可能有重叠（例如，Envoy）。但是，它们的角色有很大的不同，理解这一点可以在部署微服务架构和发现无意的假设时为您省去很多麻烦。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>企业组织中采用服务网格的挑战</title>
      <link>https://cloudnativecn.com/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/</link>
      <pubDate>Tue, 22 Oct 2019 19:25:19 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.christianposta.com/challenges-of-adopting-service-mesh-in-enterprise-organizations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;本文作者介绍了企业组织采用服务网格面临的哪些挑战，建议企业应该从数据平面开始逐步推进，从了解它、熟悉它、再到扩大规模使用它，并且以介绍其演讲的幻灯片为切入点介绍了架构演进的步骤。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;最近，我写了&lt;a href=&#34;https://dzone.com/trendreports/migrating-to-microservices-2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一篇&lt;/a&gt;关于在企业组织中采用服务网格的具有哪些挑战的文章，这篇文章是为 DZone 及其迁移到微服务的报告撰写的。在这篇文章中，我们首先要解决的问题之一是“你是否应该沿着采用服务网格的道路走下去”，我是这么说的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先回答“不”。如果您刚刚开始使用微服务架构和少量的服务，请确保您首先准备好了基础部分。微服务及其相关的基础设施是一种优化方式，可以让您更快的变更应用程序。在没有服务网格的情况下，您可以朝着更快的方向前进。你甚至可能想要一些服务网格带来的好处，而不是去关注它所有的复杂性。那么，请看看类似 Gloo 的产品，一个建立在 Envoy 代理上的 API 网关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为在当前时刻，这是一个非常重要的考虑，有以下两大原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总的来看，服务网格的实现还没有准备好投入生产。&lt;/li&gt;
&lt;li&gt;全部投入 (all-in) 到一个服务网络的复杂性仍然很高。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这并不意味着没有团队成功地使用了服务网格，或者您应该远离它。但是，我确实认为您应该建立这样的能力，当您真正准备好了并且可以从中获益的时候，最终能成功地将服务网格引入。例如，在报告中，我列出了您&lt;strong&gt;可能想要使用&lt;/strong&gt;服务网格的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨多个集群部署大量微服务&lt;/li&gt;
&lt;li&gt;容器/k8s和虚拟机的混合部署&lt;/li&gt;
&lt;li&gt;用于构建服务的语言的异构部署&lt;/li&gt;
&lt;li&gt;网络可观测性的不完整和不一致视图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即使有了以上这些理由，你依然会面临这些挑战：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择哪一个服务网格产品？&lt;/li&gt;
&lt;li&gt;谁来做技术支持？&lt;/li&gt;
&lt;li&gt;单集群的多租户问题&lt;/li&gt;
&lt;li&gt;缺乏多集群的管理方法&lt;/li&gt;
&lt;li&gt;已有服务如何适配（sidecar 的生命周期、竞态条件等等）&lt;/li&gt;
&lt;li&gt;开发人员与运维人员的界限在哪里&lt;/li&gt;
&lt;li&gt;非容器环境/混合环境&lt;/li&gt;
&lt;li&gt;中心化 vs 去中心化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过我在&lt;a href=&#34;https://blog.christianposta.com/moving-on-from-red-hat/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat&lt;/a&gt;和现在&lt;a href=&#34;https://blog.christianposta.com/career/new-adventure-starts-at-solo-io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;加起来两年以上的工作，我一直在帮助人们解决那些棘手的问题 (顺便说一句，如果你想交谈/需要这些方面的帮助，可以通过&lt;a href=&#34;http://twitter.com/christianposta?lang=en&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt;联系我)。但有一件我从我们的客户/用户一直观察到，并且持续一段时间提出建议，那就是你采用服务网格的第一步，应该总是先使用在一定程度上（自行）隔离的数据平面技术，要了解它是如何工作的，如何实施，如何调试等等。&lt;/p&gt;
&lt;p&gt;例如，在我最近做的一次演讲中，我说过要从 Envoy（Envoy 是许多服务网格实现的底层数据平面技术）开始。PPT 如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-start-slow-slide&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;start-slow-slide&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/start-slow-slide_hu18108406989513513259.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/start-slow-slide_hu3181520876483472127.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/start-slow-slide_hu15292544148375762219.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/start-slow-slide_hu18108406989513513259.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      start-slow-slide
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从架构的角度来看，它可能是这样的：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-single-gateway&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;single-gateway&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/single-gateway_hu3903655991832465456.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/single-gateway_hu7815576826026248747.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/single-gateway_hu4808224198819675580.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/single-gateway_hu3903655991832465456.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      single-gateway
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当然，如果你要使用 Envoy，我&lt;a href=&#34;https://medium.com/solo-io/getting-started-with-a-service-mesh-starts-with-a-gateway-96384deedca2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;建议从 Gloo&lt;/a&gt;开始，这基本上是一个&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;具有 edge 与 API 网关能力的企业版 Envoy&lt;/a&gt;，并且很好地植入了服务网格。一旦你有了它，对它熟练使用，那么你就会准备好增加它的使用，甚至可能通过代理的分层引入一些隔离：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-multi-tier-gw&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;multi-tier-gw&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/multi-tier-gw_hu3715100316429805162.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/multi-tier-gw_hu5250106744402398806.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/multi-tier-gw_hu6965744750496012098.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/multi-tier-gw_hu3715100316429805162.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      multi-tier-gw
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来的方法是将网关推入到应用架构中。我们看到我们的用户在每个应用程序边界采用一个网关的方法，开始有了一个网格的“感觉”，但在应用程序引入了一些结构 (例如，&lt;a href=&#34;https://medium.com/solo-io/api-gateways-are-going-through-an-identity-crisis-d1d833a313d7&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 网关模式&lt;/a&gt;)。我开始称之为“waypoints”架构。就像飞行员使用航路点（waypoints）来指导他们的飞行计划一样，这些网关为您的应用架构增加了结构，同时解决了诸如安全性和 API 解耦的南北通信问题，同时为成功采用服务网格奠定了基础。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-bc-gw&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;bc-gw&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/bc-gw_hu13390444697338265715.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/bc-gw_hu1739182017219781967.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/bc-gw_hu16537157850857947893.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/bc-gw_hu13390444697338265715.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      bc-gw
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，您可以开始在应用程序中引入独立于边界的服务网格代理，以解决棘手的但恰恰是服务网格技术最擅长解决的 service-to-service 通信挑战：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-push-down-gw&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;push-down-gw&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/push-down-gw_hu9330693794835399619.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/push-down-gw_hu3824162132576765604.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/push-down-gw_hu13003081155321655110.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/push-down-gw_hu9330693794835399619.webp&#34;
               width=&#34;760&#34;
               height=&#34;432&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      push-down-gw
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里重要的部分是网关，并且仍然有非常有用的用途！它们向应用架构中添加结构和路径点，同时在需要的地方将某些实现细节与其他服务分离并隐藏起来。在很多方面，这都遵循了 DDD 有界上下文模型，网关提供了一个“反腐败”层。否则，如果你只是把所有的服务都当作“伙伴”，你就会开始坚定地迈向死星：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deathstar&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;deathstar&#34; srcset=&#34;
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/deathstar_hu14125506066022702861.webp 400w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/deathstar_hu12086501711159262881.webp 760w,
               /blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/deathstar_hu5478698456542335434.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/challenges-of-adopting-service-mesh-in-enterprise-organizations/deathstar_hu14125506066022702861.webp&#34;
               width=&#34;760&#34;
               height=&#34;433&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      deathstar
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;希望这篇文章有助于您奠定一个成功的方法，通过小范围使用服务网格，然后逐渐缓慢扩展有意义的各个地方，并且你的应用程序可以从服务网格架构中获益。否则，您将承担同时引入太多复杂性的风险，这将违背您实现应用程序和基础设施现代化的意图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为 Envoy 构建控制面指南第 2 部分：识别组件</title>
      <link>https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/</link>
      <pubDate>Fri, 28 Jun 2019 10:41:16 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-for-envoy-identify-components/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;编者按&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文介绍如何为 Envoy 构建控制面指南的第 2 部分：识别控制平面的各个组件。对实施 Envoy 控制平面需要了解的基础知识很有帮助。也算是 Envoy 的概念介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这个系列文章的前一篇&lt;/a&gt;中，我们浏览了 Envoy 动态配置对于在云原生环境中运行 Envoy 是多么的重要。在这篇文章中，我们来一起看看为了支持控制平面，我们需要如何协调各个组件。&lt;/p&gt;
&lt;p&gt;由于操作环境的变化很大，因此为 Envoy 实施控制平面所需的组件也是如此。例如，在一个极端情况下，如果你需要构建时静态生成 Envoy 文件并发送给 Envoy 的需求，你需要以下组件来满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模板引擎&lt;/li&gt;
&lt;li&gt;数据存储/ VCS，用于输入模板的值&lt;/li&gt;
&lt;li&gt;任何特定于服务的配置，可能/可能不与服务/应用程序一起存储&lt;/li&gt;
&lt;li&gt;一个将各个部分组合在一起的编排器&lt;/li&gt;
&lt;li&gt;一种将这些传递给 Envoy 的方法&lt;/li&gt;
&lt;li&gt;一种触发配置文件重新加载/热重启的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一方面，如果您选择使用 gRPC 流式 xDS 实现，则需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心 xDS 服务接口和实现&lt;/li&gt;
&lt;li&gt;用于处理向服务注册表注册/取消注册服务的组件&lt;/li&gt;
&lt;li&gt;服务注册表&lt;/li&gt;
&lt;li&gt;描述您的 Envoy 配置的抽象对象模型（可选）&lt;/li&gt;
&lt;li&gt;用于保存配置的数据存储&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;您最有可能需要支持 Envoy 操作的其他辅助组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;证书/ CA 存储&lt;/li&gt;
&lt;li&gt;统计收集引擎&lt;/li&gt;
&lt;li&gt;分布式跟踪后端/引擎&lt;/li&gt;
&lt;li&gt;外部认证&lt;/li&gt;
&lt;li&gt;限速服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，您需要考虑构建控制平面，以便组件独立运行，并且可以松散协作以满足控制平面的需求。您要做的最后一件事是通过部署整体控制平面来支持 Envoy 的微服务部署。例如，在&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开源 Gloo 项目&lt;/a&gt; 中，我们有以下驱动控制平面的组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Gloo&lt;/code&gt; - 一个事件驱动的组件，负责为核心 xDS 服务生成配置并为其提供服务，并配置自定义 Envoy 过滤器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Discovery&lt;/code&gt; - 一个可选组件，知道如何使用服务发现服务（Consul，Kubernetes 等）来发现和通告上游集群和端点。它还可以发现 REST 端点（通过 swagger），gRPC 功能（基于 gRPC 反射）和 AWS / GCP / Azure 云功能。该组件创建配置（在 Kubernetes 上，用&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CustomResourceDefinitions&lt;/a&gt;表示）&lt;code&gt;Gloo&lt;/code&gt;组件可用于 构建通过 xDS 表示的规范 Envoy 配置。我们将在本系列博客的后续部分中看到更多内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Gateway&lt;/code&gt; - 该组件允许用户使用更舒适的对象模型来根据其角色（即边缘网关，共享代理，knative 群集入口等）配置 Envoy 代理。控制平面的这一部分还生成“Gloo”控制平面可用于通过 xDS 生成 Envoy 配置的配置。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/gloo-control-plane_hu15052166512457288133.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/gloo-control-plane_hu9357010111900368503.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/gloo-control-plane_hu15593686230781484443.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/gloo-control-plane_hu15052166512457288133.webp&#34;
               width=&#34;522&#34;
               height=&#34;373&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正如您所看到的，这些基本组件被部署为协同工作的服务，以构建通过 xDS 提供的相应 Envoy 配置。Gloo 通过使用这些松散协调的控制平面组件来实现其强大的发现功能，对函数的语义理解等，这些组件可用于服务 Envoy 配置。当 Gloo 部署到 Kubernetes 时，存储和配置非常具有“kube-native”的感觉：所有内容都由&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自定义资源定义&lt;/a&gt;表示。具体而言，所有面向用户的配置以及驱动 xDS 端点的核心配置都是 CRDs。您可以使用 Kubernetes API 和 kubectl 与 Gloo 进行交互。但是，我们还提供了一个&lt;code&gt;glooctl&lt;/code&gt; &lt;a href=&#34;https://gloo.solo.io/cli/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CLI 工具来简化与 Gloo 控制平面的交互&lt;/a&gt; - 特别是如果你不想的话，你不必为了 YAML 而烦恼。通过这种方式，Gloo 非常注重开发人员的体验和简化 YAML 的配置，对开发人员（或任何人？）来说这些可能非常繁琐。&lt;/p&gt;
&lt;p&gt;Istio 也采用类似的方法来使用通过 Kubernetes CRDs 配置的松散协调的控制平面组件。Istio 的控制平面由以下部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Istio Pilot&lt;/code&gt;  - 核心 xDS 服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Istio Galley&lt;/code&gt;  - 配置/存储抽象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Istio Citadel&lt;/code&gt;  -  CA /证书引擎&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Istio Telemetry&lt;/code&gt; - 遥测信号的接收器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Istio Policy&lt;/code&gt; - 一个可插拔的策略引擎&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/istio-control-plane_hu3760615727816722426.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/istio-control-plane_hu13896229697445098622.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/istio-control-plane_hu13006578401014654115.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/istio-control-plane_hu3760615727816722426.webp&#34;
               width=&#34;760&#34;
               height=&#34;249&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Heptio Contour 实际上只有两个组件组成了它的控制平面，但是，由于它完全基于 Kubernetes，它实际上利用了很多内置的 Kubernetes 工具，如 Kubernetes API / Storage 和 CRDs 来驱动配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;contour&lt;/code&gt;服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init-container&lt;/code&gt; 启动引导&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/contour-control-plane_hu5573575581705568866.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/contour-control-plane_hu1506572108413987392.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/contour-control-plane_hu1456860666444689325.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-2-identify-components/contour-control-plane_hu5573575581705568866.webp&#34;
               width=&#34;760&#34;
               height=&#34;181&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Contour 使用&lt;code&gt;init-container&lt;/code&gt;为 Envoy 生成一个静态引导配置文件，告诉它在哪里找到 xDS 服务。xDS 服务器是控制平面中的第二个组件，默认情况下与数据平面一起部署，并提供单独部署的选项。我们将在本系列“部署控制平面组件”的第 5 部分中介绍这种架构及其权衡。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;确定控制平面所需的核心组件。不要试图构建一个单体的控制平面抽象，因为这将成为维护和更新的噩梦。在松散耦合的体系结构中构建控制平面所需的组件。如果您可以构建在 Kubernetes 之上，那么这样做：&lt;a href=&#34;https://medium.com/@allingeek/kubernetes-as-a-common-ops-data-plane-f8f2cf40cd59&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 提供了一个非常强大的集成数据平面&lt;/a&gt;用于操作分布式系统，例如 Envoy 控制平面。如果你在 Kubernetes 之上构建一个控制平面，你应该利用&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自定义资源定义&lt;/a&gt;来驱动配置你的控制平面。有些人选择使用&lt;a href=&#34;https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/annotations.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;入口定义&lt;/a&gt;，&lt;a href=&#34;https://www.getambassador.io/reference/configuration/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务注释&lt;/a&gt;，或&lt;a href=&#34;https://www.youtube.com/watch?v=a1tXFUrqt5M&amp;amp;list=PLj6h78yzYM2PF_iYEBntfR0m4KAZET18Q&amp;amp;index=14&amp;amp;t=0s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;配置映射&lt;/a&gt;来构建他们的控制平面。在 Kubernetes CRDs 可用之前，这些可能是适当的解决方法，但此时你应该避免这些方法并坚持使用 CRDs。就像&lt;a href=&#34;https://kubernetespodcast.com/episode/041-ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tim Hockin（Kubernetes 的创始人）在最近的播客中所说的那样&lt;/a&gt;，用于驱动 Ingress Gateway 资源的注释是一个糟糕的选择。&lt;/p&gt;
&lt;p&gt;本系列的下一篇文章实际上已经发布：&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-for-envoy-domain-specific-configuration-api/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为 Envoy 构建控制平面的指南第 3 部分 - 域特定配置 API&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>构建 Envoy 的控制平面手册第 5 部分 - 部署的权衡</title>
      <link>https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/</link>
      <pubDate>Fri, 14 Jun 2019 10:30:32 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.christianposta.com/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;作为探索为 Envoy 构建控制平面系列文章的第 5 部分，本文介绍了部署控制平面的选项与权衡，着重阐述了保持控制平面与数据平面解耦的几大好处，并且在文章结尾建议构建一个可拔插的控制平面以支持各种新特性、拓展和适配。&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;这是探索为 Envoy 构建控制平面&lt;a href=&#34;https://blog.christianposta.com/envoy/guidfor-build-a-control-plane-to-management-Envoy-Proxy-based-infrastructure/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;系列文章&lt;/a&gt;的第 5 部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-to-manage-envoy-proxy-based-infrastructure/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;采用一种机制来动态更新 Enovy 的路由、服务发现和其他配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-for-envoy-identify-components/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;识别构成控制平面的组件，包括支持存储、服务发现 api、安全组件等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/envoy/guidance-for-building-a-control-plane-for-envoy-domain-specific-configuration-api/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构建最适合你的使用场景和组织架构的特定域的配置对象和 api&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/guidance-for-building-a-control-plane-for-envoy-build-for-pluggability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;考虑如何最好地使你的控制平面可插在你需要它的地方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;部署各种控制平面组件的选项 (本文)&lt;/li&gt;
&lt;li&gt;基于控制平面的测试工具的思考&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上一篇文章中，我们探讨了为什么可拔插控制平面对于跟上快速迭代的 Envoy API 以及与组织可能采用的不同工作流集成至关重要。在本文中，我们将讨论部署各种控制平面组件时的权衡。&lt;/p&gt;
&lt;h2 id=&#34;部署控制平面组件&#34;&gt;部署控制平面组件&lt;/h2&gt;
&lt;p&gt;一旦您构建并设计了控制平面及其各种支持组件，您就需要准确地决定如何部署它的组件。在确定最适合您的实现时，您需要权衡各种安全性、可伸缩性和可用性问题。这些选项里包括将控制平面组件与数据平面一起部署，以及将控制平面与数据平面完全解耦。这里也有一个折中方案：部署一些与控制平面共存的组件，并保持一些集中。让我们来看看。&lt;/p&gt;
&lt;p&gt;在 Istio service-mesh 项目中，控制平面组件与数据平面分别部署和运行。这在服务网格实现中非常常见。也就是说，数据平面与应用程序一起运行，处理所有的应用程序流量，并通过 gRPC 流上的 xDS API 与控制平面通信。控制平面组件通常在它们自己的命名空间中运行，并且在理想情况下，不当操作或者意外使用将导致组件被锁定。&lt;/p&gt;
&lt;p&gt;Gloo 项目作为一个 API 网关，遵循类似的部署模型。控制平面组件与数据平面解耦，Envoy 数据平面使用 xDS gRPC 流来收集关于监听器、路由、端点和集群等的配置。您可以使用 Gloo 部署与数据平面代理共存的控制面板组件，但不建议这样做。我们稍后会看一些权衡。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-separatecontrolplane&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;separatecontrolplane&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hu12145064519117944850.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hu1952640949423725740.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hu16530017286167752970.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hu12145064519117944850.webp&#34;
               width=&#34;760&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      separatecontrolplane
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，我们研究了控制平面组件与数据平面的协同部署。在 Contour 项目中，默认情况下，控制平面组件是与数据平面一起部署的，尽管&lt;a href=&#34;https://github.com/heptio/contour/blob/master/docs/deploy-seperate-pods.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;存在一个拆分部署的选项&lt;/a&gt;。Contour 实际上利用 CRD 或 Ingress 资源进行配置，所以所有的配置文件处理和监控都发生在 Kubernetes 中。然而，xDS 服务却是与数据平面共同部署 (同样，这是默认情况—您依然可以将它们拆分)。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-codeployed&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;codeployed&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/codeployed_hu1580340437179214055.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/codeployed_hu17192045330719525453.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/codeployed_hu16371917329015739390.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/codeployed_hu1580340437179214055.webp&#34;
               width=&#34;231&#34;
               height=&#34;174&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      codeployed
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当&lt;a href=&#34;https://www.youtube.com/watch?v=a1tXFUrqt5M&amp;amp;list=PLj6h78yzYM2PF_iYEBntfR0m4KAZET18Q&amp;amp;index=14&amp;amp;t=0s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBay 为他们的 Envoy 部署构建了控制平面&lt;/a&gt;时，他们还将控制平面 (discovery pieces) 的&lt;em&gt;部分组件&lt;/em&gt;与数据平面联合部署。他们基本上自己实现了一个控制器来监视 CRD、Ingress 和服务资源，并且生成配置映射。然后，这些配置映射将由与 Pod 一起运行的&lt;code&gt;discovery&lt;/code&gt;容器使用，并随着改动重新热启动，以及更新 Envoy。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/ebay-control-plane_hu10688452327675684891.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/ebay-control-plane_hu16423499121144465709.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/ebay-control-plane_hu4255534220523928932.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/ebay-control-plane_hu10688452327675684891.webp&#34;
               width=&#34;760&#34;
               height=&#34;220&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/double-click-ebay-control-plane_hu3588137896082002136.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/double-click-ebay-control-plane_hu10022829264168795424.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/double-click-ebay-control-plane_hu13872821023811968885.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/double-click-ebay-control-plane_hu3588137896082002136.webp&#34;
               width=&#34;760&#34;
               height=&#34;239&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 Ebay 的案例中，我们看到了一种“混合”的方法，并且深受其架构其余部分的具体影响。那么，在为 Envoy 评估控制平面时，或者考虑自己构建控制平面时，应该如何部署控制平面组件？&lt;/p&gt;
&lt;h3 id=&#34;我应该将控制平面与数据平面分开吗&#34;&gt;我应该将控制平面与数据平面分开吗？&lt;/h3&gt;
&lt;p&gt;各种方法都有优缺点。&lt;a href=&#34;https://github.com/solo-io/gloo/graphs/contributor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 团队&lt;/a&gt;认为，对于大多数应用场景来说，保持控制平面独立是正确的选择，应该避免将控制平面与数据平面完全部署在一起。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hu12145064519117944850.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hu1952640949423725740.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hu16530017286167752970.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-deployment-tradeoffs/separatecontrolplane_hu12145064519117944850.webp&#34;
               width=&#34;760&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果 Envoy 是 L7 网络的核心和灵魂，那么控制平面就是大脑。部署与数据平面分离的控制平面非常重要，原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全性—如果您的数据平面中的某个节点受到攻击，您肯定不希望因为允许您的控制平面受到攻击而放弃对其他应用程序和网络的控制，从而加剧您的情况。此外，控制平面可以处理密钥、证书或其他机密的分发，这些机密信息应该与数据平面分开保存。&lt;/li&gt;
&lt;li&gt;伸缩性—您可能最终会以不同的方式伸缩数据平面和控制平面。例如，如果您的控制平面正在轮询 Kubernetes 中的服务/端点等，那么您肯定不希望将这些组件与您的数据平面放在一起—您将扼杀任何可伸缩性的机会。&lt;/li&gt;
&lt;li&gt;分组—您的数据平面可能具有不同的角色和职责；例如，您可能在边缘有数据平面 Envoy，这将需要不同的安全性和网络状态，而不是用于微服务的共享代理池与您可能部署的任何 sidecar 代理。将控制平面与数据平面放在一起会使数据和配置分开变得更加困难。&lt;/li&gt;
&lt;li&gt;资源利用—您可能希望根据组件分配或限制某些资源使用。例如，您的数据平面可能比控制平面更需要计算 (控制平面可能更需要内存)，并且您将使用不同的资源限制来满足这些角色的需求。将它们分开可以让您获得更多细粒度的资源池选项，而不只是将它们集中在一起。此外，如果控制平面和数据平面被配置在一起，并且争夺相同的资源，您可能会得到难以诊断的奇怪的尾延迟 (Tail Latency)。&lt;/li&gt;
&lt;li&gt;部署/生命周期—您可能希望独立于数据平面对控制平面进行补丁、升级或其他服务。&lt;/li&gt;
&lt;li&gt;存储—如果您的控制平面需要任何类型的存储，那么您可以单独配置它，如果您将组件分离出来，则不需要涉及数据平面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于这些原因，我们建议保持控制平面与数据平面解耦。&lt;/p&gt;
&lt;h2 id=&#34;要点&#34;&gt;要点&lt;/h2&gt;
&lt;p&gt;为 Envoy 构建控制平面并不容易，一旦您了解了工作流需要从控制平面得到什么，您就需要了解如何最好地部署它。Gloo 团队建议构建一个可拔插的控制平面，并将其与数据平面分开，原因如上所述。Gloo 的体系结构是这样构建的，它使&lt;a href=&#34;https://github.com/solo-io/gloo/graphs/contributor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 团队&lt;/a&gt;能够快速添加任何新特性和扩展，以支持任何平台、配置、过滤器，以及更多。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway 的身份认同危机</title>
      <link>https://cloudnativecn.com/blog/api-gateways-are-going-through-an-identity-crisis/</link>
      <pubDate>Mon, 13 May 2019 20:08:37 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/api-gateways-are-going-through-an-identity-crisis/</guid>
      <description>&lt;p&gt;如今，API 网关经历了一系列&lt;a href=&#34;https://en.wikipedia.org/wiki/Identity_crisis&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;身份认同危机&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们是集中式共享资源，有助于将 API 暴露和维护到外部实体吗？&lt;/li&gt;
&lt;li&gt;它们是否为集群的 ingress 哨兵，严格控制用户流量在集群的进出？&lt;/li&gt;
&lt;li&gt;或它们是否为某类 API 的集成，以便更简洁地表达 API，具体取决于它所具有的客户端类型？&lt;/li&gt;
&lt;li&gt;当然还有不愿多谈但我经常听到的一个问题：&amp;ldquo;服务网格是否会使 API 网关过时？&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;有关背景&#34;&gt;有关背景&lt;/h2&gt;
&lt;p&gt;随着技术的快速发展，以及行业在技术和架构模式中的快速发展，你会想到&amp;quot;这一切都让我头晕目眩&amp;quot;。在这篇文章中，我希望简化&amp;quot;API 网关&amp;quot;的不同身份，澄清组织中哪些组可能使用 API 网关（他们试图解决的问题），并重新关注第一原则。理想情况下，在本文结束时，您将更好地了解不同团队在不同层面的 API 架构的作用，以及如何从每个层面中获取最大价值。&lt;/p&gt;
&lt;p&gt;在我们深入研究之前，让我们对 API 这个术语非常清楚。&lt;/p&gt;
&lt;h2 id=&#34;我对-api-的定义&#34;&gt;我对 API 的定义：&lt;/h2&gt;
&lt;p&gt;一种明确且有目的地定义的接口，旨在通过网络调用，使软件开发人员能够以受控且舒适的方式对组织内的数据和功能进行编程访问。&lt;/p&gt;
&lt;p&gt;这些接口抽象了实现它们的技术基础结构的细节。对于这些设计好的端点，我们期望能有些一定程度的文档，例如使用指南，稳定性报告和向后兼容性。&lt;/p&gt;
&lt;p&gt;相反，仅仅因为我们可以通过网络与另一个软件通信并不一定意味着远程端点是这个定义好的 API。许多系统彼此通信，往往这种通信更加随意地发生，并且通过耦合和其他因素进行实时交互。&lt;/p&gt;
&lt;p&gt;我们创建 API 以提供对业务部分的深思熟虑的抽象，并实现新的业务功能以及偶发创新。&lt;/p&gt;
&lt;p&gt;在讨论 API 网关时首先列出的是 API 管理。&lt;/p&gt;
&lt;h2 id=&#34;api-管理&#34;&gt;API 管理&lt;/h2&gt;
&lt;p&gt;很多人都在 API 管理方面考虑 API 网关。这是合理的。但是让我们快速了解一下 API 网关到底是做什么的。&lt;/p&gt;
&lt;p&gt;通过&lt;a href=&#34;https://en.wikipedia.org/wiki/API_management&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Management&lt;/a&gt;，我们希望解决：当我们希望公开现有 API 以供其他人使用时，如何跟踪谁使用这些 API，实施允许谁使用这些 API 的策略，建立安全流以进行身份​​验证和授权允许，使用并构建可在设计时使用的服务目录，以促进 API 使用并为有效治理奠定基础。&lt;/p&gt;
&lt;p&gt;我们希望解决：现有的，规划好的 API，我们希望按照我们的条款分享给他人的问题。&lt;/p&gt;
&lt;p&gt;API 管理还可以很好地允许用户（潜在 API 消费者）自助服务，注册不同的 API 消费计划（想一想：指定价格点在给定时间范围内每个端点的每个用户的呼叫数）。我们能够实施这些管理功能的基础设施是我们的 API 流量通过的网关。在这一点上，我们可以执行诸如身份认证，流量限速，指标采集，以及其他策略执行操作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-management-sketch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;利用 API 网关的 API 管理软件示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://apigee.com/api-management/#/homepage&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Apigee&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.3scale.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat 3Scale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mulesoft.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mulesoft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://konghq.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个层面上，我们考虑 API（如上所述）以及如何最好地管理和允许访问它们。我们没有考虑服务器，主机，端口，容器甚至服务（另一个定义不明确的词，但你理解我的！）。&lt;/p&gt;
&lt;p&gt;API 管理（以及它们相应的网关）通常实现为由&amp;quot;平台团队&amp;quot;，&amp;ldquo;集成团队&amp;quot;或其他 API 基础架构团队拥有的严格控制的共享基础架构。通常这样做是为了强制执行一定程度的治理，变更管理和策略。在某些情况下，即使这些基础架构集中部署和管理，它们也可能支持更分散的物理部署。例如，Kong 的首席技术官 Marco Palladino 在评论中指出，Kong 可以选择部署的组件来支持集中式或分布式模型。&lt;/p&gt;
&lt;p&gt;有一点需要注意：我们要注意不要让任何业务逻辑进入这一层。如前一段所述，API 管理是共享基础架构，但由于我们的 API 流量通过它，它倾向于重造&amp;quot;全知全能&amp;rdquo;（思考企业服务总线）治理门户，为通过它，我们必须全盘改造我们的服务。理论上这听起来很棒。实际上，这可能最终成为组织瓶颈。有关更多信息，请参阅此文章：&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Network Functions with ESBs, API Management, and Now… Service Mesh?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;集群入口&#34;&gt;集群入口&lt;/h2&gt;
&lt;p&gt;为了构建和实现 API，我们专注于代码，数据，业务框架等方面。但是，要让这些的东西提供价值，必须对它们进行测试，部署到生产环境中并进行监控。当我们开始部署到云原生平台时，我们开始基于部署，容器，服务，主机，端口等考虑，以便构建我们的应用程序适应该环境。我们大概还需要制作工作流程（CI）和管道（CD），以利用云平台快速迭代，将其提供给客户等。&lt;/p&gt;
&lt;p&gt;在这种环境中，我们可以构建和维护多个集群来托管我们的应用程序，并需要某种方式来访问这些集群内的应用程序和服务。以 Kubernetes 为例。我们可以使用&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Ingress controller&lt;/a&gt;来允许访问 Kubernetes 集群（集群中的其他所有内容都无法从外部访问）。通过这种方式，我们可以非常严格地控制流量可能进入（甚至离开）我们的集群，具有明确定义的入口点，如域名/虚拟 hosts，端口，协议等。&lt;/p&gt;
&lt;p&gt;在这个层面中，我们可能希望某种&amp;quot;&lt;a href=&#34;https://istio.io/docs/tasks/traffic-management/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ingress gateway&lt;/a&gt;&amp;ldquo;成为允许请求和消息进入集群的流量哨兵。在这个层面中，你需要更多考虑的是：&amp;ldquo;我在我的集​​群中有这项服务，我需要集群外部的人能够调用它&amp;rdquo;。这可能是一个服务（暴露 API），一个系统整体，一个 gRPC 服务，一个缓存，一个消息队列，一个数据库等。有些人选择将其称为 API 网关，其中的一些可能实际上做得比流量入口/出口更多，但重点是问题存在于集群级操作上。由于我们倾向于部署更多集群（相对于单个高度多租户集群），我们最终会有更多网络入口点和彼此交互的需求。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/cluster-ingress-sketch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些类型的入口实现的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Envoy Proxy and projects that build upon it including:
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.getambassador.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Datawire Ambassador&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io Gloo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/heptio/contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heptio Contour&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HAProxy
&lt;ul&gt;
&lt;li&gt;Including &lt;a href=&#34;https://docs.openshift.com/container-platform/3.9/install_config/router/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenShift’s Router&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/ingress-nginx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NGINX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://traefik.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Kong/kubernetes-ingress-controller&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此层面的集群入口控制器由平台团队管理，但是这个基础架构通常与更分散的自助服务工作流程相关联（正如您期望从云原生平台那样）。请参阅&lt;a href=&#34;https://www.weave.works/blog/gitops-operations-by-pull-request&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;See the &amp;ldquo;GitOps&amp;rdquo; workflow as described by the good folks at Weaveworks&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;api-gateway-模式&#34;&gt;API Gateway 模式&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;API 网关&amp;quot;这一术语的另一重意思才是我最开始理解的，即它是最接近 API Gateway 模式的那个。 &lt;a href=&#34;https://www.chrisrichardson.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chris Richardson&lt;/a&gt;在第 8 章的&amp;rdquo;&amp;quot;&lt;a href=&#34;https://microservices.io/book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务设计模式&lt;/a&gt;&amp;ldquo;&amp;ldquo;一书中做了很好的工作。我强烈建议将该书用作本文和其他微服务模式的教学。在他的&lt;a href=&#34;https://microservices.io/patterns/apigateway.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;microservices.io&lt;/a&gt;网站可以上略扫一下即可知，API Gateway 模式，简而言之，是关于策划 API 以便更好地使用不同类别的消费者。此策略涉及 API 间接级别。您可能听到的代表 API Gateway 模式的另一个术语是&amp;quot;服务于前端的后端&amp;rdquo;，其中&amp;quot;前端&amp;quot;可以是单纯前端界面（UI），移动客户端，物联网客户端，甚至是其他服务/应用开发人员。&lt;/p&gt;
&lt;p&gt;在 API Gateway 模式中，我们明确简化了一组 API 的调用，以模拟特定用户，客户或消费者的&amp;quot;应用程序&amp;quot;的内聚 API。回想一下，当我们使用微服务来构建我们的系统时，&amp;ldquo;应用程序&amp;quot;的概念就会消失。API Gateway 模式有助于重塑此概念。这里的关键在于 API 网关，当它实现时，它成为客户端和应用程序的 API，并负责与任何后端 API 和其他应用程序网络端点（那些不符合上述 API 定义的端点）进行通信。&lt;/p&gt;
&lt;p&gt;与上一节中的 Ingress 控制器不同，此 API 网关更接近于开发人员的全局视图，并且不太关注为集群外消耗而暴露的端口或服务。这个&amp;quot;API Gateway&amp;quot;也不同于我们对已有 API 的进行管理所用的 API 管理观念。这个 API 网关掩盖了对可能暴露 API 的后端的调用，但是也可能会谈到较少描述为 API 的事情，例如对旧系统的 RPC 调用，使用不符合&amp;quot;REST&amp;quot;式优雅的协议调用，例如 JSON over HTTP，gRPC，SOAP，GraphQL，websockets 和消息队列这些黑科技。还可以调用这种类型的网关来进行消息级转换，复杂路由，网络负载均衡/回调以及响应的集成。&lt;/p&gt;
&lt;p&gt;如果您熟悉&lt;a href=&#34;https://www.crummy.com/writing/speaking/2008-QCon/act3.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Richardson 的 REST API 的成熟度模型&lt;/a&gt;，那么实现 API Gateway 模式的 API 网关会被要求集成更多的 Level 0 请求（以及介于两者之间的所有内容）而不是 Level 1-3 实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/richardson-model.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://martinfowler.com/articles/richardsonMaturityModel.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://martinfowler.com/articles/richardsonMaturityModel.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这些类型的网关实现仍然需要解决诸如速率限制，认证/授权，熔断，指标采集，流量路由等一类的事情。这些类型的网关可以在集群的边缘用作集群入口控制器，也可以在集群的深处用作应用程序网关。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-gateway-pattern.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此类 API 网关的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://spring.io/projects/spring-cloud-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud Gateway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io Gloo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Netflix/zuul&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix Zuul&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://strongloop.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM-Strongloop Loopback/Microgateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种类型的网关也可以使用更通用的编程或集成语言/框架来构建，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache Camel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io/projects/spring-integration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Integration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ballerina.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ballerina.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://vertx.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Eclipse Vert.x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/en/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NodeJS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于这种类型的 API 网关与应用程序和服务的开发密切相关，我们希望开发人员能够参与、帮助指定 API 网关公开的 API，了解所涉及的任何 mashup 逻辑以及需要能够快速测试和更改此 API 基础结构。我们还希望操作或 SRE 对 API 网关的安全性，弹性和可观察性配置有一些看法。此级别的基础架构还必须适应不断发展的按需自助服务开发人员工作流程。再次参见 GitOps 模型以获取更多信息。&lt;/p&gt;
&lt;h2 id=&#34;谈到服务网格&#34;&gt;谈到服务网格&lt;/h2&gt;
&lt;p&gt;在云基础架构上运行服务架构的一部分包括难以在网络中构建适当级别的可观察性和控制。在解决此问题的先前迭代中，&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们使用应用程序库和有希望的开发人员治理来实现此目的&lt;/a&gt;。然而，在规模和多语言环境中，&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格技术的出现提供了更好的解决方案&lt;/a&gt;。服务网格通过透明实现为平台及其组成服务带来以下功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务到服务（即东西流量）的恢复能力&lt;/li&gt;
&lt;li&gt;安全性包括最终用户验证，双向 TLS，服务到服务 RBAC / ABAC&lt;/li&gt;
&lt;li&gt;黑盒服务可观察性（专注于网络通信），用于请求/秒，请求延迟，请求失败，熔断事件，分布式跟踪等&lt;/li&gt;
&lt;li&gt;服务到服务速率限制，配额执行等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;精明的读者会认识到，&lt;a href=&#34;https://dzone.com/articles/api-gateway-vs-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 网关和服务网格的功能似乎有些重叠&lt;/a&gt;。服务网格的目标是通过在 L7 上透明地解决任何服务/应用程序来解决这些问题。换句话说，服务网格希望融入服务（实际上没有被编码到服务的代码中）。另一方面，API 网关位于服务网格和应用程序之上（L8？）。服务网格为服务，主机，端口，协议等（东/西流量）之间的请求流带来价值。它们还可以提供基本的集群入口功能，以便为北/南流量带来一些此功能。但是，这不应与 API 网关可以为南北向流量带来的功能相混淆（如在集群的北/南和向应用程序或应用程序组的北/南）。&lt;/p&gt;
&lt;p&gt;服务网格和 API 网关在某些领域的功能上重叠，但它们是互补的，因为它们生活在不同的层次并解决不同的问题。理想的解决方案是将每个组件（API Management，API Gateway，Service Mesh）即插即用，并在需要时在组件之间保持良好的界限（或者在不需要它们时将其排除）。同样重要的是找到&lt;a href=&#34;https://developer.ibm.com/apiconnect/2018/12/10/api-management-centralized-or-decentralized/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;适合您的分散开发人员和操作工作流程&lt;/a&gt;的这些工具的实现。尽管这些不同组成部分的术语和身份存在混淆，但我们应该依赖于第一原则并理解我们的架构中这些组件在何处带来价值以及它们如何独立存在并共存互补性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-layers.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;我们很乐意帮忙&#34;&gt;我们很乐意帮忙！&lt;/h2&gt;
&lt;p&gt;一些读者可能知道我热衷于帮助人们，特别是在云，微服务，事件驱动架构和服务网络领域。在我的公司，&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;，我们正在帮助 IT 组织认识并成功采用适当级别的网关和服务网格等 API 技术，以及他们成功优化它们的速度（更重要的是，他们确实需要这些技术！！）。我们在&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Proxy&lt;/a&gt;，&lt;a href=&#34;https://graphql.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GraphQL&lt;/a&gt;和&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;等技术的基础上构建了&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;，&lt;a href=&#34;https://sqoop.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Scoop&lt;/a&gt;和&lt;a href=&#34;https://supergloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SuperGloo&lt;/a&gt;等工具，以帮助实现 API 网关和服务网格管理。请直接联系我们（&lt;a href=&#34;https://twitter.com/soloio_inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@soloio_inc&lt;/a&gt;，&lt;a href=&#34;http://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http：//solo.io&lt;/a&gt;）或直接与我联系（&lt;a href=&#34;http://www.twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt;，&lt;a href=&#34;http://blog.christianposta.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;），深入了解我们的愿景以及我们的技术如何为您的组织提供帮助。在下一系列博客中，我们将深入探讨 API Gateway 模式，多集群场景的难点，多服务网格的难点等！敬请关注！&lt;/p&gt;
&lt;h2 id=&#34;相关阅读&#34;&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>为 Envoy 构建控制面指南第 4 部分：构建的可扩展性</title>
      <link>https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/</link>
      <pubDate>Mon, 22 Apr 2019 10:41:16 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility-40f8ac8e48e&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编者按&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文介绍如何为 Envoy 构建控制面指南的第 4 部分：构建的可扩展性。Gloo 团队建议将重点放在控制平面的简单核心上，然后通过插件和微服务控制器的可组合性扩展它。Gloo 的体系结构是这样构建的，它使 Gloo 团队能够快速添加任何新特性，以支持任何平台、配置、过滤器，以及更多的新特性。这就是为什么，尽管 Gloo 是非常 kubernets 原生的，但它是为在任何云上的任何平台上运行而构建的。核心控制平面的设计允许这样做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是探究为 Envoy 代理构建控制平面系列文章的第 4 部分。请关注&lt;a href=&#34;https://twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt;和&lt;a href=&#34;https://twitter.com/soloio_inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@soloio_inc&lt;/a&gt;将在一周内推出下一部分内容。&lt;/p&gt;
&lt;p&gt;在本系列博客中，我们将关注以下领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh-badb6c36a2af&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;采用一种机制来动态更新 Envoy 的路由、服务发现和其他配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-proxy-part-2-identify-components-2d0731b0d8a4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;确定控制平面由哪些组件组成，包括支持存储、服务发现 API、安全组件等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./Guidance-for-Building-a-Control-Plane-for-Envoy-Part-3-Domain-Specific-Configuration.md&#34;&gt;建立最适合您的使用场景和组织架构的特定于域的配置对象和 API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;考虑如何让控制平面支持可拔插 (本博客)&lt;/li&gt;
&lt;li&gt;部署各种控制平面组件的选项&lt;/li&gt;
&lt;li&gt;为你的控制平面考虑测试套件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;a href=&#34;./Guidance-for-Building-a-Control-Plane-for-Envoy-Part-3-Domain-Specific-Configuration.md&#34;&gt;上一篇文章&lt;/a&gt;中，我们探讨了为您的控制平面构建一个特定于领域的 API，使得该 API 最适合您的组织和工作流并满足首选条件/约束。&lt;/p&gt;
&lt;h2 id=&#34;构建可插拔的控制平面引擎&#34;&gt;构建可插拔的控制平面引擎&lt;/h2&gt;
&lt;p&gt;Envoy 是一个非常强大的软件，每天都有&lt;a href=&#34;https://github.com/envoyproxy/envoy/pull/4950&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;新的用例和贡献被提交给社区&lt;/a&gt;。尽管 Envoy 的核心非常稳定，但它建立在&lt;a href=&#34;https://github.com/envoyproxy/envoy-filter-example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可插拔的过滤器架构&lt;/a&gt;之上，因此人们可以为不同的 L7 协议编写新的编解码器或添加新的功能。目前，Envoy 过滤器是用 C++编写的，可以选择使用&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/http_filters/lua_filter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lua&lt;/a&gt;扩展 Envoy，但是也有&lt;a href=&#34;https://github.com/envoyproxy/envoy/issues/4272&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一些讨论支持 Web Assembly 实现&lt;/a&gt;可扩展性。同样值得注意的是，&lt;a href=&#34;https://cilium.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium&lt;/a&gt;社区的很多人正在围绕一个&lt;a href=&#34;https://cilium.io/blog/2018/10/23/cilium-13-envoy-go/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Go 的 Envoy 可扩展机制&lt;/a&gt;开展工作。伴随着 Envoy 社区的快速发展和需要配置这些新功能，还需要新的特定于领域的对象模型来支持想利用 Envoy 新平台的需求。在本节中，我们将探索沿着这两个维度扩展 Envoy 控制平面。&lt;/p&gt;
&lt;p&gt;通过编写 C++过滤器，扩展 Envoy 非常简单。我们在&lt;a href=&#34;https://github.com/solo-io/envoy-gloo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 项目&lt;/a&gt;上创建的 Envoy 过滤器包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/solo-io/squash&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Squash&lt;/a&gt;调试器
(&lt;a href=&#34;https://github.com/envoyproxy/envoy/tree/master/api/envoy/config/filter/http/squash&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/envoyproxy/envoy/tree/master/api/envoy/config/filter/http/squash&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Caching(目前为封闭源码;应该在不久的将来开放源代码)&lt;/li&gt;
&lt;li&gt;Request/Response 传输 (&lt;a href=&#34;https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/transformation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/transformation&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;AWS lambda (&lt;a href=&#34;https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/aws_lambda&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/aws_lambda&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;NATS streaming (&lt;a href=&#34;https://github.com/solo-io/envoy-nats-streaming&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/solo-io/envoy-nats-streaming&lt;/a&gt;, &lt;a href=&#34;https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/nats/streaming&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/solo-io/envoy-gloo/tree/master/source/extensions/filters/http/nats/streaming&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Google Cloud Functions (&lt;a href=&#34;https://github.com/solo-io/envoy-google-function&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/solo-io/envoy-google-function&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Azure function (&lt;a href=&#34;https://github.com/solo-io/envoy-azure-functions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/solo-io/envoy-azure-functions&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34;
           src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLgy1g202enyhmsg30q10iajsu.gif&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在上面的图示中，您可以看到请求是如果通过 Envoy 并经过一些过滤器的，这些过滤器具有应用于请求和响应的特定任务。你可以在&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;首席执行官/创始人&lt;a href=&#34;https://medium.com/@idit.levine_92620&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Idit Levine&lt;/a&gt;和 Solo.io 首席架构师&lt;a href=&#34;https://medium.com/@yuval.kohavi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Yuval Kohavi&lt;/a&gt;写的一篇博客文章中读到更多关于&lt;a href=&#34;https://medium.com/solo-io/building-a-control-plane-for-envoy-7524ceb09876&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 的功能和构建 Gloo 的控制平面所做的权衡&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因为 Envoy 功能非常多，而且一直在添加新特性，所以值得花一些时间来考虑是否要将控制平面构建为可扩展的，以便能够使用这些新特性。在 Gloo 项目中，选择在以下几个层次上进行扩展：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在核心 Gloo 配置对象的基础上构建更容易进行自定义特定域的配置对象&lt;/li&gt;
&lt;li&gt;控制平面插件化以增强控制平面的现有行为&lt;/li&gt;
&lt;li&gt;创建工具来加速前面两点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们来看看每一个层次，以及它们是如何构建可扩展和灵活的控制平面的。&lt;/p&gt;
&lt;h2 id=&#34;核心-api-对象构建时要考虑灵活性&#34;&gt;核心 API 对象，构建时要考虑灵活性&lt;/h2&gt;
&lt;p&gt;在上一节中，我们重点讨论了用于配置控制平面的特定于域的配置对象。在 Gloo 中，我们有&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最低级别的配置对象&lt;/a&gt;，称为&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy&lt;/a&gt;和&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstream&lt;/a&gt;。&lt;code&gt;Proxy&lt;/code&gt;定义了我们可以对底层代理 (在本例中是 Envoy) 进行的最低级别配置。使用&lt;code&gt;Proxy&lt;/code&gt;对象，我们定义请求如何路由到&lt;code&gt;Upstream&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面是 Proxy 对象的一个例子 (在 Kubernetes 中是 CRD)：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo.solo.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Proxy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;clusterName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2019-02-15T13:27:39Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;generation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;created_by&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway-proxy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo-system&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resourceVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;5209108&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selfLink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/apis/gloo.solo.io/v1/namespaces/gloo-system/proxies/gateway-proxy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;771377f2-3125-11e9-8523-42010aa800e0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;bindAddress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;::&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;bindPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;httpListener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;virtualHosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;domains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;s1&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo-system.default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;matcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exact&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/petstore/findPet&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routeAction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;single&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;destinationSpec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;functionName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;findPetById&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;parameters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;upstream&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default-petstore-8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo-system&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;matcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exact&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/sample-route-1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routeAction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;single&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;upstream&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default-petstore-8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo-system&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routePlugins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefixRewrite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefixRewrite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/api/pets&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;reported_by&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您可以看到&lt;code&gt;Proxy&lt;/code&gt;对象指定监听器、类型以及路由信息。如果您仔细观察，您会发现它在一定程度上遵循 Envoy 的配置，但在支持附加功能方面有所不同。在路由中，您可以看到请求被发送到“Upstream”。Gloo 知道如何路由到&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstream&lt;/a&gt;，您可以在上面的&lt;code&gt;Proxy&lt;/code&gt;对象中看到这些定义。&lt;code&gt;Proxy&lt;/code&gt;对象是由 Gloo 的控制平面转换为 Envoy xDS API 的对象。您会看到如下的 Gloo 的组件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                             READY   STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;discovery-676bcc49f8-n55jt       1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          8m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gateway-d8598c78c-425hz          1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          8m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gateway-proxy-6b4b86b4fb-cm2cr   1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          8m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gloo-565659747c-x7lvf            1/1     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          8m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;gateway-proxy&lt;/code&gt;组件是 Envoy 代理。控制平面由以下组件组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gateway&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;discovery&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gloo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;负责此&lt;code&gt;Proxy&lt;/code&gt;-&amp;gt;Envoy xDS 转换的组件是&lt;code&gt;gloo&lt;/code&gt;，它是一个事件驱动组件，通过将&lt;code&gt;Proxy&lt;/code&gt;对象转换为Envoy的LDS/RDS/CDS/EDS API，负责核心 xDS 服务和自定义 Envoy 过滤器的配置。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222c27h5dj30ht06174i_hu13581886372845052847.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222c27h5dj30ht06174i_hu4605556927948333687.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222c27h5dj30ht06174i_hu10117146104869518244.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222c27h5dj30ht06174i_hu13581886372845052847.webp&#34;
               width=&#34;641&#34;
               height=&#34;217&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Gloo 知道如何路由到&lt;code&gt;Upstream&lt;/code&gt;和它上面的函数。&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstream&lt;/a&gt;也是 Gloo 的核心配置对象。我们需要这个&lt;code&gt;Upstream&lt;/code&gt;对象的原因是，它封装了上游集群功能的更多实现，而不是 Envoy 所知道的开箱即用的功能。Envoy 知道“集群”，但是 Gloo(位于 Envoy 之上) 知道其上的函数。此功能支持&lt;a href=&#34;https://medium.com/solo-io/announcing-gloo-the-function-gateway-3f0860ef6600&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;功能级路由&lt;/a&gt;，功能级路由是用于组合新应用程序和 API 的更强大的路由结构。Envoy 从“host:port”端点方面了解集群，但是使用 Gloo，我们可以为这些集群附加额外的上下文，以便它们理解“函数”，这些函数可以是 REST 方法/路径、gRPC 操作或 Lambda 之类的云函数。例如，这里有一个名为&lt;code&gt;default-petstore-8080&lt;/code&gt;的 Gloo 上游：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;discoveryMetadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;discovered_by&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubernetesplugin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;petstore&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sevice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;petstore&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default-petstore-8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo-system&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;reportedBy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gloo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Accepted&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;upstreamSpec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kube&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;petstore&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;petstore&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servicePort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceSpec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;swaggerInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http://petstore.default.svc.cluster.local:8080/swagger.json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transformations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;addPet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;id&amp;#34;: {{ default(id, &amp;#34;&amp;#34;) }},&amp;#34;name&amp;#34;: &amp;#34;{{ default(name, &amp;#34;&amp;#34;)}}&amp;#34;,&amp;#34;tag&amp;#34;:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;                &amp;#34;{{ default(tag, &amp;#34;&amp;#34;)}}&amp;#34;}&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;POST&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/api/pets&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;content-type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;application/json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;deletePet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DELETE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/api/pets/{{ default(id, &amp;#34;&amp;#34;) }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;content-type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;application/json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;findPetById&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;GET&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/api/pets/{{ default(id, &amp;#34;&amp;#34;) }}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;content-length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;content-type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transfer-encoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;findPets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;GET&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/api/pets?tags={{default(tags, &amp;#34;&amp;#34;)}}&amp;amp;limit={{default(limit,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;)}}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;content-length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;content-type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transfer-encoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意，我们有更多责任来确定 upstream 的函数要公开哪些部分。在这种情况下，上游恰好是一个 REST 服务，它公开了一个&lt;a href=&#34;https://github.com/OAI/OpenAPI-Specification&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open API Spec/Swagger&lt;/a&gt;文档。Gloo 自动发现这些信息，并用这些信息丰富这个 Upstream 对象，然后可以在代理对象中使用这些信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222ij2oucj30ht0ep0ti_hu15270764055941103270.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222ij2oucj30ht0ep0ti_hu5397593793156490321.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222ij2oucj30ht0ep0ti_hu3052387926219316519.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g222ij2oucj30ht0ep0ti_hu15270764055941103270.webp&#34;
               width=&#34;641&#34;
               height=&#34;529&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;回到 Gloo 控制平面的组件，您将看到一个&lt;code&gt;discovery&lt;/code&gt;组件，它通过添加“Upstream Discovery Service”(UDS) 和“Function Discovery Service”(FDS) 来增强 Envoy 的服务发现 API。UDS 使用一组插件 (参见下一节) 自动地从各自的运行时目录中发现&lt;code&gt;Upstream&lt;/code&gt;。最简单的例子是在 Kubernetes 中运行时，我们可以自动发现&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Services&lt;/a&gt;。Gloo 还可以发现来自 Consul、AWS 和&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/plugins.proto.sk/#a-name-upstreamspec-upstreamspec-a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;其他&lt;/a&gt;的&lt;code&gt;Upstream&lt;/code&gt;。函数发现服务 (FDS) 评估已经发现的每个&lt;code&gt;Upstream&lt;/code&gt;，并尝试发现它们的类型 (REST、gRPC、GraphQL、AWS Lambda 等)。如果 FDS 能够发现关于上游的这些附加属性，它就会用这些“函数”丰富 upstream 元数据。&lt;/p&gt;
&lt;p&gt;Gloo 控制平面中的&lt;code&gt;discovery&lt;/code&gt;组件仅使用其 UDS 和 FDS 服务来发现&lt;code&gt;Upstream&lt;/code&gt;对象并将其写入 Kuberentes CRDs。从这里，用户可以创建从 Envoy 代理上的特定 API 路径到&lt;code&gt;Upstream&lt;/code&gt;上的特定函数的路由规则。Envoy 代理不直接与这个控制平面组件交互 (请回忆一下，Envoy 只使用&lt;code&gt;gloo&lt;/code&gt;组件公开的 xDS API)。相反，&lt;code&gt;discovery&lt;/code&gt;组件促进了向&lt;code&gt;Upstream&lt;/code&gt;的创建，然后可以由&lt;code&gt;Proxy&lt;/code&gt;对象使用。这是一个使用支持微服务 (本例中的&lt;code&gt;discovery&lt;/code&gt;服务) 来为控制平面的整体功能做出贡献的好例子。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Proxy&lt;/code&gt;和&lt;code&gt;Upstream&lt;/code&gt;是上一节中提到的较底层特定于域的配置对象。更有趣的是，我们如何在此之上分层一组配置对象，以满足具有更自定义工作流的用户特定用例。&lt;/p&gt;
&lt;h2 id=&#34;扩展特定于域的配置层&#34;&gt;扩展特定于域的配置层&lt;/h2&gt;
&lt;p&gt;在 Gloo 的控制平面中，还有另一个组件称为&lt;code&gt;gateway&lt;/code&gt;。该组件实现更高级别的特定于域的配置，用户最终将与之交互 (直接通过 YAML 文件或通过&lt;code&gt;glooctl&lt;/code&gt; CLI 工具间接地交互)。&lt;code&gt;gateway&lt;/code&gt;组件涉及两个特定于域的对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gateway/api/v1/gateway.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway&lt;/a&gt; — 指定特定监听器端口上可用的路由和 API 端点，以及每个 API 的安全性&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gateway/api/v1/virtual_service.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VirtualService&lt;/a&gt; — 将 API 路由分组到一组“虚拟 API”中，这些“虚拟 API”可以路由到支持的函数 (gRPC、http/1、http/2、lambda 等)；让开发人员控制路由如何处理&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/plugins/transformation/transformation.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不同的转换&lt;/a&gt;，以便将前端 API 与后端 API(以及后端可能引入的任何破坏性更改) 分离开来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g223285hajj30o20dxabd_hu11471859134957526233.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g223285hajj30o20dxabd_hu3878736900594028651.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g223285hajj30o20dxabd_hu5026144549322130083.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g223285hajj30o20dxabd_hu11471859134957526233.webp&#34;
               width=&#34;760&#34;
               height=&#34;440&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些对象允许与&lt;code&gt;Proxy&lt;/code&gt;对象解耦。当用户使用符合标准的 API 或是不标准的 API 创建新的&lt;code&gt;Gateway&lt;/code&gt;或&lt;code&gt;VirtualService&lt;/code&gt;对象时，Gloo 的&lt;code&gt;Gateway&lt;/code&gt;组件将接受这些对象 (Kubernetes 中的 crd、Consul 中的配置) 并更新底层&lt;code&gt;Proxy&lt;/code&gt;对象。这是扩展 Gloo 的一种常见模式：首选控件平面组件的可组合性。这允许我们为主观的领域特定对象构建更专门化的控制器，以支持不同的使用。比如&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;团队还为 Gloo 构建了一个名为&lt;a href=&#34;https://sqoop.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sqoop&lt;/a&gt;的开源控制器，该控制器遵循相同的模式，并扩展了 Gloo API，用于声明基于&lt;a href=&#34;https://graphql.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GraphQL 引擎&lt;/a&gt;的路由规则。在 Sqoop 中，我们引入&lt;a href=&#34;https://sqoop.solo.io/introduction/concepts/api_objects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Schema 和 ResolverMap&lt;/a&gt;对象，它们最终组合进 Proxy 对象，然后将代理对象转换为 Envoy xDS。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g2235n0elij30m80i5jsa_hu14461442121141411060.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g2235n0elij30m80i5jsa_hu15638203432740790355.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g2235n0elij30m80i5jsa_hu14347208026777447741.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-4-build-for-extensibility/006gLaqLly1g2235n0elij30m80i5jsa_hu14461442121141411060.webp&#34;
               width=&#34;760&#34;
               height=&#34;620&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;构建在基本 Gloo 对象上的领域特定配置分层的另一个例子是，我们最近在&lt;a href=&#34;https://medium.com/solo-io/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-324753586f3a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative 中使用 Gloo 代理作为 Istio 的替代方案&lt;/a&gt;。Knative 有一个用来声明集群入口资源的特定对象，称为&lt;a href=&#34;https://github.com/knative/serving/blob/master/pkg/client/clientset/versioned/typed/networking/v1alpha1/clusteringress.go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ClusterIngress&lt;/a&gt;对象，如下图所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.internal.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterIngress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serving.knative.dev/route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serving.knative.dev/routeNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld-go-txrqt&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;generation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;helloworld-go.default.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;helloworld-go.default.svc.cluster.local&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;helloworld-go.default.svc&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;helloworld-go.default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;paths&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;appendHeaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;knative-serving-namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;knative-serving-revision&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld-go-00001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;retries&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;attempts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;perTryTimeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;10m0s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;splits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;percent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;activator-service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-serving&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servicePort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;10m0s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;visibility&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ExternalIP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了支持 Gloo 中的这个用例，我们所做的就是&lt;a href=&#34;https://github.com/solo-io/gloo/blob/ac3bddf202423b297fb909eb6eff498745a8c015/projects/clusteringress/pkg/translator/translate.go#L19&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;构建一个新的控制器&lt;/a&gt;，用于监视和将&lt;a href=&#34;https://github.com/knative/serving/blob/master/pkg/client/clientset/versioned/typed/networking/v1alpha1/clusteringress.go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ClusterIngress&lt;/a&gt;对象转换为 Gloo 的&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy&lt;/a&gt;。有关在 Knative 中使用 Gloo 以简化&lt;a href=&#34;https://github.com/knative/serving&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Serving&lt;/a&gt;安装以使用 Gloo 作为集群入口的更多信息，请参阅&lt;a href=&#34;https://blog.christianposta.com/guidance-for-building-a-control-plane-for-envoy-build-for-pluggability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;本博客&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;控制平面插件化以增强现有行为&#34;&gt;控制平面插件化以增强现有行为&lt;/h2&gt;
&lt;p&gt;在上一节中，我们讨论了通过在核心对象之上分层特定于域的配置对象来扩展控制平面的功能。另一个扩展点直接位于控件平面核心对象本身中。在 Istio 中是&lt;code&gt;VirtualService&lt;/code&gt;和&lt;code&gt;DestinationRule&lt;/code&gt;，在 Contour 中是&lt;code&gt;IngressRoute&lt;/code&gt;，在 Gloo 中是&lt;code&gt;Proxy&lt;/code&gt;和&lt;code&gt;Upstream&lt;/code&gt;对象。例如，Gloo 的&lt;a href=&#34;https://github.com/solo-io/gloo/blob/7a5c3a9a7a060841a7047efce79e5b7b3ed981be/projects/gloo/api/v1/proxy.proto#L30&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy 对象&lt;/a&gt;包含&lt;a href=&#34;https://github.com/solo-io/gloo/blob/7a5c3a9a7a060841a7047efce79e5b7b3ed981be/projects/gloo/api/v1/proxy.proto#L90&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Listeners&lt;/a&gt;、&lt;a href=&#34;https://github.com/solo-io/gloo/blob/7a5c3a9a7a060841a7047efce79e5b7b3ed981be/projects/gloo/api/v1/proxy.proto#L124&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VirtualHosts&lt;/a&gt;和&lt;a href=&#34;https://github.com/solo-io/gloo/blob/7a5c3a9a7a060841a7047efce79e5b7b3ed981be/projects/gloo/api/v1/proxy.proto#L154&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Routes&lt;/a&gt;的扩展点。这意味着在 Proxy 配置中有一些定义良好的点，我们可以以最小的修改代价将新功能引入到我们的配置中 (例如，如果我们希望公开新的 Envoy 功能，或者为我们希望公开配置的 Envoy 编写新的过滤器等)。例如，我们&lt;a href=&#34;https://github.com/solo-io/gloo/blob/a27e1018640c46f7a25e4c1a0dc1f4cadf1773f5/projects/gloo/api/v1/plugins.proto#L44&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;编写了一些插件丰富了 Envoy 的路由和转换功能&lt;/a&gt;。例如，要将一个请求转换为 Envoy 并发送到一个名为&lt;code&gt;foo-service&lt;/code&gt;的服务，我们可以使用&lt;a href=&#34;https://github.com/pantor/inja&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Inja template&lt;/a&gt;手工插入头或正文。有关更多信息，请参见&lt;a href=&#34;https://gloo.solo.io/user_guides/function_routing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 文档中的函数路由指南&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;routes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;matcher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routeAction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;single&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;upstream&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foo-service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routePlugins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transformations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;requestTransformation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;transformationTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;x-canary-foo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;foo-bar-v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;:path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/v2/canary/feature&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;passthrough&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要查看 Gloo &lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy&lt;/a&gt;和&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstream&lt;/a&gt;对象上可用插件的完整列表，请参阅这里的&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/plugins.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;一旦向控制平面添加了新的插件，就可以扩展面向用户的特定于域的配置对象，以利用这些新功能。您可以增强现有的控制器来实现这一点，或者添加新的控制器 (遵循微服务松散协调的原则)。我们已经编写了&lt;a href=&#34;https://gloo.solo.io/dev/example-proxy-controller/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大量的例子来帮助您编写控制器&lt;/a&gt;来增强您的控制平面功能，或者在&lt;a href=&#34;https://slack.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slack&lt;/a&gt;上寻找更多关于这方面的指南。&lt;/p&gt;
&lt;h2 id=&#34;利用工具加快前面两个工作的实施&#34;&gt;利用工具加快前面两个工作的实施&lt;/h2&gt;
&lt;p&gt;在前几节中，我们了解了如何考虑控制平面的可扩展性和灵活性。我们了解了如何使用多层特定于域的配置对象，通过添加新对象和控制器来实现可扩展性。在&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;我们创建了一个名为&lt;a href=&#34;https://github.com/solo-io/solo-kit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;solo-kit&lt;/a&gt;的开源项目，它通过从&lt;a href=&#34;https://developers.google.com/protocol-buffers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protobuf&lt;/a&gt;对象开始，并通过代码生成正确的类型安全客户机，以便在平台上与这些对象交互，从而加快为您的控制平面构建新的、声明性的、自定义的 API 对象。例如，在 Kubernetes 上，&lt;a href=&#34;https://github.com/solo-io/solo-kit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;solo-kit&lt;/a&gt;将这些原型转换为&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CustomResourceDefinitions&lt;/a&gt;，并生成 Golang Kubernetes 客户机，用于监视和与这些资源交互。如果不在 Kubernetes 上，还可以使用 Consul、Vault 和其他组件作为后端存储。&lt;/p&gt;
&lt;p&gt;一旦您创建了资源并生成了类型安全的客户端，您就需要检测用户何时创建新资源或更改现有资源。使用&lt;a href=&#34;https://github.com/solo-io/solo-kit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;solo-kit&lt;/a&gt;，您只需指定希望查看哪些资源，或者称为“快照”的资源组合，客户端运行一个事件循环来处理任何通知。在事件循环中，可以更新协作对象或核心对象。事实上，这就是 Gloo 分层的特定于域的配置对象的工作方式。有关更多信息，请参见&lt;a href=&#34;https://gloo.solo.io/operator_guide/gloo_declarative_model/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 声明性模型文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;控制平面可以简单到您需要的程度，也可以复杂到您需要的程度。Gloo 团队建议将重点放在控制平面的简单核心上，然后通过插件和微服务控制器的可组合性扩展它。Gloo 的体系结构是这样构建的，它使&lt;a href=&#34;https://github.com/solo-io/gloo/graphs/contributors&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 团队&lt;/a&gt;能够快速添加任何新特性，以支持任何平台、配置、过滤器，以及更多的新特性。这就是为什么，尽管 Gloo 是非常 kubernets 原生的，但它是为在任何云上的任何平台上运行而构建的。核心控制平面的设计允许这样做。&lt;/p&gt;
&lt;p&gt;在本系列的下一篇文章中，我们将讨论部署控制平面组件的优缺点，包括可伸缩性、容错、独立性和安全性。请&lt;a href=&#34;https://twitter.com/soloio_inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;继续关注！&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>选择 FaaS 还是微服务？</title>
      <link>https://cloudnativecn.com/blog/faas-vs-microservices/</link>
      <pubDate>Tue, 09 Apr 2019 22:42:29 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/faas-vs-microservices/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://dzone.com/articles/faas-vs-microservices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在做项目的云原生改造时我们可以采用微服务架构。DevOps 和自动化构建两方面的成功经验对微服务的实践很有帮助。经过一段时间的实践，你可能会有将微服务架构推广到其他部门的想法。而你担心微服务本身的复杂性和分布式系统的高维护成本会让其他部门难以接受它。可能在我们想方设法解决微服务带来的问题时，总会有些人觉得这样做毫无意义。因为现在技术发展如此之快，总会出现更好的技术方案，你能保证自己在微服务领域所做的工作最后没有白费吗？&lt;/p&gt;
&lt;p&gt;我认为不会白费！&lt;/p&gt;
&lt;p&gt;现在“serverless”和“functions-as-a-service”（FAAS）还处于早期的炒作阶段。有些人觉得 serverless 就是下一代的微服务，所以我们应该跳过当前的微服务模式而直接采用 serverless。其实这种说法是有点夸大其词。作为架构师或开发者，我们通过学习新技术来提升自身能力让自己变得更&amp;quot;值钱&amp;quot;并没有错。但我们也要以务实态度来判断是否应该采用新技术。虽然持续跟进最新技术是我们作为架构师的职责所在，但掌握在之前的产品和 IT 部门引用新技术的时机也很重要。我们可以通过下面的模块来理解微服务架构和 serverless，从而让它们可以更好的融入我们的技术栈。&lt;/p&gt;
&lt;p&gt;首先，我们需要知道为什么我们需要微服务。选用微服务架构的主要原因就是避免项目的体量阻碍产品的迭代，所有微服务其他的优势都是基于这点。更快的迭代速度意味着可以更快的为客户交付新功能/修改，从而更快的验证这些改动能够带来的效果。我们需要快速的知道自己所做的努力是否能够带来好的效果，如果不能就要马上调整方向。快速迭代就是微服务架构的核心优势。&lt;/p&gt;
&lt;p&gt;对于大多数的团队而言，至少有一部分应用能从微服务的迭代过程中获益。因此作为架构师或开发者，我们不要因为采用微服务有门槛就对其失去信心。实践微服务的重要步骤就是确定和测量改进指标。改进指标一般可以为每天迭代应用的次数、保证迭代应用稳定性的方法等。&lt;/p&gt;
&lt;p&gt;另一方面，不是所有的应用都需要用这种松散而复杂的方式来保证服务的迭代速度。如果只想简单做个应用来验证自己创意的商业价值，那你完全可以选择更加适合的架构。这时采用 MVP 测试（最小可行性测试）就是个很好的方案。如果你因为商业价值很低而打算放弃的话，那也只是放弃了一个 MVP 应用。你可以非常快的迭代它并从潜在的用户中获得反馈。在这种情况下，你可能需要根据反馈反复修改 API、功能边界、组件等。所以过早就将组件功能做成分布式的服务也会拖慢产品的发布速度。你想修改分布式组件和它的 api 就必须在各个团队间进行协调。&lt;/p&gt;
&lt;p&gt;上述观点能够反映出微服务架构和单体架构适用不同的场景。而事实上并没有所谓&amp;quot;一招鲜吃遍天“的方案。当我们在微服务架构和单体架构之间纠结时，还需要考虑到所需服务是否已经存在以及它提供服务的方式（第三方服务/公司内部服务）。我们完全可以充分利用当前已有服务来构建我们的应用，不必重新购买硬件、安装和修补操作系统，以及优化服务从而达到最高吞吐量，而这也正是云及其服务存在的意义。云供应商和他们的合作伙伴能提供数据库、消息队列、缓存、CDN 和其他更高级的功能：例如语言翻译、地图/地理空间地图、天气等。我们可以组合各种按量付费的服务来构建自己的应用。如果在使用某个服务的时候无需关心安装、参数和容量等问题，其实我们就已经在采用 serverless 架构了。serverless 架构的特点就是可以重用已经存在的 service，而无需关心运行服务需要消耗些什么。&lt;/p&gt;
&lt;p&gt;函数即服务和 serverless 具有某种联系，因为它利用了缩小到单个应用程序函数的范围的计算模型，而这有助于将各种服务组合在一起构建应用。在这种模型下，功能按需分解，你只需为使用的功能付费。它特别适合对我们使用的服务进行按需计费和按量付费。这样一来我们能够构建弹性应用，而不需要考虑复杂的技术问题。将这些复杂的技术问题外包给别人可以让你更专注于为客户提供商业价值。&lt;/p&gt;
&lt;p&gt;但是将这部分能力外包不总是可行的。如果选择云服务，我们就丧失了对程序运行时、具体功能、bug 修复和接受监管的控制力。这也是需要考虑的一部分。&lt;/p&gt;
&lt;p&gt;serverless 不一定是完整的“公有云或无云”方案。如果以单个组织的角度来看，&amp;ldquo;serverless&amp;quot;可能只是代表整个体系的其他部分。例如：零售业务可以为组织内部其他服务或第三方提供“购买“服务以支持诸如分析、推荐以及其他使用“购买”服务的应用。利用定义良好的 API 和订阅并消费 API 的工作负载，你可以在自己的基础设施为微服务应用或单体应用提供 serverless 能力。在很多时候这其实就是服务向 SOA 架构进化的方向。但它们之间最大的不同就是在你将组织看作一个整体时，自己给自己的其他部分提供服务并不算 serverless。因为此时还是需要自己手动的去安装、管理和更新应用。&lt;/p&gt;
&lt;p&gt;最终采用哪种方案其实取决于很多因素，例如：业务、商业目标、软件部门对该技术的熟练度和历史遗留问题等。如果你觉得应该采用微服务架构，那就不要因为其他新技术而分心。我们可以持续跟进最新技术，从而保证适时的采用它们。总的来讲，不管是微服务架构、单体架构还是 serverless 架构，它们都有自己的应用场景。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为 Envoy 构建控制平面指南第 3 部分：领域特定配置</title>
      <link>https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/</link>
      <pubDate>Thu, 04 Apr 2019 18:00:43 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration-c97e8124b9d1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这是探索为 Envoy 代理构建控制平面系列文章的第 3 部分。&lt;/p&gt;
&lt;p&gt;在本系列博客中，我们将关注以下领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh-badb6c36a2af&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;采用一种机制来动态更新 Envoy 的路由、服务发现和其他配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-proxy-part-2-identify-components-2d0731b0d8a4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;确定控制平面由哪些组件组成，包括支持存储、服务发现 api、安全组件等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;建立最适合您的使用场景和组织架构的特定于域的配置对象和 api（本博客）&lt;/li&gt;
&lt;li&gt;考虑如何最好地使您的控制平面可插在您需要它的地方&lt;/li&gt;
&lt;li&gt;部署各种控制平面组件的选项&lt;/li&gt;
&lt;li&gt;通过控制平面的测试工具来思考&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在前面的&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-for-envoy-proxy-part-2-identify-components-2d0731b0d8a4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客部分&lt;/a&gt;中，我们评估了控制平面可能需要的组件。在本节中，我们将探索特定于域的 API 在您的控制平面上可能是什么样子的。&lt;/p&gt;
&lt;h2 id=&#34;建立您的控制平面交互点和-api-面&#34;&gt;建立您的控制平面交互点和 API 面&lt;/h2&gt;
&lt;p&gt;一旦您考虑了哪些组件可能构成您的控制平面体系结构 (请参阅前面的部分)，您就需要考虑您的用户将如何与控制平面交互，甚至更重要的是，您的用户将是谁？要回答这个问题，您必须决定基于 Envoy 的基础设施将扮演什么角色，以及流量将如何通过体系结构。它可以是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 管理网关（南北向流量）&lt;/li&gt;
&lt;li&gt;简单 Kubernetes 边缘负载均衡器/反向代理/入口控制（南北向流量）&lt;/li&gt;
&lt;li&gt;共享服务代理（东西向流量）&lt;/li&gt;
&lt;li&gt;每个服务的 sidecar（东西向流量）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio 项目旨在成为服务网格平台，用户通过平台，可以在此基础上构建工具来驱动服务和应用程序之间的网络控制。Istio 用于配置 Envoy 的领域特定配置对象主要围绕以下对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/docs/reference/config/networking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway&lt;/a&gt;：定义一个共享代理组件（能够集群进入），该组件指定可用于负载均衡和路由流量的协议、TLS、端口和主机/权限&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/docs/reference/config/networking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VirtualService&lt;/a&gt;：如何与特定服务交互的规则；可以指定诸如路由匹配、超时、重试等内容&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/docs/reference/config/networking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DestinationRule&lt;/a&gt;：如何与特定服务进行交互的规则，包括熔断、负载均衡、mTLS 策略、服务的子集定义等&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/docs/reference/config/networking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ServiceEntry&lt;/a&gt;：显式地将服务添加到 Istio 的服务注册中心&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocpfgj5dj30ma09dq3j_hu6584494835506811482.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocpfgj5dj30ma09dq3j_hu1709746329225464572.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocpfgj5dj30ma09dq3j_hu10413421848366492713.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocpfgj5dj30ma09dq3j_hu6584494835506811482.webp&#34;
               width=&#34;760&#34;
               height=&#34;319&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;运行在 Kubernetes 中的所有这些配置对象都实现为 &lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CustomResourceDefinitions&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/heptio/contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heptio/VMWare Contour&lt;/a&gt; 旨在作为 Kubernetes ingress 网关，并具有一个简化的特定于域的配置模型，具有 CustomResourceDefinition（CRD）风格和 &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes ingress 资源&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/heptio/contour/blob/master/docs/ingressroute.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IngressRoute&lt;/a&gt; 是一个 Kubernetes CRD，它提供一个位置来指定 Contour 代理的配置&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/heptio/contour/blob/master/docs/annotations.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ingress 资源支持&lt;/a&gt;，允许你在你的 Kubernetes Ingress 资源上指定注解。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLly1g1oao8vmp8j30hc05gaa8_hu2815880938051055325.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLly1g1oao8vmp8j30hc05gaa8_hu16900998908614308159.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLly1g1oao8vmp8j30hc05gaa8_hu8609507030873152773.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLly1g1oao8vmp8j30hc05gaa8_hu2815880938051055325.webp&#34;
               width=&#34;624&#34;
               height=&#34;196&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 项目&lt;/a&gt;中，将可用的配置对象分成两个级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为用户提供最佳符合人机工程学的面向用户的配置，并为可扩展性留下选项（下一节将详细介绍）&lt;/li&gt;
&lt;li&gt;抽象 Envoy 但不明确用于直接用户操作的低层配置。较高级别的对象被转换为这种较低级别的表示形式，最终用于转换为 Envoy xDS api。这样设计的原因将在下一节中说明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于用户，Gloo 关注拥有路由配置的团队，因为路由的语义（以及可用的转换/聚合功能）受到 API 和微服务开发人员的严重影响。对于面向用户的 API 对象，我们使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gateway/api/v1/gateway.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway&lt;/a&gt;：指定特定监听器端口上可用的路由和 API 端点，以及每个 API 的安全性&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gateway/api/v1/virtual_service.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VirtualService &lt;/a&gt;：将 API 路由分组到一组“虚拟 API”中，这些“虚拟 API”可以路由到支持的函数（gRPC、http/1、http/2、lambda 等）；使开发人员能够控制路由如何处理&lt;a href=&#34;&#34;&gt;不同的转换&lt;/a&gt;，从而尝试将前端 API 与后端 API（以及后端可能引入的任何破坏性更改）分离开来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，这些对象与这些对象的 Istio 变体不同。&lt;/p&gt;
&lt;p&gt;Gloo 中的面向用户的 API 对象驱动较低层的对象，这些对象最终用于派生 Envoy xDS 配置。例如，Gloo 的底层核心 API 对象是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/upstream.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstream&lt;/a&gt;：获取关于后端集群和在此上公开的函数的详细信息。您可以将 Gloo 上游与 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/cds.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 集群&lt;/a&gt;松散地关联起来，但有一个很大的区别：上游可以理解特定端点上可用的实际服务功能（换句话说，了解 &lt;code&gt;/foo/bar&lt;/code&gt; 和 &lt;code&gt;/bar/wine&lt;/code&gt;，包括它们的预期参数和参数结构，而不仅仅是 &lt;code&gt;hostname:port&lt;/code&gt;），后文会详细解释。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/v1/github.com/solo-io/gloo/projects/gloo/api/v1/proxy.proto.sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy&lt;/a&gt;：代理是抽象我们可以应用于 Envoy 的所有配置的主要对象。这包括监听器、虚拟主机、路由和上行流。高级对象（VirtualService，Gateway 等）用于驱动这个低级代理对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocrrdccrj30o20dxabd_hu11471859134957526233.webp 400w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocrrdccrj30o20dxabd_hu3878736900594028651.webp 760w,
               /blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocrrdccrj30o20dxabd_hu5026144549322130083.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-for-envoy-part-3-domain-specific-configuration/006gLaqLgy1g1ocrrdccrj30o20dxabd_hu11471859134957526233.webp&#34;
               width=&#34;760&#34;
               height=&#34;440&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Gloo 控件的两层配置之间的分离允许我们在保持配置 Envoy 的简单抽象的同时扩展 Gloo 控制平面功能。本系列的第 4 部分将对此进行更详细的解释。&lt;/p&gt;
&lt;p&gt;在前面的三个示例中（Istio、Contour、Gloo），每个控制平面公开一组特定于域的配置对象，这些对象以用户为中心，但最终转换为 Envoy 配置，并通过 xDS 数据面 API 公开。这提供了 Envoy 与用户的工作方式及其工作流之间的解耦。尽管我们已经看到了一些为抽象 Envoy 创建更关注用户和工作流的领域特定配置的例子，但这并不是构建 Envoy 控制平面的唯一方法。&lt;a href=&#34;https://www.slideshare.net/IvanKruglov/ivan-kruglov-introducing-envoybased-service-mesh-at-bookingcom-version-7&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Booking.com 有一个很棒的演示&lt;/a&gt;，介绍了他们是如何与 Envoy 配置保持更紧密的联系，并使用一个引擎将所有不同团队的配置片段合并到实际的 Envoy 配置中。&lt;/p&gt;
&lt;p&gt;除了考虑特定于域的配置之外，还应该考虑 API/对象模型的特定接触点。例如，Kubernetes 非常关注 YAML 和资源文件。您可以构建一个更特定于领域的 CLI 工具（就像 &lt;a href=&#34;https://docs.openshift.com/enterprise/3.2/dev_guide/new_app.html#dev-guide-new-app&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenShift 对 oc CLI&lt;/a&gt; ，&lt;a href=&#34;https://istio.io/docs/reference/commands/istioctl/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 对 istioctl&lt;/a&gt; ， &lt;a href=&#34;https://gloo.solo.io/cli/glooctl/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 对 glooctl&lt;/a&gt; 所做的那样）。&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;当您构建一个 Envoy 控制平面时，您是带着一个特定的意图或一组架构/用户来做这件事的。您应该考虑到这一点，并构建适合您的用户并改进您的 Envoy 操作工作流使其符合人体工程学的、有主见的特定于领域的 API。&lt;a href=&#34;https://github.com/solo-io/gloo/graphs/contributors&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 团队&lt;/a&gt;建议研究现有的 Envoy 控制平面实现，只有在其他实现都不合适的情况下才构建自己的 Envoy 控制平面。Gloo 的控制为扩展和定制奠定了基础。我们将在下一篇文章中看到，可以构建一个完全可扩展的控制平面，以适应许多不同的用户、工作流和操作约束。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Envoy Proxy 构建控制平面指南</title>
      <link>https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/</link>
      <pubDate>Wed, 06 Mar 2019 12:17:02 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/solo-io/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh-badb6c36a2af&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;编者案&#34;&gt;编者案&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Envoy 作为最受欢迎的早期网络组件，现在已经可以说是云原生架构中的通用数据平面。本文作者指引我们更方便的使用 Envoy，及其定制控制平面，作者通过收集到的数据给出定制控制平面不同的意见，非常中肯，后续系列会更深入，欢迎关注该系列文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 最近成为一个受欢迎的网络组件。几年前 Matt Klein &lt;a href=&#34;https://blog.envoyproxy.io/the-universal-data-plane-api-d15cec7a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;写了一篇博客&lt;/a&gt; ，讨论了 Envoy 的动态配置 API，以及 Envoy 发展的历史和动机。他称该博客为“通用数据平面 API”。由于许多其他项目采用&lt;a href=&#34;https://www.envoyproxy.io/community&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 作为其产品的核心组件，因此对于应用程序/L7 网络解决方案而言，毫不夸张地说，“Envoy 已成为云原生架构中的通用数据平面”，而不仅仅是简单建立了 API 标准。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfoc0c9yj20dm07faap_hu4812946534804844873.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfoc0c9yj20dm07faap_hu4934331983453669392.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfoc0c9yj20dm07faap_hu9679480568858658771.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfoc0c9yj20dm07faap_hu4812946534804844873.webp&#34;
               width=&#34;490&#34;
               height=&#34;267&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，由于 &lt;a href=&#34;https://blog.envoyproxy.io/the-universal-data-plane-api-d15cec7a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 的通用数据平面 API&lt;/a&gt; ，我们已经看到了许多 &lt;em&gt;管理层&lt;/em&gt; 的实现，用于配置和驱动基于 Envoy 的基础架构。我们将深入探讨为 Envoy 构建控制平面所需的内容，以便您可以使用此信息来评估哪种类型的基础架构最适合您的组织和使用情况。因为这是一个广泛的主题，我们将在未来几天发布的多部系列博客中解决它。&lt;/p&gt;
&lt;p&gt;在EnvoyCon/KubeCon上 有一些 &lt;a href=&#34;https://blog.envoyproxy.io/envoycon-recap-579d53576511&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;精彩的演讲&lt;/a&gt; ，一些组织分享了他们采用 Envoy 的经验，包括他们如何构建自己的控制平面。人们选择自己建立控制平面的一些原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现有的解决方案，建立在已有不同数据平面的控制平面，需要改造 Envoy（与已有方案且冲突）&lt;/li&gt;
&lt;li&gt;为没有任何现有开源或其他 Envoy 控制平面（即 VM，AWS ECS 等）的基础架构构建（商业公司必须重新建方案）&lt;/li&gt;
&lt;li&gt;不需要使用 Envoy 的所有功能; 只是一个子集（功能太多，需要精简）&lt;/li&gt;
&lt;li&gt;首选适用于Envoy配置的特定于域的API/对象模型，以更好地适应其工作流程/世界观（与已有方案冲突）&lt;/li&gt;
&lt;li&gt;当其组织准备部署时，暂时没有成熟的控制平面（走的太快）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mforyrc1j20go0digsn_hu8118104456080034633.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mforyrc1j20go0digsn_hu1785748900489719613.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mforyrc1j20go0digsn_hu13412529366652562526.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mforyrc1j20go0digsn_hu8118104456080034633.webp&#34;
               width=&#34;600&#34;
               height=&#34;486&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;若是因为一些早期采用者建立了他们自己的定制控制平面，并不意味着你现在也要自己重新开发控制平面。因为 Envoy 构建控制平面的项目在去年已经成熟了很多，若你决定重新开发另一个控制平面前你应该探索使用它们。其次，正如 Datawire 的人们发现的那样，&lt;a href=&#34;https://twitter.com/danielbryantuk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;丹尼尔·布莱恩特&lt;/a&gt; 最近明确表示， &lt;a href=&#34;https://www.infoq.com/articles/ambassador-api-gateway-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为 Envoy 建造一个控制平面并不适合胆小的人&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我参与&lt;/a&gt; 了 &lt;a href=&#34;https://github.com/istio/istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;几个&lt;/a&gt;为 Envoy 构建控制平面的&lt;a href=&#34;https://github.com/solo-io/gloo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开源项目&lt;/a&gt; 。例如， &lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt; 是 &lt;a href=&#34;https://medium.com/solo-io/announcing-gloo-the-function-gateway-3f0860ef6600&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一个功能网关&lt;/a&gt; ，可以充当非常强大的 Kubernetes 入口，API 网关或功能网关，以简化单体应用到微服务的过渡。Gloo &lt;a href=&#34;https://gloo.solo.io/introduction/architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;有一个 Envoy 的控制平面&lt;/a&gt; ，我们可以在这一系列的帖子中作为一个例子来说明如何构建一个简单的抽象，允许在你需要的控制点上实现可插拔性和可扩展性。您可以用作参考的其他可靠的控制平面实现是 &lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/heptio/contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heptio Contour&lt;/a&gt; 我们将在整个系列博客中使用这些作为很好的例子。如果不出意外，您可以了解 Envoy 控制平面存在哪些选项，并使用它来指导您的实施，如果您必须走这条路。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpbj0hgj21200a840t_hu7153264421838168547.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpbj0hgj21200a840t_hu16177728809570977714.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpbj0hgj21200a840t_hu7083585307291066634.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpbj0hgj21200a840t_hu7153264421838168547.webp&#34;
               width=&#34;760&#34;
               height=&#34;204&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个博客系列中，我们将看看以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用动态更新机制的 Envoy 路由、服务发现和其他配置&lt;/li&gt;
&lt;li&gt;确定构成控制平面的组件，包括后端存储、服务发现 API、安全组件等。&lt;/li&gt;
&lt;li&gt;为您和组织最适合的用例，建立任何特定于域的配置对象和 API&lt;/li&gt;
&lt;li&gt;考虑如何最好地将控制平面插入您需要的地方&lt;/li&gt;
&lt;li&gt;部署各种控制平面组件的选项&lt;/li&gt;
&lt;li&gt;通过控制平面的测试工具进行思考&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了开始这个系列，我们来看看使用 Envoy 的动态配置 API 在运行时更新 Envoy 以处理拓扑和部署的变化。&lt;/p&gt;
&lt;h2 id=&#34;使用-xds-api-动态配置-envoy&#34;&gt;使用 xDS API 动态配置 Envoy&lt;/h2&gt;
&lt;p&gt;构建在 Envoy 之上的主要优势之一是它的数据平面 API。使用数据平面 API，我们可以 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/intro/arch_overview/dynamic_configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;动态配置 Envoy 的大部分重要运行时设置&lt;/a&gt; 。Envoy 通过其 xDS API 的配置 &lt;a href=&#34;https://blog.envoyproxy.io/embracing-eventual-consistency-in-soa-networking-32a5ee5d443d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最终一致的&lt;/a&gt;  - 即无法影响集群中所有代理的“原子更新”。当控制平面具有配置更新时，它通过 xDS API 使它们可用于数据平面代理，并且每个代理将彼此独立地应用这些更新。&lt;/p&gt;
&lt;p&gt;以下是我们可以通过 xDS 动态配置的 Envoy 运行时模型的部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/listeners/lds#config-listeners-lds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;监听器发现服务 API -&lt;/a&gt; 用于发布监听流量的端口的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/listeners/lds#config-listeners-lds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LDS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/api-v2/api/v2/eds.proto#envoy-api-file-envoy-api-v2-eds-proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;端点发现服务 API-&lt;/a&gt; 用于服务发现的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/api-v2/api/v2/eds.proto#envoy-api-file-envoy-api-v2-eds-proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EDS&lt;/a&gt; ，&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/http_conn_man/rds#config-http-conn-man-rds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;路由发现服务 API-RDS&lt;/a&gt; 用于流量路由决策&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/cluster_manager/cds#config-cluster-manager-cds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;集群发现服务 -&lt;/a&gt; 用于后端服务的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/cluster_manager/cds#config-cluster-manager-cds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CDS&lt;/a&gt; ，我们可以将流量路由到该服务&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/secret&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;secret 发现服务 -&lt;/a&gt; 用于分发 Secret 的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/secret&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SDS&lt;/a&gt; （证书和密钥）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpqxtkyj20p00gm0yz_hu1843949318616797264.webp 400w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpqxtkyj20p00gm0yz_hu8480489569136244073.webp 760w,
               /blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpqxtkyj20p00gm0yz_hu471672870029468496.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/guidance-for-building-a-control-plane-to-manage-envoy-proxy-at-the-edge-as-a-gateway-or-in-a-mesh/61411417ly1g0mfpqxtkyj20p00gm0yz_hu1843949318616797264.webp&#34;
               width=&#34;760&#34;
               height=&#34;505&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;API 使用 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/overview/v2_overview#config-overview-v2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 Protocol Buffers&lt;/a&gt; 定义，甚至还有一些参考实现可用于引导您自己的控制平面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/go-control-plane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go 控制平面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/java-control-plane&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;java 的控制平面&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然这些领域（LDS/EDS/RDS/CDS/SDS，一起“xDS”）中的每一个都是动态可配置的，但这并不意味着您必须动态配置所有内容。您可以拥有静态定义的部分组合以及动态更新的部分组合。例如，要实现一种 &lt;code&gt;endpoints&lt;/code&gt; 预期为动态但 &lt;code&gt;clusters&lt;/code&gt; 在部署时众所周知 的服务发现类型，您可以静态定义 &lt;code&gt;clusters&lt;/code&gt; 并使用 Envoy 中 的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/api-v2/api/v2/eds.proto#envoy-api-file-envoy-api-v2-eds-proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;端点发现服务&lt;/a&gt; 。如果您不确定在部署时将使用哪些 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/intro/arch_overview/terminology&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;上游集群，&lt;/a&gt; 则可以使用 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.9.0/configuration/cluster_manager/cds#config-cluster-manager-cds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;集群发现服务&lt;/a&gt; 动态地找到那些。关键是，您可以构建一个工作流程和流程，静态配置您需要的部分，同时使用动态 xDS 服务来发现运行时所需的部分。您看到不同的控制平面实现的原因之一并不是每个人都有一个完全动态和可互换的环境，其中所有部分都应该是动态的。在给定现有约束和可用工作流程的情况下，采用最适合您系统的动态级别。&lt;/p&gt;
&lt;p&gt;在 Gloo 的情况下，我们使用&lt;a href=&#34;https://github.com/solo-io/gloo/blob/ac3bddf202423b297fb909eb6eff498745a8c015/projects/gloo/pkg/xds/envoy.go#L76&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 go-control-plane 的控制平面&lt;/a&gt; 来实现 xDS API 以服务 Envoy 的动态配置。与 Heptio Contour 一样，Istio 也使用此实现。此控制平面 API 利用 &lt;a href=&#34;https://grpc.io/docs/guides/concepts.html#server-streaming-rpc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC 流&lt;/a&gt; 调用和存根 API，因此您可以使用实现填充它。 &lt;a href=&#34;https://github.com/turbinelabs/rotor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Turbine Labs’Rotor 项目&lt;/a&gt; 是另一个不幸被弃用但可以用来学习的&lt;a href=&#34;https://github.com/turbinelabs/rotor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;项目&lt;/a&gt; 。这是将 Envoy 的数据平面 API 与控制平面集成的高效方法。&lt;/p&gt;
&lt;p&gt;gRPC 流不是更新 Envoy 配置的唯一方式。在&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/v1.5.0/api-v1/api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以前版本的 Envoy xDS API 中&lt;/a&gt; ，轮询是确定新配置是否可用的唯一选项。虽然这是可以接受的，并且符合“最终一致”配置更新的标准，但它在网络和计算使用方面效率都较低。也可能难以适当地调整轮询配置以减少浪费的资源。&lt;/p&gt;
&lt;p&gt;最后，一些 Envoy 管理实施选择生成 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/v2_overview#static&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;静态 Envoy 配置文件，&lt;/a&gt; 并定期替换 Envoy 磁盘上的配置文件，然后执行 &lt;a href=&#34;https://blog.envoyproxy.io/envoy-hot-restart-1d16b14555b5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 进程&lt;/a&gt; 的 &lt;a href=&#34;https://blog.envoyproxy.io/envoy-hot-restart-1d16b14555b5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;热重新加载&lt;/a&gt; 。在高度动态的环境中（如 Kubernetes，但实际上是任何基于 ephemeral-compute 的平台），此文件生成，交付，热重启等的管理可能变得难以处理。Envoy 最初是在一个执行此类更新的环境中运行的（Lyft，它是在哪里创建的），但它们逐渐转向使用 xDS API。&lt;/p&gt;
&lt;h2 id=&#34;takeaway&#34;&gt;Takeaway&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/solo-io/gloo/graphs/contributors&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo 团队&lt;/a&gt; 认为使用 gRPC 流和 xDS API 是实现 Envoy 动态配置和控制的理想方式。同样，如果您不需要，并非所有 Envoy 配置都应动态提供，但是如果您在高度动态的环境中运行（例如，Kubernetes），则动态配置 Envoy 的选项至关重要。其他环境可能没有这种需求。无论哪种方式，动态的 g​​RPC 流 API 都是理想的选择。这种方法的一些好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件驱动的配置更新; 当配置在控制平面中可用时，配置被推送到 Envoy&lt;/li&gt;
&lt;li&gt;无需轮询更改&lt;/li&gt;
&lt;li&gt;没有必要热加载 Envoy&lt;/li&gt;
&lt;li&gt;没有中断流量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;下一步是什么&#34;&gt;下一步是什么&lt;/h2&gt;
&lt;p&gt;在第一部分中，我们通过介绍 xDS API 以及为 Envoy 提供动态配置的不同选项，为如何为 Envoy 构建控制平面建立了一些基本背景。在接下来的部分中，将在几天内发布，将涵盖将您的控制平面分解为可部署组件，确定您需要哪些部分，特定于域的配置对象模型，以及如何考虑控件的可插拔性平面。关注 twitter（ &lt;a href=&#34;https://twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt; ， &lt;a href=&#34;https://twitter.com/soloio_inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@ solio_in&lt;/a&gt; ）或博客（ &lt;a href=&#34;https://medium.com/solo-io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://medium.com/solo-io&lt;/a&gt; ）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>应用程序安全性和正确性的责任不能推卸给 Istio 和任何服务网格</title>
      <link>https://cloudnativecn.com/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/</link>
      <pubDate>Thu, 23 Aug 2018 15:31:39 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/</guid>
      <description>&lt;p&gt;我最近在讨论集成服务的演进以及服务网格的使用，特别是关于 Istio。自从 2017 年 1 月我听说了 Istio 以来，我一直很兴奋，事实上我是为这种新技术感到兴奋，它可以帮助组织构建微服务以及原生云架构成为可能。也许你可以说，因为我已经写了很多关于它的文章（请关注 &lt;a href=&#34;https://twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt; 的动态)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/the-hardest-part-of-microservices-calling-your-services/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Hardest Part of Microservices: Calling Your Services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/00-microservices-patterns-with-envoy-proxy-series/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microservices Patterns With Envoy Sidecar Proxy: The series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Network Functions With ESBs, API Management, and Now.. Service Mesh?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/comparing-envoy-and-istio-circuit-breaking-with-netflix-hystrix/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Comparing Envoy and Istio Circuit Breaking With Netflix OSS Hystrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/traffic-shadowing-with-istio-reduce-the-risk-of-code-release/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traffic Shadowing With Istio: Reducing the Risk of Code Release&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/advanced-traffic-shadowing-patterns-for-microservices-with-istio-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Advanced Traffic-shadowing Patterns for Microservices With Istio Service Mesh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/how-a-service-mesh-can-help-with-microservices-security/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How a Service Mesh Can Help With Microservices Security&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio 建立在容器和 Kubernetes 的一些目标之上：提供有价值的分布式系统模式作为语言无关的习惯用法。例如：Kubernetes 通过执行启动/停止、健康检查、缩放/自动缩放等来管理容器，而不管容器中实际运行的是什么。类似的，Istio 可以通过在应用程序容器之外透明地解决可靠性、安全性、策略和通信方面的挑战。&lt;/p&gt;
&lt;p&gt;随着 &lt;a href=&#34;https://istio.io/blog/2018/announcing-1.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 1.0&lt;/a&gt; 版本在 2018 年 7 月 31 日的发布，我们看到 Istio 的使用和采纳有了很大的增加。我看到的一个问题是“如果 Istio 为我提供了可靠性，那么在应用程序中我还需要在担心它吗？”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的答案是：绝对要！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;就在前一年，我写了一篇文章&lt;/a&gt;，其中包含了这一区别，但并不是足够有力；这篇文章是我试图纠正这一点，&lt;a href=&#34;https://www.slideshare.net/ceposta/evolution-of-integration-and-microservices-patterns-with-service-mesh-107786281&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;并建立在前面提到的谈话的基础上&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因此，设置一些上下文：Istio 提供了应用程序网络的“可靠性”能力，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动重试（automatic retry）&lt;/li&gt;
&lt;li&gt;重试配额/预算（retry quota/budget）&lt;/li&gt;
&lt;li&gt;连接超时（connection timeout）&lt;/li&gt;
&lt;li&gt;请求超时（request timeout）&lt;/li&gt;
&lt;li&gt;客户端负载均衡（client-side load balancing）&lt;/li&gt;
&lt;li&gt;断路器（circuit breaking）&lt;/li&gt;
&lt;li&gt;隔离层（bulkheading）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在处理分布式系统时，这些功能是必不可少的。网络并不是可靠的，并且破坏了我们在一个整体中所拥有的很多好的安全假设/抽象。我们要么迫切的解决这些问题，要么遭受系统范围内不可预测的停机。&lt;/p&gt;
&lt;h2 id=&#34;退一步说&#34;&gt;退一步说&lt;/h2&gt;
&lt;p&gt;这里更大的问题实际上是让应用程序相互通信来解决一些业务的问题。这就是为什么我们编写软件的原因，最终用来提供某种商业价值。同时该软件也使用一些商业领域模型，例如：“客户”、“购物车”、“账户”等。从领域驱动的设计来看，每个服务可能在理解这些概念上都略微有不同。&lt;/p&gt;
&lt;p&gt;这里有一些不太明确的概念和更大的业务约束（例如：客户可以由名称和电子邮件来确认唯一性，或者客户只能拥有一种类型的支票账户等），以及不可靠的网络和整个不可预知的基础设施（假定可以构建这样的服务，可以或者失败）使构建正确是非常困难的。&lt;/p&gt;
&lt;h2 id=&#34;端到端的正确性和安全性&#34;&gt;端到端的正确性和安全性&lt;/h2&gt;
&lt;p&gt;然而，事实上是，在构建正确和安全的应用程序方面，这样的责任归属到了应用程序上（以及所有它支持的人）。我们可以尝试将更低级别的可靠性构建到系统的性能或优化的组件中，但总的责任还是在应用程序中。1984 年 Saltzer、Reed 和 Clark 在“系统设计中的端到端论证”中提到了这一原则。具体地说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只有在对通信系统端点的应用程序足够了解的情况下，才能完全正确的实现所讨论的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里，“功能”是应用程序的需求之一，比如“预订”或“向购物车中添加商品”。这种功能不能概括为通信系统或其组件/基础设置（这里的通信系统指的是网络、中间件和任何为应用程序提供基础设施的工作）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因此，提供被质疑的功能作为通信系统本身的特质是不可能的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，我们可以做一些事情以保证通信系统的部分可靠，这样有助于实现更高层次的应用程序的需求。我们做这些事情后可以优化部分区域，这样不至于过于担心这样的问题，但应用程序不能完全忽略这些事情：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有时，通信系统提供的非完整的版本的功能，可能对于增强性能很有用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：在 Saltzer 的论文中，他们使用从应用程序 A 传输文件到应用程序 B 的示例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwgy1fuibtn8kvfj31fc0v2ju4.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们需要做什么（安全）来保证文件被正确的传送到？在图中的任何一点都有能出现错误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存储机制可能有失败的区域/移位的比特/损坏，所以当应用程序 A 读取一个文件时，读取的是一个错误的文件；&lt;/li&gt;
&lt;li&gt;应用程序在读取文件到内存中或者发送文件时存在 bug；&lt;/li&gt;
&lt;li&gt;网络可能混淆字节的顺序，文件部分重复等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以进行优化，例如使用更可靠的传输，如 TCP 协议或消息队列，但是 TCP 不知道“正确传输文件”的语意，所以我们期望的最好结果至少是当我们在网络上处理事情时，网络是可靠的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwgy1fuiihqrv73j31es0eqjsf.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了完整的实现端到端的正确性，我们可能需要使用一些类似文件校验的东西，与文件一起在文件初始化时写入，然后在 B 接收文件时校验其校验和。然而，我们在校验传输的正确性（实现细节），其职责在于找出解决方案并使其正确，而不是使用 TCP 或者消息队列。&lt;/p&gt;
&lt;h2 id=&#34;典型的模式是什么样的&#34;&gt;典型的模式是什么样的？&lt;/h2&gt;
&lt;p&gt;为了解决分布式应用程序中应用程序的正确性和安全性，我们可以使用一些模式。在早些时候，我们提到了 Istio 提供给我们的一些可靠的模式，但这些并不是唯一的。通常，有两类模式可以帮助我们正确和安全的构建应用程序，并且这两类模式是相关的。我们称这类位“应用程序集成”和“应用程序网络”。两者都是应用程序的责任。让我们来看看：&lt;/p&gt;
&lt;h3 id=&#34;应用程序集成&#34;&gt;应用程序集成&lt;/h3&gt;
&lt;p&gt;这些模式以如下这样的形式出现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用排序、多播和编排（Call sequencing, multicasting, and orchestration）&lt;/li&gt;
&lt;li&gt;聚合响应、转换消息语义、拆分消息等（Aggregate responses, transforming message semantics, splitting messages, etc）&lt;/li&gt;
&lt;li&gt;原子性、一致性问题、saga 模式（Atomicity, consistency issues, saga pattern）&lt;/li&gt;
&lt;li&gt;反腐败层、适配器、边界转换（Anti-corruption layers, adapters, boundary transformations）&lt;/li&gt;
&lt;li&gt;消息重试、排重/幂等性（Message retries, de-duplication/idempotency）&lt;/li&gt;
&lt;li&gt;消息重新排序（Message re-ordering）&lt;/li&gt;
&lt;li&gt;缓存（Caching）&lt;/li&gt;
&lt;li&gt;消息级路由（Message-level routing）&lt;/li&gt;
&lt;li&gt;重试、超时（Retries, timeouts）&lt;/li&gt;
&lt;li&gt;后端/遗留系统集成（Backend/legacy systems integration）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用一个简单的例子，”在购物车中添加一个项目“，我们可以来说明这个概念：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwgy1fuikdn3j02j31ks0oa77e.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当一个用户在点击“加入购物车”功能时，用户期望看到的是商品已经加入到他们的购物车中。在系统中，这可能涉及到对推荐引擎的协调、调用顺序（嘿，我们把它加入到购物车中了，想知道是否计算推荐报价来配合它）、库存服务和其他服务等，然后再调用服务插入购物车。我们需要能够将消息转换到不同的后端，处理失败（并回滚我们发起的任何更改），并且在每个服务中我们都需要可以处理重复。如果由于某种原因，调用变得很慢，但用户又再次点击了“加入购物车”时怎么办呢？如果用户这么做了，那么再多可靠的基础设施也拯救不了我们；我们需要在应用程序中检测和实现重复检查/幂等服务。&lt;/p&gt;
&lt;h3 id=&#34;应用程序网络&#34;&gt;应用程序网络&lt;/h3&gt;
&lt;p&gt;这些模式以如下这样的形式出现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动重试（automatic retry）&lt;/li&gt;
&lt;li&gt;重试指标/预算（retry quota/budget）&lt;/li&gt;
&lt;li&gt;连接超时（connection timeout）&lt;/li&gt;
&lt;li&gt;请求超时（request timeout）&lt;/li&gt;
&lt;li&gt;客户端负载均衡（client-side load balancing）&lt;/li&gt;
&lt;li&gt;熔断器（circuit breaking）&lt;/li&gt;
&lt;li&gt;隔离层（bulkheading）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但在通过网络进行通信的应用程序时，还存在其他复杂的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;金丝雀展示（Canary rollout）&lt;/li&gt;
&lt;li&gt;流量路由（Traffic routing）&lt;/li&gt;
&lt;li&gt;指标集合（Metrics collection）&lt;/li&gt;
&lt;li&gt;分布式跟踪（Distributed tracing）&lt;/li&gt;
&lt;li&gt;影子流量（Traffic shadowing）&lt;/li&gt;
&lt;li&gt;故障注入（Fault injection）&lt;/li&gt;
&lt;li&gt;健康检查（Health checking）&lt;/li&gt;
&lt;li&gt;安全（Security）&lt;/li&gt;
&lt;li&gt;组织策略（Organizational policy）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何使用这么模式&#34;&gt;如何使用这么模式？&lt;/h2&gt;
&lt;p&gt;在过去，我们试图将这些领域中的职责混合在一起。我们会做一些事情，比如把所有东西都推入集中式基础设施中，这样它基本上就 100% 可用的（应用程序网络 + 应用系统集成）。我们将应用程序的关注点放在集中的基础设施中（它本应该使我们更加敏捷），但是当需要对应用程序做快速的更改时，却遇到了瓶颈和僵化的问题。这些动态体现在我们实现企业服务总线（ESB）的方式上：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwly1fuit5y2mn6j311g0x418y.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;或者，我认为大型云厂商（Netflix、Amazon、Twitter 等）以及认识到了这些模式的“应用程序职责”方面，并将应用程序网络代码混合到应用程序中。想想像 Netflix OSS，有用于断路器、客户端负载均衡、服务发现等不同的库。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwly1fuitn6o25ij30yy0x0408.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如你所知，围绕应用程序网络的 Netflix OSS 库非常关注 Java。当组织开始采用 Netflix OSS 以及类似 spring-cloud-netflix 这样的衍生产品时，他们就会遇到这样一个事实：一旦开始添加其他语言时，操作这样的架构就变的令人望而却步了。Netflix 已经非常成熟了并且实现了自动化，但其他公司并不是 Netflix。在尝试操作应用程序库和框架来解决应用程序联网问题是遇到的一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每种语言/框架对于这些关注点都有自己的实现方式。&lt;/li&gt;
&lt;li&gt;实现不会完全相同，它们会变化、不同，有时会有错误。&lt;/li&gt;
&lt;li&gt;如何管理、更新以及修补这些库？也就是说，生命周期的管理。&lt;/li&gt;
&lt;li&gt;这些库混淆了应用程序的逻辑。&lt;/li&gt;
&lt;li&gt;对开发人员给与了极大的信任。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio 和服务网格的总体目标是解决应用程序网络类问题。将这些问题的解决方案迁移到服务网格中是可操作性的优化。但这并不意味着它不再是应用程序的责任，而是意味着这些功能的实现存在于进程之外了，并且必须是可配置的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwly1fuiuklgkjxj31060wyt9g.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过这样做，我们可以通过以下操作来优化可操作性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这些功能的单一实现随处可见。&lt;/li&gt;
&lt;li&gt;一致的功能。&lt;/li&gt;
&lt;li&gt;正确的功能。&lt;/li&gt;
&lt;li&gt;应用程序运维人员和应用程序开发人员都可编程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio 和服务网格不允许你将责任推给基础设施，它们只是增加了一定程度的可靠性和可操作性的优化。就像在端到端的参数中一样，TCP 允许卸载应用程序的责任。&lt;/p&gt;
&lt;p&gt;Istio 有助于解决应用程序网络类问题，但是应用程序集成类问题是什么呢？幸运的是，对于开发人员来说，有大量的框架可以帮助他们来实现应用程序的集成。对于 Java 开发者我最喜欢的 Apache Camel，它提供了许多编写正确和安全的应用程序所需的组件，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Call sequencing, multicasting, and orchestration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/aggregate-eip.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aggregate responses, transforming message semantics, splitting messages, etc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/saga-eip.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Atomicity, consistency issues, saga pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;Anti-corruption layers, adapters, boundary transformations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/idempotentConsumer-eip.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Message retries, de-duplication/idempotency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/resequence-eip.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Message reordering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Caching&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/content-based-router-eip.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Message-level routing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Retries, timeouts&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel/blob/master/components/readme.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Backend/legacy systems integration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwly1fuiv4suzo8j316m0xataq.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其他框架包括 &lt;a href=&#34;https://spring.io/projects/spring-integration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Integration&lt;/a&gt;，甚至还有 WSO2 中一个有趣的新编程语言 &lt;a href=&#34;https://ballerina.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ballerina&lt;/a&gt; 。请注意，重用现有的模式和构造是非常好的，特别是当这些模式相对于您选择的语言来说成熟时，但是这些模式都不需要您使用框架。&lt;/p&gt;
&lt;h1 id=&#34;智能端点和-dumb-管道&#34;&gt;智能端点和 dumb 管道&lt;/h1&gt;
&lt;p&gt;关于微服务，我有一个朋友提出了一个问题，关于微服务的“智能端点和 dumb pipe”这句话很吸引人，但很简单，“让基础设施智能化”是个前提：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/006tNbRwly1fuivligg5sj30g50cygmn.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;管道仍然是 dumb 的；我们不是通过使用服务网格将应用程序的正确性和安全性的应用程序逻辑强制加入基础设施中。我们只是使它更可靠，优化运维方面，并简化应用程序必须实现的内容（不必为此负责）。如果你不认同或者有其他想法，请随时在 Twitter 上留言或联系 &lt;a href=&#34;https://twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;如果您想了解更多关于 Istio 的信息，请查看 &lt;a href=&#34;http://istio.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://istio.io&lt;/a&gt; 或者&lt;a href=&#34;http://blog.christianposta.com/our-book-has-been-released-introducing-istio-service-mesh-for-microservices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我写的关于 Istio 的书&lt;/a&gt; 。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
