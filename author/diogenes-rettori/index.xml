<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Diogenes Rettori | 云原生社区</title>
    <link>https://cloudnative.to/author/diogenes-rettori/</link>
      <atom:link href="https://cloudnative.to/author/diogenes-rettori/index.xml" rel="self" type="application/rss+xml" />
    <description>Diogenes Rettori</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://cloudnative.to/author/diogenes-rettori/avatar_hue38add62c87b7486d80c9f3fda25dfc1_12220_270x270_fill_q75_lanczos_center.jpg</url>
      <title>Diogenes Rettori</title>
      <link>https://cloudnative.to/author/diogenes-rettori/</link>
    </image>
    
    <item>
      <title>Solo.io打造的Gloo——Knative中Istio的替代方案</title>
      <link>https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/</link>
      <pubDate>Thu, 16 May 2019 12:20:44 +0800</pubDate>
      <guid>https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/solo-io/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-324753586f3a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;[编者按]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;之前有社区成员询问是不是想尝试Knative时，必须要安装Istio才行，今天就告诉大家一种Istio的替代方案，使用Solo.io公司研发的Gloo来替代Istio来使用Knative。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;在Knative中，Istio的主要作用是作为一个Ingress技术。Gloo现在加入Istio作为Knative的集成和支持Ingress。有关快速演示demo，请参阅文章末尾。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，&lt;a href=&#34;https://github.com/knative/docs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative的存在&lt;/a&gt;是为了定义在&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;上构建和服务化工作负载的一套标准方法。Knative的一个显著特性是它的serverless特性：它将工作负载的执行与事件关联起来，而只在此类事件发生时消耗计算能力（事件驱动）。&lt;/p&gt;
&lt;p&gt;Knative是最初在谷歌创建，现在已与Pivotal、Red Hat、SAP、IBM等许多公司联合开发的开源协作技术。&lt;/p&gt;
&lt;h2 id=&#34;使用knative服务处理请求&#34;&gt;使用Knative服务处理请求&lt;/h2&gt;
&lt;p&gt;让我们简要了解一下Knative如何处理请求，以及它与“纯”Kubernetes的比较。&lt;/p&gt;
&lt;p&gt;Kubernetes上的&lt;em&gt;传统&lt;/em&gt;工作负载，比如web应用程序，需要一个运行的Pod和一个Ingress，以允许流量从其他集群流入到当前集群。&lt;/p&gt;
&lt;p&gt;现在，通过Knative的视角，让我们考虑下面的示例：有如下一个场景，客户端希望从一个在Knative平台上注册但不一定立即运行的应用程序中检索天气预报信息。使用Knative术语，有一个服务可以创建必要的配置和路由，以便在调用天气预报应用程序时运行它。在Knative上下文中，应用程序包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/spec/spec.md#service&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Service&lt;/a&gt;（不要与Kubernetes Service对象混淆）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/spec/spec.md#route&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Route&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/spec/spec.md#configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Configuration&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个或多个&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/spec/spec.md#revision&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Revision&lt;/a&gt;，运行时，Revision会变成Kubernetes Pod。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu8b8feffdb7437aba10b7738dce37ed90_17607_c739631f7042ad0cf5b0f88eeab2cca2.webp 400w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu8b8feffdb7437aba10b7738dce37ed90_17607_896e1a773019d5ab105a8445b502a76d.webp 760w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu8b8feffdb7437aba10b7738dce37ed90_17607_80a77e2587113afb0dbbf5f8c8c88439.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu8b8feffdb7437aba10b7738dce37ed90_17607_c739631f7042ad0cf5b0f88eeab2cca2.webp&#34;
               width=&#34;624&#34;
               height=&#34;176&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;深入到流量管理部分，Knative service有一个名为&lt;a href=&#34;https://github.com/knative/serving/tree/master/pkg/activator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Activator&lt;/a&gt;的组件，它负责报告某个工作负载需要运行相应数量的pod来处理请求。&lt;/p&gt;
&lt;p&gt;这种架构的美妙之处在于，如果负责运行应用程序的Pod没有运行，那么请求将被搁置，直到流量可以路由到一个或多个pod为止。这优化了资源利用率。&lt;/p&gt;
&lt;p&gt;如果您想知道，还有一些特性允许您预热应用程序，这样就不会阻塞任何请求。这使您能够对是否始终保持Pod运行做出明智的决策。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu84784781ccc78ef8c1fe3d2bdbf7c777_34231_6a9ff245ff18ce6ac15dd8af4772ec90.webp 400w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu84784781ccc78ef8c1fe3d2bdbf7c777_34231_4f0725462826a2684d7bc1bc1f8e54e2.webp 760w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu84784781ccc78ef8c1fe3d2bdbf7c777_34231_cef23d43ecf4f480c6eb77989c9c1367.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu84784781ccc78ef8c1fe3d2bdbf7c777_34231_6a9ff245ff18ce6ac15dd8af4772ec90.webp&#34;
               width=&#34;624&#34;
               height=&#34;378&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如前所述，一旦有一个修订（一个或多个Pod）来处理请求，流量就可以从Ingress网关流到您的修订。Knative Serving将继续收到请求的通知，以便确定是否需要对服务于修订的Pod进行伸缩。这真的太棒了!&lt;/p&gt;
&lt;h2 id=&#34;istio的必要性&#34;&gt;Istio的必要性&lt;/h2&gt;
&lt;p&gt;请求可能需要路由到相同配置的不同版本(请阅读工作负载规范)，特别是在同时运行同一应用程序的不同版本的情况下。为了做到这一点，Knative需要一个可以执行以下功能的Ingress控制器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;流量分流&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TLS终止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于Header路由&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;追加Header&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Solo.io拥抱&lt;a href=&#34;https://istio.io/zh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;。我们已经投资构建了一个名为&lt;a href=&#34;https://github.com/solo-io/supergloo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SuperGloo&lt;/a&gt;的服务网格编排器和管理平台，这可能是开始使用Istio的最简单方法。就我个人而言，我也很喜欢Istio。在红帽的时候，我参与了这个项目的&lt;a href=&#34;https://blog.openshift.com/red-hat-istio-launch/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;正式启动&lt;/a&gt;，并&lt;a href=&#34;https://www.infoworld.com/article/3273547/the-rise-of-the-istio-service-mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;写下&lt;/a&gt;了为什么Istio如此受欢迎。&lt;/p&gt;
&lt;p&gt;但如果我诚实地评价Istio在Knative上的角色，我的感觉是：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu0ff703ec26179ab22d1d2ecde3171989_18831_c257a68a676cf3e6c8052328bf512672.webp 400w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu0ff703ec26179ab22d1d2ecde3171989_18831_e5c60560fa0111d19a1d18c63eb9cb08.webp 760w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu0ff703ec26179ab22d1d2ecde3171989_18831_30a11665b3d36f7c0d624b785d5df908.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu0ff703ec26179ab22d1d2ecde3171989_18831_c257a68a676cf3e6c8052328bf512672.webp&#34;
               width=&#34;624&#34;
               height=&#34;177&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Istio提供了一组令人惊讶的特性，但是Knative只使用了其中的一些。作为参考，Istio目前有48个CRD （CustomResourceDefinition对象），其中只有一个主要由Knative（VirtualService）使用。&lt;/p&gt;
&lt;p&gt;现在，如果您的组织也愿意采用服务网格技术，并且Istio是您的选择，那么这种痛苦肯定会减少。为此，您必须熟悉或已经熟悉Istio的工作原理。现在对于许多用户来说，增加的复杂性可能不值得。&lt;/p&gt;
&lt;h2 id=&#34;gloo下一代通用api网关作为网关服务&#34;&gt;Gloo——下一代通用API网关，作为网关服务。&lt;/h2&gt;
&lt;p&gt;Gloo是下一代API网关，它既满足Knative的需求，又不会带来成熟服务网格技术(Istio就是这种情况)的不必要包袱。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_huc67c83c46f00a70d7b5e5e86be23706d_11173_f1e7a088829dcfa2a969361011e84c41.webp 400w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_huc67c83c46f00a70d7b5e5e86be23706d_11173_4032fcf9bf494e21112497fe31404d9f.webp 760w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_huc67c83c46f00a70d7b5e5e86be23706d_11173_7645e8a942107931fd8961f1a9f434db.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_huc67c83c46f00a70d7b5e5e86be23706d_11173_f1e7a088829dcfa2a969361011e84c41.webp&#34;
               width=&#34;317&#34;
               height=&#34;135&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;建立在Envoy之上，&lt;a href=&#34;https://knative.dev/docs/install/knative-with-gloo/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;是Knative第一个官方的Istio替代品&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但这在现实中意味着什么呢?当我们决定对这个解决方案投入精力时，我们的主要目标之一就是解决方案的可持续性。当一个新版本出现时，一起工作的项目突然停止工作，这肯定会令人沮丧，我们的集成工作主要集中在三个方面：易用性、实现和持续集成。&lt;/p&gt;
&lt;h2 id=&#34;易用性&#34;&gt;易用性&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;作为一家公司的一个关键任务是为了弥合先进的开源技术与使用这种技术的企业和用户之间的差距。在这种程度上，我们在&lt;a href=&#34;https://knative.dev/docs/install/knative-with-gloo/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用Gloo时改进了Knative本身的安装&lt;/a&gt;。整个社区可以立即受益于一种更简单的实验和生产方式。&lt;/p&gt;
&lt;p&gt;流行的&lt;code&gt;glooctl&lt;/code&gt;命令现在包含一个Knative选项，该选项&lt;a href=&#34;https://gloo.solo.io/installation/#2c-install-the-gloo-knative-cluster-ingress-to-your-kubernetes-cluster-using-glooctl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不仅安装Gloo网关本身而且还将安装Knative&lt;/a&gt;（！！！）。在安装过程中，Knative配置了&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;作为集群Ingress网关，它使用一个命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ glooctl install knative
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;虽然这是一个显而易见的问题，但我们创建了必要的控制和监视，以便&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;能够在Istio Ingress运行时在相同或更好的容量水平上运行和报告。大部分工作都是在Gloo上完成的。在技术层面，Gloo得到了扩展，包括基于Knative ClusterIngress CRD读取和应用配置的能力。&lt;/p&gt;
&lt;h2 id=&#34;持续集成&#34;&gt;持续集成&lt;/h2&gt;
&lt;p&gt;我们在&lt;a href=&#34;https://github.com/knative/serving/pull/3087&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative&lt;/a&gt;的CI测试流水线中实现并引入了特定的Gloo测试，这意味着如果Knative中的一个更改破坏了与Gloo的集成，反之亦然，那么社区将得到通知并根据情况采取相应的行动。这为任何正在寻找Knative上的Istio的替代方案的人提供了可能，在撰写本文时，Knative是唯一的替代方案。&lt;/p&gt;
&lt;h2 id=&#34;立刻行动吧&#34;&gt;立刻行动吧！&lt;/h2&gt;
&lt;p&gt;如果您能够访问Kubernetes集群，只需&lt;a href=&#34;https://github.com/solo-io/gloo/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;下载&lt;/a&gt;最适合您的操作系统的&lt;code&gt;glooctl&lt;/code&gt;版本，然后立即开始您的Knative（和&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;）之旅。我们最近也增加了对Windows的支持。要获得更多帮助，请查看我们的Knative特定&lt;a href=&#34;https://gloo.solo.io/installation/#2c-install-the-gloo-knative-cluster-ingress-to-your-kubernetes-cluster-using-glooctl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;并加入我们的&lt;a href=&#34;http://slack.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slack&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Gloo可以做的不仅仅是基本的Ingress路由。Gloo被设计为下一代API网关，能够理解功能级别的调用(HTTP1、HTTP2、gRPC、REST/OpenAPISpec、SOAP、WebSockets、Lambda/Cloud函数)，并能够帮助您从单一功能到微服务和serverless的演进。参加我们的&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络研讨会&lt;/a&gt;，我们将讨论如何渐进地、安全地发展您的应用程序架构，以利用新功能来满足您的业务需求，而不必对您的单体应用进行危险的更改。&lt;/p&gt;
&lt;h2 id=&#34;观看介绍视频&#34;&gt;观看介绍视频&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=_e61MB2Afvs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.youtube.com/watch?v=_e61MB2Afvs&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Istio服务网格的崛起</title>
      <link>https://cloudnative.to/blog/the-rise-of-the-istio-service-mesh/</link>
      <pubDate>Tue, 12 Jun 2018 15:06:25 +0800</pubDate>
      <guid>https://cloudnative.to/blog/the-rise-of-the-istio-service-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://www.infoworld.com/article/3273547/containers/the-rise-of-the-istio-service-mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如何确保微服务之间网络通信的可靠性、安全性和可管理性？ 使用服务网格吧！&lt;/p&gt;
&lt;p&gt;在过去一年中，&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;服务网格技术引发关注度和吸引力的持续提升，这是一件非常有趣的事情。 事实上，在我写这篇文章时，Istio仅为0.8版本，但对于最近两届&lt;a href=&#34;https://events.linuxfoundation.org/events/kubecon-cloudnativecon-europe-2018/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KubeCon/CloudNativeCon&lt;/a&gt;活动而言，它一直是&lt;a href=&#34;https://events.linuxfoundation.org/events/kubecon-cloudnativecon-europe-2018/program/schedule/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;热门话题&lt;/a&gt;，仅在丹麦的活动中就有超过十几个不同的活动议题。 那么它为什么会这样受欢迎？&lt;/p&gt;
&lt;p&gt;在深入研究Istio受欢迎的原因之前，让我们先来介绍一下服务网格。 这是一个通用术语，其早已被投入在多个不同场景中。例如定义不同无线设备之间的通信方法；或者定义一个系统，各个应用程序可以直接通过它与其他应用程序通信。&lt;a href=&#34;https://istio.io/docs/concepts/what-is-istio/overview.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最近&lt;/a&gt;，这个术语被用来表示应用或微服务的网络，以及它们之间的互相作用关系。后者是本文的重点。&lt;/p&gt;
&lt;p&gt;事实上红帽公司一直参与云原生和微服务领域建设，包括四年前决定将OpenShift向Kubernetes和Docker转变，这帮助我们理解了服务网格技术，尤其是Istio的重要性。本文将探讨为什么我会坚信Istio会很受欢迎的四个原因。&lt;/p&gt;
&lt;h2 id=&#34;微服务和转型&#34;&gt;微服务和转型&lt;/h2&gt;
&lt;p&gt;纵观你整个职业生涯，或者结合如今的工作，你可能已经发现从代码完成开发到部署至生产之间的时间不断被延长，以至于开发资源被转移到其他项目，同时也使你的产品反馈周期变得无效或无关紧要。为了缩短交付时间，一些公司决定以功能服务架构或微服务架构来将大型应用拆散，以此提高效率。即曾经具有多种功能的单个应用程序（包）被切分成可独立更新的单个程序包。&lt;/p&gt;
&lt;p&gt;这当然是有价值的，但同时也要承认，使用这种架构需要对单独的服务和它们之间的接口进行更多的开发治理。例如曾经定义在应用程序内部的一部分API调用关系现在上升在到网络层中。&lt;/p&gt;
&lt;p&gt;Christian Posta的演讲“&lt;a href=&#34;https://www.slideshare.net/ceposta/the-hardest-part-of-microservices-calling-your-services&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务中最困难的部分：调用你的服务&lt;/a&gt;”谈到了一个重要问题。当调用API时，你可能会认为你在处理A和B之间的直接集成调用（下图1）。然而计算机网络并不会针对直接通信进行优化（下图2）。因此在某些情况，尤其当应用处于你正考虑或使用的云环境中时，你不可避免且不得不考虑这些不同的失控物理和虚拟网络设备。例如，就可能存在这样一种情况：其中一台设备的性能低于最佳性能，这将影响整个应用程序的响应时间（下图3）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-a和b之间的调用关系图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;A和B之间的调用关系图&#34; srcset=&#34;
               /blog/the-rise-of-the-istio-service-mesh/78a165e1gy1fs7fmkvibwj20jf0dfq40_hua4ac7e4fbdfcb6ee0f980c97f6d86460_49931_8ac83aa3fdd33e48307bb1ef4945a835.webp 400w,
               /blog/the-rise-of-the-istio-service-mesh/78a165e1gy1fs7fmkvibwj20jf0dfq40_hua4ac7e4fbdfcb6ee0f980c97f6d86460_49931_bc37229f803df0e5330b517fb8c0492b.webp 760w,
               /blog/the-rise-of-the-istio-service-mesh/78a165e1gy1fs7fmkvibwj20jf0dfq40_hua4ac7e4fbdfcb6ee0f980c97f6d86460_49931_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-rise-of-the-istio-service-mesh/78a165e1gy1fs7fmkvibwj20jf0dfq40_hua4ac7e4fbdfcb6ee0f980c97f6d86460_49931_8ac83aa3fdd33e48307bb1ef4945a835.webp&#34;
               width=&#34;699&#34;
               height=&#34;483&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      A和B之间的调用关系图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;微服务先驱和netflix-oss&#34;&gt;微服务先驱和Netflix OSS&lt;/h2&gt;
&lt;p&gt;有些公司似乎是为了云计算而生的。为了在云中提供弹性服务，应用程序不得不保护自己免受环境异常影响。&lt;/p&gt;
&lt;p&gt;Netflix构建并随后&lt;a href=&#34;https://netflix.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开源&lt;/a&gt;了一系列涉及诸如断路、边缘路由、服务发现和负载均衡等功能的Java技术解决方案。这些组件使应用能够更好地控制通信，从而提高整体可用性。为了测试并确保组件的弹性，Netflix还使用了&lt;a href=&#34;http://principlesofchaos.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;混沌工程&lt;/a&gt;，通过将各种现实中可能存在的问题注入到应用程序的网络中，以便能在任何给定时间中断工作流。 Netflix开发的技术组合允许其应用程序投入到一个以应用程序为中心的网络中，这实际上就是服务网格。&lt;/p&gt;
&lt;p&gt;在构建Netflix OSS堆栈的时代，虚拟机是在云中运行应用程序的唯一方式。因此Netflix选择Java作为开发语言来构建服务网格功能。&lt;/p&gt;
&lt;p&gt;除了Netflix OSS堆栈的纯Java依赖，另一个挑战是为了实现服务网格功能，开发人员必须将Java库包含在其应用程序中，并在代码中引用来使用这些组件。但在当时，那些希望强制使用这些技术的公司无法在平台级进行如上工作。&lt;/p&gt;
&lt;p&gt;随着&lt;a href=&#34;https://www.infoworld.com/article/3268073/containers/what-is-kubernetes-container-orchestration-explained.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;的来临，诸如服务发现和负载均衡等功能成为平台本身的一部分，并且平台允许用任何语言编写的应用程序都可以使用。通过声明式和活动状态管理，Kubernetes还能够通过自动重启无响应的应用来提高整体应用的可用性。在当今世界，Kubernetes和容器是运行微服务应用程序的标准。&lt;/p&gt;
&lt;p&gt;在Kubernetes中，你的应用程序以由一个或多个容器组成“pod”运行。在pod中运行多个容器的技术有时也被称为“sidecar”，其实质上是一种将你的应用程序拆散，将子模块运行在共享隔离空间（pod）的解决方案。&lt;/p&gt;
&lt;p&gt;Kubernetes为Istio这样的技术的崛起创造了有利条件。出行共享公司Lyft已经开始通过智能代理&lt;a href=&#34;https://github.com/envoyproxy/envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;来提供微服务部署所需的弹性和动态路由功能。 sidecar容器和Envoy这类架构允许为每个应用程序实例附加一个轻量级代理，以支持服务发现、负载均衡、断路器、链路跟踪以及服务网格的其他功能。将它与一个控制面板结合，并添加服务治理和Envoy实例配置管理功能，你就拥有了Istio。&lt;/p&gt;
&lt;h2 id=&#34;拥抱分布式架构&#34;&gt;拥抱分布式架构&lt;/h2&gt;
&lt;p&gt;最后，Istio和服务网格通常与“拥抱”&lt;a href=&#34;https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;分布式计算的谬论&lt;/a&gt;有关。 换而言之，”&lt;strong&gt;Istio允许应用程序假定网络是可靠的、快速的、安全的、不变的等等——这使得分布式计算的谬论不再是谬论&lt;/strong&gt; “。说Istio和Kubernetes可以解决所有这些问题，但忽视这些谬论可能导致企业犯大错误。 企业必须接受这样一个事实：当你有多个微服务和功能服务互相交互时，你就处理分布式系统。&lt;/p&gt;
&lt;p&gt;请参阅下面的分布式计算谬论的完整列表以及Istio的解决方案：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;谬论&lt;/th&gt;
&lt;th&gt;Istio的解决方案&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;可靠网络&lt;/td&gt;
&lt;td&gt;断路和负载均衡&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;延迟为零&lt;/td&gt;
&lt;td&gt;超时和重试&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;忽略带宽&lt;/td&gt;
&lt;td&gt;服务评级和限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;安全网络&lt;/td&gt;
&lt;td&gt;相互TLS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;拓扑不可改&lt;/td&gt;
&lt;td&gt;服务发现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单一管理员&lt;/td&gt;
&lt;td&gt;基于角色的访问控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;零传输成本&lt;/td&gt;
&lt;td&gt;gRPC和Protobuf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;同质化网络&lt;/td&gt;
&lt;td&gt;动态路由，A/B测试和金丝雀部署&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在我与OpenShift客户的沟通中，我经常发现他们由于自身需求，已经实现了类似Netflix模式的功能。我也对实现这些功能的团队很有兴趣，经常听到他们说“我们是断路小组”或“我们是服务发现小组”。&lt;/p&gt;
&lt;p&gt;创建自己的服务网格功能的公司现在有机会使用Kubernetes和Istio。通过使用这些被标准化的开源技术，他们可以获得由大型社区开发的功能、整理知识和用例，并帮助他们实现更具弹性的应用程序，同时以更低的成本更快地将产品推向市场。&lt;/p&gt;
&lt;p&gt;作者Diogenes Rettori是&lt;a href=&#34;https://www.redhat.com/en/technologies/cloud-computing/openshift&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;红帽OpenShift&lt;/a&gt;的主任产品经理。在加入OpenShift团队之前，他专注于红帽JBoss中间件的客户培训。 Diogenes拥有强大的工程背景，曾为爱立信和IBM等公司工作。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
