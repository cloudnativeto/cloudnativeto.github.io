<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>EBPF | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/category/ebpf/</link>
      <atom:link href="https://cloudnativecn.com/category/ebpf/index.xml" rel="self" type="application/rss+xml" />
    <description>EBPF</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Wed, 10 Jan 2024 12:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/media/sharing.png</url>
      <title>EBPF</title>
      <link>https://cloudnativecn.com/category/ebpf/</link>
    </image>
    
    <item>
      <title>用 eBPF 洞察应用层网络流量</title>
      <link>https://cloudnativecn.com/blog/application-traffic-with-ebpf/</link>
      <pubDate>Wed, 10 Jan 2024 12:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/application-traffic-with-ebpf/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://thebsdbox.co.uk/2023/12/08/Application-traffic-with-eBPF/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application traffic with eBPF&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要：本文介绍了如何使用 eBPF 程序捕获、分析和修改应用层的网络数据，包括 HTTP 头部和 URL 路径。作者还展示了如何使用 eBPF map 在内核和用户空间之间传递数据。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在&lt;a href=&#34;../ebpf-adventures-in-networking/&#34;&gt;先前的帖子&lt;/a&gt;中，我稍微谈到了建立 eBPF 知识，以开始更多地了解网络适配器的输入和输出情况。基本上，将以太网帧并剥离标头（以太网标头+IP 标头+TCP/UDP 标头），最终你将得到来自应用程序或数据角度的数据包中剩余的内容。&lt;/p&gt;
&lt;p&gt;所有的代码都在“学习 eBPF”存储库中，具体的 eBPF 代码在&lt;a href=&#34;https://github.com/thebsdbox/learning-ebpf/blob/main/ebpf/http/http.c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;。这篇文章的计划是逐步介绍我认为有用或可能重要的部分&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：此代码确实对入口/出口数据包进行了一些修改，因此需要 6.1+ 的 Linux 内核才能使用一些 eBPF 助手函数。&lt;/p&gt;
&lt;h2 id=&#34;映射&#34;&gt;映射！&lt;/h2&gt;
&lt;p&gt;你可能以前遇到过这些吧？如果没有，不用担心！简而言之，eBPF 映射是在用户空间和内核中的 eBPF 程序之间通信的机制。在我看来，非常酷的一点是这些映射使用键和值&amp;hellip;所以我不必循环比较数据并寻找匹配的内容，我传递一个键，如果有匹配的内容，我就得到相应的数据:D&lt;/p&gt;
&lt;p&gt;下面是我将要使用的映射，称为&lt;code&gt;url_map&lt;/code&gt;，键是 20 个字符长（可以说是有界的“字符串”），分配给该键的值是我在上面定义的结构体。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 定义与键关联的不同URL
struct url_path {
  __u8 path_len;
  __u8 path[max_path_len]; // 这应该是一个char，但在这里和Go之间的代码生成有点不同...
};

// 定义我的URL映射
struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 1024);
  __type(key, char[max_path_len]);
  __type(value, struct url_path);
}
url_map SEC(&amp;#34;.maps&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ebpf-程序&#34;&gt;eBPF 程序！&lt;/h2&gt;
&lt;p&gt;代码中定义了两个 eBPF 程序&lt;code&gt;tc_egress&lt;/code&gt;和&lt;code&gt;tc_ingress&lt;/code&gt;，如果你能猜到它们是如何连接的，那就加分！在这篇文章中，我们只关注&lt;code&gt;tc_ingress&lt;/code&gt;程序。&lt;/p&gt;
&lt;p&gt;就像我们在已经存在的众多示例中看到的那样，我们需要进行标头识别的操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进行合理性检查，并将&lt;code&gt;data&lt;/code&gt;强制转换为&lt;code&gt;ethhdr&lt;/code&gt;类型（&lt;a href=&#34;https://en.wikipedia.org/wiki/Ethernet_frame&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以太网标头&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;通过读取以太网标头内部的&lt;code&gt;h_proto&lt;/code&gt;（也称为&lt;code&gt;Ethertype&lt;/code&gt;）来查找以太网帧内部的协议。&lt;/li&gt;
&lt;li&gt;将以太网标头后的数据强制转换为&lt;code&gt;iphdr&lt;/code&gt;类型（&lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_Protocol_version_4#Header&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IP 标头&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;在 IP 标头内查找协议，我们还需要确定 IP 标头的大小（原来它们可以有不同的大小！&lt;code&gt;¯\_(ツ)_/¯&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;为了确定标头的大小，我们将其值乘以四，你可能会问为什么！好吧，这个值乘以 32 位以确定标头的大小，所以如果值为 6，那么标头将是 192 位（或 24 字节）。所以，为了简单地确定 IP 标头的字节数，我们可以将这个值乘以 4！&lt;/li&gt;
&lt;li&gt;将以 IP 标头后的数据强制转换为&lt;code&gt;tcphdr&lt;/code&gt;类型（&lt;a href=&#34;https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TCP 标头&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;像步骤（5）一样，我们需要确定 TCP 标头的大小（它也可以是动态的），在这里的步骤也是一样的，我们只需要将值&lt;code&gt;doff&lt;/code&gt;乘以四来确定标头的大小（以字节为单位）。&lt;/li&gt;
&lt;li&gt;通过计算所有这些，我们现在可以推断出数据位于以太网标头大小、IP 标头大小和 TCP 标头大小的末尾。&lt;/li&gt;
&lt;li&gt;最后，我们可以通过从 IP 标头中减去 IP 和 TCP 标头的大小来确定应用程序数据的大小，使用&lt;code&gt;tot_len&lt;/code&gt;（总长度）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;应用数据&#34;&gt;应用数据！！&lt;/h3&gt;
&lt;p&gt;为了读取这些数据，我们将需要上面提到的一些东西！&lt;/p&gt;
&lt;p&gt;首先，我们需要数据偏移量（数据起始位置），它位于以太网标头+IP 标头大小（一旦计算出来）和 TCP 标头（再次，一旦计算出来）之后。我们还需要一个缓冲区来存储我们将从套接字缓冲区中读取的数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 用于存储我们应用程序数据的数据缓冲区
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 计算数据实际位置的偏移量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;poffset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ETH_HLEN&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ip_hlen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tcp_hlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 从套接字缓冲区加载数据，poffset 从 TCP 标头的末尾开始
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bpf_skb_load_bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;skb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;poffset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们使用&lt;code&gt;bpf_skb_load_bytes&lt;/code&gt;从套接字缓冲区（&lt;code&gt;skb&lt;/code&gt;）中读取一定量的数据（60 个字节）到我们的缓冲区（&lt;code&gt;pdata&lt;/code&gt;），起始位置是我们知道数据位于的偏移量（&lt;code&gt;poffset&lt;/code&gt;）！&lt;/p&gt;
&lt;p&gt;此时，我们有了 60 字节的数据，应该足够让我们编写一些代码来理解它。&lt;/p&gt;
&lt;h3 id=&#34;http-数据--&#34;&gt;HTTP 数据 :-)&lt;/h3&gt;
&lt;p&gt;让我们看看当我们尝试进行 HTTP 请求时会发生什么！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ~ curl code/test -vvv
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*   Trying 192.168.0.22:80...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;* Connected to code (192.168.0.22) port 80 (#0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; GET /test HTTP/1.1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; Host: code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; User-Agent: curl/7.87.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; Accept: */*
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我正在使用&lt;code&gt;curl&lt;/code&gt;从主机&lt;code&gt;code&lt;/code&gt;（code 是我的开发 VM，运行 code-server）请求 URL &lt;code&gt;/test&lt;/code&gt;。我们可以看到发送到服务器的数据（每行以&lt;code&gt;&amp;gt;&lt;/code&gt;开头，用于确定通信的方向）。HTTP 请求中的第一行数据通常是一个&lt;em&gt;动词&lt;/em&gt;，后面是我们希望与之交互的资源，然后是 HTTP 规范和回车符，如&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP#HTTP/1.1_request_messages&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTP 标准&lt;/a&gt;中定义。因此，我们可以看到我们关心的行是&lt;code&gt;GET /test&lt;/code&gt;（在这一点上，我们/我不太关心 HTTP 规范:D）。&lt;/p&gt;
&lt;p&gt;第一步是读取&lt;code&gt;pdata&lt;/code&gt;的前三个字符，查找&lt;code&gt;pdata[0] == G&lt;/code&gt;，&lt;code&gt;pdata[1] == E&lt;/code&gt;和&lt;code&gt;pdata[2] == T&lt;/code&gt;，这将有效地帮助我们确定首先是否是 HTTP 请求，特别是是否是 HTTP 请求！&lt;/p&gt;
&lt;p&gt;一旦我们验证了这前 3 个字节，我们将想要从第 4 个字节（请求的前三个字节加上一个用于分隔的空格）开始读取更多数据！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_path_len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;memset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path_len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 查找请求 URI（从偏移量 4 开始），以空格结束
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;path_len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的函数将从 HTTP 数据的第 4 个字节开始（从第 4 个字节开始）读取其余的数据，直到遇到空格为止，留下我们要&lt;code&gt;GET&lt;/code&gt;的 URL！我们可以通过一个调试打印语句来验证这一点：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;bpf_printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;lt;- incoming path [%s], length [%d]&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path_len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这将在日志中显示如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;idle&amp;gt;-0       [001] dNs3. 2252901.017812: bpf_trace_printk: &amp;lt;- incoming path [/test], length [5]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;对-http-应用程序请求采取行动&#34;&gt;对 HTTP 应用程序请求采取行动&lt;/h3&gt;
&lt;p&gt;上述解释详细说明了我们如何读取数据以及如何读取数据，但如果我们想要“动态”查找 HTTP 请求，我们将需要使用 eBPF 映射。&lt;/p&gt;
&lt;p&gt;在我们的 Go 用户空间代码中，我们执行以下操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;path&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;The URL Path to watch for&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;flag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Parse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 创建一个 uint8 数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;urlPath&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 将我们的字节复制到 uint8 数组中（我们可以进行类型转换）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;copy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;urlPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:],&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 将我们的 urlPath 作为键
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;objs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;UrlMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;urlPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;bpfUrlPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;Path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;urlPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;PathLen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;urlPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正如我们在上面的代码中看到的，当我们启动 Go 程序时，它将从标志&lt;code&gt;-path&lt;/code&gt;中读取，并将其用作我们 eBPF 映射中的&lt;strong&gt;键&lt;/strong&gt;，可以暂时忽略值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;url_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;found_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bpf_map_lookup_elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;url_map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;found_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;bpf_printk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Looks like we&amp;#39;ve found your path [%s]&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 可能进行更多操作，阻止流量或重定向？
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在我们的 eBPF 程序中，我们将对 HTTP 请求进行映射查找，如果该请求作为 char 数组存在于&lt;strong&gt;键&lt;/strong&gt;中，那么我们就可以对其进行操作！&lt;/p&gt;
&lt;p&gt;现在启动我们的 Go 程序 &lt;code&gt;sudo ./http -interface ens160 -path /test&lt;/code&gt; 将得到以下结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;INFO[0000] Starting 🐝 the eBPF HTTP watcher, on interface [ens160] for path [/test]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;INFO[0000] Loaded TC QDisc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;INFO[0000] Press Ctrl-C to exit and remove the program
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &amp;lt;idle&amp;gt;-0       [001] d.s3. 2252901.015575: bpf_trace_printk: &amp;lt;- 0.0.0.0:56345 -&amp;gt; 0.0.0.0:80
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &amp;lt;idle&amp;gt;-0       [001] D.s3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;. 2252901.015642: bpf_trace_printk: -&amp;gt; 192.168.0.22:80 -&amp;gt; 192.168.0.180:56345
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &amp;lt;idle&amp;gt;-0       [001] d.s3. 2252901.017552: bpf_trace_printk: &amp;lt;- 0.0.0.0:56345 -&amp;gt; 0.0.0.0:80
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &amp;lt;idle&amp;gt;-0       [001] d.s3. 2252901.017793: bpf_trace_printk: &amp;lt;- 0.0.0.0:56345 -&amp;gt; 0.0.0.0:80
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &amp;lt;idle&amp;gt;-0       [001] dNs3. 2252901.017812: bpf_trace_printk: &amp;lt;- incoming path [/test], length [5]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &amp;lt;idle&amp;gt;-0       [001] dNs3. 2252901.017814: bpf_trace_printk: Looks like we&amp;#39;ve found your path [/test]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;解析 HTTP 并不太困难，因为它是一个相对简单的协议，它使用简单的动词和结构的简单方法，使用空格和回车符来区分。这种方法可能也适用于其他协议，如 DNS、POP3 或 SMTP。当数据加密时，我们需要一种解密的方法，然后才能解析数据（这超出了我的能力&amp;hellip;）。但是，我希望这会激发你更多地尝试使用 eBPF 来解析和操作应用程序的想法！&lt;/p&gt;
&lt;p&gt;我一直想写一些有希望有用的关于 eBPF 的帖子，尽管通常在我想出可能有用的东西之后，别人已经抢先一步。鉴于我已经在一段时间里以某种方式关注网络，这基本上是我关注的领域，尽管我确实为最近的 eBPF 峰会 2023 编写了一些有趣的内容。如上所述，有很多人开始撰写 eBPF 内容，所以我可能会参考他们的帖子，而不是重复内容。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何用 eBPF 改变网络编程的游戏规则</title>
      <link>https://cloudnativecn.com/blog/ebpf-adventures-in-networking/</link>
      <pubDate>Wed, 10 Jan 2024 08:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/ebpf-adventures-in-networking/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://thebsdbox.co.uk/2023/11/18/eBPF-adventures-in-networking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF adventures in networking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要：这篇文章介绍了 eBPF 在网络领域的一些应用和实践，包括 XDP、TC 和 sysprobes 三种不同的 eBPF 程序挂载方式的优缺点，以及如何使用 eBPF 实现网络数据的捕获、分析和修改。作者还分享了一些有用的 eBPF 工具和资源，以及自己开发的一个 eBPF 网络代理的项目。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我一直想写一些关于 eBPF 的帖子，希望它们能有所帮助，尽管通常在我想到可能有用的东西时，其他人已经先我一步了。鉴于我已经在网络方面集中精力一段时间，这基本上是我专注的领域，尽管我确实设法为最近的 eBPF 峰会 2023 准备了一些我认为很有趣的东西。正如我之前提到的，有很多人开始撰写关于 eBPF 的内容，因此我可能会参考他们的帖子，而不是重复内容。&lt;/p&gt;
&lt;p&gt;我将从一些在 Linux 内核中可能或可能不会遇到的首字母缩写或技术开始。但基本上从我的角度来看，这些是你修改正在运行的系统以与网络数据交互的主要选项。&lt;/p&gt;
&lt;h3 id=&#34;xdp&#34;&gt;XDP&lt;/h3&gt;
&lt;p&gt;关于 eXpress Data Plane 已经存在大量信息，因此我不会深入探讨太多细节。&lt;code&gt;tl;dr&lt;/code&gt;是 XDP eBPF 程序挂钩到 XDP 将使其能够访问由内核自身处理之前的传入网络帧。在某些情况下，eBPF 程序将加载到 NIC 驱动程序本身中，这将有效地将程序卸载到 NIC 本身。&lt;/p&gt;
&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;最佳性能&lt;/li&gt;
&lt;li&gt;非常适用于防火墙、DDoS 防护或负载均衡等用例&lt;/li&gt;
&lt;li&gt;在任何其他内容进行修改之前看到传入的流量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;仅支持入站流量，使用 XDP 程序看到的任何流量都只是传入流量，目前无法看到出站流量&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;XDP&lt;/code&gt;数据结构，与大多数套接字编程的默认数据结构&lt;code&gt;SKB&lt;/code&gt;有一些不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tctraffic-control或流量控制&#34;&gt;TC（Traffic Control）或流量控制&lt;/h3&gt;
&lt;p&gt;Traffic Control 是内核网络结构的一个重要组成部分，主要包括添加诸如 qdisc 和过滤器之类的功能到接口的能力。qdisc 主要集中在为 TBD（待定）提供服务，而过滤器通常在底层实际上是一个 eBPF 程序。&lt;/p&gt;
&lt;p&gt;常见的工作流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个关注入口或出口的 qdisc，或者替换一个现有的 qdisc。qdisc 将附加到接口上。&lt;/li&gt;
&lt;li&gt;加载你的 eBPF 程序。&lt;/li&gt;
&lt;li&gt;创建一个过滤器，将其附加到通过接口上的 qdisc 上的入口或出口之一。该过滤器将与 eBPF 程序相关联，这意味着所有传入或传出的流量现在都会通过一个程序运行（如果连接）。&lt;/li&gt;
&lt;li&gt;获利 💰&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;优点-1&#34;&gt;优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提供入口和出口的挂钩点&lt;/li&gt;
&lt;li&gt;使用传统的&lt;code&gt;SKB&lt;/code&gt;数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缺点-1&#34;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;将 TC 程序附加到入口或出口队列稍微复杂一些。用户需要使用 qdisc 来做到这一点，某些 eBPF SDK 不会原生支持 TC 程序的使用。&lt;/li&gt;
&lt;li&gt;TC eBPF 程序看到的流量可能已经被之前的 XDP 程序或内核本身修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;系统调用&#34;&gt;系统调用&lt;/h3&gt;
&lt;p&gt;与其他两种专门设计用于处理网络的方法相比，这可能会显得有些奇怪，因为它是将一些 eBPF 代码附加到内核中的系统调用的一种替代方法，具体来说是&lt;code&gt;tcp4_connect()&lt;/code&gt; / &lt;code&gt;tcp6_connect()&lt;/code&gt;等调用。这在协议栈中略微靠后，因为在此时，传入数据包已经经过了很多内核逻辑，而 eBPF 内省点是当流量即将与应用程序本身交互时。&lt;/p&gt;
&lt;h2 id=&#34;编写网络程序&#34;&gt;编写网络程序！&lt;/h2&gt;
&lt;p&gt;所以在这一点上，我们（希望）意识到我们有许多不同的入口点，允许我们在“传送带”上注入我们的代码，这个传送带从 NIC 开始，一直到应用程序（以及在出站的情况下）。&lt;/p&gt;
&lt;h3 id=&#34;回顾&#34;&gt;回顾&lt;/h3&gt;
&lt;p&gt;在我们所谓的“传送带”的开头，我们可以附加我们的 XDP 程序并获得未经触碰的原始网络数据。在“传送带”的中间，我们的 TC 程序将成为通过内核的路径的一部分，并接收可能被修改的网络数据。在传送带的末端，我们可以将代码附加到应用程序将在它被运行之前获取网络数据的函数，这些函数可以在传送带的末端进行附加。&lt;/p&gt;
&lt;h3 id=&#34;数据表示&#34;&gt;数据表示&lt;/h3&gt;
&lt;p&gt;你的程序附加到的位置决定了两个主要事物，一个是潜在的流量修改的相对级别，另一个是流量的表示方式。&lt;/p&gt;
&lt;h3 id=&#34;xdp-结构&#34;&gt;XDP 结构&lt;/h3&gt;
&lt;p&gt;我会写关于它的内容，但是 DataDog 已经做了，你可以在&lt;a href=&#34;https://www.datadoghq.com/blog/xdp-intro/#the-flow-of-an-xdp-program&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;阅读。&lt;/p&gt;
&lt;h3 id=&#34;skb套接字缓冲区&#34;&gt;SKB（套接字缓冲区）&lt;/h3&gt;
&lt;p&gt;SKB 是在 eBPF 添加到内核之前就存在于内核中的数据类型，它已经具备了一些使与 SKB 对象交互变得稍微容易一些的辅助功能。有关更深入的 SKB 介绍，你可以阅读此文 -&amp;gt; &lt;a href=&#34;http://vger.kernel.org/~davem/skb_data.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://vger.kernel.org/~davem/skb_data.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;解析数据&#34;&gt;解析数据&lt;/h3&gt;
&lt;p&gt;无论与哪个结构进行交互，它们都共享一些共同之处，这主要是两个变量，对于这两种数据类型来说是相同的。&lt;/p&gt;
&lt;p&gt;这些变量是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;data&lt;/code&gt;，它是 eBPF 程序接收到的数据的指针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;data_len&lt;/code&gt;，它是一个整数，指定了有多少数据可用（以帮助确保你永远不会访问&lt;code&gt;data&lt;/code&gt;超过&lt;code&gt;data_len&lt;/code&gt;（显而易见的真理 🤓））&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以这一切似乎很简单，但等等&amp;hellip; &lt;code&gt;*data&lt;/code&gt;中实际上有什么？（这取决于你的发现）&lt;/p&gt;
&lt;p&gt;通过不断“转换”&lt;code&gt;*data&lt;/code&gt;并沿着它移动以剥离各种标头，我们可以了解和查找底层数据！&lt;/p&gt;
&lt;h3 id=&#34;转换&#34;&gt;转换？&lt;/h3&gt;
&lt;p&gt;如果你愿意，你可以跳过此部分，但这是一个快速（且糟糕）的示例，说明了我们通常如何将一些原始数据转换为有意义的东西。目前，&lt;code&gt;*data&lt;/code&gt;将只是一串随机数据，毫无意义，我们需要有效地为其添加“格式”以便我们可以理解其外观。&lt;/p&gt;
&lt;p&gt;考虑一下随机数据行：“Bobby0004500100.503 Harvard Drive90210”，其中一些对裸眼来说是有意义的，但有些是不清楚的。&lt;/p&gt;
&lt;p&gt;想象一下名为“person”的数据结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Name: string
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Age: number
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Balance: float
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Street: string
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ZipCode: number
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们要将我们的随机数据“转换”为上面的“person”结构，它将突然变成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Name: Bobby
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Age: &lt;span class=&#34;m&#34;&gt;45&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Balance: 100.50
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Street: &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; Harvard Drive
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ZipCode: &lt;span class=&#34;m&#34;&gt;90210&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在突然间，我能够理解并访问结构中的底层变量，因为它们现在是有意义的，即 person-&amp;gt;Name，并且发现此特定的 person 类型对象具有名称变量“Bobby”！&lt;/p&gt;
&lt;p&gt;这正是我们将对我们的&lt;code&gt;*data&lt;/code&gt;所做的！&lt;/p&gt;
&lt;h3 id=&#34;数据中包含什么&#34;&gt;数据中包含什么？&lt;/h3&gt;
&lt;p&gt;因此，第一步是确定数据是否以以太网帧开头！几乎所有传输的数据都以以太网帧开头，这相当简单，但其作用是具有源和目标硬件地址（无论虚拟化/容器化/有线网络还是 WiFi 如何）。因此，我们的第一步是将我们的&lt;code&gt;*data&lt;/code&gt;转换为类型&lt;code&gt;ETHHDR&lt;/code&gt;，如果成功，我们现在将能够了解组成以太网头数据类型的变量。这些包括源和目标 MAC 地址，但更重要的是剩余数据的内容是什么。再次，在大多数情况下，以太网头之后的&lt;code&gt;*data&lt;/code&gt;内容通常是 IP 头，但我们将通过检查以太网帧的 TBD 变量来验证。&lt;/p&gt;
&lt;p&gt;一旦我们验证下一组数据是 IP 头，我们将需要将以太网头之后的数据转换为 IPHDR 类型。一旦我们这样做，我们将能够访问 IP 特定的数据，例如源 IP（&lt;code&gt;saddr&lt;/code&gt;）或目标地址（&lt;code&gt;daddr&lt;/code&gt;），再次重要的是 IP 头包含一个变量，详细说明了 IP 头之后的数据是什么。这通常是 TCP 头或 UDP 头，但还有其他选择，例如 sctp 等。&lt;/p&gt;
&lt;p&gt;一旦我们查看了 IP 头的内部并确定数据类型是 TCP（也可能是 UDP 或其他内容），我们将把以太网头和 IP 头之后的数据都转换为 TCP 头类型！（几乎完成了）。通过访问 TCP 头的内容，我们可以获得 TCP 特定的数据，例如源端口或目标端口，用于验证数据的有效性的校验和以及其他有用的变量。&lt;/p&gt;
&lt;p&gt;现在我们几乎拥有一切，但是 TCP 头的长度可能是可变的，因此我们需要通过查看 tcl_len 变量来确定这一点，我们需要将其乘以 4。现在我们拥有了访问最终数据所需的一切！&lt;/p&gt;
&lt;p&gt;因此，&lt;code&gt;*data&lt;/code&gt;指向数据的开头！我们已经确定了以太网头之后是 IP 头，最后是 TCP 头，这意味着`*data + 以太网头 + IP 头 + TCP 头 = 实际应用程序数据！&lt;/p&gt;
&lt;h3 id=&#34;我们可以用这些信息做什么&#34;&gt;我们可以用这些信息做什么？&lt;/h3&gt;
&lt;p&gt;当我们解析各种标头时，实际上在 OSI 模型的不同层次上解锁了越来越多的信息！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[第 2 层]&lt;/strong&gt; 以太网头为我们提供了源和目标硬件地址，我们可以使用此信息来潜在地阻止从我们知道危险的源 MAC 地址处理的帧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[第 3 层]&lt;/strong&gt; IP 头包含源和目标 IP 地址，再次，我们可以像防火墙一样运作，通过使用 eBPF 程序丢弃特定 IP 地址的所有流量。或者，我们可以根据 IP 地址重定向流量，或者甚至在这一层实施负载均衡逻辑，以将流量重定向到其他底层 IP 地址集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[第 4 层]&lt;/strong&gt; TCP 或 UDP 标头定义了目标端口号，我们可以使用这些信息来确定应用程序协议是什么（即端口 80 通常意味着剩余的*data 可能是 HTTP 数据）。在这一层，我们通常会执行负载均衡等操作，基于目标（即在多个其他负载均衡器地址之间平衡）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[第 7 层]&lt;/strong&gt; 正如前面提到的，各种标头集合的末尾的数据是实际的应用程序数据，只要我们知道格式，我们也可以解析它。例如，如果外部 Web 浏览器尝试访问我的计算机上的&lt;code&gt;/index.html&lt;/code&gt;并附加了 eBPF 程序，我会解析到 TCP，然后确定它是端口 80，然后应用程序数据应该是 HTTP 格式。我可以通过查看应用程序数据的前三个字符（在所有标头之后）来验证这一点，使用以下伪代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;ApplicationData&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; EthernetHDR + IPHDR + TCPHDR // 将所有标头长度相加以找到数据
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;If &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; data&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;ApplicationData&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;G&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; data&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;ApplicationData+1&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;E&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; data&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;ApplicationData+2&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;T&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	// 这是一个HTTP GET请求
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	// 做一些令人兴奋的事情
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;现在我们“有点”理解了这个逻辑，也许我们应该考虑实施一些代码来完成所有这些&amp;hellip;但这将是另一天的事情。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>深入浅出运维可观测工具（一）：聊聊 eBPF 的前世今生</title>
      <link>https://cloudnativecn.com/blog/current-state-and-future-of-ebpf/</link>
      <pubDate>Thu, 10 Aug 2023 15:05:42 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/current-state-and-future-of-ebpf/</guid>
      <description>&lt;p&gt;今天跟大家分享的 eBPF（extended Berkeley Packet Filter），相信很多技术人员已经很熟悉了。作为 Linux 社区的新宠，它备受 Goole、Facebook、Twitter 等大公司的青睐。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-究竟有什么魔力让大家这么关注&#34;&gt;eBPF 究竟有什么魔力让大家这么关注&lt;/h2&gt;
&lt;p&gt;这是因为 eBPF 增加了内核的可扩展性，让内核变得更加灵活和强大。如果大家玩过乐高积木的话就会深有体会，乐高积木就是通过不断向主体添加积木来组合出更庞大的模型。而 eBPF 就像乐高积木一样，可以不断向内核添加 eBPF 模块来增强内核的功能。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ebpf&#34;&gt;什么是 eBPF&lt;/h2&gt;
&lt;p&gt;在介绍 eBPF (Extended Berkeley Packet Filter) 之前，我们先来了解一下它的前身－BPF (Berkeley Packet Filter) 伯克利数据包过滤器。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f1_hu5682574955635526630.webp 400w,
               /blog/current-state-and-future-of-ebpf/f1_hu6374631291070097637.webp 760w,
               /blog/current-state-and-future-of-ebpf/f1_hu18172806500673528673.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/current-state-and-future-of-ebpf/f1_hu5682574955635526630.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;BPF 最早由 Van Jacobson 在 1992 年开发，用于在 Unix 操作系统中过滤和捕获网络数据包。它运行在内核中，通过提供一个简单而强大的虚拟机，可以在网络协议层上进行高效的数据包处理操作。BPF 通过把过程转换成指令序列来实现，这些指令直接在内核中执行，从而避免了用户空间和内核空间之间频繁的切换。&lt;/p&gt;
&lt;h2 id=&#34;基于-bpf-开发的工具库有-libpcaptcpdump-等工具&#34;&gt;基于 BPF 开发的工具库有 libpcap、tcpdump 等工具。&lt;/h2&gt;
&lt;p&gt;BPF 在网络性能监测和安全策略实施方面具有广泛的应用。然而，由于其指令集的限制和功能的局限性，它无法支持更加复杂和灵活的数据包处理需求。&lt;/p&gt;
&lt;p&gt;正是为了克服 BPF 的限制，eBPF 应运而生。eBPF 于 2014 年（3.18 版本）年首次引入 Linux 内核，并在此后的几年中经历了快速的发展和完善。&lt;/p&gt;
&lt;p&gt;eBPF 是一个高度可扩展的、运行在内核中的虚拟机，具备与传统 BPF 相似的指令集，但功能更加强大且更加灵活。eBPF 可以在运行时即时编译，从而能够处理更加复杂和动态的数据包处理任务，如网络流量分析、安全检测和性能优化等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f2_hu15784856433667263209.webp 400w,
               /blog/current-state-and-future-of-ebpf/f2_hu11626152001242697386.webp 760w,
               /blog/current-state-and-future-of-ebpf/f2_hu14693445252091243321.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/current-state-and-future-of-ebpf/f2_hu15784856433667263209.webp&#34;
               width=&#34;760&#34;
               height=&#34;215&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;eBPF 的灵活性和可扩展性体现在它可以与各种用户空间程序（如 tcpdump、Wireshark、Suricata 等）和工具（如网络监控、调试器等) 无缝集成。&lt;/p&gt;
&lt;p&gt;eBPF 还可以与系统的其他组件（如网络协议栈、调度器等）交互，从而实现更加细粒度的性能优化和安全策略。&lt;/p&gt;
&lt;p&gt;此外，eBPF 的开发和使用也得到了广泛的支持和推动。社区中有许多致力于 eBPF 的开发者和贡献者，他们不断改进和扩展 eBPF 的功能。同时，一些知名的大型技术公司，如 Facebook、Netflix 和 Google 等，也在其产品和基础设施中广泛使用 eBPF。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-的发展史&#34;&gt;eBPF 的发展史&lt;/h2&gt;
&lt;p&gt;2014 年初，Alexei Starovoitov 实现了 eBPF。新的设计针对现代硬件进行了优化，所以 eBPF 生成的指令集比旧的 BPF 解释器生成的机器码执行得更快。扩展版本也增加了虚拟机中的寄存器数量，将原有的 2 个 32 位寄存器增加到 10 个 64 位寄存器。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f3_hu17421057482717197853.webp 400w,
               /blog/current-state-and-future-of-ebpf/f3_hu4266841647394804020.webp 760w,
               /blog/current-state-and-future-of-ebpf/f3_hu940626636710556166.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/current-state-and-future-of-ebpf/f3_hu17421057482717197853.webp&#34;
               width=&#34;760&#34;
               height=&#34;560&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;由于寄存器数量和宽度的增加，开发人员可以使用函数参数自由交换更多的信息，编写更复杂的程序。总之，这些改进使 eBPF 版本的速度比原来的 BPF 提高了 4 倍。&lt;/p&gt;
&lt;p&gt;eBPF 是一项具有革命性的技术，源自于 Linux 内核，可以在特权环境中运行受沙盒保护的程序，例如操作系统内核。它被用于安全有效地扩展内核的功能，而无需更改内核源代码或加载内核模块。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f4_hu5417348816224861253.webp 400w,
               /blog/current-state-and-future-of-ebpf/f4_hu13009276457627645217.webp 760w,
               /blog/current-state-and-future-of-ebpf/f4_hu11711827173174884446.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/current-state-and-future-of-ebpf/f4_hu5417348816224861253.webp&#34;
               width=&#34;760&#34;
               height=&#34;506&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在历史上，操作系统一直是实现可观察性、安全性和网络功能的理想场所，这是因为内核具有特权能力，可以监督和控制整个系统。与此同时，由于内核在系统中的核心地位以及对稳定性和安全性的高要求，操作系统内核的演进往往很困难。因此，与操作系统外部实现的功能相比，操作系统层面的创新速度传统上较低。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f5_hu9609662473548064110.webp 400w,
               /blog/current-state-and-future-of-ebpf/f5_hu15219833447841719633.webp 760w,
               /blog/current-state-and-future-of-ebpf/f5_hu7694316219702030872.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/current-state-and-future-of-ebpf/f5_hu9609662473548064110.webp&#34;
               width=&#34;760&#34;
               height=&#34;391&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;eBPF 从根本上改变了这个现象。通过在操作系统内运行受沙盒保护的程序，应用开发人员可以在运行时运行 eBPF 程序，为操作系统添加额外的功能。操作系统会利用即时编译器和验证引擎的帮助来保证安全性和执行效率，就像本地编译一样。这导致了一系列基于 eBPF 的项目的涌现，涵盖了各种用例，包括下一代网络、可观测性和安全功能。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-应用场景&#34;&gt;eBPF 应用场景&lt;/h2&gt;
&lt;p&gt;如今，eBPF 被广泛应用于驱动各种用例：在现代数据中心和云原生环境中提供高性能的网络和负载均衡；&lt;/p&gt;
&lt;p&gt;以低开销提取细粒度的安全可观测性数据，帮助应用开发人员追踪应用程序、提供性能故障排除的见解，进行预防性应用程序和容器运行时安全执行等等。&lt;/p&gt;
&lt;p&gt;可能性是无限的，eBPF 正在释放出的创新力量才刚刚开始。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-特性&#34;&gt;eBPF 特性&lt;/h2&gt;
&lt;h3 id=&#34;hook-overview&#34;&gt;Hook Overview&lt;/h3&gt;
&lt;p&gt;eBPF 程序都是事件驱动的，它们会在内核或者应用程序经过某个确定的 Hook 点的时候运行，这些 Hook 点都是提前定义的，包括系统调用、函数进入/退出、内核 tracepoints、网络事件等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f6_hu2974626716997495089.webp 400w,
               /blog/current-state-and-future-of-ebpf/f6_hu16939794538925235318.webp 760w,
               /blog/current-state-and-future-of-ebpf/f6_hu15052267427534527297.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/current-state-and-future-of-ebpf/f6_hu2974626716997495089.webp&#34;
               width=&#34;760&#34;
               height=&#34;578&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;verification&#34;&gt;Verification&lt;/h3&gt;
&lt;p&gt;With great power there must also come great responsibility.&lt;/p&gt;
&lt;p&gt;每一个 eBPF 程序加载到内核都要经过 Verification，用来保证 eBPF 程序的安全性，主要包括：&lt;/p&gt;
&lt;p&gt;要保证加载 eBPF 程序的进程有必要的特权级，除非节点开启了 unpriviledged 特性，只有特权级的程序才能够加载 eBPF 程序。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内核提供了一个配置项 /proc/sys/kernel/unprivileged_bpf_disabled 来禁止非特权用户使用 bpf(2) 系统调用，可以通过 sysctl 命令修改&lt;/li&gt;
&lt;li&gt;比较特殊的一点是，这个配置项特意设计为一次性开关（one-time kill switch），这意味着一旦将它设为 1，就没有办法再改为 0 了，除非重启内核&lt;/li&gt;
&lt;li&gt;一旦设置为 1 之后，只有初始命名空间中有 CAP_SYS_ADMIN 特权的进程才可以调用 bpf(2) 系统调用。Cilium 启动后也会将这个配置项设为 1：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;$ echo 1 &amp;gt; /proc/sys/kernel/unprivileged_bpf_disabled&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要保证 eBPF 程序不会崩溃或者使得系统出故障。&lt;/p&gt;
&lt;p&gt;要保证 eBPF 程序不能陷入死循环，能够 runs to completion。&lt;/p&gt;
&lt;p&gt;要保证 eBPF 程序必须满足系统要求的大小，过大的 eBPF 程序不允许被加载进内核。&lt;/p&gt;
&lt;p&gt;要保证 eBPF 程序的复杂度有限，Verifier 将会评估 eBPF 程序所有可能的执行路径，必须能够在有限时间内完成 eBPF 程序复杂度分析。&lt;/p&gt;
&lt;h3 id=&#34;jit-compilation&#34;&gt;JIT Compilation&lt;/h3&gt;
&lt;p&gt;Just-In-Time（JIT）编译用来将通用的 eBPF 字节码翻译成与机器相关的指令集，从而极大加速 BPF 程序的执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与解释器相比，它们可以降低每个指令的开销。通常指令可以 1:1 映射到底层架构的原生指令。&lt;/li&gt;
&lt;li&gt;这也会减少生成的可执行镜像的大小，因此对 CPU 的指令缓存更友好。&lt;/li&gt;
&lt;li&gt;特别地，对于 CISC 指令集（例如 x86），JIT 做了很多特殊优化，目的是为给定的指令产生可能的最短操作码，以降低程序翻译过程所需的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;64 位的 x86_64、arm64、ppc64、s390x、mips64、sparc64 和 32 位的 arm、x86_32 架构都内置了 in-kernel eBPF JIT 编译器，它们的功能都是一样的，可以用如下方式打开：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ echo 1 &amp;gt; /proc/sys/net/core/bpf_jit_enable&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;32 位的 mips、ppc 和 sparc 架构目前内置的是一个 cBPF JIT 编译器。这些只有 cBPF JIT 编译器的架构，以及那些甚至完全没有 BPF JIT 编译器的架构，需要通过内核中的解释器（in-kernel interpreter）执行 eBPF 程序。&lt;/p&gt;
&lt;p&gt;要判断哪些平台支持 eBPF JIT，可以在内核源文件中 grep HAVE_EBPF_JIT：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f8_hu16612290089547048337.webp 400w,
               /blog/current-state-and-future-of-ebpf/f8_hu8630502918549797434.webp 760w,
               /blog/current-state-and-future-of-ebpf/f8_hu3356698373949496590.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/current-state-and-future-of-ebpf/f8_hu16612290089547048337.webp&#34;
               width=&#34;760&#34;
               height=&#34;215&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f7_hu3940783226783878166.webp 400w,
               /blog/current-state-and-future-of-ebpf/f7_hu5253803303824727073.webp 760w,
               /blog/current-state-and-future-of-ebpf/f7_hu18182771546194607026.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/current-state-and-future-of-ebpf/f7_hu3940783226783878166.webp&#34;
               width=&#34;760&#34;
               height=&#34;364&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;好啦，本期关于运维可观测工具 eBPF 的分享到这里就告一段落了，下期我们再来讲讲 eBPF 在实际使用中遇到的问题。感兴趣的朋友可以关注一下~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编译运行 Linux 内核源码中的 eBPF 示例代码</title>
      <link>https://cloudnativecn.com/blog/compile-bpf-examples/</link>
      <pubDate>Thu, 06 Aug 2020 19:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/compile-bpf-examples/</guid>
      <description>&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;声明：下文提到的&lt;code&gt;bpf/BPF&lt;/code&gt;字样是泛指，包括&lt;code&gt;cBPF&lt;/code&gt;和&lt;code&gt;eBPF&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过文章，你能了解 Linux 内核代码中关于 bpf 程序的编译运行机制，并能学会如何基于 Linux 内核 bpf 示例环境编写你自己的 bpf 程序。文章涉及的实验环境和代码可以到这个 git repo 获取：
&lt;a href=&#34;https://github.com/nevermosby/linux-bpf-learning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/nevermosby/linux-bpf-learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近 Kubecon 2020 China 上已经有了 3 个关于 bpf 的中文分享（来自腾讯和 PingCAP），也看到国内第一梯队公司越来越关心 bpf 这项新技术，欢迎大家都能加入 bpf 学习队伍。&lt;/p&gt;
&lt;h2 id=&#34;内核源码里的-bpf-示例代码概述&#34;&gt;内核源码里的 BPF 示例代码概述&lt;/h2&gt;
&lt;p&gt;示例代码里基本是&lt;strong&gt;kern&lt;/strong&gt;和&lt;strong&gt;user&lt;/strong&gt;成对出现，也就是对于一个示例来说，分别提供了在内核空间运行的和用户空间运行的程序，绝对是良心之作了。&lt;/p&gt;
&lt;h2 id=&#34;下载-linux-内核源代码&#34;&gt;下载 Linux 内核源代码&lt;/h2&gt;
&lt;p&gt;First thing first，第一步是下载内核代码。&lt;/p&gt;
&lt;h3 id=&#34;选择内核版本&#34;&gt;选择内核版本&lt;/h3&gt;
&lt;p&gt;目前社区维护的内核版本繁多，你需要确定下载哪个版本的代码。个人建议是下载与你的操作系统运行一致的内核版本，避免后续编译时出现不兼容问题。&lt;/p&gt;
&lt;h3 id=&#34;选择下载渠道&#34;&gt;选择下载渠道&lt;/h3&gt;
&lt;p&gt;代码下载渠道也很多：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过 Linux 社区官方仓库下载。以下几个网站都是官方维护的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/torvalds/linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&lt;/a&gt;
观察下来，只要有新的commit，基本是实时同步的，下载最新版本的内核代码肯定没问题。如果你跟我一样，需要相对较旧的版本，只要切换相关的目标tag即可。我的内核版本是&lt;strong&gt;v4.15.0&lt;/strong&gt;，下载地址参考如下：
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/tree/v4.15&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/torvalds/linux/tree/v4.15&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tag/?h=v4.15&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tag/?h=v4.15&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 Ubuntu apt 仓库下载。Ubuntu 官方自己维护了每个操作系统版本的背后的 Linux 内核代码，可以通过以下两种 apt 命令方式获取相关代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 第一种方式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 先搜索&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; apt-cache search linux-source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-4.15.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 4.15.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-4.18.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 4.18.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-5.0.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 5.0.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-5.3.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 5.3.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 再安装&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; apt install linux-source-4.15.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 第二种方式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; apt-get &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; linux
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Reading package lists... Done
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NOTICE: &lt;span class=&#34;s1&#34;&gt;&amp;#39;linux&amp;#39;&lt;/span&gt; packaging is maintained in the &lt;span class=&#34;s1&#34;&gt;&amp;#39;Git&amp;#39;&lt;/span&gt; version control system at:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/bionic
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Please use:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/bionic
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;to retrieve the latest &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;possibly unreleased&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; updates to the package.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Need to get &lt;span class=&#34;m&#34;&gt;167&lt;/span&gt; MB of &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; archives.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Get:2 https://mirrors.ustc.edu.cn/ubuntu bionic-updates/main linux 4.15.0-99.100 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;tar&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;158&lt;/span&gt; MB&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;......
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 以上两种方式，内核源代码均下载至/usr/src/目录下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下载完成后，BPF 示例就在&lt;strong&gt;源码根目录/samples/bpf&lt;/strong&gt;目录下，可以到&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;看个在线版的，建议大家通读一遍这个目录下的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf/README.rst&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;README.rst&lt;/a&gt;，了解整体步骤。&lt;/p&gt;
&lt;h2 id=&#34;编译-bpf-示例代码&#34;&gt;编译 BPF 示例代码&lt;/h2&gt;
&lt;h3 id=&#34;安装编译所依赖的工具&#34;&gt;安装编译所依赖的工具&lt;/h3&gt;
&lt;p&gt;在真正开始编译工作之前，请确保你的实验环境已经安装&lt;code&gt;clang&lt;/code&gt;和&lt;code&gt;llvm&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clang &amp;gt;= version 3.4.0&lt;/li&gt;
&lt;li&gt;llvm &amp;gt;= version 3.7.1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;正式编译示例代码&#34;&gt;正式编译示例代码&lt;/h3&gt;
&lt;p&gt;万事俱备了，可以正式开始编译工作。我们说的“编译”其本质就是利用内核目录下不同的&lt;code&gt;Makefile&lt;/code&gt;，通过特定的&lt;code&gt;make&lt;/code&gt;指令完成特定工作。来，先上命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 切换到内核源代码根目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; linux_sourcecode/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 生成内核编译时需要的头文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make headers_install
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 可视化选择你想为内核添加的内核模块，最终生成保存了相关模块信息的.config文件，为执行后面的命令做准备&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make menuconfig
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 使用make命令编译samples/bpf/目录下所有bpf示例代码，注意需要加上最后的/符号&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make samples/bpf/ &lt;span class=&#34;c1&#34;&gt;# or  make M=samples/bpf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如下截图看结果，生成了一大堆的文件，有&lt;code&gt;.o&lt;/code&gt;后缀的目标文件，还有绿色高亮的可执行文件，挑两个执行下，效果符合期待。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kernel-bpf-examples&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kernel-bpf-examples&#34; srcset=&#34;
               /blog/compile-bpf-examples/bpf-kernel-examples_hu7047798090788963497.webp 400w,
               /blog/compile-bpf-examples/bpf-kernel-examples_hu9902525685196824568.webp 760w,
               /blog/compile-bpf-examples/bpf-kernel-examples_hu11785637165634411174.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/compile-bpf-examples/bpf-kernel-examples_hu7047798090788963497.webp&#34;
               width=&#34;760&#34;
               height=&#34;451&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      kernel-bpf-examples
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;分析samplesbpfmakefile文件&#34;&gt;分析&lt;strong&gt;samples/bpf/Makefile&lt;/strong&gt;文件&lt;/h2&gt;
&lt;p&gt;如果你是个喜欢打破砂锅问到底的同学，可以跟我一起看看最后的 make 命令到底用了什么魔法？当然你也可以跳过这个章节。本次分析的 Makefile 是基于内核版本&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;v4.15.0&lt;/a&gt;，不同内核版本的 Makefile 内容会有差异，但总体逻辑是一致的。&lt;/p&gt;
&lt;h3 id=&#34;前提条件&#34;&gt;前提条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果你对&lt;code&gt;make&lt;/code&gt;作为构建工具还不熟悉，可以看看这个&lt;a href=&#34;http://www.ruanyifeng.com/blog/2015/02/make.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;教程&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;Linux 内核中大部分 Makefile 都是基于&lt;a href=&#34;https://www.kernel.org/doc/html/latest/kbuild/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kernel Build System&lt;/a&gt;，简称&lt;code&gt;kbuild&lt;/code&gt;，它是对 Makefile 的扩展，使其在编译内核文件时更加高效、简洁。因此你需要对其有所了解，可以到&lt;a href=&#34;https://www.kernel.org/doc/html/latest/kbuild/makefiles.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;看看官方介绍。&lt;/li&gt;
&lt;li&gt;上文使用的另外两个&lt;strong&gt;make&lt;/strong&gt;命令，利用的是根目录下的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/a&gt;，完成“生成头文件”和“生成.config 文件”，这两步是内核开发的必要步骤，感兴趣的同学移步看&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/Documentation/admin-guide/README.rst&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;README.rst&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分段分析&#34;&gt;分段分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一段关于变量&lt;code&gt;hostprogs-y&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# List of programs to build&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; test_lru_dist
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sock_example
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; fds_example
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sockex1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sockex2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sockex3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Makefile 的第一段是初始化变量&lt;code&gt;hostprogs-y&lt;/code&gt;，乍一看，好像是把所有示例程序名称都赋值给了&lt;code&gt;hostprogs-y&lt;/code&gt;。官方的注释是&lt;strong&gt;List of programs to build&lt;/strong&gt;，直译过来是，“准备构建的程序清单”、，大致能猜出这个变量的意义了，通过查询官方文档，发现一个概念叫&lt;a href=&#34;https://www.kernel.org/doc/html/latest/kbuild/makefiles.html#host-program-support&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Host Program support&lt;/strong&gt;&lt;/a&gt;，意思是在编译阶段就构建出可以在本机直接运行的可执行文件，为了实现这个目的，需要经过两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一步告诉 &lt;strong&gt;kbuild&lt;/strong&gt; 需要生成哪些可执行文件，这个就是通过变量&lt;code&gt;hostprogs-y&lt;/code&gt;来指定。来看源码中的这一行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; test_lru_dist
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;程序&lt;code&gt;test_lru_dist&lt;/code&gt;就是一个被指定的可执行程序名称，&lt;code&gt;kbuild&lt;/code&gt;默认会去同一个目录下查找名为&lt;code&gt;test_lru_dist.c&lt;/code&gt;作为构建这个可执行文件的源文件。类似代码也是同样的意义，总计有41个可执行文件赋值给了变量&lt;code&gt;hostprogs-y&lt;/code&gt;中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二步是将显式依赖关系添加到可执行文件中。这可以通过两种方式来完成，一种是为Makefile中某个&lt;strong&gt;target&lt;/strong&gt;添加这个可执行文件，作为&lt;strong&gt;prerequisites&lt;/strong&gt;，形成依赖关系，这样就可以触发这个可执行文件的构建任务，另一种是直接利用变量 &lt;code&gt;always&lt;/code&gt;，即无需指定第一种方式中的依赖关系，只要Makefile被执行，变量&lt;code&gt;always&lt;/code&gt;中包含的可执行文件都会被构建。来看源码中的相关片段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Tell kbuild to always build the programs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;always :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;hostprogs-y&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到它使用上文提到的第二种方式，保证这些可执行文件一定会被执行构建任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二段关于变量&lt;code&gt;&amp;lt;executeable&amp;gt;-objs&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Libbpf dependencies&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;LIBBPF :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; ../../tools/lib/bpf/bpf.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CGROUP_HELPERS :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; ../../tools/testing/selftests/bpf/cgroup_helpers.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;test_lru_dist-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; test_lru_dist.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sock_example-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sock_example.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;fds_example-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; fds_example.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex1-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex1_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex2-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex2_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex3-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex3_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一、二行是声明并初始化了两个变量&lt;code&gt;LIBBPF&lt;/code&gt;和&lt;code&gt;CGROUP_HELPERS&lt;/code&gt;，以便后续复用。后面的几行是有共性的，&lt;code&gt;:=&lt;/code&gt;符号左边是个有规律的变量：&lt;code&gt;&amp;lt;executeable&amp;gt;-objs&lt;/code&gt;，右边是多个.o 文件，看上去的意义像是右边的多个文件会合并成一个指定文件。通过查询文档可知，可执行文件可以由多个其他文件复合组成，通过&lt;code&gt;&amp;lt;executeable&amp;gt;-objs&lt;/code&gt;这样的语法，可以列出并指定所有用于生成最终可执行文件（命名为&lt;code&gt;executeable&lt;/code&gt;）的文件清单。以如下代码为例，可执行文件&lt;code&gt;sockex1&lt;/code&gt;是由&lt;code&gt;bpf_load.o&lt;/code&gt;、&lt;code&gt;bpf.o&lt;/code&gt;和&lt;code&gt;sockex1_usr.o&lt;/code&gt;链接生成的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex1-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex1_user.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三段关于变量&lt;code&gt;HOSTCFLAGS&lt;/code&gt;和&lt;code&gt;HOSTLOADLIBES&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objtree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/usr/include
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/lib/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/testing/selftests/bpf/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/lib/ -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/include
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/perf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HOSTCFLAGS_bpf_load.o +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objtree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/usr/include -Wno-unused-variable
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_fds_example&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_sockex1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_sockex2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_sockex3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_tracex4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf -lrt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码中有两个关键变量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;变量&lt;code&gt;HOSTCFLAGS&lt;/code&gt;顾名思义，它是在编译 host program（即可执行文件）时，为&lt;strong&gt;编译&lt;/strong&gt;操作指定的特殊选项，如上面代码中使用&lt;code&gt;-I&lt;/code&gt;参数指定依赖的头文件所在目录。默认情况下，这个变量的配置会作用到当前 Makefile 涉及的所有 host program。如果你想为某个 host program 单独指定一个编译选项，可以像上文的这行代码：
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HOSTCFLAGS_bpf_load.o +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objtree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/usr/include -Wno-unused-variable
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;只为&lt;code&gt;bpf_load.o&lt;/code&gt;这个 object 文件指定特殊选项。&lt;/li&gt;
&lt;li&gt;变量&lt;code&gt;HOSTLOADLIBES&lt;/code&gt;是用于&lt;strong&gt;链接&lt;/strong&gt;（link）操作时指定的特殊选项，如上面代码中使用两个 library（因为代码中使用了相关的函数），通过选项&lt;code&gt;-l&lt;/code&gt;加到最终生成的可执行文件中：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libelf&lt;/code&gt;，这个库用来管理 elf 格式的文件，bpf 程序一般都会使用 elf 作为最终格式，因此需要加载这个 library。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;librt&lt;/code&gt;，这个库其实很常用，一般含有&lt;code&gt;#include&amp;lt;time.h&amp;gt;&lt;/code&gt;头文件的代码，都需要加载这个 library，用来支持 real time 相关功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四段关于如何编译 BPF 程序源文件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Trick to allow make to be run from this directory&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;all:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;MAKE&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -C ../../ &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;obj&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.o: &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;src&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;CLANG&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;NOSTDINC_FLAGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LINUXINCLUDE&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;EXTRA_CFLAGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;obj&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/testing/selftests/bpf/ &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-D__KERNEL__ -Wno-unused-value -Wno-pointer-sign &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-D__TARGET_ARCH_&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;ARCH&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -Wno-compare-distinct-pointer-types &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-Wno-gnu-variable-sized-type-not-at-end &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-Wno-address-of-packed-member -Wno-tautological-compare &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-Wno-unknown-warning-option &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;CLANG_ARCH_ARGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-O2 -emit-llvm -c $&amp;lt; -o -&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LLC&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -march&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;bpf -filetype&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;obj -o &lt;span class=&#34;nv&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中有两个系统变量：第一个&lt;code&gt;$@&lt;/code&gt;代表的是 target 所指的文件名；第二个&lt;code&gt;$&amp;lt;&lt;/code&gt;代表的是第一个 prerequisite 的文件名。看过本站关于 BPF 博文的同学可能已经看出如上代码的玄机了，我把它简化下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;clang -I &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/testing/selftests/bpf/ &lt;span class=&#34;se&#34;&gt;\ &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  	      -O2 -emit-llvm -c $&amp;lt; -o -&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\ &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  	      llc -march&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;bpf -filetype&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;obj -o &lt;span class=&#34;nv&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上面的简化版命令，可以看出最后一行 make 命令的本质，就是把所有.c 源代码文件，通过 clang 全部编译成.o 目标文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;对&lt;strong&gt;samples/bpf/Makefile&lt;/strong&gt;这个文件执行 make 命令的本质就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为运行在内核空间的示例源代码（一般文件名称后缀为&lt;strong&gt;kern.c&lt;/strong&gt;），编译生成.o 后缀的目标文件，以便加载到对应 BPF 提供的 hook 中去。&lt;/li&gt;
&lt;li&gt;为运行在用户空间的示例源代码 (一般文件文件后缀为&lt;strong&gt;user.c&lt;/strong&gt;)，编译生成可以在本机直接运行的可执行文件，以便用户可以直接运行测试。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;我在执行-make-命令遇到的问题&#34;&gt;我在执行 Make 命令遇到的问题&lt;/h2&gt;
&lt;p&gt;我自己的实验环境是 Ubuntu 18.04 with 4.15.0 内核，在执行上面的 make 命令时，发生了以下的错误信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;In file included from ./tools/perf/perf-sys.h:9:0,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            	 from samples/bpf/bpf_load.c:28:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h: In &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; ‘sys_perf_event_open’:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h:68:15: error: ‘test_attr__enabled’ undeclared &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;first use in this &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;unlikely&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;test_attr__enabled&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/include/linux/compiler.h:74:43: note: in definition of macro ‘unlikely’
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;c1&#34;&gt;# define unlikely(x)  __builtin_expect(!!(x), 0)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                    	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h:68:15: note: each undeclared identifier is reported only once &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; each &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; it appears in
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;unlikely&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;test_attr__enabled&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/include/linux/compiler.h:74:43: note: in definition of macro ‘unlikely’
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;c1&#34;&gt;# define unlikely(x)  __builtin_expect(!!(x), 0)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                    	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;In file included from samples/bpf/bpf_load.c:28:0:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h:69:3: warning: implicit declaration of &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; ‘test_attr__open’ &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;-Wimplicit-function-declaration&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   test_attr__open&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;attr, pid, cpu, fd, group_fd, flags&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   ^~~~~~~~~~~~~~~
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;scripts/Makefile.host:107: recipe &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; target &lt;span class=&#34;s1&#34;&gt;&amp;#39;samples/bpf/bpf_load.o&amp;#39;&lt;/span&gt; failed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: *** &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;samples/bpf/bpf_load.o&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Error &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Makefile:1823: recipe &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; target &lt;span class=&#34;s1&#34;&gt;&amp;#39;samples/bpf/&amp;#39;&lt;/span&gt; failed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make: *** &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;samples/bpf/&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Error &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据错误信息，查看发生错误的文件为**./tools/perf/perf-sys.h**，报错的那一行是 test 开头的。通过 Google 发现了内核大佬们的邮件来往：&lt;a href=&#34;https://www.spinics.net/lists/netdev/msg608676.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.spinics.net/lists/netdev/msg608676.html&lt;/a&gt;。大佬们建议由于是测试相关的代码，所以可以 skip 掉。修改完的文件在&lt;a href=&#34;https://github.com/nevermosby/linux-bpf-learning/blob/master/bpf/perf-sys.h&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;，请斟酌参考。重新运行 make 命令，错误不再发生了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make samples/bpf/ &lt;span class=&#34;c1&#34;&gt;# and it works&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;编译运行自己的-bpf-程序&#34;&gt;编译运行自己的 BPF 程序&lt;/h2&gt;
&lt;p&gt;如果你想利用 Linux 内核环境来编译自己的 BPF 程序，是非常方便的。只要对&lt;code&gt;samples/bpf/&lt;/code&gt;目录下的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/a&gt;进行一点点自定义改造即可，如果你仔细阅读了上面的分析，那么改造的原理就显而易见了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 假设你自己BPF程序如下所示：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 内核空间代码：my_bpf_101_kern.c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 用户空间代码：my_bpf_101_user.c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 从上之下，添加新的代码行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 1. 追加新的一行至hostprogs-y开头的代码块最后，保证自己的BPF程序能够生成可执行文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; my_bpf_101
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 2. 一般BPF程序使用以下命令即可，具体取决于你的程序是否依赖其他特殊头文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;my_bpf_101-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; my_bpf_101_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 3. 追加新的一行至always开头的代码块最后，保证触发生成可执行文件的任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;always&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; my_bpf_101_kern.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一般的 BPF 程序只需要通过如上 3 处更新加入到 Makefile 中，就可以使用&lt;code&gt;make samples/bpf/&lt;/code&gt;命令，生成你自己程序的可执行文件了。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
