<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>eBPF | 云原生社区（中国）</title>
    <link>https://cloudnative.to/category/ebpf/</link>
      <atom:link href="https://cloudnative.to/category/ebpf/index.xml" rel="self" type="application/rss+xml" />
    <description>eBPF</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 10 Aug 2023 15:05:42 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>eBPF</title>
      <link>https://cloudnative.to/category/ebpf/</link>
    </image>
    
    <item>
      <title>深入浅出运维可观测工具（一）：聊聊 eBPF 的前世今生</title>
      <link>https://cloudnative.to/blog/current-state-and-future-of-ebpf/</link>
      <pubDate>Thu, 10 Aug 2023 15:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/current-state-and-future-of-ebpf/</guid>
      <description>&lt;p&gt;今天跟大家分享的 eBPF（extended Berkeley Packet Filter），相信很多技术人员已经很熟悉了。作为 Linux 社区的新宠，它备受 Goole、Facebook、Twitter 等大公司的青睐。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-究竟有什么魔力让大家这么关注&#34;&gt;eBPF 究竟有什么魔力让大家这么关注&lt;/h2&gt;
&lt;p&gt;这是因为 eBPF 增加了内核的可扩展性，让内核变得更加灵活和强大。如果大家玩过乐高积木的话就会深有体会，乐高积木就是通过不断向主体添加积木来组合出更庞大的模型。而 eBPF 就像乐高积木一样，可以不断向内核添加 eBPF 模块来增强内核的功能。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ebpf&#34;&gt;什么是 eBPF&lt;/h2&gt;
&lt;p&gt;在介绍 eBPF (Extended Berkeley Packet Filter) 之前，我们先来了解一下它的前身－BPF (Berkeley Packet Filter) 伯克利数据包过滤器。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f1_huec675403e37987096c28758d6a9ae0a2_46422_105b77956754669ab9791b7694cfcc20.webp 400w,
               /blog/current-state-and-future-of-ebpf/f1_huec675403e37987096c28758d6a9ae0a2_46422_c4957cadb115974b0bde50770fcce2a7.webp 760w,
               /blog/current-state-and-future-of-ebpf/f1_huec675403e37987096c28758d6a9ae0a2_46422_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f1_huec675403e37987096c28758d6a9ae0a2_46422_105b77956754669ab9791b7694cfcc20.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;BPF 最早由 Van Jacobson 在 1992 年开发，用于在 Unix 操作系统中过滤和捕获网络数据包。它运行在内核中，通过提供一个简单而强大的虚拟机，可以在网络协议层上进行高效的数据包处理操作。BPF 通过把过程转换成指令序列来实现，这些指令直接在内核中执行，从而避免了用户空间和内核空间之间频繁的切换。&lt;/p&gt;
&lt;h2 id=&#34;基于-bpf-开发的工具库有-libpcaptcpdump-等工具&#34;&gt;基于 BPF 开发的工具库有 libpcap、tcpdump 等工具。&lt;/h2&gt;
&lt;p&gt;BPF 在网络性能监测和安全策略实施方面具有广泛的应用。然而，由于其指令集的限制和功能的局限性，它无法支持更加复杂和灵活的数据包处理需求。&lt;/p&gt;
&lt;p&gt;正是为了克服 BPF 的限制，eBPF 应运而生。eBPF 于 2014 年（3.18 版本）年首次引入 Linux 内核，并在此后的几年中经历了快速的发展和完善。&lt;/p&gt;
&lt;p&gt;eBPF 是一个高度可扩展的、运行在内核中的虚拟机，具备与传统 BPF 相似的指令集，但功能更加强大且更加灵活。eBPF 可以在运行时即时编译，从而能够处理更加复杂和动态的数据包处理任务，如网络流量分析、安全检测和性能优化等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f2_hu9bd9b6d925224e98e5e6d07de5460ab9_109821_e0755e376f378cdb83eab10aa9581ae9.webp 400w,
               /blog/current-state-and-future-of-ebpf/f2_hu9bd9b6d925224e98e5e6d07de5460ab9_109821_e86323b9991075671c1ec70687983f9f.webp 760w,
               /blog/current-state-and-future-of-ebpf/f2_hu9bd9b6d925224e98e5e6d07de5460ab9_109821_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f2_hu9bd9b6d925224e98e5e6d07de5460ab9_109821_e0755e376f378cdb83eab10aa9581ae9.webp&#34;
               width=&#34;760&#34;
               height=&#34;215&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;eBPF 的灵活性和可扩展性体现在它可以与各种用户空间程序（如 tcpdump、Wireshark、Suricata 等）和工具（如网络监控、调试器等) 无缝集成。&lt;/p&gt;
&lt;p&gt;eBPF 还可以与系统的其他组件（如网络协议栈、调度器等）交互，从而实现更加细粒度的性能优化和安全策略。&lt;/p&gt;
&lt;p&gt;此外，eBPF 的开发和使用也得到了广泛的支持和推动。社区中有许多致力于 eBPF 的开发者和贡献者，他们不断改进和扩展 eBPF 的功能。同时，一些知名的大型技术公司，如 Facebook、Netflix 和 Google 等，也在其产品和基础设施中广泛使用 eBPF。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-的发展史&#34;&gt;eBPF 的发展史&lt;/h2&gt;
&lt;p&gt;2014 年初，Alexei Starovoitov 实现了 eBPF。新的设计针对现代硬件进行了优化，所以 eBPF 生成的指令集比旧的 BPF 解释器生成的机器码执行得更快。扩展版本也增加了虚拟机中的寄存器数量，将原有的 2 个 32 位寄存器增加到 10 个 64 位寄存器。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f3_hucb5a0143d8e35c49a6eb44093b0441ed_50462_f43b60aaae0273b8a03431bc40106785.webp 400w,
               /blog/current-state-and-future-of-ebpf/f3_hucb5a0143d8e35c49a6eb44093b0441ed_50462_851e4467b9fbcf225e1f00ed199ebe6f.webp 760w,
               /blog/current-state-and-future-of-ebpf/f3_hucb5a0143d8e35c49a6eb44093b0441ed_50462_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f3_hucb5a0143d8e35c49a6eb44093b0441ed_50462_f43b60aaae0273b8a03431bc40106785.webp&#34;
               width=&#34;760&#34;
               height=&#34;560&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;由于寄存器数量和宽度的增加，开发人员可以使用函数参数自由交换更多的信息，编写更复杂的程序。总之，这些改进使 eBPF 版本的速度比原来的 BPF 提高了 4 倍。&lt;/p&gt;
&lt;p&gt;eBPF 是一项具有革命性的技术，源自于 Linux 内核，可以在特权环境中运行受沙盒保护的程序，例如操作系统内核。它被用于安全有效地扩展内核的功能，而无需更改内核源代码或加载内核模块。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f4_hue851aaa4c06e0d6bd892fa834496ae89_50559_962ea43852ed52fb7f6ae5c9af16101e.webp 400w,
               /blog/current-state-and-future-of-ebpf/f4_hue851aaa4c06e0d6bd892fa834496ae89_50559_a40db8e1b54ec22c07701a89ead7f676.webp 760w,
               /blog/current-state-and-future-of-ebpf/f4_hue851aaa4c06e0d6bd892fa834496ae89_50559_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f4_hue851aaa4c06e0d6bd892fa834496ae89_50559_962ea43852ed52fb7f6ae5c9af16101e.webp&#34;
               width=&#34;760&#34;
               height=&#34;506&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在历史上，操作系统一直是实现可观察性、安全性和网络功能的理想场所，这是因为内核具有特权能力，可以监督和控制整个系统。与此同时，由于内核在系统中的核心地位以及对稳定性和安全性的高要求，操作系统内核的演进往往很困难。因此，与操作系统外部实现的功能相比，操作系统层面的创新速度传统上较低。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f5_hu709774a88aa9173a4288ecbb03b21bee_168520_bbc447523629b2ccdacc846a1d0a77f8.webp 400w,
               /blog/current-state-and-future-of-ebpf/f5_hu709774a88aa9173a4288ecbb03b21bee_168520_975ca3e286b98a7a4c309649843c8643.webp 760w,
               /blog/current-state-and-future-of-ebpf/f5_hu709774a88aa9173a4288ecbb03b21bee_168520_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f5_hu709774a88aa9173a4288ecbb03b21bee_168520_bbc447523629b2ccdacc846a1d0a77f8.webp&#34;
               width=&#34;760&#34;
               height=&#34;391&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;eBPF 从根本上改变了这个现象。通过在操作系统内运行受沙盒保护的程序，应用开发人员可以在运行时运行 eBPF 程序，为操作系统添加额外的功能。操作系统会利用即时编译器和验证引擎的帮助来保证安全性和执行效率，就像本地编译一样。这导致了一系列基于 eBPF 的项目的涌现，涵盖了各种用例，包括下一代网络、可观测性和安全功能。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-应用场景&#34;&gt;eBPF 应用场景&lt;/h2&gt;
&lt;p&gt;如今，eBPF 被广泛应用于驱动各种用例：在现代数据中心和云原生环境中提供高性能的网络和负载均衡；&lt;/p&gt;
&lt;p&gt;以低开销提取细粒度的安全可观测性数据，帮助应用开发人员追踪应用程序、提供性能故障排除的见解，进行预防性应用程序和容器运行时安全执行等等。&lt;/p&gt;
&lt;p&gt;可能性是无限的，eBPF 正在释放出的创新力量才刚刚开始。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-特性&#34;&gt;eBPF 特性&lt;/h2&gt;
&lt;h3 id=&#34;hook-overview&#34;&gt;Hook Overview&lt;/h3&gt;
&lt;p&gt;eBPF 程序都是事件驱动的，它们会在内核或者应用程序经过某个确定的 Hook 点的时候运行，这些 Hook 点都是提前定义的，包括系统调用、函数进入/退出、内核 tracepoints、网络事件等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f6_hu0f616358f7c32619b4b83d98702d502b_174240_b01b7c7c44dab15b4481922b1e56a010.webp 400w,
               /blog/current-state-and-future-of-ebpf/f6_hu0f616358f7c32619b4b83d98702d502b_174240_e95f99ca8b5a5bc9759e6e3417cdcabb.webp 760w,
               /blog/current-state-and-future-of-ebpf/f6_hu0f616358f7c32619b4b83d98702d502b_174240_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f6_hu0f616358f7c32619b4b83d98702d502b_174240_b01b7c7c44dab15b4481922b1e56a010.webp&#34;
               width=&#34;760&#34;
               height=&#34;578&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;verification&#34;&gt;Verification&lt;/h3&gt;
&lt;p&gt;With great power there must also come great responsibility.&lt;/p&gt;
&lt;p&gt;每一个 eBPF 程序加载到内核都要经过 Verification，用来保证 eBPF 程序的安全性，主要包括：&lt;/p&gt;
&lt;p&gt;要保证加载 eBPF 程序的进程有必要的特权级，除非节点开启了 unpriviledged 特性，只有特权级的程序才能够加载 eBPF 程序。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内核提供了一个配置项 /proc/sys/kernel/unprivileged_bpf_disabled 来禁止非特权用户使用 bpf(2) 系统调用，可以通过 sysctl 命令修改&lt;/li&gt;
&lt;li&gt;比较特殊的一点是，这个配置项特意设计为一次性开关（one-time kill switch），这意味着一旦将它设为 1，就没有办法再改为 0 了，除非重启内核&lt;/li&gt;
&lt;li&gt;一旦设置为 1 之后，只有初始命名空间中有 CAP_SYS_ADMIN 特权的进程才可以调用 bpf(2) 系统调用。Cilium 启动后也会将这个配置项设为 1：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;$ echo 1 &amp;gt; /proc/sys/kernel/unprivileged_bpf_disabled&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要保证 eBPF 程序不会崩溃或者使得系统出故障。&lt;/p&gt;
&lt;p&gt;要保证 eBPF 程序不能陷入死循环，能够 runs to completion。&lt;/p&gt;
&lt;p&gt;要保证 eBPF 程序必须满足系统要求的大小，过大的 eBPF 程序不允许被加载进内核。&lt;/p&gt;
&lt;p&gt;要保证 eBPF 程序的复杂度有限，Verifier 将会评估 eBPF 程序所有可能的执行路径，必须能够在有限时间内完成 eBPF 程序复杂度分析。&lt;/p&gt;
&lt;h3 id=&#34;jit-compilation&#34;&gt;JIT Compilation&lt;/h3&gt;
&lt;p&gt;Just-In-Time（JIT）编译用来将通用的 eBPF 字节码翻译成与机器相关的指令集，从而极大加速 BPF 程序的执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与解释器相比，它们可以降低每个指令的开销。通常指令可以 1:1 映射到底层架构的原生指令。&lt;/li&gt;
&lt;li&gt;这也会减少生成的可执行镜像的大小，因此对 CPU 的指令缓存更友好。&lt;/li&gt;
&lt;li&gt;特别地，对于 CISC 指令集（例如 x86），JIT 做了很多特殊优化，目的是为给定的指令产生可能的最短操作码，以降低程序翻译过程所需的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;64 位的 x86_64、arm64、ppc64、s390x、mips64、sparc64 和 32 位的 arm、x86_32 架构都内置了 in-kernel eBPF JIT 编译器，它们的功能都是一样的，可以用如下方式打开：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ echo 1 &amp;gt; /proc/sys/net/core/bpf_jit_enable&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;32 位的 mips、ppc 和 sparc 架构目前内置的是一个 cBPF JIT 编译器。这些只有 cBPF JIT 编译器的架构，以及那些甚至完全没有 BPF JIT 编译器的架构，需要通过内核中的解释器（in-kernel interpreter）执行 eBPF 程序。&lt;/p&gt;
&lt;p&gt;要判断哪些平台支持 eBPF JIT，可以在内核源文件中 grep HAVE_EBPF_JIT：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f8_hufef87359acc710053a41eae8ce0c442e_33096_f06677c369a30b78b0cffc6ada2cb4de.webp 400w,
               /blog/current-state-and-future-of-ebpf/f8_hufef87359acc710053a41eae8ce0c442e_33096_edf76d22a6e39c8cfe69a1b1b7e18e8b.webp 760w,
               /blog/current-state-and-future-of-ebpf/f8_hufef87359acc710053a41eae8ce0c442e_33096_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f8_hufef87359acc710053a41eae8ce0c442e_33096_f06677c369a30b78b0cffc6ada2cb4de.webp&#34;
               width=&#34;760&#34;
               height=&#34;215&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f7_hu74e6943e84e5c2e3fac5f6921d5dc7fc_71503_15583eae7ce68874c3785050044a012b.webp 400w,
               /blog/current-state-and-future-of-ebpf/f7_hu74e6943e84e5c2e3fac5f6921d5dc7fc_71503_4205e2ca601aada142d5027de67279d8.webp 760w,
               /blog/current-state-and-future-of-ebpf/f7_hu74e6943e84e5c2e3fac5f6921d5dc7fc_71503_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f7_hu74e6943e84e5c2e3fac5f6921d5dc7fc_71503_15583eae7ce68874c3785050044a012b.webp&#34;
               width=&#34;760&#34;
               height=&#34;364&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;好啦，本期关于运维可观测工具 eBPF 的分享到这里就告一段落了，下期我们再来讲讲 eBPF 在实际使用中遇到的问题。感兴趣的朋友可以关注一下~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编译运行 Linux 内核源码中的 eBPF 示例代码</title>
      <link>https://cloudnative.to/blog/compile-bpf-examples/</link>
      <pubDate>Thu, 06 Aug 2020 19:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/compile-bpf-examples/</guid>
      <description>&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;声明：下文提到的&lt;code&gt;bpf/BPF&lt;/code&gt;字样是泛指，包括&lt;code&gt;cBPF&lt;/code&gt;和&lt;code&gt;eBPF&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过文章，你能了解 Linux 内核代码中关于 bpf 程序的编译运行机制，并能学会如何基于 Linux 内核 bpf 示例环境编写你自己的 bpf 程序。文章涉及的实验环境和代码可以到这个 git repo 获取：
&lt;a href=&#34;https://github.com/nevermosby/linux-bpf-learning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/nevermosby/linux-bpf-learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近 Kubecon 2020 China 上已经有了 3 个关于 bpf 的中文分享（来自腾讯和 PingCAP），也看到国内第一梯队公司越来越关心 bpf 这项新技术，欢迎大家都能加入 bpf 学习队伍。&lt;/p&gt;
&lt;h2 id=&#34;内核源码里的-bpf-示例代码概述&#34;&gt;内核源码里的 BPF 示例代码概述&lt;/h2&gt;
&lt;p&gt;示例代码里基本是&lt;strong&gt;kern&lt;/strong&gt;和&lt;strong&gt;user&lt;/strong&gt;成对出现，也就是对于一个示例来说，分别提供了在内核空间运行的和用户空间运行的程序，绝对是良心之作了。&lt;/p&gt;
&lt;h2 id=&#34;下载-linux-内核源代码&#34;&gt;下载 Linux 内核源代码&lt;/h2&gt;
&lt;p&gt;First thing first，第一步是下载内核代码。&lt;/p&gt;
&lt;h3 id=&#34;选择内核版本&#34;&gt;选择内核版本&lt;/h3&gt;
&lt;p&gt;目前社区维护的内核版本繁多，你需要确定下载哪个版本的代码。个人建议是下载与你的操作系统运行一致的内核版本，避免后续编译时出现不兼容问题。&lt;/p&gt;
&lt;h3 id=&#34;选择下载渠道&#34;&gt;选择下载渠道&lt;/h3&gt;
&lt;p&gt;代码下载渠道也很多：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过 Linux 社区官方仓库下载。以下几个网站都是官方维护的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/torvalds/linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&lt;/a&gt;
观察下来，只要有新的commit，基本是实时同步的，下载最新版本的内核代码肯定没问题。如果你跟我一样，需要相对较旧的版本，只要切换相关的目标tag即可。我的内核版本是&lt;strong&gt;v4.15.0&lt;/strong&gt;，下载地址参考如下：
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/tree/v4.15&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/torvalds/linux/tree/v4.15&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tag/?h=v4.15&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tag/?h=v4.15&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 Ubuntu apt 仓库下载。Ubuntu 官方自己维护了每个操作系统版本的背后的 Linux 内核代码，可以通过以下两种 apt 命令方式获取相关代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 第一种方式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 先搜索&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; apt-cache search linux-source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-4.15.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 4.15.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-4.18.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 4.18.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-5.0.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 5.0.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-5.3.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 5.3.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 再安装&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; apt install linux-source-4.15.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 第二种方式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; apt-get &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; linux
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Reading package lists... Done
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NOTICE: &lt;span class=&#34;s1&#34;&gt;&amp;#39;linux&amp;#39;&lt;/span&gt; packaging is maintained in the &lt;span class=&#34;s1&#34;&gt;&amp;#39;Git&amp;#39;&lt;/span&gt; version control system at:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/bionic
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Please use:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/bionic
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;to retrieve the latest &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;possibly unreleased&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; updates to the package.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Need to get &lt;span class=&#34;m&#34;&gt;167&lt;/span&gt; MB of &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; archives.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Get:2 https://mirrors.ustc.edu.cn/ubuntu bionic-updates/main linux 4.15.0-99.100 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;tar&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;158&lt;/span&gt; MB&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;......
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 以上两种方式，内核源代码均下载至/usr/src/目录下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下载完成后，BPF 示例就在&lt;strong&gt;源码根目录/samples/bpf&lt;/strong&gt;目录下，可以到&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;看个在线版的，建议大家通读一遍这个目录下的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf/README.rst&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;README.rst&lt;/a&gt;，了解整体步骤。&lt;/p&gt;
&lt;h2 id=&#34;编译-bpf-示例代码&#34;&gt;编译 BPF 示例代码&lt;/h2&gt;
&lt;h3 id=&#34;安装编译所依赖的工具&#34;&gt;安装编译所依赖的工具&lt;/h3&gt;
&lt;p&gt;在真正开始编译工作之前，请确保你的实验环境已经安装&lt;code&gt;clang&lt;/code&gt;和&lt;code&gt;llvm&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clang &amp;gt;= version 3.4.0&lt;/li&gt;
&lt;li&gt;llvm &amp;gt;= version 3.7.1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;正式编译示例代码&#34;&gt;正式编译示例代码&lt;/h3&gt;
&lt;p&gt;万事俱备了，可以正式开始编译工作。我们说的“编译”其本质就是利用内核目录下不同的&lt;code&gt;Makefile&lt;/code&gt;，通过特定的&lt;code&gt;make&lt;/code&gt;指令完成特定工作。来，先上命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 切换到内核源代码根目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; linux_sourcecode/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 生成内核编译时需要的头文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make headers_install
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 可视化选择你想为内核添加的内核模块，最终生成保存了相关模块信息的.config文件，为执行后面的命令做准备&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make menuconfig
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 使用make命令编译samples/bpf/目录下所有bpf示例代码，注意需要加上最后的/符号&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make samples/bpf/ &lt;span class=&#34;c1&#34;&gt;# or  make M=samples/bpf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如下截图看结果，生成了一大堆的文件，有&lt;code&gt;.o&lt;/code&gt;后缀的目标文件，还有绿色高亮的可执行文件，挑两个执行下，效果符合期待。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kernel-bpf-examples&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kernel-bpf-examples&#34; srcset=&#34;
               /blog/compile-bpf-examples/bpf-kernel-examples_huec5682109456d7311ac8ab990a6e8b54_422281_a52f884c6350e498c80d9f1a41024f7f.webp 400w,
               /blog/compile-bpf-examples/bpf-kernel-examples_huec5682109456d7311ac8ab990a6e8b54_422281_7792b31a233f595b5498f86ef11b4e01.webp 760w,
               /blog/compile-bpf-examples/bpf-kernel-examples_huec5682109456d7311ac8ab990a6e8b54_422281_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/compile-bpf-examples/bpf-kernel-examples_huec5682109456d7311ac8ab990a6e8b54_422281_a52f884c6350e498c80d9f1a41024f7f.webp&#34;
               width=&#34;760&#34;
               height=&#34;451&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      kernel-bpf-examples
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;分析samplesbpfmakefile文件&#34;&gt;分析&lt;strong&gt;samples/bpf/Makefile&lt;/strong&gt;文件&lt;/h2&gt;
&lt;p&gt;如果你是个喜欢打破砂锅问到底的同学，可以跟我一起看看最后的 make 命令到底用了什么魔法？当然你也可以跳过这个章节。本次分析的 Makefile 是基于内核版本&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;v4.15.0&lt;/a&gt;，不同内核版本的 Makefile 内容会有差异，但总体逻辑是一致的。&lt;/p&gt;
&lt;h3 id=&#34;前提条件&#34;&gt;前提条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果你对&lt;code&gt;make&lt;/code&gt;作为构建工具还不熟悉，可以看看这个&lt;a href=&#34;http://www.ruanyifeng.com/blog/2015/02/make.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;教程&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;Linux 内核中大部分 Makefile 都是基于&lt;a href=&#34;https://www.kernel.org/doc/html/latest/kbuild/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kernel Build System&lt;/a&gt;，简称&lt;code&gt;kbuild&lt;/code&gt;，它是对 Makefile 的扩展，使其在编译内核文件时更加高效、简洁。因此你需要对其有所了解，可以到&lt;a href=&#34;https://www.kernel.org/doc/html/latest/kbuild/makefiles.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;看看官方介绍。&lt;/li&gt;
&lt;li&gt;上文使用的另外两个&lt;strong&gt;make&lt;/strong&gt;命令，利用的是根目录下的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/a&gt;，完成“生成头文件”和“生成.config 文件”，这两步是内核开发的必要步骤，感兴趣的同学移步看&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/Documentation/admin-guide/README.rst&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;README.rst&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分段分析&#34;&gt;分段分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一段关于变量&lt;code&gt;hostprogs-y&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# List of programs to build&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; test_lru_dist
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sock_example
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; fds_example
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sockex1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sockex2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sockex3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Makefile 的第一段是初始化变量&lt;code&gt;hostprogs-y&lt;/code&gt;，乍一看，好像是把所有示例程序名称都赋值给了&lt;code&gt;hostprogs-y&lt;/code&gt;。官方的注释是&lt;strong&gt;List of programs to build&lt;/strong&gt;，直译过来是，“准备构建的程序清单”、，大致能猜出这个变量的意义了，通过查询官方文档，发现一个概念叫&lt;a href=&#34;https://www.kernel.org/doc/html/latest/kbuild/makefiles.html#host-program-support&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Host Program support&lt;/strong&gt;&lt;/a&gt;，意思是在编译阶段就构建出可以在本机直接运行的可执行文件，为了实现这个目的，需要经过两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一步告诉 &lt;strong&gt;kbuild&lt;/strong&gt; 需要生成哪些可执行文件，这个就是通过变量&lt;code&gt;hostprogs-y&lt;/code&gt;来指定。来看源码中的这一行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; test_lru_dist
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;程序&lt;code&gt;test_lru_dist&lt;/code&gt;就是一个被指定的可执行程序名称，&lt;code&gt;kbuild&lt;/code&gt;默认会去同一个目录下查找名为&lt;code&gt;test_lru_dist.c&lt;/code&gt;作为构建这个可执行文件的源文件。类似代码也是同样的意义，总计有41个可执行文件赋值给了变量&lt;code&gt;hostprogs-y&lt;/code&gt;中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二步是将显式依赖关系添加到可执行文件中。这可以通过两种方式来完成，一种是为Makefile中某个&lt;strong&gt;target&lt;/strong&gt;添加这个可执行文件，作为&lt;strong&gt;prerequisites&lt;/strong&gt;，形成依赖关系，这样就可以触发这个可执行文件的构建任务，另一种是直接利用变量 &lt;code&gt;always&lt;/code&gt;，即无需指定第一种方式中的依赖关系，只要Makefile被执行，变量&lt;code&gt;always&lt;/code&gt;中包含的可执行文件都会被构建。来看源码中的相关片段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Tell kbuild to always build the programs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;always :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;hostprogs-y&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到它使用上文提到的第二种方式，保证这些可执行文件一定会被执行构建任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二段关于变量&lt;code&gt;&amp;lt;executeable&amp;gt;-objs&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Libbpf dependencies&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;LIBBPF :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; ../../tools/lib/bpf/bpf.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CGROUP_HELPERS :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; ../../tools/testing/selftests/bpf/cgroup_helpers.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;test_lru_dist-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; test_lru_dist.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sock_example-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sock_example.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;fds_example-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; fds_example.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex1-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex1_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex2-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex2_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex3-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex3_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一、二行是声明并初始化了两个变量&lt;code&gt;LIBBPF&lt;/code&gt;和&lt;code&gt;CGROUP_HELPERS&lt;/code&gt;，以便后续复用。后面的几行是有共性的，&lt;code&gt;:=&lt;/code&gt;符号左边是个有规律的变量：&lt;code&gt;&amp;lt;executeable&amp;gt;-objs&lt;/code&gt;，右边是多个.o 文件，看上去的意义像是右边的多个文件会合并成一个指定文件。通过查询文档可知，可执行文件可以由多个其他文件复合组成，通过&lt;code&gt;&amp;lt;executeable&amp;gt;-objs&lt;/code&gt;这样的语法，可以列出并指定所有用于生成最终可执行文件（命名为&lt;code&gt;executeable&lt;/code&gt;）的文件清单。以如下代码为例，可执行文件&lt;code&gt;sockex1&lt;/code&gt;是由&lt;code&gt;bpf_load.o&lt;/code&gt;、&lt;code&gt;bpf.o&lt;/code&gt;和&lt;code&gt;sockex1_usr.o&lt;/code&gt;链接生成的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex1-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex1_user.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三段关于变量&lt;code&gt;HOSTCFLAGS&lt;/code&gt;和&lt;code&gt;HOSTLOADLIBES&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objtree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/usr/include
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/lib/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/testing/selftests/bpf/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/lib/ -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/include
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/perf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HOSTCFLAGS_bpf_load.o +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objtree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/usr/include -Wno-unused-variable
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_fds_example&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_sockex1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_sockex2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_sockex3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_tracex4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf -lrt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码中有两个关键变量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;变量&lt;code&gt;HOSTCFLAGS&lt;/code&gt;顾名思义，它是在编译 host program（即可执行文件）时，为&lt;strong&gt;编译&lt;/strong&gt;操作指定的特殊选项，如上面代码中使用&lt;code&gt;-I&lt;/code&gt;参数指定依赖的头文件所在目录。默认情况下，这个变量的配置会作用到当前 Makefile 涉及的所有 host program。如果你想为某个 host program 单独指定一个编译选项，可以像上文的这行代码：
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HOSTCFLAGS_bpf_load.o +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objtree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/usr/include -Wno-unused-variable
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;只为&lt;code&gt;bpf_load.o&lt;/code&gt;这个 object 文件指定特殊选项。&lt;/li&gt;
&lt;li&gt;变量&lt;code&gt;HOSTLOADLIBES&lt;/code&gt;是用于&lt;strong&gt;链接&lt;/strong&gt;（link）操作时指定的特殊选项，如上面代码中使用两个 library（因为代码中使用了相关的函数），通过选项&lt;code&gt;-l&lt;/code&gt;加到最终生成的可执行文件中：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libelf&lt;/code&gt;，这个库用来管理 elf 格式的文件，bpf 程序一般都会使用 elf 作为最终格式，因此需要加载这个 library。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;librt&lt;/code&gt;，这个库其实很常用，一般含有&lt;code&gt;#include&amp;lt;time.h&amp;gt;&lt;/code&gt;头文件的代码，都需要加载这个 library，用来支持 real time 相关功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四段关于如何编译 BPF 程序源文件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Trick to allow make to be run from this directory&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;all:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;MAKE&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -C ../../ &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;obj&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.o: &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;src&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;CLANG&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;NOSTDINC_FLAGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LINUXINCLUDE&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;EXTRA_CFLAGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;obj&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/testing/selftests/bpf/ &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-D__KERNEL__ -Wno-unused-value -Wno-pointer-sign &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-D__TARGET_ARCH_&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;ARCH&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -Wno-compare-distinct-pointer-types &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-Wno-gnu-variable-sized-type-not-at-end &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-Wno-address-of-packed-member -Wno-tautological-compare &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-Wno-unknown-warning-option &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;CLANG_ARCH_ARGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-O2 -emit-llvm -c $&amp;lt; -o -&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LLC&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -march&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;bpf -filetype&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;obj -o &lt;span class=&#34;nv&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中有两个系统变量：第一个&lt;code&gt;$@&lt;/code&gt;代表的是 target 所指的文件名；第二个&lt;code&gt;$&amp;lt;&lt;/code&gt;代表的是第一个 prerequisite 的文件名。看过本站关于 BPF 博文的同学可能已经看出如上代码的玄机了，我把它简化下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;clang -I &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/testing/selftests/bpf/ &lt;span class=&#34;se&#34;&gt;\ &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  	      -O2 -emit-llvm -c $&amp;lt; -o -&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\ &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  	      llc -march&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;bpf -filetype&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;obj -o &lt;span class=&#34;nv&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上面的简化版命令，可以看出最后一行 make 命令的本质，就是把所有.c 源代码文件，通过 clang 全部编译成.o 目标文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;对&lt;strong&gt;samples/bpf/Makefile&lt;/strong&gt;这个文件执行 make 命令的本质就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为运行在内核空间的示例源代码（一般文件名称后缀为&lt;strong&gt;kern.c&lt;/strong&gt;），编译生成.o 后缀的目标文件，以便加载到对应 BPF 提供的 hook 中去。&lt;/li&gt;
&lt;li&gt;为运行在用户空间的示例源代码 (一般文件文件后缀为&lt;strong&gt;user.c&lt;/strong&gt;)，编译生成可以在本机直接运行的可执行文件，以便用户可以直接运行测试。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;我在执行-make-命令遇到的问题&#34;&gt;我在执行 Make 命令遇到的问题&lt;/h2&gt;
&lt;p&gt;我自己的实验环境是 Ubuntu 18.04 with 4.15.0 内核，在执行上面的 make 命令时，发生了以下的错误信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;In file included from ./tools/perf/perf-sys.h:9:0,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            	 from samples/bpf/bpf_load.c:28:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h: In &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; ‘sys_perf_event_open’:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h:68:15: error: ‘test_attr__enabled’ undeclared &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;first use in this &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;unlikely&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;test_attr__enabled&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/include/linux/compiler.h:74:43: note: in definition of macro ‘unlikely’
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;c1&#34;&gt;# define unlikely(x)  __builtin_expect(!!(x), 0)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                    	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h:68:15: note: each undeclared identifier is reported only once &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; each &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; it appears in
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;unlikely&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;test_attr__enabled&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/include/linux/compiler.h:74:43: note: in definition of macro ‘unlikely’
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;c1&#34;&gt;# define unlikely(x)  __builtin_expect(!!(x), 0)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                    	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;In file included from samples/bpf/bpf_load.c:28:0:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h:69:3: warning: implicit declaration of &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; ‘test_attr__open’ &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;-Wimplicit-function-declaration&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   test_attr__open&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;attr, pid, cpu, fd, group_fd, flags&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   ^~~~~~~~~~~~~~~
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;scripts/Makefile.host:107: recipe &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; target &lt;span class=&#34;s1&#34;&gt;&amp;#39;samples/bpf/bpf_load.o&amp;#39;&lt;/span&gt; failed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: *** &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;samples/bpf/bpf_load.o&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Error &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Makefile:1823: recipe &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; target &lt;span class=&#34;s1&#34;&gt;&amp;#39;samples/bpf/&amp;#39;&lt;/span&gt; failed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make: *** &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;samples/bpf/&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Error &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据错误信息，查看发生错误的文件为**./tools/perf/perf-sys.h**，报错的那一行是 test 开头的。通过 Google 发现了内核大佬们的邮件来往：&lt;a href=&#34;https://www.spinics.net/lists/netdev/msg608676.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.spinics.net/lists/netdev/msg608676.html&lt;/a&gt;。大佬们建议由于是测试相关的代码，所以可以 skip 掉。修改完的文件在&lt;a href=&#34;https://github.com/nevermosby/linux-bpf-learning/blob/master/bpf/perf-sys.h&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;，请斟酌参考。重新运行 make 命令，错误不再发生了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make samples/bpf/ &lt;span class=&#34;c1&#34;&gt;# and it works&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;编译运行自己的-bpf-程序&#34;&gt;编译运行自己的 BPF 程序&lt;/h2&gt;
&lt;p&gt;如果你想利用 Linux 内核环境来编译自己的 BPF 程序，是非常方便的。只要对&lt;code&gt;samples/bpf/&lt;/code&gt;目录下的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/a&gt;进行一点点自定义改造即可，如果你仔细阅读了上面的分析，那么改造的原理就显而易见了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 假设你自己BPF程序如下所示：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 内核空间代码：my_bpf_101_kern.c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 用户空间代码：my_bpf_101_user.c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 从上之下，添加新的代码行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 1. 追加新的一行至hostprogs-y开头的代码块最后，保证自己的BPF程序能够生成可执行文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; my_bpf_101
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 2. 一般BPF程序使用以下命令即可，具体取决于你的程序是否依赖其他特殊头文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;my_bpf_101-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; my_bpf_101_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 3. 追加新的一行至always开头的代码块最后，保证触发生成可执行文件的任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;always&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; my_bpf_101_kern.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一般的 BPF 程序只需要通过如上 3 处更新加入到 Makefile 中，就可以使用&lt;code&gt;make samples/bpf/&lt;/code&gt;命令，生成你自己程序的可执行文件了。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
