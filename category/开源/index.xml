<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开源 | 云原生社区（中国）</title>
    <link>https://cloudnative.to/category/%E5%BC%80%E6%BA%90/</link>
      <atom:link href="https://cloudnative.to/category/%E5%BC%80%E6%BA%90/index.xml" rel="self" type="application/rss+xml" />
    <description>开源</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Mon, 06 Mar 2023 12:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>开源</title>
      <link>https://cloudnative.to/category/%E5%BC%80%E6%BA%90/</link>
    </image>
    
    <item>
      <title>Google 开源 Service Weaver——构建和部署分布式应用程序框架</title>
      <link>https://cloudnative.to/blog/introducing-service-weaver-framework-for-writing-distributed-applications/</link>
      <pubDate>Mon, 06 Mar 2023 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/introducing-service-weaver-framework-for-writing-distributed-applications/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;编者按：近日 Google 开源了一个名为 Service Weaver 的开源框架，它可以帮助开发者构建和部署分布式应用程序。Service Weaver 的特点是，它允许开发者以模块化单体的方式编写应用程序，然后使用自定义部署器将其部署为一组微服务。这样，开发者可以在不改变代码的情况下，灵活地调整应用程序的架构和性能。&lt;a href=&#34;https://opensource.googleblog.com/2023/03/introducing-service-weaver-framework-for-writing-distributed-applications.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google 开源博客&lt;/a&gt;介绍了该项目，并给出了开源地址：https://github.com/ServiceWeaver/weaver&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Service Weaver 是一个用于构建和部署分布式应用程序的开源框架&lt;/strong&gt;。Service Weaver 允许您将应用程序编写为&lt;strong&gt;模块化单体&lt;/strong&gt;，并将其部署为一组微服务。&lt;/p&gt;
&lt;p&gt;更具体地说，Service Weaver 由两个核心部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一组编程库，可让您将应用程序编写为单个&lt;strong&gt;模块化&lt;/strong&gt;二进制文件，仅使用本机数据结构和方法调用，以及&lt;/li&gt;
&lt;li&gt;一组部署器，可让您配置应用程序的运行时拓扑并将其部署为一组微服务，可以在本地或在您选择的云上部署。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-service-weaver-编程库从开发到执行的流程图将标记为-a-到-d-的四个模块从跨微服务级别的应用程序移动到标记为-desktopgoogle-cloud-和其他云的部署程序&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Service Weaver 编程库从开发到执行的流程图，将标记为 A 到 D 的四个模块从跨微服务级别的应用程序移动到标记为 Desktop、Google Cloud 和其他云的部署程序&#34; srcset=&#34;
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/1_hu46a7297586c81fc6954e40274b0dcbe7_38036_55f361add14bf921fe6d63ac526e5402.webp 400w,
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/1_hu46a7297586c81fc6954e40274b0dcbe7_38036_05b8c1eb3e3983639a785c496f83e2a4.webp 760w,
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/1_hu46a7297586c81fc6954e40274b0dcbe7_38036_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/introducing-service-weaver-framework-for-writing-distributed-applications/1_hu46a7297586c81fc6954e40274b0dcbe7_38036_55f361add14bf921fe6d63ac526e5402.webp&#34;
               width=&#34;760&#34;
               height=&#34;380&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Service Weaver 编程库从开发到执行的流程图，将标记为 A 到 D 的四个模块从跨微服务级别的应用程序移动到标记为 Desktop、Google Cloud 和其他云的部署程序
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过将应用程序编写过程与运行时考虑因素（例如应用程序如何拆分为微服务、使用何种数据序列化格式以及如何发现服务）分离，Service Weaver 旨在提高分布式应用程序开发速度和性能。&lt;/p&gt;
&lt;h3 id=&#34;构建-service-weaver-的动机&#34;&gt;构建 Service Weaver 的动机&lt;/h3&gt;
&lt;p&gt;在编写基于微服务的应用程序时，我们发现维护多个不同的微服务二进制文件（具有它们自己的配置文件、网络端点和可序列化数据格式）的开销大大降低了我们的开发速度。&lt;/p&gt;
&lt;p&gt;更重要的是，&lt;strong&gt;微服务严重影响我们进行跨二进制更改的能力&lt;/strong&gt;。 使得我们不得不做一些事情，比如在每个二进制文件中标记新功能，仔细地改进我们的数据格式，并深入了解我们的上线过程。 最后，拥有预定数量的特定微服务会有效地冻结我们的 API； 它们变得如此难以更改，以至于将我们所有的更改都压缩到现有的 API 中而不是改进它们。&lt;/p&gt;
&lt;p&gt;因此，我们希望我们有一个单一的整体二进制文件来使用。 单体二进制文件易于编写：它们仅使用语言原生类型和方法调用。 它们也很容易更新：只需编辑源代码并重新部署。 它们很容易在本地或虚拟机中运行：只需执行二进制文件即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service Weaver 是一个提供两全其美的框架：单体应用程序的开发速度，以及微服务的可扩展性、安全性和容错性。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;服务编织器概述&#34;&gt;服务编织器概述&lt;/h2&gt;
&lt;p&gt;Service Weaver 的核心思想是它的&lt;strong&gt;模块化单体&lt;/strong&gt;模型。 您编写单个二进制文件，仅使用语言的原生数据结构和方法调用。 您将二进制文件组织成一组称为组件的模块，它们是您的编程语言中的原生类型。 例如，这是一个使用 Service Weaver 用 Go 语言编写的简单应用程序。 它由一个 main() 函数和一个 Adder 组件组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Adder&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;adder&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;weaver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Implements&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Background&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;weaver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;weaver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行上述应用程序时，您可以进行简单的配置选择，即是将 Adder 组件放置在 main() 函数中还是单独放置。 当 Adder 组件分离时，Service Weaver 框架自动将 Add 调用翻译成跨机 RPC； 否则，Add 调用仍然是本地方法调用。&lt;/p&gt;
&lt;p&gt;要更改上述应用程序，例如向 Add 方法添加无限数量的参数，您所要做的就是更改 Add 的签名，更改其调用站点，然后重新部署您的应用程序。 Service Weaver 确保新版本的 main() 只与新版本的 Adder 通信，无论它们是否位于同一位置。 这种行为与使用语言原生数据结构和方法调用相结合，使您可以专注于编写应用程序逻辑，而不必担心部署拓扑和服务间通信（例如，代码中没有原型、存根或 RPC 通道）。&lt;/p&gt;
&lt;p&gt;当需要运行您的应用程序时，Service Weaver 允许您在任何地方运行它——在您的本地桌面环境或本地机器机架上，或在云中——而无需对您的应用程序代码进行任何更改。 这种级别的可移植性是通过将关注点明确分离到 Service Weaver 框架中来实现的。 一方面，我们有应用程序开发的编程框架。 另一方面，我们有各种 &lt;strong&gt;deployer&lt;/strong&gt; 实现，每个部署环境一个。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-描述一次迭代中跨三个独立平台的-service-weaver-libraries-部署程序实施的流程图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;描述一次迭代中跨三个独立平台的 Service Weaver Libraries 部署程序实施的流程图&#34; srcset=&#34;
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/2_hud5c231be01a374c4c9980a37c37e22da_36441_174d04a3c7f8a6747261b91089906151.webp 400w,
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/2_hud5c231be01a374c4c9980a37c37e22da_36441_2ddf822cb01bbf537b7cefe8acd2b012.webp 760w,
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/2_hud5c231be01a374c4c9980a37c37e22da_36441_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/introducing-service-weaver-framework-for-writing-distributed-applications/2_hud5c231be01a374c4c9980a37c37e22da_36441_174d04a3c7f8a6747261b91089906151.webp&#34;
               width=&#34;732&#34;
               height=&#34;265&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      描述一次迭代中跨三个独立平台的 Service Weaver Libraries 部署程序实施的流程图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种关注点分离允许您通过 go run 在单个进程中本地运行您的应用程序。 或者通过 weaver gke deploy 在谷歌云上运行它； 或者在其他平台上启用并运行它。 在所有这些情况下，您无需修改或重新编译您的应用程序即可获得相同的应用程序行为。&lt;/p&gt;
&lt;h2 id=&#34;service-weaver-v01-中有什么&#34;&gt;Service Weaver v0.1 中有什么？&lt;/h2&gt;
&lt;p&gt;Service Weaver 的 v0.1 版本包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于编写应用程序的 核心&lt;a href=&#34;https://github.com/ServiceWeaver/weaver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go 库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;许多用于在&lt;a href=&#34;https://github.com/ServiceWeaver/weaver/tree/main/cmd/weaver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;本地&lt;/a&gt;或&lt;a href=&#34;https://github.com/ServiceWeaver/weaver-gke&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GKE 上&lt;/a&gt;运行您的应用程序的部署程序&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ServiceWeaver/weaver/tree/main/runtime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一组 API&lt;/a&gt;，允许您为任何其他平台编写自己的部署程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有库都是在 Apache 2.0 许可下发布的。请注意，在发布 v1.0 版之前， &lt;strong&gt;我们可能会引入重大更改&lt;/strong&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>开源评估框架</title>
      <link>https://cloudnative.to/blog/a-framework-for-open-source-evaluation/</link>
      <pubDate>Sun, 08 Aug 2021 17:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/a-framework-for-open-source-evaluation/</guid>
      <description>&lt;p&gt;本文翻译自 Bilgin Ibryam  的文章 &lt;a href=&#34;https://monetize.substack.com/p/a-framework-for-open-source-evaluation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A Framework for Open Source Evaluation&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如今，真&lt;a href=&#34;https://www.linuxjournal.com/content/open-vs-fauxpen&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;假&lt;/a&gt;开源无处不在。最近开源项目转为闭源的案例越来越多，同时也有不少闭源项目（按照 &lt;a href=&#34;https://opensource.org/osd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OSI 定义&lt;/a&gt;）像开源一样构建社区的例子。这怎么可能，开源项目不应该始终如此吗？&lt;/p&gt;
&lt;p&gt;开源不是非黑即白，它具有开放性、透明、协作性和信任性的多个&lt;a href=&#34;https://monetize.substack.com/p/a-holistic-vision-of-open-source&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;维度&lt;/a&gt;。有些开源是 Github 上的任何项目，有些必须通过 OSI 定义，有些是必须遵守不成文但普遍接受的开源规范。这里通过看一些商业和技术方面，再讨论社区管理习惯，来同大家分享一下我对评估开源项目的看法。&lt;/p&gt;
&lt;h2 id=&#34;免责声明&#34;&gt;免责声明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这些是我的个人观点，与我的雇主或我所属的软件基金会和项目无关。&lt;/li&gt;
&lt;li&gt;这不是法律或专业意见（我不是律师，也不是专门从事 OSS 评估的），而是外行的意见。
更新：我收到了多位开源律师的反馈并更新了文章！&lt;/li&gt;
&lt;li&gt;这篇博文由&lt;a href=&#34;https://monetize.substack.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;订阅&lt;/a&gt;和&lt;a href=&#34;https://twitter.com/bibryam/status/1371045284751507463&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;分享&lt;/a&gt;按钮赞助，点击这些按钮表示支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;知识产权&#34;&gt;知识产权&lt;/h2&gt;
&lt;p&gt;关于“开源”项目的第一个问题是关于知识产权的所有权。好消息是，即使不了解这些法律含义，你可以应用一个简单的 Litmus 测试。该项目是否属于你信任的信誉良好的开源基金会？例如，&lt;a href=&#34;https://www.fsf.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FSF&lt;/a&gt; 拥有其托管项目的版权，更多情况下拥有基金会（如 &lt;a href=&#34;https://www.apache.org/foundation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ASF&lt;/a&gt;、&lt;a href=&#34;https://www.linuxfoundation.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LF&lt;/a&gt;) 通过贡献者许可协议，聚合对其项目的贡献许可权。在任何一种情况下，你都可以相信他们将充当良好的去中心化管家，并且不会在一夜之间改变项目的未来方向。如果一个项目不属于信誉良好的软件基金会，而是由一家公司提供支持，那么问题是你是否信任该公司作为供应链合作伙伴。如果这些问题的答案是肯定的，请转到下一部分。如果答案是否定的，那么你最好调查一下版权所有者是谁，以及他们对你的长期前景和潜在风险是什么。今天的单一供应商开源项目，明天可能会变成闭源。&lt;/p&gt;
&lt;h2 id=&#34;许可&#34;&gt;许可&lt;/h2&gt;
&lt;p&gt;商标出现在许可之前的原因是软件的权利人（通常是作者）通过许可授予最终用户使用一个或多个软件副本的许可。自由软件许可证是一种说明，它授予源代码或其二进制形式的使用者修改和重新分发该软件的权利。如果没有许可，这些行为将受到版权法的禁止。这里的重点是权利人可以改变主意并更改许可。权利持有人可以决定在多个许可证下分发软件或随时将许可证更改为非开源许可证。该软件也可能在&lt;a href=&#34;https://opensource.org/node/878&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公共领域&lt;/a&gt;，在这种情况下，它不受版权法的限制。公共领域并不等同于开源许可证，这是一种不太流行的方法，我们可以在这里忽略。&lt;/p&gt;
&lt;p&gt;同样，如果不是律师，这是一个外行对许可的 Litmus 测试：该项目是否根据 OSI 批准的&lt;a href=&#34;https://opensource.org/licenses/alphabetical&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;许可清单&lt;/a&gt;获得的许可？如果答案是肯定的，那么你可以依靠这些基金会的尽职调查来审查、分类许可并指出任何限制。如果答案是否定的，请让你公司的律师来查看和解释许可上的每个字以及可能的许可兼容性影响。&lt;/p&gt;
&lt;h2 id=&#34;治理&#34;&gt;治理&lt;/h2&gt;
&lt;p&gt;在余下的检查中，我们正在从更多的商业和法律方面转向涉及开源项目领域的技术和社区。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-开源评估框架&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.substack.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F7f06c148-d675-4bb7-803e-b3704f0016ef_3309x2473.png&#34; alt=&#34;开源评估框架&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      开源评估框架
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;假设不担心商标持有方（未来的合作伙伴）、许可（使用开源软件的条款），下一个问题是治理。&lt;a href=&#34;https://www.oasis-open.org/policies-guidelines/open-projects-process/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;治理&lt;/a&gt;是项目决定谁来做什么、他们应该如何做以及何时做的规则或习惯。它定义了与不同项目角色相关的职责、特权和权限，以及人们如何分配到角色和从角色中删除。此处的示例是小型日常活动，例如谁有权批准拉取请求、投票给候选发布、就项目架构达成共识、定义项目路线图以及选举项目治理委员会。&lt;/p&gt;
&lt;p&gt;如果你正在评估对你的组织具有战略意义的项目，你想知道谁负责。不仅如此，你甚至可能&lt;a href=&#34;https://hackernoon.com/reciprocity-in-open-source-e60fb98ee1cc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;希望&lt;/a&gt;你的开发人员对项目的方向有发言权。&lt;/p&gt;
&lt;p&gt;还有一个简单的 Litmus 测试：对于开源基金会的项目，对于谁可以对重要决策进行投票，以及如何成为决策委员会的一部分，都有明确的规则。在某些基金会（例如 ASF）中，它基于社区成员的个人功绩，而在某些基金会（例如&lt;a href=&#34;https://www.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; CNCF &lt;/a&gt;）中，它从成为付费成员组织的员工开始。在基于区块链的开源项目中，它是基于&lt;a href=&#34;https://bit.ly/devprtcl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;令牌（Token）&lt;/a&gt;的投票持有人。其他基金会有不同的规则，但都力求在多个参与者之间实现中立和权力下放。如果一个项目由一家公司或一个人管理，你相信他们会为项目和社区的利益做出最佳决策。其中一些项目可能已经写下了他们遵循的治理规则，而有些可能根本没有。由你来确定治理动态及其对你的项目参与的重要性。除了具有治理透明度和公开决策之外，另一个方面是治理机构的信任度和声誉。当你查看项目的治理委员会时，是否有一位或一组具有经过验证的技术和社交技能的领导者，让你相信他们可以将项目提升到一个新的水平？或者你是否看到一个在政治斗争中不断争论的团体？这些是开源项目是否会成功并长期发展的一些指标，还是可以预期的头痛和停滞。&lt;/p&gt;
&lt;h2 id=&#34;基础设施&#34;&gt;基础设施&lt;/h2&gt;
&lt;p&gt;拥有开源许可可能在技术上有资格作为开源项目，但这并不能说明项目是否以开源方式构建。有许多在 OSI 批准的许可下发布的软件示例，但它们是在封闭的基础设施之后开发的。通过基础设施，我的意思是用户快速提问的聊天频道。进行更深入的开发人员讨论的论坛和邮件列表。审查拉取请求的源代码管理系统，以及运行测试和每晚创建二进制文件的构建服务器。&lt;/p&gt;
&lt;p&gt;对于关注开源项目的商务人士和律师来说，这些可能并不重要，但对于将要使用开源项目的技术人员来说，这些是一些假设的好处。这里要做的检查是探索软件是否是使用开放式基础设施以开源方式开发的，而不是闭门造车。以下是几个示例问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户可以在项目聊天中提出问题并在没有中间人的情况下从另一个用户那里得到答案吗？&lt;/li&gt;
&lt;li&gt;开发人员能否与项目提交者联系并获得深入的技术问题的答案？&lt;/li&gt;
&lt;li&gt;你能否运行最新版本并确认已知的错误已修复？&lt;/li&gt;
&lt;li&gt;架构师可以参加每周一次的社区电话会议并确定项目的未来方向吗？（原文 Can an architect the weekly community call and figure out the future direction of the project? ）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于封闭的基础架构，你必须创建支持工单并付费才能获得类似问题的答案。通过开放的基础设施和开放的参与，那些知道如何以开源方式工作的人可以获得答案。&lt;/p&gt;
&lt;h2 id=&#34;社区和采用&#34;&gt;社区和采用&lt;/h2&gt;
&lt;p&gt;开源软件的主要好处之一是它允许好创意的发展和传播。你可能拥有最先进的技术、最宽松的许可和开放式开发，但如果该软件没有不断壮大的社区和不断提高的采用率，那就是一个值得调查的迹象。不同的项目会有不同的采用率。有些可能会迅速成长为主流或被其他同类型项目所取代。一些项目可能有一个小但持续的增长率和一个持续数十年的生态社区。社区规模和采用率是开源项目的最终寿命指标。以下是你可以提出的一些示例问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目中有多少活跃的开发人员（提交者），平均提交率是多少？&lt;/li&gt;
&lt;li&gt;上个月有多少用户订阅了用户论坛以及提出了多少问题？&lt;/li&gt;
&lt;li&gt;软件的最新稳定版本已被下载多少次？&lt;/li&gt;
&lt;li&gt;还有哪些项目和服务&lt;a href=&#34;https://libraries.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;依赖&lt;/a&gt;并使用这个项目？&lt;/li&gt;
&lt;li&gt;有多少商业组织支持这个项目？&lt;/li&gt;
&lt;li&gt;是否有商业组织围绕它提供产品、支持和服务？&lt;/li&gt;
&lt;li&gt;这个项目有多少 StackOverflow 问题？&lt;/li&gt;
&lt;li&gt;有多少书籍、会议演讲和职位描述提到了这个项目？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行这些问题会给你一个指示，即该项目是在增长并成为其领域的事实上的标准，还是停滞不前并可能被下一个大项目所取代。&lt;/p&gt;
&lt;p&gt;通常，开源与快节奏的开发和创新有关。同时，开源也是一种创建广泛采用和创建非官方标准的机制。许多开源项目已经变成了标准，例如用于容器编排的 Kubernetes、用于流处理的 Apache Kafka、用于 Web 服务器的 Apache httpd 等。软件中最昂贵的事情之一是找到具有合适技能的人。使用采用率高的开源项目将使你有更好的机会找到技术娴熟的人，并让他们能够更长时间地重复使用他们的技能。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;根据开源项目的关键程度，有不同的风险和评估标准。对于战略性的、难以替代的项目，这将是你的 IT 基础设施的基础，你需要是已经成为其领域事实上的开源标准的完善项目。在这里确定谁拥有该项目的商标以及谁将成为你的长期合作伙伴非常重要。通常，这些合作伙伴是项目所属软件基金会的成员组织或持有项目 IP 的单个公司。对于后者，你可能需要考虑长期风险，例如核心开发人员分叉项目的机会、提供项目即服务的超大规模者、公司收购等。&lt;/p&gt;
&lt;p&gt;对于交付速度最重要的非战略性、战术性、短期项目，你可以让你的开发人员根据开放性、社区协作和热度（对于某些前端技术很重要）来推动选择和挑选项目。在这里，定期的安全修复、开发人员支持和许可兼容性检查等中短期风险可能就足够了。&lt;/p&gt;
&lt;p&gt;在任何一种情况下，都没有适合所有情况的单一评估标准。你必须在长期商业风险、技术稳定性与最新热度、创新和开发人员满意度之间取得平衡。这里的框架将为你概括需要探索的领域和需要考虑的一些风险。祝你好运！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
