<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开源 | 云原生社区（中国）</title>
    <link>https://cloudnative.to/category/%E5%BC%80%E6%BA%90/</link>
      <atom:link href="https://cloudnative.to/category/%E5%BC%80%E6%BA%90/index.xml" rel="self" type="application/rss+xml" />
    <description>开源</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 19 Sep 2023 11:03:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>开源</title>
      <link>https://cloudnative.to/category/%E5%BC%80%E6%BA%90/</link>
    </image>
    
    <item>
      <title>Kubernetes 配置语言 KCL 正式成为 CNCF 沙盒项目</title>
      <link>https://cloudnative.to/blog/kcl-joining-cncf-sandbox/</link>
      <pubDate>Tue, 19 Sep 2023 11:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/kcl-joining-cncf-sandbox/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./kcl-joining-cncf-sandbox.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2023 年 9 月 12 日，KCL 项目通过了全球顶级开源基金会云原生计算基金会（CNCF）技术监督委员会评定，正式成为 CNCF 沙箱项目。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这意味着 KCL 得到了云原生开源社区的认可，保障了项目的中立性，有利于开发者、合作伙伴等共同参与项目建设，协作共赢，并为云原生应用交付带来动态配置管理和自动化能力迈出了重要一步！&lt;/p&gt;
&lt;!--TODO: CNCF Sandbox Review 通过的邮件截图--&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;项目地址：&lt;a href=&#34;https://github.com/kcl-lang/kcl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/kcl-lang/kcl&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;项目官网：&lt;a href=&#34;https://kcl-lang.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kcl-lang.io&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过进入 CNCF 沙箱，KCL 社区将更多吸引更多开发者和用户参与共建，进一步推动项目在云原生业务场景的成熟应用，此外加入 CNCF 将为 KCL 提供一个增强的协作和创新平台。它提供了与处于云原生技术前沿的多元化开发者、组织和行业专家社区进行交流的机会。我们期待与其他 CNCF 项目进行更多合作，贡献我们的技术专业知识，并探索更多 CNCF 项目集成的可能性。&lt;/p&gt;
&lt;h2 id=&#34;什么是-cncf&#34;&gt;什么是 CNCF？&lt;/h2&gt;
&lt;p&gt;CNCF，全称 Cloud Native Computing Foundation（云原生计算基金会），是 Linux 基金会旗下的子基金会。CNCF 致力于为云原生软件构建可持续生态系统，涉及领域包括存储、计算、编排、调度、CI/CD、DevOps、服务治理、服务网关等。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Kubernetes 便是 CNCF 最具代表性的项目之一&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&#34;什么是-cncf-sandbox-沙盒项目&#34;&gt;什么是 CNCF Sandbox 沙盒项目？&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./cncf-sandbox-logo.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;CNCF 社区将项目分为沙箱项目（Sandbox）、孵化项目（Incubating）、毕业项目（Graduated）。著名的毕业项目有：Kubernetes、Prometheus、Istio、ETCD、Containerd、ArgoCD 和 Helm 等。完整的毕业和孵化项目列表查看地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cncf.io/projects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/projects/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sandbox 是 CNCF 创建的，旨在为开源项目提供一个有益的、中立的家园，以促进开源项目的合作与开发。入选沙箱的项目，是被 CNCF TOC 认可的，并值得进行实验和开发的潜力项目。&lt;/p&gt;
&lt;p&gt;Sandbox 对应的是 CNCF 社区早期项目，列表为：&lt;a href=&#34;https://www.cncf.io/sandbox-projects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/sandbox-projects/&lt;/a&gt;。进入 Sandbox 需要 66% 以上的 TOC（技术委员会）成员赞成，即全部 11 人 &lt;a href=&#34;https://github.com/cncf/toc#members&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/cncf/toc#members&lt;/a&gt; 中的 8 人投赞成票。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kcl&#34;&gt;什么是 KCL&lt;/h2&gt;
&lt;p&gt;KCL 是一个开源的基于约束的记录及函数语言，期望通过成熟的编程语言技术和实践来改进对大量繁杂配置比如云原生 Kubernetes 配置场景的编写，致力于围绕配置的模块化、扩展性和稳定性，打造更简单的逻辑编写体验，构建更简单的自动化和生态集成路径。&lt;/p&gt;
&lt;p&gt;项目主要里程碑如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2022 年 5 月，KCL 由蚂蚁集团发起，正式开源&lt;/li&gt;
&lt;li&gt;2023 年 6 月，KCL 正式成为 CNCF Landscape 项目&lt;/li&gt;
&lt;li&gt;2023 年 9 月，KCL 由 CNCF 应用交付 TAG 进行审核并通过 TOC 投票，顺利成为 CNCF Sandbox 项目 - &lt;a href=&#34;https://github.com/cncf/sandbox/issues/48&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/cncf/sandbox/issues/48&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;为什么需要-kcl&#34;&gt;为什么需要 KCL&lt;/h2&gt;
&lt;p&gt;正如记录音乐有五线谱，存储时间序列数据有时序数据库一样，在云原生配置和自动化的特定问题域内，我们使用专用配置和策略语言用于编写和管理规模化复杂配置及策略。不同于混合编写范式、混合工程能力的高级通用语言，专用语言的核心逻辑是以收敛的有限的语法、语义集合解决领域问题近乎无限的变化和复杂性，将复杂配置和策略编写思路和方式沉淀到语言特性中。&lt;/p&gt;
&lt;p&gt;此外，KCL 期望通过更现代化的声明式配置语言和工具，在轻量级客户端云原生动态配置领域填补配置语言及工具的空白并解决如下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;维度爆炸&lt;/strong&gt;: 大多数静态配置如云原生领域的 Kubernetes YAML 配置需要为每个环境单独进行配置；在最糟糕的情况下，它可能引入涉及环境交叉链接的难以调试的错误，稳定性和扩展性都较差。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置漂移&lt;/strong&gt;: 对于不同环境的静态管理应用程序和基础设施配置的方式，往往没有标准的方式去管理这些动态的不同环境的配置，采用非标准化的方法比如脚本和胶水代码的拼盘，会导致复杂度呈指数增长，并导致配置漂移。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;认知负担&lt;/strong&gt;: Kubernetes 等作为构建平台的平台技术手段在底层统一基础架构细节方面出色，但是缺乏更上层的应用软件交付抽象，对于普通开发者认知负担较高，影响了更上层应用开发者的软件交付体验。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对如上问题，KCL 期望提供如下能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;strong&gt;代码抽象&lt;/strong&gt;等手段屏蔽基础设施和平台的细节和复杂性，降低研发者&lt;strong&gt;认知负担&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编辑&lt;/strong&gt;和&lt;strong&gt;校验&lt;/strong&gt;已有的存量配置或模版，直接解决云原生小配置场景问题如 Helm Chart 配置硬编码问题，但远不止如此&lt;/li&gt;
&lt;li&gt;通过配置语言无副作用地&lt;strong&gt;管理跨团队的大规模配置数据&lt;/strong&gt;，提升团队协作效率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体来说，KCL 可以&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在代码层面提升&lt;strong&gt;配置语义验证&lt;/strong&gt;的能力，比如 Schema 定义、字段可选/必选、类型、范围等配置检查校验能力&lt;/li&gt;
&lt;li&gt;提供&lt;strong&gt;配置分块编写、组合和抽象&lt;/strong&gt;的能力，比如结构定义、结构继承、约束定义和配置策略合并等能力&lt;/li&gt;
&lt;li&gt;用&lt;strong&gt;现代编程语言&lt;/strong&gt;的方式以&lt;strong&gt;编写代码&lt;/strong&gt;的方式提升配置的灵活度，比如条件语句、循环、函数、包管理等特性提升配置重用的能力&lt;/li&gt;
&lt;li&gt;提供&lt;strong&gt;完备的工具链支持&lt;/strong&gt;，丰富的 IDE 插件、语言和生态工具链支持用以降低上手门槛，提升使用体验&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;包管理工具&lt;/strong&gt; 和 &lt;strong&gt;OCI 注册表&lt;/strong&gt;使得配置以更简单的方式在不同团队/角色之间分享，传播和交付&lt;/li&gt;
&lt;li&gt;提供&lt;strong&gt;高性能&lt;/strong&gt;的编译器满足规模化配置场景诉求，比如满足由一份基线配置根据部署上下文生成不同环境不同拓扑的配置的渲染性能以及配置自动化修改性能诉求&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;多语言 SDK，KCL 语言插件&lt;/strong&gt;等手段提升其自动化集成能力，在发挥配置及策略编写价值的同时显著降低 KCL 的学习成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了语言自身，KCL 还提供了许多额外的工具如格式化，测试、文档等工具帮助您使用、理解和检查编写的配置或策略；通过 VS Code 等 IDE 插件，包管理工具和 Playground 降低配置编写和分享的成本；通过 Rust, Go, 和 Python 多语言 SDK 自动化地管理和执行配置。&lt;/p&gt;
&lt;h2 id=&#34;kcl-能做什么&#34;&gt;KCL 能做什么&lt;/h2&gt;
&lt;h3 id=&#34;动态配置管理&#34;&gt;动态配置管理&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./standalone-kcl-form.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;作为一种配置语言，KCL 为应用程序和平台开发人员/SRE 提供的最重要的功能是动态配置管理。通过代码抽象，我们可以构建以应用为中心的模型屏蔽复杂的基础设施和平台概念，为开发人员提供一个以应用程序为中心且易于理解的界面。此外，KCL 还允许平台人员快速扩展和定义自己的模型，并且这些模型可以通过 OCI 注册表进行分享和复用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./krm-kcl-form.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，KCL 还支持与 Kubernetes Resource Model (KRM) 规范直接集成，KRM KCL 是一个通用的配置模型规范，用于描述和管理各种云原生资源，如容器、Pod、服务的配置操作和抽象等。KRM KCL 规范提供了一种统一的方式来定义和管理这些资源，使得它们可以在不同的环境中进行移植和复用。它建立在一个完全开放的 Kubernetes 世界当中，几乎不与任何编排/引擎工具或者 Kubernetes 控制器绑定，它在关注点分离的基础上允许平台人员扩展自己的抽象，配置编辑和验证逻辑，并提供一个开发者友好的配置管理界面。&lt;/p&gt;
&lt;h3 id=&#34;gitops-集成&#34;&gt;GitOps 集成&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./gitops.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;无论是使用独立的 KCL 还是 KRM KCL 配置形式，我们都支持 KCL 与各种以及 CI/CD 和 GitOps 工具的集成，KCL 允许开发人员以声明式的方式定义应用程序所需的资源，通过将 KCL 和 GitOps 工具相结合可以帮助我们更好地实现基础设施即代码（IaC），提高部署效率，简化应用程序的配置管理。&lt;/p&gt;
&lt;p&gt;使用 GitOps，开发人员和运维团队可以通过分别修改应用和配置代码来管理应用程序的部署，GitOps 工具链可以基于 KCL 的自动化能力实现对配置的自动更改，从而实现持续部署并确保一致性。如果出现问题，可以使用 GitOps 工具链快速回滚。&lt;/p&gt;
&lt;h2 id=&#34;生态集成&#34;&gt;生态集成&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./integration.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了与 ArgoCD 等 GitOps 自动化工具进行集成，作为 CNCF 的项目，KCL 还与 CNCF 其他众多生态项目进行了集成，比如为现有的 CNCF 生态配置管理工具项目如 Helm、Kustomize、kpt 等提供 KCL 插件，在运行时提供 KCL Kubernetes Operator，以满足不同场景的配置管理需求等。此外我们还提供如下集成支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多语言支持&lt;/strong&gt;：我们提供了多语言 SDK，帮助用户以不同的语言操作 KCL，并将其集成到自己的应用程序中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;包管理支持&lt;/strong&gt;：我们提供了 KPM 包管理工具可以将 KCL 配置通过 docker hub, GitHub 容器注册表进行分发和复用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Schema 迁移支持&lt;/strong&gt;：我们支持其他生态系统的 Schema 一键迁移到 KCL Schema，如 Go/Rust 结构定义、JsonSchema、Protobuf、OpenAPI、Terraform Provider Schema 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;落地实践&#34;&gt;落地实践&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./practice-krm-kcl.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先，KCL 作为云原生领域内的一个小语言，它可以直接被用于解决场景中简单的小问题，如通过 KCL 模型直接为 Kubernetes 资源注入环境变量等配置而不是编写脚本，通过 KCL 模型和 Helm KCL 插件无侵入处理 Helm Chart 的硬编码配置而不是 Fork Helm Chart 直接修改等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./practice-konfig-gitops.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其次，KCL 也可以被用于企业内部与各种 CI/CD 和应用配置交付引擎比如 &lt;a href=&#34;https://kusionstack.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KusionStack&lt;/a&gt; 等相配合，实现关注点分离、以应用为中心的可编程模型界面和 GitOps 流程，以简化当今混合多云环境中规模化应用的部署和运维操作，提升发布运维效率和开发者体验。&lt;/p&gt;
&lt;p&gt;当然，KCL 能够解决的问题和实践的场景远不止如此，我们会陆续分享社区中采用者的最佳实践，也欢迎大家加入我们的社区进行进一步交流和讨论 ❤️。&lt;a href=&#34;https://github.com/kcl-lang/community&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/kcl-lang/community&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;社区动态&#34;&gt;社区动态&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./community.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 KCL 开源短短的这一年里，我们发布了许多版本，并与全世界许多贡献者和维护者合作构建了 KCL 社区，并得到了一些采用者比如有赞和华为等公司的认可，通过加入 CNCF，我们的目标是提高项目的知名度并促进社区采用和参与，因为强大且知名的基金会组织对于推动语言生态系统的发展至关重要。&lt;/p&gt;
&lt;p&gt;此外，我们在开源社区收获了来自全世界包括中国、北美、欧洲和澳大利亚各地小伙伴的认可，感谢一路陪伴 KCL 走来的各位用户和社区研发者，同时也欢迎更多的小伙伴加入到我们的社区一起共建 ❤️&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;对 KCL 来说，加入 CNCF 并不代表成功，它意味着一个新的开始，我们将和社区的小伙伴们一起努力打造更好的 KCL 语言、工具链和 IDE 体验！最后，也欢迎大家加入我们的社区进行交流和贡献 👏👏👏&lt;/p&gt;
&lt;h2 id=&#34;其他资源&#34;&gt;其他资源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;KCL 网站：https://kcl-lang.io/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KusionStack 网站：https://kusionstack.io/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KCL 社区：https://github.com/kcl-lang/community&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KCL 2023 路线规划：https://kcl-lang.io/docs/community/release-policy/roadmap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KCL GitHub Issues: &lt;a href=&#34;https://github.com/kcl-lang/kcl/issues&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/kcl-lang/kcl/issues&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KCL GitHub Discussion: &lt;a href=&#34;https://github.com/orgs/kcl-lang/discussions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/orgs/kcl-lang/discussions&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Google 开源 Service Weaver——构建和部署分布式应用程序框架</title>
      <link>https://cloudnative.to/blog/introducing-service-weaver-framework-for-writing-distributed-applications/</link>
      <pubDate>Mon, 06 Mar 2023 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/introducing-service-weaver-framework-for-writing-distributed-applications/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;编者按：近日 Google 开源了一个名为 Service Weaver 的开源框架，它可以帮助开发者构建和部署分布式应用程序。Service Weaver 的特点是，它允许开发者以模块化单体的方式编写应用程序，然后使用自定义部署器将其部署为一组微服务。这样，开发者可以在不改变代码的情况下，灵活地调整应用程序的架构和性能。&lt;a href=&#34;https://opensource.googleblog.com/2023/03/introducing-service-weaver-framework-for-writing-distributed-applications.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google 开源博客&lt;/a&gt;介绍了该项目，并给出了开源地址：https://github.com/ServiceWeaver/weaver&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Service Weaver 是一个用于构建和部署分布式应用程序的开源框架&lt;/strong&gt;。Service Weaver 允许您将应用程序编写为&lt;strong&gt;模块化单体&lt;/strong&gt;，并将其部署为一组微服务。&lt;/p&gt;
&lt;p&gt;更具体地说，Service Weaver 由两个核心部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一组编程库，可让您将应用程序编写为单个&lt;strong&gt;模块化&lt;/strong&gt;二进制文件，仅使用本机数据结构和方法调用，以及&lt;/li&gt;
&lt;li&gt;一组部署器，可让您配置应用程序的运行时拓扑并将其部署为一组微服务，可以在本地或在您选择的云上部署。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-service-weaver-编程库从开发到执行的流程图将标记为-a-到-d-的四个模块从跨微服务级别的应用程序移动到标记为-desktopgoogle-cloud-和其他云的部署程序&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Service Weaver 编程库从开发到执行的流程图，将标记为 A 到 D 的四个模块从跨微服务级别的应用程序移动到标记为 Desktop、Google Cloud 和其他云的部署程序&#34; srcset=&#34;
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/1_huf4882d3c7ca30bb9e8058102f31d9c40_37319_0992182b7d182f578649ce9d3b3aeb23.webp 400w,
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/1_huf4882d3c7ca30bb9e8058102f31d9c40_37319_d804be9d4aa26207eadf33792d09c41f.webp 760w,
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/1_huf4882d3c7ca30bb9e8058102f31d9c40_37319_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/introducing-service-weaver-framework-for-writing-distributed-applications/1_huf4882d3c7ca30bb9e8058102f31d9c40_37319_0992182b7d182f578649ce9d3b3aeb23.webp&#34;
               width=&#34;760&#34;
               height=&#34;380&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Service Weaver 编程库从开发到执行的流程图，将标记为 A 到 D 的四个模块从跨微服务级别的应用程序移动到标记为 Desktop、Google Cloud 和其他云的部署程序
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过将应用程序编写过程与运行时考虑因素（例如应用程序如何拆分为微服务、使用何种数据序列化格式以及如何发现服务）分离，Service Weaver 旨在提高分布式应用程序开发速度和性能。&lt;/p&gt;
&lt;h3 id=&#34;构建-service-weaver-的动机&#34;&gt;构建 Service Weaver 的动机&lt;/h3&gt;
&lt;p&gt;在编写基于微服务的应用程序时，我们发现维护多个不同的微服务二进制文件（具有它们自己的配置文件、网络端点和可序列化数据格式）的开销大大降低了我们的开发速度。&lt;/p&gt;
&lt;p&gt;更重要的是，&lt;strong&gt;微服务严重影响我们进行跨二进制更改的能力&lt;/strong&gt;。使得我们不得不做一些事情，比如在每个二进制文件中标记新功能，仔细地改进我们的数据格式，并深入了解我们的上线过程。最后，拥有预定数量的特定微服务会有效地冻结我们的 API；它们变得如此难以更改，以至于将我们所有的更改都压缩到现有的 API 中而不是改进它们。&lt;/p&gt;
&lt;p&gt;因此，我们希望我们有一个单一的整体二进制文件来使用。单体二进制文件易于编写：它们仅使用语言原生类型和方法调用。它们也很容易更新：只需编辑源代码并重新部署。它们很容易在本地或虚拟机中运行：只需执行二进制文件即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service Weaver 是一个提供两全其美的框架：单体应用程序的开发速度，以及微服务的可扩展性、安全性和容错性。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;服务编织器概述&#34;&gt;服务编织器概述&lt;/h2&gt;
&lt;p&gt;Service Weaver 的核心思想是它的&lt;strong&gt;模块化单体&lt;/strong&gt;模型。您编写单个二进制文件，仅使用语言的原生数据结构和方法调用。您将二进制文件组织成一组称为组件的模块，它们是您的编程语言中的原生类型。例如，这是一个使用 Service Weaver 用 Go 语言编写的简单应用程序。它由一个 main() 函数和一个 Adder 组件组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Adder&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;adder&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;weaver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Implements&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Background&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;weaver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;weaver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行上述应用程序时，您可以进行简单的配置选择，即是将 Adder 组件放置在 main() 函数中还是单独放置。当 Adder 组件分离时，Service Weaver 框架自动将 Add 调用翻译成跨机 RPC；否则，Add 调用仍然是本地方法调用。&lt;/p&gt;
&lt;p&gt;要更改上述应用程序，例如向 Add 方法添加无限数量的参数，您所要做的就是更改 Add 的签名，更改其调用站点，然后重新部署您的应用程序。Service Weaver 确保新版本的 main() 只与新版本的 Adder 通信，无论它们是否位于同一位置。这种行为与使用语言原生数据结构和方法调用相结合，使您可以专注于编写应用程序逻辑，而不必担心部署拓扑和服务间通信（例如，代码中没有原型、存根或 RPC 通道）。&lt;/p&gt;
&lt;p&gt;当需要运行您的应用程序时，Service Weaver 允许您在任何地方运行它——在您的本地桌面环境或本地机器机架上，或在云中——而无需对您的应用程序代码进行任何更改。这种级别的可移植性是通过将关注点明确分离到 Service Weaver 框架中来实现的。一方面，我们有应用程序开发的编程框架。另一方面，我们有各种 &lt;strong&gt;deployer&lt;/strong&gt; 实现，每个部署环境一个。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-描述一次迭代中跨三个独立平台的-service-weaver-libraries-部署程序实施的流程图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;描述一次迭代中跨三个独立平台的 Service Weaver Libraries 部署程序实施的流程图&#34; srcset=&#34;
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/2_hu8d2fad478d5447f760431eccae81a4ae_35718_20533cbed71db134f0a916f475d3b8b0.webp 400w,
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/2_hu8d2fad478d5447f760431eccae81a4ae_35718_0622f3103db18aa88d3009d08290b4c5.webp 760w,
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/2_hu8d2fad478d5447f760431eccae81a4ae_35718_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/introducing-service-weaver-framework-for-writing-distributed-applications/2_hu8d2fad478d5447f760431eccae81a4ae_35718_20533cbed71db134f0a916f475d3b8b0.webp&#34;
               width=&#34;732&#34;
               height=&#34;265&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      描述一次迭代中跨三个独立平台的 Service Weaver Libraries 部署程序实施的流程图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种关注点分离允许您通过 go run 在单个进程中本地运行您的应用程序。或者通过 weaver gke deploy 在谷歌云上运行它；或者在其他平台上启用并运行它。在所有这些情况下，您无需修改或重新编译您的应用程序即可获得相同的应用程序行为。&lt;/p&gt;
&lt;h2 id=&#34;service-weaver-v01-中有什么&#34;&gt;Service Weaver v0.1 中有什么？&lt;/h2&gt;
&lt;p&gt;Service Weaver 的 v0.1 版本包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于编写应用程序的 核心&lt;a href=&#34;https://github.com/ServiceWeaver/weaver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go 库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;许多用于在&lt;a href=&#34;https://github.com/ServiceWeaver/weaver/tree/main/cmd/weaver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;本地&lt;/a&gt;或&lt;a href=&#34;https://github.com/ServiceWeaver/weaver-gke&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GKE 上&lt;/a&gt;运行您的应用程序的部署程序&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ServiceWeaver/weaver/tree/main/runtime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一组 API&lt;/a&gt;，允许您为任何其他平台编写自己的部署程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有库都是在 Apache 2.0 许可下发布的。请注意，在发布 v1.0 版之前， &lt;strong&gt;我们可能会引入重大更改&lt;/strong&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>我不是供应商</title>
      <link>https://cloudnative.to/blog/not-a-supplier/</link>
      <pubDate>Mon, 20 Feb 2023 11:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/not-a-supplier/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;译者评论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文作者观点是：不应该将自由和开源软件（FOSS）置于你的软件供应链中，而是寻找他们的供应商，因为只有能够为软件负责任的供应商存在才能作为供应链的一环。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在过去的几年里，我们看到了很多围绕软件供应链概念的讨论。这些讨论始于 LeftPad 时代，并随着过去几年发生的各种事件而升级。这个领域所有工作的问题在于它忘记了一个基本点。&lt;/p&gt;
&lt;p&gt;在开始讨论这个基本点之前，我将定义供应链和一般供应商的含义，以及我们申请软件的原因。那么为什么将 FOSS（自由和开源软件）置于该定义之下的尝试被深深地误导了。&lt;/p&gt;
&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;p&gt;在过去的几十年里，我们看到了 FOSS 的兴起。特别是，这可以极大地增加打包为库的代码片段的重用。这要归功于围绕这个想法蓬勃发展的庞大的基础设施生态系统。今天，每一种编程语言环境中都有一个包管理器，中央存储库保存着查找库和处理它们的分发所需的元数据。&lt;/p&gt;
&lt;p&gt;这是可能的，因为 FOSS 许可证非常宽松，并且可以重复使用和重新混合这些库，否则会出现的大量法律和财务问题。一个现代软件项目可能有成百上千个这样的依赖项，从 OpenSSL 到测试框架或日期选择器，涵盖诸如 JSON 编码器/解码器库甚至它所部署的操作系统的 libc 之类的东西。&lt;/p&gt;
&lt;p&gt;这种依赖关系的生态系统，其中许多是可传递的（依赖关系的依赖关系），就是软件供应链模型所称的项目供应链。在这个模型中，我们将找到有助于管理它的工具，例如软件物料清单 (SBOM)，它应该包含一些关于这个项目使用了哪些库、在哪里可以找到它们、哪个版本、内容等的散列信息。&lt;/p&gt;
&lt;h2 id=&#34;什么是供应链&#34;&gt;什么是供应链？&lt;/h2&gt;
&lt;p&gt;供应链的想法当然不是空穴来风。在制造业中，供应链是生产特定工厂产品所需的供应商的长链。例如，如果您组装一辆汽车，您需要座椅、大量螺丝、电缆、电子产品、各种冲压金属板……您的电缆供应商需要铜、塑料、能源，可能还需要各种机床。可能需要制造其他机床、螺钉、螺栓、螺母和一些电子设备……我们可以继续玩这个“你需要什么来制造这辆车”的漫长游戏，直到你的图表看起来像一个巨大的意大利面球。&lt;/p&gt;
&lt;p&gt;然后德国一家不知名的小工厂里有人生病了，碰巧链条上有五层，每个层级都取决于他们的特定螺栓，都被我们搞砸了。这个问题的一个版本出现在为 Covid19 提供疫苗的早期，当时供应链专家意识到他们需要的玻璃瓶数量超过全世界一年的产量。&lt;/p&gt;
&lt;p&gt;为了避免在这个链条上五个层级上出现最终会停止其有价值的生产的障碍，制造公司花了数年时间在流程的每个层次上与供应商建立关系。这既是一种非常深厚的关系，但往往还不够，但不是每个复杂系统都如此吗？&lt;/p&gt;
&lt;h2 id=&#34;为什么要谈软件供应链&#34;&gt;为什么要谈软件供应链？&lt;/h2&gt;
&lt;p&gt;好吧，因为公司不断发现他们的产品存在大问题，而这些问题并非来自软件工程师编写的代码。问题可能来自库的所有者决定停止提供对它的访问（例如 Leftpad）并破坏了一半的互联网。&lt;/p&gt;
&lt;p&gt;或者它可能来自 OpenSSL 或 Log4J 等通用数字基础设施中使用的大型库，这些库中存在许多安全问题，使一半的互联网容易受到黑客攻击。&lt;/p&gt;
&lt;p&gt;或者有人可以与拥有库的人交谈，获得他们的信任，让拥有库的人相信他们是来帮忙的，获得访问权限并向其中添加加密货币挖矿代码以获取利润（很多时候我不知道从哪里开始）。&lt;/p&gt;
&lt;p&gt;或者代码的所有者不喜欢好战政权，所以他会添加代码来破坏在那些政权所在地使用其代码的计算机（是的，这种情况已经发生过）。&lt;/p&gt;
&lt;p&gt;然后，这些公司的每个人都发现他们的产品可以从他们不知道的代码中“远程操作”。于是出现了“软件供应链”的概念，定义了供应链中的人需要做的所有事情，这些库的所有者，为了不破坏下游公司使用的代码，做个好公民。&lt;/p&gt;
&lt;p&gt;这些规则管理诸如我们如何测试代码、我们如何保护有权访问它的人、我们如何发布版本、我们如何验证其安全性、我们如何组织代码工作、我们如何保护控制代码等等。&lt;/p&gt;
&lt;h2 id=&#34;我不是供应商&#34;&gt;我不是供应商&lt;/h2&gt;
&lt;p&gt;这里有个小问题。我们不是供应商。对于编写和维护这些项目的每个人来说，我们不是供应商。我们与这些组织中的任何一个都没有业务关系。我们是根据这些许可编写代码并在线发布的志愿者。是的，我们把它放在网上供人们使用。但我们没有从中得到任何东西。&lt;/p&gt;
&lt;p&gt;更糟糕的是，许多支撑我们所谓的数字经济结构的库都在努力筹集足够的钱来支付食物。关于这个话题，我强烈建议大家花时间阅读 &lt;a href=&#34;https://www.fordfoundation.org/work/learning/research-reports/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nadia Eghbal Road and Bridges&lt;/a&gt; 的报告，以了解问题的深度。它有点旧，因为它是在 HeartBleed 之后写的，但它在今天和当时一样重要。&lt;/p&gt;
&lt;p&gt;或者为了更有趣、更直观的解释，&lt;a href=&#34;https://xkcd.com/2347/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;XKCD 2347&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-xkcd-2347一堆块的图像标记为所有现代数字基础设施一个小块保持整个堆栈稳定标记为内布拉斯加州某个随机的人自-2003-年以来一直在不知疲倦地维护的项目&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;XKCD 2347，一堆块的图像，标记为“所有现代数字基础设施”，一个小块保持整个堆栈稳定，标记为“内布拉斯加州某个随机的人自 2003 年以来一直在不知疲倦地维护的项目。&#34; srcset=&#34;
               /blog/not-a-supplier/dependency_hu9aab65391edcc77b1b768625ad7c3f55_23987_1c678cef18dd13090011e30b7ebcf43a.webp 400w,
               /blog/not-a-supplier/dependency_hu9aab65391edcc77b1b768625ad7c3f55_23987_b251e1234759b9cb0de6c94f82fcd500.webp 760w,
               /blog/not-a-supplier/dependency_hu9aab65391edcc77b1b768625ad7c3f55_23987_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/not-a-supplier/dependency_hu9aab65391edcc77b1b768625ad7c3f55_23987_1c678cef18dd13090011e30b7ebcf43a.webp&#34;
               width=&#34;385&#34;
               height=&#34;489&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      XKCD 2347，一堆块的图像，标记为“所有现代数字基础设施”，一个小块保持整个堆栈稳定，标记为“内布拉斯加州某个随机的人自 2003 年以来一直在不知疲倦地维护的项目。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们知道。这就是为什么在这些许可中都管理着在这些库中在线发布的作品的重复使用规则，你会发现这一段是逐字复制的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本软件“按原样”提供，不提供任何明示或暗示的保证，包括但不限于适销性、特定用途适用性和非侵权保证。在任何情况下，作者或版权所有者均不对因软件或其使用或其他交易引起的或与之相关的任何索赔、损害或其他责任负责，无论是合同、侵权或其他方面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里有太多法律术语，但我可以很容易地总结出来。如果你用这个，我什么都不欠你。绝对不。我们无所谓。我把它放在网上的条件是，如果你使用它，你将完全自行承担风险。&lt;/p&gt;
&lt;p&gt;这意味着这里没有供应链。因为没有供应商。我不会把你从我这里买的东西送给你。没关系。我把东西放到网上是因为我想。你的产品依赖于它是你的责任。不是我的。不是提供者之一。我们提供图书馆。你不能对我套用这些规则。&lt;/p&gt;
&lt;p&gt;老实说，我不会接受它们。我几乎没有花时间在我维护的 FOSS 库上工作，而且这样做常常让做这件事的人筋疲力尽。&lt;/p&gt;
&lt;p&gt;现在，我很高兴成为供应商。你希望我以某种方式工作，我非常乐意这样做。但要做到这一点，我将不得不成为一名供应商。这意味着你将不得不开始付钱给我。价格公道，我们可以协商。在不同的许可证下。&lt;/p&gt;
&lt;p&gt;在那之前，我不是你的供应商。那么你所有的软件供应链想法？你不是从供应商那里购买，你是在垃圾箱中挖掘免费代码。所以我建议你把这些规则放在同一个箱子里。记住。我不是供应商。 &lt;strong&gt;因为本软件“按原样”提供。&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>开源评估框架</title>
      <link>https://cloudnative.to/blog/a-framework-for-open-source-evaluation/</link>
      <pubDate>Sun, 08 Aug 2021 17:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/a-framework-for-open-source-evaluation/</guid>
      <description>&lt;p&gt;本文翻译自 Bilgin Ibryam  的文章 &lt;a href=&#34;https://monetize.substack.com/p/a-framework-for-open-source-evaluation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A Framework for Open Source Evaluation&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如今，真&lt;a href=&#34;https://www.linuxjournal.com/content/open-vs-fauxpen&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;假&lt;/a&gt;开源无处不在。最近开源项目转为闭源的案例越来越多，同时也有不少闭源项目（按照 &lt;a href=&#34;https://opensource.org/osd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OSI 定义&lt;/a&gt;）像开源一样构建社区的例子。这怎么可能，开源项目不应该始终如此吗？&lt;/p&gt;
&lt;p&gt;开源不是非黑即白，它具有开放性、透明、协作性和信任性的多个&lt;a href=&#34;https://monetize.substack.com/p/a-holistic-vision-of-open-source&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;维度&lt;/a&gt;。有些开源是 Github 上的任何项目，有些必须通过 OSI 定义，有些是必须遵守不成文但普遍接受的开源规范。这里通过看一些商业和技术方面，再讨论社区管理习惯，来同大家分享一下我对评估开源项目的看法。&lt;/p&gt;
&lt;h2 id=&#34;免责声明&#34;&gt;免责声明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这些是我的个人观点，与我的雇主或我所属的软件基金会和项目无关。&lt;/li&gt;
&lt;li&gt;这不是法律或专业意见（我不是律师，也不是专门从事 OSS 评估的），而是外行的意见。
更新：我收到了多位开源律师的反馈并更新了文章！&lt;/li&gt;
&lt;li&gt;这篇博文由&lt;a href=&#34;https://monetize.substack.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;订阅&lt;/a&gt;和&lt;a href=&#34;https://twitter.com/bibryam/status/1371045284751507463&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;分享&lt;/a&gt;按钮赞助，点击这些按钮表示支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;知识产权&#34;&gt;知识产权&lt;/h2&gt;
&lt;p&gt;关于“开源”项目的第一个问题是关于知识产权的所有权。好消息是，即使不了解这些法律含义，你可以应用一个简单的 Litmus 测试。该项目是否属于你信任的信誉良好的开源基金会？例如，&lt;a href=&#34;https://www.fsf.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FSF&lt;/a&gt; 拥有其托管项目的版权，更多情况下拥有基金会（如 &lt;a href=&#34;https://www.apache.org/foundation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ASF&lt;/a&gt;、&lt;a href=&#34;https://www.linuxfoundation.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LF&lt;/a&gt;) 通过贡献者许可协议，聚合对其项目的贡献许可权。在任何一种情况下，你都可以相信他们将充当良好的去中心化管家，并且不会在一夜之间改变项目的未来方向。如果一个项目不属于信誉良好的软件基金会，而是由一家公司提供支持，那么问题是你是否信任该公司作为供应链合作伙伴。如果这些问题的答案是肯定的，请转到下一部分。如果答案是否定的，那么你最好调查一下版权所有者是谁，以及他们对你的长期前景和潜在风险是什么。今天的单一供应商开源项目，明天可能会变成闭源。&lt;/p&gt;
&lt;h2 id=&#34;许可&#34;&gt;许可&lt;/h2&gt;
&lt;p&gt;商标出现在许可之前的原因是软件的权利人（通常是作者）通过许可授予最终用户使用一个或多个软件副本的许可。自由软件许可证是一种说明，它授予源代码或其二进制形式的使用者修改和重新分发该软件的权利。如果没有许可，这些行为将受到版权法的禁止。这里的重点是权利人可以改变主意并更改许可。权利持有人可以决定在多个许可证下分发软件或随时将许可证更改为非开源许可证。该软件也可能在&lt;a href=&#34;https://opensource.org/node/878&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公共领域&lt;/a&gt;，在这种情况下，它不受版权法的限制。公共领域并不等同于开源许可证，这是一种不太流行的方法，我们可以在这里忽略。&lt;/p&gt;
&lt;p&gt;同样，如果不是律师，这是一个外行对许可的 Litmus 测试：该项目是否根据 OSI 批准的&lt;a href=&#34;https://opensource.org/licenses/alphabetical&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;许可清单&lt;/a&gt;获得的许可？如果答案是肯定的，那么你可以依靠这些基金会的尽职调查来审查、分类许可并指出任何限制。如果答案是否定的，请让你公司的律师来查看和解释许可上的每个字以及可能的许可兼容性影响。&lt;/p&gt;
&lt;h2 id=&#34;治理&#34;&gt;治理&lt;/h2&gt;
&lt;p&gt;在余下的检查中，我们正在从更多的商业和法律方面转向涉及开源项目领域的技术和社区。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-开源评估框架&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.substack.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F7f06c148-d675-4bb7-803e-b3704f0016ef_3309x2473.png&#34; alt=&#34;开源评估框架&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      开源评估框架
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;假设不担心商标持有方（未来的合作伙伴）、许可（使用开源软件的条款），下一个问题是治理。&lt;a href=&#34;https://www.oasis-open.org/policies-guidelines/open-projects-process/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;治理&lt;/a&gt;是项目决定谁来做什么、他们应该如何做以及何时做的规则或习惯。它定义了与不同项目角色相关的职责、特权和权限，以及人们如何分配到角色和从角色中删除。此处的示例是小型日常活动，例如谁有权批准拉取请求、投票给候选发布、就项目架构达成共识、定义项目路线图以及选举项目治理委员会。&lt;/p&gt;
&lt;p&gt;如果你正在评估对你的组织具有战略意义的项目，你想知道谁负责。不仅如此，你甚至可能&lt;a href=&#34;https://hackernoon.com/reciprocity-in-open-source-e60fb98ee1cc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;希望&lt;/a&gt;你的开发人员对项目的方向有发言权。&lt;/p&gt;
&lt;p&gt;还有一个简单的 Litmus 测试：对于开源基金会的项目，对于谁可以对重要决策进行投票，以及如何成为决策委员会的一部分，都有明确的规则。在某些基金会（例如 ASF）中，它基于社区成员的个人功绩，而在某些基金会（例如&lt;a href=&#34;https://www.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; CNCF &lt;/a&gt;）中，它从成为付费成员组织的员工开始。在基于区块链的开源项目中，它是基于&lt;a href=&#34;https://bit.ly/devprtcl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;令牌（Token）&lt;/a&gt;的投票持有人。其他基金会有不同的规则，但都力求在多个参与者之间实现中立和权力下放。如果一个项目由一家公司或一个人管理，你相信他们会为项目和社区的利益做出最佳决策。其中一些项目可能已经写下了他们遵循的治理规则，而有些可能根本没有。由你来确定治理动态及其对你的项目参与的重要性。除了具有治理透明度和公开决策之外，另一个方面是治理机构的信任度和声誉。当你查看项目的治理委员会时，是否有一位或一组具有经过验证的技术和社交技能的领导者，让你相信他们可以将项目提升到一个新的水平？或者你是否看到一个在政治斗争中不断争论的团体？这些是开源项目是否会成功并长期发展的一些指标，还是可以预期的头痛和停滞。&lt;/p&gt;
&lt;h2 id=&#34;基础设施&#34;&gt;基础设施&lt;/h2&gt;
&lt;p&gt;拥有开源许可可能在技术上有资格作为开源项目，但这并不能说明项目是否以开源方式构建。有许多在 OSI 批准的许可下发布的软件示例，但它们是在封闭的基础设施之后开发的。通过基础设施，我的意思是用户快速提问的聊天频道。进行更深入的开发人员讨论的论坛和邮件列表。审查拉取请求的源代码管理系统，以及运行测试和每晚创建二进制文件的构建服务器。&lt;/p&gt;
&lt;p&gt;对于关注开源项目的商务人士和律师来说，这些可能并不重要，但对于将要使用开源项目的技术人员来说，这些是一些假设的好处。这里要做的检查是探索软件是否是使用开放式基础设施以开源方式开发的，而不是闭门造车。以下是几个示例问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户可以在项目聊天中提出问题并在没有中间人的情况下从另一个用户那里得到答案吗？&lt;/li&gt;
&lt;li&gt;开发人员能否与项目提交者联系并获得深入的技术问题的答案？&lt;/li&gt;
&lt;li&gt;你能否运行最新版本并确认已知的错误已修复？&lt;/li&gt;
&lt;li&gt;架构师可以参加每周一次的社区电话会议并确定项目的未来方向吗？（原文 Can an architect the weekly community call and figure out the future direction of the project? ）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于封闭的基础架构，你必须创建支持工单并付费才能获得类似问题的答案。通过开放的基础设施和开放的参与，那些知道如何以开源方式工作的人可以获得答案。&lt;/p&gt;
&lt;h2 id=&#34;社区和采用&#34;&gt;社区和采用&lt;/h2&gt;
&lt;p&gt;开源软件的主要好处之一是它允许好创意的发展和传播。你可能拥有最先进的技术、最宽松的许可和开放式开发，但如果该软件没有不断壮大的社区和不断提高的采用率，那就是一个值得调查的迹象。不同的项目会有不同的采用率。有些可能会迅速成长为主流或被其他同类型项目所取代。一些项目可能有一个小但持续的增长率和一个持续数十年的生态社区。社区规模和采用率是开源项目的最终寿命指标。以下是你可以提出的一些示例问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目中有多少活跃的开发人员（提交者），平均提交率是多少？&lt;/li&gt;
&lt;li&gt;上个月有多少用户订阅了用户论坛以及提出了多少问题？&lt;/li&gt;
&lt;li&gt;软件的最新稳定版本已被下载多少次？&lt;/li&gt;
&lt;li&gt;还有哪些项目和服务&lt;a href=&#34;https://libraries.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;依赖&lt;/a&gt;并使用这个项目？&lt;/li&gt;
&lt;li&gt;有多少商业组织支持这个项目？&lt;/li&gt;
&lt;li&gt;是否有商业组织围绕它提供产品、支持和服务？&lt;/li&gt;
&lt;li&gt;这个项目有多少 StackOverflow 问题？&lt;/li&gt;
&lt;li&gt;有多少书籍、会议演讲和职位描述提到了这个项目？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行这些问题会给你一个指示，即该项目是在增长并成为其领域的事实上的标准，还是停滞不前并可能被下一个大项目所取代。&lt;/p&gt;
&lt;p&gt;通常，开源与快节奏的开发和创新有关。同时，开源也是一种创建广泛采用和创建非官方标准的机制。许多开源项目已经变成了标准，例如用于容器编排的 Kubernetes、用于流处理的 Apache Kafka、用于 Web 服务器的 Apache httpd 等。软件中最昂贵的事情之一是找到具有合适技能的人。使用采用率高的开源项目将使你有更好的机会找到技术娴熟的人，并让他们能够更长时间地重复使用他们的技能。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;根据开源项目的关键程度，有不同的风险和评估标准。对于战略性的、难以替代的项目，这将是你的 IT 基础设施的基础，你需要是已经成为其领域事实上的开源标准的完善项目。在这里确定谁拥有该项目的商标以及谁将成为你的长期合作伙伴非常重要。通常，这些合作伙伴是项目所属软件基金会的成员组织或持有项目 IP 的单个公司。对于后者，你可能需要考虑长期风险，例如核心开发人员分叉项目的机会、提供项目即服务的超大规模者、公司收购等。&lt;/p&gt;
&lt;p&gt;对于交付速度最重要的非战略性、战术性、短期项目，你可以让你的开发人员根据开放性、社区协作和热度（对于某些前端技术很重要）来推动选择和挑选项目。在这里，定期的安全修复、开发人员支持和许可兼容性检查等中短期风险可能就足够了。&lt;/p&gt;
&lt;p&gt;在任何一种情况下，都没有适合所有情况的单一评估标准。你必须在长期商业风险、技术稳定性与最新热度、创新和开发人员满意度之间取得平衡。这里的框架将为你概括需要探索的领域和需要考虑的一些风险。祝你好运！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
