<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>serverless | 云原生社区</title>
    <link>https://cloudnative.to/category/serverless/</link>
      <atom:link href="https://cloudnative.to/category/serverless/index.xml" rel="self" type="application/rss+xml" />
    <description>serverless</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Mon, 08 Nov 2021 06:37:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>serverless</title>
      <link>https://cloudnative.to/category/serverless/</link>
    </image>
    
    <item>
      <title>Knative 1.0 发布了！</title>
      <link>https://cloudnative.to/blog/knative-1-0-ga/</link>
      <pubDate>Mon, 08 Nov 2021 06:37:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/knative-1-0-ga/</guid>
      <description>&lt;p&gt;作者：&lt;a href=&#34;https://twitter.com/csantanapr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Carlos Santana &lt;/a&gt;(IBM)、&lt;a href=&#34;https://twitter.com/omer_bensaadon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Omer Bensaadon &lt;/a&gt;(VMware)、&lt;a href=&#34;https://twitter.com/marianarra_&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maria Cruz &lt;/a&gt;(Google)，原文发布于 &lt;a href=&#34;https://knative.dev/blog/articles/knative-1.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative 官方博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;今天我们发布了 Knative 1.0，达到了一个重要的里程碑，这要归功于 600 多名开发者的贡献和合作。Knative 项目是由谷歌在 2018 年 7 月发布的，并与 VMWare、IBM、Red Hat 和 SAP 紧密合作开发的。在过去 3 年中，Knative 已经成为 &lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2020/11/CNCF_Survey_Report_2020.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 上最广泛安装的无服务器层&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;最新动态&#34;&gt;最新动态&lt;/h2&gt;
&lt;p&gt;如果你没有密切关注 Knative 的发展，自从我们在 2018 年 7 月首次发布以来，已经有很多变化。&lt;/p&gt;
&lt;p&gt;除了无数的错误修复、稳定性和性能增强之外，我们的社区还按时间顺序进行了以下改进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持多个 HTTP 路由层（包括 Istio、Contour、Kourier 和 Ambassador）&lt;/li&gt;
&lt;li&gt;支持多个存储层的事件概念与常见的订阅方法（包括 Kafka、GCP PubSub 和 RabbitMQ）&lt;/li&gt;
&lt;li&gt;“鸭子类型 &amp;quot; 的抽象，允许处理具有共同字段（如 status.conditions 和 status.address）的任意 Kubernetes 资源&lt;/li&gt;
&lt;li&gt;支持额外功能插件的&lt;a href=&#34;https://knative.dev/docs/client/install-kn/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;命令行客户端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;6 周一次的定期发布流程&lt;/li&gt;
&lt;li&gt;支持 HTTP/2、gRPC 和 WebSockets&lt;/li&gt;
&lt;li&gt;Broker 和触发器，以简化事件的发布和订阅，同时将生产者和消费者解耦&lt;/li&gt;
&lt;li&gt;支持事件组件向非 Knative 组件传递，包括集群外组件或主机上的特定 URL&lt;/li&gt;
&lt;li&gt;支持自动提供 TLS 证书（通过 DNS 或 HTTP01 挑战）&lt;/li&gt;
&lt;li&gt;为活动目的地定制交付选项，包括对无法交付的信息进行重试和 dead-letter 排队&lt;/li&gt;
&lt;li&gt;对 Broker 和 Channel 的事件追踪支持，以改善调试工作&lt;/li&gt;
&lt;li&gt;由 Knative Build 催生的 &lt;a href=&#34;https://tekton.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tekton 项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;并行和序列组件，用于编纂某些复合事件的工作流程&lt;/li&gt;
&lt;li&gt;事件源的文档以及如何贡献说明，目前涵盖了大约 40 个不同的事件源&lt;/li&gt;
&lt;li&gt;“Hitless&amp;quot; 的升级，在小版本发布之间没有放弃的请求&lt;/li&gt;
&lt;li&gt;重新设计服务的 API，以匹配部署、CronJob 等使用的 PodTemplateSpec，以简化 Kubernetes 用户的使用&lt;/li&gt;
&lt;li&gt;支持将事件目的地地址注入 PodTemplateSpec 的对象中&lt;/li&gt;
&lt;li&gt;支持基于并发量或 RPS 的水平 Pod 自动扩展&lt;/li&gt;
&lt;li&gt;使用领导者选举片的控制平面组件的高可用性&lt;/li&gt;
&lt;li&gt;一个帮助管理员安装 Knative 的 Operator&lt;/li&gt;
&lt;li&gt;快速入门，供开发者在本地试用 Knative&lt;/li&gt;
&lt;li&gt;使用 DomainMapping 简化服务的管理和发布&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10-意味着什么&#34;&gt;1.0 意味着什么？&lt;/h2&gt;
&lt;p&gt;Knative 是由许多组件组成的，这些组件的版本是一起分布的。这些组件有不同的成熟度，从 “实验性 &amp;quot; 到 “已经 GA”(Generally Available)。我们仍然希望保持版本的同步，因此决定将所有的组件转移到 1.0 版本。GA 级别会单独标记组件。&lt;/p&gt;
&lt;h3 id=&#34;为什么要一次把所有的组件移到-10&#34;&gt;为什么要一次把所有的组件移到 1.0？&lt;/h3&gt;
&lt;p&gt;两个原因：一个是面向用户的，一个是面向贡献者的。主要是面向用户的原因是，它给用户提供了一个单一的数字，让他们在了解他们所安装的东西和哪些东西可以一起使用时，可以挂在上面。次要的面向贡献者的原因是，我们所有的基础设施都是为了管理一个单一的版本号而设计的，更新它以支持多个版本号似乎不是很好地利用时间。&lt;/p&gt;
&lt;h3 id=&#34;一个组件既是-10-又是-beta-岂不是很混乱吗&#34;&gt;一个组件既是 “1.0&amp;quot; 又是 “Beta” 岂不是很混乱吗？&lt;/h3&gt;
&lt;p&gt;除非我们等待与 Knative 有关的所有事情都完成，否则我们总会有一些组件或功能处于 alpha 或 beta 状态。虽然这种情况有时会沿着组件的边界发生，但它也可能发生在一个组件内部，所以版本号不能作为 “GA 与否 &amp;quot; 的唯一指标。(这种情况也发生在其他项目上，如 Kubernetes，以及 Serving 或 Eventing 中的特定功能）。&lt;/p&gt;
&lt;p&gt;展望未来，该项目将清楚地了解各种组件或功能的成熟度，并将功能沿着 GA 或退役的路线移动。&lt;/p&gt;
&lt;h2 id=&#34;了解更多&#34;&gt;了解更多&lt;/h2&gt;
&lt;p&gt;Knative 指导委员会成员 Ville Aikas 是&lt;a href=&#34;https://kubernetespodcast.com/episode/166-knative-1.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;本周谷歌 Kubernetes 播客的嘉宾&lt;/a&gt;，他讲述了该项目创建的故事以及它的 1.0 之旅。你也可以参加 &lt;a href=&#34;https://calendar.google.com/calendar/u/0/r/eventedit/NnAycjJyZmdlMTF1b2FuOGJzZjZ1dXA0aTZfMjAyMTExMjRUMTczMDAwWiBrbmF0aXZlLnRlYW1fOXE4M2JnMDdxczViOXJyc2xwNWpvcjRsNnNAZw?tab=mc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;11 月 17 日的 Knative 社区聚会&lt;/a&gt;，届时 Ville 将谈论项目的最新变化。&lt;/p&gt;
&lt;h2 id=&#34;参与其中&#34;&gt;参与其中&lt;/h2&gt;
&lt;p&gt;Knative 社区随时欢迎新成员的加入。&lt;a href=&#34;https://slack.knative.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;加入 Knative Slack 空间&lt;/a&gt;，在熟悉项目的过程中提出问题并排除故障。最后，在 Knative 网站上找到所有的&lt;a href=&#34;https://knative.dev/docs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;项目文档&lt;/a&gt;，并&lt;a href=&#34;https://github.com/knative&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 GitHub 上为该项目做出贡献&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;感谢我们的贡献者&#34;&gt;感谢我们的贡献者&lt;/h2&gt;
&lt;p&gt;实现这一里程碑确实是一个社区的努力–我们不能不感谢一些帮助我们走到今天的人。感谢…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持 Knative 的公司，包括：
&lt;ul&gt;
&lt;li&gt;谷歌（他们还赞助了我们的网站和测试基础设施，并每月举办社区聚会）&lt;/li&gt;
&lt;li&gt;IBM&lt;/li&gt;
&lt;li&gt;红帽&lt;/li&gt;
&lt;li&gt;SAP&lt;/li&gt;
&lt;li&gt;TriggerMesh&lt;/li&gt;
&lt;li&gt;VMWare&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://knative.teststats.cncf.io/d/5/companies-table?orgId=1&amp;amp;var-period_name=Last_decade&amp;amp;var-metric=contributions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以及更多&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;我们的&lt;a href=&#34;https://github.com/knative/community/blob/main/TECH-OVERSIGHT-COMMITTEE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;技术监督委员会&lt;/a&gt;、&lt;a href=&#34;https://github.com/knative/community/blob/main/STEERING-COMMITTEE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;指导委员会&lt;/a&gt;和&lt;a href=&#34;https://github.com/knative/community/blob/main/TRADEMARK-COMMITTEE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;商标委员会&lt;/a&gt;的成员&lt;/li&gt;
&lt;li&gt;所有 Knative 的贡献者，过去和现在的&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>选择FaaS还是微服务？</title>
      <link>https://cloudnative.to/blog/faas-vs-microservices/</link>
      <pubDate>Tue, 09 Apr 2019 22:42:29 +0800</pubDate>
      <guid>https://cloudnative.to/blog/faas-vs-microservices/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://dzone.com/articles/faas-vs-microservices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在做项目的云原生改造时我们可以采用微服务架构。DevOps和自动化构建两方面的成功经验对微服务的实践很有帮助。经过一段时间的实践，你可能会有将微服务架构推广到其他部门的想法。而你担心微服务本身的复杂性和分布式系统的高维护成本会让其他部门难以接受它。可能在我们想方设法解决微服务带来的问题时，总会有些人觉得这样做毫无意义。因为现在技术发展如此之快，总会出现更好的技术方案，你能保证自己在微服务领域所做的工作最后没有白费吗？&lt;/p&gt;
&lt;p&gt;我认为不会白费！&lt;/p&gt;
&lt;p&gt;现在“serverless”和“functions-as-a-service”（FAAS）还处于早期的炒作阶段。有些人觉得serverless就是下一代的微服务，所以我们应该跳过当前的微服务模式而直接采用serverless。其实这种说法是有点夸大其词。作为架构师或开发者，我们通过学习新技术来提升自身能力让自己变得更&amp;quot;值钱&amp;quot;并没有错。但我们也要以务实态度来判断是否应该采用新技术。虽然持续跟进最新技术是我们作为架构师的职责所在，但掌握在之前的产品和IT部门引用新技术的时机也很重要。我们可以通过下面的模块来理解微服务架构和serverless，从而让它们可以更好的融入我们的技术栈。&lt;/p&gt;
&lt;p&gt;首先，我们需要知道为什么我们需要微服务。选用微服务架构的主要原因就是避免项目的体量阻碍产品的迭代，所有微服务其他的优势都是基于这点。更快的迭代速度意味着可以更快的为客户交付新功能/修改，从而更快的验证这些改动能够带来的效果。我们需要快速的知道自己所做的努力是否能够带来好的效果，如果不能就要马上调整方向。快速迭代就是微服务架构的核心优势。&lt;/p&gt;
&lt;p&gt;对于大多数的团队而言，至少有一部分应用能从微服务的迭代过程中获益。因此作为架构师或开发者，我们不要因为采用微服务有门槛就对其失去信心。实践微服务的重要步骤就是确定和测量改进指标。改进指标一般可以为每天迭代应用的次数、保证迭代应用稳定性的方法等。&lt;/p&gt;
&lt;p&gt;另一方面，不是所有的应用都需要用这种松散而复杂的方式来保证服务的迭代速度。如果只想简单做个应用来验证自己创意的商业价值，那你完全可以选择更加适合的架构。这时采用MVP测试（最小可行性测试）就是个很好的方案。如果你因为商业价值很低而打算放弃的话，那也只是放弃了一个MVP应用。你可以非常快的迭代它并从潜在的用户中获得反馈。在这种情况下，你可能需要根据反馈反复修改API、功能边界、组件等。所以过早就将组件功能做成分布式的服务也会拖慢产品的发布速度。你想修改分布式组件和它的api就必须在各个团队间进行协调。&lt;/p&gt;
&lt;p&gt;上述观点能够反映出微服务架构和单体架构适用不同的场景。而事实上并没有所谓&amp;quot;一招鲜吃遍天“的方案。当我们在微服务架构和单体架构之间纠结时，还需要考虑到所需服务是否已经存在以及它提供服务的方式（第三方服务/公司内部服务）。我们完全可以充分利用当前已有服务来构建我们的应用，不必重新购买硬件、安装和修补操作系统，以及优化服务从而达到最高吞吐量，而这也正是云及其服务存在的意义。云供应商和他们的合作伙伴能提供数据库、消息队列、缓存、CDN和其他更高级的功能： 例如语言翻译、地图/地理空间地图、天气等。我们可以组合各种按量付费的服务来构建自己的应用。如果在使用某个服务的时候无需关心安装、参数和容量等问题，其实我们就已经在采用serverless架构了。serverless架构的特点就是可以重用已经存在的service，而无需关心运行服务需要消耗些什么。&lt;/p&gt;
&lt;p&gt;函数即服务和serverless具有某种联系，因为它利用了缩小到单个应用程序函数的范围的计算模型，而这有助于将各种服务组合在一起构建应用。在这种模型下，功能按需分解，你只需为使用的功能付费。它特别适合对我们使用的服务进行按需计费和按量付费。这样一来我们能够构建弹性应用，而不需要考虑复杂的技术问题。将这些复杂的技术问题外包给别人可以让你更专注于为客户提供商业价值。&lt;/p&gt;
&lt;p&gt;但是将这部分能力外包不总是可行的。如果选择云服务，我们就丧失了对程序运行时、具体功能、bug修复和接受监管的控制力。这也是需要考虑的一部分。&lt;/p&gt;
&lt;p&gt;serverless不一定是完整的“公有云或无云”方案。如果以单个组织的角度来看，&amp;ldquo;serverless&amp;quot;可能只是代表整个体系的其他部分。例如：零售业务可以为组织内部其他服务或第三方提供“购买“服务以支持诸如分析、推荐以及其他使用“购买”服务的应用。利用定义良好的API和订阅并消费API的工作负载，你可以在自己的基础设施为微服务应用或单体应用提供serverless能力。在很多时候这其实就是服务向SOA架构进化的方向。但它们之间最大的不同就是在你将组织看作一个整体时，自己给自己的其他部分提供服务并不算serverless。因为此时还是需要自己手动的去安装、管理和更新应用。&lt;/p&gt;
&lt;p&gt;最终采用哪种方案其实取决于很多因素，例如：业务、商业目标、软件部门对该技术的熟练度和历史遗留问题等。如果你觉得应该采用微服务架构，那就不要因为其他新技术而分心。我们可以持续跟进最新技术，从而保证适时的采用它们。总的来讲，不管是微服务架构、单体架构还是serverless架构，它们都有自己的应用场景。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
