<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>可观测性 | 云原生社区（中国）</title>
    <link>https://cloudnative.to/category/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link>
      <atom:link href="https://cloudnative.to/category/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/index.xml" rel="self" type="application/rss+xml" />
    <description>可观测性</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 02 Jan 2024 08:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>可观测性</title>
      <link>https://cloudnative.to/category/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link>
    </image>
    
    <item>
      <title>OpenTelemetry 与可观测性：展望未来</title>
      <link>https://cloudnative.to/blog/opentelemetry-and-observability-looking-forward/</link>
      <pubDate>Tue, 02 Jan 2024 08:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/opentelemetry-and-observability-looking-forward/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://thenewstack.io/opentelemetry-and-observability-looking-forward/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry and Observability: Looking Forward&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让我们探讨一些令人兴奋的趋势，考虑到我们期待 2024 年会有什么样的可观测性发展。&lt;/p&gt;
&lt;p&gt;随着年底的临近，现在是一个停下来思考的好时机。2023 年对于 OpenTelemetry 来说是一个里程碑，因为其三个基本信号，跟踪、度量和日志，都达到了稳定版本。这一成就标志着&lt;a href=&#34;https://thenewstack.io/opentelemetry-gaining-traction-from-companies-and-vendors/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt;最初愿景的实现，即提供一个基于标准的框架，用于仪器化和收集可观测性数据。&lt;/p&gt;
&lt;p&gt;让我们抓住这个机会，探讨一下我们所见证的一些令人兴奋的趋势，深入研究创新的产品和用例，并在期待 2024 年的到来时深思熟虑地考虑可观测性的不断演变。&lt;/p&gt;
&lt;h2 id=&#34;度量标准的崭露头角&#34;&gt;度量标准的崭露头角&lt;/h2&gt;
&lt;p&gt;尽管 OpenTelemetry 关于度量的规范在 2022 年 5 月被宣布为稳定版本，但今年看到了其被广泛采用。以下是一些从业者的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由 VMware 的 Matthew Kocher 和 Carson Long 撰写的文章，标题为“&lt;a href=&#34;https://opentelemetry.io/blog/2023/cloud-foundry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;体验报告：在 Cloud Foundry 中采用 OpenTelemetry 进行度量&lt;/a&gt;”。&lt;/li&gt;
&lt;li&gt;我们自己的 Matheus Nogueira 撰写的文章，标题为“&lt;a href=&#34;https://tracetest.io/blog/adding-opentelemetry-metrics-in-your-go-app&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在你的 Go 应用程序中添加 OpenTelemetry 度量&lt;/a&gt;”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;展望 2024 年，可以预期会看到类似的日志运动和采用。&lt;/p&gt;
&lt;h2 id=&#34;关注在负载测试中使用分布式跟踪&#34;&gt;关注在负载测试中使用分布式跟踪&lt;/h2&gt;
&lt;p&gt;2023 年，两个领先的负载测试工具，&lt;a href=&#34;https://k6.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana k6&lt;/a&gt;和&lt;a href=&#34;https://artillery.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Artillery.io&lt;/a&gt;，都添加了对 OpenTelemetry 的支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Grafana k6 &lt;a href=&#34;https://github.com/grafana/xk6-distributed-tracing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;引入了跟踪&lt;/a&gt;功能，使性能工程师能够在&lt;a href=&#34;https://thenewstack.io/trace-based-testing-the-next-step-in-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;负载测试&lt;/a&gt;期间识别系统瓶颈或故障。&lt;/li&gt;
&lt;li&gt;Artillery.io 随后也&lt;a href=&#34;https://www.artillery.io/blog/introducing-opentelemetry-support&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;添加了度量和分布式跟踪&lt;/a&gt;，提供了对系统性能更详细的分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tracetest 利用了 k6 测试中暴露的功能，以&lt;a href=&#34;https://docs.tracetest.io/tools-and-integrations/k6&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;启用基于跟踪的负载测试&lt;/a&gt;，在运行测试时进行深入的断言。我们已经看到许多客户广泛使用了这个功能，比如&lt;a href=&#34;https://tracetest.io/case-studies/how-sigma-software-built-load-testing-for-their-microservices-with-k6-tracetest&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sigma Software&lt;/a&gt;。在 2024 年，Tracetest 团队将考虑将这一能力添加到&lt;a href=&#34;http://artillery.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Artillery.io&lt;/a&gt;和其他负载测试工具中。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-的支持和用例扩展&#34;&gt;OpenTelemetry 的支持和用例扩展&lt;/h2&gt;
&lt;p&gt;越来越多的供应商正在采用 OpenTelemetry 标准，以支持典型但非常重要的遥测数据分析之外的行动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一些公司，比如&lt;a href=&#34;https://opentelemetry.io/blog/2023/tyk-api-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tyk 正在仪器化其 API 网关，以原生支持 OpenTelemetry&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;终端用户正在发现 OpenTelemetry 的新用例，比如&lt;a href=&#34;https://thenewstack.io/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用分布式跟踪来观察你的 CI/CD 流水线&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tracetest.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tracetest&lt;/a&gt;利用分布式跟踪数据进行集成和端到端测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;强调-opentelemetry-收集器&#34;&gt;强调 OpenTelemetry 收集器&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://thenewstack.io/how-adobe-uses-opentelemetry-collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 收集器&lt;/a&gt;位于 OpenTelemetry 世界的中心，接收来自应用程序的信号，处理和转换这些信号，然后将它们导出到任意数量的后端系统。随着对 OpenTelemetry 的集成和供应商支持的扩展，对这个集中式收集器的需求和要求也在增加。&lt;/p&gt;
&lt;p&gt;2023 年引入了 OpenTelemetry Transformation Language (OTTL)，增强了 OpenTelemetry 收集器处理和转换传入信号的能力。&lt;/p&gt;
&lt;p&gt;在 Tracetest 中，我们能够利用&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/processor/filterprocessor/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在过滤器处理器中使用 OTTL&lt;/a&gt;的能力，改进了我们从输出大量遥测数据的生产环境中收集跟踪数据的方式。这一变化对&lt;a href=&#34;https://tracetest.io/blog/opentelemetry-collectors-new-filter-processor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 收集器的过滤器处理器&lt;/a&gt;使 Tracetest 适用于在高负载环境中运行测试，包括生产环境。&lt;/p&gt;
&lt;h2 id=&#34;无处不在的可观测性&#34;&gt;无处不在的可观测性&lt;/h2&gt;
&lt;p&gt;在最近的讨论中，我们发现了一种客户中不断增长的趋势，即“无处不在的可观测性”方法。这些公司不仅限于由网站可靠性工程师和 DevOps 传统使用，还包括了每个人，包括开发人员和测试人员，参与到可观测性中。这种转变重新定义&lt;/p&gt;
&lt;p&gt;了可观测性，使其从生产问题的一种反应性工具变成了在开发和测试中都有益的一种主动工具。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.honeycomb.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Honeycomb&lt;/a&gt;强调了&lt;a href=&#34;https://www.honeycomb.io/blog/observability-driven-development&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在开发过程中使用可观测性&lt;/a&gt;，而像&lt;a href=&#34;http://digma.ai/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Digma.ai&lt;/a&gt;和 Tracetest 这样的工具正在推动这一前进。&lt;/p&gt;
&lt;h2 id=&#34;浏览器&#34;&gt;浏览器&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 的主要作用一直局限于仪器化后端系统，而基于开放标准的浏览器仪器化仍然是实验性的，进展缓慢。正在努力改进和标准化这种仪器化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tracetest.io/case-studies/how-uzufly-built-end-to-end-testing-serverless-web-app-with-distributed-traces&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Uzufly&lt;/a&gt;在这方面脱颖而出。它使用现有的客户端仪器化来构建测试。展望未来，它的雄心是扩展基于跟踪的测试，以覆盖浏览器内部发起的前端操作所进行的测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这将实现前端和后端的全面端到端测试。请关注 2024 年更多关于这个主题的信息！&lt;/p&gt;
&lt;h2 id=&#34;2023-已经过去&#34;&gt;2023 已经过去&lt;/h2&gt;
&lt;p&gt;告别 2023，我们怀着热情期待 2024 年的到来。OpenTelemetry 具有势头，得到了标准和广泛采用的支持，推动了其增长。新的一年承诺带来令人兴奋的发展，围绕 OpenTelemetry 出现了创新的产品和用例。我迫不及待地想看到 2024 年将揭示的进步和创新。愿 OpenTelemetry 长存！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OpenTelemetry 最佳实践：用户入门指南</title>
      <link>https://cloudnative.to/blog/opentelemetry-best-practices/</link>
      <pubDate>Fri, 22 Dec 2023 09:14:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/opentelemetry-best-practices/</guid>
      <description>&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;本文译自：&lt;a href=&#34;https://grafana.com/blog/2023/12/18/opentelemetry-best-practices-a-users-guide-to-getting-started-with-opentelemetry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry best practices: A user&amp;rsquo;s guide to getting started with OpenTelemetry&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要：文章介绍了 OpenTelemetry 的概念和优势，以及如何使用 Grafana 的分发版进行自动和手动的仪表化、配置和导出数据。&lt;/p&gt;
&lt;p&gt;评论：这是一篇非常实用和有价值的文章，它为 OpenTelemetry 的新手和老手提供了一些最佳实践和技巧，帮助他们更好地利用这个强大的服务网格平台，实现应用程序的可观测性和安全性。文章不仅介绍了 OpenTelemetry 的基本概念和组件，还展示了如何使用 Grafana 的分发版，轻松地对 Java 和 .NET 应用程序进行仪表化，发送遥测数据到 Grafana Cloud，以及优化数据的质量和成本。文章还提供了一些有用的链接和资源，供读者进一步学习和探索。我认为这篇文章是 OpenTelemetry 的一个很好的入门指南，也是 Grafana 的一个很好的推广案例，值得云原生社区的关注和推荐。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;如果你正在阅读这篇博客，你很可能要么考虑开始你的 OpenTelemetry 之旅，要么已经在路上。随着 OpenTelemetry 的采用不断增长，不仅在可观察性社区内，还在 Grafana Labs 内部以及我们的用户中，我们经常收到关于如何最佳实施 OpenTelemetry 策略的请求。&lt;/p&gt;
&lt;p&gt;Grafana Labs 全力支持 OpenTelemetry，在我们的开源项目和产品中构建了与之兼容性，并积极参与了 OTel 社区。在过去的一年中，我们在 OpenTelemetry 上的两个主要关注领域分别是&lt;a href=&#34;https://grafana.com/blog/2023/07/20/a-practical-guide-to-data-collection-with-opentelemetry-and-prometheus/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;与 Prometheus 的互操作性&lt;/a&gt;和&lt;a href=&#34;https://grafana.com/docs/opentelemetry/instrumentation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;仪表 SDK&lt;/a&gt;。我们还为 OTel Collector 贡献了对 Prometheus 本地直方图的支持。 （有趣的事实：Grafana Labs 是唯一一家在对 Prometheus &lt;em&gt;和&lt;/em&gt; OpenTelemetry 的贡献方面处于领先地位的公司。）&lt;/p&gt;
&lt;p&gt;以下是基于常见问题、经常讨论的主题和我们自己的经验的 OpenTelemetry 最佳实践汇编。我们希望你会在实施过程中记住一些有用的提示和技巧。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-仪表化&#34;&gt;OpenTelemetry 仪表化&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：使用自动仪表化开始。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;自动仪表化旨在涵盖各种用例，因此它不会始终提供专业信息（例如，你实施的任何专有 IP 或业务代码）。如果有疑问，可以从自动仪表化开始，如果缺少某些内容，然后考虑添加手动仪表化，在缺少细节的地方以及去掉你不需要的内容。&lt;/p&gt;
&lt;p&gt;你可以了解更多关于&lt;a href=&#34;https://grafana.com/blog/2023/11/16/the-grafana-opentelemetry-distribution-for-.net-optimized-for-application-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana .NET 的自动仪表化&lt;/a&gt;和&lt;a href=&#34;https://grafana.com/blog/2023/11/16/the-grafana-opentelemetry-distribution-for-java-optimized-for-application-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana Java 的自动仪表化&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;首先初始化-opentelemetry&#34;&gt;首先初始化 OpenTelemetry&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：确保你实际收集到你想要的一切。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在使用任何应该被仪表化的库之前，你应该始终初始化 OpenTelemetry 和应用程序前面定义的任何变量。否则，你将无法找到所需的跨度。&lt;/p&gt;
&lt;p&gt;对于自动仪表化，这意味着将相关的 OpenTelemetry 框架添加到你的代码中（例如，在 Java 中，这包括将 OpenTelemetry JAR 文件与你的应用程序一起使用）。&lt;/p&gt;
&lt;p&gt;在手动仪表化的情况下，这包括将 OpenTelemetry SDK 库导入你的代码中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：说到手动仪表化，不要忘记结束你的跨度！一个跨度始终应该有一个开始和一个结束。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;opentelemetry-属性生成&#34;&gt;OpenTelemetry 属性生成&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：确保你的数据一致且有意义。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;通常，你应该只包括与跨度代表的操作相关的属性。例如，如果你正在跟踪 HTTP 请求，你可以包括属性，如请求方法、URL 和响应状态代码。&lt;/p&gt;
&lt;p&gt;如果你不确定是否应该包括某个属性，最好谨慎行事，不要包括它。如果需要，你随时可以稍后添加更多属性！&lt;/p&gt;
&lt;h3 id=&#34;关于-opentelemetry-属性的做与不做&#34;&gt;关于 OpenTelemetry 属性的做与不做&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不要&lt;/strong&gt;将度量或日志作为属性放入你的跨度中。让每种遥测类型都尽其所能地完成其工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要&lt;/strong&gt;使用冗余属性。没有必要有五个不同的属性，都指定了服务名称。这只会让最终用户感到困惑，并增加跨度大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;要&lt;/strong&gt;考虑服务流程和在当前跨度上下文中发生的事情，只有在考虑要添加哪些属性时才这样做。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用-opentelemetry-语义&#34;&gt;使用 OpenTelemetry 语义&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;TL;DR：语义是方法。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;OpenTelemetry 的&lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/blob/main/docs/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;语义约定&lt;/a&gt;提供了描述不同类型实体（属性和资源）的通用词汇表，有助于确保你的数据一致且有意义。如果你刚开始使用 OpenTelemetry，这是一种早期实施的绝佳方法，以确保有一个共同的框架。&lt;/p&gt;
&lt;p&gt;说到框架，命名属性和资源时，优先选择描述性的名称，避免不熟悉的缩写或首字母缩写。确立一致的大写、格式（例如，后缀或前缀）和标点符号样式。&lt;/p&gt;
&lt;h2 id=&#34;关联-opentelemetry-数据&#34;&gt;关联 OpenTelemetry 数据&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：在度量、日志和跨度的用例方面要有战略意识和现实意识，并生成正确的遥测类型来回答问题。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;确保你能够无缝关联这些数据，以便无论存储在哪个后端，都可以跳转到正确的数据。例如，在你已经仪表化的应用程序的日志中记录 traceID，并利用元数据。阅读更多策略&lt;a href=&#34;https://grafana.com/blog/2020/03/31/how-to-successfully-correlate-metrics-logs-and-traces-in-grafana/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此处&lt;/a&gt;！&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-批处理&#34;&gt;OpenTelemetry 批处理&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：根据大小或时间批处理和压缩遥测数据，以便更快地查询数据。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;是否批处理？这又是一个因情况而异的答案。一般来说，批处理可能更受欢迎，因为它将减少你的网络开销，并允许你更好地规划资源消耗；但是，批处理处理器将为数据添加一些处理时间，增加生成和可查询之间的延迟。&lt;/p&gt;
&lt;p&gt;如果你的应用程序需要几乎实时的查询，最好为该应用程序使用简单的处理，并为其他应用程序批处理，但即使使用批处理，数据也会被非常快速地处理，因此这可能不会影响大多数情况！&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-采样&#34;&gt;OpenTelemetry 采样&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：找到适合你用例的采样策略。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;采样可能是一个好主意，但它取决于你的用例。尽管&lt;a href=&#34;https://grafana.com/oss/tempo/?pg=blog&amp;amp;plcmt=body-txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana Tempo&lt;/a&gt;能够存储完整的跟踪数据，但在某些时候，它可能会成为成本考虑因素，或者根据吞吐量和摄取量而定。&lt;/p&gt;
&lt;p&gt;你选择的最佳采样策略将取决于系统的具体要求。可能需要考虑的一些因素包括生成的数据量、系统的性能要求以及遥测数据使用者的具体需求。没有一种大小适合所有的解决方案，因此你需要进行实验，找到最适合你需求的最佳策略。&lt;/p&gt;
&lt;h3 id=&#34;opentelemetry-采样优点&#34;&gt;OpenTelemetry 采样：优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;减少收集的数据量，以节省存储和带宽成本&lt;/li&gt;
&lt;li&gt;提高性能，因为需要处理和传输的数据较少&lt;/li&gt;
&lt;li&gt;过滤噪声，专注于系统的特定部分&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;opentelemetry-采样缺点&#34;&gt;OpenTelemetry 采样：缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;引入偏差到数据中，因为没有收集所有数据&lt;/li&gt;
&lt;li&gt;可能更难排查问题，因为可能无法获得问题的完整上下文&lt;/li&gt;
&lt;li&gt;可能难以实施和管理，因为它需要仔细考虑系统的具体需求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在许多情况下，远程控制的头采样与概率尾采样配对在大多数用例中足够了。阅读我们的&lt;a href=&#34;https://grafana.com/blog/2022/05/11/an-introduction-to-trace-sampling-with-grafana-tempo-and-grafana-agent/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关于跟踪采样的介绍博文&lt;/a&gt;以了解不同策略。&lt;/p&gt;
&lt;h2 id=&#34;跨度事件&#34;&gt;跨度事件&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：充分利用你的跟踪数据。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;跨度事件用于记录在任何单一跨度期间发生的有趣和有意义的事件。跨度始终具有开始和结束，因此可以将用户单击“结账”视为开始（单击）到结束（页面加载）的记录。事件是时间的一个瞬间，例如错误消息或记录页面变得可交互的时间。自动仪表化将为你收集跨度事件中的相关信息。例如，在自动仪表化的 Java 应用程序中，所有异常将自动记录在跨度事件字段中。&lt;/p&gt;
&lt;h2 id=&#34;上下文传播&#34;&gt;上下文传播&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：确保在需要的时间和地点拥有正确的数据。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;虽然手动传播上下文是可能的，但让仪表化库为你处理是更好的实践。对于大多数 OpenTelemetry SDK，如果使用自动仪表化，HTTP 和 gRPC 通信都将包含传播器。除非你的环境中有独特的用例或系统需要，否则应使用&lt;a href=&#34;https://www.w3.org/TR/trace-context/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;W3C 跟踪上下文推荐&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;在适用的情况下使用-baggage&#34;&gt;在适用的情况下使用 Baggage&lt;/h3&gt;
&lt;p&gt;在跨度之间传播键值对时，Baggage 使用 HTTP 标头。以一个原始 IP 的示例。这些数据可能对事务中的第一个服务可用，&lt;/p&gt;
&lt;p&gt;但除非你指定要将其传播到其余跨度，否则后续服务无法访问该数据。使用 Baggage，你可以根据存储为 Baggage 的值将属性添加到未来的跨度中。&lt;/p&gt;
&lt;h2 id=&#34;跨度指标和服务图连接器&#34;&gt;跨度指标和服务图连接器&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：始终充分利用跨度指标以轻松分析 RED 数据！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;跨度指标使你能够查询、分析和基于请求速率、错误率和随时间变化的持续时间（RED 指标）的聚合构建自定义可视化。&lt;/p&gt;
&lt;p&gt;在完全托管的&lt;a href=&#34;https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana Cloud&lt;/a&gt;平台中，可以从你摄取的跟踪中自动生成跨度指标和服务图指标。这与 OpenTelemetry 提供的这些连接器相同的功能，如果喜欢，你可以在收集器侧或使用 Flow 模式中的 Grafana Agent 中实现生成。重要的是跨度指标在某个地方生成！&lt;/p&gt;
&lt;p&gt;你可以在 GitHub 中阅读有关如何配置&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/connector/spanmetricsconnector/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;跨度指标连接器&lt;/a&gt;和&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/connector/servicegraphconnector/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务图连接器&lt;/a&gt;的更多信息。&lt;/p&gt;
&lt;p&gt;你还可以参考我们的文档，了解有关在 Grafana Cloud 中如何配置&lt;a href=&#34;https://grafana.com/docs/tempo/latest/metrics-generator/service_graphs/#how-they-work&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;度量生成器&lt;/a&gt;和&lt;a href=&#34;https://grafana.com/docs/tempo/latest/metrics-generator/span_metrics/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;跨度指标&lt;/a&gt;生成的更多信息。你还可以查看我们关于&lt;a href=&#34;https://grafana.com/blog/2023/12/07/traces-to-metrics-ad-hoc-red-metrics-in-grafana-tempo-with-aggregate-by/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 Grafana Tempo 生成临时 RED 指标&lt;/a&gt;的博客文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;生成-red-指标的选项&#34;&gt;生成 RED 指标的选项&lt;/h3&gt;
&lt;p&gt;在 Grafana Cloud 中，基于摄取的跨度生成指标。如果在 Grafana Agent 或 OpenTelemetry Collector 中使用任何类型的尾采样器，那么那些未采样的跨度将在摄取之前被丢弃。如果使用 10% 的概率采样器，这意味着你只看到 10% 的跟踪范围的指标。显然，这会极大地影响观察到的生成指标，并且如果发生错误、延迟等采样，那么这些指标可能不会有用（尽管 Tempo 和 Grafana Cloud Traces 包括一个选项，可以粗略地将跨度值乘以以使其具有代表性）。&lt;/p&gt;
&lt;p&gt;Grafana Agent（如果管道配置正确）在尾采样发生之前从跨度生成指标。因此，仍然依赖这些收集器中可以发送到 Grafana 的本地指标生成将为所有跨度进行采样前提供准确的反映。即使采样也可以实现准确的指标活动系列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;opentelemetry-架构&#34;&gt;OpenTelemetry 架构&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：使用收集器！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;无论你选择 Grafana Agent 分发还是 OpenTelemetry Collector，都可以在存储之前对数据进行批处理、压缩、变异和转换。作为一个集中的代理，这种实现还提供了一个中央的单一位置来管理密钥。&lt;/p&gt;
&lt;p&gt;使用收集器提供的所有灵活性，你可以实现无限的用例。即使现在你没有任何想法，部署收集器在长期内几乎肯定会对你有益。通常情况下，我们建议你&lt;strong&gt;仅在测试或小规模开发场景下直接发送到 OTLP 端点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最终的架构可能如下所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-opentelemetry-collector-通用架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;OpenTelemetry Collector 通用架构图&#34; srcset=&#34;
               /blog/opentelemetry-best-practices/network-architecture-opentelemetry-grafana-cloud_hu1e9c21e999f8d3992c652a74096386db_98438_ae59c6d77bc8676ab8b8287b2a74ad17.webp 400w,
               /blog/opentelemetry-best-practices/network-architecture-opentelemetry-grafana-cloud_hu1e9c21e999f8d3992c652a74096386db_98438_53febc79e85d70cae3b744e621c5e67d.webp 760w,
               /blog/opentelemetry-best-practices/network-architecture-opentelemetry-grafana-cloud_hu1e9c21e999f8d3992c652a74096386db_98438_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/opentelemetry-best-practices/network-architecture-opentelemetry-grafana-cloud_hu1e9c21e999f8d3992c652a74096386db_98438_ae59c6d77bc8676ab8b8287b2a74ad17.webp&#34;
               width=&#34;760&#34;
               height=&#34;641&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      OpenTelemetry Collector 通用架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果你仍然对收集器有疑虑，请查看我们最近的&lt;a href=&#34;https://grafana.com/blog/2023/11/21/do-you-need-an-opentelemetry-collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;你是否需要 OpenTelemetry 收集器？&lt;/a&gt;博客文章。&lt;/p&gt;
&lt;h3 id=&#34;opentelemetry-collector-部署架构&#34;&gt;OpenTelemetry Collector 部署架构&lt;/h3&gt;
&lt;p&gt;在决定部署的生产架构时，需要考虑许多因素。有关不同部署选项的详细信息，请参阅我们的&lt;a href=&#34;https://grafana.com/docs/opentelemetry/collector/use-cases/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;用例&lt;/a&gt;文档。&lt;/p&gt;
&lt;h2 id=&#34;使用导出器&#34;&gt;使用导出器&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：确保将数据发送到某个地方。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;所以你的收集器正在运行？在 Grafana Agent 或 OpenTelemetry Collector 中使用一个或多个导出器将数据发送到后端或记录到控制台以进行故障排除。如果你正在进行测试或积极开发，为什么不两者都使用呢？这两个选项都支持使用多个导出器，因此你可以在收集器中使用特定于供应商的组合和日志导出器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示：了解你的限制&lt;/strong&gt;
在 Grafana Tempo 中，围绕跟踪/跨度和属性大小设置了一些默认限制。&lt;/p&gt;
&lt;p&gt;最大属性值长度：2046
最大跟踪大小：50MB&lt;/p&gt;
&lt;p&gt;我们还实施了&lt;a href=&#34;https://opentelemetry.io/docs/specs/otel/common/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 规范&lt;/a&gt;中的默认限制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;充分利用-grafana-cloud-的-opentelemetry-数据&#34;&gt;充分利用 Grafana Cloud 的 OpenTelemetry 数据&lt;/h2&gt;
&lt;p&gt;Grafana Cloud 是开始有效可视化、查询和关联 OpenTelemetry 数据的最简单方法。通过启用&lt;a href=&#34;https://grafana.com/blog/2023/11/14/announcing-application-observability-in-grafana-cloud-with-native-support-for-opentelemetry-and-prometheus/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Observability&lt;/a&gt;，该功能与 OpenTelemetry 和 Prometheus 兼容，你将获得一组与 OpenTelemetry 数据本地集成的预构建 Grafana 仪表板。尽管开箱即用的仪表板总是不错的，但有时你可能希望构建自己的仪表板。以下是一个示例，演示了如何基于你的 OpenTelemetry 跟踪和跨度指标构建自定义仪表板。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-使用-opentelemetry-数据的-grafana-仪表板&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;使用 OpenTelemetry 数据的 Grafana 仪表板&#34; srcset=&#34;
               /blog/opentelemetry-best-practices/grafana-dashboard-opentelemetry-traces-metrics_hud7c53683209fbae1371f263d077d50a0_185239_a2fdac4b23de6fab36baef44a13b0c0f.webp 400w,
               /blog/opentelemetry-best-practices/grafana-dashboard-opentelemetry-traces-metrics_hud7c53683209fbae1371f263d077d50a0_185239_f35b7c50245a7b34496fdccb56e34e3b.webp 760w,
               /blog/opentelemetry-best-practices/grafana-dashboard-opentelemetry-traces-metrics_hud7c53683209fbae1371f263d077d50a0_185239_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/opentelemetry-best-practices/grafana-dashboard-opentelemetry-traces-metrics_hud7c53683209fbae1371f263d077d50a0_185239_a2fdac4b23de6fab36baef44a13b0c0f.webp&#34;
               width=&#34;613&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      使用 OpenTelemetry 数据的 Grafana 仪表板
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果你正在使用 Grafana Cloud，还可以考虑超越常规，将你的 OpenTelemetry 数据与其他功能集成。例如，如果你的应用程序在预期值之外看到请求的异常增加，是否可以使用&lt;a href=&#34;https://grafana.com/docs/grafana-cloud/alerting-and-irm/machine-learning/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana 机器学习&lt;/a&gt;来发现？&lt;/p&gt;
&lt;p&gt;要了解有关 OpenTelemetry 和 Grafana Cloud 的更多信息，请阅读我们的&lt;a href=&#34;https://grafana.com/docs/grafana-cloud/monitor-infrastructure/integrations/integration-reference/integration-opentelemetry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 OpenTelemetry 提升 CI/CD 管道的可观察性</title>
      <link>https://cloudnative.to/blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/</link>
      <pubDate>Tue, 12 Dec 2023 14:30:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://thenewstack.io/how-to-observe-your-ci-cd-pipelines-with-opentelemetry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://thenewstack.io/how-to-observe-your-ci-cd-pipelines-with-opentelemetry&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要：这篇文章介绍了 OpenTelemetry 这个开源框架，它可以帮助你生成、收集换和导出 CI/CD 管道的遥测数据，以实现性能、可靠性、安全性等方面的度量、监控、告警、分析等功能。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如今的软件比 20 多年前的软件复杂得多，这带来了在故障排除代码时面临新挑战。幸运的是，通过将可观测性引入我们的系统，我们在理解应用程序的性能如何以及问题发生在何处方面取得了相当大的进展。&lt;/p&gt;
&lt;p&gt;然而，不仅软件发生了演变 - 创建和开发软件的过程也发生了变化。&lt;a href=&#34;https://roadmap.sh/devops&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DevOps&lt;/a&gt;引入了&lt;a href=&#34;https://thenewstack.io/a-primer-continuous-integration-and-continuous-delivery-ci-cd/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CI/CD的概念&lt;/a&gt;。随着交付周期从每月、每季度，到现在每周甚至一天多次，我们正在全面采用自动化来进行软件交付。&lt;/p&gt;
&lt;p&gt;不幸的是，与应用程序软件相比，&lt;a href=&#34;https://thenewstack.io/ci-cd/&#34; title=&#34;CI/CD pipelines&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CI/CD流水线&lt;/a&gt;的可观测性进展不大。考虑到这些流水线是软件交付流程的基础，这令人惊讶：如果你没有可见性，那么当出现问题且无法将软件投入生产时，你该如何排除问题？&lt;/p&gt;
&lt;p&gt;这正是本文将重点讨论的内容：CI/CD 流水线的可观测性。首先，我们将定义一些概念；然后，我们将深入探讨观察流水线的重要性以及如何使其可观测；最后，我们将讨论一些尚未解决的挑战。&lt;/p&gt;
&lt;h2 id=&#34;关键概念&#34;&gt;关键概念&lt;/h2&gt;
&lt;p&gt;以下是一些需要了解的定义：&lt;/p&gt;
&lt;h3 id=&#34;可观测性&#34;&gt;可观测性&lt;/h3&gt;
&lt;p&gt;有关&lt;a href=&#34;https://thenewstack.io/observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可观测性&lt;/a&gt;有多种定义，因此我们将其缩小为我们最喜欢的定义：&lt;/p&gt;
&lt;p&gt;可观测性，或简称 o11y（发音为“ollie”），允许你通过不了解系统内部运作方式就能从外部了解系统。有趣的是：“o11y”中的数字 11 代表了“可观测性”一词中的字母“o”和“y”之间的字符数。&lt;/p&gt;
&lt;p&gt;这意味着即使你不了解系统的所有细节业务逻辑，系统仍会发出足够的信息，使你能够通过跟踪线索来回答：“为什么会发生这种情况？”但是，如果你的系统不发出信息，那么你就无法进行观察。你如何获取这些信息呢？一种方式是使用 OpenTelemetry。&lt;/p&gt;
&lt;h3 id=&#34;opentelemetry&#34;&gt;OpenTelemetry&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://thenewstack.io/introducing-opentelemetry-in-your-organization-3-steps/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry（OTel）&lt;/a&gt;是一个用于生成、收集、转换和导出遥测数据的开源可观测性框架。它提供了一组 API、软件开发工具包（SDK）、仪器库和工具，帮助你完成这些任务。自 2019 年正式成立以来，它已成为应用程序仪器和遥测生成和收集的事实标准，被包括&lt;a href=&#34;https://innovation.ebayinc.com/tech/engineering/why-and-how-ebay-pivoted-to-opentelemetry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBay&lt;/a&gt;和&lt;a href=&#34;https://www.infoq.com/presentations/opentelemetry-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Skyscanner&lt;/a&gt;在内的公司使用。&lt;/p&gt;
&lt;p&gt;其最大的好处之一是不受供应商锁定的限制。你可以为应用程序添加遥测一次，并将遥测发送到最适合你的后端。它还提供一些非常酷的工具，例如 Collector。&lt;/p&gt;
&lt;p&gt;Collector 是一个供应商中立的服务，用于接收、转换和导出数据到一个或多个可观测性后端。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-otel-collector-组件的图示&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;OTel Collector 组件的图示&#34; srcset=&#34;
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/1_hub324021bb8008512e57337f27dac5f93_39000_7e054da520dcf8fbfadfe76b5f62f958.webp 400w,
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/1_hub324021bb8008512e57337f27dac5f93_39000_a71a87fc736a69596d4529a63c625ad8.webp 760w,
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/1_hub324021bb8008512e57337f27dac5f93_39000_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/1_hub324021bb8008512e57337f27dac5f93_39000_7e054da520dcf8fbfadfe76b5f62f958.webp&#34;
               width=&#34;760&#34;
               height=&#34;272&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      OTel Collector 组件的图示
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Collector 由四个主要组件组成，这些组件访问遥测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Receivers&lt;/strong&gt; 接收数据，无论是来自你的应用程序代码还是基础架构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Processors&lt;/strong&gt; 转换数据。处理器可以执行诸如模糊化数据、添加属性、删除属性或过滤数据等操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exporters&lt;/strong&gt; 将数据转换为与你选择的可观测性后端兼容的格式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Connectors&lt;/strong&gt; 允许你连接两个流水线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以将 OTel Collector 视为数据管道。&lt;/p&gt;
&lt;h3 id=&#34;cicd-流水线&#34;&gt;CI/CD 流水线&lt;/h3&gt;
&lt;p&gt;CI/CD 是一种自动化的软件交付方法，依赖于两个关键实践：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续集成（CI）是指在进行代码更改时构建、打包和测试软件。&lt;/li&gt;
&lt;li&gt;连续交付（CD）是指立即将该软件包部署到生产环境中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-cicd-流水线-gif其中有只猫在其中移动&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;CI/CD 流水线 GIF，其中有只猫在其中移动&#34;
           src=&#34;https://cloudnative.to/blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/2.gif&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      CI/CD 流水线 GIF，其中有只猫在其中移动
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;自动化的流水线通过允许你更快地向客户提供新功能、修复错误和一般更新来实现快速的产品迭代。它们消除了手动错误的风险，并标准化了对开发人员的反馈循环。&lt;/p&gt;
&lt;h2 id=&#34;为何-cicd-流水线的可观测性很重要&#34;&gt;为何 CI/CD 流水线的可观测性很重要&lt;/h2&gt;
&lt;p&gt;当你的流水线健康时，你的团队可以持续编写、构建、测试和部署代码和配置更改到生产环境。你还可以改进或实现开发敏捷性，这意味着你可以更改运营方式并最小化确定这些修改是否对应用程序的健康产生了积极或消极影响所需的时间。&lt;/p&gt;
&lt;p&gt;相反，当你的流水线不健康时，你可能会遇到以下一种或多种问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;部署缓慢&lt;/strong&gt;：修复错误可能不够快，以制止用户的不满，问题可能会变得严重。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试问题&lt;/strong&gt;：不得不等待测试完成，或没有足够的时间来测试不同的配置，可能会导致延迟的部署和难以在用户群中实现足够的应用程序性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术债务&lt;/strong&gt;：难以确定底层问题可能导致技术债务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-处于燃烧房间中的猫说一切正常&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;处于燃烧房间中的猫说：“一切正常。”&#34; srcset=&#34;
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/3_hucc598ff7983effda9403f72784f50a7e_342512_f81563b07d737636c0c5d022ee172e2b.webp 400w,
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/3_hucc598ff7983effda9403f72784f50a7e_342512_638c70f7bba482d7f806ec2ff825d8e2.webp 760w,
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/3_hucc598ff7983effda9403f72784f50a7e_342512_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/3_hucc598ff7983effda9403f72784f50a7e_342512_f81563b07d737636c0c5d022ee172e2b.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      处于燃烧房间中的猫说：“一切正常。”
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;流水线是-devops-工程师的生产系统&#34;&gt;流水线是 DevOps 工程师的生产系统&lt;/h3&gt;
&lt;p&gt;虽然流水线可能不是外部用户与之互动的生产环境，但它们绝对是内部用户 - 例如，软件工程师和&lt;a href=&#34;https://thenewstack.io/our-2023-site-reliability-engineering-wish-list/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;站点可靠性工程师&lt;/a&gt;（SRE）- 与之互动的生产环境。能够观察你的生产环境意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免不必要的长周期时间或更改的引导时间，这会影响提交进入生产所需的时间。&lt;/li&gt;
&lt;li&gt;减少推出新功能和错误修复的等待时间。&lt;/li&gt;
&lt;li&gt;缩短用户等待时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;代码可能会失败&#34;&gt;代码可能会失败&lt;/h3&gt;
&lt;p&gt;CI/CD 流水线由定义其工作方式的代码运行，尽管你付出了最大的努力，代码仍然可能会失败。使应用程序代码可观测有助于你在遇到生产问题时理清头绪。同样，了解你的流水线可以帮助你了解它们失败时发生了什么。&lt;/p&gt;
&lt;h3 id=&#34;故障排除更容易&#34;&gt;故障排除更容易&lt;/h3&gt;
&lt;p&gt;具有可观测的流水线有助于回答以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么失败了？&lt;/li&gt;
&lt;li&gt;为什么失败了？&lt;/li&gt;
&lt;li&gt;是否曾经失败过？&lt;/li&gt;
&lt;li&gt;最常发生了什么失败？&lt;/li&gt;
&lt;li&gt;流水线的正常运行时间是多少？&lt;/li&gt;
&lt;li&gt;是否存在任何瓶颈？如果有，它们是什么？&lt;/li&gt;
&lt;li&gt;你能够缩短修复流水线问题的导向时间吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;想要收集什么样的数据&#34;&gt;想要收集什么样的数据？&lt;/h3&gt;
&lt;p&gt;要回答这些问题，你需要收集有关你的流水线的信息。但是这些信息应该是什么呢？捕获诸如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分支名称。&lt;/li&gt;
&lt;li&gt;提交的安全哈希算法（SHA）。&lt;/li&gt;
&lt;li&gt;机器 IP。&lt;/li&gt;
&lt;li&gt;运行类型（按计划执行，由合并/推送触发）。&lt;/li&gt;
&lt;li&gt;失败的步骤。&lt;/li&gt;
&lt;li&gt;步骤持续时间。&lt;/li&gt;
&lt;li&gt;构建编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何观察流水线&#34;&gt;如何观察流水线&lt;/h2&gt;
&lt;p&gt;请记住，当系统发出足够的信息来回答问题：“为什么会发生这种情况？”时，系统就是可观测的。首先，你需要一种方法来发出这些信息；然后，你需要一个发送信息的地方；最后，你需要分析信息并找出需要修复的问题。&lt;/p&gt;
&lt;p&gt;这就是 OpenTelemetry 的用武之地。你可以在系统中实施 OpenTelemetry，以发出你需要实现系统可观测性的信息。与用于应用程序的方式一样，你也可以将其用于 CI/CD 流水线！仍然需要将生成的遥测数据发送到后端进行分析，但我们将专注于第一个部分，即仪器化。&lt;/p&gt;
&lt;h3 id=&#34;使用-opentelemetry&#34;&gt;使用 OpenTelemetry&lt;/h3&gt;
&lt;p&gt;对于仪器化 CI/CD 流水线来说，OpenTelemetry 是一个很合理的选择，因为许多人已经在应用程序中使用它进行仪器化；在过去的几年中，采用和实施逐渐增加。&lt;/p&gt;
&lt;h3 id=&#34;有哪些选项&#34;&gt;有哪些选项？&lt;/h3&gt;
&lt;p&gt;目前，情况有些复杂。存在以下选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商业 SaaS 监控解决方案，如&lt;a href=&#34;https://www.datadoghq.com/product/ci-cd-monitoring/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Datadog&lt;/a&gt;和&lt;a href=&#34;https://www.splunk.com/en_us/blog/learn/ci-cd-devops-analytics.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Splunk&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;供应商创建的工具，你可以将其插入现有的 CI/CD 工具中，以帮助实现 CI/CD 可观测性（例如，&lt;a href=&#34;https://github.com/honeycombio/buildevents&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Honeycomb buildevents&lt;/a&gt;、&lt;a href=&#34;https://docs.newrelic.com/docs/codestream/how-use-codestream/cicd/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;New Relic 的 Codestream 与 CircleCI 集成&lt;/a&gt;和&lt;a href=&#34;https://docs.newrelic.com/docs/change-tracking/ci-cd/change-tracking-github-actions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub Actions 的更改跟踪&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;自制的 GitHub actions（请参阅&lt;a href=&#34;https://github.com/inception-health/otel-export-trace-action&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;、&lt;a href=&#34;https://words.boten.ca/GitHub-Action-to-OTLP/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;和&lt;a href=&#34;https://cloud-native.slack.com/archives/C0598R66XAP/p1698393723861129&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;的示例），以在 CI/CD 流水线中启用可观测性。&lt;/li&gt;
&lt;li&gt;自制的 &lt;a href=&#34;https://github.com/DavidS/circleci-hook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CircleCI OTel webhook&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;自制的 &lt;a href=&#34;https://cloud-native.slack.com/archives/C0598R66XAP/p1698408390701199&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Drone CI OTel webhook&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;将 OpenTelemetry 原生集成到 &lt;a href=&#34;https://plugins.jenkins.io/opentelemetry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jenkins&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/tektoncd/community/blob/main/teps/0124-distributed-tracing-for-tasks-and-pipelines.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tekton&lt;/a&gt; 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你还可以将这些工具集成到你的 CI/CD 流水线中；它们会发出 OpenTelemetry 信号，从而帮助使你的流水线可观测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-java-contrib/blob/main/maven-extension/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maven 构建 OTel 扩展&lt;/a&gt;发出 Java 构建的分布式跟踪。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/collections/community/general/opentelemetry_callback.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ansible OpenTelemetry 回调&lt;/a&gt;跟踪 Ansible playbooks。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dynatrace-oss/junit-jupiter-open-telemetry-extension&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dynatrace 的 JUnit Jupiter OpenTelemetry 扩展&lt;/a&gt;是用于通过 OpenTelemetry 收集 JUnit 测试执行数据的 Gradle 插件。还有一个&lt;a href=&#34;https://github.com/dynatrace-oss/junit-jupiter-open-telemetry-extension/packages/1061205&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maven 版本&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pypi.org/project/pytest-otel/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pytest-otel&lt;/a&gt;记录执行的 Python 测试的分布式跟踪。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/equinix-labs/otel-cli&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;otel-cli&lt;/a&gt;是用 Go 编写的命令行界面（CLI）工具，可使 shell 脚本发出跟踪信号。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/filelogreceiver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Filelog 接收器&lt;/a&gt;（OTel Collector）从文件中读取和解析日志。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/gitproviderreceiver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Git 提供商接收器&lt;/a&gt;（OTel Collector）从 Git 供应商处获取数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;可观测的流水线示例&#34;&gt;可观测的流水线示例&lt;/h2&gt;
&lt;p&gt;以下图表显示了如何使用上述提到的一些工具实现流水线可观测性。假设你正在构建和部署一个 Java 应用程序。你正在使用 Jenkins 来编排构建和部署过程。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-启用了-otel-的-jenkins-cicd-流水线&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;启用了 OTel 的 Jenkins CI/CD 流水线&#34; srcset=&#34;
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/4_huc1771516b10019a0f9db7a99859b125f_108196_04bf2a16501e0d7fe30c9ce76e39afad.webp 400w,
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/4_huc1771516b10019a0f9db7a99859b125f_108196_a5d0354f3fb81ef664dca8f74520c5b4.webp 760w,
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/4_huc1771516b10019a0f9db7a99859b125f_108196_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/4_huc1771516b10019a0f9db7a99859b125f_108196_04bf2a16501e0d7fe30c9ce76e39afad.webp&#34;
               width=&#34;760&#34;
               height=&#34;333&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      启用了 OTel 的 Jenkins CI/CD 流水线
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Jenkins CI/CD 流水线可以通过&lt;a href=&#34;https://plugins.jenkins.io/opentelemetry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jenkins OTel 插件&lt;/a&gt;发出遥测信号。&lt;/li&gt;
&lt;li&gt;在构建阶段中：
&lt;ul&gt;
&lt;li&gt;你可以使用&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-java-contrib/blob/main/maven-extension/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maven OTel 扩展&lt;/a&gt;发出 Java 构建的分布式跟踪。&lt;/li&gt;
&lt;li&gt;如果你的构建包括 shell 脚&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本，你可以使用&lt;a href=&#34;https://github.com/equinix-labs/otel-cli&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;otel-cli&lt;/a&gt;工具来使你的 shell 脚本能够发出跟踪信号。
3. 在测试阶段中，&lt;a href=&#34;https://github.com/dynatrace-oss/junit-jupiter-open-telemetry-extension/packages/1061205&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maven 的 JUnit Jupiter 插件&lt;/a&gt;允许你通过 OpenTelemetry 收集 JUnit 测试执行数据。
4. 在打包阶段中，使用 Artifactory 来打包你的应用程序，你可以将其日志发送给 OTel Collector，通过&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/filelogreceiver/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Filelog 接收器&lt;/a&gt;进行解析，该接收器会从文件中读取和解析日志。
5. 在部署阶段，使用 Ansible 来编排你的部署，&lt;a href=&#34;https://docs.ansible.com/ansible/latest/collections/community/general/opentelemetry_callback.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ansible OpenTelemetry 回调&lt;/a&gt;会将跟踪添加到你的 Ansible playbooks 中。如果你的 Ansible playbook 还使用 shell 脚本，它可以利用&lt;a href=&#34;https://github.com/equinix-labs/otel-cli&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;otel-cli&lt;/a&gt;工具，使你的 shell 脚本发出额外的跟踪数据。
6. 各种插件发出的信号被 OTel Collector 捕获。可以使用标准的&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector/tree/main/receiver/otlpreceiver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OTLP 接收器&lt;/a&gt;来接收遥测数据，以及&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/gitproviderreceiver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Git 提供商接收器&lt;/a&gt;和&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/filelogreceiver/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Filelog 接收器&lt;/a&gt;。然后，Collector 将遥测信号发送到可观测性后端。
7. 一旦你的数据到达可观测性后端，你可以查看和查询数据，设置警报等等。&lt;/p&gt;
&lt;h2 id=&#34;实现可观测流水线的挑战&#34;&gt;实现可观测流水线的挑战&lt;/h2&gt;
&lt;p&gt;虽然使用 OpenTelemetry 实现 CI/CD 流水线可观测性是有道理的，但缺乏标准化，工具情况有点混乱。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 并未集成到大多数 CI/CD 工具中。虽然有人希望将观察能力添加到诸如 GitLab 和 GitHub Actions 等 CI/CD 工具中，但这些倡议进展缓慢。例如，尽管&lt;a href=&#34;https://gitlab.com/gitlab-org/gitlab/-/issues/338943&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitLab 有关使用 OTel 进行流水线可观测性的请求&lt;/a&gt;存在活动，但该请求已经开放了两年。&lt;a href=&#34;https://github.com/open-telemetry/oteps/pull/223&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;有关 CI/CD 流水线可观测性的 OTel 提案&lt;/a&gt;于 2023 年 1 月提出，但（截至 2023 年 11 月）自 7 月以来尚未有任何活动。&lt;/p&gt;
&lt;p&gt;因此，如果你想使用这些工具，你将取决于创建自己工具的个人和组织是否愿意维护这些工具。如果他们决定不再维护这些工具，会发生什么呢？&lt;/p&gt;
&lt;h2 id=&#34;了解更多&#34;&gt;了解更多&lt;/h2&gt;
&lt;p&gt;使你的 CI/CD 流水线可观测有助于更有效地排除问题，实现开发敏捷性，并深入了解其内部工作原理，以便你可以调整它们以使其运行更高效。&lt;/p&gt;
&lt;p&gt;健康的流水线意味着你可以连续编写、构建、测试和部署新代码。相反，不健康的流水线可能意味着部署较慢，测试问题和技术债务。&lt;/p&gt;
&lt;p&gt;你可以使用 OpenTelemetry 在流水线中添加可观测性；尽管当前选项有限，但事情正在朝着正确的方向发展，我们对 CI/CD 的未来充满期待！&lt;/p&gt;
&lt;p&gt;进一步阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://logz.io/learn/cicd-observability-jenkins&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;解决慢和不稳定的 CI/CD 流水线始于可观测性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/pulse/leveraging-opentelemetry-enhance-ansible-jaeger-tracing-infralovers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;利用 OpenTelemetry 增强 Ansible 的 Jaeger 跟踪&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.splunk.com/en_us/blog/learn/monitoring-ci-cd.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CI/CD 流水线监控：简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在&lt;a href=&#34;https://communityinviter.com/apps/cloud-native/cncf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Slack&lt;/a&gt;的&lt;a href=&#34;https://cloud-native.slack.com/archives/C0598R66XAP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cicd-o11y&lt;/a&gt;频道中查看更多信息。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>为什么 Prometheus 查询很难？</title>
      <link>https://cloudnative.to/blog/why-are-prometheus-queries-hard/</link>
      <pubDate>Tue, 10 Oct 2023 10:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/why-are-prometheus-queries-hard/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://fiberplane.com/blog/why-are-prometheus-queries-hard&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://fiberplane.com/blog/why-are-prometheus-queries-hard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Prometheus 是一个强大的开源可观测性工具。但是许多人，包括我自己，都很难理解其查询语言。在这篇文章中，我将从头开始建立一个基本的查询，并使用每个步骤来解释 PromQL 中一些较难理解的方面。希望这能更直观地展示 Prometheus 的工作原理，帮助你编写查询并理解数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于&lt;a href=&#34;https://autometrics.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Autometrics&lt;/a&gt;项目的一个快速介绍：它是一个开源微型框架，使你可以轻松地为代码添加最有用的指标，并为你编写 Prometheus 查询。无需手动编写查询，即可在生产环境中识别和调试问题！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;用简单的查询回答问题&#34;&gt;用“简单”的查询回答问题&lt;/h2&gt;
&lt;p&gt;假设我们正在运行一个 HTTP API，并且我们想了解用户遇到错误的频率。这似乎是一个简单的问题，对吧？&lt;/p&gt;
&lt;p&gt;为了从 Prometheus 中获取这个答案，我们需要进行类似以下的查询，其中已经涉及了很多内容：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sum by (status) (rate(http_requests_total[5m]))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了理解为什么这个查询有效，以及为什么我们需要这个查询，我们需要深入了解 Prometheus 如何存储数据以及一些关键的 PromQL 功能。在接下来的几节中，我们将逐步构建这个查询，同时花时间理解每个部分的作用以及为什么它是必要的。&lt;/p&gt;
&lt;h2 id=&#34;计数器主要是递增的&#34;&gt;计数器主要是递增的&lt;/h2&gt;
&lt;p&gt;Prometheus 最重要且最令人困惑的一个方面是，它跟踪的大多数值都是递增的。Prometheus 不会存储每个小时间段发生的事件数量。相反，它跟踪的是随着时间累积的总数。这既是 Prometheus 效率的来源，也是在编写查询时造成困惑的主要原因之一。&lt;/p&gt;
&lt;p&gt;当你在应用程序中创建一个计数器时，它将使用内存中存储的一个简单数字来跟踪事件发生的总次数。Prometheus 每隔几秒钟抓取这些数据并存储它所观察到的总数。如果你想要计算在特定时间段内事件发生的次数，你需要编写一个查询，从 Prometheus 实际存储的累积总数中提取这些信息（我们将在下面详细介绍）。&lt;/p&gt;
&lt;p&gt;为了说明这一点和后续的内容，有一个有关 Prometheus 内部数据的心智模型是很有用的。下面是一个简化的图片，显示了一个跟踪服务的 HTTP 请求总数的计数器。请注意，每个计数器的值在不同的时间段内要么增加，要么保持不变。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/1_huf043d28e52d76f54617a7ba3cb26ae3e_112856_42be651e62d0366c37dc4ba030f75d4d.webp 400w,
               /blog/why-are-prometheus-queries-hard/1_huf043d28e52d76f54617a7ba3cb26ae3e_112856_be5f95248e820ce08ca39b2562c1c5c5.webp 760w,
               /blog/why-are-prometheus-queries-hard/1_huf043d28e52d76f54617a7ba3cb26ae3e_112856_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-are-prometheus-queries-hard/1_huf043d28e52d76f54617a7ba3cb26ae3e_112856_42be651e62d0366c37dc4ba030f75d4d.webp&#34;
               width=&#34;760&#34;
               height=&#34;264&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;每个时间点上，我们看到的是自开始以来到该时间点的 HTTP 请求的&lt;em&gt;总数&lt;/em&gt;，而不是自上次观察以来的请求数量。&lt;/p&gt;
&lt;p&gt;为什么我们说计数器“主要”是递增的，而不是总是递增的？因为有重新启动和崩溃的情况。如果你的服务由于任何原因重新启动，它在内存中存储的计数器值将被重置为零，并重新开始计数。PromQL 具有处理计数器重置的特殊函数，因此你的派生统计数据是正确的。&lt;/p&gt;
&lt;p&gt;现在我们知道计数器主要是递增的，我们可以开始查询数据并利用它。&lt;/p&gt;
&lt;h2 id=&#34;即时向量和范围向量&#34;&gt;即时向量和范围向量&lt;/h2&gt;
&lt;p&gt;PromQL 有两种主要类型的数据：即时向量和范围向量 - 这两个术语让我的眼睛立刻变得模糊。&lt;/p&gt;
&lt;p&gt;下面是即时向量和范围向量之间的区别的示例。即时向量以橙色显示，是一个时间点上的值的快照。范围向量以蓝色显示，每个系列的每个时间点都有一个值。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/2_hu4febf0279dbbc0aa5f55140ce699a828_148402_3c8ae426f8d58a57041244cd65434a63.webp 400w,
               /blog/why-are-prometheus-queries-hard/2_hu4febf0279dbbc0aa5f55140ce699a828_148402_6cf61867895d5ad0d8eea7a6d7f75fa5.webp 760w,
               /blog/why-are-prometheus-queries-hard/2_hu4febf0279dbbc0aa5f55140ce699a828_148402_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-are-prometheus-queries-hard/2_hu4febf0279dbbc0aa5f55140ce699a828_148402_3c8ae426f8d58a57041244cd65434a63.webp&#34;
               width=&#34;760&#34;
               height=&#34;291&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为什么我们有两种类型的向量呢？如果要绘制图形，你需要一个即时向量，因为图形每个时间点只能显示一个值。然而，你很少想绘制随时间累积的事件总数。相反，你经常希望绘制随时间变化的事件速率，为此需要将统计函数应用于一系列数据，以计算每个时间点要显示的值。这就是范围向量的用途。&lt;/p&gt;
&lt;p&gt;让我们看一下如何开始构建一个查询，这也展示了查询中微小差异如何改变我们是在使用即时向量还是范围向量。&lt;/p&gt;
&lt;p&gt;如果我们将以下查询发送到 Prometheus，我们将获得以下即时向量。请注意，它只是上面表格中的最后一列数据。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http_requests_total
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/3_hu6e253b7687f059d1721aa606804eee54_71414_9b190f3cdc88ee540c93fa9d7ecbaaae.webp 400w,
               /blog/why-are-prometheus-queries-hard/3_hu6e253b7687f059d1721aa606804eee54_71414_7d903ee81ea8c72e54590f190b0bced3.webp 760w,
               /blog/why-are-prometheus-queries-hard/3_hu6e253b7687f059d1721aa606804eee54_71414_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-are-prometheus-queries-hard/3_hu6e253b7687f059d1721aa606804eee54_71414_9b190f3cdc88ee540c93fa9d7ecbaaae.webp&#34;
               width=&#34;760&#34;
               height=&#34;408&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此查询返回一个范围向量，显示每个系列的最后 5 分钟数据：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http_requests_total[5m]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/4_hu454bde1e9be2503834e3b32542f9979f_83728_311a3f1b182fe78e60894b4824bc3513.webp 400w,
               /blog/why-are-prometheus-queries-hard/4_hu454bde1e9be2503834e3b32542f9979f_83728_e5c25a4f6b70a972452d3e4433e7dece.webp 760w,
               /blog/why-are-prometheus-queries-hard/4_hu454bde1e9be2503834e3b32542f9979f_83728_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-are-prometheus-queries-hard/4_hu454bde1e9be2503834e3b32542f9979f_83728_311a3f1b182fe78e60894b4824bc3513.webp&#34;
               width=&#34;760&#34;
               height=&#34;408&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些数据有什么用？这就引出了我们的下一个主题。&lt;/p&gt;
&lt;h2 id=&#34;为什么通常需要使用rate&#34;&gt;为什么通常需要使用&lt;code&gt;rate&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;我们之前提到，计数器会跟踪随时间累积的总数，但我们经常希望看到显示特定时间点上发生了多少事件的图形。这就是速率的用途。&lt;/p&gt;
&lt;p&gt;速率函数显示在一定时间范围内计算出的每秒平均事件数量。&lt;code&gt;一定时间范围&lt;/code&gt;就是范围向量的用途。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;rate(http_requests_total[5m])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/5_huff48bf47c86c87c7ff01452797d30457_79928_953b1af5f57749b5f08f6f5532de1333.webp 400w,
               /blog/why-are-prometheus-queries-hard/5_huff48bf47c86c87c7ff01452797d30457_79928_887a84c5b9bc1994a2fd6a19b176ce3f.webp 760w,
               /blog/why-are-prometheus-queries-hard/5_huff48bf47c86c87c7ff01452797d30457_79928_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-are-prometheus-queries-hard/5_huff48bf47c86c87c7ff01452797d30457_79928_953b1af5f57749b5f08f6f5532de1333.webp&#34;
               width=&#34;760&#34;
               height=&#34;408&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些数字看起来突然变得更加复杂，但第一个值只是表示在 5 分钟窗口内发生了一个事件：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/6_hu198abe4e23d3d67954191585cabfde4b_30154_7317dd346eaa5f23a1ce65459122932c.webp 400w,
               /blog/why-are-prometheus-queries-hard/6_hu198abe4e23d3d67954191585cabfde4b_30154_c1a5a445cb8b5f84e609e27a68b1362f.webp 760w,
               /blog/why-are-prometheus-queries-hard/6_hu198abe4e23d3d67954191585cabfde4b_30154_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-are-prometheus-queries-hard/6_hu198abe4e23d3d67954191585cabfde4b_30154_7317dd346eaa5f23a1ce65459122932c.webp&#34;
               width=&#34;760&#34;
               height=&#34;63&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;现在，如果我们将此查询绘制成图表而不是查看表格视图，图表上的每个点将是给定时间点每秒发生的请求数。这更接近我们实际关心的内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rate&lt;/code&gt;函数还处理计数器重置。因此，如果你的服务崩溃，Prometheus 观察到计数器从 1000 变为 5，它将使用在这些抓取之间发生了 5 个事件的事实来计算速率。&lt;/p&gt;
&lt;h2 id=&#34;标签集和通常需要使用sum-by&#34;&gt;标签集和通常需要使用&lt;code&gt;sum by&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在继续构建我们的查询之前，重要的是花一点时间了解 Prometheus 标签。Prometheus 为每个唯一的标签值组合存储一个单独的时间序列。&lt;/p&gt;
&lt;p&gt;在我们的示例表中，我们有带有&lt;code&gt;path&lt;/code&gt;和&lt;code&gt;status&lt;/code&gt;标签的计数器&lt;code&gt;http_requests_total&lt;/code&gt;。对于每个&lt;code&gt;path&lt;/code&gt;和&lt;code&gt;status&lt;/code&gt;的组合，我们为每个时间戳存储一个计数器值。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/7_huff140567d1675e9bb8ae4de74917817e_61794_9ecc3da701c5f479524df74c951df26b.webp 400w,
               /blog/why-are-prometheus-queries-hard/7_huff140567d1675e9bb8ae4de74917817e_61794_97ad599d75df916c8ba94bd767f399e0.webp 760w,
               /blog/why-are-prometheus-queries-hard/7_huff140567d1675e9bb8ae4de74917817e_61794_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-are-prometheus-queries-hard/7_huff140567d1675e9bb8ae4de74917817e_61794_9ecc3da701c5f479524df74c951df26b.webp&#34;
               width=&#34;760&#34;
               height=&#34;652&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;（这也是为什么人们经常谈论“标签基数问题”或&lt;a href=&#34;https://blog.cloudflare.com/how-cloudflare-runs-prometheus-at-scale/#metrics-cardinality&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;“基数爆炸”&lt;/a&gt;。你对给定标签的每个新值都需要存储一个新的时间序列。如果存储的标签变化太大，例如用户 ID，你将创建过多的时间序列并导致 Prometheus 数据库膨胀。）&lt;/p&gt;
&lt;p&gt;在查询数据时，我们通常关心其中一些标签维度，而不关心其他标签。在 PromQL 中，&lt;code&gt;sum by (label1, label2，…)&lt;/code&gt;按你指定的标签对时间序列进行分组，并使用&lt;code&gt;sum&lt;/code&gt;函数将系列合并在一起（类似于 SQL 中的&lt;code&gt;GROUP BY&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;回到我们的示例表，我们只有两个标签：&lt;code&gt;path&lt;/code&gt;和&lt;code&gt;status&lt;/code&gt;。如果我们想查看每个&lt;code&gt;path&lt;/code&gt;的每秒请求数，而忽略&lt;code&gt;status&lt;/code&gt;，我们将使用以下查询：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sum by (path) (rate(http_requests_total[5m]))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在实际的 Prometheus 部署中，我们通常有更多的标签。例如，Prometheus 会自动添加作业（job）和实例（instance）标签来标识它正在抓取的每个唯一目标。然而，我们可能不关心针对服务的每个实例单独查看指标，因此我们需要使用我们关心的标签进行求和，让 Prometheus 对其余部分进行求和。&lt;/p&gt;
&lt;p&gt;最后，这使我们回到了最初的查询。如果我们想查看返回不同 HTTP 状态代码的请求数，而与路径无关，我们可以使用此查询，并会看到以下结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sum by (status) (rate(http_requests_total[5m]))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/8_hu3408895e88969762328e60a39820c92c_42226_1f866cfab36e8d493da45d279314b379.webp 400w,
               /blog/why-are-prometheus-queries-hard/8_hu3408895e88969762328e60a39820c92c_42226_c012d176bfc2c3239200e96b001257b5.webp 760w,
               /blog/why-are-prometheus-queries-hard/8_hu3408895e88969762328e60a39820c92c_42226_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-are-prometheus-queries-hard/8_hu3408895e88969762328e60a39820c92c_42226_1f866cfab36e8d493da45d279314b379.webp&#34;
               width=&#34;760&#34;
               height=&#34;288&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sum by (labels) (rate(metric[5m]))&lt;/code&gt;这种构造方式非常有用，值得记住。&lt;/p&gt;
&lt;p&gt;不幸的是，除了与 PromQL 相关的特定问题之外，还有许多重要问题需要注意。&lt;/p&gt;
&lt;h2 id=&#34;我是否在查看正确的数据&#34;&gt;我是否在查看正确的数据？&lt;/h2&gt;
&lt;p&gt;工程师经常遇到的另外两个挑战与查询语言本身无关。&lt;/p&gt;
&lt;p&gt;首先，应该使用哪些指标来回答特定的问题？组织可能有数千个指标，如果没有经验，很难知道有哪些可用，并且哪些可能有助于调查特定类型的问题。预先构建的仪表板和查询可能会在一定程度上帮助，但许多组织也面临一个问题，即有太多的仪表板，人们不知道该看哪个。&lt;/p&gt;
&lt;p&gt;第二个甚至更为严重的问题是，你编写的查询是否显示了你认为它显示的内容。你可能会花费很多时间编写查询，并最终得到正确的语法。但它是否在统计上是正确的？从根本上说，Prometheus 不知道。这些时间序列只是一堆附带字符串标签的数字。Prometheus 不知道不同指标的含义，因此无法帮助你编写好的查询或告诉你所查看的图形是否回答了你的实际问题。这尤其危险，因为错误的查询可能会让你在调试事故时陷入无用的路径，或者可能会建议一种实际上无法解决问题的修复方法。&lt;/p&gt;
&lt;h2 id=&#34;结论promql-查询很难&#34;&gt;结论：PromQL 查询很难&lt;/h2&gt;
&lt;p&gt;编写好的查询需要对系统的了解，对查询语言语法的理解，甚至还需要一些统计知识。在本文中，我们只是浅尝辄止！所有这些都很难掌握，绝对不是你希望在服务崩溃并且用户在抱怨时学习的内容。在任何查询语言中编写查询都很困难，PromQL 也不例外。&lt;/p&gt;
&lt;h2 id=&#34;autometrics-为你编写-promql&#34;&gt;Autometrics 为你编写 PromQL&lt;/h2&gt;
&lt;p&gt;在 Fiberplane 为 DevOps 和站点可靠性工程师制作协作笔记本时，我们一直听到工程师说“查询很难”。这就是我们创建开源项目 Autometrics 的动机。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://autometrics.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Autometrics&lt;/a&gt;基于现有的 Prometheus 和 OpenTelemetry 客户端库，并使你的代码中的函数使用最有用的指标（请求速率、错误率和延迟）非常简单。它&lt;a href=&#34;https://fiberplane.com/blog/the-case-for-function-level-metrics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标准化这些指标&lt;/a&gt;，然后根据函数详细信息为你构建强大的 PromQL 查询。这改进了对代码的仪表化体验，并极大地简化了在生产环境中识别和调试问题的过程。&lt;/p&gt;
&lt;p&gt;如果你正在使用 Prometheus，但不喜欢手动编写查询，请尝试将其添加到你的项目之一！它现在可用于 Rust、Go、Python、TypeScript 和 C#。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OpenTelemetry Protocol (OTLP) 1.0.0 发布</title>
      <link>https://cloudnative.to/blog/otlp-version-one-released/</link>
      <pubDate>Sun, 06 Aug 2023 13:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/otlp-version-one-released/</guid>
      <description>&lt;p&gt;摘要：OpenTelemetry Protocol (OTLP) 1.0.0 已发布，它是 OpenTelemetry 项目中的通用遥测数据传递协议。OpenTelemetry 是一个开源的可观测性框架，提供了一组 API、库、代理和收集器服务，用于捕获分布式跟踪和指标。OTLP 在客户端和服务器之间进行数据交换，定义了一个序列化模式，紧密遵循跟踪、指标和日志的数据模型。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&#34;https://www.infoq.com/news/2023/08/otlp-version-one-released/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.infoq.com/news/2023/08/otlp-version-one-released/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近，&lt;a href=&#34;https://opentelemetry.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt; Protocol (OTLP) 1.0.0 发布了。OTLP 规范描述了遥测数据在遥测源、收集器等中间节点和遥测后端之间的编码、传输和传递机制。它是 OpenTelemetry 项目中设计的通用遥测数据传递协议。&lt;/p&gt;
&lt;p&gt;OpenTelemetry (OTEL) 是一个由 OpenCensus 和 OpenTracing 项目合并形成的开源 Cloud Native Computing Foundation (CNCF) 项目。它是一个供仪表化、生成、收集和导出遥测数据（例如跟踪、指标和日志）使用的供应商中立的开源可观测性框架。该框架提供了一组 API、库、代理和收集器服务，用于捕获分布式跟踪和指标。此外，它的规范在 2021 年早些时候达到了 1.0.0 版本状态，并被 InfoQ 报道。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 通过使用 API 来仪表化应用程序代码，以生成遥测数据，并在不同的 SDK 实现之间无缝地引导收集指标。它提供了针对特定语言的集成和库，例如 Java、Golang、.NET 和 Python 的 OTel SDK，以使开发人员能够仪表化其代码并捕获遥测数据。这些库中的遥测数据被收集并传输到 OpenTelemetry Collector，利用 OTLP 在客户端和服务器之间进行数据交换。OTLP 定义了一个序列化模式，紧密遵循跟踪、指标和日志的数据模型。&lt;/p&gt;
&lt;p&gt;作为中央存储库，OpenTelemetry Collector 接收、处理和导出从各种源收集的遥测数据，既作为单个应用程序的本地代理，也作为多个应用程序的网关。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-opentelemetry-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;OpenTelemetry 架构图&#34;
           src=&#34;https://cloudnative.to/blog/otlp-version-one-released/otel-diagram.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      OpenTelemetry 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Open Telemetry Diagram（来源：&lt;a href=&#34;https://opentelemetry.io/docs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 文档&lt;/a&gt;）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;OTLP 在数据序列化、反序列化和网络服务之间的传输方面发挥着重要作用。该协议旨在指定一个序列化模式，紧密遵循数据模型并解决其他遥测协议的问题。&lt;/p&gt;
&lt;p&gt;Honeycomb 开发者倡导者 &lt;a href=&#34;https://twitter.com/MartinDotNet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Martin Thwaites&lt;/a&gt; 说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OTLP 是 OpenTelemetry 的生命力，使其比以往任何时候都更强大；转向 v1 将把这一点提升到一个新的水平。已经有大多数供应商适应了使用 OTLP 协议接收数据；通过 V1，这将给人们带来一些急需的信心，希望可以让最后几个顽固分子添加 OTLP 支持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外，他表示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这很重要，因为它开启了更多的互操作性，减少了添加专有协议库到我们堆栈中的需求，这对于希望更好地了解其应用程序的情况下获得更多可见性的人来说只能是一个胜利。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，OpenTelemetry 项目目前是 CNCF 的&lt;a href=&#34;https://www.cncf.io/projects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;孵化项目&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何利用 OpenTelemetry 监控和优化 Kubernetes 的性能</title>
      <link>https://cloudnative.to/blog/how-opentelemetry-works-with-kubernetes/</link>
      <pubDate>Tue, 09 May 2023 16:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/how-opentelemetry-works-with-kubernetes/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;摘要：本文译自 &lt;a href=&#34;https://thenewstack.io/how-opentelemetry-works-with-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How OpenTelemetry Works with Kubernetes&lt;/a&gt;。本文介绍了如何将 OpenTelemetry 与 Kubernetes 配合使用。OpenTelemetry 可以作为 Prometheus 的替代品，也可以将数据导出到各种后端，包括 Prometheus。OpenTelemetry Operator 负责部署和管理 OpenTelemetry Collector，该组件是收集、处理和导出遥测数据的中央组件。OpenTelemetry 日志提供了一种标准化的方式来收集、处理和分析分布式系统中的日志。此外，本文还介绍了 OpenTelemetry 的下一步计划，包括 Web 服务器的自动化仪器化、OpenTelemetry Profile 和 Open Agent Management Protocol。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OpenTelemetry 的主要目标是提供一种标准的方式，使开发人员和最终用户能够从他们的应用程序和系统中创建、收集和导出遥测数据，并促进不同可观察性工具和平台之间的互操作性。&lt;/p&gt;
&lt;p&gt;OTEL 支持多种编程语言，包括 &lt;a href=&#34;https://thenewstack.io/getting-started-with-opentelemetry-for-java/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Java&lt;/a&gt;、&lt;a href=&#34;https://thenewstack.io/an-introduction-to-python-a-language-for-the-ages/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Python&lt;/a&gt;、&lt;a href=&#34;https://thenewstack.io/opentelemetry-in-go-its-all-about-context/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go&lt;/a&gt;、&lt;a href=&#34;https://thenewstack.io/why-were-sticking-with-ruby-on-rails-at-gitlab/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ruby&lt;/a&gt; 等，因此可以从不同类型的应用程序和系统中收集遥测数据，是一种多用途的解决方案。&lt;/p&gt;
&lt;p&gt;一旦 OpenTelemetry 组件收集到遥测数据，就可以将其导出到各种后端，如软件即服务解决方案、平台或存储系统，提供存储和查询功能。OpenTelemetry 提供与各种后端的集成，包括 &lt;a href=&#34;https://prometheus.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus&lt;/a&gt;、Jaeger、&lt;a href=&#34;https://zipkin.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zipkin&lt;/a&gt; 等，使导出遥测数据到不同系统变得更加容易。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中使用 OTEL 并不困难。实际上，安装 &lt;a href=&#34;https://thenewstack.io/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 的 OTEL Operator 是一个简单的过程，在本文中，您将学习如何执行此操作。&lt;/p&gt;
&lt;p&gt;通过此 Operator，您可以轻松地管理 Kubernetes 集群中的 OpenTelemetry 组件，并将其配置为导出遥测数据到您选择的后端。这简化了监视 Kubernetes 集群的过程，并使您能够对应用程序的健康和性能做出明智的决策。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-的基本组件&#34;&gt;OpenTelemetry 的基本组件&lt;/h2&gt;
&lt;p&gt;前四个组件用于仪器开发人员或可观察性公司创建可观察性产品。&lt;/p&gt;
&lt;h3 id=&#34;规范&#34;&gt;规范&lt;/h3&gt;
&lt;p&gt;规范提供了定义这些组件的行为和功能的标准化方式，确保在不同的 OpenTelemetry 实现之间保持一致性和兼容性。例如，规范定义了跟踪和指标数据的格式和语义，确保它们可以被系统中的其他组件正确解释。&lt;/p&gt;
&lt;h3 id=&#34;api&#34;&gt;API&lt;/h3&gt;
&lt;p&gt;OpenTelemetry API 为开发人员提供了一种标准的方式来使用跟踪、指标和其他遥测数据对其应用程序进行仪器化。该 API 是语言不可知的，并允许在不同的编程语言和框架之间进行一致的仪器化。&lt;/p&gt;
&lt;p&gt;API 为开发人员提供了一种标准的方式来使用跟踪和指标对其应用程序进行仪器化。&lt;/p&gt;
&lt;h3 id=&#34;sdk&#34;&gt;SDK&lt;/h3&gt;
&lt;p&gt;OpenTelemetry SDK 提供了 OpenTelemetry API 的语言特定实现。SDK 通过提供用于收集和导出遥测数据的库和实用程序，使开发人员更轻松地对其应用程序进行仪器化。&lt;/p&gt;
&lt;h3 id=&#34;数据模型---otlp&#34;&gt;数据模型 - OTLP&lt;/h3&gt;
&lt;p&gt;OpenTelemetry 数据模型提供了一种用于遥测数据的标准化格式，称为 OTLP（OpenTelemetry 协议）。OTLP 是一种供应商中立的格式，使将遥测数据导出到不同的后端和分析工具变得更加容易。&lt;/p&gt;
&lt;p&gt;最后两个组件，OpenTelemetry 自动仪器化和收集器，适用于希望从其应用程序收集和导出遥测数据到不同后端的开发人员，而无需编写自己的仪器化代码。&lt;/p&gt;
&lt;h3 id=&#34;自动仪器化&#34;&gt;自动仪器化&lt;/h3&gt;
&lt;p&gt;OpenTelemetry 包括一个自动仪器化代理，可以注入具有跟踪和指标的应用程序，而无需任何手动仪器化代码。这使得可以向现有应用程序添加可观察性，而无需进行重大代码更改。&lt;/p&gt;
&lt;p&gt;自动仪器化组件可以下载并安装为库或代理，具体取决于使用的编程语言或框架。自动仪器化库会自动将应用程序代码注入 OpenTelemetry API 调用，以捕获和导出遥测数据。&lt;/p&gt;
&lt;h3 id=&#34;收集器&#34;&gt;收集器&lt;/h3&gt;
&lt;p&gt;收集器组件负责从不同来源（如应用程序、服务器和基础架构组件）收集遥测数据，并将其导出到各种后端。&lt;/p&gt;
&lt;p&gt;收集器可以下载并配置以从不同来源收集数据，并可以执行聚合、采样和其他操作，以在导出到不同后端之前对遥测数据执行处理，具体取决于特定用例。&lt;/p&gt;
&lt;h2 id=&#34;telemetry-数据是如何创建的&#34;&gt;Telemetry 数据是如何创建的&lt;/h2&gt;
&lt;p&gt;我们以一个包含三个工作负载的电子商务应用程序为例——前端、驱动程序和客户端——它们通过 HTTP 相互通信。我们想要收集遥测数据以监视这些应用程序的性能和健康状况。&lt;/p&gt;
&lt;p&gt;为此，我们使用 OpenTelemetry API 为每个应用程序实现仪表化：&lt;code&gt;logger.log()&lt;/code&gt;、&lt;code&gt;meter.record()&lt;/code&gt; 和 &lt;code&gt;tracer.span().start()&lt;/code&gt;。这些 API 允许我们创建遥测信号，例如日志、度量和跟踪。&lt;/p&gt;
&lt;p&gt;创建这些信号后，它们被发送或者由 OpenTelemetry 收集器收集，后者充当集中式数据中心。&lt;/p&gt;
&lt;p&gt;收集器负责处理这些信号，其中包括批处理、重新标记、PII 过滤、数据丢弃和聚合等任务，以确保数据准确和有意义。一旦收集器对数据满意，它就将遥测信号发送到平台进行存储和分析。&lt;/p&gt;
&lt;p&gt;收集器可以配置为将这些处理后的信号发送到各种平台，例如 Prometheus、&lt;a href=&#34;https://github.com/grafana/loki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Loki&lt;/a&gt;、Jaeger 或供应商，例如 &lt;a href=&#34;https://www.dynatrace.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dynatrace&lt;/a&gt;、New Relic 等。&lt;/p&gt;
&lt;p&gt;例如，收集器可以将日志发送到类似 Loki 的日志聚合平台、将指标发送到类似 Prometheus 的监控平台、将跟踪发送到类似 Jaeger 的分布式跟踪平台。平台中存储的遥测数据可以用于深入了解系统的行为和性能，并识别需要解决的任何问题。&lt;/p&gt;
&lt;h2 id=&#34;定义-kubernetes-operator-的行为&#34;&gt;定义 Kubernetes Operator 的行为&lt;/h2&gt;
&lt;p&gt;您可以将 OpenTelemetry Operator 部署到 Kubernetes 集群中，并使其自动为应用程序仪表化和收集遥测数据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://opentelemetry.io/docs/k8s-operator/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Kubernetes Operator&lt;/a&gt; 提供了两个自定义资源定义（CRD），用于定义 Operator 的行为。这两个 CRD 共同允许您为应用程序定义 OpenTelemetry Operator 的完整行为。&lt;/p&gt;
&lt;p&gt;这两个 CRD 是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;otelinst&lt;/code&gt;&lt;/strong&gt; ：此 CRD 用于定义应用程序的仪表化。它指定要使用 OpenTelemetry API 的哪些组件、要收集哪些数据以及如何将该数据导出到后端。&lt;/p&gt;
&lt;p&gt;使用 otelinst CRD，您可以指定要仪表化的应用程序的名称、语言和运行时环境、跟踪的采样率以及要使用的导出器类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;otelcol&lt;/code&gt;&lt;/strong&gt;：此 CRD 用于定义 OpenTelemetry 收集器的行为。它指定收集器的配置，包括接收器（遥测数据源）、处理器（用于过滤和转换数据）和导出器（用于将数据发送到后端）。&lt;/p&gt;
&lt;p&gt;使用 otelcol CRD，您可以指定要用于通信的协议，例如 Google 远程过程调用（gRPC）或 HTTP，要使用哪些接收器和导出器，以及任何其他配置选项。&lt;/p&gt;
&lt;h2 id=&#34;安装-opentelemetry-kubernetes-operator&#34;&gt;安装 OpenTelemetry Kubernetes Operator&lt;/h2&gt;
&lt;p&gt;OpenTelemetry Kubernetes Operator 可以使用各种方法安装，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Operator 生命周期管理器 (OLM)。这是&lt;a href=&#34;https://olm.operatorframework.io/docs/tasks/install-operator-with-olm/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;推荐的方法&lt;/a&gt;，因为它提供了方便的安装、升级和管理 Operator 的方法。&lt;/li&gt;
&lt;li&gt;Helm charts。Helm 是 Kubernetes 的软件包管理器，提供了一种在 Kubernetes 上部署和管理应用程序的简单方法。OpenTelemetry operator 的 Helm charts &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-helm-charts/tree/main/charts/opentelemetry-operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可用&lt;/a&gt;，可用于部署 Operator。&lt;/li&gt;
&lt;li&gt;Kubernetes 清单。Operator 也可以使用 Kubernetes 清单进行安装，后者提供了一种声明性的方式来管理 Kubernetes 资源。Operator 清单可以根据特定要求进行定制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要收集遥测数据，我们需要使用创建遥测信号的代码仪表化我们的应用程序。有不同的方法来为遥测数据仪表化应用程序。&lt;/p&gt;
&lt;h3 id=&#34;显式手动方法&#34;&gt;显式/手动方法&lt;/h3&gt;
&lt;p&gt;在此方法中，开发人员明确向其应用程序添加仪表化代码，以创建日志、度量和跟踪等遥测信号。这种方法使开发人员对遥测数据更具控制力，但可能耗时且容易出错。&lt;/p&gt;
&lt;h3 id=&#34;直接集成在运行时&#34;&gt;直接集成在运行时&lt;/h3&gt;
&lt;p&gt;某些运行时，例如 &lt;a href=&#34;https://quarkus.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quarkus&lt;/a&gt; 和 &lt;a href=&#34;https://www.wildfly.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WildFly&lt;/a&gt; 框架，直接与 OpenTelemetry 集成。这意味着开发人员无需向其应用程序添加仪表化代码，运行时会自动为他们生成遥测数据。这种方法可能更易于使用，要求更少的维护工作，但比显式/手动方法灵活性可能较差。&lt;/p&gt;
&lt;p&gt;直接集成在运行时的主要缺点是，仪表化仅限于支持的框架。如果应用程序使用不受支持的框架，则可能无法有效捕获遥测数据或需要额外的自定义仪表化。&lt;/p&gt;
&lt;p&gt;如果所选运行时或框架仅与特定的可观察性供应商兼容，则此方法还可能导致供应商锁定。&lt;/p&gt;
&lt;p&gt;因此，此方法可能不适用于所有应用程序或组织，特别是如果他们需要在选择可观察性堆栈或需要仪器化各种框架和库时具有灵活性。&lt;/p&gt;
&lt;h3 id=&#34;自动仪表化代理方法&#34;&gt;自动仪表化/代理方法&lt;/h3&gt;
&lt;p&gt;在此方法中，向应用程序运行时添加 OpenTelemetry 代理或自动仪表化库。代理/库自动为应用程序代码创建仪表化并生成遥测数据，而无需开发人员添加仪表化代码。&lt;/p&gt;
&lt;p&gt;这种方法可能是最易于使用的，需要最少的维护工作，但可能不太灵活，并且可能无法捕获所有相关的遥测数据。&lt;/p&gt;
&lt;p&gt;虽然自动仪表化/代理方法具有许多优点，但主要缺点之一是它可能消耗更多的内存和 CPU 周期，因为它支持广泛的框架并为应用程序中几乎所有 API 进行仪表化。这种附加开销可能会影响应用程序的性能，尤其是如果应用程序已经消耗了资源。&lt;/p&gt;
&lt;p&gt;此外，此方法可能无法捕获所有必要的遥测数据，或可能会导致错误的正面或负面结果。例如，它可能无法捕获某些边缘情况，或者可能捕获过多的数据，使查找相关信息变得困难。&lt;/p&gt;
&lt;p&gt;但是，尽管存在这些缺点，自动仪表化/代理方法仍然强烈推荐给刚开始使用观察性的组织，因为它提供了一种快速且简单的方法来快速收集遥测数据。&lt;/p&gt;
&lt;h2 id=&#34;传送遥测数据的收集和导出&#34;&gt;传送遥测数据的收集和导出&lt;/h2&gt;
&lt;p&gt;收集器负责接收来自仪器代码的遥测数据，处理并将其导出到平台进行存储和分析。收集器可以配置各种组件，例如接收器、处理器和导出器，以满足特定需求。&lt;/p&gt;
&lt;p&gt;接收器负责从各种来源（例如代理、导出器或网络）接受数据，而处理器则可以转换、过滤或增强数据。最后，导出器将数据发送到存储或分析平台，例如 Prometheus 或 Jaeger。&lt;/p&gt;
&lt;p&gt;收集器有两个版本，Core 和 Contrib。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-releases/tree/main/distributions/otelcol&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Core&lt;/a&gt; 是官方版本，包含稳定和经过充分测试的组件，而 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Contrib&lt;/a&gt; 是社区驱动版本，包含额外的实验性&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-releases/tree/main/distributions/otelcol-contrib&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;组件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;您还可以通过选择所需的组件并根据您的要求进行配置来构建自己的收集器。收集器用 Go 编写，这使得它易于部署和维护。&lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 网站上的文档&lt;/a&gt;提供了详细的指南，介绍如何设置、配置和使用收集器。&lt;/p&gt;
&lt;p&gt;在某些情况下，OpenTelemetry 可以作为 Prometheus 的替代品，特别是在边缘设备上资源有限的情况下。Prometheus 更加专注于监控和警报，而 OpenTelemetry 则专为可观察性而设计，并提供超出指标以外的功能，包括跟踪和日志记录。&lt;/p&gt;
&lt;p&gt;此外，OpenTelemetry 可以用于将数据导出到各种后端，包括 Prometheus，因此如果您愿意，仍然可以使用 Prometheus 进行监控和警报。OpenTelemetry 的灵活性和可扩展性使您可以将可观察性解决方案定制为符合您的特定需求和资源限制。&lt;/p&gt;
&lt;p&gt;OpenTelemetry Operator 负责部署和管理 OpenTelemetry Collector，该组件是收集、处理和导出遥测数据的中央组件。它不部署其他边车，例如 Envoy，但可以与它们一起工作以收集额外的遥测数据。&lt;/p&gt;
&lt;p&gt;OpenTelemetry Collector 可以以不同的模式部署，例如边车、daemonset、deployment 或 statefulset，具体取决于特定用例和要求。&lt;/p&gt;
&lt;p&gt;但是，如果目标是从群集中的节点收集日志，则将收集器部署为 daemonset 可以是一个不错的选择，因为它确保在每个节点上运行一个收集器实例，从而实现高效且可靠的日志收集。&lt;/p&gt;
&lt;h3 id=&#34;otel-收集器配置&#34;&gt;OTEL 收集器配置&lt;/h3&gt;
&lt;p&gt;以下是使用 otelcol 自定义资源定义部署 OpenTelemetry 收集器的 Kubernetes 清单文件示例：&lt;/p&gt;
&lt;p&gt;在此示例中，我们定义了一个名为 &lt;code&gt;otel-collector&lt;/code&gt; 的收集器，它使用 OTLP 接收器接收跟踪数据，使用 Prometheus 导出器将指标导出到 Prometheus 服务器，并使用两个处理器（&lt;code&gt;batch&lt;/code&gt; 和 &lt;code&gt;queued_retry&lt;/code&gt;）处理数据。config 字段指定收集器的配置，其格式为 YAML。&lt;/p&gt;
&lt;p&gt;使用 OpenTelemetry 收集跟踪、指标和日志在几个方面都很重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;增加可观察性。&lt;/strong&gt; 通过收集和关联跟踪、指标和日志，您可以更好地了解应用程序和系统的性能。增强的可观察性使您能够在影响用户之前快速识别和解决问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;改进故障排除。&lt;/strong&gt; OpenTelemetry 提供了一种收集遥测数据的标准化方式，这使得在整个堆栈中进行故障排除变得更加容易。通过在单个位置访问所有相关遥测数据，您可以快速找到问题的根本原因。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更好的性能优化。&lt;/strong&gt; 有了详细的遥测数据，您可以做出有关如何优化应用程序和系统以实现更好的性能和可靠性的明智决策。例如，通过分析指标，您可以确定系统中未利用或过度利用的区域，并相应地调整资源分配。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨平台兼容性。&lt;/strong&gt; OpenTelemetry 设计用于跨多种编程语言、框架和平台工作，这使得从堆栈的不同部分收集遥测数据变得更加容易。这种互操作性对于使用多种技术并需要在整个堆栈中标准化可观察性实践的组织非常重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;opentelemetry-日志&#34;&gt;OpenTelemetry 日志&lt;/h3&gt;
&lt;p&gt;OpenTelemetry 日志提供了一种标准化的方式来收集、处理和分析分布式系统中的日志。通过使用 OpenTelemetry 收集日志，开发人员可以避免日志分布在多个系统和不同格式的问题，从而难以分析和排除问题。&lt;/p&gt;
&lt;p&gt;使用 OpenTelemetry 日志，开发人员可以从多个来源收集日志，包括传统的日志库，然后使用通用格式和 API 处理和分析它们。这允许更好地与可观察性堆栈的其他部分（例如指标和跟踪）集成，并提供更完整的系统行为视图。&lt;/p&gt;
&lt;p&gt;此外，OpenTelemetry 日志提供了一种将日志与其他上下文信息（例如有关请求、用户或环境的元数据）进行丰富的方法，这些信息可以用于使日志分析更有意义和有效。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-的下一步是什么&#34;&gt;OpenTelemetry 的下一步是什么？&lt;/h2&gt;
&lt;h3 id=&#34;web-服务器的自动化仪器化&#34;&gt;Web 服务器的自动化仪器化&lt;/h3&gt;
&lt;p&gt;OTEL &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-cpp-contrib/tree/main/instrumentation/otel-webserver-module#otel-webserver-module&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;webserver&lt;/a&gt; 模块包括 Apache 和 &lt;a href=&#34;https://www.nginx.com/?utm_content=inline-mention&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nginx&lt;/a&gt; 仪器化。Apache 模块负责在运行时将仪器化注入到 Apache 服务器中，以跟踪传入请求到服务器。它捕获参与传入请求的许多模块的响应时间，包括 mod_proxy。这使得可以捕获每个模块的分层时间消耗。&lt;/p&gt;
&lt;p&gt;类似地，Nginx web 服务器模块也可以通过在运行时将仪器化注入到 Nginx 服务器中来跟踪传入请求到服务器。它捕获涉及请求处理的各个模块的响应时间。&lt;/p&gt;
&lt;h3 id=&#34;opentelemetry-profile&#34;&gt;OpenTelemetry Profile&lt;/h3&gt;
&lt;p&gt;此 &lt;a href=&#34;https://github.com/open-telemetry/oteps/blob/main/text/profiles/0212-profiling-vision.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt; 概述了 OpenTelemetry 项目中的分析支持的长期愿景。该计划是 OpenTelemetry 社区成员之间的讨论和协作的结果，代表了各种行业和专业知识的多元化。&lt;/p&gt;
&lt;p&gt;该文档旨在指导 OpenTelemetry 中的分析支持开发，但并非要求清单。预计随着学习和反馈的增加，该愿景将随时间演化和完善。&lt;/p&gt;
&lt;h3 id=&#34;open-agent-management-protocol&#34;&gt;Open Agent Management Protocol&lt;/h3&gt;
&lt;p&gt;Open Agent Management Protocol (OpAMP) 是一种网络协议，可实现对大型数据收集代理群集的远程管理。它允许代理报告其状态并从服务器接收配置，并从服务器接收代理安装包更新。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/open-telemetry/opamp-spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpAMP&lt;/a&gt; 是供应商无关的，因此服务器可以远程监视和管理实现 OpAMP 的不同供应商的代理群集，包括来自不同供应商的混合代理群集。&lt;/p&gt;
&lt;p&gt;它支持代理的远程配置、状态报告、代理自身的遥测报告、可下载特定于代理的软件包的管理、安全自动更新功能和连接凭据管理。此功能允许管理大型混合代理群集的单个窗口视图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>以图形重构 Kubernetes 可观测性</title>
      <link>https://cloudnative.to/blog/reframing-kubernetes-observability-with-a-graph/</link>
      <pubDate>Sat, 06 May 2023 06:27:22 +0800</pubDate>
      <guid>https://cloudnative.to/blog/reframing-kubernetes-observability-with-a-graph/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://thenewstack.io/reframing-kubernetes-observability-with-a-graph/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Reframing Kubernetes Observability with a Graph&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;摘要：本文介绍了将 DevOps 和 Kubernetes 视为图形的方法，以提高效率和弹性。通过将 Kubernetes 部署中的不同组件建模为图中的节点，组织可以更好地了解不同组件的交互方式以及一个区域的更改如何影响整个系统。这可以帮助组织采取更为主动、战略性的 DevOps 方法，而不仅仅是在问题出现时做出反应。&lt;/p&gt;
&lt;p&gt;Kubernetes 可以跨多个主机部署应用程序，同时让团队将它们作为单个逻辑单元进行管理。它抽象了底层基础架构，并提供了一个用于与集群交互的统一 API，以及用于简化工作流程的自动化。它是现代开发实践的完美系统。&lt;/p&gt;
&lt;p&gt;但在这些以云为先的生态系统中确保效率和弹性并不容易。微服务架构使得无法跟上正在不断发生的所有软件和基础架构变化。这个问题只会因分裂的监视和可观测工具以及团队和个人之间的隔离信息而变得更加严重。&lt;/p&gt;
&lt;p&gt;为了跟上，组织必须以一种新的方式考虑 DevOps 和 Kubernetes - 作为一个图形。&lt;/p&gt;
&lt;h2 id=&#34;将-devops-视为图形&#34;&gt;将 DevOps 视为图形&lt;/h2&gt;
&lt;p&gt;DevOps 通常专注于自动化和集成，而不考虑底层工具和流程之间的关系和依赖关系。另一方面，将 &lt;a href=&#34;https://thenewstack.io/devops-as-a-graph-for-real-time-troubleshooting/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DevOps 视为图形&lt;/a&gt; 更加注重这些连接，以提供更好的上下文，从而导致更有效的操作。传统的 DevOps 方法通常依赖于线性、顺序工作流，而将 DevOps 视为图形有助于组织采用更全面、基于系统的方法。&lt;/p&gt;
&lt;p&gt;通过将 DevOps 流水线的不同组件建模为图中的节点，组织可以更好地了解不同组件的交互方式以及一个区域的更改如何影响整个系统。这可以帮助组织采取更为主动、战略性的 DevOps 方法，而不仅仅是在问题出现时做出反应。&lt;/p&gt;
&lt;p&gt;以这种方式考虑 DevOps 需要从以工具为中心的方法转向更为系统化的方法，需要思维方式和实践方法上的转变。&lt;/p&gt;
&lt;p&gt;这并不容易，但最终使团队和组织更加数据驱动和主动。&lt;/p&gt;
&lt;h2 id=&#34;图形和-kubernetes&#34;&gt;图形和 Kubernetes&lt;/h2&gt;
&lt;p&gt;在基于 Kubernetes 的 DevOps 流水线中，可以使用基于图形的方法对许多组件进行建模和分析。例如，Kubernetes 集群中不同容器、服务和 Pod 之间的关系可以表示为图中的节点，它们之间的交互可以表示为边。通过分析这个图，组织可以获得有关其基于 Kubernetes 的 DevOps 流水线性能的见解，包括识别瓶颈、故障排除和优化工作流程。&lt;/p&gt;
&lt;p&gt;更具体地说，应用于 Kubernetes 部署的图形方法允许：&lt;/p&gt;
&lt;h3 id=&#34;知识捕获和保留&#34;&gt;知识捕获和保留&lt;/h3&gt;
&lt;p&gt;通过将 Kubernetes 部署中的不同组件可视化为图形，组织可以更好地了解不同组件的交互方式，以及一个区域的更改如何影响其他区域。例如，它可以显示特定服务是否被其他组件广泛依赖。或者在处理像 Amazon 关系型数据库服务 (RDS) 或 DynamoDB 这样的外部资源时，组织可以注意到哪个 Pod 依赖于哪个数据库，以获得清晰的依赖关系和风险。&lt;/p&gt;
&lt;p&gt;以下是实际实现的方法：&lt;/p&gt;
&lt;p&gt;在 DevOps 可观测性平台中，我们为 Kubernetes/Amazon Elastic Kubernetes Service (EKS) 设置了一个场景。场景提供了 Kubernetes 架构的拓扑视图。在这种情况下，我们创建了一个简单的 Kubernetes 基础设施图，它可以自动发现和可视化所有 Kubernetes 依赖项，以帮助跟踪更改。依赖关系图包括来自群集和服务到 Pod、容器和进程的资源。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/reframing-kubernetes-observability-with-a-graph/1_hud4fd5d2f2c8ff51a72f1cfeb695c169e_110356_40d50b4f7acd52b20d96cfc351d47962.webp 400w,
               /blog/reframing-kubernetes-observability-with-a-graph/1_hud4fd5d2f2c8ff51a72f1cfeb695c169e_110356_fa9456b2c88229f8671c519d82343377.webp 760w,
               /blog/reframing-kubernetes-observability-with-a-graph/1_hud4fd5d2f2c8ff51a72f1cfeb695c169e_110356_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/reframing-kubernetes-observability-with-a-graph/1_hud4fd5d2f2c8ff51a72f1cfeb695c169e_110356_40d50b4f7acd52b20d96cfc351d47962.webp&#34;
               width=&#34;760&#34;
               height=&#34;400&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;场景可以包括度量指标，允许用户学习 Pod、节点和命名空间之间的关系以及与它们相关的指标。如果所选实体有任何关联的指标，那么它们将出现在上下文菜单中的指标选项卡下。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/reframing-kubernetes-observability-with-a-graph/2_hu74f26c63bbb1f1a138aa8b4a266f2b77_13001_b188cad8e6008c1d32a0059332f5147a.webp 400w,
               /blog/reframing-kubernetes-observability-with-a-graph/2_hu74f26c63bbb1f1a138aa8b4a266f2b77_13001_b2874328a7aa02098ba224db6aab0ca4.webp 760w,
               /blog/reframing-kubernetes-observability-with-a-graph/2_hu74f26c63bbb1f1a138aa8b4a266f2b77_13001_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/reframing-kubernetes-observability-with-a-graph/2_hu74f26c63bbb1f1a138aa8b4a266f2b77_13001_b188cad8e6008c1d32a0059332f5147a.webp&#34;
               width=&#34;478&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;单击列出的任何指标将生成一个图表窗口。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/reframing-kubernetes-observability-with-a-graph/3_huc18582dc0df7975eb6c705f10792d8e8_37095_f6d34faf5e73a9a77ad1faf5ac66e858.webp 400w,
               /blog/reframing-kubernetes-observability-with-a-graph/3_huc18582dc0df7975eb6c705f10792d8e8_37095_6fbc696620a96ded0c4d858a1d2184b1.webp 760w,
               /blog/reframing-kubernetes-observability-with-a-graph/3_huc18582dc0df7975eb6c705f10792d8e8_37095_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/reframing-kubernetes-observability-with-a-graph/3_huc18582dc0df7975eb6c705f10792d8e8_37095_f6d34faf5e73a9a77ad1faf5ac66e858.webp&#34;
               width=&#34;760&#34;
               height=&#34;509&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然后，您可以将图表添加到仪表板中，以帮助确定问题并建立问题的根本原因。&lt;/p&gt;
&lt;h3 id=&#34;优化和故障排除&#34;&gt;优化和故障排除&lt;/h3&gt;
&lt;p&gt;通过分析 Kubernetes 部署的图形，组织还可以识别瓶颈并优化工作流程的流程。如果基于图形的分析显示特定的 Pod 经常导致超时或错误，组织可以调查原因并采取措施予以纠正。更好的是，团队可以看到与异常行为相关的相关更改的时间轴，并实时揭示根本原因。曾经故障排除需要太长时间，因为团队未能意识到其环境中所有持续变化，现在他们可以在共享的、上下文驱动的空间中连接因果关系。&lt;/p&gt;
&lt;h3 id=&#34;资源分配&#34;&gt;资源分配&lt;/h3&gt;
&lt;p&gt;优化资源分配也变得更简单。通过分析组件和需求之间的关系，组织可以识别优化资源使用和降低成本的机会。例如，基于图形的分析可能显示特定的 Pod 进行了过度配置，需要缩减规模，而如果没有它，可能很难确定部署的哪个离散方面是问题。&lt;/p&gt;
&lt;h2 id=&#34;更好的-devops&#34;&gt;更好的 DevOps&lt;/h2&gt;
&lt;p&gt;最终，将 DevOps 视为图形具有不可否认的好处。通过关系和工作流程映射，它提供了对复杂系统更好、更细粒度的了解。它提高了离散组件的可视化，以便快速识别和解决整个环境中的问题。&lt;/p&gt;
&lt;p&gt;决策可以通过从图中揭示的模式和关系获得数据驱动的洞见来得到加强。简单地说，这是增加效率并持续改进 DevOps 过程的最佳方法，即使在处理 Kubernetes 和其他以云为先的技术的复杂性时也是如此。&lt;/p&gt;
&lt;p&gt;要达到这种运营效率水平，DevOps 团队需要使用提供统一的或易于连接的更改时间轴的依赖图的工具。团队必须全面查看部署中所有不同的组件，同时能够注意到它们所有的关系和依赖关系。&lt;/p&gt;
&lt;p&gt;由于云为先的体系结构（如 Kubernetes）存在的知识差距和复杂性问题，这不能通过手动或逐案例完成。只有现代的变更智能工具，可以在生成实时、准确的拓扑视图的同时，通过相关指标添加上下文，才能有效地实现这一点。&lt;/p&gt;
&lt;p&gt;想象一下团队通过不必手动构建、维护和管理图形，就能节省多少时间和头痛。幸运的是，您不必想象太久。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>可观测性峰会 2023 回顾及 PPT 下载</title>
      <link>https://cloudnative.to/blog/observability-summit-2023-recap/</link>
      <pubDate>Sun, 23 Apr 2023 22:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/observability-summit-2023-recap/</guid>
      <description>&lt;p&gt;「可观测性峰会 2023」是云原生社区组织的技术会议，旨在分享并探讨云原生应用程序和基础架构中实现可观测性的最新技术和工具以及最佳实践。&lt;/p&gt;
&lt;p&gt;时间：2023 年 4 月 22 日（周六）&lt;/p&gt;
&lt;p&gt;地点：北京奥佳美术馆酒店&lt;/p&gt;
&lt;p&gt;活动详情：&lt;a href=&#34;https://www.huodongxing.com/event/6695157778700&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.huodongxing.com/event/6695157778700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f0_hubc7b39edba1af54441ce60546431902e_2226288_51fd489e5e7ebc7e83ae7194063e6411.webp 400w,
               /blog/observability-summit-2023-recap/f0_hubc7b39edba1af54441ce60546431902e_2226288_6194df2804b9ef2ebbd02dcfd71ac112.webp 760w,
               /blog/observability-summit-2023-recap/f0_hubc7b39edba1af54441ce60546431902e_2226288_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f0_hubc7b39edba1af54441ce60546431902e_2226288_51fd489e5e7ebc7e83ae7194063e6411.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本次大会的主持人来自云原生社区管委会，上半场主持人为罗广明。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f1_hu60a3df32b1c9be8ea101508a14a9a5aa_2367668_4b4c9e3981f47a1629fa9834ebec4d21.webp 400w,
               /blog/observability-summit-2023-recap/f1_hu60a3df32b1c9be8ea101508a14a9a5aa_2367668_3dae9b2a19b1c5bb6358544a8637e665.webp 760w,
               /blog/observability-summit-2023-recap/f1_hu60a3df32b1c9be8ea101508a14a9a5aa_2367668_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f1_hu60a3df32b1c9be8ea101508a14a9a5aa_2367668_4b4c9e3981f47a1629fa9834ebec4d21.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;下半场主持人张丽颖。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f2_huf1ff4863f3ab579117905b0a65e45d40_1943060_63f02789a212ca4be55f62cd5e0f9f9c.webp 400w,
               /blog/observability-summit-2023-recap/f2_huf1ff4863f3ab579117905b0a65e45d40_1943060_31712f6e3cc7f4fe8121a331d9b268f5.webp 760w,
               /blog/observability-summit-2023-recap/f2_huf1ff4863f3ab579117905b0a65e45d40_1943060_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f2_huf1ff4863f3ab579117905b0a65e45d40_1943060_63f02789a212ca4be55f62cd5e0f9f9c.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;开场致辞&#34;&gt;开场致辞&lt;/h3&gt;
&lt;p&gt;嘉宾：&lt;/p&gt;
&lt;p&gt;宋净超，云原生社区创始人&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f3_hu5121ef38a1b701a4aa0b4bd8735fcdac_1687484_be21f92f63607543b8e52356086bbf22.webp 400w,
               /blog/observability-summit-2023-recap/f3_hu5121ef38a1b701a4aa0b4bd8735fcdac_1687484_f475a560be77b4bdecae7c806770becb.webp 760w,
               /blog/observability-summit-2023-recap/f3_hu5121ef38a1b701a4aa0b4bd8735fcdac_1687484_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f3_hu5121ef38a1b701a4aa0b4bd8735fcdac_1687484_be21f92f63607543b8e52356086bbf22.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;陈屹力，中国信通院云大所副总工程师&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f4_huf839f863d4b8ffebff18dccfcc451c94_2939209_c41df77ea407d81c20b5c407c78b3b39.webp 400w,
               /blog/observability-summit-2023-recap/f4_huf839f863d4b8ffebff18dccfcc451c94_2939209_e6b3510a94f12dd60e977db966e25c9e.webp 760w,
               /blog/observability-summit-2023-recap/f4_huf839f863d4b8ffebff18dccfcc451c94_2939209_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f4_huf839f863d4b8ffebff18dccfcc451c94_2939209_c41df77ea407d81c20b5c407c78b3b39.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;视频链接：&lt;a href=&#34;https://www.bilibili.com/video/BV1zV4y1o79E/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bilibili.com/video/BV1zV4y1o79E/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f14_hu7072d95a3cded18872b1de1f86ef47de_384386_f949238c945b8704abba25ec13a61154.webp 400w,
               /blog/observability-summit-2023-recap/f14_hu7072d95a3cded18872b1de1f86ef47de_384386_854d4100859a96490dcd4126967dde36.webp 760w,
               /blog/observability-summit-2023-recap/f14_hu7072d95a3cded18872b1de1f86ef47de_384386_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f14_hu7072d95a3cded18872b1de1f86ef47de_384386_f949238c945b8704abba25ec13a61154.webp&#34;
               width=&#34;599&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;可观测性-opscenter-在移动云平台落地实践&#34;&gt;可观测性 OpsCenter 在移动云平台落地实践&lt;/h3&gt;
&lt;p&gt;沈巍，中国移动云能力中心架构师&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f5_hu407f6c5fa3371973dd98baef007c4c7e_2249775_88f28c2d03b0e795b5f228dc52f89d43.webp 400w,
               /blog/observability-summit-2023-recap/f5_hu407f6c5fa3371973dd98baef007c4c7e_2249775_ce1a59457205659b5c188ae5a9e532b0.webp 760w,
               /blog/observability-summit-2023-recap/f5_hu407f6c5fa3371973dd98baef007c4c7e_2249775_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f5_hu407f6c5fa3371973dd98baef007c4c7e_2249775_88f28c2d03b0e795b5f228dc52f89d43.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;讲师介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;沈巍，中国移动云能力中心，软件开发工程师，曾就职于全球最大的移动通信设备商爱立信；在爱立信工作期间参与设计了爱立信全球第一套超大规模 NFV 电信云落地，全球第一套超大规模 5GC 电信云落地；荣获爱立信年度最具有价值员工称号。擅长 openstack，kubernetes 等云平台的解决方案设计与实现；云平台可观测性监控的设计与实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;议题概要&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;介绍移动云的现状，包括资源池和设备供应商的多样性以及网络设备和网络结构存在的问题。&lt;/li&gt;
&lt;li&gt;针对移动云的现状，提出了适合移动云的可观测性平台的解决方案和实现方法。其中，介绍了监控数据来源（包括分层级监控和分应用监控），告警分发策略和主动运维的必要性。&lt;/li&gt;
&lt;li&gt;探讨了部署可观测性平台的收益和价值性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;视频链接：&lt;a href=&#34;https://www.bilibili.com/video/BV1GX4y1B7qG/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bilibili.com/video/BV1GX4y1B7qG/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f1_hu83a96862f36fa1a23c40b96b3cbfb33e_385757_251793f973c7d9f9f4ae71583e87a06b.webp 400w,
               /blog/observability-summit-2023-recap/f1_hu83a96862f36fa1a23c40b96b3cbfb33e_385757_754e3dbb962a6f97efbfdcf03cbb2a3d.webp 760w,
               /blog/observability-summit-2023-recap/f1_hu83a96862f36fa1a23c40b96b3cbfb33e_385757_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f1_hu83a96862f36fa1a23c40b96b3cbfb33e_385757_251793f973c7d9f9f4ae71583e87a06b.webp&#34;
               width=&#34;599&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;使用-ebpf-零代码修改绘制全景应用拓扑&#34;&gt;使用 eBPF 零代码修改绘制全景应用拓扑&lt;/h3&gt;
&lt;p&gt;向阳，云杉网络&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f6_hu57a5f4707bac491c6533a90ef70b01f1_2532536_fc7f5264a10d4974104d862652cce7f3.webp 400w,
               /blog/observability-summit-2023-recap/f6_hu57a5f4707bac491c6533a90ef70b01f1_2532536_df04a7ac523cab39719bfb2ab9b31a5e.webp 760w,
               /blog/observability-summit-2023-recap/f6_hu57a5f4707bac491c6533a90ef70b01f1_2532536_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f6_hu57a5f4707bac491c6533a90ef70b01f1_2532536_fc7f5264a10d4974104d862652cce7f3.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;讲师介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向阳，云杉网络研发 VP，清华大学博士。致力于打造一款零侵扰的云原生应用可观测性产品，让观测更自动，让开发者更自由。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;议题概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;云原生应用访问关系错综复杂、更新频繁，依靠手动绘制不现实，依靠代码插桩或服务网格侵入性大难以覆盖全景。DeepFlow 利用 eBPF 实现了无需代码修改、无需应用重发布、无需业务进程重启的全景应用拓扑绘制能力，并在拓扑之上提供了所有服务、所有访问路径的全栈性能指标。&lt;/p&gt;
&lt;p&gt;视频链接：&lt;a href=&#34;https://www.bilibili.com/video/BV1B14y1f7UB/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bilibili.com/video/BV1B14y1f7UB/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f2_hud4bc0b64cc4f9c4846357d0f7dc81df9_374587_588ebbd1a5565e6f5fc78cf8b8c9610c.webp 400w,
               /blog/observability-summit-2023-recap/f2_hud4bc0b64cc4f9c4846357d0f7dc81df9_374587_b56ad7d169eb009c61bf41991cd30a84.webp 760w,
               /blog/observability-summit-2023-recap/f2_hud4bc0b64cc4f9c4846357d0f7dc81df9_374587_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f2_hud4bc0b64cc4f9c4846357d0f7dc81df9_374587_588ebbd1a5565e6f5fc78cf8b8c9610c.webp&#34;
               width=&#34;599&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;可观测技术应用现状及发展趋势研究&#34;&gt;可观测技术应用现状及发展趋势研究&lt;/h3&gt;
&lt;p&gt;高继翔，中国信通院&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f7_hu33118cbba33912fec77bcf61001688ef_1828272_a8657b5ce4a60fcd9b8a7e1a13edbc41.webp 400w,
               /blog/observability-summit-2023-recap/f7_hu33118cbba33912fec77bcf61001688ef_1828272_0a46fca9fed7bbd64f96e9b6ca12708c.webp 760w,
               /blog/observability-summit-2023-recap/f7_hu33118cbba33912fec77bcf61001688ef_1828272_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f7_hu33118cbba33912fec77bcf61001688ef_1828272_a8657b5ce4a60fcd9b8a7e1a13edbc41.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;讲师介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高继翔，中国信通院云大所业务主管，从事可观测性、SRE 等云计算领域关键技术研究，牵头编写了《可观测性技术 平台能力分级要求》行业标准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;议题概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;支撑工信部在 31 个省市开展云服务稳定安全运行应急演练专项活动过程中，对可观测性技术应用现状的调查结果，同时结合产业研究成果，介绍可观测性技术发展趋势及方向。&lt;/p&gt;
&lt;p&gt;视频链接：&lt;a href=&#34;https://www.bilibili.com/video/BV1xv4y1E7wF/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bilibili.com/video/BV1xv4y1E7wF/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f3_huc1a6ce8abb7ad08b13a3d36acd06bdeb_381094_ea0f01b7ded550cdab93702a64ffe130.webp 400w,
               /blog/observability-summit-2023-recap/f3_huc1a6ce8abb7ad08b13a3d36acd06bdeb_381094_9ebf5646aacab2cde024a2c90caa9575.webp 760w,
               /blog/observability-summit-2023-recap/f3_huc1a6ce8abb7ad08b13a3d36acd06bdeb_381094_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f3_huc1a6ce8abb7ad08b13a3d36acd06bdeb_381094_ea0f01b7ded550cdab93702a64ffe130.webp&#34;
               width=&#34;599&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;圆桌讨论云原生应用可观测性现状及趋势&#34;&gt;圆桌讨论：云原生应用可观测性现状及趋势&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f8_hu8805e4f0322c33282125cd8713412fee_2097756_8e9a3c083dc4d98772699a30a6a65e3c.webp 400w,
               /blog/observability-summit-2023-recap/f8_hu8805e4f0322c33282125cd8713412fee_2097756_05a9fc12cce4eb6171510d29dfd21812.webp 760w,
               /blog/observability-summit-2023-recap/f8_hu8805e4f0322c33282125cd8713412fee_2097756_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f8_hu8805e4f0322c33282125cd8713412fee_2097756_8e9a3c083dc4d98772699a30a6a65e3c.webp&#34;
               width=&#34;760&#34;
               height=&#34;504&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;嘉宾&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;罗广明，主持人&lt;/li&gt;
&lt;li&gt;吴晟，Tetrate 创始工程师&lt;/li&gt;
&lt;li&gt;向阳，云杉科技研发 VP&lt;/li&gt;
&lt;li&gt;乔新亮，原苏宁科技副总裁，现彩食鲜 CTO&lt;/li&gt;
&lt;li&gt;董江，中国移动云能力中心高级系统架构专家&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;讨论话题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;云原生大背景之下，可观测性为什么如此重要？&lt;/li&gt;
&lt;li&gt;如何评估云原生应用程序和基础设施的可观测性水平？&lt;/li&gt;
&lt;li&gt;未来云原生可观测性的发展趋势是什么？将来可观测性的实现方式和手段会有哪些变化？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;视频链接：&lt;a href=&#34;https://www.bilibili.com/video/BV1is4y1d7gd/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bilibili.com/video/BV1is4y1d7gd/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f4_hu3f7e5772628fbb4e858e28014932135d_410237_23d8a1f1fecd672d5046118f485c5361.webp 400w,
               /blog/observability-summit-2023-recap/f4_hu3f7e5772628fbb4e858e28014932135d_410237_51b623c1c4313838054b491c882601a4.webp 760w,
               /blog/observability-summit-2023-recap/f4_hu3f7e5772628fbb4e858e28014932135d_410237_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f4_hu3f7e5772628fbb4e858e28014932135d_410237_23d8a1f1fecd672d5046118f485c5361.webp&#34;
               width=&#34;599&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;基于-prometheus-的-slo-告警实战&#34;&gt;基于 Prometheus 的 SLO 告警实战&lt;/h3&gt;
&lt;p&gt;宋佳洋，Oppo&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f9_hu6d26fd5aef6852bfbb32fee91217e883_1642330_32354d055ce34ef7a1afd1cf46d78841.webp 400w,
               /blog/observability-summit-2023-recap/f9_hu6d26fd5aef6852bfbb32fee91217e883_1642330_80efe4963b7742d16d6c32c1c9f8343c.webp 760w,
               /blog/observability-summit-2023-recap/f9_hu6d26fd5aef6852bfbb32fee91217e883_1642330_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f9_hu6d26fd5aef6852bfbb32fee91217e883_1642330_32354d055ce34ef7a1afd1cf46d78841.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;讲师介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;宋佳洋，OPPO 高级后端工程师，OpenTelemetry、Prometheus、Cortex 代码贡献者。2013 年参加工作，先后就职于七牛云、京东云等公司，目前就职于 OPPO 云计算部门。爱好 Golang 和开源，目前主要专注于云原生和观察性领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;议题概要&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于 SLO 告警基础&lt;/li&gt;
&lt;li&gt;开源方案对比（Sloth、Pyrra）&lt;/li&gt;
&lt;li&gt;多租户 SLO 实现方式（Cortex 扩展）&lt;/li&gt;
&lt;li&gt;遥测塔 SLO 服务介绍&lt;/li&gt;
&lt;li&gt;Demo 展示&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;视频链接：&lt;a href=&#34;https://www.bilibili.com/video/BV1jV4y1o7Q7/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bilibili.com/video/BV1jV4y1o7Q7/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f5_huff7fe9c6098fa9190e8b2a2d7cbeb2b6_372901_c7c43cf65260d9062991a2a8a3b64e82.webp 400w,
               /blog/observability-summit-2023-recap/f5_huff7fe9c6098fa9190e8b2a2d7cbeb2b6_372901_0ddad763f16c7534b407767c7fa49b9e.webp 760w,
               /blog/observability-summit-2023-recap/f5_huff7fe9c6098fa9190e8b2a2d7cbeb2b6_372901_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f5_huff7fe9c6098fa9190e8b2a2d7cbeb2b6_372901_c7c43cf65260d9062991a2a8a3b64e82.webp&#34;
               width=&#34;599&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;为-apache-skywalking-构建-grafana-dashboards----基于对原生-promql-的支持&#34;&gt;为 Apache SkyWalking 构建 Grafana dashboards &amp;ndash; 基于对原生 PromQL 的支持&lt;/h3&gt;
&lt;p&gt;万凯，Tetrate&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f10_hu642a5c6253ab5026d6c42ed851971555_1542974_2ead987c6247860b1d03013e31f80583.webp 400w,
               /blog/observability-summit-2023-recap/f10_hu642a5c6253ab5026d6c42ed851971555_1542974_0a7afed76760e869938a2d451312386f.webp 760w,
               /blog/observability-summit-2023-recap/f10_hu642a5c6253ab5026d6c42ed851971555_1542974_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f10_hu642a5c6253ab5026d6c42ed851971555_1542974_2ead987c6247860b1d03013e31f80583.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;讲师介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;万凯，Tetrate 工程师，Apache SkyWalking PMC 成员，专注于应用性能可观测性领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;议题概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本次分享将介绍 Apache SkyWalking 的新特性 PromQL Service，它将为 SkyWalking 带来更广泛的生态集成能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是 PromQL&lt;/li&gt;
&lt;li&gt;SkyWalking 的 PromQL Service 是什么，能够做什么&lt;/li&gt;
&lt;li&gt;SkyWalking 中的基本概念和 metrics 的特性&lt;/li&gt;
&lt;li&gt;如何使用 PromQL Service&lt;/li&gt;
&lt;li&gt;使用 PromQL Service 构建 Grafana dashboards 的实践&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;视频链接：&lt;a href=&#34;https://www.bilibili.com/video/BV1ms4y1d7NF/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bilibili.com/video/BV1ms4y1d7NF/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f6_hue25c9cb03780253517ce8bba355b0b2f_400469_814ebfab9bf94b4927ab3e959ae726a5.webp 400w,
               /blog/observability-summit-2023-recap/f6_hue25c9cb03780253517ce8bba355b0b2f_400469_cd3a8d54f28399f6221082f7015f3e4c.webp 760w,
               /blog/observability-summit-2023-recap/f6_hue25c9cb03780253517ce8bba355b0b2f_400469_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f6_hue25c9cb03780253517ce8bba355b0b2f_400469_814ebfab9bf94b4927ab3e959ae726a5.webp&#34;
               width=&#34;599&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;apache-dubbo-云原生可观测性的探索与实践&#34;&gt;Apache Dubbo 云原生可观测性的探索与实践&lt;/h3&gt;
&lt;p&gt;江河清，阿里巴巴&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f11_hu34a6765f1d2c5f2a6edec5ce70d01fc3_845365_3d331554d6ac782fb439bdf905bdffda.webp 400w,
               /blog/observability-summit-2023-recap/f11_hu34a6765f1d2c5f2a6edec5ce70d01fc3_845365_33a03904f69236e3e70f8c4c496b6725.webp 760w,
               /blog/observability-summit-2023-recap/f11_hu34a6765f1d2c5f2a6edec5ce70d01fc3_845365_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f11_hu34a6765f1d2c5f2a6edec5ce70d01fc3_845365_3d331554d6ac782fb439bdf905bdffda.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;讲师介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Apache Dubbo PMC，阿里云研发工程师，专注于服务框架，Apache Dubbo 核心维护团队成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;议题概要&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;云原生背景下传统微服务应用的架构升级&lt;/li&gt;
&lt;li&gt;云原生微服务场景下可观测性的价值&lt;/li&gt;
&lt;li&gt;Apache Dubbo 对接可观测体系的思路和目标&lt;/li&gt;
&lt;li&gt;Apache Dubbo 基于 Micrometer 实现实时指标采集和全链路追踪方案的介绍&lt;/li&gt;
&lt;li&gt;Apache Dubbo 通过 OpenTelemetry 对接可观测平台的方案&lt;/li&gt;
&lt;li&gt;基于可观测能力提升生产稳定性的最佳实践介绍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;视频链接：&lt;a href=&#34;https://www.bilibili.com/video/BV1mV4y1o7Uj/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bilibili.com/video/BV1mV4y1o7Uj/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f7_hu41d88059af01f03beda1401703ce0169_386214_96fdecbb2d1af2434316a25479540d67.webp 400w,
               /blog/observability-summit-2023-recap/f7_hu41d88059af01f03beda1401703ce0169_386214_5ca1f649ed0fb9677008876afa38565a.webp 760w,
               /blog/observability-summit-2023-recap/f7_hu41d88059af01f03beda1401703ce0169_386214_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f7_hu41d88059af01f03beda1401703ce0169_386214_96fdecbb2d1af2434316a25479540d67.webp&#34;
               width=&#34;599&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;我为可观测性做减法微信日志热点约简实践与探索&#34;&gt;我为可观测性做减法：微信日志热点约简实践与探索&lt;/h3&gt;
&lt;p&gt;余广坝，中山大学&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f12_hu3e782c16f42eae9ce2409d3478c97209_2113724_95cbbdb7b787c2d38552b446e379afc9.webp 400w,
               /blog/observability-summit-2023-recap/f12_hu3e782c16f42eae9ce2409d3478c97209_2113724_7e2e5b32373a32b1fa82e942c7942228.webp 760w,
               /blog/observability-summit-2023-recap/f12_hu3e782c16f42eae9ce2409d3478c97209_2113724_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f12_hu3e782c16f42eae9ce2409d3478c97209_2113724_95cbbdb7b787c2d38552b446e379afc9.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;讲师介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;余广坝，中山大学 2020 级计算机专业的博士研究生，研究方向为云原生系统的性能诊断与优化，累计发表学术论文 20 余篇，其中 包括 CCF A 类论文 4 篇。2022 年入选 2022 腾讯犀牛鸟精英人才计划，到腾讯 WXG 做科研实习生，主要研究微信后台日志约简话题。此次分享的话题对应学术论文被 CCF A 类国际软件工程大会 ICSE 2023 录用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;议题概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在微信中，每天的后台日志打印接近 100 万亿行，占用了接近 20PB 的存储，带来了巨大的运营成本。为了削减日志的运营成本，我们对微信后台的日志打印和存储的特征进行了分析和挖掘，发现「绝大多数的日志开销是由少数的几条日志语句导致的」，我们将这些日志语句称为「日志热点」。这个发现启发我们：「及时发现日志热点，对日志热点的打印进行优化即可降低大量的日志开销」。针对这个问题，他将分享以下几个话题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微信后台日志热点出现的普遍性、原因和修复方案调研&lt;/li&gt;
&lt;li&gt;微信日志热点定位与离线约简实践&lt;/li&gt;
&lt;li&gt;基于 eBPF 的在线日志热点约简探索&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;视频链接：&lt;a href=&#34;https://www.bilibili.com/video/BV1Ec411J7sk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bilibili.com/video/BV1Ec411J7sk/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f8_hu0311658a90c0964d41abb3bf9d071c58_396183_035ca325778af297cb9d8ba6e4b679dd.webp 400w,
               /blog/observability-summit-2023-recap/f8_hu0311658a90c0964d41abb3bf9d071c58_396183_7f592e6721433d57583d92edb0348cc4.webp 760w,
               /blog/observability-summit-2023-recap/f8_hu0311658a90c0964d41abb3bf9d071c58_396183_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f8_hu0311658a90c0964d41abb3bf9d071c58_396183_035ca325778af297cb9d8ba6e4b679dd.webp&#34;
               width=&#34;599&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;使用-ebpfwasm-构建下一代可观测性数据采集基础设施&#34;&gt;使用 eBPF+WASM 构建下一代可观测性数据采集基础设施&lt;/h3&gt;
&lt;p&gt;赵亚雄，三度观测云（tricorder.dev）创始人 CEO&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f13_hubd4e3d2a95b38423cf21e5468f95ab58_1368014_35fe685395daf1af88745556e3b1ad86.webp 400w,
               /blog/observability-summit-2023-recap/f13_hubd4e3d2a95b38423cf21e5468f95ab58_1368014_1b8c6523a893f2aba00066f68c7ed124.webp 760w,
               /blog/observability-summit-2023-recap/f13_hubd4e3d2a95b38423cf21e5468f95ab58_1368014_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f13_hubd4e3d2a95b38423cf21e5468f95ab58_1368014_35fe685395daf1af88745556e3b1ad86.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;讲师介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;赵亚雄博士 2012 - 2013 年参与 Amazon Kinesis 开发（世界首个流式大数据云服务）；2013 - 2019 年先后在 Google NetInfra 团队参与 Jupiter 软件定义网络系统、及 Borg 容器云平台的研发，后期担任 Borg Clients 团队经理，承担下一代云原生自动化运维系统的研发；2019 - 2022 年是 Pixie（&lt;a href=&#34;https://px.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://px.dev&lt;/a&gt;）创始团队成员，Pixie 获得顶级风投 Benchmark、GV 投资，于 2020 年 12 月被纽约证券交易所上市公司 New Relic（&lt;a href=&#34;https://newrelic.com/%EF%BC%89%E6%94%B6%E8%B4%AD%EF%BC%8C%E5%8E%86%E6%97%B6%E4%BB%85&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://newrelic.com/）收购，历时仅&lt;/a&gt; 1.5 年；2022 年 10 月创立三度观测云，从全球超过 5000 家申请企业中脱颖而出、获选进入奇绩创坛创业营，并获得陆奇博士天使轮投资。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;议题概要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;议题简介
可观测性是云原生技术版图中的核心，是支撑云原生软件系统开发、运维的基础。可观测性技术的本质是通过数据来揭示软件系统自身的运行机制，提升和扩展工程师在云原生环境中进行软件开发、测试、运维的能力边界。&lt;/p&gt;
&lt;p&gt;数据是可观测性的基础和价值源泉。但是，针对可观测性数据采集，可观测性技术群体沿用了一条错误的技术路线：各类可观测性产品须在被观测的软件系统内植入代码来采集可观测性数据，好比是做体检都需要开膛破肚。这种方式从根本上增加了可观测性产品的使用成本，限制了可观测性技术发挥价值的空间，降低了可观测性技术在云原生生态中的普及速度；甚至阻碍了云原生技术自身的普及。&lt;/p&gt;
&lt;p&gt;赵亚雄博士介绍了基于 eBPF+WASM 实现无侵入式数据采集的技术思想，从根本上降低可观测性数据采集的成本，符合云原生技术自身技术规律；以此技术思想为指导，星舰（Starship）观测平台在 Kubernetes 上实现了可观测性数据即时采集，助力工程师获取高价值数据，解决云原生软件系统的开发、测试、运维过程中的各类技术问题。&lt;/p&gt;
&lt;p&gt;视频链接：&lt;a href=&#34;https://www.bilibili.com/video/BV1kM411V7Y9/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bilibili.com/video/BV1kM411V7Y9/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/observability-summit-2023-recap/f9_hufdebb4398444f732dffb6f1a14cfba27_399713_e99312c609c2711f91dda85c45ed32ac.webp 400w,
               /blog/observability-summit-2023-recap/f9_hufdebb4398444f732dffb6f1a14cfba27_399713_4a46b60a44dbbeb6b4826082fbb5943f.webp 760w,
               /blog/observability-summit-2023-recap/f9_hufdebb4398444f732dffb6f1a14cfba27_399713_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/observability-summit-2023-recap/f9_hufdebb4398444f732dffb6f1a14cfba27_399713_e99312c609c2711f91dda85c45ed32ac.webp&#34;
               width=&#34;599&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;大会总结&#34;&gt;大会总结&lt;/h3&gt;
&lt;p&gt;本次可观测性峰会 2023 在北京奥加美术馆酒店圆满结束。本次峰会聚焦于云原生应用程序和基础架构中可观测性的最佳实践。上午场聚焦最佳实践和经验分享，并围绕可观测性进行了精彩的讨论，下午场的五场分享展示了最新的技术和工具，为参会者带来了许多宝贵的经验和启示。&lt;/p&gt;
&lt;p&gt;其中，基于 Prometheus 的 SLO 告警实战分享了如何在实践中应用 SLO 告警基础，使得告警更加准确；Apache SkyWalking 的分享介绍了其新特性 PromQL Service，展示了如何使用 SkyWalking 中的 PromQL Service 构建 Grafana dashboards；Apache Dubbo 的分享介绍了在云原生微服务场景下可观测性的价值和 Dubbo 对接可观测体系的思路和目标；微信日志热点约简实践与探索分享了如何通过发现日志热点对日志打印进行优化从而降低日志开销；使用 eBPF+WASM 构建下一代可观测性数据采集基础设施分享了基于 eBPF+WASM 实现无侵入式数据采集的技术思想。&lt;/p&gt;
&lt;p&gt;参会者对本次峰会的内容表示非常满意，认为分享的内容新颖、实用，有助于他们更好地应用可观测性技术。此外，本次峰会的社区影响力也得到了一致的肯定，参会者表示，这是一次非常成功的活动，期待未来的峰会能够继续展示最新的技术和工具，为业界带来更多的启示和收获。&lt;/p&gt;
&lt;p&gt;本次可观测性峰会 2023 是一次非常成功的活动，为业界带来了许多启示和收获，展示了最新的技术和工具，同时也促进了社区的发展和交流。希望未来的峰会能够继续为业界带来更多的启示和收获，展示最新的技术和工具，为可观测性技术的发展和应用做出更大的贡献。&lt;/p&gt;
&lt;h3 id=&#34;ppt-下载&#34;&gt;PPT 下载&lt;/h3&gt;
&lt;p&gt;讲师 PPT 可以在 GitHub 上下载，下载链接：&lt;a href=&#34;https://github.com/cloudnativeto/academy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/cloudnativeto/academy&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用全景拓扑持续跟踪云原生应用的压测性能瓶颈</title>
      <link>https://cloudnative.to/blog/service-map-observation-performance-test/</link>
      <pubDate>Fri, 21 Apr 2023 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/service-map-observation-performance-test/</guid>
      <description>&lt;p&gt;测试小姐姐正在对云原生的电商应用进行压测，但是如何对压测结果进行持续的观测呢？这一直是比较头痛的事情，本文将介绍如何利用 DeepFlow 的全景拓扑帮助小姐姐快速找到瓶颈点。DeepFlow 全景拓扑无需业务修改代码、配置或者重启服务，利用 BPF/eBPF 技术通过对业务零侵扰的方式构建而来，这是一种很便捷且低成本的方式来观测全链路压测的结果。&lt;/p&gt;
&lt;h2 id=&#34;背景介绍&#34;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;DeepFlow 在线的 Sandbox 环境中部署了一个云原生的电商应用，此电商应用来源于 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt;，此应用覆盖 Go/Java/.NET/PHP/Python 等多种语言，且涵盖 Redis/Kafka/PostgreSQL 等中间件，所有的这些服务都部署在 K8s 环境中。在做全链路压测时，当前通常的方式需要对应用进行代码级别的改造，这对于仅负责测试的小姐姐来说又很难推动，接下来将详细介绍 DeepFlow 的全景拓扑如何轻松解决小姐姐的苦恼。&lt;/p&gt;
&lt;p&gt;以下是电商应用微服务的调用关系图，提供了外网和内网访问的两种方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-调用关系&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/pub/pic/202304206440e8e3b447b.png&#34; alt=&#34;调用关系&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      调用关系
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;DeepFlow 的 Sandbox 考虑到安全性的问题，仅支持了内网的访问方式，以下是 DeepFlow 的全景拓扑自动绘制的调用关系，接下来的整个过程都将基于此拓扑进行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-全景拓扑&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/pub/pic/20230420644151ebabb38.jpg&#34; alt=&#34;全景拓扑&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      全景拓扑
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;DeepFlow 的全景拓扑可以与多指标进行结合，当指标量超过阈值时，则将通过标红的形式可视化出来。在开始接下来压测及调优过程之前，需要对本次过程中使用到的指标有一个了解。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指标&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;观测目标&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;流量速率&lt;/td&gt;
&lt;td&gt;作为主指标，构建全景拓扑&lt;/td&gt;
&lt;td&gt;&amp;ndash;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;应用请求速率&lt;/td&gt;
&lt;td&gt;统计服务的请求速率，主要用于观测压测过程中请求量是否符合压测预期&lt;/td&gt;
&lt;td&gt;符合测试压测的速率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;应用异常个数&lt;/td&gt;
&lt;td&gt;统计服务的异常个数，主要用于观测压测过程中是否存在服务异常的情况&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;应用响应时延&lt;/td&gt;
&lt;td&gt;统计服务的响应时延，主要用于观测压测过程中响应时延是否超过预期&lt;/td&gt;
&lt;td&gt;1s 以内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCP 建连时延&lt;/td&gt;
&lt;td&gt;统计 TCP 建连时延，主要用于观测压测过程中网络是否存在波动&lt;/td&gt;
&lt;td&gt;10ms 以内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCP 建连失败&lt;/td&gt;
&lt;td&gt;统计 TCP 建连失败，主要用于观测压测过程中系统性能是否稳定&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;逐个击破性能瓶颈&#34;&gt;逐个击破性能瓶颈&lt;/h2&gt;
&lt;p&gt;在 loadgenerator 所在的 node，通过脚本模拟 1.5k 的并发访问量，观测全景拓扑，一片红（在当前并发量的情况下，观测的指标量都超过阈值了），说明了目前这个系统在当前资源分配情况下，是扛不住 1.5k 的并发访问量的。查看指标量，应用响应时延、异常数和网络建连时延、建连失败的指标量都远超阈值了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-压测开始&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/pub/pic/202304206440e8e7c5190.jpg&#34; alt=&#34;压测开始&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      压测开始
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;找一个指标量（服务响应时延）来层层追踪拓扑图，loadgenerator 访问 frontend 响应时延达到 15s，而 frontend 访问后端服务中，其中访问 productcatalog 及 recommendation 分别都消耗了大概 11s、5s 的时延，其中 productcatalog 没有继续往后的访问了，可继续追踪 recommendation 访问的后端，其中也是访问 productcatalog 消耗了大概 4s 的时延，&lt;strong&gt;到此基本能确定当前应用的性能瓶颈就在 productcatalog 上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-分析拓扑&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/pub/pic/202304206440e8e553e4e.jpg&#34; alt=&#34;分析拓扑&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      分析拓扑
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来先直接对 productcatalog 扩容，增加 pod 数量到之前的 1 倍，然后再观测下全景拓扑，可以看出来拓扑图上的红变少一些了，同时观测下指标量，发现应用的响应时延及异常数都降下来了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-扩容_01&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/pub/pic/202304206440e8e46c14c.jpg&#34; alt=&#34;扩容_01&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      扩容_01
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;沿着前面的思路，依然使用服务响应时延来层层追踪拓扑图，&lt;strong&gt;发现通过扩容 1 倍的 POD 数，虽然缓解了 productcatalog 性能压力，但是还是没彻底解决。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-分析拓扑_01&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/pub/pic/202304206440e8e906a89.jpg&#34; alt=&#34;分析拓扑_01&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      分析拓扑_01
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来继续对 productcatalog 扩容，这次扩容到 2 倍，再观测全景拓扑，红色部分更少了，指标量也更接近预期了。不过&lt;strong&gt;这次发现解决了 productcatalog 的性能问题后，cart 的性能问题冒出来了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-扩容_02&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/pub/pic/202304206440e8e64d271.jpg&#34; alt=&#34;扩容_02&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      扩容_02
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;继续对 cart 服务的 POD 的数量扩容 1 倍，观测全景拓扑，发现红色部分都没了。到此基本上可以出压测结果了，&lt;strong&gt;针对当前电商应用在 1.5k 的并发访问量的情况下，productcatalog 需要是比其他服务（除 cart 外）2 倍的资源分配，cart 需要比其他服务（除 productcatalog 外）多 1 倍的资源分配才能应对。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-扩容_03&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/pub/pic/202304206440e8e6c4bf9.jpg&#34; alt=&#34;扩容_03&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      扩容_03
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;指标量分析&#34;&gt;指标量分析&lt;/h2&gt;
&lt;p&gt;再结合历史曲线图，来详细分析下指标量的变化，让大家能更好的理解为什么应用的性能问题除了带来应用指标量的波动，为什么还会带了网络指标量的变化。明显在 17:48 分后端服务是整个处理不过来的，这时多个指标都能反应此情况。&lt;code&gt;建连失败&lt;/code&gt;很多，在失败的过程中还不停的&lt;code&gt;重传 SYN 报文&lt;/code&gt;，同时建连失败的都是因为&lt;code&gt;服务端直接回 RST &lt;/code&gt;导致，此时仅看这部分指标量已经能清楚是&lt;strong&gt;后端系统对连接处理不过来了&lt;/strong&gt;。再继续结合应用指标量分析，在建连失败多的情况下，&lt;code&gt;请求量&lt;/code&gt;反而下降了，这是因为建连都没成功，根本发不了请求，此时后端的&lt;code&gt;异常数&lt;/code&gt;及&lt;code&gt;响应时延&lt;/code&gt;也都是挺高，也是直接反应了&lt;strong&gt;后端对请求处理不过来了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-历史曲线&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/pub/pic/202304206440e8e89523c.jpg&#34; alt=&#34;历史曲线&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      历史曲线
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;什么是-deepflow&#34;&gt;什么是 DeepFlow&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/deepflowio/deepflow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow&lt;/a&gt; 是一款开源的高度自动化的可观测性平台，是为云原生应用开发者建设可观测性能力而量身打造的全栈、全链路、高性能数据引擎。DeepFlow 使用 eBPF、WASM、OpenTelemetry 等新技术，创新的实现了 AutoTracing、AutoMetrics、AutoTagging、SmartEncoding 等核心机制，帮助开发者提升埋点插码的自动化水平，降低可观测性平台的运维复杂度。利用 DeepFlow 的可编程能力和开放接口，开发者可以快速将其融入到自己的可观测性技术栈中。&lt;/p&gt;
&lt;p&gt;GitHub 地址：&lt;a href=&#34;https://github.com/deepflowio/deepflow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/deepflowio/deepflow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&#34;https://deepflow.io/docs/zh/install/overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow Demo&lt;/a&gt;，体验高度自动化的可观测性新时代。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何降低可观测性带来的认知负荷</title>
      <link>https://cloudnative.to/blog/reducing-the-cognitive-load-associated-with-observability/</link>
      <pubDate>Thu, 13 Apr 2023 17:32:17 +0800</pubDate>
      <guid>https://cloudnative.to/blog/reducing-the-cognitive-load-associated-with-observability/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://thenewstack.io/reducing-the-cognitive-load-associated-with-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Reducing the Cognitive Load Associated with Observability - The New Stack&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：本文讨论了降低可观测性对认知负荷的影响。在处理大量数据时，我们需要过滤和转换数据点以生成适当的信号，并依赖警报系统来进行人类干预。游戏日是测试响应能力的好机会。在团队中培养协作文化对每个人的福祉至关重要。通过实施这些策略，软件工程团队可以确保他们具备使用和有效理解可观测性信号所需的知识和技能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;你能想象在没有现代可观测工具的情况下开发或操作分布式系统吗？我们知道可观测性是一项关键的实践，可以让我们提高系统的可靠性，减少服务停机时间，可视化使用模式，提供性能见解并促进问题解决。&lt;/p&gt;
&lt;p&gt;随着过去十年微服务架构和全球“shift left”的意图的广泛采用，工程师的角色——从开发人员和运维人员到 DevOps、站点可靠性工程和平台工程——发生了巨大变化。许多人被赋予更多的责任，并增加了工作量。&lt;/p&gt;
&lt;div class=&#34;alert-note-title&#34;&gt;
    &lt;p&gt;什么是 Shift left？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
    &lt;p&gt;&amp;ldquo;Shift left&amp;rdquo; 是一种软件开发术语，它指的是在开发生命周期的早期阶段引入测试和安全性措施，以便更早地发现和修复潜在问题，从而减少开发成本和增强产品质量。&lt;/p&gt;
&lt;p&gt;传统的软件开发过程中，测试和安全性通常是在开发周期的后期才被考虑，这意味着潜在的问题可能已经存在于系统中并且需要更多时间和成本来修复。而“Shift left”意味着在开发过程的早期引入这些步骤，以便更快地发现并解决潜在的问题。&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;作为软件工程组织，我们的工作是构建满足特定业务需求的高质量系统。为了实现这一目标，我们已经对我们的应用程序进行了仪器化，设置了分布式跟踪以及集中式日志收集，并不断监视延迟、错误率和吞吐量，并在此之上设置了警报。现在呢？我们可以依赖我们组织中的一个英雄专家来处理警报，诊断系统故障并防止停机。或者我们可以将这种知识传播给所有工程师并分享工作负载。&lt;/p&gt;
&lt;p&gt;要求每个人都能熟练掌握现有的工具和理解生成的大量数据不可避免地会导致焦虑、沮丧和疲劳。我们能否以某种方式降低与可观测性相关的认知负荷？&lt;/p&gt;
&lt;h2 id=&#34;理解可观测性数据&#34;&gt;理解可观测性数据&lt;/h2&gt;
&lt;p&gt;可观测性有一些硬技能。工程师需要接受训练以解密基本数据类型。希望工具能在这项任务中协助人类。难怪我们看到了大量的供应商工具涌现，旨在提供最佳的解释和可视化分布式跟踪、指标和日志体验。这是一项复杂的任务！分布式跟踪只是一大块链接时间戳和元数据；指标可以是测量仪、计数器或直方图；日志语句可以根据受众和使用者而是结构化或非结构化的。即使是最常见的日志语句在没有受过培训的人的眼中也可能看起来很陌生。只要问问 Java 开发人员如何解开 Python 堆栈跟踪！&lt;/p&gt;
&lt;p&gt;然后我们面临“太多数据”的问题。我们依赖工具来在大海捞针并过滤噪声，并使其清晰明了，即在任何时候，收集但未在任何可视化中公开或由任何警报使用的信号都是删除的候选信号。&lt;/p&gt;
&lt;h3 id=&#34;信号在大海中找到触发事件的针头&#34;&gt;信号：在大海中找到触发事件的针头&lt;/h3&gt;
&lt;p&gt;需要过滤和转换数据点才能生成适当的信号。没有人想每天 24x7 小时盯着仪表板或日志，因此我们依赖警报系统。当警报触发时，它旨在进行人类干预，这意味着将原始信号转换为带有上下文数据的可操作事件：警报的重要性、环境、描述、注释、链接等。必须提供足够的信息来引起对问题的关注，但不要提供太多的信息以避免被淹没在噪音中。&lt;/p&gt;
&lt;p&gt;页面警报需要人工响应。否则，工程师如何证明他们已经中断了他们的流程？&lt;/p&gt;
&lt;p&gt;当警报触发时，分析开始了。虽然我们热切地希望通过人工智能的出现实现异常检测和自动化分析，从而完全消除人为因素，但我们可以使用一些技巧来帮助我们的大脑快速识别问题所在。&lt;/p&gt;
&lt;h3 id=&#34;可视化不要低估平台---人类交互的价值&#34;&gt;可视化：不要低估平台 - 人类交互的价值&lt;/h3&gt;
&lt;p&gt;需要警报信号触发的阈值。在可视化方面，调查和检测异常的人员也需要考虑这些阈值。这个数据值是否过低或者出乎意料地高呢？&lt;/p&gt;
&lt;p&gt;在这个非常普遍的图表中，图表标题、轴标签和描述被故意删除了。我们缺乏上下文，但我们的大脑可以立即发现异常。导致图表的警报应该始终包含一个视觉指示器。它们对于突出趋势和异常模式是至关重要的，即使对于未受过训练的人。&lt;/p&gt;
&lt;h2 id=&#34;积极学习避免英雄文化训练你的团队&#34;&gt;积极学习：避免英雄文化；训练你的团队&lt;/h2&gt;
&lt;p&gt;在出问题时，你的团队中的谁是事实上的第一响应者和可观测性专家，当事情变得不好时会挺身而出呢？也许是你。要求他退缩，尽管越来越渴望恢复服务的正常运行时间并挽救局面。问问自己这些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最坏的情况是什么？&lt;/li&gt;
&lt;li&gt;是否会有其他人挺身而出？&lt;/li&gt;
&lt;li&gt;这对团队中其他人来说是个学习机会吗？&lt;/li&gt;
&lt;li&gt;这是一个教学机会吗？在这种情况下，跟随经验丰富的团队成员的阴影工作是否可行？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让其他人变得擅长工作。调整期望并给自己和团队调查的空间是减轻压力和应对紧急情况的关键。在控制的无压力环境中实时响应真实事件和生产系统中的数据是最终的训练。这就是为什么我们有 Game Days。&lt;/p&gt;
&lt;h3 id=&#34;game-days&#34;&gt;Game Days&lt;/h3&gt;
&lt;p&gt;游戏日是消防演习。我们需要接受故障和故障将发生的事实。游戏日的目标是通过提前练习我们的响应能力来减少实际事件的压力。我们希望在危机时能够快速自信地行动，并建立一些直觉和反应能力，这些能力在凌晨 4 点非常有用。练习使人完美！&lt;/p&gt;
&lt;p&gt;首先选择一个游戏大师和必要的同谋。通常，这些是域或系统的主题专家。他们需要仔细选择在游戏日活动期间将接受测试的系统和场景。以下情况非常普遍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重播以前的事件场景。这会测试事件响应过程是否得到改进，人们是否知道要关注哪些可观测性信号并了解如何相关数据点。这也是测试后期学习和纠正行动后系统更具弹性的好机会。&lt;/li&gt;
&lt;li&gt;确保一个新的系统或服务在进入生产之前具有正确的监控、警报和度量衡。这会测试您是否准备好操作系统，以及人们是否知道如何发现可观测性数据并知道如何响应警报。&lt;/li&gt;
&lt;li&gt;校准安全、优雅降级、高可用系统等方面的过度自信偏见。这会测试您是否实际了解系统的故障模式，以及工程师是否有能力诊断未知问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后要求游戏大师提出一组假设并预测演习的预期收益。评估演习对业务的影响（爆炸半径），并确定如果/需要采取的步骤以将其最小化（例如，通过将演习限制在时间框中，如果发生意外情况则中止它等）。&lt;/p&gt;
&lt;p&gt;然后开始游戏！故意破坏并引入一些混乱。我们希望人们在处理事件时依靠理性、专注和深思熟虑的认知功能。压力和恐惧会影响认知功能和决策能力。&lt;/p&gt;
&lt;p&gt;观察人类互动在这个解决问题的练习中如何发挥作用。这个练习是否促进了协作文化？团队成员是否互相支持？&lt;/p&gt;
&lt;h2 id=&#34;协作文化不再保留数据&#34;&gt;协作文化：不再保留数据&lt;/h2&gt;
&lt;p&gt;在团队中培养协作文化对每个人的福祉至关重要。分享数据、见解和问题将从团队成员中获得更多的参与、好奇心和信任。信息应该被共享，应避免保密。这些是简单的原则，但很少有组织符合这个标准，当从事事故学习时。透明的后期检查可以推动有意义的变革，我们应该庆祝失败！指责和指责的文化只会加速焦虑和意外的恶性循环。&lt;/p&gt;
&lt;p&gt;每个事件响应过程都应包括事后检查。有效的无指责事后检查将确保团队成员有权提出对过程、工具或系统的更改。这项活动通过纠正措施和质量改进使人们有能力做出改变。后期检查还应受益于组织中可能没有直接涉及领先事件的其他成员，因为书面记录应该广泛共享并作为学习材料。&lt;/p&gt;
&lt;h2 id=&#34;在值班时&#34;&gt;在值班时&lt;/h2&gt;
&lt;p&gt;工程师有能力理解可观测性数据。在团队的每个成员都积极学习如何应对游戏日事故的情况下，分享整个工程组织的值班任务非常重要，而不是只由少数精选人员负责。这也有助于减轻可能随时到来的重负和压力。当值班时，不应让任何一名工程师独自面对。角色和升级路径需要明确定义和理解。从第一响应者（911 调度员）到事故指挥官（专业人士）和升级经理（通常是负责沟通的工程经理），都不应要求他们成为英雄，而应要求他们协调和组装最适合解决问题的团队。&lt;/p&gt;
&lt;p&gt;在值班时，检查清单可以被称为“运行簿”或其他名称。这些清单可以作为认知援助，卸载完成复杂教学任务的思维过程。游戏日是测试这些清单的完美场所。&lt;/p&gt;
&lt;p&gt;因为我们已经通过消除信号噪声来确保减少虚假警报，并且每个人都了解自己在值班轮换中的角色，所以警报疲劳应该成为过去式。&lt;/p&gt;
&lt;h2 id=&#34;人仍然是分布式系统的核心&#34;&gt;人仍然是分布式系统的核心&lt;/h2&gt;
&lt;p&gt;通过实施这些策略，软件工程团队可以确保他们具备使用和有效理解可观测性信号所需的知识和技能。充分利用收集的数据对于提高分布式系统的整体性能和可靠性至关重要。教学和学习将使人因素超越单个个体。虽然我们仍然必须依靠人类大脑来诊断和解决问题，但让我们确保我们可以可持续地这样做。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>应用响应时延背后深藏的网络时延</title>
      <link>https://cloudnative.to/blog/analysis-of-delay-with-deepflow/</link>
      <pubDate>Wed, 08 Mar 2023 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/analysis-of-delay-with-deepflow/</guid>
      <description>&lt;p&gt;应用异常时，基本可以分为&lt;strong&gt;服务访问不通&lt;/strong&gt;和&lt;strong&gt;服务响应慢&lt;/strong&gt;两个大类。其中服务响应慢的问题定位非常棘手，很多无头案。应用团队有日志和追踪，对于自认为的不可能不合理的事情都会甩给基础设施团队，又由于基础设施团队现有的监控数据缺乏应用的观测视角，通常成为一切「不是我的问题」超自然现象的终极背锅侠，其中以网络团队尤为严重。&lt;/p&gt;
&lt;h2 id=&#34;响应时延&#34;&gt;响应时延&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;服务为什么响应慢&lt;/strong&gt;？？？首先，我们需要一种方式来度量何为响应慢，参考 Google 在 SRE Handbook 中提到过&lt;code&gt;4 个黄金信号&lt;/code&gt;及 Weave Cloud 提出来的 &lt;code&gt;RED 方法&lt;/code&gt;，都存在度量的指标（Latency/Duration），后文统称为&lt;code&gt;响应时延&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Latency 表达的是&lt;strong&gt;服务处理某个请求所需要的时间&lt;/strong&gt;，站在的是服务端视角&lt;/li&gt;
&lt;li&gt;Duration 表达的是&lt;strong&gt;每个请求所花费的时间&lt;/strong&gt;，站在的是客户端视角&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结下来，不论站在什么视角，&lt;code&gt;响应时延&lt;/code&gt;表达的都是处理一个请求所花费的时间，可以用来&lt;strong&gt;表征服务响应慢的度量指标&lt;/strong&gt;，但若要定位为什么响应慢还需要进一步剖解响应时延：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统时延：系统转发请求/响应的时延消耗&lt;/li&gt;
&lt;li&gt;网络时延：包含查询 DNS 时延及网络处理的时延&lt;/li&gt;
&lt;li&gt;应用时延：从不同视角来看，包含客户端应用处理时延 + 服务端应用处理时延&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-响应时延拆解&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./2.jpg&#34; alt=&#34;响应时延拆解&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      响应时延拆解
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;确定度量指标后，接下就可以分析服务响应慢的原因，此时可以利用&lt;strong&gt;分布式链路追踪&lt;/strong&gt;能力来快速来&lt;strong&gt;定界瓶颈点&lt;/strong&gt;，例如可利用 DeepFlow 的分布式追踪能力来快速定界瓶颈点在应用、系统还是网络。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-分布式链路追踪---火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./1.png&#34; alt=&#34;分布式链路追踪 - 火焰图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      分布式链路追踪 - 火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;完成瓶颈点定界后，则需要去查找根因。对于应用或者系统的问题，可以利用&lt;strong&gt;性能剖析（profile）继续追查根因&lt;/strong&gt;，而对应网络时延的分析，其中 DNS 时延分析是相对简单的，只需要关注请求的响应时延即可，但网络处理时延瓶颈的定位却缺少了分析的工具，接下来将主要聚焦讨论网络传输时延如何分析。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-性能剖析---火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./3.jpg&#34; alt=&#34;性能剖析 - 火焰图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      性能剖析 - 火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;网络时延&#34;&gt;网络时延&lt;/h2&gt;
&lt;p&gt;参考 AWS 中的定义网络时延是指网络通信中的延时，网络时延显示了数据通过网络传输所需的时间。&lt;strong&gt;讨论网络时延如何，也是需要可度量的指标&lt;/strong&gt;，AWS 也指定了使用“首字节时间”和“往返时间”等指标来衡量网络时延，这两个指标是可以适用于所有网络协议的传输时延的度量，但实际应用 80% 都使用的 TCP 协议，对于 TCP 协议是需要更细粒度的度量指标，下文通过图文的形式，详细的介绍目前可用的度量指标及用法。&lt;/p&gt;
&lt;p&gt;TCP 协议是面向连接的传输层通信协议，对其详细的通信过程分析，时延可分为三大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建连时产生的时延
&lt;ul&gt;
&lt;li&gt;[1] 完整的&lt;code&gt;建连时延&lt;/code&gt;包含客户端发出 SYN 包到收到服务端回复的 SYN+ACK 包，并再次回复 ACK 包的整个时间。建连时延拆解开又可分为&lt;code&gt;客户端建连时延&lt;/code&gt;与&lt;code&gt;服务端建连时延&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;code&gt;客户端建连时延&lt;/code&gt;为客户端收到 SYN+ACK 包后，回复 ACK 包的时间&lt;/li&gt;
&lt;li&gt;[3] &lt;code&gt;服务端建连时延&lt;/code&gt;为服务端收到 SYN 包后，回复 SYN+ACK 包的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据通信时产生的时延，可拆解为&lt;code&gt;客户端等待时延&lt;/code&gt;+&lt;code&gt;数据传输时延&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;[4] &lt;code&gt;客户端等待时延&lt;/code&gt;为建连成功后，客户端首次发送请求的时间；为收到服务端的数据包后，客户端再发起数据包的时间&lt;/li&gt;
&lt;li&gt;[5] &lt;code&gt;数据传输时延&lt;/code&gt;为客户端发送数据包到收到服务端回复数据包的时间&lt;/li&gt;
&lt;li&gt;[6] 在数据传输时延中还会产生系统协议栈的处理时延，称为&lt;code&gt;系统时延&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;断连时产生的时延：因为断连的时延并不影响到应用的响应时延，因此并不会单独统计此部分使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-tcp-网络时延解剖&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./4.jpg&#34; alt=&#34;TCP 网络时延解剖&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      TCP 网络时延解剖
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;度量的网络时延的指标已经拆解好了，接下来讨论在哪里采集指标&lt;/strong&gt;，网络的报文将在客户端，各种虚拟和物理网络与服务端之间穿梭，因此可报文穿梭的位置点来采集，后续统称为&lt;code&gt;统计位置&lt;/code&gt;。当然统计位置越多，定位网络的瓶颈路径越快，但是统计位置多则随之带来的计算量也是成倍增加，企业在有成本压力时，建议在重要节点进行采集即可，比如 K8s Pod 虚拟网卡、K8s Node 网卡、云服务器网卡、网关（如 LVS/Nginx 等）网卡、硬件防火墙/负载均衡器前后&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-统计位置&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./5.jpg&#34; alt=&#34;统计位置&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      统计位置
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;分析到这，&lt;strong&gt;基本已经清晰网络时延的详细的度量指标了，回过头结合响应时延再讨论下如何查看网络时延对其的影响&lt;/strong&gt;，基本可以分两种情况讨论&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用发起请求为短连接&lt;/strong&gt;：此时分析网络时延需要查看 &lt;strong&gt;DNS 时延 + 建连时延 + 客户端等待时延 + 数据传输时延 + 系统时延&lt;/strong&gt;，则可快速定位时延发生的具体原因了。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DNS 时延高&lt;/strong&gt;，结合统计位置，则可回答是&lt;strong&gt;网络传输时延高&lt;/strong&gt;还是&lt;strong&gt;DNS 服务响应慢&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;建连时延高&lt;/strong&gt;，结合客户端建连时延 + 服务端建连时延 + 统计位置，则可回答是&lt;strong&gt;网络传输时延高&lt;/strong&gt;还是&lt;strong&gt;客户端系统回复慢&lt;/strong&gt;还是&lt;strong&gt;服务端处理建连响应慢&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端等待时延高&lt;/strong&gt;，结合统计位置，则可回答是&lt;strong&gt;网络传输时延高&lt;/strong&gt;还是&lt;strong&gt;客户端请求发送延迟&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据传输时延高&lt;/strong&gt;，结合统计位置，则可回答是&lt;strong&gt;网络传输时延高&lt;/strong&gt;还是&lt;strong&gt;服务端响应慢&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统时延高&lt;/strong&gt;，结合统计位置，则可回答&lt;strong&gt;网络传输时延高&lt;/strong&gt;还是&lt;strong&gt;服务端协议栈处理慢&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用发起请求为长连接&lt;/strong&gt;：因为长连接是保持长期活动的 HTTP 连接，不需要考虑 DNS 查询与建连的时延消耗，只需要关注&lt;strong&gt;客户端等待时延 + 数据传输时延 + 系统时延&lt;/strong&gt;即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;案例分析&#34;&gt;案例分析&lt;/h2&gt;
&lt;p&gt;限于笔者时间限制又想早点将&lt;strong&gt;应用响应时延背后深藏的网络时延&lt;/strong&gt;剖解分享给大家，本文不继续补充实际案例，将在一周后分享在某 xx 智能终端公司的如何结合 DeepFlow 在&lt;strong&gt;服务响应慢时，网络团队在存在可观测性的时延数据时，如何硬气回怼。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;什么是-deepflow&#34;&gt;什么是 DeepFlow&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/deepflowys/deepflow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow&lt;/a&gt; 是一款开源的高度自动化的可观测性平台，是为云原生应用开发者建设可观测性能力而量身打造的全栈、全链路、高性能数据引擎。DeepFlow 使用 eBPF、WASM、OpenTelemetry 等新技术，创新的实现了 AutoTracing、AutoMetrics、AutoTagging、SmartEncoding 等核心机制，帮助开发者提升埋点插码的自动化水平，降低可观测性平台的运维复杂度。利用 DeepFlow 的可编程能力和开放接口，开发者可以快速将其融入到自己的可观测性技术栈中。&lt;/p&gt;
&lt;p&gt;GitHub 地址：https://github.com/deepflowys/deepflow&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&#34;https://deepflow.yunshan.net/docs/zh/install/overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow Demo&lt;/a&gt;，体验高度自动化的可观测性新时代。&lt;/p&gt;
&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/cn/what-is/latency/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://aws.amazon.com/cn/what-is/latency/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/22026261&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/22026261&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.to/aws/why-are-services-slow-sometimes-mn3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dev.to/aws/why-are-services-slow-sometimes-mn3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-promql-best-praticase&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-promql-best-praticase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.weave.works/blog/the-red-method-key-metrics-for-microservices-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.weave.works/blog/the-red-method-key-metrics-for-microservices-architecture/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/what-is/latency/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://aws.amazon.com/what-is/latency/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>可观测性实战：快速定位 K8s 应用故障</title>
      <link>https://cloudnative.to/blog/troubleshooting-of-the-k8s-application-with-deepflow/</link>
      <pubDate>Tue, 14 Feb 2023 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/troubleshooting-of-the-k8s-application-with-deepflow/</guid>
      <description>&lt;p&gt;故障发生在 2023 春节前两天，DeepFlow 团队内部访问工单系统出现问题，影响了所有北京区的同事，这篇文章将详细记录如何利用 DeepFlow 定位到对这次问题根因（网关 MSS 误变更导致报文大于 MTU，大数据报文被丢弃）。&lt;/p&gt;
&lt;h2 id=&#34;背景介绍&#34;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;工单系统是 DeepFlow 团队自主研发的一个跟踪工单的内部工具，部署在阿里公有云的容器服务（ACK）中，工单系统通过 Ingress 的方式对外提供服务，办公区与阿里云通过 VPN 连接，因此办公区可以直接使用域名访问工单系统。在&lt;a href=&#34;https://deepflow.yunshan.net/blog/020-k8s-service-exception-troubleshooting/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《K8s 服务异常排障过程全解密》&lt;/a&gt;文中对 K8s 访问方式做过总结，工单系统是比较典型的&lt;code&gt;方式三&lt;/code&gt;的访问形式&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-集群外客户端通过-ingress-访问集群内服务&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;集群外客户端通过 Ingress 访问集群内服务&#34; srcset=&#34;
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/1_hu3eb7482df3b531df42fb90370a58ba89_133175_c7a3401f10a291649313fded591db22c.webp 400w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/1_hu3eb7482df3b531df42fb90370a58ba89_133175_04629858c3e08170fa90814a5f01cd67.webp 760w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/1_hu3eb7482df3b531df42fb90370a58ba89_133175_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/troubleshooting-of-the-k8s-application-with-deepflow/1_hu3eb7482df3b531df42fb90370a58ba89_133175_c7a3401f10a291649313fded591db22c.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      集群外客户端通过 Ingress 访问集群内服务
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;下图是通过 DeepFlow 自动绘制的访问拓扑图，可以看出北京和广州办公区都是通过 Ingress 的形式来访问工单的入口服务 (ticket_web)。工单系统部署在基础服务的容器集群上，此容器集群所有的 Node 上都已经部署了 deepflow-agent，因此可以自动采集所有 POD 及 Node 的网络/系统/应用相关的数据，其中就包括阿里云 nginx-ingress-controller 服务对应的 POD 以及应用的 POD&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-工单系统访问拓扑&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;工单系统访问拓扑&#34; srcset=&#34;
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/3_hu510af6b4939069d4fbcb42aaef55c512_87502_74da9d07bdbda2060ae3cff6c1814b15.webp 400w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/3_hu510af6b4939069d4fbcb42aaef55c512_87502_9589d48a658ee580e295314b6ae1bd62.webp 760w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/3_hu510af6b4939069d4fbcb42aaef55c512_87502_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/troubleshooting-of-the-k8s-application-with-deepflow/3_hu510af6b4939069d4fbcb42aaef55c512_87502_74da9d07bdbda2060ae3cff6c1814b15.webp&#34;
               width=&#34;760&#34;
               height=&#34;358&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      工单系统访问拓扑
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;排障过程&#34;&gt;排障过程&lt;/h2&gt;
&lt;p&gt;下午 3:00 左右，陆续收到同事反馈，工单系统加载不出来，首先和工单系统研发明确，并未做过任何变更&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-故障现场&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;故障现场&#34; srcset=&#34;
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/4_hua2762a2b97262cf132e4a3b8ab602aac_164728_2c2603d2326172a0d073427e99de744f.webp 400w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/4_hua2762a2b97262cf132e4a3b8ab602aac_164728_fffc07213cfd8c26940a8c1331b051f4.webp 760w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/4_hua2762a2b97262cf132e4a3b8ab602aac_164728_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/troubleshooting-of-the-k8s-application-with-deepflow/4_hua2762a2b97262cf132e4a3b8ab602aac_164728_2c2603d2326172a0d073427e99de744f.webp&#34;
               width=&#34;760&#34;
               height=&#34;254&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      故障现场
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;依据&lt;a href=&#34;https://deepflow.yunshan.net/blog/020-k8s-service-exception-troubleshooting/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《K8s 服务异常排障过程全解密》&lt;/a&gt;总结的思路&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-k8s-服务异常排障思路&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;K8s 服务异常排障思路&#34; srcset=&#34;
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/5_huf40e422bd134640ff1094c07fa49e9bb_40473_0de577ceeae3c2b2ce3f89cc2ffc48d2.webp 400w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/5_huf40e422bd134640ff1094c07fa49e9bb_40473_7bb1900b5c961c0dc5653323b8732627.webp 760w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/5_huf40e422bd134640ff1094c07fa49e9bb_40473_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/troubleshooting-of-the-k8s-application-with-deepflow/5_huf40e422bd134640ff1094c07fa49e9bb_40473_0de577ceeae3c2b2ce3f89cc2ffc48d2.webp&#34;
               width=&#34;760&#34;
               height=&#34;470&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      K8s 服务异常排障思路
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;查看了对应的 &lt;code&gt;Node/POD&lt;/code&gt; 负载、状态等都正常；登录到 DeepFlow 平台，调出了工单系统的访问拓扑（拓扑上标红部分表明有异常），从访问拓扑可知&lt;code&gt;后端服务&lt;/code&gt;黄金指标也都一切正常；又通过图可看出来广州办公室对工单系统的访问也并没有异常（也同步与广州同事确认，访问一切正常），可推测 &lt;code&gt;DNS/SVC&lt;/code&gt; 也应该都正常；进一步结合拓扑图，&lt;strong&gt;可看出异常仅出现在北京办公室与 nginx-ingress-controller 之间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-访问拓扑&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;访问拓扑&#34; srcset=&#34;
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/6_huc09d4efcb33aeeacf144fc79baeef54c_91852_3bffe99b02d3324f72bb239362470db1.webp 400w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/6_huc09d4efcb33aeeacf144fc79baeef54c_91852_89720168effb05fc9a4b4abd6b829fa2.webp 760w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/6_huc09d4efcb33aeeacf144fc79baeef54c_91852_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/troubleshooting-of-the-k8s-application-with-deepflow/6_huc09d4efcb33aeeacf144fc79baeef54c_91852_3bffe99b02d3324f72bb239362470db1.webp&#34;
               width=&#34;760&#34;
               height=&#34;330&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      访问拓扑
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继续分析标红的路径&lt;/strong&gt;，查看对应的流日志，因为云下未部署采集器，因此仅支持查看的是 nginx-ingress-controller POD 以及 Node 的数据，发现了几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端异常都是因为&lt;code&gt;传输-连接超时&lt;/code&gt;导致的&lt;/li&gt;
&lt;li&gt;服务端异常时，服务端 (nginx-ingress-controller) 回复的数据包，都是大包&lt;/li&gt;
&lt;li&gt;服务端异常时，服务端 (nginx-ingress-controller) 都未收到任何客户端发送的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-流日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;流日志&#34; srcset=&#34;
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/7_hu0306f88ea6697776af52d9ce72391ae7_84292_f7cef79e1bdc5be4df9f43e63aeb1572.webp 400w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/7_hu0306f88ea6697776af52d9ce72391ae7_84292_a37303252d5c4bca730743ca668fc927.webp 760w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/7_hu0306f88ea6697776af52d9ce72391ae7_84292_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/troubleshooting-of-the-k8s-application-with-deepflow/7_hu0306f88ea6697776af52d9ce72391ae7_84292_f7cef79e1bdc5be4df9f43e63aeb1572.webp&#34;
               width=&#34;760&#34;
               height=&#34;91&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      流日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结合以上几点发现，怀疑方向转移到 MSS/MTU 上&lt;/strong&gt;，立马咨询了 IT 同事，是不是变动过网关的 MSS/MTU 值，IT 同事否认了&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-聊天记录--01&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;聊天记录 -01&#34; srcset=&#34;
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/8_hu82ab74ef14b8e0a8332c52729a142b49_55800_278b93b38397f2112b9be36fa6cde951.webp 400w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/8_hu82ab74ef14b8e0a8332c52729a142b49_55800_429765a21705f53e63351d619e893c18.webp 760w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/8_hu82ab74ef14b8e0a8332c52729a142b49_55800_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/troubleshooting-of-the-k8s-application-with-deepflow/8_hu82ab74ef14b8e0a8332c52729a142b49_55800_278b93b38397f2112b9be36fa6cde951.webp&#34;
               width=&#34;760&#34;
               height=&#34;125&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      聊天记录 -01
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;既然云下部分未变动过，转而怀疑是不是 nginx-ingress-controller 动过 MSS/MTU&lt;/strong&gt;，通过&lt;code&gt;时序图&lt;/code&gt;查看 MSS 是否有变化，通过故障前后对比可知：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端在故障前后发送的 MSS 确实发生过变动，从 1280 变为了 1380&lt;/li&gt;
&lt;li&gt;服务端 (nginx-ingress-controller) MSS 值一直未变动过&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-时序图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;时序图&#34; srcset=&#34;
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/9_hubf2ef94933fc91e4f73dafca19eab66c_97010_f42038953292ae1d8572b2ee72d5533a.webp 400w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/9_hubf2ef94933fc91e4f73dafca19eab66c_97010_089c486fac69e51f8dd8cc8f79623563.webp 760w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/9_hubf2ef94933fc91e4f73dafca19eab66c_97010_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/troubleshooting-of-the-k8s-application-with-deepflow/9_hubf2ef94933fc91e4f73dafca19eab66c_97010_f42038953292ae1d8572b2ee72d5533a.webp&#34;
               width=&#34;760&#34;
               height=&#34;218&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      时序图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过数据可明确，云下一定变动过 MSS 值，拿着数据截图又去找 IT 同事，最后 IT 同事一顿找，&lt;strong&gt;明确改了 MSS 值&lt;/strong&gt;，将 MSS 值恢复后，工单系统恢复正常&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-聊天记录--02&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;聊天记录 -02&#34; srcset=&#34;
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/10_huf6a3031d370b4dc6619de1790b5b3438_81036_1cbd86ee8b560dc0ed600f47992b0979.webp 400w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/10_huf6a3031d370b4dc6619de1790b5b3438_81036_e3e49bbb75f60ba3e01553b722645480.webp 760w,
               /blog/troubleshooting-of-the-k8s-application-with-deepflow/10_huf6a3031d370b4dc6619de1790b5b3438_81036_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/troubleshooting-of-the-k8s-application-with-deepflow/10_huf6a3031d370b4dc6619de1790b5b3438_81036_1cbd86ee8b560dc0ed600f47992b0979.webp&#34;
               width=&#34;760&#34;
               height=&#34;271&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      聊天记录 -02
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;问题总结&#34;&gt;问题总结&lt;/h2&gt;
&lt;p&gt;问：&lt;strong&gt;MSS 值变动了，为什么影响了工单系统&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为云下的 MTU 值设置的是 1420，如果 MSS 值为 1380 + 报文头则会大于 MTU 值，因此大数据报文无法通过云下的网关，这就导致了 nginx-ingress-controller 收不到任何客户端的回应（客户端也未收到服务端的包）出现&lt;code&gt;传输-连接超时&lt;/code&gt;的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问：&lt;strong&gt;MSS 值变动了，为什么其他内部系统未受到影响&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工单描述中包含了大量的图片和文件，因此存在传输大数据的情况，而其他系统大部分都是文字传输，所以未受到明显影响&lt;/li&gt;
&lt;li&gt;其他如 gitlab 存在图片和大文字传输的服务，并未使用 Ingress 的方式对外提供访问形式，而是利用阿里云 Terway 提供的内网直接访问 Headless 服务后端 POD 的方式，在协商 MSS 值时，后端 POD 的值为 1360（nginx-ingress-controller 的值为 1460），因此最终协商的取 1360 + 报文头则小于 MTU 值，所以也未受到明显影响&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;什么是-deepflow&#34;&gt;什么是 DeepFlow&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/deepflowys/deepflow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow&lt;/a&gt; 是一款开源的高度自动化的可观测性平台，是为云原生应用开发者建设可观测性能力而量身打造的全栈、全链路、高性能数据引擎。DeepFlow 使用 eBPF、WASM、OpenTelemetry 等新技术，创新的实现了 AutoTracing、AutoMetrics、AutoTagging、SmartEncoding 等核心机制，帮助开发者提升埋点插码的自动化水平，降低可观测性平台的运维复杂度。利用 DeepFlow 的可编程能力和开放接口，开发者可以快速将其融入到自己的可观测性技术栈中。&lt;/p&gt;
&lt;p&gt;GitHub 地址：https://github.com/deepflowys/deepflow&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&#34;https://deepflow.yunshan.net/docs/zh/install/overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow Demo&lt;/a&gt;，体验高度自动化的可观测性新时代。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>可观测性场景下 Grafana Plugin 开发实战</title>
      <link>https://cloudnative.to/blog/grafana-plugins-on-cloud-observability/</link>
      <pubDate>Wed, 28 Dec 2022 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/grafana-plugins-on-cloud-observability/</guid>
      <description>&lt;p&gt;本文为云杉网络&lt;code&gt;原力释放 - 云原生可观测性分享会&lt;/code&gt;第十三期直播实录。&lt;a href=&#34;https://www.bilibili.com/video/BV1f44y1m7n8/?spm_id_from=333.788&amp;amp;vd_source=37077a01afa812c311092cba5befac7c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;回看链接&lt;/a&gt;，&lt;a href=&#34;http://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/yunshan-ticket/pdf/95b33b06763f2d05b77c18327aa38c3c_20221213150423.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PPT 下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Grafana 是目前最广泛使用的数据可视化软件之一，DeepFlow 中已有大量基于 Grafana Dashboard 解决的可观测性场景的实战分享。这些场景都是基于 DeepFlow Grafana 插件提供的查询能力来构建的。DeepFlow 社区致力于基于开源生态构建一个完整的可观测性平台，而终端呈现和数据的可视化呈现是其中的重要一环。本文对当前 DeepFlow 提供的 Grafana 插件做一个简单介绍，抛砖引玉，希望大家能了解并创造更多的 DeepFlow 可观测性生态应用，也希望能让大家掌握如何开发一套完整的 Grafana Plugin。&lt;/p&gt;
&lt;h2 id=&#34;deepflow-插件简介&#34;&gt;DeepFlow 插件简介&lt;/h2&gt;
&lt;p&gt;在最早的 DeepFlow 企业版中，我们提供了一些比较简单的 Grafana 插件。这些插件是基于 DeepFlow 企业版 API 来提供服务的，目的是为了能让用户无缝将 DeepFlow 页面中的视图在自己的 Grafana 环境中搭建起来，避免改变用户的使用习惯。在 DeepFlow 宣布开源以后，我们基于社区版重新设计了若干插件。包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data source plugin：DeepFlow Querier，用于为 Grafana 提供 DeepFlow 的数据&lt;/li&gt;
&lt;li&gt;Panel plugin：DeepFlow AppTracing，用于展示分布式追踪火焰图&lt;/li&gt;
&lt;li&gt;Panel plugin：DeepFlow Topo，用于展示服务之间的访问关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些定制化插件，配合 Grafana 原本提供的一系列标准图表，可以构建出一组完整的 DeepFlow 可观测性视图。可以前往我们的&lt;a href=&#34;https://ce-demo.deepflow.yunshan.net/d/pplication_DNS_Monitoring/application-dns-monitoring?orgId=1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在线 Demo&lt;/a&gt; 快速体验。&lt;/p&gt;
&lt;h2 id=&#34;data-source-plugin&#34;&gt;Data source plugin&lt;/h2&gt;
&lt;p&gt;Grafana 的 Data source 插件是用来将数据源接入 Grafana 体系中的核心插件。DeepFlow 架构中，提供了基于 SQL 查询语句的 Querier 接口，因此我们的 Data source 插件会基于这个查询语法，来提供用户完全自由的查询。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./20221214639946e49a2f2.png&#34; alt=&#34;DeepFlow 架构&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从代码的文件结构，Data source 插件主要有如下部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ConfigEditor 是在 Grafana 中加入数据源时配置编辑模块，一般用于配置数据源本身连接方式、账户密码等。只需要实现对应的 ConfigEditor 类即可实现对应的编辑界面。&lt;/li&gt;
&lt;li&gt;QueryEditor 是构建数据源查询界面的主要模块，通过实现 QueryEditor 类即可实现编辑界面，其中可以自由引用 Grafana 自带 UI 库或者其他第三方库进行界面实现。&lt;/li&gt;
&lt;li&gt;Grafana 在 dashboard 中还可以支持变量。通过实现 VariableQueryEditor 可以实现自定义的变量动态查询，方便 dashboard 中关联使用。&lt;/li&gt;
&lt;li&gt;datasource.ts 是核心的逻辑模块，用于处理从界面接受的配置项，并从后端进行查询并对返回数据进行处理&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;zhenyu@dev202 deepflow-gui-grafana&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;$ tree deepflow-querier-datasource/src/ -L &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deepflow-querier-datasource/src/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── components
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── ConfigEditor.tsx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── consts.ts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── datasource.ts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── img
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── index.d.ts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── module.ts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── plugin.json
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── QueryEditor.css
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── QueryEditor.tsx
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── types.ts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── update-dashboards.js
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;└── utils
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;模块之间的关系如下图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-插件代码结构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./202212096392dfcb09cf3.png&#34; alt=&#34;插件代码结构&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      插件代码结构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;注意其中需要在插件的 plugin.json 中配置相关的 proxy 信息，这样能让 Grafana core 中的 backendsrv 知道该如何转发去往 querier 的请求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;path&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;auth&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;{{ .JsonData.requestUrl }}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;headers&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Content-Type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;content&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;application/x-www-form-urlencoded&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;authorization&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;content&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Bearer {{ .JsonData.token }}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从执行的数据流角度，Data source 插件中的数据流如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将用户在 QueryEditor 中输入的查询内容，构造为一个标准 JSON 结构&lt;/li&gt;
&lt;li&gt;将 JSON 化的查询条件通过 DeepFlow Querier SDK 生成一个有效的查询语句（SQL）&lt;/li&gt;
&lt;li&gt;将语句封装为 API 请求&lt;/li&gt;
&lt;li&gt;通过 plugin 的 plugin.json 中设置的 proxy 转发至 DeepFlow Querier&lt;/li&gt;
&lt;li&gt;将 DeepFlow Querier 返回的数据转换为符合 Panel 需要的数据&lt;/li&gt;
&lt;li&gt;在 Panel 中将数据可视化呈现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-数据流&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./202212096392dfec166f5.png&#34; alt=&#34;数据流&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      数据流
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其中，DeepFlow Querier SDK 是一个 DeepFlow 的内部转换库，可以将标准化的 JSON 结构转换为 SQL 或者 DeepFlow APP 所需要的参数格式。&lt;/p&gt;
&lt;p&gt;上述数据流中最后一步，是将从 Querier 中获取查询到的数据，并可以将这些数据发送给 Panel 模块，用于可视化展示。&lt;/p&gt;
&lt;h2 id=&#34;deepflow-查询数据逻辑简介&#34;&gt;DeepFlow 查询数据逻辑简介&lt;/h2&gt;
&lt;p&gt;在如何将查询数据结果进行可视化展现之前，需要简单的介绍下 DeepFlow 的数据查询逻辑。&lt;/p&gt;
&lt;p&gt;DeepFlow 中的数据表，一般会分为双端表和单端表两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单端表是对单个服务或实例的统计数据，数据本身没有方向。例如某个 K8s 服务的 RED 指标数据，某个进程的网络性能指标等等。这种数据一般适合用常规的折线、柱图、表格等展示。&lt;/li&gt;
&lt;li&gt;双端表是对 A 服务到 B 服务的访问路径的统计数据，有源、目的、方向等区分。例如，&lt;code&gt;A -&amp;gt; B&lt;/code&gt; 和 &lt;code&gt;B -&amp;gt; A&lt;/code&gt; 是两条不同的数据。这种数据一般适合用拓扑图等表征访问关系的视图进行展示。目前双端表有：
&lt;ul&gt;
&lt;li&gt;flow_metrics.vtap_app_edge_port：服务之间的应用访问关系和性能指标&lt;/li&gt;
&lt;li&gt;flow_metrics.vtap_flow_edge_port：服务之间的网络访问关系和性能指标&lt;/li&gt;
&lt;li&gt;flow_log.l7_flow_log：应用调用日志&lt;/li&gt;
&lt;li&gt;flow_log.l4_flow_log：网络流日志&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，DeepFlow 的存储数据和其他主流 TSDB/OLAP 也一样，所有的表都会有时间列、有 Tag 和 Metric 的区分，以及支持数据的分组聚合能力。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-分组聚合&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./2022121463996a6ae21d4.png&#34; alt=&#34;分组聚合&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      分组聚合
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图中每个小圆点代表一行数据。查询到的原始数据，经过分组后，每组中有若干条数据，再对每组数据中进行聚合计算，每个分组得到一列数据。&lt;/p&gt;
&lt;p&gt;这样的查询方式，可以很方便的查询出如下场景的数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每分钟的平均请求数 &lt;code&gt;SELECT AVG(request) ... GROUP BY INTERVAL(time, 60)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每个 K8s Pod 在每分钟中的平均 TCP 重传比率 &lt;code&gt;SELECT AVG(retrans_ratio) ... GROUP BY INTERVAL(time, 60), pod&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从 QueryEditor UI 收集到的用户输入，会通过统一模块转换为 querier 认识的 SQL 语句，或者 API 约定的参数结构。我们提供了一个 SDK &lt;code&gt;deepflow-sdk-js&lt;/code&gt;，可以按需将结构化的数据生成指定的文本输出。&lt;/p&gt;
&lt;p&gt;这个 SDK 中，会首先对结构数据补充相关的信息，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例分组转换为实例 ID 的分组，避免实例之间的重名&lt;/li&gt;
&lt;li&gt;自动增加 &lt;code&gt;node_type&lt;/code&gt;、&lt;code&gt;icon_id&lt;/code&gt; 等算子，用于附加实例的类型和对应图标等信息&lt;/li&gt;
&lt;li&gt;实现对枚举类型的自动翻译，例如 &lt;code&gt;protocol&lt;/code&gt; 会自动附加 &lt;code&gt;Enum(protocol)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自动进行别名转换，以可读的方式展示每一列数据名称&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SDK 中还会通过指定函数或者操作符的序列化，按照定制方式生成 SQL 语句。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;EQ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;escape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NEQ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;escape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;escape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LTE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;escape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;escape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GTE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;escape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;IN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;formatIn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NOT_IN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;formatIn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;REGEXP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt; REGEXP &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;escape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NOT_REGEXP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt; NOT REGEXP &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;escape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;AS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt; AS \`&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;\``&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SELF&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;INTERVAL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;sb&#34;&gt;`time(&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;, &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;)`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LIKE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;formatLike&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;OP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NOT_LIKE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;formatLike&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中还会对一些逻辑运算符进行自动的化简和合并。例如条件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;and&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;or&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;and&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nx&#34;&gt;not&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;and&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nx&#34;&gt;eq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;vm_name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;ab c&amp;#34; bla&amp;#34;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nx&#34;&gt;eq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;ip&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.1.1.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nx&#34;&gt;eq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;subnet_1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nx&#34;&gt;oneOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;subnet_1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;subnet_2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nx&#34;&gt;like&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;host&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;host.*&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nx&#34;&gt;or&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;and&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;bps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;rps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;lt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;bps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;and&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;not&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;or&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;rps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;and&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;and&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;bps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;rps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;falseOp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出的条件结果为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vm_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;ab c&amp;#34; bla&amp;#34;&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;OR&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;10.1.1.1&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;OR&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;subnet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;subnet_1&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;OR&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;subnet&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NOT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;IN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;subnet_1&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;subnet_2&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;OR&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NOT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;REGEXP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;host.*&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;AND&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bps&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;AND&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rps&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;OR&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bps&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;OR&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rps&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;data-source-plugin-对数据的处理&#34;&gt;Data source plugin 对数据的处理&lt;/h2&gt;
&lt;p&gt;通过上面的 Data source 插件，我们已经成功从 Querier 中查询出一组数据。接下来需要将这些数据进行展示。很简单的，通过 Grafana 列表插件，我们可以得到这组数据的列表：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-数据列表&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./20221206638f00ee8300d.png&#34; alt=&#34;数据列表&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      数据列表
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但如果我们进一步想要画出这个列表对应的折线图时，会遇到一个问题：如何将这些数据整理为折线图 Panel 所需要的数据结构呢？在折线图中，需要每条线有单独的 Series，而我们目前只有一个 &lt;code&gt;data: Record&amp;lt;string, any&amp;gt;[]&lt;/code&gt; 结构的数据。当我们需要展示多条线时，是无法画出想要的图的。&lt;/p&gt;
&lt;p&gt;因此我们在 Data source plugin 中提供了一个输出格式的转换选择，可以根据选择的 Panel 转换为不同的数据结构：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-格式化数据&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./20221206638f02880686e.png&#34; alt=&#34;格式化数据&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      格式化数据
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当选择折线图时，会把数据转换为 &lt;code&gt;data: [{time: timestamp, 组1: number}, {time: timestamp, 组2: number}, ...}]&lt;/code&gt; 的结构，这样折线图 Panel 会按组绘制出对应的折线。&lt;/p&gt;
&lt;p&gt;在数据转换时，会根据分组的 Tag 中所有可能取值进行分组。例如当分组条件为 Pod 时，就能绘制出每个 Pod 的折线：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-分组折线图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./20221206638f05a84acfc.png&#34; alt=&#34;分组折线图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      分组折线图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;组X&lt;/code&gt; 的名称，可以通过自定义的形式进行格式化：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-格式化名称&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./20221206638f062cca546.png&#34; alt=&#34;格式化名称&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      格式化名称
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;同样，在选择拓扑图时，也需要对返回的数据做二次处理，将数据处理为 Panel 识别的格式。&lt;/p&gt;
&lt;h2 id=&#34;deepflow-topo-panel&#34;&gt;DeepFlow Topo panel&lt;/h2&gt;
&lt;p&gt;DeepFlow 中大量数据都在描述微服务之间的访问关系，因此需要一个流量拓扑图来进行展示这些数据。我们基于 d3.js 来构建流量拓扑，主要的考虑点为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自由度更高&lt;/li&gt;
&lt;li&gt;更能满足产品经理的各种要求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;绘制流量拓扑时，我们使用客户端优先的模式进行宽度优先搜索，将单纯的客户端节点作为第一层，然后遍历去构建出整个拓扑。&lt;/p&gt;
&lt;p&gt;在普通拓扑的基础上，我们还提供了瀑布拓扑的展现形式，可以有序的呈现拓扑各节点的关系：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-瀑布拓扑&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./20221214639943f4432ad.png&#34; alt=&#34;瀑布拓扑&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      瀑布拓扑
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;瀑布拓扑会提供额外的分组能力，能够对拓扑做二次分组：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-瀑布拓扑的二次分组能力&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./202212146399443d643ca.png&#34; alt=&#34;瀑布拓扑的二次分组能力&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      瀑布拓扑的二次分组能力
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;瀑布拓扑使用普通拓扑嵌套的方式构建，可以实现在分组聚合情况下的拓扑展示。&lt;/p&gt;
&lt;h2 id=&#34;deepflow-apptracing-panel&#34;&gt;DeepFlow AppTracing panel&lt;/h2&gt;
&lt;p&gt;AppTracing panel 用来展现应用追踪数据。这些数据是从应用访问中通过 eBPF、cBPF、OpenTelemetry 等采集到的一组结构化日志数据，有起始时间，也有从属关系。通过时间先后关系和从属关联，构建出应用访问的火焰图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-分布式追踪&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./20221214639942c884286.png&#34; alt=&#34;分布式追踪&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      分布式追踪
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了使用 DeepFlow AppTracing panel 来可视化应用追踪数据，我们也支持使用 Grafana Tempo 来显示 DeepFlow 的 Tracing 数据。&lt;/p&gt;
&lt;p&gt;我们设计了一个完全模拟 Grafana Tempo backend 的模块，通过实现 Tempo 的 API，可以无缝将 DeepFlow 中的统计数据注入 Tempo UI 中显示，而且不需要额外部署 Tempo 后端：&lt;/p&gt;
&lt;p&gt;DeepFlow 使用 Tempo Panel, 通过 &lt;code&gt;deepflow-server&lt;/code&gt; 替代 tempo 的 backend：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-tempo&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./2022121363985b3136396.png&#34; alt=&#34;DeepFlow-Tempo&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow-Tempo
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其中需要实现的 API:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-tempo-api&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./2022121363984b093583b.png&#34; alt=&#34;Tempo-API&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Tempo-API
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;deepflow-vis&#34;&gt;DeepFlow-Vis&lt;/h2&gt;
&lt;p&gt;上述的两个 Panel 插件，核心都是一组基于 d3.js 的可视化库。这些功能我们整合到一个独立的可视化库中，为 Panel 提供绘图能力。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-vis&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./202212146399428a4e867.png&#34; alt=&#34;DeepFlow-Vis&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow-Vis
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;DeepFlow-Vis 提供如下能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素的抽象，提供了应用层的抽象元素&lt;/li&gt;
&lt;li&gt;几何计算，提供元素本身的几何运算，并提供一些简单的布局模型&lt;/li&gt;
&lt;li&gt;提供属性和绘图元素的直接获取，调用层可以很方便的获取数据以及基础的 dom/svg 等对象，方便自行修改&lt;/li&gt;
&lt;li&gt;提供了一个独立的渲染层，可以使用不同的方式进行渲染输出，如使用 canvas 替换 svg&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些能力是以一个比较松散的结构组合在一起，因此在人力有限的情况下，可以更快的实现不同需求场景下的不同适配。&lt;/p&gt;
&lt;p&gt;在此之上，提供了一些封装好的绘图，并实装在 AppTracing 和 Topo panel 中。&lt;/p&gt;
&lt;h2 id=&#34;next&#34;&gt;Next&lt;/h2&gt;
&lt;p&gt;我们计划在 DeepFlow 后续版本中，将对应的 Grafana 插件及相关库全部开源，并完成在 Grafana 官方的注册。也欢迎大家能够一起加入，丰富 DeepFlow 客观性的生态。&lt;/p&gt;
&lt;h2 id=&#34;什么是-deepflow&#34;&gt;什么是 DeepFlow&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/deepflowys/deepflow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow&lt;/a&gt; 是一款开源的高度自动化的可观测性平台，是为云原生应用开发者建设可观测性能力而量身打造的全栈、全链路、高性能数据引擎。DeepFlow 使用 eBPF、WASM、OpenTelemetry 等新技术，创新的实现了 AutoTracing、AutoMetrics、AutoTagging、SmartEncoding 等核心机制，帮助开发者提升埋点插码的自动化水平，降低可观测性平台的运维复杂度。利用 DeepFlow 的可编程能力和开放接口，开发者可以快速将其融入到自己的可观测性技术栈中。&lt;/p&gt;
&lt;p&gt;GitHub 地址：https://github.com/deepflowys/deepflow&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&#34;https://deepflow.yunshan.net/docs/zh/install/overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow Demo&lt;/a&gt;，体验高度自动化的可观测性新时代。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes 服务异常排障过程全解密</title>
      <link>https://cloudnative.to/blog/k8s-service-exception-troubleshooting/</link>
      <pubDate>Mon, 26 Dec 2022 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/k8s-service-exception-troubleshooting/</guid>
      <description>&lt;p&gt;Kubernetes（K8s）是一个用于大规模运行分布式应用和服务的开源容器编排平台。K8s 让应用发布更加快速安全，让应用部署也更加灵活，但在带来这些便利性的同时，也给应用排障增加了 K8s 平台层面的复杂度，本篇文章将以常见的服务异常入手，来详细拆解 K8s 服务访问方式，以及如何利用现有的可观测体系来对 k8s 平台和应用服务进行快速排障。&lt;/p&gt;
&lt;h2 id=&#34;服务的访问方式&#34;&gt;服务的访问方式&lt;/h2&gt;
&lt;p&gt;开启 K8s 服务异常排障过程前，须对 K8s 服务的访问路径有一个全面的了解，下面我们先介绍目前常用的 K8s 服务访问方式（不同云原生平台实现方式可能基于部署方案、性能优化等情况会存在一些差异，但是如要运维 K8s 服务，则需要在一开始就对访问方式有一个了解）。&lt;/p&gt;
&lt;p&gt;方式一：&lt;strong&gt;集群内客户端通过 ClusterIP 访问集群内服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-集群内客户端通过-clusterip-访问集群内服务&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;集群内客户端通过 ClusterIP 访问集群内服务&#34; srcset=&#34;
               /blog/k8s-service-exception-troubleshooting/1_hu481a70ad7adbbda78ae05af465de7098_48788_7610414c6383d18072c9842d129cb80f.webp 400w,
               /blog/k8s-service-exception-troubleshooting/1_hu481a70ad7adbbda78ae05af465de7098_48788_c25036f0ddf217660361283c45726a74.webp 760w,
               /blog/k8s-service-exception-troubleshooting/1_hu481a70ad7adbbda78ae05af465de7098_48788_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/k8s-service-exception-troubleshooting/1_hu481a70ad7adbbda78ae05af465de7098_48788_7610414c6383d18072c9842d129cb80f.webp&#34;
               width=&#34;760&#34;
               height=&#34;572&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      集群内客户端通过 ClusterIP 访问集群内服务
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;访问逻辑拓扑&lt;/code&gt;来分析，集群内客户端 POD 访问的是集群内服务的 svc_name，然后在 svc 层进行 DNAT，将请求转发到对应的后端 POD。这个过程对应的&lt;code&gt;访问实现拓扑&lt;/code&gt;则要复杂不少：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step 1: client_pod 根据 DNS 配置，请求 DNS 服务器解析 svc_name，DNS 服务器会返回 svc_name 对应的 ClusterIP&lt;/li&gt;
&lt;li&gt;step 2: client_pod 请求 ClusterIP，Node 根据 kube-proxy 配置的 IPVS/IPTABLES 完成 DNAT&lt;/li&gt;
&lt;li&gt;step 3: 根据 DNAT 的结果，Node 将请求转发给对应的 server_pod，server_pod 可能与 client_pod 在同一个 Node，也可能在不同 Node，此差异主要体现在网络转发层面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方式二：&lt;strong&gt;集群外客户端通过 NodePort 访问集群内服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-集群外客户端通过-nodeport-访问集群内服务&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;集群外客户端通过 NodePort 访问集群内服务&#34; srcset=&#34;
               /blog/k8s-service-exception-troubleshooting/2_hu938b1f4c551852395b7e9ea81c8432a1_44738_bac641b6a581a541f5fc0998bb9d7600.webp 400w,
               /blog/k8s-service-exception-troubleshooting/2_hu938b1f4c551852395b7e9ea81c8432a1_44738_a374cd75c8411e42b51c06ed1492a224.webp 760w,
               /blog/k8s-service-exception-troubleshooting/2_hu938b1f4c551852395b7e9ea81c8432a1_44738_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/k8s-service-exception-troubleshooting/2_hu938b1f4c551852395b7e9ea81c8432a1_44738_bac641b6a581a541f5fc0998bb9d7600.webp&#34;
               width=&#34;760&#34;
               height=&#34;573&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      集群外客户端通过 NodePort 访问集群内服务
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;相比&lt;code&gt;方式一&lt;/code&gt;，&lt;code&gt;访问逻辑拓扑&lt;/code&gt;上 client 访问的区别是从 svc_name 替换为 nodeip:port。&lt;code&gt;访问实现拓扑&lt;/code&gt;主要过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step 1: client 直接请求 svc 对外暴露的 nodeip:port，如果是 LoadBalance 类型的服务，在此之前还会访问 LB（因为并不是 K8s 服务的中的特别能力，所以此处并无特别说明），请求转发到对应的 Node 上，Node 也会根据 kube-proxy 配置的 IPVS/IPTABLES 完成 DNAT&lt;/li&gt;
&lt;li&gt;step 2: 与&lt;code&gt;方式一&lt;/code&gt;的 step 3 一致&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方式三：&lt;strong&gt;集群外客户端通过 Ingress 访问集群内服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-集群外客户端通过-ingress-访问集群内服务&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;集群外客户端通过 Ingress 访问集群内服务&#34; srcset=&#34;
               /blog/k8s-service-exception-troubleshooting/3_hub91409d41c060708195a6e1d616e1f93_64647_435be17f76503b86ada92fbccaf41135.webp 400w,
               /blog/k8s-service-exception-troubleshooting/3_hub91409d41c060708195a6e1d616e1f93_64647_81d0791a09749c09b9bca8ed574a00b8.webp 760w,
               /blog/k8s-service-exception-troubleshooting/3_hub91409d41c060708195a6e1d616e1f93_64647_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/k8s-service-exception-troubleshooting/3_hub91409d41c060708195a6e1d616e1f93_64647_435be17f76503b86ada92fbccaf41135.webp&#34;
               width=&#34;760&#34;
               height=&#34;642&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      集群外客户端通过 Ingress 访问集群内服务
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;方式三&lt;/code&gt;相比前两种方式，引入了 Ingress 的概念，因此复杂度增加了非常多。&lt;code&gt;访问逻辑拓扑&lt;/code&gt;中外部 client 可以直接请求 url 而不是 ip 了，请求 url 会先到达 Ingress，由 Ingress 完成反向代理，转发给后端的 svc，svc 再完成 DNAT 转发给后端 POD。&lt;code&gt;访问实现拓扑&lt;/code&gt;会根据 ingress-controller 部署形式不同而有差异，ingress-controller &lt;strong&gt;非&lt;/strong&gt; hostnetwork 部署下文简称&lt;code&gt;部署模式一&lt;/code&gt;，ingress-controller hostnetwork 部署下文简称&lt;code&gt;部署模式二&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step 1：外部 client 请求 DNS 服务器解析 url 的域名，DNS 服务会返回 ingress-controller 服务所在的 IP (如果前面有挂 LB，则访问的是 LB 的 IP，否则返回的是 ingress-controller 服务的 nodeip:port)&lt;/li&gt;
&lt;li&gt;step 2：此时&lt;code&gt;部署模式一&lt;/code&gt;，则需要按&lt;code&gt;方式二&lt;/code&gt;访问 ingress-controller（为避免画图过于复杂，未画出 ingress_controller_pod 分布在不同 Node 场景）；&lt;code&gt;部署模式二&lt;/code&gt;，请求到达 Node 后，则直接转给 ingress_controller_pod&lt;/li&gt;
&lt;li&gt;step 3：此为&lt;code&gt;部署模式一&lt;/code&gt;特有的步骤，参考&lt;code&gt;方式二&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;step 4/5/6：请求经过 ingress_controller_pod 后，已经确定需要转发的后端 svc，则按&lt;code&gt;方式一&lt;/code&gt;进行转发即可（为避免画图过于复杂，未画出 server_pod 分布在同 Node 场景）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务异常的排障思路&#34;&gt;服务异常的排障思路&lt;/h2&gt;
&lt;p&gt;了解服务的访问方式后，在遇到服务异常时，基于一套整体的排障思路来开展工作，更能事半功倍，接下来详细聊聊如何进行排障。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务异常的排障思路&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;服务异常的排障思路&#34; srcset=&#34;
               /blog/k8s-service-exception-troubleshooting/4_huf40e422bd134640ff1094c07fa49e9bb_40473_0291e587cbf1cafc7350cd08f9f7071a.webp 400w,
               /blog/k8s-service-exception-troubleshooting/4_huf40e422bd134640ff1094c07fa49e9bb_40473_8869ac007c540fdbcbc02ea3db59e695.webp 760w,
               /blog/k8s-service-exception-troubleshooting/4_huf40e422bd134640ff1094c07fa49e9bb_40473_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/k8s-service-exception-troubleshooting/4_huf40e422bd134640ff1094c07fa49e9bb_40473_0291e587cbf1cafc7350cd08f9f7071a.webp&#34;
               width=&#34;760&#34;
               height=&#34;470&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务异常的排障思路
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;step 1：&lt;strong&gt;确定 Node/POD 是否异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们可以通过 Prometheus 提供的 Dashboard 来检查部署的实例的基础状态，通过直接查看应用的 CPU/内存/带宽等指标，确认目前部署实例的负载都在正常范围内。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-node&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;node&#34; srcset=&#34;
               /blog/k8s-service-exception-troubleshooting/5_hu566706784b9f59bc878cfc040fba735f_150311_b138c3565cbfb4ff830167f407859af9.webp 400w,
               /blog/k8s-service-exception-troubleshooting/5_hu566706784b9f59bc878cfc040fba735f_150311_ed6d00587dcd13ab02fac7166c15a3cf.webp 760w,
               /blog/k8s-service-exception-troubleshooting/5_hu566706784b9f59bc878cfc040fba735f_150311_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/k8s-service-exception-troubleshooting/5_hu566706784b9f59bc878cfc040fba735f_150311_b138c3565cbfb4ff830167f407859af9.webp&#34;
               width=&#34;760&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      node
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-pod&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;pod&#34; srcset=&#34;
               /blog/k8s-service-exception-troubleshooting/6_hu942c7e3d5c0eda7d62bebf0fb0be66bd_253324_87d9a7e5a16bc6a640b6a7ea20998e33.webp 400w,
               /blog/k8s-service-exception-troubleshooting/6_hu942c7e3d5c0eda7d62bebf0fb0be66bd_253324_a3d4729296bfb6da6b4b25e50e6d8d67.webp 760w,
               /blog/k8s-service-exception-troubleshooting/6_hu942c7e3d5c0eda7d62bebf0fb0be66bd_253324_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/k8s-service-exception-troubleshooting/6_hu942c7e3d5c0eda7d62bebf0fb0be66bd_253324_87d9a7e5a16bc6a640b6a7ea20998e33.webp&#34;
               width=&#34;760&#34;
               height=&#34;334&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      pod
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;step 2：&lt;strong&gt;确定后端服务是否异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后我们可以通过 DeepFlow 提供的 Dashboard 查看后端服务的黄金指标：请求、异常、时延，以快速判断目前的服务是否在正常运行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-后端服务&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;后端服务&#34; srcset=&#34;
               /blog/k8s-service-exception-troubleshooting/7_hu20150ddb997b6c4e490e26c855a9f332_180558_53fbbf1b4ab29615841adb71456f058e.webp 400w,
               /blog/k8s-service-exception-troubleshooting/7_hu20150ddb997b6c4e490e26c855a9f332_180558_254d048c0de9574a08a34b2bbe59ddcf.webp 760w,
               /blog/k8s-service-exception-troubleshooting/7_hu20150ddb997b6c4e490e26c855a9f332_180558_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/k8s-service-exception-troubleshooting/7_hu20150ddb997b6c4e490e26c855a9f332_180558_53fbbf1b4ab29615841adb71456f058e.webp&#34;
               width=&#34;760&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      后端服务
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;step 3：&lt;strong&gt;确定 DNS 是否异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从前面&lt;strong&gt;服务的访问方式&lt;/strong&gt;一节可知，仅方式一/方式三的访问过程经过 DNS 服务，因此只有这两种场景才需要检查 DNS 服务是否异常，方式一和三都需要检查集群内的 DNS 服务是否异常，方式三相比方式一还需要检查 client 访问的集群外的 DNS 服务是否异常。对于 CoreDNS 本身，我们可以使用 Prometheus 提供的 Dashboard 来进行排障，对于排查应用服务访问 DNS 异常，我们可以使用 DeepFlow 提供的 Dashboard 查看 DNS 服务的请求、异常、时延指标。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-coredns&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;coredns&#34; srcset=&#34;
               /blog/k8s-service-exception-troubleshooting/8_hu1bbad9cf56080518d08b1dfb3df3858c_157224_2d7e677784c8c2f21ed570f97e6f9477.webp 400w,
               /blog/k8s-service-exception-troubleshooting/8_hu1bbad9cf56080518d08b1dfb3df3858c_157224_e85285e315cb095d6d5b44bcdf3eb04f.webp 760w,
               /blog/k8s-service-exception-troubleshooting/8_hu1bbad9cf56080518d08b1dfb3df3858c_157224_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/k8s-service-exception-troubleshooting/8_hu1bbad9cf56080518d08b1dfb3df3858c_157224_2d7e677784c8c2f21ed570f97e6f9477.webp&#34;
               width=&#34;760&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      coredns
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-dns&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DNS&#34; srcset=&#34;
               /blog/k8s-service-exception-troubleshooting/9_hud610c64dc68c916a3ff56d8710dd613c_229910_a4af671e30f7a0e0aec402739e4427d3.webp 400w,
               /blog/k8s-service-exception-troubleshooting/9_hud610c64dc68c916a3ff56d8710dd613c_229910_ef86dd2b479a4d3af3233009823e167f.webp 760w,
               /blog/k8s-service-exception-troubleshooting/9_hud610c64dc68c916a3ff56d8710dd613c_229910_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/k8s-service-exception-troubleshooting/9_hud610c64dc68c916a3ff56d8710dd613c_229910_a4af671e30f7a0e0aec402739e4427d3.webp&#34;
               width=&#34;760&#34;
               height=&#34;416&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DNS
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如 DNS 服务无异常，则可直接用 ClusterIP 访问服务，如果能正常访问，那可以确定是 DNS 的问题，并且这个问题很大可能就是配置错误。&lt;/p&gt;
&lt;p&gt;step 4：&lt;strong&gt;确定 SVC 是否异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 SVC 的功能实际是 kube-proxy 同步配置到 IPVS/IPTABLES 来实现的，所以我们可以参考 &lt;strong&gt;step 1&lt;/strong&gt; 的排查步骤，把 kube-proxy 视作应用 POD，通过 Prometheus 提供的 Dashboard 查看 kube-proxy 是否正常。&lt;/p&gt;
&lt;p&gt;如果能确定应用服务运行正常，可以尝试直接访问后端 POD，如果能正常访问，则可以继续分析 SVC 问题，很大可能是 IPVS/IPTABLES 配置错误。&lt;/p&gt;
&lt;p&gt;step 5：&lt;strong&gt;确定 Ingress 是否异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;服务访问方式&lt;/strong&gt;中方式三的场景下，如果需要检查 Ingress 的状态，可以查看基于 ingress-controller 服务的状态/负载/请求日志等构建的 Dashboard。这一类 Dashboard 除了 Prometheus/DeepFlow 有提供之外，各个 API 网关的厂商也有提供，可以用 DeepFlow + 厂商提供的 Dashboard 结合进行分析，厂商会更关注网关本身的分析，DeepFlow 则更关注全链路分析，快速定位问题点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ingress&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;ingress&#34; srcset=&#34;
               /blog/k8s-service-exception-troubleshooting/10_hu9ccbd2ea775c7fedf916fa65de646f87_167137_c6989549a93a7a6db09a53604f029c15.webp 400w,
               /blog/k8s-service-exception-troubleshooting/10_hu9ccbd2ea775c7fedf916fa65de646f87_167137_f7c050f291970fcb4c92470cf6435555.webp 760w,
               /blog/k8s-service-exception-troubleshooting/10_hu9ccbd2ea775c7fedf916fa65de646f87_167137_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/k8s-service-exception-troubleshooting/10_hu9ccbd2ea775c7fedf916fa65de646f87_167137_c6989549a93a7a6db09a53604f029c15.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      ingress
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;step 6：&lt;strong&gt;追踪访问路径异常点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述排障过程，都是独立的一个个点检查，如果都没问题，则可以去追踪报障的某一次访问路径是否有异常。如果能直接定位访问路径，确认问题点就会变得更简单。比如我们发现访问路径如果存在断路，则分析断路位置即可；如果追踪的是时延高的问题，则分析追踪到的每一段路径的时延即可。访问路径需要能覆盖从应用-&amp;gt;系统-&amp;gt;网络各个层面，目前提供这样全链路追踪能力的组件不多，可以使用 DeepFlow 自动化的分布式追踪能力来进行排查。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-追踪访问路径&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;追踪访问路径&#34; srcset=&#34;
               /blog/k8s-service-exception-troubleshooting/11_hudf3e3c9a8c85b883d75e22b8e4ac7228_55618_490877f91b63daa85c756e35388ab346.webp 400w,
               /blog/k8s-service-exception-troubleshooting/11_hudf3e3c9a8c85b883d75e22b8e4ac7228_55618_248840991765891909aa57285738ea7d.webp 760w,
               /blog/k8s-service-exception-troubleshooting/11_hudf3e3c9a8c85b883d75e22b8e4ac7228_55618_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/k8s-service-exception-troubleshooting/11_hudf3e3c9a8c85b883d75e22b8e4ac7228_55618_490877f91b63daa85c756e35388ab346.webp&#34;
               width=&#34;760&#34;
               height=&#34;131&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      追踪访问路径
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;什么是-deepflow&#34;&gt;什么是 DeepFlow&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/deepflowys/deepflow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow&lt;/a&gt; 是一款开源的高度自动化的可观测性平台，是为云原生应用开发者建设可观测性能力而量身打造的全栈、全链路、高性能数据引擎。DeepFlow 使用 eBPF、WASM、OpenTelemetry 等新技术，创新的实现了 AutoTracing、AutoMetrics、AutoTagging、SmartEncoding 等核心机制，帮助开发者提升埋点插码的自动化水平，降低可观测性平台的运维复杂度。利用 DeepFlow 的可编程能力和开放接口，开发者可以快速将其融入到自己的可观测性技术栈中。&lt;/p&gt;
&lt;p&gt;GitHub 地址：&lt;a href=&#34;https://github.com/deepflowys/deepflow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/deepflowys/deepflow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&#34;https://deepflow.yunshan.net/docs/zh/install/overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow Demo&lt;/a&gt;，体验高度自动化的可观测性新时代。&lt;/p&gt;
&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://deepflow.yunshan.net/docs/zh/about/overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://deepflow.yunshan.net/docs/zh/about/overview/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://grafana.com/grafana/dashboards/1860-node-exporter-full/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://grafana.com/grafana/dashboards/1860-node-exporter-full/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://grafana.com/grafana/dashboards/15661-1-k8s-for-prometheus-dashboard-20211010/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://grafana.com/grafana/dashboards/15661-1-k8s-for-prometheus-dashboard-20211010/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://grafana.com/grafana/dashboards/9614-nginx-ingress-controller/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://grafana.com/grafana/dashboards/9614-nginx-ingress-controller/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://grafana.com/grafana/dashboards/14981-coredns/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://grafana.com/grafana/dashboards/14981-coredns/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubernetes.io/docs/concepts/services-networking/service/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nginx.com/products/nginx-ingress-controller/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.nginx.com/products/nginx-ingress-controller/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/haproxytech/kubernetes-ingress#readme&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/haproxytech/kubernetes-ingress#readme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service-topology/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubernetes.io/docs/concepts/services-networking/service-topology/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/mp5coRHPAdx5nIfcCnPFhw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://mp.weixin.qq.com/s/mp5coRHPAdx5nIfcCnPFhw&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SkyWalking 基于 ShardingSphere-Proxy 的 MySQL-Sharding 分库分表的存储特性介绍</title>
      <link>https://cloudnative.to/blog/skywalking-shardingsphere-proxy/</link>
      <pubDate>Fri, 02 Dec 2022 10:31:33 +0800</pubDate>
      <guid>https://cloudnative.to/blog/skywalking-shardingsphere-proxy/</guid>
      <description>&lt;p&gt;Apache SkyWalking 作为一个分布式系统的应用性能监控工具，它观察服务网格中的指标、日志、痕迹和事件。其中 SkyWalking OAP 高性能的数据流处理架构能够实时处理庞大的数据流量，但是这些海量数据的存储更新和后续查询对后端存储系统带来了挑战。&lt;/p&gt;
&lt;p&gt;SkyWalking 默认已经提供了多种存储支持包括 H2、OpenSearch、ElasticSearch、MySQL、TiDB、PostgreSQL、BanyanDB。其中 MySQL 存储提供的是针对单机和单表的存储方式（MySQL 的集群能力需要自己选型提供），在面对高流量的业务系统时，监控数据的存储存在较大压力，同时影响查询性能。&lt;/p&gt;
&lt;p&gt;在 MySQL 存储基础上 SkyWalking v9.3.0 提供了一种新的存储方式 MySQL-Sharding，它提供了基于 &lt;a href=&#34;https://shardingsphere.apache.org/document/5.1.2/cn/quick-start/shardingsphere-proxy-quick-start/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ShardingSphere-Proxy&lt;/a&gt; 的分库分表特性，而分库分表是关系型数据库面对大数据量处理的成熟解决方案。&lt;/p&gt;
&lt;h2 id=&#34;部署架构&#34;&gt;部署架构&lt;/h2&gt;
&lt;p&gt;SkyWalking 使用 ShardingSphere-Proxy 的部署方式如下图所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-部署架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;部署架构&#34; srcset=&#34;
               /blog/skywalking-shardingsphere-proxy/arch_hu815a4fd79c722d8c456efc77c9af09cf_29121_423803fe9dce133b026fa2ad984b2d38.webp 400w,
               /blog/skywalking-shardingsphere-proxy/arch_hu815a4fd79c722d8c456efc77c9af09cf_29121_d72d08176fce81a7e3cad4ce937ea18e.webp 760w,
               /blog/skywalking-shardingsphere-proxy/arch_hu815a4fd79c722d8c456efc77c9af09cf_29121_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/skywalking-shardingsphere-proxy/arch_hu815a4fd79c722d8c456efc77c9af09cf_29121_423803fe9dce133b026fa2ad984b2d38.webp&#34;
               width=&#34;463&#34;
               height=&#34;403&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      部署架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SkyWalking OAP 由直连数据库的方式变成只与 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ShardingSphere-Proxy&lt;/a&gt; 进行交互；&lt;/li&gt;
&lt;li&gt;每一个 MySQL 节点暴露的连接都是一个数据源，由 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ShardingSphere-Proxy&lt;/a&gt; 进行统一管理；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ShardingSphere-Proxy&lt;/a&gt; 会根据配置建立一个虚拟逻辑数据库，根据 OAP 提供的分库分表规则进行库表分片和路由；&lt;/li&gt;
&lt;li&gt;SkyWalking OAP 负责生成分库分表规则并且像操作 MySQL 一样对虚拟逻辑库执行 DDL 和 DML；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;适用场景&#34;&gt;适用场景&lt;/h2&gt;
&lt;p&gt;希望使用 MySQL 作为存储，随着业务规模的增长，单表模式已经无法满足性能需要。&lt;/p&gt;
&lt;h2 id=&#34;skywalking-分库分表逻辑&#34;&gt;SkyWalking 分库分表逻辑&lt;/h2&gt;
&lt;p&gt;分库分表逻辑通过注解 &lt;code&gt;@SQLDatabase.Sharding&lt;/code&gt; 对 SkyWalking 中的数据模型 Model 进行定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@interface&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Sharding&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;ShardingAlgorithm&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;shardingAlgorithm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dataSourceShardingColumn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;default&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tableShardingColumn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;default&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shardingAlgorithm&lt;/code&gt;：表分片算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dataSourceShardingColumn&lt;/code&gt;：分库键&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tableShardingColumn&lt;/code&gt;：分表键&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SkyWalking 根据注解 &lt;code&gt;@SQLDatabase.Sharding&lt;/code&gt; 选择分库键、分表键以及表分片算法对每个表动态生成分片规则通过 DistSQL 操作 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy&lt;/a&gt; 执行规则定义 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy&lt;/a&gt; 根据规则定义进行数据分片。&lt;/p&gt;
&lt;h3 id=&#34;分库方式&#34;&gt;分库方式&lt;/h3&gt;
&lt;p&gt;SkyWalking 对于分库采用统一的方式，路由目标库的数字后缀使用分库键的哈希值取模需要分库的数据库数量，所以路由目标库为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ds_{dataSourceShardingColumn.hashcode() % dataSourceList.size()}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如我们有 &lt;code&gt;dataSourceList = ds_0...ds_n&lt;/code&gt;，如果&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{dataSourceShardingColumn.hashcode() % dataSourceList.size() = 2}&lt;/code&gt; 那么所有数据将会路由到 &lt;code&gt;ds_2&lt;/code&gt; 这个数据源节点上。&lt;/p&gt;
&lt;h3 id=&#34;分表方式&#34;&gt;分表方式&lt;/h3&gt;
&lt;p&gt;由于 TTL 机制的存在，分表算法主要根据时间的日期进行分片，分片表的数量是根据 TTL 每天一个表：&lt;/p&gt;
&lt;p&gt;分片表名 = 逻辑表名_时间序列（日期）：&lt;code&gt;{tableName =logicTableName_timeSeries}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为保证在 TTL 有效期内的数据能够被写入和查询，时间序列将生成当前日期&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{timeSeries = currentDate - TTL +1...currentDate + 1}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如：如果 &lt;code&gt;TTL=3, currentDate = 20220907&lt;/code&gt;，则分片表为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;logicTableName_20220905
logicTableName_20220906
logicTableName_20220907
logicTableName_20220908
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SkyWalking 提供了多种不同的分表算法用于不同的数据模型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;算法名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;分片说明&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;分片键时间精度要求&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;典型应用数据模型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;NO_SHARDING&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不做任何表分片，保持单表模式&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;/&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据量小无需分片的数据模型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;TIME_RELATIVE_ID_SHARDING_ALGORITHM&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 ID 列中的 &lt;code&gt;time_bucket&lt;/code&gt; 按天分片&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;time_bucket&lt;/code&gt; 的精度可以是同一表中的秒、分、小时和天&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;各类 Metrics 指标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;TIME_SEC_RANGE_SHARDING_ALGORITHM&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 &lt;code&gt;time_bucket&lt;/code&gt; 列按天分片&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;time_bucket&lt;/code&gt; 的精度必须是秒&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;SegmentRecordLogRecord&lt;/code&gt; 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;TIME_MIN_RANGE_SHARDING_ALGORITHM&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 &lt;code&gt;time_bucket&lt;/code&gt; 列按天分片&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;time_bucket&lt;/code&gt; 的精度必须是分钟&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EndpointTraffic&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;TIME_BUCKET_SHARDING_ALGORITHM&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 &lt;code&gt;time_bucket&lt;/code&gt; 列按天分片&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;time_bucket&lt;/code&gt; 的精度可以是同一个表中的秒、分、小时和天&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Service、Instance、Endpoint 调用关系等如 &lt;code&gt;ServiceRelationServerSideMetrics&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ttl-机制&#34;&gt;TTL 机制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对于进行分片的表根据 TTL 直接删除 &lt;code&gt;deadline&lt;/code&gt; &amp;gt;= &lt;code&gt;timeSeries&lt;/code&gt; 的物理表 &lt;code&gt;{deadline = new DateTime().plusDays(-ttl)}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TTL 定时器在根据当前日期删除过期表的同时也会根据新日期更新分片规则，通知 ShardingSphere-Proxy 创建新的分片表&lt;/li&gt;
&lt;li&gt;对于单表的延续之前的方式，删除 deadline &amp;gt;= &lt;code&gt;time_bucket&lt;/code&gt; 的行记录&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分片数据存储示例&#34;&gt;分片数据存储示例&lt;/h2&gt;
&lt;p&gt;下面以 segment（Record 类型）和 &lt;code&gt;service_resp_time&lt;/code&gt;（Metrics 类型）两个为例说明数据存储的逻辑和物理分布。这里假设 MySQL 为 &lt;code&gt;ds_0&lt;/code&gt; 和 &lt;code&gt;ds_1&lt;/code&gt; 两个节点。&lt;/p&gt;
&lt;p&gt;注意：以下的存储表结构仅为简化后的存储示例，不表示 SkyWalking 真实的表结构。&lt;/p&gt;
&lt;h3 id=&#34;segment&#34;&gt;segment&lt;/h3&gt;
&lt;p&gt;分片配置为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@SQLDatabase.Sharding(shardingAlgorithm = ShardingAlgorithm.TIME_SEC_RANGE_SHARDING_ALGORITHM, dataSourceShardingColumn = service_id, tableShardingColumn = time_bucket)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;逻辑库表结构和实际库表如下图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-逻辑表结构和实际库表-1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;逻辑表结构和实际库表 1&#34; srcset=&#34;
               /blog/skywalking-shardingsphere-proxy/f1_hu0e25c30df9960fe539dd827af53bb991_102870_897cc8a44e2070c04c010262ba613f2a.webp 400w,
               /blog/skywalking-shardingsphere-proxy/f1_hu0e25c30df9960fe539dd827af53bb991_102870_70a3913c47d6370101c88378e6c413eb.webp 760w,
               /blog/skywalking-shardingsphere-proxy/f1_hu0e25c30df9960fe539dd827af53bb991_102870_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/skywalking-shardingsphere-proxy/f1_hu0e25c30df9960fe539dd827af53bb991_102870_897cc8a44e2070c04c010262ba613f2a.webp&#34;
               width=&#34;760&#34;
               height=&#34;454&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      逻辑表结构和实际库表 1
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;service_resp_time&#34;&gt;service_resp_time&lt;/h3&gt;
&lt;p&gt;分片配置为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@SQLDatabase.Sharding(shardingAlgorithm = ShardingAlgorithm.TIME_RELATIVE_ID_SHARDING_ALGORITHM, tableShardingColumn = id, dataSourceShardingColumn = entity_id)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;逻辑库表结构和实际库表如下图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-逻辑表结构和实际库表-2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;逻辑表结构和实际库表 2&#34; srcset=&#34;
               /blog/skywalking-shardingsphere-proxy/f2_hu56f8f64be2d7b6bc78fa401c72ede1e3_162254_937abf1689d12b2aa3ed77af9e16c3ec.webp 400w,
               /blog/skywalking-shardingsphere-proxy/f2_hu56f8f64be2d7b6bc78fa401c72ede1e3_162254_d6eb7485398f36d048824d911bac31d8.webp 760w,
               /blog/skywalking-shardingsphere-proxy/f2_hu56f8f64be2d7b6bc78fa401c72ede1e3_162254_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/skywalking-shardingsphere-proxy/f2_hu56f8f64be2d7b6bc78fa401c72ede1e3_162254_937abf1689d12b2aa3ed77af9e16c3ec.webp&#34;
               width=&#34;760&#34;
               height=&#34;696&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      逻辑表结构和实际库表 2
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;如何使用&#34;&gt;如何使用&lt;/h2&gt;
&lt;p&gt;你可以选择手动或使用 Docker 来运行 Demo。&lt;/p&gt;
&lt;h3 id=&#34;手动部署&#34;&gt;手动部署&lt;/h3&gt;
&lt;p&gt;这里以单节点 SkyWalking OAP 和 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy 5.1.2&lt;/a&gt; 部署为例，集群部署请参考其他相关文档。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;准备好 MySQL 集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署安装并配置 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;conf/server.yaml&lt;/code&gt;，&lt;code&gt;props.proxy-hint-enabled&lt;/code&gt; 必须为 &lt;code&gt;true&lt;/code&gt;，完整配置可参考&lt;a href=&#34;https://github.com/wankai123/skywalking-mysql-sharding-demo/blob/main/shardingsphere-proxy/conf/server.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;conf/config-sharding.yaml&lt;/code&gt;，配置逻辑数据库和 &lt;code&gt;dataSources&lt;/code&gt; 列表，&lt;code&gt;dataSource&lt;/code&gt; 的名称必须以 &lt;code&gt;ds_&lt;/code&gt;为前缀，并且从 &lt;code&gt;ds_0&lt;/code&gt; 开始，完整配置可参考&lt;a href=&#34;https://github.com/wankai123/skywalking-mysql-sharding-demo/blob/main/shardingsphere-proxy/conf/config-sharding.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署安装并配置 SkyWalking OAP：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置 OAP 环境变量 &lt;code&gt;${SW_STORAGE:mysql-sharding}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据实际部署情况配置连接信息： &lt;code&gt;${SW_JDBC_URL}&lt;/code&gt; &lt;code&gt;${SW_DATA_SOURCE_USER}&lt;/code&gt; &lt;code&gt;${SW_DATA_SOURCE_PASSWORD}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：连接信息需对应 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy&lt;/a&gt; 虚拟数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy&lt;/a&gt; 中 &lt;code&gt;conf/config-sharding.yaml&lt;/code&gt; 配置的数据源名称配置在 &lt;code&gt;${SW_JDBC_SHARDING_DATA_SOURCES}&lt;/code&gt; 中，用 &lt;code&gt;,&lt;/code&gt; 分割&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 MySQL 集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 SkyWalking OAP&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用-docker-运行-demo&#34;&gt;使用 Docker 运行 Demo&lt;/h3&gt;
&lt;p&gt;GitHub 资源库提供了一个基于 Docker 完整可运行的 demo：&lt;a href=&#34;https://github.com/wankai123/skywalking-mysql-sharding-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;skywalking-mysql-sharding-demo&lt;/a&gt;，可以快速尝试实际运行效果。&lt;/p&gt;
&lt;p&gt;其中部署包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;oap 服务 1 个，Metrics 和 Record 数据的 TTL 均设为 2 天&lt;/li&gt;
&lt;li&gt;sharding-proxy 服务 1 个版本为 5.1.2，对外端口为 13307，创建的逻辑库名称为 swtest&lt;/li&gt;
&lt;li&gt;mysql 服务 2 个，对外端口分别为 3306，3307，在 sharding-proxy 的 &lt;code&gt;conf/config-sharding.yaml&lt;/code&gt; 中配置为 &lt;code&gt;ds_0&lt;/code&gt; 和 &lt;code&gt;ds_1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;provider 服务 1 个（模拟业务程序用于验证 trace 和 metrics 等数据），对外端口为 9090&lt;/li&gt;
&lt;li&gt;consumer 服务 1 个（模拟业务程序用于验证 trace 和 metrics 等数据），对外端口为 9092&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将 Demo 程序获取到本地后，在 skywalking-mysql-sharding-demo 目录下直接运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-compose up -d
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意：初次启动由于拉取镜像和新建所有表可能需要一定的时间。&lt;/p&gt;
&lt;p&gt;所有服务启动完成之后可以通过数据库工具查看 &lt;code&gt;sharding-proxy&lt;/code&gt; 逻辑表创建情况，以及两个 MySQL 库中实际的物理分片表创建情况。也可以连接 &lt;code&gt;sharding-proxy&lt;/code&gt; 逻辑库 &lt;code&gt;swtest&lt;/code&gt; 查看数据查询路由情况，如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;PREVIEW&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SEGMENT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-查询结果&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;查询结果&#34; srcset=&#34;
               /blog/skywalking-shardingsphere-proxy/sql_hudf8b8b145dc1e45d066d968cf5301e6a_25419_4ab10b41c0f11a4a3b29b478c6c2ca0d.webp 400w,
               /blog/skywalking-shardingsphere-proxy/sql_hudf8b8b145dc1e45d066d968cf5301e6a_25419_5dcd8a017e7838a1ec3e69f3683c74c2.webp 760w,
               /blog/skywalking-shardingsphere-proxy/sql_hudf8b8b145dc1e45d066d968cf5301e6a_25419_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/skywalking-shardingsphere-proxy/sql_hudf8b8b145dc1e45d066d968cf5301e6a_25419_4ab10b41c0f11a4a3b29b478c6c2ca0d.webp&#34;
               width=&#34;760&#34;
               height=&#34;53&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      查询结果
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Demo 提供的模拟业务程序可以通过请求 consumer 服务模拟业务请求，用于验证各类型数据分布：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl http://127.0.0.1:9092/info
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇文章中我们详细介绍了 SkyWalking  基于 ShardingSphere-Proxy 的 MySQL-Sharding 存储特性的部署架构、适应场景、核心分库分表逻辑以及 TTL 机制，并提供了运行后的数据存储示例和详细部署配置步骤以便大家快速理解上手。SkyWalking 提供了多种存储方式以供选择，如果你目前的需求如本文所述，欢迎使用该新特性。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>KubeCon 北美 2022 可观测性开放日见闻</title>
      <link>https://cloudnative.to/blog/kubecon-summary-of-the-open-observability-day/</link>
      <pubDate>Wed, 09 Nov 2022 09:16:27 +0800</pubDate>
      <guid>https://cloudnative.to/blog/kubecon-summary-of-the-open-observability-day/</guid>
      <description>&lt;p&gt;2022 年 10 月底，作为在底特律举行的完整 KubeCon 和 CloudNativeCon 活动之前的场外活动，&lt;a href=&#34;https://events.linuxfoundation.org/open-observability-day-north-america/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Observability Day&lt;/a&gt; 为期一天的活动首次举行。&lt;/p&gt;
&lt;p&gt;活动会场在亨廷顿广场会议中心，可以看到河对面加拿大的景色（很多人都不知道底特律离美国北部边境如此之近） 。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymecxp5ij312c0pemzi_hu7bbdd72bbd4ae47024b6a9175fd9d862_68455_e556d9341fc7b5549627cbb95594382a.webp 400w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymecxp5ij312c0pemzi_hu7bbdd72bbd4ae47024b6a9175fd9d862_68455_375c472d0c739e95b9cc932f9b1c800e.webp 760w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymecxp5ij312c0pemzi_hu7bbdd72bbd4ae47024b6a9175fd9d862_68455_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymecxp5ij312c0pemzi_hu7bbdd72bbd4ae47024b6a9175fd9d862_68455_e556d9341fc7b5549627cbb95594382a.webp&#34;
               width=&#34;760&#34;
               height=&#34;503&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Open Observability Day 的&lt;a href=&#34;https://events.linuxfoundation.org/open-observability-day-north-america/program/schedule/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;完整时间表可在线获得&lt;/a&gt;，今天我想分享一下在那里的感受。&lt;/p&gt;
&lt;p&gt;这一天以所有与开放可观测性相关的 CNCF 项目为中心，充斥了供应商和以项目为中心的演讲。&lt;/p&gt;
&lt;p&gt;活动从 CNCF 项目创始人 Bartek Płotka 的概述开始，他叙述了 Thanos、Fluntd、OpenTelemetry、Jeager 等项目的更新。然后过渡到两个简短的主题演讲。&lt;/p&gt;
&lt;h2 id=&#34;分布式追踪斗争是真实的&#34;&gt;分布式追踪：斗争是真实的&lt;/h2&gt;
&lt;p&gt;Chronosphere 的现场首席技术官 Ian Smith 分享了他在该领域从事分布式跟踪解决方案 9 年后的想法。他带我们进行了一次旋风之旅，了解了它的来源和可能的发展方向，以及围绕支持分布式跟踪的工具存在哪些技术问题。下面是他给出的 tips：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;追踪已成为高承诺、高努力、低价值的故事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他继续强调对开发人员工具的关注需要如何扭转这种局面，并开始以更少的努力和更多的价值提供一些承诺。&lt;/p&gt;
&lt;h2 id=&#34;简化可观测性&#34;&gt;简化可观测性&lt;/h2&gt;
&lt;p&gt;Calyptia 首席执行官 Eduardo Silva 分享了从创建 Fluentd 项目到专注于云原生环境的新 Fluent-bit 项目的故事。然后，他介绍了他们在构建 Fluent Bit 项目的日志空间方面的经验，以及如何扩展生态系统以支持指标和追踪，从而帮助塑造简化的用户可观测性体验。他宣布发布 Calyptia Core，使用开源工具通过数据管道收集数据，而无需使用代理。现在可以免费使用，并且可以安装到现有的 Kubernetes 集群中。他们还有一个 Docker 桌面扩展。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymizzdfhj31400u0q82_hu96c7bdee9344f5af095f768c15fa0750_104177_f1028f11fe7c8eae5e817a19b1c5f7ee.webp 400w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymizzdfhj31400u0q82_hu96c7bdee9344f5af095f768c15fa0750_104177_265cbf260b3da91279fe89273b654e8c.webp 760w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymizzdfhj31400u0q82_hu96c7bdee9344f5af095f768c15fa0750_104177_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymizzdfhj31400u0q82_hu96c7bdee9344f5af095f768c15fa0750_104177_f1028f11fe7c8eae5e817a19b1c5f7ee.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;两个主题演讲都很短，只有 10 分钟，之后主要演讲开始了。&lt;/p&gt;
&lt;h2 id=&#34;使用-fluent-bit-构建可观测性管道&#34;&gt;使用 Fluent Bit 构建可观测性管道&lt;/h2&gt;
&lt;p&gt;LinkedIn 的 Chao Xu 谈到了他们如何从现有的可观测性管道封闭工具过渡到开源和开放标准。他们主要使用 Fluent Bit 和 Open Telemetry。他们还将语言工具从 Java 应用程序扩展到 Go、C++ 和 Python。他们将跟踪和日志整合到单个管道中，而不是单独的数据管道中，从而创建更简单的维护标准和更少的资源负载。他们是 OTEL 收集器的忠实信徒，但他们将其扩展为新扩展的可观测性代理，以支持数据转换和过滤以及 OTEL 数据流的摄取。LinkedIn 也非常喜欢 Fluent Bit 提供的用于处理各种数据流的增强标签管理。&lt;/p&gt;
&lt;h2 id=&#34;为什么大规模可观测性需要图&#34;&gt;为什么大规模可观测性需要图&lt;/h2&gt;
&lt;p&gt;SquaredUp 的 Richard Benwell 深入研究了可观测性 Wikipedia 页面，这是一种相当有趣的方式来尝试构建我们所说的可观测性的基础。他用它来表明我们有带有指标、日志和跟踪的信号，但是我们在当前的可观测性平台中缺少我们的系统模型。这个演讲假设没有模型，信号是无用的。他继续使用架构作为我们正在收集的指标、日志和跟踪的模型。这就引出了一个问题：你是否需要架构师来设计模型，或者你是否只是像跟踪工具那样生成模型？此外，该模型很好（它有助于理解），但你需要能够深入了解你正在收集和建模的数据的含义。然后演讲深入到我们大学都学习过的图入门课程，从顶点到边到顶点类型的故事。它唤起了人们对数学课程和人工智能领域建模的美好回忆，以解决医疗诊断等问题领域。&lt;/p&gt;
&lt;h2 id=&#34;对混沌的-kubernetes-可观测性充满信心&#34;&gt;对混沌的 Kubernetes 可观测性充满信心&lt;/h2&gt;
&lt;p&gt;来自 GitLab 的 Michael Friedrich 分享了我们如何从运行云原生环境转变为使用 Prometheus、Perces、Graphans 等 CNCF 项目监控。现在我们被所有传入的数据所淹没，这不是一个新概念。所以现在我们有了这个，他分享了一些关于故意破坏事物的想法，以了解它的行为、监控和恢复方式。他强调了 Chaos Mesh 项目，这是一个有趣的想法，即如何查看整个环境将如何响应问题。演讲以 Chaos Mesh 使用的现场演示结束。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymp1ajxmj30u0140dkm_hu55e7a9c2caf813b11b487f5d3082bf53_106953_4ea948f3afeaaf963ff75188abd9d883.webp 400w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymp1ajxmj30u0140dkm_hu55e7a9c2caf813b11b487f5d3082bf53_106953_f0042cd64caf60003febef030190c565.webp 760w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymp1ajxmj30u0140dkm_hu55e7a9c2caf813b11b487f5d3082bf53_106953_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymp1ajxmj30u0140dkm_hu55e7a9c2caf813b11b487f5d3082bf53_106953_4ea948f3afeaaf963ff75188abd9d883.webp&#34;
               width=&#34;570&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;午餐前后有几个闪电演讲，只有短短的 10 分钟。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 FluentBit 实现云和边缘的统一可观测性&lt;/li&gt;
&lt;li&gt;通过自动发现的安全策略理解可观测性&lt;/li&gt;
&lt;li&gt;通过 OpAMP 协议管理 OpenTelemetry&lt;/li&gt;
&lt;li&gt;如何为可观测性构建数据管道&lt;/li&gt;
&lt;li&gt;eBPF 实际上可以为现代可观测性做什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下午结束了完整的分组会议：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymqtfzusj30u01407au_hu75d6465f230520d0aab548d6f476e005_128947_bd979e6f13dd6706b4ce63098926ee2f.webp 400w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymqtfzusj30u01407au_hu75d6465f230520d0aab548d6f476e005_128947_a0f8120cd62e486c968f5e81085ed828.webp 760w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymqtfzusj30u01407au_hu75d6465f230520d0aab548d6f476e005_128947_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymqtfzusj30u01407au_hu75d6465f230520d0aab548d6f476e005_128947_bd979e6f13dd6706b4ce63098926ee2f.webp&#34;
               width=&#34;570&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;在-ebay-采用开放遥测收集器在飞行中换引擎&#34;&gt;在 eBay 采用开放遥测收集器：在飞行中换引擎&lt;/h2&gt;
&lt;p&gt;来自 eBay 的 Vijay Samuel 分享了从 Elastic Beats for traces 迁移到 Open Telemetry 的经验。他谈到了他们的云原生规模、遇到的问题、从 Metric Beats 到 OTEL 收集器的旅程、弥合动态配置重新加载的差距以及确保迁移后的数据奇偶性。这很有趣，他们正在招聘工程师。&lt;/p&gt;
&lt;h2 id=&#34;使用--opentelemetry-的-prometheus-管道&#34;&gt;使用  OpenTelemetry 的 Prometheus 管道&lt;/h2&gt;
&lt;p&gt;来自 Grafana Labs 和作为 Prometheus 维护者超过五年的 Goutham Veeramachaneni 分享了如何在 Prometheus 数据管道中利用 OTEL 来为你的指标基础设施添加追踪。&lt;/p&gt;
&lt;p&gt;这个概述不包括今天举行的所有会谈，但给人留下了很好的印象。我必须承认，由于在休息期间出现的网络问题，我无法跟上所有会话。有几次，我进行了深入的讨论，使我在大厅或展位上的时间比计划的休息时间更长，但这就是这些活动的目的！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>论元数据在可观测性中的重要性</title>
      <link>https://cloudnative.to/blog/the-importance-of-metadata-in-observability/</link>
      <pubDate>Mon, 07 Nov 2022 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/the-importance-of-metadata-in-observability/</guid>
      <description>&lt;p&gt;本文为云杉网络原力释放 - 云原生可观测性分享会第十一期直播实录。&lt;a href=&#34;https://mp.weixin.qq.com/s/QKb1cbqfkmhtxI8rGEtLUg?vid=1688856588389646&amp;amp;deviceid=8b31b0c6-6d71-4c84-864b-f1d468e717a1&amp;amp;version=4.0.19.6020&amp;amp;platform=win&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;回看链接&lt;/a&gt;，&lt;a href=&#34;http://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/yunshan-ticket/pdf/39efae2215f69da573b095259f8cd79f_20221027183747.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PPT 下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;大家好，我是陈晨，今天和分享的内容是《论元数据在可观测性中的重要性》，大纲为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从智能驾驶看可观测性未来发展。&lt;/li&gt;
&lt;li&gt;用开源产品构建可观测性遇到的痛点。&lt;/li&gt;
&lt;li&gt;构建内部元数据平台打通多信号关联。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那前期我们多位老师为大家分享了可观测性相关的领域知识，看到大家对&lt;strong&gt;多信号之间的关联&lt;/strong&gt;有一些疑惑，今天来和大家聊下&lt;strong&gt;元数据在可观测性多信号关联的重要性&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;从智能驾驶看可观测性未来发展&#34;&gt;从智能驾驶看可观测性未来发展&lt;/h2&gt;
&lt;p&gt;在此之前为大家解释下多信号的概念，该概念来源于 CNCF 可观测性 SIG 推出的《可观测性白皮书》一文中的译词，当然云原生社区也有我们翻译的中文版白皮书内容，欢迎大家去看往期的文章推送。那从白皮书里总结起来，多信号就是可观测性系统中各种用途不同但具备结构化、标准化数据的总称，例如我们常常听到的 logs，traces，metrics 等数据。&lt;/p&gt;
&lt;p&gt;可观测性在获取到多个信号后，会将其以静态或动态的状态放置于存储内，通过多个不同状态的信号来构建属于自己的可观测性平台，以此来缩短解决错误的时间和透视化软件服务内部的黑盒状态。在这个动态过程中，让多信号之间可以紧密的配合来反馈应用程序或 IT 部署环境的实际运行状态，就是元数据开始发挥作用的时候了。&lt;/p&gt;
&lt;p&gt;当然我们在聊元数据之前，我们先来看两张图。这两张图来源于张城老师在云原生社区 Meetup 北京站演讲的 PPT（已经征求本人同意）《云原生下的可观测性发展方向》。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-智能驾驶分级&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;智能驾驶分级&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/1_hud8fc380cc56e8e45f3952bd1c8584658_167252_f1598a827bee65a32b6775257012811d.webp 400w,
               /blog/the-importance-of-metadata-in-observability/1_hud8fc380cc56e8e45f3952bd1c8584658_167252_1d690ad4b5b61fa214d7e4f1c9ba1782.webp 760w,
               /blog/the-importance-of-metadata-in-observability/1_hud8fc380cc56e8e45f3952bd1c8584658_167252_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/1_hud8fc380cc56e8e45f3952bd1c8584658_167252_f1598a827bee65a32b6775257012811d.webp&#34;
               width=&#34;704&#34;
               height=&#34;281&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      智能驾驶分级
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上面这张图是自动驾驶分级后的表现图。我们可以看到自动驾驶依据分级可分为 6 级，其中 0 - 2 级主要还是靠人工来干预，三级后开始变得无意识起来，之后开始变得更加智能化起来。&lt;/p&gt;
&lt;p&gt;下面这张图则是 IT 系统可观测性参考智能驾驶划分的六级图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-可观测性分级&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;可观测性分级&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/2_hu6ae5b2c89319351e3c581098a1035ba9_106131_e955c0447182286d8ecab7ed75992abe.webp 400w,
               /blog/the-importance-of-metadata-in-observability/2_hu6ae5b2c89319351e3c581098a1035ba9_106131_6f7f4309b0e518bab2d3a302f2c54ddf.webp 760w,
               /blog/the-importance-of-metadata-in-observability/2_hu6ae5b2c89319351e3c581098a1035ba9_106131_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/2_hu6ae5b2c89319351e3c581098a1035ba9_106131_e955c0447182286d8ecab7ed75992abe.webp&#34;
               width=&#34;760&#34;
               height=&#34;219&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      可观测性分级
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等级 0：手工分析，依靠基础的 Dashboard、告警、日志查询、分布式链路追踪等方式进行手动告警、分析，也是目前绝大部分公司使用的场景&lt;/li&gt;
&lt;li&gt;等级 1：智能告警，能够自动去扫描所有的可观测性数据，利用机器学习的方式去识别一些异常并进行自动告警，免去人工设置 / 调整各种基线告警的工作&lt;/li&gt;
&lt;li&gt;等级 2：异常关联 + 统一视图，对于自动识别的异常，能够进行上下文的关联，形成一个统一的业务视图，便于快速的定位问题&lt;/li&gt;
&lt;li&gt;等级 3：根因分析 + 问题自愈，自动根据异常以及系统的 CMDB 信息直接定位问题的根因，根因定位准确后那边可以去做问题的自愈。这一阶段相当于是一次质的飞跃，在某些场景下可以在人不用参与的情况下实现问题的自愈。&lt;/li&gt;
&lt;li&gt;等级 4：故障预测，故障发生总会有损失，所以最好的情况是避免故障的发生，因此故障预测技术可以更好的来保证系统的可靠性，利用之前积累的一些故障先兆信息做到“未卜先知”&lt;/li&gt;
&lt;li&gt;等级 5：变更影响预测，我们知道绝大部分的故障都是由变更引起的，因此如果能够模拟出每个变更对系统带来的影响以及可能产生的问题，我们就能够提前评估出是否能够允许此次变更。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然我们会有一些专业的可观测性团队已经在实践异常关联、根因分析、故障预测等能力。那我们今天以大家最常用的手工分析作为切入点来看下问题排查过程中遇到的问题。&lt;/p&gt;
&lt;h2 id=&#34;用开源产品构建可观测性遇到的痛点&#34;&gt;用开源产品构建可观测性遇到的痛点&lt;/h2&gt;
&lt;p&gt;我们在进行案例分析前来看一个图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-链路拓扑分析&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;链路拓扑分析&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/3_hub85d1ac51092bc4206b3e75c9a85f8ce_103467_6d4119df91657ca0ecd00f0a5e9bea7c.webp 400w,
               /blog/the-importance-of-metadata-in-observability/3_hub85d1ac51092bc4206b3e75c9a85f8ce_103467_8c9ed2a6b7521390d7c7bae8de8c0999.webp 760w,
               /blog/the-importance-of-metadata-in-observability/3_hub85d1ac51092bc4206b3e75c9a85f8ce_103467_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/3_hub85d1ac51092bc4206b3e75c9a85f8ce_103467_6d4119df91657ca0ecd00f0a5e9bea7c.webp&#34;
               width=&#34;760&#34;
               height=&#34;325&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      链路拓扑分析
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;熟悉的&lt;strong&gt;拓扑分析&lt;/strong&gt;，大家一直都在考虑为用户产生一个具体的运行时应用级别的画像，可以清晰的告诉开发者我们的应用关联是怎样的，应用所依赖的中间件运行状态，我们出入口流量等。&lt;/p&gt;
&lt;p&gt;那这样的拓扑分析其实有很很多小技巧，比如我们可以构建一个静态的应用拓扑依赖分析图，也可以构建 Request Scope 级别的运行时应用拓扑分析图。那什么叫做&lt;strong&gt;静态的应用拓扑分析图&lt;/strong&gt;呢？&lt;/p&gt;
&lt;p&gt;比如我们业务应用只想知道自己依赖的上下游服务和相关联的中间件的拓扑，那这种拓扑则当业务应用开始运行时就会确定，不存在有较大的改变的可能，除非在中间件 Client 做了中间件 Server 的&lt;strong&gt;故障动态切换和转移&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那相对的&lt;strong&gt;动态的应用拓扑分析图&lt;/strong&gt;呢？就是指在 Request Scope 下的某一次请求下的应用实时拓扑分析，一般动态应用拓扑分析里面包含了运行时的一些指标数据以及关联的 Span 信息还有一些业务日志的联动。&lt;/p&gt;
&lt;p&gt;当然具体是静态拓扑还是动态拓扑，我们都需要在某一个地方获取到这些关联关系，行业优秀产品 SkyWalking 在旧版本 DashBoard 上绘制出来的链路拓扑分析图则是依赖存储中聚合到的 Span 来构建应用的关联关系，并对关键的 RED 指标做了关联，那其实相对的这种方式对存储也会有一定的压力。&lt;/p&gt;
&lt;p&gt;以 Grafana Loki 中介绍的一个典型问题排查过程来看：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-loki-demo-案例&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Loki Demo 案例&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/4_hu393fa42e05662ada17ad5af0864c43ee_252724_df84c198ac2d6a063d117e9b6bab3801.webp 400w,
               /blog/the-importance-of-metadata-in-observability/4_hu393fa42e05662ada17ad5af0864c43ee_252724_eb96427147e4a03bda50709197e73248.webp 760w,
               /blog/the-importance-of-metadata-in-observability/4_hu393fa42e05662ada17ad5af0864c43ee_252724_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/4_hu393fa42e05662ada17ad5af0864c43ee_252724_df84c198ac2d6a063d117e9b6bab3801.webp&#34;
               width=&#34;760&#34;
               height=&#34;344&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Loki Demo 案例
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们通常因为告警而感知系统出现了运行时问题（主要是 metrics，当然会有一些历史项目使用 logs），&lt;/li&gt;
&lt;li&gt;因为大盘而确定异常的模块（metrics/events）和查看一些系统性指标，&lt;/li&gt;
&lt;li&gt;通过拓扑分析/链路信息定位到问题发生的具体应用（topology/traces），&lt;/li&gt;
&lt;li&gt;然后通过应用运行时日志确定具体的细节（logs）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过多信号之间的配合完成问题的定位，有些问题的排查步骤和上述不太一致，有些许改变。但是不影响多信号之间配合发挥的重要作用。&lt;/p&gt;
&lt;p&gt;我们将上述定位问题使用到的&lt;strong&gt;信号解析到数据层面&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-数据层面的多信号&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;数据层面的多信号&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/5_hua1de0cdc9b925b40a3d64152a4136fb4_54411_2f0f4ddf388862487b9edde2b06d5113.webp 400w,
               /blog/the-importance-of-metadata-in-observability/5_hua1de0cdc9b925b40a3d64152a4136fb4_54411_d5aa46684199f92feb4ed7c900e3b3ec.webp 760w,
               /blog/the-importance-of-metadata-in-observability/5_hua1de0cdc9b925b40a3d64152a4136fb4_54411_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/5_hua1de0cdc9b925b40a3d64152a4136fb4_54411_2f0f4ddf388862487b9edde2b06d5113.webp&#34;
               width=&#34;760&#34;
               height=&#34;418&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      数据层面的多信号
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;告警：我们有基本的告警信息，包括告警内容，告警级别，告警时间以及其他一些利于定位问题的信息（行政信息、云资产信息等）。&lt;/li&gt;
&lt;li&gt;Metrics：不同的指标会有不同的 lables/tags，和告警可以匹配到一般是一组依据算子计算好的指标数据。Open Metrics 组织和 Prometheus 是这方面的专家，当然也有一些比较优秀的厂商在做这样的指标产品。&lt;/li&gt;
&lt;li&gt;Traces：各家 trace 产品大同小异，内部包含的元信息也类似。不过我们应该感谢 OTel，让这件事儿变成了标准，并让数据流管道化。&lt;/li&gt;
&lt;li&gt;Logs：logs 里会有一些和其他信号重复的数据，例如 service name, instance name, trace info 等。logs 的重点也会在他的 msg 内，一般供大家检索查询。当然也会有一些不需要检索的日志产品，Loki 是这方面的实践专家。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然可观测性也是在不断的进化，会有新的信号进来和现有的多信号配合一起来透视化软件黑盒状态和加速解决问题的进度。例如大家一直都在实践的 profiles/ dumps 等。&lt;/p&gt;
&lt;p&gt;那这些&lt;strong&gt;多信号间是如何关联的&lt;/strong&gt;呢？我们来看下一张图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-多信号关联&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;多信号关联&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/6_huc47617aed4c37840af2ab5d740d57ec6_210111_5f92ddfa4d30449af5f4e04d96933509.webp 400w,
               /blog/the-importance-of-metadata-in-observability/6_huc47617aed4c37840af2ab5d740d57ec6_210111_3cec0ae0dfa0cbec32a2e6b0b0fb24ab.webp 760w,
               /blog/the-importance-of-metadata-in-observability/6_huc47617aed4c37840af2ab5d740d57ec6_210111_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/6_huc47617aed4c37840af2ab5d740d57ec6_210111_5f92ddfa4d30449af5f4e04d96933509.webp&#34;
               width=&#34;760&#34;
               height=&#34;352&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      多信号关联
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们依据时间来缩小问题定位的窗口，依据 多信号间共有的 元信息来关联多信号。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们依据  trace id 来关联 traces 和 logs 以及 metrics 的 Exemplars（是最普遍也是最有效的方式）。&lt;/li&gt;
&lt;li&gt;我们依靠埋点的 service name，instance name，span id 或者其他元信息来关联到更细节的信号（例如我们指标和指标之间的关联通过 labels/tags 中重复的元数据，业务日志通过应用信息关联到 K8s Pod metrics）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些元信息里面包括 私有云，公有云的实例信息，容器的运行时信息，应用的列表信息，中间件的连接信息，业务自埋点的信息等。但是这样我们一定就能够做到无缝连接了吗？&lt;/p&gt;
&lt;p&gt;我们来看下&lt;strong&gt;多信号关联的难点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-多信号关联难点&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;多信号关联难点&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/7_hu0dca73ae334c2430963c153df2e3d97c_178383_a80501fd4946d51a121c672ca2db3c4c.webp 400w,
               /blog/the-importance-of-metadata-in-observability/7_hu0dca73ae334c2430963c153df2e3d97c_178383_3e4578cd61f7b69066aa8e03fa683020.webp 760w,
               /blog/the-importance-of-metadata-in-observability/7_hu0dca73ae334c2430963c153df2e3d97c_178383_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/7_hu0dca73ae334c2430963c153df2e3d97c_178383_a80501fd4946d51a121c672ca2db3c4c.webp&#34;
               width=&#34;760&#34;
               height=&#34;315&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      多信号关联难点
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;不一致的元数据&lt;/strong&gt;：我们能看到多信号关联的重点在于存在同样的元数据，但是其实垂直领域下现阶段我们使用的各家产品在元数据层面并没有达到一致，包括统一产品在不同版本迭代中也会出现 意思相同命名不同的现象，造成准确性和及时性无法保障。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺少 trace info&lt;/strong&gt;：logs, metrics, traces 关联过程最简单也是最高效的方式是通过 trace info 被打点在各个信号中，然后依据 trace info 去将多信号进行关联。但是如果应用级的 trace 中丢失了 span infos，那将会是一个灾难。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;糟糕的采样&lt;/strong&gt;：采样是一个极具争议的话题，一方面会降低存储压力，但是一方面又会影响产品功能的完整性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺失的元数据&lt;/strong&gt;：我们想从系统层面关联到应用层面，继而再通过网络关联到其他的系统层面以及网络层面，当缺失了某些元数据，对于可观测性系统来说将是灾难性的，对产品的功能有极大的影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，依据多信号内的元数据不能做到 100% 的高度关联，还需要做一些其他的工作来辅助和补充元数据，以此来大幅度提升可观测性的能力。比如统一具备&lt;strong&gt;通用性的元数据&lt;/strong&gt;打入到我们的多信号内，以此来&lt;strong&gt;增强多信号关联性&lt;/strong&gt;。但是因为打入在多信号中的元数据愈发变多，存储的压力及繁琐的工作也常常会让我们头痛。&lt;/p&gt;
&lt;h2 id=&#34;构建元数据平台打通多信号关联&#34;&gt;构建元数据平台打通多信号关联&lt;/h2&gt;
&lt;p&gt;那基于此，如果我们要构建一个健壮的可观测性平台，在这个过程中遇到的散落在各地的元数据，我们应该将他组织并利用起来，以此站在更高纬度的视角去观测我们的系统（当然元数据平台的功能不止于此）。&lt;/p&gt;
&lt;p&gt;依据维基百科中元数据的定义：元数据被定义为提供某些资料单方面或多方面信息的资料，被用来概述资料的基础信息，以简化查找过程与方便使用。&lt;/p&gt;
&lt;p&gt;IT 基础设施的元数据构建我们可以考虑以下几点：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-元数据平台能力&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;元数据平台能力&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/8_hud53cb00dc910d0e1b4d6cd7792944277_66624_569442fa550e0307acc80e18c842ada9.webp 400w,
               /blog/the-importance-of-metadata-in-observability/8_hud53cb00dc910d0e1b4d6cd7792944277_66624_ddfa55c88ca9e7bc202efbb76a72f259.webp 760w,
               /blog/the-importance-of-metadata-in-observability/8_hud53cb00dc910d0e1b4d6cd7792944277_66624_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/8_hud53cb00dc910d0e1b4d6cd7792944277_66624_569442fa550e0307acc80e18c842ada9.webp&#34;
               width=&#34;760&#34;
               height=&#34;457&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      元数据平台能力
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;网络级别的元数据&lt;/strong&gt;：包括我们使用的网络设施的基础数据和实际运行时挂载的运行时元数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用级别的元数据&lt;/strong&gt;：包括我们业务应用列表信息和应用关联的中间件的连接元数据信息及中间件自身的元数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统级别的元数据&lt;/strong&gt;：包括我们主机列表信息以及虚拟化容器化之后的动态元数据信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然构建这样的系统可能是一件需要持续做下去的事情，但是构建这样的元数据平台对于基础设施建设和 IT 可观测性的重要性不言而喻。那可能有人会问，我们这里的元数据和运维侧的元数据平台的区别是什么呢。&lt;/p&gt;
&lt;p&gt;一些公司内部可能会构建属于自己运维侧的元数据平台，那根据过往经验内部包含的则是一些资产信息和管理信息。我们这里的元数据平台将其归纳到系统级元数据内，并对其做了一定的补充，包括应用级元数据、网络层元数据等，但其实还缺少了行政级元数据。如果有了这样齐全的元数据信息后，这样我们做到什么能力呢。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;精准的告警直达某业务线某小组内某应用的主要开发者、测试人员和负责人，而不是告警泛滥。&lt;/li&gt;
&lt;li&gt;精准的告警直达某中间件中的某表或某队列、某交换机，继而转发至对应团队、对应负责人来处理。&lt;/li&gt;
&lt;li&gt;准确的关联关系构建，细粒度的产品角度去为不同问题筛选出不同的可观测性视角，而不是千篇一律的 DashBoard（举例 Grafana 的筛选栏）。&lt;/li&gt;
&lt;li&gt;完整的关联关系、准确无误的为高阶可观测性系统能力做铺垫，例如根因分析、错误自愈、缩容扩容自动化等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，急剧扩充的元数据会让可观测性多信号的数据暴涨，也会带来一些其他的问题，那这些问题该如何解决呢，请&lt;strong&gt;关注我们下期的直播内容&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;那其实我们今天讲的蛮浅的，从&lt;strong&gt;智能驾驶来看可观测性的发展&lt;/strong&gt;作为引入，然后我们依据一个案例来分析在这个过程中，我们&lt;strong&gt;使用开源产品遇到的多信号关联的挑战&lt;/strong&gt;，继而引出了我们构建一个这样的&lt;strong&gt;元数据平台&lt;/strong&gt;，并且需要&lt;strong&gt;维护什么样&lt;/strong&gt;的数据作为结尾，最终我们聊了下构建出这样的元数据平台为我们可观测性平台&lt;strong&gt;带来了什么样的价值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那构建 IT 的可观测性是一件复杂而又重要的事情，元数据为&lt;strong&gt;多信号之间关联&lt;/strong&gt;和&lt;strong&gt;产品的健壮性&lt;/strong&gt;带来了重要的作用。当然 OTel 为这项工作带来了不少便利，但是还会有更多的挑战在等着我们！&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 架构图&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/9_hu59d0d34067b5af64fcc087349529f932_212777_8a1baee9296ec106f7ced150f14ba034.webp 400w,
               /blog/the-importance-of-metadata-in-observability/9_hu59d0d34067b5af64fcc087349529f932_212777_f52a1b9200a532f08ed0ab17397b49d0.webp 760w,
               /blog/the-importance-of-metadata-in-observability/9_hu59d0d34067b5af64fcc087349529f932_212777_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/9_hu59d0d34067b5af64fcc087349529f932_212777_8a1baee9296ec106f7ced150f14ba034.webp&#34;
               width=&#34;760&#34;
               height=&#34;331&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后重点来啦，&lt;strong&gt;DeepFlow&lt;/strong&gt; 作为新时代的高度自动化的可观测性平台，将为大家带来意想不到的能力。&lt;/p&gt;
&lt;p&gt;大家对我们的产品的第一印象可能是 使用了 eBPF，但是我想告诉大家的是，我们产品&lt;strong&gt;不仅仅使用了一些炫酷的技术&lt;/strong&gt;，也会有比上述更加炫酷的&lt;strong&gt;类似元数据平台的功能&lt;/strong&gt;，并且对比其他产品具备&lt;strong&gt;无侵入的高度观测能力&lt;/strong&gt;、炫酷的 AutoTagging 技术和&lt;strong&gt;大幅度降低存储压力&lt;/strong&gt;的 SmartEncoding 能力等优点，欢迎大家关注我们的 Github 和公众号来了解更多。&lt;/p&gt;
&lt;p&gt;当然刚才提到了，后面几期我们会有专题来介绍 AutoTagging 和 SmartEncoding 能力，欢迎大家预定后面的直播。&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&#34;https://ce-demo.DeepFlow.yunshan.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow Online Demo&lt;/a&gt;，体验高度自动化的可观测性新时代。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/blog/cloud-native-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生下的可观测性发展方向&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%85%83%E6%95%B0%E6%8D%AE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;维基百科中的元数据的定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E5%85%83%E6%95%B0%E6%8D%AE/1946090&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;百度百科中的元数据的定义&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>DeepFlow 开启 Kube-OVN CNI Kubernetes 集群的可观测性</title>
      <link>https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/</link>
      <pubDate>Fri, 21 Oct 2022 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/</guid>
      <description>&lt;p&gt;本文为云杉网络原力释放 - 云原生可观测性分享会第十期直播实录。&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzA3ODM4ODIzNQ==&amp;amp;mid=2650725660&amp;amp;idx=1&amp;amp;sn=941fb54698dd8602511741b79fb26f92&amp;amp;chksm=8749f078b03e796ec928cd910aa92291918cb6250f5447eb8f877d9001a64312649ef5914cba#rd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;回看链接&lt;/a&gt;，&lt;a href=&#34;http://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/yunshan-ticket/pdf/6cb85592e56e6c0764e4a2300ae00448_20221017154248.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PPT 下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;大家好，我是云杉网络 DeepFlow 的云原生工程师宋建昌，今天给大家带来的主题是《DeepFlow 在 Kube-OVN 环境的可观测实践》&lt;/p&gt;
&lt;p&gt;今天讲解的主要内容是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一：DeepFlow 高度自动化的可观测性能力；&lt;/li&gt;
&lt;li&gt;第二：DeepFlow 一键开启 Kube-OVN 的可观测性；&lt;/li&gt;
&lt;li&gt;第三：DeepFlow 在 Kube-OVN 环境下的实际应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x0-deepflow-高度自动化的可观测性能力&#34;&gt;0x0: DeepFlow 高度自动化的可观测性能力&lt;/h1&gt;
&lt;p&gt;为什么需要可观测性，以及可观测的概念前面几期已经讲解过了，我再简单聊一下 DeepFlow 的架构、能力，方便不太熟悉 DeepFlow 的同学快速了解 DeepFlow 的背景：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 架构&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/3_hud7099c99220c6bea94aff12d95ef711a_260154_05ea26c49cd40b89bac273ed00ae5d96.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/3_hud7099c99220c6bea94aff12d95ef711a_260154_57dee99ad53215bd01bd576e6947a750.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/3_hud7099c99220c6bea94aff12d95ef711a_260154_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/3_hud7099c99220c6bea94aff12d95ef711a_260154_05ea26c49cd40b89bac273ed00ae5d96.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Rust 实现的 deepflow-agent 作为 frontend 采集数据，并与 K8s apiserver 同步资源和 Label 信息；Golang 实现的 deepflow-server 作为 backend 负责管理控制、负载均摊、存储查询。我们使用 MySQL 存储元数据，使用 ClickHouse 存储观测数据并支持扩展替换，使用 Grafana 展示观测数据。目前我们还有一个 Python 实现的 DeepFlow-app 进程用于提供分布式追踪的 API，后续将会使用 Golang 重写并逐步合并到 deepflow-server 中。deepflow-server 向上提供 SQL API，我们基于此开发了 Grafana 的 DeepFlow DataSource 和拓扑、分布式追踪等 Panel。deepflow-agent 可以运行在主机或 K8s 环境下，但 deepflow-server 必须运行在 K8s 中。&lt;/p&gt;
&lt;p&gt;AutoTagging 能力。我们为 DeepFlow 的所有原生数据和集成数据都自动注入了大量的标签，使得数据关联不再有屏障、数据下钻不再有缺陷。这些标签来自云资源、K8s 资源、K8s 自定义 Label，至于和业务相关的动态标签，DeepFlow 也会以非常高效的方式完整的存储下来，支持检索和聚合。&lt;/p&gt;
&lt;p&gt;DeepFlow 基于 BPF 的 AutoMetrics 能力可自动获取每一个微服务的 API 调用在应用函数、系统函数和网络通信等全栈路径上的黄金性能指标，并通过 BPF 和 AF_PACKET/winpcap 将这些能力扩展到更广泛的 Linux 内核版本及 Windows 操作系统。
目前，DeepFlow 已经通过 eBPF 支持了主流应用协议的解析，包括 HTTP 1/2/S、Dubbo、MySQL、Redis、Kafka、MQTT、DNS，未来还将扩展更多应用协议的支持。基于 DeepFlow 的 AutoMetrics 能力，能够零侵扰的获取应用的 RED（Request、Error、Delay）指标、网络协议栈的吞吐、时延、建连异常、重传、零窗等指标。DeepFlow Agent 会维护每个 TCP 连接、每个应用协议 Request 的会话状态，称之为 Flow。所有原始性能指标数据精细至 Flow 粒度，并额外自动聚合为 1s、1min 指标数据。基于这些指标数据，我们可呈现任意服务、工作负载、API 的全栈性能数据，并可绘制任意服务之间的调用关系拓扑图 —— Universal Service Map。&lt;/p&gt;
&lt;p&gt;基于 eBPF，DeepFlow 创新的实现了零侵扰的分布式追踪。DeepFlow 将 eBPF Event、BPF Packet、Thread ID、Coroutine ID、Request 到达时序、TCP 发送时序进行关联，实现了高度自动化的分布式追踪（AutoTracing）。目前 AutoTracing 支持所有同步阻塞调用（BIO，Blocking IO）场景、部分同步非阻塞调用（NIO，Non-blocking IO）场景，支持内核线程调度（kernel-level threading (opens new window)）场景，在这些场景下支持对任意服务组成的分布式调用链进行追踪。除此之外，通过解析请求中的 X-Request-ID 等字段，也支持对采用 NIO 模式的网关（如 Envoy）前后的调用链进行追踪。&lt;/p&gt;
&lt;p&gt;以及自动采集应用调用日志和流日志的 AutoLogging 技术等。&lt;/p&gt;
&lt;p&gt;我平时经常活跃于社群里面，经常有社区同学给我反馈一些问题等，其中有小伙伴反馈说内部推荐都不知道那些点可以用来说，具体解决什么问题。不知道如何界定使用场景，这次站在解决问题这个角度，来看一下 DeepFlow 可以定位什么具体问题，怎么定位问题。&lt;/p&gt;
&lt;p&gt;第一个场景，可能某天突然有个数据库节点负载、流量的告警发过来了，怎么快速定位到哪个服务请求数据库的流量变多，哪些 SQL 突然变多，然后下一步怎么去看上游服务的 api 调用情况：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-快速定位异常-sql&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;快速定位异常 SQL&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/4_hu01342ac9df99e887ced534243a3fd0de_327167_94664da24f39f19b32396307afcf1b2d.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/4_hu01342ac9df99e887ced534243a3fd0de_327167_dd6669fa331e25183add418adafeb05e.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/4_hu01342ac9df99e887ced534243a3fd0de_327167_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/4_hu01342ac9df99e887ced534243a3fd0de_327167_94664da24f39f19b32396307afcf1b2d.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      快速定位异常 SQL
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;以往这类问题单纯从数据库的角度可能不太容易得到客户端分组精确的指标数据，但是现在有了 DeepFlow 就可以在看数据去定位问题：&lt;/p&gt;
&lt;p&gt;这页 PPT 中的第一个 panel 可以看到慢查询的 SQL，找到慢请求；&lt;/p&gt;
&lt;p&gt;第二个 panel 可以看到和数据库有交互的服务请求数据库的流量大小，查找到请求流量较多的服务；&lt;/p&gt;
&lt;p&gt;第三个 panel 可以看到和数据库有交互的服务请求数量，查找到请求数量较多的服务；&lt;/p&gt;
&lt;p&gt;第四个 panel 可以看到和数据库请求 SQL 的 top 数据，查找较多的 SQL 的请求数量，进而快速找到对应的模块和相关研发；
然后切换协议到 ALL 或者 HTTP，切换 workload 到上游服务，继续排查上游服务的情况：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-快速定位上游服务异常-api&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;快速定位上游服务异常 API&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/5_hu01342ac9df99e887ced534243a3fd0de_302336_c40cab0572363eb7b4782a03bde581df.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/5_hu01342ac9df99e887ced534243a3fd0de_302336_12047331cf10639b37216c34375ecb50.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/5_hu01342ac9df99e887ced534243a3fd0de_302336_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/5_hu01342ac9df99e887ced534243a3fd0de_302336_c40cab0572363eb7b4782a03bde581df.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      快速定位上游服务异常 API
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第二个场景，响应变慢：如何判断延迟在应用、网络、还是数据库：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-1663828883603png&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;1663828883603.png&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/6_hudecd97d24540cd84432b1178514f09e9_212516_08071ca6c46d8d1f0f3e84a222359fab.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/6_hudecd97d24540cd84432b1178514f09e9_212516_97964da7b71661bdd87fd069ec1d3c59.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/6_hudecd97d24540cd84432b1178514f09e9_212516_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/6_hudecd97d24540cd84432b1178514f09e9_212516_08071ca6c46d8d1f0f3e84a222359fab.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      1663828883603.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过一个 trace，查看 span 长度即可，图中 S 开头的是 eBPF 采集到的系统 span，N 是网络 span，A 是应用 span，最下面有两个很短的紫色的是数据库的系统 span。
我们在内核版本 4.14+的环境中会自动开启 eBPF，不需要业务进行任何插码、重启等操作，即可开启这个能力。&lt;/p&gt;
&lt;p&gt;第三个场景，业务异常：如何快速找到服务端口/接口异常：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-快速发现问题接口&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;快速发现问题接口&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/7_huf52d73fb2406b7b2133180aa9fa35462_302497_d454b880bbee2949d2d817d58dbe7ba5.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/7_huf52d73fb2406b7b2133180aa9fa35462_302497_164759a150e89c4cedca07498604a081.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/7_huf52d73fb2406b7b2133180aa9fa35462_302497_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/7_huf52d73fb2406b7b2133180aa9fa35462_302497_d454b880bbee2949d2d817d58dbe7ba5.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      快速发现问题接口
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;有同学反馈有些缓存等服务挂掉了，影响了业务的响应情况，但是又不影响业务运行，没有及时发现并响应这个问题，这个场景在 DeepFlow 中就可以通过一个统计错误响应的端口的 Dashboard，并根据端口、Pod、vm 等资源快速找到对应到节点及服务，排查端口挂掉原因，以及我们已经规划了 6.1.4 版本可以配置 Grafana 告警，也会内置一些告警策略，可以通过 Grafana 告警来等功能快速感知并响应问题。&lt;/p&gt;
&lt;p&gt;可能会有同学问为什么我部署的 DeepFlow 中没有刚刚的 Dashboard，我们目前发现了现有的 Grafana 在排障中的一些不足，我们也和 DeepFlow 的用户讨论了实际需求，正在整理相关的 Dashboard，大家也可以自己构造自己的 Dashboard，如果觉着不错也可以提交 PR 到 DeepFlow 下的 dahsboard 的 repo 中，分享给所有的 DeepFlow 用户。当然也欢迎给我们反馈你的痛点、场景，我们通过 Grafana 展示 出来 DeepFlow 的数据来解决大家的痛点。&lt;/p&gt;
&lt;h1 id=&#34;0x1-deepflow-一键开启-kube-ovn-的可观测性&#34;&gt;0x1: DeepFlow 一键开启 Kube-OVN 的可观测性&lt;/h1&gt;
&lt;p&gt;上面简单聊了一下 DeepFlow 在几个场景中如何排查问题，进入今天的主题 DeepFlow + Kube-OVN 一键可观测：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-ovn-环境中快速部署-deepflow&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kube-OVN 环境中快速部署 DeepFlow&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/9_hu96e6117869e4b600c7c8173484e33b8b_155531_307e31048ee94525ae6f6c0bfd08c2c9.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/9_hu96e6117869e4b600c7c8173484e33b8b_155531_58015b9e879306cf59572af78f8a96a3.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/9_hu96e6117869e4b600c7c8173484e33b8b_155531_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/9_hu96e6117869e4b600c7c8173484e33b8b_155531_307e31048ee94525ae6f6c0bfd08c2c9.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kube-OVN 环境中快速部署 DeepFlow
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;正如同 PPT 中看到的这样，简单三条命令就可以将 DeepFlow 部署在 Kube-OVN 的集群中，观测你 K8s 集群上所有数据的同时又不需要业务进行任何改动、任何重启
同时我们还支持接入多集群 agent，接入云主机、传统服务器的 agent，接入 Prometheus、Telegraf 的 Metrics 数据，以及可以通过 otel-collector 接入符合 OpenTelemetry 协议的 trace 数据、Skywalking 的 trace 数据等等，对这些数据通过 AutoTagging 能力统一打上 DeepFlow 的 label，和 DeepFlow 的资源关联起来，打通数据孤岛。&lt;/p&gt;
&lt;p&gt;安装完 DeepFlow 之后，会默认内置一些 Dashboard，这里简单介绍一下这几个 Dashboard：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络可观测
&lt;ul&gt;
&lt;li&gt;Node/Pod 的流量拓扑&lt;/li&gt;
&lt;li&gt;Node/Pod 流日志&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用可观测
&lt;ul&gt;
&lt;li&gt;服务性能总览&lt;/li&gt;
&lt;li&gt;微服务调用拓扑&lt;/li&gt;
&lt;li&gt;服务调用日志&lt;/li&gt;
&lt;li&gt;调用链追踪 (Distributed Tracing)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-node-流量拓扑&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Node 流量拓扑&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/11_hu1b3a0cded1c663f5237e49215fc28eb9_260395_19defa991b300ab8ea3ec6430a2eddf5.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/11_hu1b3a0cded1c663f5237e49215fc28eb9_260395_e8761d85315a5a85915c3b92a6244dc2.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/11_hu1b3a0cded1c663f5237e49215fc28eb9_260395_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/11_hu1b3a0cded1c663f5237e49215fc28eb9_260395_19defa991b300ab8ea3ec6430a2eddf5.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Node 流量拓扑
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这一个是我们的 Node 流量拓扑，可以清晰的展示出来 Node 之间、Node 和 Pod 的流量关系，以及右侧的吞吐、重传比例 建联失败比例等指标&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-pod-流量拓扑&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Pod 流量拓扑&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/12_hu1b3a0cded1c663f5237e49215fc28eb9_241136_c2d32f7206f3649dc0c42c7c7c309735.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/12_hu1b3a0cded1c663f5237e49215fc28eb9_241136_b2b558765f1771bddd3dc1a79b0a86c5.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/12_hu1b3a0cded1c663f5237e49215fc28eb9_241136_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/12_hu1b3a0cded1c663f5237e49215fc28eb9_241136_c2d32f7206f3649dc0c42c7c7c309735.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Pod 流量拓扑
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第二个是我们的 Pod 流量拓扑，可以清晰的展示出来 Pod 之间的流量关系，以及右侧的吞吐、重传 建联失败等指标&lt;/p&gt;
&lt;p&gt;把鼠标放到两个 Pod 的连线上可以看到两个 Pod 之间的指标，比如可以通过 tap_side 看出采集位置是在客户端和服务端、pps、重传、建连失败、延迟等指标&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-pod-拓扑中发现的-kube-ovn-配置异常&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Pod 拓扑中发现的 Kube-OVN 配置异常&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/13_hu8e8233a050b79c95bf2c869a939c0f21_333038_a102ea80e6b60af04e3337c1a6d7963f.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/13_hu8e8233a050b79c95bf2c869a939c0f21_333038_db1b8f8e94ec28eeb1389d13e04fea73.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/13_hu8e8233a050b79c95bf2c869a939c0f21_333038_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/13_hu8e8233a050b79c95bf2c869a939c0f21_333038_a102ea80e6b60af04e3337c1a6d7963f.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Pod 拓扑中发现的 Kube-OVN 配置异常
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里有个小插曲，我上周在做这篇 PPT 的时候，使用 sealos 一键拉起了一个 Kube-OVN、DeepFlow 的环境，但是发现 Pod 的拓扑图没有连接起来，左侧是异常的拓扑图，右侧是使用 Kube-OVN 官网脚本部署的 Kube-OVN1.8.8 版本的正常数据，稍微看一下发现所有跨节点的流量在拓扑图里展示的都是客户端节点 ovn0 网卡的 IP，而不是客户端 Pod IP，怀疑是解封装的时候源 IP 有了问题，梦馨反馈是 sealos 的部署脚本里默认把 ovn-lb 给关了，svc 路径上的处理有的地方被 NAT 了，把 kube-ovn-controller 里的 enable-lb 改成 true 应该就行了，这里也致敬一下 sealos，基于 sealos 的集群镜像功能，可以一键拉起一个部署好 Kube-OVN、DeepFlow、Helm 等应用、工具的 K8s 集群，节省了大量的时间和精力。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-node-流日志展示&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Node 流日志展示&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/14_hu1b3a0cded1c663f5237e49215fc28eb9_247877_19ab08a6ffdd25b6bc1b4e4d6f5a80dd.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/14_hu1b3a0cded1c663f5237e49215fc28eb9_247877_aa070affb2a0f6cd8c728e380a43219f.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/14_hu1b3a0cded1c663f5237e49215fc28eb9_247877_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/14_hu1b3a0cded1c663f5237e49215fc28eb9_247877_19ab08a6ffdd25b6bc1b4e4d6f5a80dd.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Node 流日志展示
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这一个是我们的 Node 流日志，可以看到 Node 之间的每个流的情况，所谓流日志是捕获特定位置的流量，将流量转化为流日志记录下来，流日志是记录捕获特定时间窗口的特定五元组的网络流。&lt;/p&gt;
&lt;p&gt;这个 Dashboard 以 Node 维度看流日志总量、错误数量、TCP 建连时延、传输时延等情况，以及每一个流的开始时间、客户端、服务端、流量采集位置、协议、客户端口、服务端口、状态、发送、接收流量大小、客户端、服务端重传、TCP 建连、传输时延等数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-pod-流日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Pod 流日志&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/15_hu1b3a0cded1c663f5237e49215fc28eb9_254710_71ffe014e95baef912c5c409c9211726.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/15_hu1b3a0cded1c663f5237e49215fc28eb9_254710_d058498b26a25e4edd806308fe7567e6.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/15_hu1b3a0cded1c663f5237e49215fc28eb9_254710_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/15_hu1b3a0cded1c663f5237e49215fc28eb9_254710_71ffe014e95baef912c5c409c9211726.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Pod 流日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个 Dashboard 以 Pod 维度以看流日志总量、错误数量、TCP 建连时延、传输时延等情况，以及每一个流的开始时间、客户端、服务端、流量采集位置、协议、客户端口、服务端口、状态、发送、接收流量大小、客户端、服务端重传、TCP 建连、传输时延等数据。&lt;/p&gt;
&lt;p&gt;前面的 Dashboard 是在网络层面的统计数据，后面几个是在应用层面的统计数据：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务性能总览&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;服务性能总览&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/16_hu1a7000499458e4d099f0e689fe781f48_271607_366d3bdc79a69692c66a6f2c18d5c335.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/16_hu1a7000499458e4d099f0e689fe781f48_271607_0c5a95ac1842255a94807647f81aac50.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/16_hu1a7000499458e4d099f0e689fe781f48_271607_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/16_hu1a7000499458e4d099f0e689fe781f48_271607_366d3bdc79a69692c66a6f2c18d5c335.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务性能总览
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务性能总览：上面是有发送的请求数量、错误数量及延迟等，以及 Pod 维度的 协议分组的请求数量、客户端错误比例、服务端错误比例及延迟等：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-微服务调用总览&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;微服务调用总览&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/17_hu1a7000499458e4d099f0e689fe781f48_239546_6845642669f3efb4a30a08988244ef70.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/17_hu1a7000499458e4d099f0e689fe781f48_239546_1de2e5f2f3ea0e35d1e9c719bc4706f6.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/17_hu1a7000499458e4d099f0e689fe781f48_239546_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/17_hu1a7000499458e4d099f0e689fe781f48_239546_6845642669f3efb4a30a08988244ef70.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      微服务调用总览
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务调用拓扑，和前面 Pod 流量拓扑有什么不同呢，前面的 Pod map 是基于 4 层流量画出来的拓扑，这个是基于 7 层请求的流量画出来的，拓扑、请求、错误延迟等指标、以及区分客户端、服务端的请求、错误、延迟的指标数据：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-微服务调用日志展示&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;微服务调用日志展示&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/18_hu1a7000499458e4d099f0e689fe781f48_274311_50ad41e13a7a8b634c61f774fbc6ae2b.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/18_hu1a7000499458e4d099f0e689fe781f48_274311_609e3e7f2515cbc9c7b53a4c2db0d549.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/18_hu1a7000499458e4d099f0e689fe781f48_274311_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/18_hu1a7000499458e4d099f0e689fe781f48_274311_50ad41e13a7a8b634c61f774fbc6ae2b.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      微服务调用日志展示
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;服务调用日志，
上面有 7 层请求的总量、错误数量、延迟等指标
下面可以看到每一个应用调用的开始时间、客户端、服务端、对应的协议、方法、请求域名、请求资源、状态、响应码等数据&lt;/p&gt;
&lt;p&gt;这个就是我们的一个基于 eBPF 的 AutoTracing 能力，内核大于 4.14+ 不需要业务进行任何改动即可开启这个能力：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-调用链追踪-tracing&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;调用链追踪 (tracing)&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/19_hu1a7000499458e4d099f0e689fe781f48_230046_3254d1e41a9d2c86cc5122be8d216eef.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/19_hu1a7000499458e4d099f0e689fe781f48_230046_0734ee439cd14cb1751ec1e21fe55864.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/19_hu1a7000499458e4d099f0e689fe781f48_230046_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/19_hu1a7000499458e4d099f0e689fe781f48_230046_3254d1e41a9d2c86cc5122be8d216eef.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      调用链追踪 (tracing)
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;以上所有的截图都是在 Kube-OVN 的环境中截的，安装 DeepFlow 后几分钟就能看到上面说的所有数据。&lt;/p&gt;
&lt;h1 id=&#34;0x2-deepflow-对-kube-ovn-的实际应用&#34;&gt;0x2: DeepFlow 对 Kube-OVN 的实际应用&lt;/h1&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-增强-kube-ovn-diagnose-工具的可观测能力&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 增强 Kube-OVN diagnose 工具的可观测能力&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/21_hu1328532474b18c80f0ad49fc1aa6fd8f_324983_a317691b087fc76405437ab6ca375b58.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/21_hu1328532474b18c80f0ad49fc1aa6fd8f_324983_08b73dbf0c55192443dd13ecda166a2a.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/21_hu1328532474b18c80f0ad49fc1aa6fd8f_324983_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/21_hu1328532474b18c80f0ad49fc1aa6fd8f_324983_a317691b087fc76405437ab6ca375b58.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 增强 Kube-OVN diagnose 工具的可观测能力
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;diagnose 作为 Kube-OVN 的网络组件状态检查工具，可以一键检测 Kube-OVN 组件的状态、本节点、跨节点的关键服务的连通性和网络延迟情况等，可以快速获得检测数据，定位系统问题。&lt;/p&gt;
&lt;p&gt;DeepFlow 的定位是一个云原生无侵入的可观测平台，可以大幅增强 Kube-OVN 环境的可观测能力，通过丰富的数据可以画出任何想要的 Dashboard，比如前面讲到的接口/SQL 调用时延趋势图及端口的错误请求数量趋势图等，可以快速看到有问题的服务、端口、接口等，帮助快速定位到相关有问题的服务/模块，甚至可以通过 Grafana 进行告警，在出现问题的第一时间进行响应，减小损失。也可以观察整个集群/服务的当前状态，统计一个时间段内的服务响应情况等：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-增强-kube-ovn-的观测能力&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 增强 Kube-OVN 的观测能力&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/22_hu1328532474b18c80f0ad49fc1aa6fd8f_197800_bcadc0f26586b7a208f857d17e487a19.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/22_hu1328532474b18c80f0ad49fc1aa6fd8f_197800_8d3b5410e2ce7b619322462f4a89af3b.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/22_hu1328532474b18c80f0ad49fc1aa6fd8f_197800_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/22_hu1328532474b18c80f0ad49fc1aa6fd8f_197800_bcadc0f26586b7a208f857d17e487a19.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 增强 Kube-OVN 的观测能力
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;流量采集位置：我们默认会在容器节点的物理网卡及容器内 eth0 网卡在节点的 veth-peer 网卡上采集 cBPF 流量，通过 eBPF 采集进程 span 信息，Kube-OVN 的默认容器网卡名称为 containerID_h
，并对流量进行关联节点、Pod 等资源，那么这个图是在同子网跨节点场景的一个架构图，实际上在跨 VPC、双栈等场景采集方式都是一样的，并没有任何区别。&lt;/p&gt;
&lt;p&gt;隧道解封装：DeepFlow 会查看所有包是否有封装，一旦看到有封装，就会进行解封装操作，目前默认开启了 vxlan 和 IPIP 隧道等解封装，也就是在容器节点的 eth0 网卡上的 Pod 流量是经过了封装的，不过我们会自动解开，并获取解封装后的流量源 IP、目标 IP 等数据关联客户端服务端的 Pod 等资源。
Kube-OVN 的 geneve 隧道如果大家用的比较多，也可以反馈给我们，我们支持一下这个协议的隧道解析。&lt;/p&gt;
&lt;p&gt;跨 Node 流量如何关联：我们的 deepflow-agent 以 daemonset 部署在所有节点上，我们通过五元组等信息可以判断到跨 Node 的同一个流，并统计在每个流量采集位置的网络吞吐到性能，再到时延多个维度的指标量。&lt;/p&gt;
&lt;p&gt;流量关联 Pod、Node 等资源：agent 会 watch K8s 集群的资源，获取 NodeIP、mac、deployment、svc、Pod 等信息，并上报给 server，通过 AutoTagging 能力对 agent 采集到的流量进行关联对应的资源，在 Grafana 上看到的流量就不是枯燥的 IP MAC 等信息了，而是 Pod、Node 等资源：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络通信场景追踪&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络通信场景追踪&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/23_hu77e9e4c9d9f4d5761caac0097ed93a8b_207026_a9248c021b38193af4c1f5df4949a010.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/23_hu77e9e4c9d9f4d5761caac0097ed93a8b_207026_d5b88ad608f39676b79ef6e44b41cb2c.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/23_hu77e9e4c9d9f4d5761caac0097ed93a8b_207026_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/23_hu77e9e4c9d9f4d5761caac0097ed93a8b_207026_a9248c021b38193af4c1f5df4949a010.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络通信场景追踪
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;NetworkPolicy 为 Kubernetes 提供的网络策略接口，Kube-OVN 通过 OVN 的 ACL 进行了实现。使用了 NetworkPolicy 后如果出现网络不通的情况，难以判断是网络故障问题还是 NetworkPolicy 规则设置问题导致的网络中断。Kube-OVN 提供了 NetworkPolicy 日志功能，帮助管理员快速定位 NetworkPolicy drop 规则是否命中，并记录有哪些非法访问。&lt;/p&gt;
&lt;p&gt;NetworkPolicy 日志功能一旦开启，对每个命中 drop 规则的数据包都需要打印日志，会带来额外性能开销。&lt;/p&gt;
&lt;p&gt;而 DeepFlow 虽然目前无法判断流量是被 drop 了还是网络问题，但是从 DeepFlow 的多个维度以及熟悉 K8s networkpolicy 功能的同学还是能大概判断出流量是被 networkpolicy drop 掉了，DeepFlow 也规划了流状态的功能。&lt;/p&gt;
&lt;p&gt;Kube-OVN 可以的流日志基本判断出流量是被 drop 了还是网络故障，让我想起了之前遇到的场景，研发反馈一个开发环境的一个 Namespace 下的 Pod 突然 Ping 不通了，接到问题后和研发一起开始排查，发现 Node 和除这个 Namespace 下的 Pod 网络都是通的，但是又无法解释为啥从 Node Ping 这个 NS 下的 Pod 网络不通了，然后突然发现我们容器云产品页面上的网络策略功能被打开了，这个功能藏的有些深，一般不去看这个地方，后来确认是产品不熟悉这个功能，就点了一下，但没有及时关闭导致的，现在回头想一下，如果当时有 Kube-OVN 的 networkpolicy 日志功能或者 DeepFlow，可能 10 分钟就能知道流量是被网络策略给 drop 掉了：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-自动生成网络流日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;自动生成网络流日志&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/24_hu89f1e3c12bdfd26e1fd6cd24b0e6e43a_362489_13b1fcf5ee707374fee9d676e4d07a41.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/24_hu89f1e3c12bdfd26e1fd6cd24b0e6e43a_362489_4f87dabc963275d2ccca6550d320fbe5.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/24_hu89f1e3c12bdfd26e1fd6cd24b0e6e43a_362489_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/24_hu89f1e3c12bdfd26e1fd6cd24b0e6e43a_362489_13b1fcf5ee707374fee9d676e4d07a41.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      自动生成网络流日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-网络流日志功能和-kube-ovn-networkpolicy-日志功能的差异&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 网络流日志功能和 Kube-OVN NetworkPolicy 日志功能的差异&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/25_hu89f1e3c12bdfd26e1fd6cd24b0e6e43a_244350_25a0d5ddbf2c1aa0902e0e7c8f0a18f2.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/25_hu89f1e3c12bdfd26e1fd6cd24b0e6e43a_244350_da9243f8fdffcc3515a9130f40a61a9b.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/25_hu89f1e3c12bdfd26e1fd6cd24b0e6e43a_244350_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/25_hu89f1e3c12bdfd26e1fd6cd24b0e6e43a_244350_25a0d5ddbf2c1aa0902e0e7c8f0a18f2.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 网络流日志功能和 Kube-OVN NetworkPolicy 日志功能的差异
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;DeepFlow 对后端分析工具更友好，当然这个功能只在我们企业版本中有，下面是我们 DeepFlow 在流量分发功能上对 Kube-OVN 的增强：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-增强-kube-ovn-的流量分发能力&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 增强 Kube-OVN 的流量分发能力&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/26_hu9810aeb7c7d3bdf03533b32f81d78db8_221377_1a80da7c53f7dc7d04df0adb1f35ca48.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/26_hu9810aeb7c7d3bdf03533b32f81d78db8_221377_849ca15aaeac323bc8ed098c64f359ae.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/26_hu9810aeb7c7d3bdf03533b32f81d78db8_221377_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/26_hu9810aeb7c7d3bdf03533b32f81d78db8_221377_1a80da7c53f7dc7d04df0adb1f35ca48.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 增强 Kube-OVN 的流量分发能力
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-增强-kube-ovn-的流量分发能力&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 增强 Kube-OVN 的流量分发能力&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/27_hu9810aeb7c7d3bdf03533b32f81d78db8_145748_f5d21273624884fba7e070b5d054010e.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/27_hu9810aeb7c7d3bdf03533b32f81d78db8_145748_f29a2d18e78b01cf796076cf2b5748a0.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/27_hu9810aeb7c7d3bdf03533b32f81d78db8_145748_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/27_hu9810aeb7c7d3bdf03533b32f81d78db8_145748_f5d21273624884fba7e070b5d054010e.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 增强 Kube-OVN 的流量分发能力
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;面向业务的流量过滤&lt;/strong&gt;：用户可设置源端地址、端口号、目的端地址、端口号、协议五元组作为过滤条件，并支持直接输入 VPC、子网、云服务器、容器 Pod、自定义资源组等替代 IP 地址，精准过滤虚拟网络中的流量，最大利用网络带宽和分析工具效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;源端 Payload 截断&lt;/strong&gt;：用户可设置对网包的 L4 Payload 长度进行截断，最大利用网络带宽和分析工具效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多层流量标签&lt;/strong&gt;：分发流量利用隧道封装发送，通过在隧道头中携带特殊的流量标签，用于对不同 VPC、容器服务、流量采集位置（客户端/服务端）等流量属性进行标记，以帮助后端分析工具解决 VPC 之间 IP 段冲突、容器服务后端 Pod 的 IP 地址频繁变动等问题，并实现对客户端、服务端采集流量进行端到端对比分析。
采集器支持在原始包之前添加 VXLAN 或 ERSPAN 隧道及内层 VLAN 标签，后端汇聚分流设备或 TAP 交换机仅需要做一次性的隧道解封装配置，无需根据不同的隧道标签解封装报文的 VLAN 标签，极大简化分流设备/TAP 交换机的配置复杂度和特性依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;流量全局去重&lt;/strong&gt;：对于同一个网包，采集器会在源端云服务器及目的端云服务器处多次采集到。当发往同一个分发点时，如果不做去重，后端分析工具将收到重复的网包，同时也会占用至少双倍的带宽。DeepFlow 引入分布式去重功能解决重复采集的问题，具体原理可查看场景介绍。
为了最大限度减少对带宽的占用，对发往同一个分发点、设置相同隧道标签的同一个网包，按所有匹配策略的最大 Payloady 截取长度进行截取。例如两条分发策略 A=Payload 截断 30、B=Payload 截断 20，对于同时匹配这两条策略的网包将会被截取 30 字节 Payload 后进行发送。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;流量多路分发&lt;/strong&gt;：当一个网包匹配的多条分发策略对应不同分发点或不同隧道标签时，流量将会复制多份分别发送。例如两条策略 A=分发点 C1、B=分发点 C2，对于同时匹配这两条策略的网包，在分发时复制两份，一份分发给 C1，一份分发给 C2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;资源变更感知&lt;/strong&gt;：当云服务器迁移、云服务器 IP 变更、容器 Pod 弹性伸缩时，分发策略自动感知，无需用户重新设置，迁移期间的流量持续分发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;0x3-什么是-deepflow&#34;&gt;0x3: 什么是 DeepFlow&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/DeepFlowys/DeepFlow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow&lt;/a&gt; 是一款开源的高度自动化的可观测性平台，是为云原生应用开发者建设可观测性能力而量身打造的全栈、全链路、高性能数据引擎。DeepFlow 使用 eBPF、WASM、OpenTelemetry 等新技术，创新的实现了 AutoTracing、AutoMetrics、AutoTagging、SmartEncoding 等核心机制，帮助开发者提升埋点插码的自动化水平，降低可观测性平台的运维复杂度。利用 DeepFlow 的可编程能力和开放接口，开发者可以快速将其融入到自己的可观测性技术栈中。&lt;/p&gt;
&lt;p&gt;GitHub 地址：https://github.com/DeepFlowys/DeepFlow&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&#34;https://ce-demo.DeepFlow.yunshan.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow Online Demo&lt;/a&gt;，体验高度自动化的可观测性新时代。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DeepFlow AutoLogging 介绍：自动采集应用调用日志和流日志</title>
      <link>https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/</link>
      <pubDate>Fri, 14 Oct 2022 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/</guid>
      <description>&lt;p&gt;本文为云杉网络&lt;code&gt;原力释放 - 云原生可观测性分享会&lt;/code&gt;第九期直播实录。&lt;a href=&#34;https://www.bilibili.com/video/BV1Z14y147XM?spm_id_from=333.337.search-card.all.click&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;回看链接&lt;/a&gt;，&lt;a href=&#34;http://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/yunshan-ticket/pdf/f9d3931bd360757b30b91d93d1aa9621_20220823171717.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PPT 下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;DeepFlow 是一款开源的高度自动化的可观测性平台，是为云原生应用开发者建设可观测性能力而量身打造的全栈、全链路、高性能数据引擎。DeepFlow 使用 eBPF、WASM、OpenTelemetry 等新技术，创新的实现了 AutoTracing、AutoMetrics、AutoTagging、SmartEncoding 等核心机制，帮助开发者提升埋点插码的自动化水平，降低可观测性平台的运维复杂度。利用 DeepFlow 的可编程能力和开放接口，开发者可以快速将其融入到自己的可观测性技术栈中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow---架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow - 架构图&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630472cfdd6cc_hue06b268d1457888f57ea4f3ca73b05d6_254620_8f6d2a541c399a6b731e3d0c6d92f949.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630472cfdd6cc_hue06b268d1457888f57ea4f3ca73b05d6_254620_1aad3ed8c372e8d3478ce847cb073bb6.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630472cfdd6cc_hue06b268d1457888f57ea4f3ca73b05d6_254620_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630472cfdd6cc_hue06b268d1457888f57ea4f3ca73b05d6_254620_8f6d2a541c399a6b731e3d0c6d92f949.webp&#34;
               width=&#34;760&#34;
               height=&#34;432&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow - 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今天的内容是云杉网络“云原生可观测性分享会”的直播里面第八期&lt;a href=&#34;https://deepflow.yunshan.net/blog/001-a-new-era-of-automated-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow 首个开源版本&lt;/a&gt;的分享的延续，上篇主要和大家详细聊了 AutoMetrics 和 AutoTracing 的能力，对于可观测领域三大支柱的的 Logging，在这次博客及直播中给大家带来详细讲解。&lt;/p&gt;
&lt;p&gt;今天从三个方面给大家进行分享：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一：分享应用调用日志，从数据来源、数据抽象到数据使用三个角度和大家谈谈，如何自动采集的 HTTP/MySQL 等多协议调用日志；&lt;/li&gt;
&lt;li&gt;二：分享网络流日志，主要对比公有云的流日志及流日志的应用场景；&lt;/li&gt;
&lt;li&gt;三：讲解 AutoLogging 的实现，基于 BPF/eBPF 的自动日志采集能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;0x0-应用调用日志---数据来源&#34;&gt;0x0: 应用调用日志 - 数据来源&lt;/h2&gt;
&lt;p&gt;首先强调，应用调用日志与应用在代码层面打的日志不同，例如 Nginx 的 AccessLog，MySQL 的 General Log/Error Log 这些都是调用日志的范畴。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志---数据来源&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志 - 数据来源&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/202208236304743fc4697_hu4e23eb74058e007390e3cac0cd7c68c0_384694_d6e5940b9fa4170c646d8fc84873de29.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/202208236304743fc4697_hu4e23eb74058e007390e3cac0cd7c68c0_384694_167d5b43391872fb31f18234d1d4b471.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/202208236304743fc4697_hu4e23eb74058e007390e3cac0cd7c68c0_384694_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/202208236304743fc4697_hu4e23eb74058e007390e3cac0cd7c68c0_384694_d6e5940b9fa4170c646d8fc84873de29.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志 - 数据来源
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但是这些日志都是单个组件的日志，并不是应用的调用日志，对于应用问题的排查，需要挨个去找组件的负责人看日志，但组件负责人不懂业务，不知道如何快速搜索日志，导致了问题的排查过程中协作成本巨高。&lt;/p&gt;
&lt;p&gt;应用的调用日志是给 Dev 团队建设的，一个站在应用视角快速查看所有的调用详情信息的能力，其实这个能力获取可以将目前现有的组件日志都集中起来查看也是一种思路，但是如何以应用无感知/自动化的形式低成本的接入，以及更符合云原生的这个理念来实现的话，这是目前市面上没有的，这是 DeepFlow 的 AutoLogging 的价值点所在。&lt;/p&gt;
&lt;p&gt;DeepFlow 的调用日志，其实由各种各样的应用协议组成的，目前 DeepFlow 平台上已经包含了例如网络应用的 HTTP 的访问日志、DNS 的查询日志、SQL/NoSQL 的操作日志、RPC 的调用日志、MQ 的 API 调用日志，也会包含可观测领域中 Tracing 的数据，例如 OpenTelmetry 协议的 Span 调用，还会陆续支持一些物联网的协议，例如 MQTT 的日志。&lt;/p&gt;
&lt;h2 id=&#34;0x1-应用调用日志---数据抽象&#34;&gt;0x1: 应用调用日志 - 数据抽象&lt;/h2&gt;
&lt;p&gt;可以看到数据的来源非常的丰富，随着社区的需求和版本的迭代，将会有更多协议的数据接入。如果需更好的使用这些‘五花八门’的数据，需要对数据进行治理，治理的第一步，对数据进行统一的抽象，数据抽象将从公共字段、请求字段、响应字段、指标量，这四个层面来展开：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志---数据抽象&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志 - 数据抽象&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b132d70_hueaae236f76106224d6ccd7391b93445b_252194_db34096826e2b4283cdfbc4068ea1ca0.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b132d70_hueaae236f76106224d6ccd7391b93445b_252194_a2b3609629451f2f06acdfeb4dd3d999.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b132d70_hueaae236f76106224d6ccd7391b93445b_252194_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b132d70_hueaae236f76106224d6ccd7391b93445b_252194_db34096826e2b4283cdfbc4068ea1ca0.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志 - 数据抽象
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公共字段：包含应用协议、协议版本、日志类型，其中日志类型包含请求/响应/会话类型，一般协议都是这三种，也会有一些协议有些例外，例如 OpenTelemetry 协议，仅一个会话类型。&lt;/li&gt;
&lt;li&gt;请求字段：整体抽象为请求类型、请求域名、请求资源、请求 ID，例如 HTTP 的方法，MySQL 的命令类型，DNS 的查询类型都为请求类型，HTTP 的 host 对应请求域名，HTTP 的 Url、MySQL 的命令、DNS 的查询名称都对应请求资源，这个请求资源的抽象是参考各个 APM 的厂商的定义，例如 Datadog 的 Resource，Skywalking 的 Endpoint。&lt;/li&gt;
&lt;li&gt;响应字段：分为响应状态、响应码、响应异常、结果，整体来说基本都是对应响应码映射的。&lt;/li&gt;
&lt;li&gt;指标量：分为吞吐请求长度、响应长度的字段，以及响应时延字段，结合指标量可以更好的分析调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;0x2-应用调用日志---自定义属性&#34;&gt;0x2: 应用调用日志 - 自定义属性&lt;/h2&gt;
&lt;p&gt;数据抽象的收益是统一管理，可弊端也在统一。在设计之初，其实就考虑了要做自定义属性的扩展，随着 OpenTemetry 的 Tracing 数据接入，这个事情就变的更加重要。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志---自定义属性&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志 - 自定义属性&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b43a9f8_huee4c235c0819f76de17963b375fb6b72_281866_f4f7202d87f23387aefb6a16e9a4d709.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b43a9f8_huee4c235c0819f76de17963b375fb6b72_281866_0807f0860b2eba93ce87f11d938559df.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b43a9f8_huee4c235c0819f76de17963b375fb6b72_281866_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b43a9f8_huee4c235c0819f76de17963b375fb6b72_281866_f4f7202d87f23387aefb6a16e9a4d709.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志 - 自定义属性
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;因此除了定义的标准字段外，又定义了 Attribute_Names 和 Attribute_Values 这两个数组，数组里面可以携带自定义属性和自定义属性对应的值，这个是根据不同的需求来携带，没有长度和格式的限制，非常的灵活。&lt;/p&gt;
&lt;p&gt;两个数组里面的 Key 和 Value 按顺序来进行映射，在产品化的时候，通过 Qurey 组件进行转化，用户是无感知数组的存在的，看到的都是 Key，Value 这样的属性关系，通过 Key 查询来获取 Value，这个和使用其他 Tag 查询的逻辑也是一致的。&lt;/p&gt;
&lt;h2 id=&#34;0x3-应用调用日志-autotagging&#34;&gt;0x3: 应用调用日志-AutoTagging&lt;/h2&gt;
&lt;p&gt;刚刚分析的是各种协议如何映射为调用日志，站在应用的视角已经可以统一查看调用日志了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-autotagging&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-AutoTagging&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b1b3c9b_hu1d14747e446b92a3960cfef4651b2d8c_361378_1e4730b15f8e744b754c0e7ee2565428.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b1b3c9b_hu1d14747e446b92a3960cfef4651b2d8c_361378_c33ff3970ca846c4f649c9fa7a88f9d4.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b1b3c9b_hu1d14747e446b92a3960cfef4651b2d8c_361378_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b1b3c9b_hu1d14747e446b92a3960cfef4651b2d8c_361378_1e4730b15f8e744b754c0e7ee2565428.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-AutoTagging
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而如何快速过滤应用呢？这也是一个必须解决的问题，在传统架构中，一般会根据 IP 段或者根据所在服务器来过滤，但是应用架构逐步迁移到云上，开始使用微服务架构后，IP 已经不再稳定，而资源也不再简单是服务器了，这种时候如何来快速过滤应用呢？&lt;/p&gt;
&lt;p&gt;DeepFlow 的 AutoTagging 能力，可以给调用日志打上各种云厂商的标签，比如租户、区域、子网、云服务器、RDS、负载均衡器、NAT 网关、Kubernetes 的命名空间、容器服务、工作负载、动态 Label 等等，有了这些标签，则可以快速的根据各种云标签过滤应用，然后查看应用的调用日志了。&lt;/p&gt;
&lt;p&gt;以上主要和大家分享了应用调用日志背后数据处理的一些理论能力，接下来带大家感受下基于这样的能力，应用调用日志激发的实际价值。&lt;/p&gt;
&lt;h2 id=&#34;0x4-应用调用日志---总览&#34;&gt;0x4: 应用调用日志 - 总览&lt;/h2&gt;
&lt;p&gt;这是基于调用日志构建的一张 Grafana 的 Dashboard，这个 Dashboard 主要可查看服务的调用关系、RED 指标量。Dashboard 就是基于前面数据抽象来实现的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志---总览&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志 - 总览&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b336e43_hu73985a664b86af75f09bb672e135bea5_220972_c129f11a3d97b68e8da7551a07cdcd1d.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b336e43_hu73985a664b86af75f09bb672e135bea5_220972_56f1322dd267c46445aebf7934f9e961.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b336e43_hu73985a664b86af75f09bb672e135bea5_220972_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b336e43_hu73985a664b86af75f09bb672e135bea5_220972_c129f11a3d97b68e8da7551a07cdcd1d.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志 - 总览
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们可以通过 AutoTagging 打上的标签，Dashboard 主要使用 Kubernetes 相关的标签，快速过滤应用，比如 DeepFlow 这个应用，就直接过滤 Namespace=DeepFlow 就可以了。然后结合 Grafana 的一些阈值能力，就可以快速的在视觉找到需要关注的服务，从而缩小问题定位的范围。&lt;/p&gt;
&lt;h2 id=&#34;0x5-应用调用日志-http-访问日志&#34;&gt;0x5: 应用调用日志-HTTP 访问日志&lt;/h2&gt;
&lt;p&gt;接下来看看如何查看 HTTP 的调用日志以及 DeepFlow 平台的调用日志与 AccessLog 的差异。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-http-访问日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-HTTP 访问日志&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b27ffc7_hu2ed6c76f2045dc9d57269867fe2677de_297428_a05a8bc28687a70ad06d3f8c8b9b3bbb.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b27ffc7_hu2ed6c76f2045dc9d57269867fe2677de_297428_b50ebbf34280f4a0aadc3ed101a2380c.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b27ffc7_hu2ed6c76f2045dc9d57269867fe2677de_297428_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b27ffc7_hu2ed6c76f2045dc9d57269867fe2677de_297428_a05a8bc28687a70ad06d3f8c8b9b3bbb.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-HTTP 访问日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;左边是在 Grafana 上构建的应用调用日志的 Dashboard，可根据 TAG 过滤应用，根据 Protocol 过滤 HTTP、HTTPS、HTTP2 协议，即可查看当前服务的 HTTP 的调用日志。&lt;/p&gt;
&lt;p&gt;右边是将 AccessLog 与 DeepFlow 的应用调用日志做的一个映射，通过对比，可看出来除了 remote_user 其他都能映射的非常好。&lt;/p&gt;
&lt;p&gt;HTTP 访问日志除了作为代替 AccessLog，还可以结合调用日志的状态和指标量，快速知道哪些调用存在异常，哪些调用响应慢。&lt;/p&gt;
&lt;h2 id=&#34;0x6-应用调用日志-mysql-慢查询日志&#34;&gt;0x6: 应用调用日志-MySQL 慢查询日志&lt;/h2&gt;
&lt;p&gt;对于 MySQL 慢查询的日志，在云上数据库实例化后，想看数据库的日志，其实并不容易，需要在云上开启各种设置和权限，及时看到了日志，也比较难快速的去过滤对应的应用日志&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-mysql-慢查询日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-MySQL 慢查询日志&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b392aa4_hu1dd9a0e0e977236c02f4bde8be545698_288721_3588dc3e51b0b08162c8f352dad26f6f.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b392aa4_hu1dd9a0e0e977236c02f4bde8be545698_288721_188121ae7c2808a92fae820d7e8ce3c3.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b392aa4_hu1dd9a0e0e977236c02f4bde8be545698_288721_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b392aa4_hu1dd9a0e0e977236c02f4bde8be545698_288721_3588dc3e51b0b08162c8f352dad26f6f.webp&#34;
               width=&#34;760&#34;
               height=&#34;431&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-MySQL 慢查询日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们来看看 DeepFlow 是如何查看慢查询日志的，这个是刚刚 HTTP 调用日志一样的 Dashboard，仅需要切换下搜索条件即可，将协议切换为 MySQL，request_type 输入为 COM_QUREY，以及 request_resource 为 SELECT*。&lt;/p&gt;
&lt;p&gt;设置好这样的过滤条件，得到的就是 MySQL 的查询日志，接着再对响应时延排序过滤，就可以找到慢查询了。&lt;/p&gt;
&lt;h2 id=&#34;0x7-应用调用日志---分布式追踪-span-日志&#34;&gt;0x7: 应用调用日志 - 分布式追踪 Span 日志&lt;/h2&gt;
&lt;p&gt;除了看网络应用协议的调用日志外，通过前面的数据来源我们也知道，调用日志也支持接入分布式追踪协议的 Span 信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志---分布式追踪-span-日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志 - 分布式追踪 Span 日志&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b4dd0dd_hu8954917a1f3a864fea1c9dfa5f36554d_285091_a265f32ed82645e0d3b6b769a09de29d.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b4dd0dd_hu8954917a1f3a864fea1c9dfa5f36554d_285091_b326842fcff6542c014c852071fd55b0.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b4dd0dd_hu8954917a1f3a864fea1c9dfa5f36554d_285091_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b4dd0dd_hu8954917a1f3a864fea1c9dfa5f36554d_285091_a265f32ed82645e0d3b6b769a09de29d.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志 - 分布式追踪 Span 日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;目前 DeepFlow 已经支持对接 OpenTelemtry 的 Span 信息，每个 Span 其实都对应着一个调用，当前展示的就是 Opentelemtry 的一个 Span 日志。&lt;/p&gt;
&lt;p&gt;接入 Span 的信息后，除了可以看日志，根据状态、指标量来定位调用问题外，还有一个重要的目的，就是还可以基于目前 DeepFlow 平台已有的网络中采集的调用和通过 eBPF 采集的调用，进行全栈全链路的追踪。&lt;/p&gt;
&lt;h2 id=&#34;0x8-应用调用日志---全栈全链路追踪&#34;&gt;0x8: 应用调用日志 - 全栈全链路追踪&lt;/h2&gt;
&lt;p&gt;这就是一个最终追踪出来的火焰图，这个火焰图上不仅包含应用代码层面的调用，也包含了系统层面、网络层面，针对如何追踪这个事，由于时间问题，今天就不展开细说，我会利用后续的直播继续给大家详细的去分享，如何对应用进行全栈全链路的追踪。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志---全栈全链路追踪&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志 - 全栈全链路追踪&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b56aa4f_hu38715c143d99c888b78fb82f14682884_218350_375759cd05891ff8bde9292a3cb5c1da.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b56aa4f_hu38715c143d99c888b78fb82f14682884_218350_f53bc734eef25742cf454c20ee3dad87.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b56aa4f_hu38715c143d99c888b78fb82f14682884_218350_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b56aa4f_hu38715c143d99c888b78fb82f14682884_218350_375759cd05891ff8bde9292a3cb5c1da.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志 - 全栈全链路追踪
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;应用调用日志，仅能观测到应用层面的一些问题，DeepFlow 可以通过 FlowID 将应用调用背后的网络流日志关联起来。接下来分享网络流日志能有什么样的能力。&lt;/p&gt;
&lt;h2 id=&#34;0x9-网络流日志---功能定义&#34;&gt;0x9: 网络流日志 - 功能定义&lt;/h2&gt;
&lt;p&gt;先看下公有云对网络流日志的功能说明，这是阿里云的一个定义，是捕获特定位置的流量，将流量转化为流日志记录下来，流日志是记录捕获特定时间窗口的特定五元组的网络流。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络流日志---功能定义&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络流日志 - 功能定义&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b7ac14f_hud31ac83bf14c68ce2a95eabb44714fad_283109_4a26f18817ee8065f4383cec988d1ecb.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b7ac14f_hud31ac83bf14c68ce2a95eabb44714fad_283109_9f449c649d8dc7229fc61ad1f0911d19.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b7ac14f_hud31ac83bf14c68ce2a95eabb44714fad_283109_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b7ac14f_hud31ac83bf14c68ce2a95eabb44714fad_283109_4a26f18817ee8065f4383cec988d1ecb.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络流日志 - 功能定义
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于基础功能的定义，DeepFlow 是有遵循公有云的定义的，并在此基础上还有更丰富的能力。&lt;/p&gt;
&lt;h2 id=&#34;0x10-网络流日志-deepflow-与公有云对比&#34;&gt;0x10: 网络流日志-DeepFlow 与公有云对比&lt;/h2&gt;
&lt;p&gt;接下来看看 DeepFlow 流日志与公有云流日志的对比，解读其中的一些差异点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络流日志-deepflow-与公有云对比&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络流日志-DeepFlow 与公有云对比&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b69ae96_hub776d11c4ef4a59d78ffd4ef4256ef91_276794_f87e584beb7b018c954afa4352c5ac33.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b69ae96_hub776d11c4ef4a59d78ffd4ef4256ef91_276794_a08dcecb330ce48f84b2e1542e72a113.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b69ae96_hub776d11c4ef4a59d78ffd4ef4256ef91_276794_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b69ae96_hub776d11c4ef4a59d78ffd4ef4256ef91_276794_f87e584beb7b018c954afa4352c5ac33.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络流日志-DeepFlow 与公有云对比
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;先看看捕获周期，DeepFlow 的粒度能小到 1 分钟，同时捕获位置 DeepFlow 也更丰富，除了 VPC 网络，也会覆盖到容器网络、物理网络、也能从网络层面扩展到系统层面。&lt;/p&gt;
&lt;p&gt;接着看看 TAG，配合 DeepFlow 的 AutoTagging 的能力，DeepFlow 流日志的 TAG 是远比公有云更丰富的，除了 VPC 网络的一些 Tag，还包含隧道的 Tag、容器网络，以及更丰富的采集位置 Tag。&lt;/p&gt;
&lt;p&gt;接着指标量，公有云仅有 Packet/Byte 这两个，DeepFlow 则覆盖了从网络吞吐到性能，再到时延多个维度。&lt;/p&gt;
&lt;p&gt;在 DeepFlow 的流日志中，增加了流状态字段，可通过此字段快速过滤异常的流，这是目前公有云上不支持的。当然公有云支持的日志状态字段和安全策略的状态，DeepFlow 目前不支持，不过此功能也已经加入到排期中了。&lt;/p&gt;
&lt;p&gt;其次从成本上看，DeepFlow 开源版本可一键部署于自建环境。&lt;/p&gt;
&lt;p&gt;下面我们来看下 DeepFlow 网络流日志功能，具体能解决什么问题。&lt;/p&gt;
&lt;h2 id=&#34;0x11-网络流日志---总览&#34;&gt;0x11: 网络流日志 - 总览&lt;/h2&gt;
&lt;p&gt;这是基于网络流日志构建的 Granafa 的 Dashboard，是可以和应用调用日志一样，查看服务的调用关系，但是和应用调用日志不一样的是，这个总览的 Dashboard 查看的是网络层面的指标量，比如吞吐、重传、建连失败、建连时延等指标数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络流日志---总览&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络流日志 - 总览&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b77ef48_hu7595c3ad527c02976dc24773295be331_231778_608f3c82934bc5439f66a61f4b732e58.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b77ef48_hu7595c3ad527c02976dc24773295be331_231778_2a947f3842415bdc9564038bed381432.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b77ef48_hu7595c3ad527c02976dc24773295be331_231778_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b77ef48_hu7595c3ad527c02976dc24773295be331_231778_608f3c82934bc5439f66a61f4b732e58.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络流日志 - 总览
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;0x12-网络流日志---网络时延&#34;&gt;0x12: 网络流日志 - 网络时延&lt;/h2&gt;
&lt;p&gt;查看应用调用日志时，经常会关注响应时延慢的调用，可这个响应慢，除了应用本身响应慢以外，还可能是 TCP 建连慢，也有可能是数据传输，也可能是协议栈慢，对于网络相关时延的排查，需要查看应用调用对应的流日志来分析。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络流日志---网络时延&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络流日志 - 网络时延&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b8aa56a_hu5c878d95735415f0ccd601fef328ac39_300124_320264425c592f3e9976a38204d1c130.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b8aa56a_hu5c878d95735415f0ccd601fef328ac39_300124_b9514b09f26a55323d94459473a610f3.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b8aa56a_hu5c878d95735415f0ccd601fef328ac39_300124_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b8aa56a_hu5c878d95735415f0ccd601fef328ac39_300124_320264425c592f3e9976a38204d1c130.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络流日志 - 网络时延
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先应用调用日志和网络流日志是如何关联的，DeepFlow 平台上是通过一个 FlowID 来将两个日志进行关联，因此可以根据调用日志的 FlowID，在流日志中进行查找，找到这条调用对应的流日志，然后分析流日志中的建连时延、系统时延和数据传输时延指标量，排查网络时延高导致了应用调用响应慢。&lt;/p&gt;
&lt;h2 id=&#34;0x13-网络流日志---流状态异常日志&#34;&gt;0x13: 网络流日志 - 流状态异常日志&lt;/h2&gt;
&lt;p&gt;应用调用日志是可以根据状态查看异常日志，流日志也是一样，可以对状态进行过滤查看异常的流日志，因此这个时候就能去看看调用异常背后是否因为网络异常导致。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络流日志---流状态异常日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络流日志 - 流状态异常日志&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b91b3ab_hu1484083e5bd2b0b1f8eb3cc220f6d544_359030_c195cd0dcb35ce19b8fda1ca0468ce53.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b91b3ab_hu1484083e5bd2b0b1f8eb3cc220f6d544_359030_af985254138592bb279f8889933fa6b1.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b91b3ab_hu1484083e5bd2b0b1f8eb3cc220f6d544_359030_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b91b3ab_hu1484083e5bd2b0b1f8eb3cc220f6d544_359030_c195cd0dcb35ce19b8fda1ca0468ce53.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络流日志 - 流状态异常日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;右上角给出来了 DeepFlow 流日志里面的状态定义，主要对流结束类型来进行定义，比如建连时延，因为端口复用可关闭，比如传输过程中，服务端发送 RST 报文导致的结束。&lt;/p&gt;
&lt;h2 id=&#34;0x14-网络流日志-tcp-时序日志&#34;&gt;0x14: 网络流日志-TCP 时序日志&lt;/h2&gt;
&lt;p&gt;接下来继续深入的结合 TCP 时序日志，分析具体的包的时延和问题。特别说明下：TCP 时序日志目前是 DeepFlow 企业版的增强功能了，现在开源的版本里面是没有的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络流日志-tcp-时序日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络流日志-TCP 时序日志&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b9aa702_hu6620d721745e2bc484206880f7cac692_166681_25c4ae6ab8c3b9cb808d056806020558.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b9aa702_hu6620d721745e2bc484206880f7cac692_166681_26e981db184fbb97c440fc697b04f862.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b9aa702_hu6620d721745e2bc484206880f7cac692_166681_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b9aa702_hu6620d721745e2bc484206880f7cac692_166681_25c4ae6ab8c3b9cb808d056806020558.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络流日志-TCP 时序日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;用一个&lt;a href=&#34;https://ce-demo.deepflow.yunshan.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;简单的 Demo&lt;/a&gt;，讲解开源的调用日志和流日志功能。这是我们给开源社区搭建的一个 Demo 环境，这个 Demo 环境是基于 Grafana 来构建的，已经构建了很多应用和网络相关的 Dashboard。&lt;/p&gt;
&lt;h2 id=&#34;0x15-autologging-采集&#34;&gt;0x15: AutoLogging-采集&lt;/h2&gt;
&lt;p&gt;接下来从日志采集和日志处理两个方面给大家介绍，AutoLogging 是如何基于 BPF/eBPF 来自动采集日志的。&lt;/p&gt;
&lt;p&gt;首先我们来看看采集部分，采集部需分别从调用日志和流日志两个方面来看。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-autologging-采集--1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;AutoLogging-采集 -1&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479ba66cf7_hu964a485b10aeb05e679e5dc688fd0498_177702_7b30e7ff142d5632232b2847cd74c0dc.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479ba66cf7_hu964a485b10aeb05e679e5dc688fd0498_177702_30ad9b4d122a7a26ea70c35eaa7c6d51.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479ba66cf7_hu964a485b10aeb05e679e5dc688fd0498_177702_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479ba66cf7_hu964a485b10aeb05e679e5dc688fd0498_177702_7b30e7ff142d5632232b2847cd74c0dc.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      AutoLogging-采集 -1
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流日志：流日志通过前面产品介绍可知，是根据网络流量来生成的日志，因此采集则主要集中在网络层面，目前可覆盖物理网络一直到虚拟网络，可以采集宿主机到虚拟机、一直到容器 POD 的网卡的流量，在实现上流日志通过 BPF + AF_PACKET 技术来完成，其中 Windows 系统的采集则通过使用 Winpcap 来完实现的。&lt;/li&gt;
&lt;li&gt;调用日志：调用日志的数据包含两部分数据，一部分是从网络应用协议来的，还有一部分是可观测的 Tracing 数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-autologging-采集--2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;AutoLogging-采集 -2&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479badd87a_hu38a52472946a916ed4da704161460b2c_194444_e09517691e8286eed36e03f35718080c.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479badd87a_hu38a52472946a916ed4da704161460b2c_194444_f296d23d9973e48c3c5258ccea9f78f7.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479badd87a_hu38a52472946a916ed4da704161460b2c_194444_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479badd87a_hu38a52472946a916ed4da704161460b2c_194444_e09517691e8286eed36e03f35718080c.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      AutoLogging-采集 -2
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于网络应用协议这部分的数据，调用日志既包含了网络层面采集的，也扩展到了 Sidecar 和应用进程层面，对于网络层面采集的位置和实现技术与流日志是一致，只是处理逻辑会有一些不一样；而对于 Sidecar 和应用进程层面，则是使用 eBPF 技术来实现的，其中对于非加密和非压缩的协议，则通过 eBPF 的 Kprobe 和 Tracepoints 来完成，而对于 HTTP2、HTTPS 则需要使用 Uprobe 来完成。&lt;/p&gt;
&lt;p&gt;对于 Opentelemetry 的数据接入，是通过 Otel-Collector 将 Traces 的数据发送给 deepflow-agent，就完成了 Tracing 的数据接入。采集的部分先分享到这里，接下来我们看看采集完成后，会进行些什么样的处理。&lt;/p&gt;
&lt;h2 id=&#34;0x16-autologging-处理&#34;&gt;0x16: AutoLogging-处理&lt;/h2&gt;
&lt;p&gt;对于日志的处理，分为三个部分：公共处理部分、流日志处理、调用日志处理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-autologging-处理&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;AutoLogging-处理&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479bb95f59_hube48bc243d22a36b3558d778ad18e82a_149191_64b867ed96a1feeb6e15028e87652dbb.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479bb95f59_hube48bc243d22a36b3558d778ad18e82a_149191_bad0170c2d0f71e18ee8c88105caae45.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479bb95f59_hube48bc243d22a36b3558d778ad18e82a_149191_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479bb95f59_hube48bc243d22a36b3558d778ad18e82a_149191_64b867ed96a1feeb6e15028e87652dbb.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      AutoLogging-处理
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于网络流量的处理可分为：隧道拆解，其中对于隧道拆解，基本主流的隧道协议，都已经支持，比如 Vxlan，IPIP，Gre 等等。隧道拆解完成后，则会按协议栈的顺序依次解析协议，从链路层一直到传输层。&lt;/p&gt;
&lt;p&gt;接着需要对于流量进行 AutoTagging 的预处理，这里主要加上唯一的 Tag，方便后面 Server 根据唯一 Tag 增加全量 Tag。到这步，对于不同的日志需要分开处理了，对于网络流日志，此时可以根据产品定义去生成流日志。&lt;/p&gt;
&lt;p&gt;对应用调用日志，还需要完成应用协议识别，确定具体协议后，再进行应用协议解析，最后才能根据定义生成调用日志。&lt;/p&gt;
&lt;p&gt;对于应用调用日志，除了刚刚分享的这个处理流程，还有另外一条路径，主要是因为应用调用日志不仅包含网络应用协议，还包含 APM 定义的 Tracing 数据，对于这部分数据，可以直接接入，接入后直接解析即可。&lt;/p&gt;
&lt;h2 id=&#34;0x17-应用调用日志---协议扩展&#34;&gt;0x17: 应用调用日志 - 协议扩展&lt;/h2&gt;
&lt;p&gt;额外说下如何扩展一个应用协议。前面一直在说应用调用日志支持接入各种各样的协议，这里大概分享下协议接入需要做一些什么事情。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志---协议扩展&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志 - 协议扩展&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479bc0101a_hu1cfa412e492b07bdfc49801eb287ccc0_393746_79fc661a5cedfd4c8f980dc863c5f2b4.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479bc0101a_hu1cfa412e492b07bdfc49801eb287ccc0_393746_c9037d75451b3d1a5b7c65dad37c5d70.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479bc0101a_hu1cfa412e492b07bdfc49801eb287ccc0_393746_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479bc0101a_hu1cfa412e492b07bdfc49801eb287ccc0_393746_79fc661a5cedfd4c8f980dc863c5f2b4.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志 - 协议扩展
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第一部分：需要解析协议；&lt;/p&gt;
&lt;p&gt;第二部分：协议解析完成后，需要将协议映射到调用日志中；&lt;/p&gt;
&lt;p&gt;第三部分：除了调用日志外，DeepFlow 还提供预聚合数据的能力，对应用 RED 指标进行计算。&lt;/p&gt;
&lt;p&gt;协议扩展要做的事情就是这些，目前 DeepFlow 已经开源，也欢迎开源社区的小伙伴们来贡献更多的协议，让应用调用日志更丰富。&lt;/p&gt;
&lt;h2 id=&#34;0x18总结&#34;&gt;0x18：总结&lt;/h2&gt;
&lt;p&gt;今天的分享主要侧重在框架的讲解，并不涉及太多代码细节，如果大家对实现细节感兴趣的话，可以直接查看 GitHub 上的代码，下方是 DeepFlow GitHub 的链接。&lt;/p&gt;
&lt;p&gt;GitHub 地址：https://github.com/deepflowys/deepflow&lt;/p&gt;
&lt;h2 id=&#34;0x18-未来迭代的方向&#34;&gt;0x18: 未来迭代的方向&lt;/h2&gt;
&lt;p&gt;最后分享下未来 DeepFlow 关于日志的一个迭代方向。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-未来迭代的方向&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;未来迭代的方向&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479bd045b9_hu3f790b01b8fb7c71c2503e4d859493fa_113092_e35b5354cbd1894e2936a20fb38567c8.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479bd045b9_hu3f790b01b8fb7c71c2503e4d859493fa_113092_c446d4248a0839f2535ac9b2141cc1f2.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479bd045b9_hu3f790b01b8fb7c71c2503e4d859493fa_113092_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479bd045b9_hu3f790b01b8fb7c71c2503e4d859493fa_113092_e35b5354cbd1894e2936a20fb38567c8.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      未来迭代的方向
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;目前 DeepFlow 在 Logging 方向上，有 AutoLogging 的能力，后面还会持续做日志集成，会接入 Promtail、Fluentd 等等的数据，并利用 AutoTagging 的能力，注入各种标签，更符合云原生设计理念。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 eBPF 准确定位服务网格的关键性能问题</title>
      <link>https://cloudnative.to/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/</link>
      <pubDate>Tue, 05 Jul 2022 17:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/</guid>
      <description>&lt;h2 id=&#34;background&#34;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;Apache SkyWalking 观察部署在服务网格中的服务的度量、日志、追踪和事件。在进行故障排除时，SkyWalking 错误分析是一个宝贵的工具，可以帮助确定错误发生的位置。然而，确定性能问题更加困难：利用预先存在的观察数据往往不可能找到性能问题的根本原因。为此，动态调试和故障排除在进行服务性能剖析时就必不可少。在这篇文章中，我们将讨论如何使用 eBPF 技术来改进 SkyWalking 中的剖析功能，并用于分析服务网格中的性能影响。&lt;/p&gt;
&lt;h2 id=&#34;trace-profiling-in-skywalking&#34;&gt;SkyWalking 中的追踪剖析&lt;/h2&gt;
&lt;p&gt;自 SkyWalking 7.0.0 以来，Trace Profiling 通过定期对线程堆栈进行采样，让开发者知道运行哪行代码花费更多时间，从而帮助开发者发现性能问题。然而，Trace Profiling 不适合以下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程模型&lt;/strong&gt;：Trace Profiling 对于剖析在单线程中执行的代码最有用。它对严重依赖异步执行模式的中间件不太有用。例如，Go 中的 Goroutines 或 Kotlin Coroutines。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语言&lt;/strong&gt;：目前，Trace Profiling 只支持 Java 和 Python，因为在 Go 和 Node.js 等一些语言的运行时中不容易获得线程栈。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Agent 绑定&lt;/strong&gt;：Trace Profiling 需要安装 Agent，根据语言的不同，这可能很麻烦（例如，PHP 必须依赖其 C 内核；Rust 和 C/C++ 需要的仪器需要手动安装）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关联性&lt;/strong&gt;：由于追踪剖析只与单个请求相关，所以当无法确认哪个请求产生问题时则变得难已处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生命周期短的服务&lt;/strong&gt;：由于（至少）两个原因，Trace Profiling 不支持短声明周期的服务：
&lt;ul&gt;
&lt;li&gt;在启动阶段，很难区分系统性能和类代码操作。&lt;/li&gt;
&lt;li&gt;Trace Profiling 与一个端点相连，以识别性能影响，但没有端点来匹配这些短生命周期的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幸运的是，有一些技术比 Trace Profiling 更实用。&lt;/p&gt;
&lt;h2 id=&#34;introduce-ebpf&#34;&gt;eBPF 简介&lt;/h2&gt;
&lt;p&gt;我们发现，eBPF —— 一种可以在操作系统内核中运行沙盒程序的技术，从而安全有效地扩展内核的功能，而不需要修改内核或加载内核模块，可以帮助我们填补 Trace Profiling 留下的空白。eBPF 技术正在流行，因为它打破了传统上的用户和内核空间之间的障碍。现在我们可以将程序作为字节码注入到内核中运行，而不需要定制和重新编译内核。可观测可以很好地利用这一点。&lt;/p&gt;
&lt;p&gt;在下图中，我们可以看到，当系统执行 &lt;code&gt;execve&lt;/code&gt; 系统调用时，eBPF 程序被触发，通过使用函数调用获得当前进程的运行时信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ebpf-程序调用流程图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;eBPF 程序调用流程图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_31dd29f7e8dc45b4aa8c3e9978c15fd3.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_501ba58999de3fea0b73da4d1a5134c6.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_31dd29f7e8dc45b4aa8c3e9978c15fd3.webp&#34;
               width=&#34;760&#34;
               height=&#34;578&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      eBPF 程序调用流程图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用 eBPF 技术，可以将 SkyWalking 的剖析能力范围扩大到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局性能剖析&lt;/strong&gt;：在 eBPF 之前，数据收集被限制在代理可以观察的范围内。由于 eBPF 程序在内核中运行，它们可以观察到所有的线程。当你不确定某个性能问题是否是由一个特定的请求引起的，这一点特别有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据内容&lt;/strong&gt;：eBPF 可以转储用户和内核空间的线程栈，所以如果性能问题发生在内核空间就更容易被发现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理绑定&lt;/strong&gt;：所有现代 Linux 内核都支持 eBPF，所以不需要安装任何东西。这意味着它是一个免编排与代理的模型。这减少了由内置软件引起的摩擦，这些软件可能没有安装正确的代理，如服务网格中的 Envoy。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;采样类型&lt;/strong&gt;：与追踪剖析不同，eBPF 是事件驱动的，因此，不受间隔轮询的限制。例如，eBPF 可以触发事件，并根据传输大小的阈值收集更多的数据。这可以让系统在极端负载下分流和优先收集数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ebpf-limitations&#34;&gt;eBPF 的局限性&lt;/h3&gt;
&lt;p&gt;虽然 eBPF 为发掘性能瓶颈提供了显著的优势，但没有任何技术是完美的。eBPF 有一些限制，如下所述（幸运的是，由于 SkyWalking 不依赖 eBPF，其影响是有限的）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Linux 版本要求&lt;/strong&gt;：eBPF 程序需要的 Linux 内核版本要 4.4 以上，更新的内核版本可以提供更多的数据收集。BCC 记录了 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/13b5563c11f7722a61a17c6ca0a1a387d2fa7788/docs/kernel-versions.md#main-features&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不同 Linux 内核版本所支持的功能&lt;/a&gt;，不同版本之间的差异在于 eBPF 收集的数据集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要特权权限&lt;/strong&gt;：所有打算将 eBPF 程序加载到 Linux 内核的进程必须在特权模式下运行。因此，代码中的错误或其他问题可能对安全有很大的影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对动态语言的支持较弱&lt;/strong&gt;：eBPF 对基于 JIT 的动态语言，如 Java，支持较弱。这也取决于你想收集什么数据。对于 Profiling，eBPF 不支持解析程序的字符表（symbol），这就是为什么大多数基于 eBPF 的剖析技术只支持静态语言如 C、C++、Go 和 Rust。然而，字符表映射有时可以通过语言所提供的工具来解决。例如，在 Java 中，可以使用 &lt;a href=&#34;https://github.com/jvm-profiling-tools/perf-map-agent#architecture&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;perf-map-agent&lt;/a&gt; 来生成字符表映射。然而，动态语言不支持附加（&lt;code&gt;uprobe&lt;/code&gt;）功能，而这种功能可以让我们通过符号追踪执行事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;introducing-skywalking-rover&#34;&gt;SkyWalking Rover 简介&lt;/h3&gt;
&lt;p&gt;SkyWalking Rover 是 SkyWalking 生态系统中引入的 eBPF 剖析功能。下图显示了 SkyWalking Rover 的整体架构。SkyWalking Rover 目前支持 Kubernetes 环境，必须部署在 Kubernetes 集群内。与 SkyWalking 后端服务器建立连接后，它将当前机器上的进程信息保存到 SkyWalking。当用户通过用户界面创建 eBPF 剖析任务时，SkyWalking Rover 会接收任务并在相关的基于 C、C++、Golang 和 Rust 语言的程序中执行。&lt;/p&gt;
&lt;p&gt;除了需要具有 eBPF 功能的内核外，部署 SkyWalking Rover 没有其他先决条件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-skywalking-rover-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SkyWalking Rover 架构图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_6edef539501f91527785125de04f77d1.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_77630572196fa0d44044c36d67f6e3d2.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_6edef539501f91527785125de04f77d1.webp&#34;
               width=&#34;760&#34;
               height=&#34;259&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SkyWalking Rover 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;cpu-profiling-with-rover&#34;&gt;使用 Rover 进行 CPU 剖析&lt;/h3&gt;
&lt;p&gt;CPU 剖析是显示服务性能的最直观方式。受 &lt;a href=&#34;https://www.brendangregg.com/offcpuanalysis.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Brendan Gregg 的博客文章&lt;/a&gt; 的启发，我们将 CPU 剖析分为两种类型，并在 Rover 中加以实施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU 剖析&lt;/strong&gt;：线程在 CPU 上的运行时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;off-CPU 剖析&lt;/strong&gt;：线程在 I/O、锁、定时器、分页 / 交换等方面被阻塞时的等待时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;profiling-envoy-with-ebpf&#34;&gt;用 eBPF 对 Envoy 进行剖析&lt;/h2&gt;
&lt;p&gt;Envoy 是一个流行的代理，在 Istio 服务网格中被用作为数据平面。在 Kubernetes 集群中，Istio 将 Envoy 作为 sidecar 注入到每个服务的 pod 中，在那里透明地拦截和处理传入和传出的流量。作为数据平面，Envoy 的任何性能问题都会影响到网格中的所有服务流量。在这种情况下，使用 eBPF 剖析来分析生产中由服务网格引起的问题是比较有力的。&lt;/p&gt;
&lt;h3 id=&#34;demo-environment&#34;&gt;演示环境&lt;/h3&gt;
&lt;p&gt;如果你想看到详细过程，我们已经建立了一个演示环境，在那里我们部署了一个 Nginx 服务进行压力测试。流量被 Envoy 拦截并转发到 Nginx。安装整个环境的命令可以在 &lt;a href=&#34;https://github.com/mrproliu/skywalking-rover-profiling-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; 上获取。&lt;/p&gt;
&lt;h2 id=&#34;on-cpu-profiling&#34;&gt;CPU 剖析&lt;/h2&gt;
&lt;p&gt;当服务的 CPU 使用率很高时，CPU 剖析适用于分析线程堆栈。如果堆栈被转储的次数较多，意味着线程堆栈占据了更多的 CPU 资源。&lt;/p&gt;
&lt;p&gt;在使用演示配置文件安装 Istio 时，我们发现有两个地方的性能可以优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Zipkin 追踪&lt;/strong&gt;：不同的 Zipkin 采样百分比对 QPS 有直接影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问日志格式&lt;/strong&gt;：减少 Envoy 访问日志的字段可以提高 QPS。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;zipkin-追踪&#34;&gt;Zipkin 追踪&lt;/h3&gt;
&lt;h3 id=&#34;zipkin-100-采样&#34;&gt;Zipkin 100% 采样&lt;/h3&gt;
&lt;p&gt;在默认的演示配置文件中，Envoy 使用 100% 采样作为默认的追踪策略。这对性能有什么影响？&lt;/p&gt;
&lt;p&gt;如下图所示，使用 CPU 剖析，我们发现它大约需要 &lt;strong&gt;16%&lt;/strong&gt; 的 CPU 开销。在固定消耗 &lt;strong&gt;2 个 CPU&lt;/strong&gt; 的情况下，其 QPS 可以达到 &lt;strong&gt;5.7K&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-zipkin-100-采样-cpu-剖析的火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Zipkin 100% 采样 CPU 剖析的火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_5c5bdd04bcd413ed5927348c85330886.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_b68a53a9b8fc1f02dbfc560074a62481.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_5c5bdd04bcd413ed5927348c85330886.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Zipkin 100% 采样 CPU 剖析的火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;禁用-zipkin-追踪&#34;&gt;禁用 Zipkin 追踪&lt;/h3&gt;
&lt;p&gt;此时，我们发现，如果没有必要，可以降低 Zipkin 采样比例，甚至可以禁用追踪。根据 &lt;a href=&#34;https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#Tracing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 文档&lt;/a&gt;，我们可以在安装 Istio 时使用以下命令禁用追踪。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set &lt;span class=&#34;s1&#34;&gt;&amp;#39;meshConfig.enableTracing=false&amp;#39;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set &lt;span class=&#34;s1&#34;&gt;&amp;#39;meshConfig.defaultConfig.tracing.sampling=0.0&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;禁用追踪后，我们再次进行 CPU 剖析。根据下图，我们发现 Zipkin 已经从火焰图中消失了。在与前面的例子相同的 &lt;strong&gt;2 个 CPU&lt;/strong&gt; 消耗下，QPS 达到 &lt;strong&gt;9K&lt;/strong&gt;，几乎增加了 &lt;strong&gt;60%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-禁用-zipkin-追踪的-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;禁用 Zipkin 追踪的 CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_6ce84d92564a56b7ebc933d9646c9347.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_4120d0c8954a6454493ed53dde25e284.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_6ce84d92564a56b7ebc933d9646c9347.webp&#34;
               width=&#34;760&#34;
               height=&#34;384&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      禁用 Zipkin 追踪的 CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;tracing-with-throughput&#34;&gt;追踪吞吐量&lt;/h3&gt;
&lt;p&gt;在 CPU 使用率相同的情况下，我们发现，当追踪功能被禁用时，Envoy 的性能会大大提升。当然，这需要我们在 Zipkin 收集的样本数量和 Envoy 的预期性能（QPS）之间做出权衡。&lt;/p&gt;
&lt;p&gt;下表说明了在相同的 CPU 使用率下，不同的 Zipkin 采样比例对 QPS 的影响。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Zipkin 采样比例&lt;/th&gt;
&lt;th&gt;QPS&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100% &lt;strong&gt;（默认）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;5.7K&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Zipkin 占用 16%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1%&lt;/td&gt;
&lt;td&gt;8.1K&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Zipkin 占用 0.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;禁用&lt;/td&gt;
&lt;td&gt;9.2K&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Zipkin 占用 0%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;access-log-format&#34;&gt;访问日志格式&lt;/h2&gt;
&lt;h3 id=&#34;default-log-format&#34;&gt;默认访问日志格式&lt;/h3&gt;
&lt;p&gt;在默认的演示配置文件中，默认的访问日志格式包含大量的数据。下面的火焰图显示了在解析数据时涉及的各种功能，如请求头、响应头和流媒体主体。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-默认访问日志格式的-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;默认访问日志格式的 CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_0f5231040d3cb686febbbade6d4f490a.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_ca470e83e66ecbe17169087ebaace536.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_0f5231040d3cb686febbbade6d4f490a.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      默认访问日志格式的 CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;simplifying-access-log-format&#34;&gt;简化访问日志格式&lt;/h3&gt;
&lt;p&gt;通常情况下，我们不需要访问日志中的所有信息，所以我们通常可以简化它来获得我们需要的信息。下面的命令简化了访问日志的格式，只显示基本信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set meshConfig.accessLogFormat&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;[% START_TIME%] \&amp;#34;% REQ (:METHOD)% % REQ (X-ENVOY-ORIGINAL-PATH?:PATH)% % PROTOCOL%\&amp;#34;% RESPONSE_CODE%\n&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;简化访问日志格式后，我们发现 QPS 从 &lt;strong&gt;5.7K&lt;/strong&gt; 增加到 &lt;strong&gt;5.9K&lt;/strong&gt;。当再次执行 CPU 剖析时，日志格式化的 CPU 使用率从 &lt;strong&gt;2.4%&lt;/strong&gt; 下降到 &lt;strong&gt;0.7%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简化日志格式帮助我们提高了性能。&lt;/p&gt;
&lt;h2 id=&#34;off-cpu-剖析&#34;&gt;Off-CPU 剖析&lt;/h2&gt;
&lt;p&gt;Off-CPU 剖析适用于由非高 CPU 使用率引起的性能问题。例如，当一个服务中有太多的线程时，使用 off-CPU 剖析可以揭示出哪些线程花费了更多的时间进行上下文切换。&lt;/p&gt;
&lt;p&gt;我们提供两个维度的数据汇总。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;切换次数&lt;/strong&gt;：一个线程切换上下文的次数。当线程返回到 CPU 时，它完成了一次上下文切换。开关次数较多的线程栈会花费更多时间进行上下文切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;切换持续时间&lt;/strong&gt;：一个线程切换上下文所需的时间。切换持续时间较长的线程栈在 off-CPU 花费的时间较多。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;write-access-log&#34;&gt;写入访问日志&lt;/h3&gt;
&lt;h4 id=&#34;enable-write&#34;&gt;启用写入&lt;/h4&gt;
&lt;p&gt;使用与之前 CPU 测试相同的环境和设置，我们进行了 off-CPU 剖析。如下图所示，我们发现访问日志的写入占总上下文切换的 &lt;strong&gt;28%&lt;/strong&gt; 左右。下图中的 &lt;code&gt;__write&lt;/code&gt; 也表明这是 Linux 内核中的方法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-启用写入的-off-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;启用写入的 off-CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_4f90812f80bcc003b7376d5607177654.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_fea2e2c0d03b286f15392cc50602ab21.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_4f90812f80bcc003b7376d5607177654.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      启用写入的 off-CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;禁用写入&#34;&gt;禁用写入&lt;/h4&gt;
&lt;p&gt;SkyWalking 实现了 Envoy 的访问日志服务（ALS）功能，允许我们使用 gRPC 协议将访问日志发送到 SkyWalking 可观察性分析平台（OAP）。即使禁用访问日志，我们仍然可以使用 ALS 来捕获 / 汇总日志。我们使用以下命令禁用了对访问日志的写入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo --set meshConfig.accessLogFile&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;禁用访问日志功能后，我们进行了 off-CPU 剖析。如下图所示，文件写入条目已经消失了。Envoy 的吞吐量也从 &lt;strong&gt;5.7K&lt;/strong&gt; 增加到 &lt;strong&gt;5.9K&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-禁用访问日志功能后的-off-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;禁用访问日志功能后的 off-CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_5d9c5dc3f590028c1b5386c0232bffb5.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_64a520f1998a1b10dd8b102cdaefebbb.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_5d9c5dc3f590028c1b5386c0232bffb5.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      禁用访问日志功能后的 off-CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇文章中，我们研究了 Apache SkyWalking 的 Trace Profiling 可以给我们带来的启示，以及使用 eBPF 剖析可以实现的更多功能。所有这些功能都在 &lt;a href=&#34;https://github.com/apache/skywalking-rover&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;skywalking-rover&lt;/a&gt; 中实现。除了 CPU 和 off-CPU 剖析之外，你还会发现以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连续剖析&lt;/strong&gt;，帮助你自动剖析，无需人工干预。例如，当 Rover 检测到 CPU 超过一个可配置的阈值时，它会自动执行 CPU 剖析任务。&lt;/li&gt;
&lt;li&gt;更多的剖析类型，以丰富使用场景，如网络和内存剖析。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>一键开启 Kubernetes 可观测性——如何自动生成和存储 OpenTelemetry 追踪</title>
      <link>https://cloudnative.to/blog/generate-and-store-opentelemetry-traces-automatically/</link>
      <pubDate>Mon, 30 May 2022 11:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/generate-and-store-opentelemetry-traces-automatically/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 追踪包含了理解分布式系统和排除故障的信息宝库 —— 但你的服务必须首先被指标化，以发射 OpenTelemetry 追踪来实现这一价值。然后，这些追踪信息需要被发送到一个可观察的后端，使你能够获得关于这些数据的任意问题的答案。可观测性是一个分析问题。&lt;/p&gt;
&lt;p&gt;本周早些时候，我们部分解决了这个问题，宣布&lt;a href=&#34;https://www.timescale.com/blog/observability-powered-by-sql-understand-your-systems-like-never-before-with-opentelemetry-traces-and-postgresql/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Promscale 中普遍提供 OpenTelemetry 追踪支持&lt;/a&gt;，将由 SQL 驱动的可观测性带给所有开发者。随着对分析语言 ——SQL 的全面支持，我们解决了分析的问题。但我们仍然需要解决第一部分的问题：测量。&lt;/p&gt;
&lt;p&gt;为了让你的服务发出追踪数据，你必须手动添加 OpenTelemetry 测量工具到代码中。而且你必须针对所有服务和你使用的所有框架来做，否则你将无法看到每个请求的执行情况。你还需要部署 OpenTelemetry 收集器来接收所有新的追踪，处理它们，批处理它们，并最终将它们发送到你的可观测性后端。这需要花费大量的时间和精力。&lt;/p&gt;
&lt;p&gt;如果你不需要做所有这些手工工作，并且可以在几分钟内而不是几小时甚至几天内启动和运行呢？如果你还能建立一个完整的可观测性技术栈并自动连接所有的组件呢？如果我告诉你，你可以用一个命令完成所有这些工作呢？&lt;/p&gt;
&lt;p&gt;我不是疯子。我只是一个 &lt;a href=&#34;https://docs.timescale.com/promscale/latest/tobs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tobs&lt;/a&gt; 用户😎。&lt;/p&gt;
&lt;p&gt;Tobs 是 Kubernetes 的可观测性技术栈，是一个可以用来&lt;a href=&#34;https://www.timescale.com/blog/introducing-tobs-deploy-a-full-observability-suite-for-kubernetes-in-two-minutes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在几分钟内在 Kubernetes 集群中部署一个完整的可观测性技术栈&lt;/a&gt;的工具。该栈包括 OpenTelemetry Operator、OpenTelemetry Collector、Promscale 和 Grafana。它还部署了其他几个工具，如 Prometheus，以收集 Kubernetes 集群的指标，并将其发送到 Promscale。&lt;a href=&#34;https://github.com/timescale/tobs/releases/tag/0.10.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在我们的最新版本中&lt;/a&gt;，tobs 包括支持通过 OpenTelemetry Operator 用 OpenTelemetry 追踪自动检测你的 Python、Java 和 Node.js 服务。&lt;/p&gt;
&lt;p&gt;是的，你没看错：自动！你不需要改变服务中的任何一行代码，就可以让它们被检测出来。锦上添花的是什么？你可以通过执行 helm 命令来部署一切。&lt;/p&gt;
&lt;p&gt;有了 tobs，你可以安装你的可观测性技术栈，只需几步就能搞定你的 OpenTelemetry 指标化的第一层。告别繁琐的配置工作，因为你的框架会自己检测。&lt;/p&gt;
&lt;p&gt;如果你想了解如何做到这一点，请继续阅读本博文。首先，我们将解释一切是如何运作的，剖析 OpenTelemetry Operator 在内部的真正作用。接下来，我们将通过一个例子演示如何将其直接付诸实践。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们将通过 tobs 在我们的 Kubernetes 集群中安装一个完整的可观测性技术栈。&lt;/li&gt;
&lt;li&gt;我们将部署一个云原生 Python 应用程序。&lt;/li&gt;
&lt;li&gt;我们将检查我们的应用程序是如何被 OpenTelemetry 追踪器自动检测到的，这要归功于 tobs 和 OpenTelemetry Operator 所做的魔术🪄。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;opentelemetry-operator&#34;&gt;OpenTelemetry Operator&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://opentelemetry.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt; 是一个开源的框架，可以捕获、转换和路由所有类型的信号（追踪、日志和指标）。在大多数情况下，你会使用 &lt;a href=&#34;https://open-telemetry.github.io/opentelemetry-js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry SDK&lt;/a&gt; 来在你的应用程序代码中生成这些信号。但是，在某些情况下，OpenTelemetry 可以自动检测你的代码 —— 也就是说，当你的应用框架被支持，并且你使用的语言是 OpenTelemetry 可以注入代码的。在这种情况下，你的系统将开始产生遥测，而不需要手动工作。&lt;/p&gt;
&lt;p&gt;要了解 OpenTelemetry 是如何做到这一点的，我们首先需要熟悉 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Operator&lt;/a&gt;。OpenTelemetry Operator 是一个实现 &lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/operator/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Operator 模式&lt;/a&gt;的应用程序，与 Kubernetes 集群中的两个 CustomResourceDefinitions（CRD）互动。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图示说明-opentelemetry-operator-如何与-kubernetes-互动&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图示说明 OpenTelemetry Operator 如何与 Kubernetes 互动&#34; srcset=&#34;
               /blog/generate-and-store-opentelemetry-traces-automatically/otel-operator-kubernetes_hu9eaea35c1c3da37ce10befac350865f4_54425_89510390ea80e6b60d8a5067819ad3e1.webp 400w,
               /blog/generate-and-store-opentelemetry-traces-automatically/otel-operator-kubernetes_hu9eaea35c1c3da37ce10befac350865f4_54425_67c2a525aead983718379ac249f37412.webp 760w,
               /blog/generate-and-store-opentelemetry-traces-automatically/otel-operator-kubernetes_hu9eaea35c1c3da37ce10befac350865f4_54425_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/generate-and-store-opentelemetry-traces-automatically/otel-operator-kubernetes_hu9eaea35c1c3da37ce10befac350865f4_54425_89510390ea80e6b60d8a5067819ad3e1.webp&#34;
               width=&#34;760&#34;
               height=&#34;481&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图示说明 OpenTelemetry Operator 如何与 Kubernetes 互动
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 CustomResourceDefinitions（CRD&lt;/a&gt;）实例的变化，Operator 为我们管理以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建和删除 OpenTelemetry Collector 实例&lt;/li&gt;
&lt;li&gt;将 OpenTelemetry 自动测量所需的库和二进制文件直接注入到你的 pod 中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们更详细地解读这两项任务。&lt;/p&gt;
&lt;h2 id=&#34;管理-opentelemetry-collector&#34;&gt;管理 OpenTelemetry Collector&lt;/h2&gt;
&lt;p&gt;OpenTelemetry Operator 的首要任务是部署 &lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Collector&lt;/a&gt; 实例。这些实例将被用来把信号从源头（你的工作负载和 Kubernetes 本身）路由到它们的目标（支持 OpenTelemetry 协议的存储系统或集群外的另一个采集器）。&lt;/p&gt;
&lt;p&gt;采集器可以以三种不同的方式部署：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为 Kubernetes Deployment：这是默认选项，它允许采集器根据需要在节点之间移动，支持向上和向下扩展。&lt;/li&gt;
&lt;li&gt;作为 Kubernetes Daemonset：这个选项将在每个节点上部署一个采集器，当你想确保你的信号在没有任何网络开销的情况下被处理时，它可能很有用。&lt;/li&gt;
&lt;li&gt;作为一个 Sidecar：被注入到任何新的注释的 pod 中（使用 &lt;code&gt;sidecar.opentelemetry.io/inject: true&lt;/code&gt;）。当采集器需要一个 pod 的特定配置时，这可能是很好的（例如，也许它需要一些专门的转换）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你愿意，你可以混合和匹配这些收集器模式。例如，你可以设置一个 sidecar，为部署中的 pod 做一些转换，然后将它们发送到一个全局收集器，与你的其他工作负载共享。&lt;/p&gt;
&lt;p&gt;定义这些收集器实例的配置在收集器 CRD（&lt;code&gt;opentelemetrycollectors.opentelemetry.io&lt;/code&gt;）中进行建模。允许多个实例来实现更复杂的模式。部署类型是通过 &lt;code&gt;mode&lt;/code&gt; 设置来选择的，伴随着一个原始的配置字符串，它被逐字传递给控制器，并作为配置加载。下面是使用 Deployment 模式创建 Operator 的 CRD 的例子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;opentelemetry.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;OpenTelemetryCollector&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tobs-tobs-opentelemetry&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    receivers:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      jaeger:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        protocols:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          grpc:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          thrift_http:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      otlp:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        protocols:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          grpc:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          http:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    exporters:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      logging:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      otlp:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        endpoint: &amp;#34;tobs-promscale-connector.default.svc:9202&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        compression: none
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        tls:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          insecure: true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      prometheusremotewrite:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        endpoint: &amp;#34;tobs-promscale-connector.default.svc:9201/write&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        tls:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          insecure: true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    processors:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      batch:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    service:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      pipelines:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        traces:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          receivers: [jaeger, otlp]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          exporters: [logging, otlp]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          processors: [batch]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        metrics:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          receivers: [otlp]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          processors: [batch]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          exporters: [prometheusremotewrite]    &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正如我们在后面的例子中看到的，当你使用 &lt;a href=&#34;https://docs.timescale.com/promscale/latest/tobs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tobs&lt;/a&gt; 时，你不需要担心所有这些配置细节。tobs 的好处之一是它会为你安装一个采集器，它将直接把数据发送到本地的 Promscale 实例。&lt;/p&gt;
&lt;h2 id=&#34;在-kubernetes-中添加-opentelemetry-自动监测系统&#34;&gt;在 Kubernetes 中添加 OpenTelemetry 自动监测系统&lt;/h2&gt;
&lt;p&gt;Operator 的第二个关注点是将 OpenTelemetry 自动测量所需的库和二进制文件注入到 pod 中。要做到这一点，这些 pod 需要容纳 Java、Python 或 Node.js 应用程序（OpenTelemetry 将来会支持更多语言）。&lt;/p&gt;
&lt;p&gt;用于部署这些 pod 的 Kubernetes 清单文件必须包括一个注释，以指示 OpenTelemetry Operator 对其进行检测。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instrumentation.opentelemetry.io/inject-&amp;lt;language&amp;gt;: &amp;#34;true&amp;#34;   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;language&lt;/code&gt; 可以是 &lt;code&gt;python&lt;/code&gt;、&lt;code&gt;java&lt;/code&gt; 或 &lt;code&gt;nodejs&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当注解的 pod 启动时，会创建一个 &lt;code&gt;init&lt;/code&gt; 容器，注入所需的代码并改变 pod 运行代码的方式，使用正确的 OpenTelemetry 自动探测方法。实际上，这意味着在使用 Kubernetes 时，不需要修改任何代码就可以获得自动监测的好处。该配置还定义了 OpenTelemetry Collector 端点，这些追踪将被发送到该端点，传播的信息类型，以及我们用来采样追踪的方法（如果有的话）(关于 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-operator/blob/main/docs/api.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CRD 的全部细节，请看文档&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;为 Python、Java 和 Node.js 应用程序提供自动测量的自定义资源的例子是这样的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;opentelemetry.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Instrumentation&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tobs-auto-instrumentation&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exporter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;endpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http://tobs-opentelemetry-collector.default.svc:4318 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;propagators&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;tracecontext&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;baggage&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;b3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sampler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;argument&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0.25&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;parentbased_traceidratio&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再一次，如果你使用 &lt;a href=&#34;https://docs.timescale.com/promscale/latest/tobs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tobs&lt;/a&gt;，你将不需要自己创建这些自定义资源。Tobs 将确保集群被自动配置成对任何有注释的 pod 进行检测，而不需要你做任何操作。你所需要做的就是在你想收集追踪的 pod 中添加以下注释之一。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instrumentation.opentelemetry.io/inject-java: &amp;#34;true&amp;#34;
instrumentation.opentelemetry.io/inject-nodejs: &amp;#34;true&amp;#34;
instrumentation.opentelemetry.io/inject-python:&amp;#34;true&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;让我们通过一个例子看看这在实践中是如何运作的。&lt;/p&gt;
&lt;h2 id=&#34;使用-opentelemetry-operator-和-tobs&#34;&gt;使用 OpenTelemetry Operator 和 Tobs&lt;/h2&gt;
&lt;p&gt;在本节中，我们将使用我们的&lt;a href=&#34;https://github.com/timescale/opentelemetry-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务演示应用程序&lt;/a&gt;，它由一个过度工程化的密码生成器应用程序组成。&lt;a href=&#34;https://github.com/timescale/opentelemetry-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 repo 中&lt;/a&gt;，你可以找到一个已测量的版本和一个未测量的版本，这就是我们在这个例子中要使用的版本。&lt;/p&gt;
&lt;p&gt;要运行这个，你首先需要一个 Kubernetes 集群，安装了 cert-manager，配置了通过 &lt;code&gt;kubectl&lt;/code&gt;（至少需要 1.21.0 版本）的访问，并安装了 &lt;a href=&#34;https://helm.sh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;helm&lt;/a&gt;。为了部署和运行所有不同的组件，你将需要在你的 Kubernetes 集群中提供大约 4 核 CPU 和 8GB 的内存。&lt;/p&gt;
&lt;p&gt;如果你的集群中没有 cert-manager，你将需要使用这个命令来安装它。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;准备好后，让我们使用 Timescale Helm Chart 来安装 tobs。在命令提示符下运行以下命令。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm repo add timescale https://charts.timescale.com/ --force-update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install --wait --timeout 10m tobs timescale/tobs
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Tobs 需要几分钟的时间来安装，但最终，你会看到类似这样的输出。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#helm install --wait tobs timescale/tobs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME: tobs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;LAST DEPLOYED: Thu May &lt;span class=&#34;m&#34;&gt;19&lt;/span&gt; 11:22:19 &lt;span class=&#34;m&#34;&gt;2022&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAMESPACE: default
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;STATUS: deployed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;REVISION: &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NOTES:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;###############################################################################&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;👋🏽 Welcome to tobs, The Observability Stack &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; Kubernetes
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;✨ Auto-configured and deployed:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🔥 Kube-Prometheus
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🐯 TimescaleDB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🤝 Promscale
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🧐 PromLens
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;📈 Grafana
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🚀 OpenTelemetry
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🎯 Jaeger
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;###################################&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;👉 故障排除提示：如果你得到这个错误信息 &lt;code&gt;INSTALLATION FAILED: rate:Wait(n=1) would exceed context deadline&lt;/code&gt;，这很可能表明你的集群中没有足够的可用资源。&lt;/p&gt;
&lt;p&gt;一旦 tobs 的安装完成，检查你的 Kubernetes 集群，确认所有的组件都已正确部署。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl get podes --all-namespaces &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s2&#34;&gt;&amp;#34;tobs-&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;👉故障排除提示：如果某些 pod 处于待定或错误状态，你可以使用 &lt;code&gt;kubectl describe pod &amp;lt;pod-name&amp;gt;&lt;/code&gt; 或 &lt;code&gt;kubectl logs &amp;lt;pod-name&amp;gt;&lt;/code&gt; 来了解可能存在的问题。&lt;/p&gt;
&lt;p&gt;现在，我们可以从 &lt;a href=&#34;https://github.com/timescale/opentelemetry-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Demo GitHub repo&lt;/a&gt; 中导入未测量的 Kubernetes 微服务。&lt;/p&gt;
&lt;p&gt;如果你回顾一下 &lt;code&gt;uninstrumented&lt;/code&gt; 文件夹中的代码，你会发现它没有提到 OpenTelemetry。例如，看一下 &lt;code&gt;load&lt;/code&gt; 微服务的 Python 文件（这个服务通过发出密码请求来驱动其他服务的流量）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;vm&#34;&gt;__name__&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过将这些微服务导入安装了 tobs 的集群中，它们将自动获得 OpenTelemetry 追踪的测量工具。&lt;/p&gt;
&lt;p&gt;要调出演示应用程序，请运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -k &lt;span class=&#34;s1&#34;&gt;&amp;#39;http://github.com/timescale/opentelemetry-demo/yaml/app&amp;#39;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当这个过程结束，应用程序被部署时，它将已经被 OpenTelemetry 追踪器所记录。追踪现在正在生成并自动发送到 Promscale。&lt;/p&gt;
&lt;p&gt;这种魔法是如何发生的？&lt;/p&gt;
&lt;p&gt;这里有一个总结性的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个 pod 都被注解为 &lt;code&gt;instrumentation.opentelemetry.io/inject-python: &amp;quot;true&amp;quot;&lt;/code&gt;，所以当它们启动时，会被 OpenTelemetry Operator 注意到。&lt;/li&gt;
&lt;li&gt;接下来，使用一个突变的 webhook 添加一个 init 容器，注入 Python 库和启用测量工具所需的代码。&lt;/li&gt;
&lt;li&gt;然后，追踪数据被发送到 Instrumentation CRD 中注明的 OpenTelemetry Collector。&lt;/li&gt;
&lt;li&gt;OpenTelemetry Collector 将数据发送到 Promscale（和 TimescaleDB），从那里可以直接用 SQL 查询或用 Grafana 等工具进行可视化访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们看看我们直接从 Grafana（tobs 也自动安装在我们的集群中）自动生成的追踪。&lt;/p&gt;
&lt;p&gt;要获得 Grafana 实例的管理用户的密码，请运行以下命令。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl get secret tobs-grafana -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.data.admin-password}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; base64 -d 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl port-forward svc/tobs-grafana 3000:80
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，导航到 http://localhost:3000/d/vBhEewLnk，使用你刚刚找回的密码，以管理员用户身份登录。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.timescale.com/promscale/latest/visualize-data/apm-experience/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Promscale 应用性能监控（APM）仪表盘&lt;/a&gt;将显示出来，向你展示关于演示应用的洞察力。Tobs 直接导入这套开箱即用、可用于生产的仪表盘，我们在 Grafana 中使用 SQL 查询对追踪数据进行构建，在这种情况下，它是由演示微服务自动生成的。下图显示了其中一个仪表盘 ——“服务详情”。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-用演示应用程序的追踪数据填充的-服务细节仪表盘&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;用演示应用程序的追踪数据填充的 &amp;lt;a href=&amp;#34;https://docs.timescale.com/promscale/latest/visualize-data/apm-experience/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;服务细节仪表盘&amp;lt;/a&amp;gt;&#34; srcset=&#34;
               /blog/generate-and-store-opentelemetry-traces-automatically/service-overview_hu7b2370ea432b5684d50aba5f5c723790_152700_e987cee28e5586d3309d943b90593978.webp 400w,
               /blog/generate-and-store-opentelemetry-traces-automatically/service-overview_hu7b2370ea432b5684d50aba5f5c723790_152700_38fa9f225f71344d9cc7cadc07a0349a.webp 760w,
               /blog/generate-and-store-opentelemetry-traces-automatically/service-overview_hu7b2370ea432b5684d50aba5f5c723790_152700_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/generate-and-store-opentelemetry-traces-automatically/service-overview_hu7b2370ea432b5684d50aba5f5c723790_152700_e987cee28e5586d3309d943b90593978.webp&#34;
               width=&#34;760&#34;
               height=&#34;390&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      用演示应用程序的追踪数据填充的 &amp;lt;a href=&amp;#34;https://docs.timescale.com/promscale/latest/visualize-data/apm-experience/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;服务细节仪表盘&amp;lt;/a&amp;gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;关于这些预建仪表盘的更多信息，请&lt;a href=&#34;https://www.timescale.com/blog/observability-powered-by-sql-understand-your-systems-like-never-before-with-opentelemetry-traces-and-postgresql/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;查看这篇博文&lt;/a&gt;（导航到“集成到 Grafana 的现代 APM 体验”一节）。&lt;/p&gt;
&lt;p&gt;我们已经得到了所有这些信息，而在任何 Python 服务中都没有测量工具代码。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 追踪从未像现在这样方便。&lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如果你的微服务是用 OpenTelemetry Operator 目前支持的语言之一编写的&lt;/a&gt;，你可以立即开始收集和存储追踪数据，只需要很少的手动工作。你只需采取以下两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/timescale/tobs/blob/master/chart/README.md#install&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Helm 在你的 Kubernetes 集群中安装 tobs&lt;/a&gt;(请注意，你必须使用 Helm 来安装 tobs，才能使这个最新版本发挥作用，而不是使用 CLI)。&lt;/li&gt;
&lt;li&gt;在部署之前，给你想收集追踪数据的微服务 pods 添加&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-operator#opentelemetry-auto-instrumentation-injection&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;注解&lt;/a&gt;（例如 &lt;code&gt;instrumentation.opentelemetry.io/inject-python: &amp;quot;true&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你的微服务将自动被 OpenTelemetry 追踪器检测，你的追踪器将自动存储在 Promscale 中，Promscale 是建立在 PostgreSQL 和 TimescaleDB 上的统一的指标和追踪器的可观测性后端。&lt;/p&gt;
&lt;p&gt;通过 &lt;a href=&#34;https://docs.timescale.com/promscale/latest/visualize-data/apm-experience/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Promscale 预先建立的 APM 仪表盘&lt;/a&gt;，你将立即了解到你的系统性能如何，并且你将能够&lt;a href=&#34;https://www.timescale.com/blog/observability-powered-by-sql-understand-your-systems-like-never-before-with-opentelemetry-traces-and-postgresql/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 SQL 查询你的追踪&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>混沌工程和视觉隐喻的可观测性</title>
      <link>https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/</link>
      <pubDate>Tue, 24 May 2022 10:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/</guid>
      <description>&lt;h2 id=&#34;主要收获&#34;&gt;主要收获&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于现代软件系统来说，可观测性不是关于数学方程。它是关于人类如何与复杂的系统互动并试图理解它们。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;混沌工程利用了可观测性，因为它可以检测到系统稳定状态的偏差。混沌工程借助可观测性可以发现和克服系统的弱点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可观测性依赖于系统所发出的信号，这些信号提供了关于系统行为的原始数据。然而，可观测性不仅受限于这些信号的质量，还受限于这些信号的可视化和解释的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑到混沌工程、可观测性和可视化涉及到人类自我的解释，仪表盘的设计者可能会对这些解释产生偏差，这是一个事实。在这个意义上，视觉隐喻并不能保证我们以正确的方式解释这些数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于视觉隐喻的仪表盘可以提供比经典的可视化更有用的数据。然而，这两种策略都很容易产生偏差；例如，在一项研究中，大多数参与者都注意到，由于显示了糟糕的柱状图和线状图，没有在图中显示出重要的分界点，因此整体结果是有偏差的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自从 Netflix、Slack 和 Linkedin 等领先的技术公司采用混沌工程来抵御生产中的意外中断后，这门学科在近来已经成为主流。在这条道路上，可观测性发挥了关键作用，为工程师们带来了数据和监控的力量，他们现在有了了解自己系统的策略，确定当某些东西发生故障时它们将如何表现，并增加复原力和可靠性。&lt;/p&gt;
&lt;p&gt;混沌工程和可观测性是两个密切相关的学科。根据 Russ Miles 的说法，&amp;quot;可观测性原则将系统变成了可检查和可调试的案发现场，而混沌工程鼓励并利用可观测性，因为它试图帮助预先发现并克服系统的弱点 &amp;quot;。混沌工程鼓励并要求可观测性，因为要自信地执行混沌实验，可观测性必须检测系统何时正常，以及在执行方法实验时如何偏离该稳定状态。见图 1 中的说明。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1-混沌工程和可观测性&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1. 混沌工程和可观测性&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f1_huf280a69d36e74c95041d917268dd5fcf_36322_5d7fb018e0e824d2448996f75ff4f637.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f1_huf280a69d36e74c95041d917268dd5fcf_36322_b2bb9661845b41200cb05c69a2d66c51.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f1_huf280a69d36e74c95041d917268dd5fcf_36322_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f1_huf280a69d36e74c95041d917268dd5fcf_36322_5d7fb018e0e824d2448996f75ff4f637.webp&#34;
               width=&#34;760&#34;
               height=&#34;399&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1. 混沌工程和可观测性
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;学术界和科技界都做出了巨大的努力，为实践混沌工程和可观测性提供了工具。然而，指标的可视化和视觉策略的适当选择仍然是有限的。本文引入了一个新的角色：视觉隐喻。具体来说，它提供了混沌工程和可观测性的概念基础，介绍了市场上可用的可视化技术的现状，并展示了树状图、仪表图、地理图和城市隐喻是如何丰富观察混沌的视觉策略的。&lt;/p&gt;
&lt;h2 id=&#34;混沌工程和可观测性的基础&#34;&gt;混沌工程和可观测性的基础&lt;/h2&gt;
&lt;p&gt;关于混沌工程：混沌、弹性和可靠性是关键的概念，而关于可观测性，当人类想要观察他们的系统时，监控、度量和仪表盘是至关重要的。因此，在深入研究混沌工程和可观测性之间的关系之前，明确这些定义很重要。&lt;/p&gt;
&lt;p&gt;混沌工程根据混沌原理定义为一门在系统上进行实验的学科，以建立对系统在生产中承受动荡条件能力的信心。为了具体解决大规模分布式系统的不确定性，混沌工程提供了一种基于实验的方法，包括四个步骤：第一个步骤包括定义稳定状态，这是系统的一个可测量的输出，表示正常行为。第二步是与假设相关的，它提出了一个改变稳态的后果的句子。有了这个假设，就该引入现实世界的事件，如服务器崩溃或硬盘故障，以证实或反驳这个假设。最后，目标是建立控制组和实验组之间稳定状态的差异分析。&lt;/p&gt;
&lt;p&gt;可观测性是指能够完全理解一个系统。在控制理论中，它被定义为衡量一个系统的内部状态可以从其外部输出的知识中推断出来的程度。特别是在软件工程中，可观测性可以被描述为提出适当的问题、提供正确的答案以及用收集到的数据建立知识的艺术。&lt;/p&gt;
&lt;p&gt;监控与可观测性是不同的，理解两者的区别很重要。监控是关于收集、处理、汇总和显示系统的实时定量数据；而可观测性是关于处理和分析这些数据，让团队主动理解和调试系统的行为。对于现代软件系统来说，可观测性不是关于数学公式。它是关于人们如何与复杂的系统互动并试图理解它们。&lt;/p&gt;
&lt;p&gt;在这个意义上，监控涉及到通过数字读取系统发出的信号，这些数字被命名为度量。指标是一个单一的数字，可以选择附加标签进行分组和搜索，比如查询次数和类型、错误次数和类型、处理时间或服务器寿命。这些数值在仪表盘中被可视化，仪表盘是提供服务核心指标的摘要视图的应用程序。&lt;/p&gt;
&lt;p&gt;传统的仪表盘是建立在折线图、饼图或柱状图上的。考虑到可观测性取决于系统发出的信号以及这些信号被可视化和解释的质量，提供最好的工具和设计是很重要的。如果颜色、图例和比例使用不当，一些可视化可能会对操作者造成限制和困惑。下一节提供了监控和可观测性的技术状况，并更详细地描述了其中的一些限制。&lt;/p&gt;
&lt;h2 id=&#34;监控和可观测性&#34;&gt;监控和可观测性&lt;/h2&gt;
&lt;p&gt;监控和可观测性已经成为工程团队和一般现代数字企业最基本的能力之一，他们希望在他们的解决方案中提供卓越。由于监控和观察系统有很多原因，谷歌记录了四个黄金信号或指标，它们定义了系统健康的含义，是可观测性和监控平台现状的基础。这四个指标描述如下。&lt;/p&gt;
&lt;p&gt;延迟（Latency）是指一个服务为一个请求提供服务所需的时间。它包括由于与数据库或其他关键后端失去连接而触发的 HTTP 500 错误，这些错误可能不会很快得到服务。延迟是一个基本指标，因为慢的错误甚至比快的错误更糟糕。&lt;/p&gt;
&lt;p&gt;流量（Traffic）是衡量对系统的需求有多大。它决定了系统在某一特定时间内从用户或通过服务运行的事务中承受多大的压力。以网络服务为例，这种测量通常是每秒的 HTTP 请求。通过监控应用程序或服务中的真实用户互动和流量，工程团队可以看到系统如何支持需求的变化，以及他们应该如何扩展资源以满足需求。&lt;/p&gt;
&lt;p&gt;错误（Error）与请求失败的比率有关，无论是显性的还是隐性的。根据系统和发生故障的组件，监控错误情况可能会有很大的不同。这就是为什么工程团队需要监控整个系统的错误发生率，但也需要监控单个服务层面的错误发生率的原因。同样重要的是，要优先考虑哪些错误是关键的，哪些错误是不太危险的。&lt;/p&gt;
&lt;p&gt;最后，饱和度（Saturation）是系统对资源利用的信号，如内存、I/O 或 CPU。考虑到许多系统在达到 100% 的利用率之前就会出现性能下降的情况，拥有一个饱和度目标是非常重要的。它允许我们回答这样的问题：服务还有多少容量？什么水平的饱和度能保证客户的服务性能和可用性？&lt;/p&gt;
&lt;h2 id=&#34;用于监控的传统可视化方法&#34;&gt;用于监控的传统可视化方法&lt;/h2&gt;
&lt;p&gt;现在，上一节所述的四个黄金信号是用传统方法监控的，如折线图、柱状图或饼状图。&lt;/p&gt;
&lt;p&gt;如图 2 所示，折线图是将系统的四个黄金信号的行为在时间上可视化的最常用策略。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2-虚构项目中的折线图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 2. 虚构项目中的折线图&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f2_hu88aeb9acab18176e9eb3c67caa5e4d41_26588_a7071667ac1f1e2b91f04ef67672971c.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f2_hu88aeb9acab18176e9eb3c67caa5e4d41_26588_0c8c4496e612c4a2c59bdf77da85218f.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f2_hu88aeb9acab18176e9eb3c67caa5e4d41_26588_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f2_hu88aeb9acab18176e9eb3c67caa5e4d41_26588_a7071667ac1f1e2b91f04ef67672971c.webp&#34;
               width=&#34;760&#34;
               height=&#34;362&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2. 虚构项目中的折线图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;线形图在颜色、图例、轴和系列的标题方面提出了不同的挑战，因为变量会聚、交叉，而且通常会纠缠在一起。如果仪表盘的创建者没有使用适当的视觉资产，这种类型的图形可能会变成最令人困惑的图表之一。&lt;/p&gt;
&lt;p&gt;另一个常见的图表是柱状图，它是用高度或长度与所代表的数值成正比的矩形条来表示分类数据。如图 3 所示，一些云供应商用它们来表示日志的分类数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-3-一个虚构的项目中的柱状图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 3. 一个虚构的项目中的柱状图&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f3_huec1427940dfdc13893b83265e8be3044_20366_f171ab2438faaf52e91c84f8323a02f9.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f3_huec1427940dfdc13893b83265e8be3044_20366_5bb59c44a456b6ffb7869609155d97d6.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f3_huec1427940dfdc13893b83265e8be3044_20366_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f3_huec1427940dfdc13893b83265e8be3044_20366_f171ab2438faaf52e91c84f8323a02f9.webp&#34;
               width=&#34;760&#34;
               height=&#34;315&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3. 一个虚构的项目中的柱状图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，尽管较少使用，饼图是表示和比较数据分布中的比例的一种简单方法。当一个比例占主导地位——一半或四分之三时，它们是最有效的。超过几种颜色的楔形图会在楔形图之间产生同一性，使其难以比较数值。&lt;/p&gt;
&lt;p&gt;考虑到这些局限性，下一节将介绍一种不同的方式来可视化这四个黄金指标。由于本文是关于混沌工程的，这种技术是在报告事件的情况下进行分析的。&lt;/p&gt;
&lt;h2 id=&#34;视觉隐喻作为视觉化混沌的一种建议&#34;&gt;视觉隐喻作为视觉化混沌的一种建议&lt;/h2&gt;
&lt;p&gt;为了克服前面提到的局限性，本文提出了一种新的策略，将生产中的混乱现象可视化。这个建议是基于其他科学领域的一个概念：视觉隐喻。视觉隐喻是一种策略，将一个应用领域的概念和对象映射到一个相似性和类比的系统中。计算机隐喻是交互式视觉对象和模型对象之间同化的基本思想。它的作用是促进对对象的语义的更好理解。一个熟悉的例子可以是在跑车的图片前使用一只豹子，暗示该产品具有速度、力量和耐力等可比性。&lt;/p&gt;
&lt;p&gt;一些例子包括：地图、城市和几何场景，如图 3 所示。该图显示了城市隐喻，这是一种用于可视化程序代码属性的流行方法。许多项目都采用了这种隐喻来可视化软件库的属性，比如说。现有的研究已经被用来用包来映射街区，用建筑来映射类。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-4-一个虚构项目中的城市隐喻来自-这里&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 4. 一个虚构项目中的城市隐喻，来自 &amp;lt;a href=&amp;#34;https://www.researchgate.net/publication/224503826_Visual_Exploration_of_Large-Scale_Evolving_Software&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;这里&amp;lt;/a&amp;gt;&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f4_hu88c9b151cfdb4b13fa315b0869397f32_20182_639d60ca309b4fa0a9f1d6248f19003d.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f4_hu88c9b151cfdb4b13fa315b0869397f32_20182_aa172a266c11157371240586a8a2dc60.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f4_hu88c9b151cfdb4b13fa315b0869397f32_20182_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f4_hu88c9b151cfdb4b13fa315b0869397f32_20182_639d60ca309b4fa0a9f1d6248f19003d.webp&#34;
               width=&#34;500&#34;
               height=&#34;384&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4. 一个虚构项目中的城市隐喻，来自 &amp;lt;a href=&amp;#34;https://www.researchgate.net/publication/224503826_Visual_Exploration_of_Large-Scale_Evolving_Software&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;这里&amp;lt;/a&amp;gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这种情况下，这个隐喻把类表示为建筑物，把包表示为建筑物所处的邻域。建筑物的每个边缘都被用来映射类的属性。&lt;/p&gt;
&lt;h2 id=&#34;提出一个将事件可视化的实验&#34;&gt;提出一个将事件可视化的实验&lt;/h2&gt;
&lt;p&gt;为了确定参与运营活动的工程团队的看法，我们对他们中的 28 人进行了关于传统仪表盘和视觉隐喻的调查。具体来说，他们被问及使用经典仪表盘和视觉隐喻对四个黄金指标（错误、延迟、流量和饱和度）进行可视化的事件。&lt;/p&gt;
&lt;p&gt;这项研究由关于一个事件的具体问题组成，其中提供了两种可视化：一种是传统的图表，另一种是视觉隐喻。对于每一种情况，都分析了每种可视化的价值。在接下来的段落中，将介绍每个问题和分析。&lt;/p&gt;
&lt;p&gt;关于人口统计学，共有 28 名参与者，其背景分布在后端、前端和全栈工程师、软件架构师、数据工程师和网站可靠性工程师。如图 5 所示，参与人数最多的是后端开发工程师。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5-人口统计学数据&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 5. 人口统计学数据&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f5_hud694102797a2daf59095aa51e0491a3e_41428_6fc1f3923bd515b4cb18185818326384.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f5_hud694102797a2daf59095aa51e0491a3e_41428_ca77edf6b3ca05bf5b1d10acd1c83280.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f5_hud694102797a2daf59095aa51e0491a3e_41428_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f5_hud694102797a2daf59095aa51e0491a3e_41428_6fc1f3923bd515b4cb18185818326384.webp&#34;
               width=&#34;760&#34;
               height=&#34;424&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5. 人口统计学数据
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第一个问题是关于 饱和信号。基本上，使用了两个仪表盘——一个折线图和一个城市隐喻来询问五个微服务的状态：&lt;code&gt;ms_authentication&lt;/code&gt;、&lt;code&gt;ms_patients&lt;/code&gt;、&lt;code&gt;ms_payments&lt;/code&gt;、&lt;code&gt;ms_medications&lt;/code&gt; 和 &lt;code&gt;ms_appointments&lt;/code&gt;。这些微服务是一个虚构的医疗系统的一部分。&lt;/p&gt;
&lt;p&gt;具体来说，问题是：使用传统的仪表板（见图 6）和视觉隐喻（见图 7），哪个微服务受到影响？正确答案是 &lt;code&gt;ms_authentication&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-6-传统的折线图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 6. 传统的折线图&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f6_hu5590d6aeee985513de58bd4f08a66814_30036_1ee9e729212ec6cb4d9f654db74dd193.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f6_hu5590d6aeee985513de58bd4f08a66814_30036_13da0e1ea8b702da78230414f4c32386.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f6_hu5590d6aeee985513de58bd4f08a66814_30036_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f6_hu5590d6aeee985513de58bd4f08a66814_30036_1ee9e729212ec6cb4d9f654db74dd193.webp&#34;
               width=&#34;760&#34;
               height=&#34;470&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6. 传统的折线图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-7-可视化的城市比喻&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 7. 可视化的城市比喻&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f7_hu06c9486b33bb5f5571cb6cfa8753345a_53008_849a632ac66913cbb50b1d54977118c9.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f7_hu06c9486b33bb5f5571cb6cfa8753345a_53008_f5caa61c40cac053a9e8748f658fc86b.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f7_hu06c9486b33bb5f5571cb6cfa8753345a_53008_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f7_hu06c9486b33bb5f5571cb6cfa8753345a_53008_849a632ac66913cbb50b1d54977118c9.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7. 可视化的城市比喻
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如图 8 所示，当他们使用视觉隐喻时，一些参与者的答案改变了，选择了正确的答案。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-8-使用传统图表与视觉隐喻的参与者的回答&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 8. 使用传统图表与视觉隐喻的参与者的回答&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f8_hu5bcc871e02eba00554a68ce49cf38a36_18330_ca0ae0f9fd58663980ac08bb34025b9a.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f8_hu5bcc871e02eba00554a68ce49cf38a36_18330_179f3b49e5d007a9cd7dd4c0e446ddbe.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f8_hu5bcc871e02eba00554a68ce49cf38a36_18330_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f8_hu5bcc871e02eba00554a68ce49cf38a36_18330_ca0ae0f9fd58663980ac08bb34025b9a.webp&#34;
               width=&#34;760&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 8. 使用传统图表与视觉隐喻的参与者的回答
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;所有参与者都认为，受 CPU 高利用率影响的微服务是认证。在这种情况下，视觉隐喻比传统的图表更有用，因为图表线很混乱，而且颜色、形状和大小都不好，改变了参与者的看法。&lt;/p&gt;
&lt;p&gt;关于错误信号，我们用经典的柱状图和树状图来要求参与者计算每个微服务的平均错误，如图 9 所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-9-用于可视化误差的传统柱状图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 9. 用于可视化误差的传统柱状图&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f9_hu559d840f31751b1167744030403ab852_30166_971d7e48c9f2a61b10d467821226c341.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f9_hu559d840f31751b1167744030403ab852_30166_b77ff086fff6e5f915ee9a79adec1483.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f9_hu559d840f31751b1167744030403ab852_30166_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f9_hu559d840f31751b1167744030403ab852_30166_971d7e48c9f2a61b10d467821226c341.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 9. 用于可视化误差的传统柱状图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-10-用于可视化错误的可视化树状图隐喻&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 10. 用于可视化错误的可视化树状图隐喻&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f10_hua3195c7c96c70dd3c846b12d78cb14a9_18716_ddc62a921dc2aff3227ae56fdc16329d.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f10_hua3195c7c96c70dd3c846b12d78cb14a9_18716_fb541186e99cf3cc9b08ae4cfe7f652b.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f10_hua3195c7c96c70dd3c846b12d78cb14a9_18716_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f10_hua3195c7c96c70dd3c846b12d78cb14a9_18716_ddc62a921dc2aff3227ae56fdc16329d.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 10. 用于可视化错误的可视化树状图隐喻
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;正确的答案是 &lt;code&gt;ms_appointments&lt;/code&gt;，虽然有些参与者没有选择它，但当他们使用视觉隐喻时，许多人改变了他们的答案。图 11 说明了这一点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-11-参与者使用传统图表与视觉隐喻来可视化错误的答案&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 11. 参与者使用传统图表与视觉隐喻来可视化错误的答案&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f11_hufb52c87f4f746414a891e3a6678ca879_17740_1872b7f97e3073fc67fc96da84d3ebef.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f11_hufb52c87f4f746414a891e3a6678ca879_17740_9eeb70bde9ec5d18ae643d93f31f345f.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f11_hufb52c87f4f746414a891e3a6678ca879_17740_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f11_hufb52c87f4f746414a891e3a6678ca879_17740_1872b7f97e3073fc67fc96da84d3ebef.webp&#34;
               width=&#34;760&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 11. 参与者使用传统图表与视觉隐喻来可视化错误的答案
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;关于流量信号，我们用一个经典的柱状图和一个地理中心的隐喻来询问参与者哪个第三方服务的流量更大。在这种情况下，原有的微服务和新的四个第三方服务：&lt;code&gt;srv_ldap&lt;/code&gt;、&lt;code&gt;srv_goverment&lt;/code&gt;、&lt;code&gt;srv_assurance&lt;/code&gt; 和 &lt;code&gt;srv_authentication&lt;/code&gt; 之间的互动被分析了。图 12 用柱状图显示了这种整合，图 13 用地理中心的隐喻显示了相同的流量值。在这个比喻中，圆圈代表服务和微服务，线条连接它们之间的关系。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-12-用于可视化微服务和第三方服务之间流量的传统柱状图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 12. 用于可视化微服务和第三方服务之间流量的传统柱状图&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f12_hu1e2b96f432e1eb414b09ea0182bcbb6b_16406_6dd60bbb299279159e708431f5278dc5.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f12_hu1e2b96f432e1eb414b09ea0182bcbb6b_16406_5e76b95d1820fd6044312887fa31e2e6.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f12_hu1e2b96f432e1eb414b09ea0182bcbb6b_16406_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f12_hu1e2b96f432e1eb414b09ea0182bcbb6b_16406_6dd60bbb299279159e708431f5278dc5.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 12. 用于可视化微服务和第三方服务之间流量的传统柱状图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-13-用于可视化微服务和第三方服务之间流量的可视化地理中心隐喻&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 13. 用于可视化微服务和第三方服务之间流量的可视化地理中心隐喻&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f13_hua57f5e5c08bf33cf890b28d0bdfb0e25_21180_dd7b9d20afbc634fbd73d38f1b50ac84.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f13_hua57f5e5c08bf33cf890b28d0bdfb0e25_21180_fc95584fa2e09b78c209d0382eebdaa5.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f13_hua57f5e5c08bf33cf890b28d0bdfb0e25_21180_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f13_hua57f5e5c08bf33cf890b28d0bdfb0e25_21180_dd7b9d20afbc634fbd73d38f1b50ac84.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 13. 用于可视化微服务和第三方服务之间流量的可视化地理中心隐喻
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;尽管有线条和大小来代表微服务和第三方服务之间的连接和流量负载，但这个比喻对参与者来说是混乱的。圆圈的大小可能与 &lt;code&gt;srv_ldap&lt;/code&gt; 的最小百分比有关，而 &lt;code&gt;srv_ldap&lt;/code&gt; 是正确的答案，它在饼中由绿色部分表示（见图 14）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-14-参与者使用传统图表与视觉隐喻对微服务和第三方服务之间的流量进行可视化的答案&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 14. 参与者使用传统图表与视觉隐喻对微服务和第三方服务之间的流量进行可视化的答案。&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f14_hu1b3794456f447f451be1b6c121834963_14664_775bfa66179990f0526e69b01cceb5a9.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f14_hu1b3794456f447f451be1b6c121834963_14664_5f79a6e8736454681951a1a343353fde.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f14_hu1b3794456f447f451be1b6c121834963_14664_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f14_hu1b3794456f447f451be1b6c121834963_14664_775bfa66179990f0526e69b01cceb5a9.webp&#34;
               width=&#34;760&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 14. 参与者使用传统图表与视觉隐喻对微服务和第三方服务之间的流量进行可视化的答案。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，我们用柱状图的视觉化和仪表的比喻来分析&lt;strong&gt;延迟信号&lt;/strong&gt;。图 15 和图 16 分别说明了这两种可视化方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-15-用于可视化延迟信号的传统柱状图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 15. 用于可视化延迟信号的传统柱状图。&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f15_hu6c80e74a88a6647574d6d6d203cf39b3_12496_a7a2aa61d99536a844016d68f20d893e.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f15_hu6c80e74a88a6647574d6d6d203cf39b3_12496_4e9ed215760e368102e54b9329ea069e.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f15_hu6c80e74a88a6647574d6d6d203cf39b3_12496_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f15_hu6c80e74a88a6647574d6d6d203cf39b3_12496_a7a2aa61d99536a844016d68f20d893e.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 15. 用于可视化延迟信号的传统柱状图。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-16-用于可视化微服务的延迟的可视化仪表隐喻&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 16. 用于可视化微服务的延迟的可视化仪表隐喻。&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f16_hu4d6fbb306e89aee71862c91585351943_13066_2ca0bbcf6f7b32d0e1594dd7c8ba72ac.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f16_hu4d6fbb306e89aee71862c91585351943_13066_b5edc29fe68b56aa6464afa5dbba7c14.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f16_hu4d6fbb306e89aee71862c91585351943_13066_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f16_hu4d6fbb306e89aee71862c91585351943_13066_2ca0bbcf6f7b32d0e1594dd7c8ba72ac.webp&#34;
               width=&#34;500&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 16. 用于可视化微服务的延迟的可视化仪表隐喻。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于这种情况，这个隐喻肯定没有为参与者提供价值，因为正确的答案是 &lt;code&gt;ms_patients&lt;/code&gt;，这在图 17 中有说明。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-17-参与者使用传统图表与视觉隐喻来可视化微服务和第三方服务之间的延迟的答案&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 17. 参与者使用传统图表与视觉隐喻来可视化微服务和第三方服务之间的延迟的答案。&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f17_huf3269a68215f055f9e1d893057adf56a_15438_e9e4644b5b090d4ff1d18293e733753e.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f17_huf3269a68215f055f9e1d893057adf56a_15438_b34fee8578d57da90b06724ec34cabfd.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f17_huf3269a68215f055f9e1d893057adf56a_15438_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/chaos-engineering-observability-visual-metaphors/f17_huf3269a68215f055f9e1d893057adf56a_15438_e9e4644b5b090d4ff1d18293e733753e.webp&#34;
               width=&#34;760&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 17. 参与者使用传统图表与视觉隐喻来可视化微服务和第三方服务之间的延迟的答案。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;引入视觉隐喻的结论&#34;&gt;引入视觉隐喻的结论&lt;/h2&gt;
&lt;p&gt;混沌的可视化，特别是生产事故的可视化，给专注于可观测性的工业和学术界带来了一些挑战。正如我们在这篇文章中所展示的，由于混沌工程、可观测性和可视化涉及到人与机器的互动，解释中的偏差是一个持续的风险。通过一项研究，28 位工程师回答了与经典仪表盘和视觉隐喻有关的 12 个问题，可以得出结论，可观测性不仅受到这些信号的数量和质量的限制，而且受到这些信号的可视化和解释方式的限制。结论是，视觉隐喻可能比传统的仪表盘表现得更好，然而，由于两者都涉及到人，所以都不能保证操作人员以正确的方式解释事故中的数据。&lt;/p&gt;
&lt;h2 id=&#34;有兴趣了解更多关于混沌工程中的可观测性吗&#34;&gt;有兴趣了解更多关于混沌工程中的可观测性吗？&lt;/h2&gt;
&lt;p&gt;我想推荐这三本书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我的第一个推荐是 Russ Miles 的《&lt;a href=&#34;https://www.humio.com/chaos-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;混沌工程可观测性&lt;/a&gt;》一书。在这本书中，作者演示了如何将你的混沌实验带入系统可观测性的世界。混沌可观测性能够使整个系统的混沌实验实时地浮现、调试和可视化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个很好的参考是 Charity Majors、Liz Fong-Jones 和 George
Miranda 的《&lt;a href=&#34;https://learning.oreilly.com/library/view/observability-engineering/9781492076438/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可观测性工程&lt;/a&gt;》一书，他们在一家名为 Honeycomb 的公司工作，正是专门从事可观测性的工作。我喜欢这本书，因为在书中，可观测性被当作一个工程领域。如你所知，可观测性对于工程、管理和改进复杂的关键业务系统至关重要，所以它应该被视为一门学科，甚至是一个组织内部的角色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，我想提到一本专注于 &lt;a href=&#34;https://www.manning.com/books/chaos-engineering&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;混沌工程&lt;/a&gt; 的参考书。我说的是 Mikolaj
Pawlikowski 的一本实用书，由曼宁公司出版。该书记录了模拟现实生活中的失败的实验室和实际实验。作者通过学习像混沌工程师那样思考，最大限度地发挥了混沌工程的优势，提供了涵盖整个软件领域的例子。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>New Relic 开源 Pixie，其 Kubernetes 原生集群内观察平台</title>
      <link>https://cloudnative.to/blog/new-relic-open-sources-pixie-its-kubernetes-native-in-cluster-observability-platform/</link>
      <pubDate>Thu, 06 May 2021 02:04:05 +0800</pubDate>
      <guid>https://cloudnative.to/blog/new-relic-open-sources-pixie-its-kubernetes-native-in-cluster-observability-platform/</guid>
      <description>&lt;p&gt;本文译自 ZDNet 的文章 &lt;a href=&#34;https://www.zdnet.com/article/new-relic-open-sources-pixie-its-kubernetes-native-in-cluster-observability-platform/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;New Relic open sources Pixie, its Kubernetes-native in-cluster observability platform&lt;/a&gt;，译者&lt;a href=&#34;https://jimmysong.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;宋净超&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;好消息是，云计算、&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 和云原生计算结合在一起，使软件开发比以前更快、更强大。坏消息是，保持对所有这些的关注比以往任何时候都更难。这就是为什么 &lt;a href=&#34;https://newrelic.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;New Relic&lt;/a&gt; 将其 Kubernetes 原生集群内观察平台 &lt;a href=&#34;http://px.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pixie&lt;/a&gt; 作为一个新的开源项目，在 &lt;a href=&#34;https://www.apache.org/licenses/LICENSE-2.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache 2.0 许可&lt;/a&gt;下贡献给&lt;a href=&#34;https://www.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生计算基金会（CNCF）的&lt;/a&gt;原因，这是一个好消息。&lt;/p&gt;
&lt;p&gt;Pixie 是一个新的云原生应用程序的可观察性平台。有了它，开发人员可以通过一个 shell 命令看到他们应用程序的所有指标、事件、日志和追踪。有了 Pixie，你不需要添加度量（instrumentation）代码，设置临时仪表板，或将数据移出集群，就能看到正在发生的事情。这将为你节省宝贵的时间，这样你就可以致力于建立更好的软件，而不是用更好的方法来监控它。&lt;/p&gt;
&lt;p&gt;该程序作为一组 Kubernetes 服务部署在被监控的集群内。简而言之，Pixie 是一个原生的 Kubernetes 程序。它的 Pixie 边缘模块（PEM）被部署为 DaemonSet。在你的集群内，PEM 利用 Pixie 的 &lt;a href=&#34;https://lwn.net/Articles/740157/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 程序来收集网络事务和系统指标，而不需要修改代码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;亚马逊网络服务（AWS）&lt;/a&gt;可观察性服务总经理 Mark Carter 补充说：“有了 &lt;a href=&#34;https://newrelic.com/blog/best-practices/what-is-ebpf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt;，即 Pixie 平台支持的 Linux 中的新度量能力，开发和运维可以利用一种新的可观察性的超级力量。”&lt;/p&gt;
&lt;p&gt;这是非常方便的。正如 New Relic 总裁 Bill Staples 在博客中所说。“这些&lt;a href=&#34;https://newrelic.com/blog/nerd-life/open-source-observability-pixie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生环境&lt;/a&gt;的动态、分布式性质&lt;a href=&#34;https://newrelic.com/blog/nerd-life/open-source-observability-pixie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;带来了一系列新的可观察性挑战&lt;/a&gt;。我们相信开源的、社区驱动是解决这些挑战的最好方法”。因此，通过使用 &lt;a href=&#34;https://opensource.newrelic.com/projects/open-telemetry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 作为度量化标准&lt;/a&gt;，分析和故障排除都变得更加容易。&lt;/p&gt;
&lt;p&gt;Staples 继续说道。“通过一个命令，你可以点亮你的整个云环境并立即获得遥测数据。我们相信所有的开发者都应该获得这种惊人的开发者体验，它可以减少观察的摩擦，节省宝贵的时间以用来开发更好的软件。为了实现这一目标，我们还将 Pixie 的大部分工程资源投入到这个开源项目中。”&lt;/p&gt;
&lt;p&gt;展望未来，New Relic 公司 Pixie 和 New Relic 开源部总经理、最近收购的 &lt;a href=&#34;https://pixielabs.ai/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pixie 实验室&lt;/a&gt;的首席执行官兼联合创始人 Zain Asgar 说，“开源是 New Relic 和 Pixie 的决定性价值，这就是为什么我们正在用 OpenTelemetry 对我们的可观察性产品进行标准化，并正在将 Pixie 作为一个开源项目进行贡献。我们已经亲眼看到了开放治理对开源项目的积极影响，我们期待着通过我们在 CNCF 的 [新] 白金会员资格，在全行业范围内支持这一倡议。”&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/blogs/opensource/gathering-insights-on-kubernetes-applications-services-and-network-traffic-with-pixie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pixie 开源现在也将在 AWS 上运行&lt;/a&gt;，作为 OpenTelemetry 项目的一个安全的、可生产的、由 AWS 支持的发行版。&lt;/p&gt;
&lt;p&gt;CNCF 总经理 Priyanka Sharma 欢迎 New Relic 加入该组织。“我们很高兴欢迎 New Relic 成为白金会员和 Zain Asgar 加入我们的董事会。Zain 和 New Relic 对推进我们的使命和支持我们的社区的承诺将有很大的帮助。我们特别期待着他们在可观察性方面细致入微的专业知识和观点”。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SkyWalking 前端监控的应用</title>
      <link>https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/</link>
      <pubDate>Tue, 13 Apr 2021 18:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/</guid>
      <description>&lt;p&gt;网络应用性能会影响用户的留存率。如果页面加载时间过长，用户就会放弃。所以我们需要监控 Web 应用来了解性能，确保服务稳定、可用、健康。&lt;a href=&#34;https://github.com/apache/skywalking&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache SkyWalking&lt;/a&gt; 是一款专门为云原生和基于容器架构设计的应用性能监控（APM）工具。其 &lt;a href=&#34;https://github.com/apache/skywalking-client-js&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;skywalking-client-js&lt;/a&gt; 是一个轻量级的客户端 JavaScript 异常、性能和追踪库。&lt;/p&gt;
&lt;p&gt;本文介绍了 skywalking-client-js 如何将其监控扩展到浏览器，为 SkyWalking 后端提供性能指标和错误收集。&lt;/p&gt;
&lt;h2 id=&#34;性能指标&#34;&gt;性能指标&lt;/h2&gt;
&lt;p&gt;skywalking-client-js 使用 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Window/performance&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;window.performance&lt;/a&gt; 来收集性能数据。从 MDN 文档来看，性能接口提供了对当前页面的性能相关信息的访问。它是 High Resolution Time API 的一部分，但对 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Performance_Timeline&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Performance Timeline API&lt;/a&gt;、&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Navigation Timing API&lt;/a&gt;、&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;User Timing API&lt;/a&gt; 和 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Resource Timing API&lt;/a&gt; 有所增强。&lt;/p&gt;
&lt;p&gt;在 skywalking-client-js 中，所有的性能指标都是根据 W3C 规范中定义的 &lt;a href=&#34;https://www.w3.org/TR/navigation-timing/?spm=a2c4g.11186623.2.12.2f495c7cmRef8Q#sec-navigation-timing-interface&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Navigation Timing API&lt;/a&gt; 来计算的。我们可以使用 window.performance.timing 属性获得一个描述页面的 PerformanceTiming 对象。PerformanceTiming 接口包含的属性提供了当前页面加载和使用过程中发生的各种事件的性能计时信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3x19976j30oa0bnac9_hu708554f1ea4ecb71366138c0b8f393b1_59423_51012c72c76540fec545aa969c69cfae.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3x19976j30oa0bnac9_hu708554f1ea4ecb71366138c0b8f393b1_59423_45760f4a7e712aef348d2e53886cf3f8.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3x19976j30oa0bnac9_hu708554f1ea4ecb71366138c0b8f393b1_59423_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3x19976j30oa0bnac9_hu708554f1ea4ecb71366138c0b8f393b1_59423_51012c72c76540fec545aa969c69cfae.webp&#34;
               width=&#34;760&#34;
               height=&#34;364&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们把这些属性放在一起看，可以更好地理解 &lt;a href=&#34;https://www.w3.org/TR/navigation-timing/?spm=a2c4g.11186623.2.14.2f495c7cmRef8Q#processing-model&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;W3C&lt;/a&gt; 的下图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3xf13fjj30pc0ff74i_hu8be70fe40f5583b37caadcb179a9445c_69303_5c506981fe66973ad8c680f5360d3cb0.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3xf13fjj30pc0ff74i_hu8be70fe40f5583b37caadcb179a9445c_69303_eb1c31bad89b9dbd0be0573371aae41f.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3xf13fjj30pc0ff74i_hu8be70fe40f5583b37caadcb179a9445c_69303_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3xf13fjj30pc0ff74i_hu8be70fe40f5583b37caadcb179a9445c_69303_5c506981fe66973ad8c680f5360d3cb0.webp&#34;
               width=&#34;760&#34;
               height=&#34;463&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;下表包含了 skywalking-client-js 的性能指标。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Metrics 名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;计算公式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redirectTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Page redirection time&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redirectEnd – redirectStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;If the current document and the document that is redirected to are not from the same &lt;a href=&#34;http://tools.ietf.org/html/rfc6454&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;origin&lt;/a&gt;, set redirectStart, redirectEnd to 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ttfbTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to First Byte&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseStart – requestStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;According to &lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/network/reference?spm=a2c4g.11186623.2.16.2f495c7cmRef8Q#timing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Development&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dnsTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to DNS query&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domainLookupEnd – domainLookupStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;tcpTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to TCP link&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connectEnd – connectStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;transTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to content transfer&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseEnd – responseStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sslTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to SSL secure connection&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connectEnd – secureConnectionStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Only supports HTTPS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;resTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to resource loading&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;loadEventStart – domContentLoadedEventEnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Represents a synchronized load resource in pages&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fmpTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to First Meaningful Paint&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Listen for changes in page elements. Traverse each new element, and calculate the total score of these elements. If the element is visible, the score is 1 * weight; if the element is not visible, the score is 0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domAnalysisTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to DOM analysis&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domInteractive – responseEnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fptTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;First Paint Time&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseEnd – fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domReadyTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to DOM ready&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domContentLoadedEventEnd – fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;loadPageTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Page full load time&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;loadEventStart – fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ttlTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to interact&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domInteractive – fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;firstPackTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to first package&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseStart – domainLookupStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;skywalking-client-js 收集这些性能指标，并发送给 &lt;a href=&#34;https://skywalking.apache.org/docs/main/latest/en/concepts-and-designs/backend-overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAP（Observability Analysis Platform）服务器&lt;/a&gt;，服务器在后台汇总数据，然后在 UI 端以可视化的方式展示出来。用户可以根据这些数据来优化页面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3yjrgk5j30q90abwfa_hu7752a5019a0f42994e1e7751581b151c_45725_e241d475e3713dc110fc3409794967c3.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3yjrgk5j30q90abwfa_hu7752a5019a0f42994e1e7751581b151c_45725_4eef79b7fe01f30a65c0a83e52a2013c.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3yjrgk5j30q90abwfa_hu7752a5019a0f42994e1e7751581b151c_45725_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3yjrgk5j30q90abwfa_hu7752a5019a0f42994e1e7751581b151c_45725_e241d475e3713dc110fc3409794967c3.webp&#34;
               width=&#34;760&#34;
               height=&#34;298&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;异常指标&#34;&gt;异常指标&lt;/h2&gt;
&lt;p&gt;在 skywalking-client-js 中可以捕捉到五种错误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;window.addeventlistener (&#39;error &#39;, callback, true)&lt;/code&gt; 捕捉资源加载错误。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;window.onerror&lt;/code&gt; 抓取 JS 执行错误。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;window.addEventListener (&#39;unhandledrejection&#39;, callback)&lt;/code&gt; 用来捕捉 Promise 错误。&lt;/li&gt;
&lt;li&gt;Vue 错误由 &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; 捕获。&lt;/li&gt;
&lt;li&gt;Ajax 错误由 &lt;code&gt;addEventListener (&#39;error&#39;，callback);addEventListener (&#39;abort&#39;，callback);addEventListener (&#39;timeout&#39;，callback);&lt;/code&gt; 在 send callback 中捕获。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;skywalking-client-js 将错误数据追踪到 OAP 服务器，最后在 UI 端将数据可视化呈现。对于 App 的错误概况，有几个指标可以进行基本的统计和错误的趋势，包括以下指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;App Error Count，选定时间段内的错误总数。&lt;/li&gt;
&lt;li&gt;App JS 错误率，选定时间段内有 JS 错误的 PV 占总 PV 的比例。&lt;/li&gt;
&lt;li&gt;All of Apps Error Count，Top N Apps 错误数排名。&lt;/li&gt;
&lt;li&gt;All of Apps JS Error Rate，前 N 个 Apps JS 错误率排名。&lt;/li&gt;
&lt;li&gt;所选 App 中的版本错误数，所选 App 中的版本错误数排名前 N 名。&lt;/li&gt;
&lt;li&gt;所选 App 中的版本错误率，所选 App 中的版本错误率排名前 N 名 JS 错误率排名。&lt;/li&gt;
&lt;li&gt;所选 App 的出错率，所选 App 的出错率排名前 N 名。&lt;/li&gt;
&lt;li&gt;所选 App 的错误率，所选 App 排名的前 N 个 JS 错误率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3zef9w5j31530rn425_hu5418562cd7ce4ce91c3277e6b10137c7_82998_63a07be9b2fb0e83d3ebbebf01f03f7d.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3zef9w5j31530rn425_hu5418562cd7ce4ce91c3277e6b10137c7_82998_b4bda99a7e1c053dcd4b70b89948053e.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3zef9w5j31530rn425_hu5418562cd7ce4ce91c3277e6b10137c7_82998_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3zef9w5j31530rn425_hu5418562cd7ce4ce91c3277e6b10137c7_82998_63a07be9b2fb0e83d3ebbebf01f03f7d.webp&#34;
               width=&#34;760&#34;
               height=&#34;511&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于页面，我们使用多个指标进行基本统计和错误趋势，包括以下指标。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Top Unstable Pages / Error Rate, Top N Error Count pages of the Selected version ranking.&lt;/li&gt;
&lt;li&gt;Top Unstable Pages / Error Count，Top N Error Count 页面的 Selected 版本排名。&lt;/li&gt;
&lt;li&gt;页面错误数布局，一段时间内不同错误的数据显示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4797f9nj31360jxmyo_hu5e7fb46224a56292f25ed496dbc8e05c_52764_2cba5ea070fa8e7851862a47625c244b.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4797f9nj31360jxmyo_hu5e7fb46224a56292f25ed496dbc8e05c_52764_e20c35d233fd8c370f991c95d5678fde.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4797f9nj31360jxmyo_hu5e7fb46224a56292f25ed496dbc8e05c_52764_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4797f9nj31360jxmyo_hu5e7fb46224a56292f25ed496dbc8e05c_52764_2cba5ea070fa8e7851862a47625c244b.webp&#34;
               width=&#34;760&#34;
               height=&#34;387&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;用户指标&#34;&gt;用户指标&lt;/h2&gt;
&lt;p&gt;SkyWalking 浏览器监控还提供了访客使用被监控网站的指标，如 PV（页面浏览量）、UV（独立访客）、前 N 名 PV（页面浏览量）等。&lt;/p&gt;
&lt;p&gt;在 SPA（单页应用）中，页面只会被刷新一次。传统方法只在页面加载后报告一次 PV，但无法统计每个子页面的 PV，也无法使其他类型的日志按子页面进行汇总。&lt;/p&gt;
&lt;p&gt;SkyWalking 浏览器监控针对 SPA 页面提供了两种处理方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启用 SPA 自动解析。该方法适用于大多数以 URL 哈希为路由的单页应用场景。在初始化配置项中，将 enableSPA 设置为 true，将开启页面的哈希变化事件监听器（触发重报 PV），在其他数据报送中使用 URL 哈希作为页面字段。&lt;/li&gt;
&lt;li&gt;手动上报。如果第一种方法无法使用，该方法可以用于所有单页应用场景。下面的例子提供了一个设置页面的方法，当数据上报时，可以手动更新页面名称。调用此方法时，页面 PV 将被默认重新上报：&lt;a href=&#34;https://gist.github.com/Fine0830/53d36508671882e210d7fca861555ce9%e3%80%82&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://gist.github.com/Fine0830/53d36508671882e210d7fca861555ce9。&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们来看看下图中的结果。它显示了最受欢迎的应用和版本，以及一段时间内 PV 的变化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4820dzsj30du0n975k_huf3ed6293ce16a3b6ac01d85e84b15009_40590_27c09821f194cd4d083d3f0c5d933b3a.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4820dzsj30du0n975k_huf3ed6293ce16a3b6ac01d85e84b15009_40590_124bbd6b1d6fd6c3fe18565e0a904729.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4820dzsj30du0n975k_huf3ed6293ce16a3b6ac01d85e84b15009_40590_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4820dzsj30du0n975k_huf3ed6293ce16a3b6ac01d85e84b15009_40590_27c09821f194cd4d083d3f0c5d933b3a.webp&#34;
               width=&#34;452&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;让浏览器成为分布式追踪的起点。&lt;/p&gt;
&lt;p&gt;SkyWalking 浏览器监控拦截 HTTP 请求，追踪段（Segment）和跨度（Span）。它支持追踪以下模式的 HTTP 请求。&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;XMLHttpRequest&lt;/a&gt; 和 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fetch.&lt;/a&gt;。它还支持追踪基于 XMLHttpRequest 和 fetch 的库和工具 —— 如 &lt;a href=&#34;https://github.com/axios/axios&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Axios&lt;/a&gt;、&lt;a href=&#34;https://github.com/visionmedia/superagent&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SuperAgent&lt;/a&gt;、&lt;a href=&#34;https://www.openapis.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenApi&lt;/a&gt; 等。&lt;/p&gt;
&lt;p&gt;我们来看看 SkyWalking 浏览器监控是如何拦截 HTTP 请求的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph48ldgzhj30u00uudo1_huebf77f8b7bffd88304b9915eebf82ea9_119237_cb3a696198a991f5ece02f1dbecab129.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph48ldgzhj30u00uudo1_huebf77f8b7bffd88304b9915eebf82ea9_119237_5ed33c3fc96f28559b44d5c7806ec458.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph48ldgzhj30u00uudo1_huebf77f8b7bffd88304b9915eebf82ea9_119237_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph48ldgzhj30u00uudo1_huebf77f8b7bffd88304b9915eebf82ea9_119237_cb3a696198a991f5ece02f1dbecab129.webp&#34;
               width=&#34;739&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;之后，使用 &lt;code&gt;window.addEventListener (&#39;xhrReadyStateChange&#39;, callback)&lt;/code&gt;，在请求头中设置 sw8=xxxx。同时，向后端报告请求信息。最后，我们可以在追踪页面上查看追踪数据。下图展示的追踪页面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49850myj30po0fsaas_hu6e60e6a10a05b51460f900a3e7e1ec26_40042_7ab99b17820ebd47e15091055f6c070d.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49850myj30po0fsaas_hu6e60e6a10a05b51460f900a3e7e1ec26_40042_818257dcf33875330b91856cca2b7b85.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49850myj30po0fsaas_hu6e60e6a10a05b51460f900a3e7e1ec26_40042_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49850myj30po0fsaas_hu6e60e6a10a05b51460f900a3e7e1ec26_40042_7ab99b17820ebd47e15091055f6c070d.webp&#34;
               width=&#34;760&#34;
               height=&#34;467&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了了解我们是如何监听 fetch 请求的，我们来看看 &lt;a href=&#34;https://github.com/github/fetch/blob/90fb680c1f50181782f276122c1b1115535b1603/fetch.js#L506&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fetch&lt;/a&gt; 的源码。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49lzy3wj30v40sq0xk_hud6ffa6e8b46ac03fe408b45c1b7a92e4_103038_32a6dc4015b8c2cbb7e5b978a8f5fdce.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49lzy3wj30v40sq0xk_hud6ffa6e8b46ac03fe408b45c1b7a92e4_103038_799e21bdebc037a361de2915a442b517.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49lzy3wj30v40sq0xk_hud6ffa6e8b46ac03fe408b45c1b7a92e4_103038_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49lzy3wj30v40sq0xk_hud6ffa6e8b46ac03fe408b45c1b7a92e4_103038_32a6dc4015b8c2cbb7e5b978a8f5fdce.webp&#34;
               width=&#34;760&#34;
               height=&#34;701&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如你所见，它创建了一个 Promise 和一个新的 XMLHttpRequest 对象。由于 fetch 的代码是内置在浏览器中的，它必须先监控代码执行。因此，当我们添加监听事件时，我们无法监控 fetch 中的代码。只是在监控完代码执行后，我们重写一下 fetch： &lt;code&gt;import {fetch} from &#39;whatwg-fetch&#39;; window.fetch = fetch;&lt;/code&gt; 这样，我们就可以通过上面的方法拦截 fetch 请求了。&lt;/p&gt;
&lt;h2 id=&#34;其他资源&#34;&gt;其他资源&lt;/h2&gt;
&lt;p&gt;从 &lt;a href=&#34;https://skywalking.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方网站&lt;/a&gt;、Tetrate &lt;a href=&#34;https://www.tetrate.io/blog/category/open-source/apache-skywalking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt; 以及可免费下载的 &lt;a href=&#34;https://www.tetrate.io/apache-skywalking-ebook-tetrate/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;电子书&lt;/a&gt; 中阅读更多关于 SKyWalking 的内容。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解读：云原生下的可观测性发展方向</title>
      <link>https://cloudnative.to/blog/cloud-native-observability/</link>
      <pubDate>Wed, 06 Jan 2021 10:47:14 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-observability/</guid>
      <description>&lt;p&gt;非常有幸参加了云原生社区 Meetup 北京站，有机会和众多业内的大牛一起讨论云原生相关的技术和应用，本次 Meetup 上我和大家分享了关于云原生下的可观测性相关的议题，相关的视频可以移步《&lt;a href=&#34;https://www.bilibili.com/video/BV1GK411g7dK&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;B 站视频回放：云原生下的可观测性&lt;/a&gt;》回看，本篇文章主要是视频的文字性总结，欢迎大家留言讨论。&lt;/p&gt;
&lt;h2 id=&#34;可观测性的由来&#34;&gt;可观测性的由来&lt;/h2&gt;
&lt;p&gt;可观测性最早来自于电气工程领域，主要原因是随着系统发展的逐步复杂，必须要有一套机制用来了解系统内部的运行状态以便更好的监控和问题修复，为此工程师们设计了很多传感器、仪表盘用于表现系统内部的状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A system is said to be observable if, for any possible evolution of &lt;a href=&#34;https://en.wikipedia.org/wiki/State_space_representation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;state and control vectors&lt;/a&gt;, the current state can be estimated using only the information from outputs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;电气工程发展了上百年，其中各个子领域的可观测性都在进行完善和升级，例如交通工具（汽车 / 飞机等）也算的是可观测性上的集大成者。抛开飞机这种超级工程不谈，一辆可正常上路的小型汽车内部也有上百种的传感器用来检测汽车内 / 外部的各种状态，以便让汽车可以稳定、舒适、安全地的行驶。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsaewyj7j30df07dtdq_hu8a8feee3d8fef820f0e317cc365e1970_36959_ad11dfb84336014208074ed3dade0d0a.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsaewyj7j30df07dtdq_hu8a8feee3d8fef820f0e317cc365e1970_36959_f93639999999d200ce127bff11a51e8d.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsaewyj7j30df07dtdq_hu8a8feee3d8fef820f0e317cc365e1970_36959_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsaewyj7j30df07dtdq_hu8a8feee3d8fef820f0e317cc365e1970_36959_ad11dfb84336014208074ed3dade0d0a.webp&#34;
               width=&#34;483&#34;
               height=&#34;265&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;可观测性的未来&#34;&gt;可观测性的未来&lt;/h2&gt;
&lt;p&gt;随着上百年的发展，电气工程下的可观测性已经不仅仅用来辅助人们进行问题检查和定位问题，我们以汽车工程来看，整个可观测性的发展经历了几个过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;盲目：1886 年 1 月 29 日德国人卡尔・本茨发明了人类史上第一辆汽车，那个时候的汽车仅仅具备行驶的最基础能力，根本没有任何和可观测性相关的事情。&lt;/li&gt;
&lt;li&gt;传感器：随着后来汽车开始正式进入市场，人们需要更好的知道汽车是不是没油了、没水了，因此基础的传感器仪表盘被发明出来。&lt;/li&gt;
&lt;li&gt;告警：为了更好的保证汽车的形式安全性，人们开始使用自检和实时告警系统来主动向驾驶员通知一些异常信息，比如电瓶没电、水温过高、胎压低、刹车片磨损等。&lt;/li&gt;
&lt;li&gt;辅助：虽然告警能够即时发出，但有时候人还是来不及处理或者不想处理，这时候辅助系统就派上了用场，例如定速巡航、主动安全、自主泊车等。这些辅助系统是把传感器 + 自动控制进行结合，能够部分解决驾驶员可能做不到或者不想做的事情。&lt;/li&gt;
&lt;li&gt;自动驾驶：上述这些功能最终还是要人去参与，而自动驾驶可以完全不需要人的参与，直接是可观测性系统 + 控制系统就可以让汽车自动运行起来。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;自动驾驶的核心要素&#34;&gt;自动驾驶的核心要素&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsahom53j315o0lk7uw_hu6f942ff219e6c25b00d4bb88c3e7041d_94233_0ce00fe5182416a02ca3db0f13f1ab2f.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsahom53j315o0lk7uw_hu6f942ff219e6c25b00d4bb88c3e7041d_94233_638f0c11ae68dd5492bf8310852e52ae.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsahom53j315o0lk7uw_hu6f942ff219e6c25b00d4bb88c3e7041d_94233_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsahom53j315o0lk7uw_hu6f942ff219e6c25b00d4bb88c3e7041d_94233_0ce00fe5182416a02ca3db0f13f1ab2f.webp&#34;
               width=&#34;760&#34;
               height=&#34;393&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;作为电气工程上可观测性的巅峰，自动驾驶将汽车获取到的各类内外部数据发挥到极致，总结起来主要有几下几个核心的要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;丰富的数据源：汽车外围遍布多个激光 / 图像雷达，能够实现高帧率、360° 实时观测周围的物体及其状态；内部则能够实时知道当前的车速、车轮角度、胎压等信息，做到知彼知己。&lt;/li&gt;
&lt;li&gt;数据集中化：相对辅助驾驶能力，自动驾驶的一个核心突破是能够将车内外的所有数据集中到一起去处理，真正发挥出数据的价值，而不是每个模块的数据作为孤岛进行独立运作。&lt;/li&gt;
&lt;li&gt;强大算力：集中化的数据也意味着数据量的急剧膨胀，无论哪家自动驾驶背后都有强大的芯片支撑，只有足够的算力才能保证在最短的时间内可以进行足够的计算。&lt;/li&gt;
&lt;li&gt;软件迭代：算力 + 算法构成了智能化的最终目标，然而算法不可能完美无瑕，我们会根据逐渐积累的自动驾驶数据不断进行算法的升级，使软件系统能够不断的升级以获得更佳的自动驾驶效果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;it-系统的可观测性&#34;&gt;IT 系统的可观测性&lt;/h2&gt;
&lt;p&gt;伴随着几十年的发展，IT 系统中的监控、问题排查也逐渐抽象为可观测性工程。在当时，最主流的方式还是使用 Metrics、Logging、Tracing 的组合。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsaecgo3j30is0b4jtd_hudf80931304d03dac5e4ec0ca3cb1831f_37832_97fb749883253680bb1b97d30f6fbc64.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsaecgo3j30is0b4jtd_hudf80931304d03dac5e4ec0ca3cb1831f_37832_19ed975074bb7f75ec825f82cb2396ba.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsaecgo3j30is0b4jtd_hudf80931304d03dac5e4ec0ca3cb1831f_37832_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsaecgo3j30is0b4jtd_hudf80931304d03dac5e4ec0ca3cb1831f_37832_97fb749883253680bb1b97d30f6fbc64.webp&#34;
               width=&#34;676&#34;
               height=&#34;400&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上面这幅图详细大家非常熟悉，这是 Peter Bourgon 在参加完 2017 Distributed Tracing Summit 后发表的一篇博文，简洁扼要地介绍了 Metrics、Tracing、Logging 三者的定义和关系。这三种数据在可观测性中都有各自的发挥空间，每种数据都没办法完全被其他数据代替。&lt;/p&gt;
&lt;p&gt;以 Grafana Loki 中介绍中的一个典型问题排查过程来看：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最开始我们通过各式各样的预设报警发现异常（通常是 Metrics/Logging）&lt;/li&gt;
&lt;li&gt;发现异常后，打开监控大盘查找异常的曲线，并通过各种查询/统计找到异常的模块（Metrics）&lt;/li&gt;
&lt;li&gt;对这个模块以及关联的日志进行查询/统计分析，找到核心的报错信息（Logging）&lt;/li&gt;
&lt;li&gt;最后通过详细的调用链数据定位到引起问题的代码（Tracing）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsabpa1kj31420m8dss_hu06b0141d62e435e81e739e1090d90d22_81919_0a518ea95577e90faaa10367af8854a4.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsabpa1kj31420m8dss_hu06b0141d62e435e81e739e1090d90d22_81919_8cf80b85b148c60ee96043fd46a4c488.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsabpa1kj31420m8dss_hu06b0141d62e435e81e739e1090d90d22_81919_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsabpa1kj31420m8dss_hu06b0141d62e435e81e739e1090d90d22_81919_0a518ea95577e90faaa10367af8854a4.webp&#34;
               width=&#34;760&#34;
               height=&#34;422&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上述例子介绍了如何使用 Metric、Tracing、Logging 去联合排查问题，当然根据不同的场景可以有不同的结合方案，例如简单的系统可以直接通过日志的错误信息去告警并直接定位问题，也可以根据调用链提取的基础指标（Latency、ErrorCode）触发告警。但整体而言，一个具有良好可观测性的系统必须具备上述三种数据。&lt;/p&gt;
&lt;h2 id=&#34;云原生下的可观测性&#34;&gt;云原生下的可观测性&lt;/h2&gt;
&lt;p&gt;云原生带来的不仅仅是应用部署能够部署云上而已，其整个的定义是一套新的 IT 系统架构升级，包括开发模式、系统架构、部署模式、基础设施全套的演进和迭代。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsadyme7j315o0kzwp3_hu2e74c21f00dcd661b457b05f5de0b3f9_73307_14ad367508115e55a5c2684e6a9ceb48.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsadyme7j315o0kzwp3_hu2e74c21f00dcd661b457b05f5de0b3f9_73307_5205070ed607fe6d34a99f4ca6fad8d4.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsadyme7j315o0kzwp3_hu2e74c21f00dcd661b457b05f5de0b3f9_73307_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsadyme7j315o0kzwp3_hu2e74c21f00dcd661b457b05f5de0b3f9_73307_14ad367508115e55a5c2684e6a9ceb48.webp&#34;
               width=&#34;760&#34;
               height=&#34;382&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;效率要求更高：随着 DevOps 模式的普及，规划、开发、测试、交付.. 的效率要求越来越高，而与之带来的问题是需要更加实时的知道此次的发布是否成功，出现了什么问题，问题在哪里，如何快速去解决。&lt;/li&gt;
&lt;li&gt;系统更加复杂：架构从最开始的一体化发展到分层模式，到现在的微服务模式，架构的升级带来了开发效率、发布效率、系统灵活性、鲁棒性等优势，但随之而来系统的复杂度将更高，问题的定位将更加难。&lt;/li&gt;
&lt;li&gt;环境动态性增强：无论是微服务的架构还是容器化的部署模式，带来的一个特性是环境的动态性会增强，每个实例的生命周期会更短，出现问题后往往现场已经被破坏，登录机器排查问题的方式已经不复存在。&lt;/li&gt;
&lt;li&gt;上下游依赖更多：问题的定位最终都会从上下游来排查，在微服务、云、K8s 的环境中，上下游将更加多，包括各类其他业务应用、云上使用的各类产品、各种中间件、K8s 自身、容器运行时、虚拟机等等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;拯救者opentelemetry&#34;&gt;拯救者：OpenTelemetry&lt;/h2&gt;
&lt;p&gt;上述的这些问题相信很多读者都会深有体会，而业界也针对这种情况退出了各类可观测性相关的产品，包括开源、商业化的众多项目。例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Metrics：Zabbix、Nagios、Prometheus、InfluxDB、OpenFalcon、OpenCensus&lt;/li&gt;
&lt;li&gt;Tracing：Jaeger、Zipkin、SkyWalking、OpenTracing、OpenCensus&lt;/li&gt;
&lt;li&gt;Logging：ELK、Splunk、SumoLogic、Loki、Loggly&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsad11dyj30gb08678x_hu1be75c37c967ba4b651099733aae1038_45012_752614dcf142b643a333954a37ffc2d8.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsad11dyj30gb08678x_hu1be75c37c967ba4b651099733aae1038_45012_600898551ebeefe2b7a5734345ae2ab7.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsad11dyj30gb08678x_hu1be75c37c967ba4b651099733aae1038_45012_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsad11dyj30gb08678x_hu1be75c37c967ba4b651099733aae1038_45012_752614dcf142b643a333954a37ffc2d8.webp&#34;
               width=&#34;587&#34;
               height=&#34;294&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;利用这些项目的组合或多或少可以解决针对性的一类或者几类问题，但真正应用起来你会发现各种问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多套方案交织：可能要使用至少 Metrics、Logging、Tracing3 种方案，维护代价巨大&lt;/li&gt;
&lt;li&gt;数据不互通：虽然是同一个业务组件，同一个系统，产生的数据由于在不同的方案中，数据难以互通，无法充分发挥数据价值&lt;/li&gt;
&lt;li&gt;厂商绑定：无论从数据采集、传输、存储、计算、可视化、告警等都可能会被厂商绑定，可观测性系统一旦上线后替换的代价讲巨大无比&lt;/li&gt;
&lt;li&gt;云原生不友好：这些方案其中很多都是针对传统系统的，对于云原生的支持相对较弱，而且方案本身部署和使用代价都很高，不符合“云原生”这种一键部署、开箱即用的使用方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsah5yzmj30wc08gae3_hu34afbc11d3ed2d7a3bb59c62663e4022_34994_a141f44d84fde174e49677a0f56c44b2.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsah5yzmj30wc08gae3_hu34afbc11d3ed2d7a3bb59c62663e4022_34994_e5e04c34a5f7e084483d35561695268b.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsah5yzmj30wc08gae3_hu34afbc11d3ed2d7a3bb59c62663e4022_34994_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsah5yzmj30wc08gae3_hu34afbc11d3ed2d7a3bb59c62663e4022_34994_a141f44d84fde174e49677a0f56c44b2.webp&#34;
               width=&#34;760&#34;
               height=&#34;198&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在此背景下，云原生基金会 CNCF 下诞生了 OpenTelemetry 项目，旨在将 Logging、Tracing、Metrics 三者进行统一，实现数据的互通互操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Create and collect telemetry data from your services and software, then forward them to a variety of analysis tools.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OpenTelemetry 最核心的功能是产生、收集可观测性数据，并支持传输到各种的分析软件中，整体的架构如下图所属，其中 Library 用于产生统一格式的可观测性数据；Collector 用来接收这些数据，并支持把数据传输到各种类型的后端系统。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsafamk9j315o0hx46t_hue7bb9740461e7e5d4f49c52c7dd75b5b_60551_2c522e1159dd3537135fd2491800d293.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsafamk9j315o0hx46t_hue7bb9740461e7e5d4f49c52c7dd75b5b_60551_3519bd08af97871e24744e85c1f15c8e.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsafamk9j315o0hx46t_hue7bb9740461e7e5d4f49c52c7dd75b5b_60551_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsafamk9j315o0hx46t_hue7bb9740461e7e5d4f49c52c7dd75b5b_60551_2c522e1159dd3537135fd2491800d293.webp&#34;
               width=&#34;760&#34;
               height=&#34;327&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OpenTelemetry 给云原生下带来的革命性的进步，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统一协议：OpenTelemetry 为我们带来了 Metric、Tracing、Logging（正在制定中，LogModel 已经定义完毕）的统一标准，三者都有相同的元数据结构，可以轻松实现互相关联&lt;/li&gt;
&lt;li&gt;统一 Agent：使用一个 Agent 即可完成所有可观测性数据的采集和传输，不需要为每个系统都部署各种各样的 Agent，大大降低了系统的资源占用，使整体可观测性系统的架构也变的更加简单&lt;/li&gt;
&lt;li&gt;云原生友好：OpenTelemetry 诞生在 CNCF，对于各类的云原生下的系统支持更加友好，此外目前众多云厂商已经宣布支持 OpenTelemetry，未来云上的使用会更加便捷&lt;/li&gt;
&lt;li&gt;厂商无关：此项目完全中立，不倾向于任何一家厂商，让大家可以有充分的自由来选择 / 更换适合自己的服务提供商，而不需要收到某些厂商的垄断或者绑定&lt;/li&gt;
&lt;li&gt;兼容性：OpenTelemetry 得到了 CNCF 下各种可观测性方案的支持，未来对于 OpenTracing 类、OpenCensus、Prometheus、Fluntd 等都会有非常好的兼容性，可以方便大家无缝迁移到 OpenTelemetry 方案上。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;opentelemetry-限制&#34;&gt;OpenTelemetry 限制&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsafux5gj315o0kv7fz_huf7c7e375f02f9b6fe1b9f5694f00151c_60953_3b1504e72e59d5f2cb2846acc0204a7b.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsafux5gj315o0kv7fz_huf7c7e375f02f9b6fe1b9f5694f00151c_60953_c9359be122080adaa2b31fff3db47095.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsafux5gj315o0kv7fz_huf7c7e375f02f9b6fe1b9f5694f00151c_60953_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsafux5gj315o0kv7fz_huf7c7e375f02f9b6fe1b9f5694f00151c_60953_3b1504e72e59d5f2cb2846acc0204a7b.webp&#34;
               width=&#34;760&#34;
               height=&#34;381&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从上面的分析来看，OpenTelemetry 的定位是作为可观测性的基础设施，解决数据规范与获取的问题，后续部分依赖各个 Vendor 来实现。当然最佳的方式是能够有一个统一的引擎去存储所有的 Metrics、Logging、Tracing，有一个统一的平台去分析、展示、关联这些数据。目前的话还没有一个厂商能够非常好的支持 OpenTelemetry 的统一后端，现在还是需要自己去使用各个厂商的产品来实现。而这个带来的另一个问题是各个数据的关联会更加复杂，还需要去解决每个厂商之间的数据关联性问题。当然这个问题相信在 1-2 年肯定会解决掉，现在有众多厂商开始在努力实现 OpenTelemetry 所有类型数据的统一方案。&lt;/p&gt;
&lt;h2 id=&#34;可观测性的未来方向&#34;&gt;可观测性的未来方向&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsacga6sj30jk07t0yd_hu6e7b47a9d159cfb1dd413197c437080d_44183_c03265a341f8457dcb19dd28ae0776a6.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsacga6sj30jk07t0yd_hu6e7b47a9d159cfb1dd413197c437080d_44183_8868cf0ff025c9180184a64d3f3c0adf.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsacga6sj30jk07t0yd_hu6e7b47a9d159cfb1dd413197c437080d_44183_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsacga6sj30jk07t0yd_hu6e7b47a9d159cfb1dd413197c437080d_44183_c03265a341f8457dcb19dd28ae0776a6.webp&#34;
               width=&#34;704&#34;
               height=&#34;281&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们团队从刚开始 09 年做飞天 5K 项目起，就一直在负责监控、日志、分布式链路追踪等可观测性相关的工作，中间经历过小型机到分布式系统再到微服务、云化的一些架构变更，相关的可观测性方案也经历了很多演变。我们觉得整体上可观测性相关的发展和自动驾驶等级的设定非常吻合。&lt;/p&gt;
&lt;p&gt;自动驾驶一共分为 6 级，其中 0-2 级主要还是靠人来进行决定，到了等级 3 之后就可以进行无意识驾驶，也就是手眼可以暂时性不用关注驾驶，到了等级 5 的话人就可以完全脱离驾驶这个枯燥的工作，在车上可以自由活动。&lt;/p&gt;
&lt;p&gt;在 IT 系统的可观测性上，也可以类似划分 6 级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等级 0：手工分析，依靠基础的 Dashboard、告警、日志查询、分布式链路追踪等方式进行手动告警、分析，也是目前绝大部分公司使用的场景&lt;/li&gt;
&lt;li&gt;等级 1：智能告警，能够自动去扫描所有的可观测性数据，利用机器学习的方式去识别一些异常并进行自动告警，免去人工设置 / 调整各种基线告警的工作&lt;/li&gt;
&lt;li&gt;等级 2：异常关联 + 统一视图，对于自动识别的异常，能够进行上下文的关联，形成一个统一的业务视图，便于快速的定位问题&lt;/li&gt;
&lt;li&gt;等级 3：根因分析 + 问题自愈，自动根据异常以及系统的 CMDB 信息直接定位问题的根因，根因定位准确后那边可以去做问题的自愈。这一阶段相当于是一次质的飞跃，在某些场景下可以在人不用参与的情况下实现问题的自愈。&lt;/li&gt;
&lt;li&gt;等级 4：故障预测，故障发生总会有损失，所以最好的情况是避免故障的发生，因此故障预测技术可以更好的来保证系统的可靠性，利用之前积累的一些故障先兆信息做到“未卜先知”&lt;/li&gt;
&lt;li&gt;等级 5：变更影响预测，我们知道绝大部分的故障都是由变更引起的，因此如果能够模拟出每个变更对系统带来的影响以及可能产生的问题，我们就能够提前评估出是否能够允许此次变更。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsadf9k4j315o0dewir_hu1c389544b17c00f1c5300e9a51cb4b30_36225_d22f3a3c007d1eabf02c7798c9a5af64.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsadf9k4j315o0dewir_hu1c389544b17c00f1c5300e9a51cb4b30_36225_d132d88dd3046183bcded24f166e4681.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsadf9k4j315o0dewir_hu1c389544b17c00f1c5300e9a51cb4b30_36225_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsadf9k4j315o0dewir_hu1c389544b17c00f1c5300e9a51cb4b30_36225_d22f3a3c007d1eabf02c7798c9a5af64.webp&#34;
               width=&#34;760&#34;
               height=&#34;244&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;阿里云-sls-在可观测性相关的工作&#34;&gt;阿里云 SLS 在可观测性相关的工作&lt;/h2&gt;
&lt;p&gt;目前我们 SLS 正在开展云原生可观测性的工作，基于 OpenTelemetry 这个未来云原生下可观测性的标准，实现各类可观测性数据的统一收集，覆盖各个数据源和各类数据类型，做到多语言支持、多设备支持、类型统一；向上我们会提供能够支持各类可观测性数据的统一存储和计算能力，支持 PB 级存储、ETL、流计算、百亿级数据秒级分析，为上层算法提供强大的算力支撑；IT 系统的问题非常复杂，尤其涉及到不同的场景和架构，因此我们把算法和经验结合起来进行异常的分析，算法包括基础的统计学、逻辑性算法，也包括 AIOp 相关的算法，经验中包括人工输入的专家知识、网上上积累的各类问题解决方案以及外部产生的一些事件；最上层我们会提供一些辅助决策的功能，例如告警通知、数据可视化、Webhook 等，此外会提供丰富的外部集成能力，例如对接三方的可视化 / 分析 / 告警系统，提供 OpenAPI 以便不同的应用方集成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsagsxmij315o0n0dzu_hu8e7675f7d0e0e841cbbed0d62cf38cf8_111438_bd339c7262bb76082bff3b88822e7d55.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsagsxmij315o0n0dzu_hu8e7675f7d0e0e841cbbed0d62cf38cf8_111438_ded57e3ab854b647fd2a24caa87efdb4.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsagsxmij315o0n0dzu_hu8e7675f7d0e0e841cbbed0d62cf38cf8_111438_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsagsxmij315o0n0dzu_hu8e7675f7d0e0e841cbbed0d62cf38cf8_111438_bd339c7262bb76082bff3b88822e7d55.webp&#34;
               width=&#34;760&#34;
               height=&#34;420&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;作为 CNCF 下除了 Kubernetes 外最活跃的项目，OpenTelemetry 受到了各大云厂商以及相关解决方案公司的关注，相信未来一定会成为云原生下可观测性的标准。虽然目前还没有到生产可用的程度，但是目前各个语言的 SDK 和 Collector 也基本上稳定，在 2021 年就能够发布生产可用的版本，值得大家期待。&lt;/p&gt;
&lt;p&gt;而 OpenTelemetry 只是定义了可观察的前半部分，后面还有非常多的复杂工作需要我们去实现，任重道远。&lt;/p&gt;
&lt;p&gt;重点来了！！！！SLS 团队长期招聘人才，欢迎对大数据、监控、可观测性、前端可视化、移动端开发、机器学习等有兴趣的同学前来联系我：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邮箱：davidzhang.zc@alibaba-inc.com&lt;/li&gt;
&lt;li&gt;微信：davidzhang-zc。&lt;/li&gt;
&lt;li&gt;职位：https://cloudnative.to/job/aliyun-sls-observability/&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://opentelemetry.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://opentelemetry.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.aliyun.com/article/766070&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://developer.aliyun.com/article/766070&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aiopsworkshop.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://aiopsworkshop.github.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://landscape.cncf.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.instana.com/blog/observability-vs-monitoring/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.instana.com/blog/observability-vs-monitoring/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
