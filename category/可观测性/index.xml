<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>可观测性 | 云原生社区（中国）</title>
    <link>https://cloudnative.to/category/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link>
      <atom:link href="https://cloudnative.to/category/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/index.xml" rel="self" type="application/rss+xml" />
    <description>可观测性</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Fri, 02 Dec 2022 10:31:33 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>可观测性</title>
      <link>https://cloudnative.to/category/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link>
    </image>
    
    <item>
      <title>SkyWalking 基于 ShardingSphere-Proxy 的 MySQL-Sharding 分库分表的存储特性介绍</title>
      <link>https://cloudnative.to/blog/skywalking-shardingsphere-proxy/</link>
      <pubDate>Fri, 02 Dec 2022 10:31:33 +0800</pubDate>
      <guid>https://cloudnative.to/blog/skywalking-shardingsphere-proxy/</guid>
      <description>&lt;p&gt;Apache SkyWalking 作为一个分布式系统的应用性能监控工具，它观察服务网格中的指标、日志、痕迹和事件。其中 SkyWalking OAP 高性能的数据流处理架构能够实时处理庞大的数据流量，但是这些海量数据的存储更新和后续查询对后端存储系统带来了挑战。&lt;/p&gt;
&lt;p&gt;SkyWalking 默认已经提供了多种存储支持包括 H2、OpenSearch、ElasticSearch、MySQL、TiDB、PostgreSQL、BanyanDB。其中 MySQL 存储提供的是针对单机和单表的存储方式（MySQL 的集群能力需要自己选型提供），在面对高流量的业务系统时，监控数据的存储存在较大压力，同时影响查询性能。&lt;/p&gt;
&lt;p&gt;在 MySQL 存储基础上 SkyWalking v9.3.0 提供了一种新的存储方式 MySQL-Sharding，它提供了基于 &lt;a href=&#34;https://shardingsphere.apache.org/document/5.1.2/cn/quick-start/shardingsphere-proxy-quick-start/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ShardingSphere-Proxy&lt;/a&gt; 的分库分表特性，而分库分表是关系型数据库面对大数据量处理的成熟解决方案。&lt;/p&gt;
&lt;h2 id=&#34;部署架构&#34;&gt;部署架构&lt;/h2&gt;
&lt;p&gt;SkyWalking 使用 ShardingSphere-Proxy 的部署方式如下图所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-部署架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;部署架构&#34; srcset=&#34;
               /blog/skywalking-shardingsphere-proxy/arch_hu7d8f1c5e4bb80e3fa384080695a3c792_29133_fa695afd2cc55fc2e40f0b86f8250975.webp 400w,
               /blog/skywalking-shardingsphere-proxy/arch_hu7d8f1c5e4bb80e3fa384080695a3c792_29133_1c4bbe8f7d4dd8ff0688df71737bb18a.webp 760w,
               /blog/skywalking-shardingsphere-proxy/arch_hu7d8f1c5e4bb80e3fa384080695a3c792_29133_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/skywalking-shardingsphere-proxy/arch_hu7d8f1c5e4bb80e3fa384080695a3c792_29133_fa695afd2cc55fc2e40f0b86f8250975.webp&#34;
               width=&#34;463&#34;
               height=&#34;403&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      部署架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SkyWalking OAP 由直连数据库的方式变成只与 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ShardingSphere-Proxy&lt;/a&gt; 进行交互；&lt;/li&gt;
&lt;li&gt;每一个 MySQL 节点暴露的连接都是一个数据源，由 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ShardingSphere-Proxy&lt;/a&gt; 进行统一管理；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ShardingSphere-Proxy&lt;/a&gt; 会根据配置建立一个虚拟逻辑数据库，根据 OAP 提供的分库分表规则进行库表分片和路由；&lt;/li&gt;
&lt;li&gt;SkyWalking OAP 负责生成分库分表规则并且像操作 MySQL 一样对虚拟逻辑库执行 DDL 和 DML；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;适用场景&#34;&gt;适用场景&lt;/h2&gt;
&lt;p&gt;希望使用 MySQL 作为存储，随着业务规模的增长，单表模式已经无法满足性能需要。&lt;/p&gt;
&lt;h2 id=&#34;skywalking-分库分表逻辑&#34;&gt;SkyWalking 分库分表逻辑&lt;/h2&gt;
&lt;p&gt;分库分表逻辑通过注解 &lt;code&gt;@SQLDatabase.Sharding&lt;/code&gt; 对 SkyWalking 中的数据模型 Model 进行定义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@interface&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Sharding&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;ShardingAlgorithm&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;shardingAlgorithm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;dataSourceShardingColumn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;default&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tableShardingColumn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;default&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shardingAlgorithm&lt;/code&gt;：表分片算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dataSourceShardingColumn&lt;/code&gt;：分库键&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tableShardingColumn&lt;/code&gt;：分表键&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SkyWalking 根据注解 &lt;code&gt;@SQLDatabase.Sharding&lt;/code&gt; 选择分库键、分表键以及表分片算法对每个表动态生成分片规则通过 DistSQL 操作 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy&lt;/a&gt; 执行规则定义 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy&lt;/a&gt; 根据规则定义进行数据分片。&lt;/p&gt;
&lt;h3 id=&#34;分库方式&#34;&gt;分库方式&lt;/h3&gt;
&lt;p&gt;SkyWalking 对于分库采用统一的方式，路由目标库的数字后缀使用分库键的哈希值取模需要分库的数据库数量，所以路由目标库为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ds_{dataSourceShardingColumn.hashcode() % dataSourceList.size()}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如我们有 &lt;code&gt;dataSourceList = ds_0...ds_n&lt;/code&gt;，如果&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{dataSourceShardingColumn.hashcode() % dataSourceList.size() = 2}&lt;/code&gt; 那么所有数据将会路由到 &lt;code&gt;ds_2&lt;/code&gt; 这个数据源节点上。&lt;/p&gt;
&lt;h3 id=&#34;分表方式&#34;&gt;分表方式&lt;/h3&gt;
&lt;p&gt;由于 TTL 机制的存在，分表算法主要根据时间的日期进行分片，分片表的数量是根据 TTL 每天一个表：&lt;/p&gt;
&lt;p&gt;分片表名 = 逻辑表名_时间序列（日期）：&lt;code&gt;{tableName =logicTableName_timeSeries}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为保证在 TTL 有效期内的数据能够被写入和查询，时间序列将生成当前日期&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{timeSeries = currentDate - TTL +1...currentDate + 1}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如：如果 &lt;code&gt;TTL=3, currentDate = 20220907&lt;/code&gt;，则分片表为:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;logicTableName_20220905
logicTableName_20220906
logicTableName_20220907
logicTableName_20220908
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SkyWalking 提供了多种不同的分表算法用于不同的数据模型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;算法名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;分片说明&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;分片键时间精度要求&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;典型应用数据模型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;NO_SHARDING&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不做任何表分片，保持单表模式&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;/&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据量小无需分片的数据模型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;TIME_RELATIVE_ID_SHARDING_ALGORITHM&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 ID 列中的 &lt;code&gt;time_bucket&lt;/code&gt; 按天分片&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;time_bucket&lt;/code&gt; 的精度可以是同一表中的秒、分、小时和天&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;各类 Metrics 指标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;TIME_SEC_RANGE_SHARDING_ALGORITHM&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 &lt;code&gt;time_bucket&lt;/code&gt; 列按天分片&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;time_bucket&lt;/code&gt; 的精度必须是秒&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;SegmentRecordLogRecord&lt;/code&gt; 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;TIME_MIN_RANGE_SHARDING_ALGORITHM&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 &lt;code&gt;time_bucket&lt;/code&gt; 列按天分片&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;time_bucket&lt;/code&gt; 的精度必须是分钟&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EndpointTraffic&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;TIME_BUCKET_SHARDING_ALGORITHM&lt;/code&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 &lt;code&gt;time_bucket&lt;/code&gt; 列按天分片&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;time_bucket&lt;/code&gt; 的精度可以是同一个表中的秒、分、小时和天&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Service、Instance、Endpoint 调用关系等如 &lt;code&gt;ServiceRelationServerSideMetrics&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ttl-机制&#34;&gt;TTL 机制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对于进行分片的表根据 TTL 直接删除 &lt;code&gt;deadline&lt;/code&gt; &amp;gt;= &lt;code&gt;timeSeries&lt;/code&gt; 的物理表 &lt;code&gt;{deadline = new DateTime().plusDays(-ttl)}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TTL 定时器在根据当前日期删除过期表的同时也会根据新日期更新分片规则，通知 ShardingSphere-Proxy 创建新的分片表&lt;/li&gt;
&lt;li&gt;对于单表的延续之前的方式，删除 deadline &amp;gt;= &lt;code&gt;time_bucket&lt;/code&gt; 的行记录&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分片数据存储示例&#34;&gt;分片数据存储示例&lt;/h2&gt;
&lt;p&gt;下面以 segment（Record 类型）和 &lt;code&gt;service_resp_time&lt;/code&gt;（Metrics 类型）两个为例说明数据存储的逻辑和物理分布。这里假设 MySQL 为 &lt;code&gt;ds_0&lt;/code&gt; 和 &lt;code&gt;ds_1&lt;/code&gt; 两个节点。&lt;/p&gt;
&lt;p&gt;注意：以下的存储表结构仅为简化后的存储示例，不表示 SkyWalking 真实的表结构。&lt;/p&gt;
&lt;h3 id=&#34;segment&#34;&gt;segment&lt;/h3&gt;
&lt;p&gt;分片配置为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@SQLDatabase.Sharding(shardingAlgorithm = ShardingAlgorithm.TIME_SEC_RANGE_SHARDING_ALGORITHM, dataSourceShardingColumn = service_id, tableShardingColumn = time_bucket)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;逻辑库表结构和实际库表如下图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-逻辑表结构和实际库表-1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;逻辑表结构和实际库表 1&#34; srcset=&#34;
               /blog/skywalking-shardingsphere-proxy/f1_huef078d27fccce2365ce632ebd3fe640f_147977_55443f265476018e1841c64ad42f59fb.webp 400w,
               /blog/skywalking-shardingsphere-proxy/f1_huef078d27fccce2365ce632ebd3fe640f_147977_3ec3add2e7b7a4497a3e2b9b98d04458.webp 760w,
               /blog/skywalking-shardingsphere-proxy/f1_huef078d27fccce2365ce632ebd3fe640f_147977_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/skywalking-shardingsphere-proxy/f1_huef078d27fccce2365ce632ebd3fe640f_147977_55443f265476018e1841c64ad42f59fb.webp&#34;
               width=&#34;760&#34;
               height=&#34;454&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      逻辑表结构和实际库表 1
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;service_resp_time&#34;&gt;service_resp_time&lt;/h3&gt;
&lt;p&gt;分片配置为：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@SQLDatabase.Sharding(shardingAlgorithm = ShardingAlgorithm.TIME_RELATIVE_ID_SHARDING_ALGORITHM, tableShardingColumn = id, dataSourceShardingColumn = entity_id)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;逻辑库表结构和实际库表如下图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-逻辑表结构和实际库表-2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;逻辑表结构和实际库表 2&#34; srcset=&#34;
               /blog/skywalking-shardingsphere-proxy/f2_hu0e496ba8722b150793e4c03cec7c77e2_180564_31b90cea41f945df9d9eafc561e5e029.webp 400w,
               /blog/skywalking-shardingsphere-proxy/f2_hu0e496ba8722b150793e4c03cec7c77e2_180564_7cdb600fc50afb904a15a01b934522fe.webp 760w,
               /blog/skywalking-shardingsphere-proxy/f2_hu0e496ba8722b150793e4c03cec7c77e2_180564_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/skywalking-shardingsphere-proxy/f2_hu0e496ba8722b150793e4c03cec7c77e2_180564_31b90cea41f945df9d9eafc561e5e029.webp&#34;
               width=&#34;760&#34;
               height=&#34;696&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      逻辑表结构和实际库表 2
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;如何使用&#34;&gt;如何使用&lt;/h2&gt;
&lt;p&gt;你可以选择手动或使用 Docker 来运行 Demo。&lt;/p&gt;
&lt;h3 id=&#34;手动部署&#34;&gt;手动部署&lt;/h3&gt;
&lt;p&gt;这里以单节点 SkyWalking OAP 和 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy 5.1.2&lt;/a&gt; 部署为例，集群部署请参考其他相关文档。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;准备好 MySQL 集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署安装并配置 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;conf/server.yaml&lt;/code&gt;，&lt;code&gt;props.proxy-hint-enabled&lt;/code&gt; 必须为 &lt;code&gt;true&lt;/code&gt;，完整配置可参考&lt;a href=&#34;https://github.com/wankai123/skywalking-mysql-sharding-demo/blob/main/shardingsphere-proxy/conf/server.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;conf/config-sharding.yaml&lt;/code&gt;，配置逻辑数据库和 &lt;code&gt;dataSources&lt;/code&gt; 列表，&lt;code&gt;dataSource&lt;/code&gt; 的名称必须以 &lt;code&gt;ds_&lt;/code&gt;为前缀，并且从 &lt;code&gt;ds_0&lt;/code&gt; 开始，完整配置可参考&lt;a href=&#34;https://github.com/wankai123/skywalking-mysql-sharding-demo/blob/main/shardingsphere-proxy/conf/config-sharding.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署安装并配置 SkyWalking OAP：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置 OAP 环境变量 &lt;code&gt;${SW_STORAGE:mysql-sharding}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据实际部署情况配置连接信息： &lt;code&gt;${SW_JDBC_URL}&lt;/code&gt; &lt;code&gt;${SW_DATA_SOURCE_USER}&lt;/code&gt; &lt;code&gt;${SW_DATA_SOURCE_PASSWORD}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：连接信息需对应 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy&lt;/a&gt; 虚拟数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy&lt;/a&gt; 中 &lt;code&gt;conf/config-sharding.yaml&lt;/code&gt; 配置的数据源名称配置在 &lt;code&gt;${SW_JDBC_SHARDING_DATA_SOURCES}&lt;/code&gt; 中，用 &lt;code&gt;,&lt;/code&gt; 分割&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 MySQL 集群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 &lt;a href=&#34;https://shardingsphere.apache.org/document/current/en/overview/#shardingsphere-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shardingsphere-Proxy&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 SkyWalking OAP&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用-docker-运行-demo&#34;&gt;使用 Docker 运行 Demo&lt;/h3&gt;
&lt;p&gt;GitHub 资源库提供了一个基于 Docker 完整可运行的 demo：&lt;a href=&#34;https://github.com/wankai123/skywalking-mysql-sharding-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;skywalking-mysql-sharding-demo&lt;/a&gt;，可以快速尝试实际运行效果。&lt;/p&gt;
&lt;p&gt;其中部署包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;oap 服务 1 个，Metrics 和 Record 数据的 TTL 均设为 2 天&lt;/li&gt;
&lt;li&gt;sharding-proxy 服务 1 个版本为 5.1.2，对外端口为 13307，创建的逻辑库名称为 swtest&lt;/li&gt;
&lt;li&gt;mysql 服务 2 个，对外端口分别为 3306，3307，在 sharding-proxy 的 &lt;code&gt;conf/config-sharding.yaml&lt;/code&gt; 中配置为 &lt;code&gt;ds_0&lt;/code&gt; 和 &lt;code&gt;ds_1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;provider 服务 1 个（模拟业务程序用于验证 trace 和 metrics 等数据），对外端口为 9090&lt;/li&gt;
&lt;li&gt;consumer 服务 1 个（模拟业务程序用于验证 trace 和 metrics 等数据），对外端口为 9092&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将 Demo 程序获取到本地后，在 skywalking-mysql-sharding-demo 目录下直接运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker-compose up -d
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意：初次启动由于拉取镜像和新建所有表可能需要一定的时间。&lt;/p&gt;
&lt;p&gt;所有服务启动完成之后可以通过数据库工具查看 &lt;code&gt;sharding-proxy&lt;/code&gt; 逻辑表创建情况，以及两个 MySQL 库中实际的物理分片表创建情况。也可以连接 &lt;code&gt;sharding-proxy&lt;/code&gt; 逻辑库 &lt;code&gt;swtest&lt;/code&gt; 查看数据查询路由情况，如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;PREVIEW&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SEGMENT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显示结果如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-查询结果&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;查询结果&#34; srcset=&#34;
               /blog/skywalking-shardingsphere-proxy/sql_hu2b7d8350b294b494434f48770bc3de7b_26059_e3087b61c6045e88c09e93690175580e.webp 400w,
               /blog/skywalking-shardingsphere-proxy/sql_hu2b7d8350b294b494434f48770bc3de7b_26059_68bb6a6bf632e9d9d4d46fd34bc8c1fb.webp 760w,
               /blog/skywalking-shardingsphere-proxy/sql_hu2b7d8350b294b494434f48770bc3de7b_26059_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/skywalking-shardingsphere-proxy/sql_hu2b7d8350b294b494434f48770bc3de7b_26059_e3087b61c6045e88c09e93690175580e.webp&#34;
               width=&#34;760&#34;
               height=&#34;53&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      查询结果
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Demo 提供的模拟业务程序可以通过请求 consumer 服务模拟业务请求，用于验证各类型数据分布：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl http://127.0.0.1:9092/info
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇文章中我们详细介绍了 SkyWalking  基于 ShardingSphere-Proxy 的 MySQL-Sharding 存储特性的部署架构、适应场景、核心分库分表逻辑以及 TTL 机制，并提供了运行后的数据存储示例和详细部署配置步骤以便大家快速理解上手。SkyWalking 提供了多种存储方式以供选择，如果你目前的需求如本文所述，欢迎使用该新特性。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>KubeCon 北美 2022 可观测性开放日见闻</title>
      <link>https://cloudnative.to/blog/kubecon-summary-of-the-open-observability-day/</link>
      <pubDate>Wed, 09 Nov 2022 09:16:27 +0800</pubDate>
      <guid>https://cloudnative.to/blog/kubecon-summary-of-the-open-observability-day/</guid>
      <description>&lt;p&gt;2022 年 10 月底，作为在底特律举行的完整 KubeCon 和 CloudNativeCon 活动之前的场外活动，&lt;a href=&#34;https://events.linuxfoundation.org/open-observability-day-north-america/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Observability Day&lt;/a&gt; 为期一天的活动首次举行。&lt;/p&gt;
&lt;p&gt;活动会场在亨廷顿广场会议中心，可以看到河对面加拿大的景色（很多人都不知道底特律离美国北部边境如此之近） 。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymecxp5ij312c0pemzi_huea7eb3c8825b39a39d5e66773d29adef_96919_8e95cf99f78106e19142384d833ad2a5.webp 400w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymecxp5ij312c0pemzi_huea7eb3c8825b39a39d5e66773d29adef_96919_edfc20351ece5e4f725e54b18c6ea0d6.webp 760w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymecxp5ij312c0pemzi_huea7eb3c8825b39a39d5e66773d29adef_96919_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymecxp5ij312c0pemzi_huea7eb3c8825b39a39d5e66773d29adef_96919_8e95cf99f78106e19142384d833ad2a5.webp&#34;
               width=&#34;760&#34;
               height=&#34;504&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Open Observability Day 的&lt;a href=&#34;https://events.linuxfoundation.org/open-observability-day-north-america/program/schedule/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;完整时间表可在线获得&lt;/a&gt;，今天我想分享一下在那里的感受。&lt;/p&gt;
&lt;p&gt;这一天以所有与开放可观测性相关的 CNCF 项目为中心，充斥了供应商和以项目为中心的演讲。&lt;/p&gt;
&lt;p&gt;活动从 CNCF 项目创始人 Bartek Płotka 的概述开始，他叙述了 Thanos、Fluntd、OpenTelemetry、Jeager 等项目的更新。然后过渡到两个简短的主题演讲。&lt;/p&gt;
&lt;h2 id=&#34;分布式追踪斗争是真实的&#34;&gt;分布式追踪：斗争是真实的&lt;/h2&gt;
&lt;p&gt;Chronosphere 的现场首席技术官 Ian Smith 分享了他在该领域从事分布式跟踪解决方案 9 年后的想法。他带我们进行了一次旋风之旅，了解了它的来源和可能的发展方向，以及围绕支持分布式跟踪的工具存在哪些技术问题。下面是他给出的 tips：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;追踪已成为高承诺、高努力、低价值的故事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他继续强调对开发人员工具的关注需要如何扭转这种局面，并开始以更少的努力和更多的价值提供一些承诺。&lt;/p&gt;
&lt;h2 id=&#34;简化可观测性&#34;&gt;简化可观测性&lt;/h2&gt;
&lt;p&gt;Calyptia 首席执行官 Eduardo Silva 分享了从创建 Fluentd 项目到专注于云原生环境的新 Fluent-bit 项目的故事。然后，他介绍了他们在构建 Fluent Bit 项目的日志空间方面的经验，以及如何扩展生态系统以支持指标和追踪，从而帮助塑造简化的用户可观测性体验。他宣布发布 Calyptia Core，使用开源工具通过数据管道收集数据，而无需使用代理。现在可以免费使用，并且可以安装到现有的 Kubernetes 集群中。他们还有一个 Docker 桌面扩展。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymizzdfhj31400u0q82_hue2aee2b4a3356fce48c1115515f748a9_199466_892650c945a9f1b0158fdfdbb6864652.webp 400w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymizzdfhj31400u0q82_hue2aee2b4a3356fce48c1115515f748a9_199466_0e537e3c9e4cde89d76ffe40700d3c8f.webp 760w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymizzdfhj31400u0q82_hue2aee2b4a3356fce48c1115515f748a9_199466_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymizzdfhj31400u0q82_hue2aee2b4a3356fce48c1115515f748a9_199466_892650c945a9f1b0158fdfdbb6864652.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;两个主题演讲都很短，只有 10 分钟，之后主要演讲开始了。&lt;/p&gt;
&lt;h2 id=&#34;使用-fluent-bit-构建可观测性管道&#34;&gt;使用 Fluent Bit 构建可观测性管道&lt;/h2&gt;
&lt;p&gt;LinkedIn 的 Chao Xu 谈到了他们如何从现有的可观测性管道封闭工具过渡到开源和开放标准。他们主要使用 Fluent Bit 和 Open Telemetry。他们还将语言工具从 Java 应用程序扩展到 Go、C++ 和 Python。他们将跟踪和日志整合到单个管道中，而不是单独的数据管道中，从而创建更简单的维护标准和更少的资源负载。他们是 OTEL 收集器的忠实信徒，但他们将其扩展为新扩展的可观测性代理，以支持数据转换和过滤以及 OTEL 数据流的摄取。LinkedIn 也非常喜欢 Fluent Bit 提供的用于处理各种数据流的增强标签管理。&lt;/p&gt;
&lt;h2 id=&#34;为什么大规模可观测性需要图&#34;&gt;为什么大规模可观测性需要图&lt;/h2&gt;
&lt;p&gt;SquaredUp 的 Richard Benwell 深入研究了可观测性 Wikipedia 页面，这是一种相当有趣的方式来尝试构建我们所说的可观测性的基础。他用它来表明我们有带有指标、日志和跟踪的信号，但是我们在当前的可观测性平台中缺少我们的系统模型。这个演讲假设没有模型，信号是无用的。他继续使用架构作为我们正在收集的指标、日志和跟踪的模型。这就引出了一个问题：你是否需要架构师来设计模型，或者你是否只是像跟踪工具那样生成模型？此外，该模型很好（它有助于理解），但你需要能够深入了解你正在收集和建模的数据的含义。然后演讲深入到我们大学都学习过的图入门课程，从顶点到边到顶点类型的故事。它唤起了人们对数学课程和人工智能领域建模的美好回忆，以解决医疗诊断等问题领域。&lt;/p&gt;
&lt;h2 id=&#34;对混沌的-kubernetes-可观测性充满信心&#34;&gt;对混沌的 Kubernetes 可观测性充满信心&lt;/h2&gt;
&lt;p&gt;来自 GitLab 的 Michael Friedrich 分享了我们如何从运行云原生环境转变为使用 Prometheus、Perces、Graphans 等 CNCF 项目监控。现在我们被所有传入的数据所淹没，这不是一个新概念。所以现在我们有了这个，他分享了一些关于故意破坏事物的想法，以了解它的行为、监控和恢复方式。他强调了 Chaos Mesh 项目，这是一个有趣的想法，即如何查看整个环境将如何响应问题。演讲以 Chaos Mesh 使用的现场演示结束。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymp1ajxmj30u0140dkm_huf46571e1c0e773ec1797624018298a39_186754_2c907fdb47386397ce1ddddc6d9bc70b.webp 400w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymp1ajxmj30u0140dkm_huf46571e1c0e773ec1797624018298a39_186754_285a4b4ec17c289b00edf726f19a9fba.webp 760w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymp1ajxmj30u0140dkm_huf46571e1c0e773ec1797624018298a39_186754_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymp1ajxmj30u0140dkm_huf46571e1c0e773ec1797624018298a39_186754_2c907fdb47386397ce1ddddc6d9bc70b.webp&#34;
               width=&#34;570&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;午餐前后有几个闪电演讲，只有短短的 10 分钟。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 FluentBit 实现云和边缘的统一可观测性&lt;/li&gt;
&lt;li&gt;通过自动发现的安全策略理解可观测性&lt;/li&gt;
&lt;li&gt;通过 OpAMP 协议管理 OpenTelemetry&lt;/li&gt;
&lt;li&gt;如何为可观测性构建数据管道&lt;/li&gt;
&lt;li&gt;eBPF 实际上可以为现代可观测性做什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下午结束了完整的分组会议：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymqtfzusj30u01407au_hu7b011573121487020a1f633502a7f44e_252136_90a81ee0300d2374ce9f302fbf713a2a.webp 400w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymqtfzusj30u01407au_hu7b011573121487020a1f633502a7f44e_252136_730220a766dcdb5a0e6dce75a69dec1e.webp 760w,
               /blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymqtfzusj30u01407au_hu7b011573121487020a1f633502a7f44e_252136_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/kubecon-summary-of-the-open-observability-day/008vxvgGgy1h7ymqtfzusj30u01407au_hu7b011573121487020a1f633502a7f44e_252136_90a81ee0300d2374ce9f302fbf713a2a.webp&#34;
               width=&#34;570&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;在-ebay-采用开放遥测收集器在飞行中换引擎&#34;&gt;在 eBay 采用开放遥测收集器：在飞行中换引擎&lt;/h2&gt;
&lt;p&gt;来自 eBay 的 Vijay Samuel 分享了从 Elastic Beats for traces 迁移到 Open Telemetry 的经验。他谈到了他们的云原生规模、遇到的问题、从 Metric Beats 到 OTEL 收集器的旅程、弥合动态配置重新加载的差距以及确保迁移后的数据奇偶性。这很有趣，他们正在招聘工程师。&lt;/p&gt;
&lt;h2 id=&#34;使用--opentelemetry-的-prometheus-管道&#34;&gt;使用  OpenTelemetry 的 Prometheus 管道&lt;/h2&gt;
&lt;p&gt;来自 Grafana Labs 和作为 Prometheus 维护者超过五年的 Goutham Veeramachaneni 分享了如何在 Prometheus 数据管道中利用 OTEL 来为你的指标基础设施添加追踪。&lt;/p&gt;
&lt;p&gt;这个概述不包括今天举行的所有会谈，但给人留下了很好的印象。我必须承认，由于在休息期间出现的网络问题，我无法跟上所有会话。有几次，我进行了深入的讨论，使我在大厅或展位上的时间比计划的休息时间更长，但这就是这些活动的目的！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>论元数据在可观测性中的重要性</title>
      <link>https://cloudnative.to/blog/the-importance-of-metadata-in-observability/</link>
      <pubDate>Mon, 07 Nov 2022 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/the-importance-of-metadata-in-observability/</guid>
      <description>&lt;p&gt;本文为云杉网络原力释放 - 云原生可观测性分享会第十一期直播实录。&lt;a href=&#34;https://mp.weixin.qq.com/s/QKb1cbqfkmhtxI8rGEtLUg?vid=1688856588389646&amp;amp;deviceid=8b31b0c6-6d71-4c84-864b-f1d468e717a1&amp;amp;version=4.0.19.6020&amp;amp;platform=win&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;回看链接&lt;/a&gt;，&lt;a href=&#34;http://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/yunshan-ticket/pdf/39efae2215f69da573b095259f8cd79f_20221027183747.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PPT下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;大家好，我是陈晨，今天和分享的内容是《论元数据在可观测性中的重要性》，大纲为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从智能驾驶看可观测性未来发展。&lt;/li&gt;
&lt;li&gt;用开源产品构建可观测性遇到的痛点。&lt;/li&gt;
&lt;li&gt;构建内部元数据平台打通多信号关联。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那前期我们多位老师为大家分享了可观测性相关的领域知识，看到大家对&lt;strong&gt;多信号之间的关联&lt;/strong&gt;有一些疑惑，今天来和大家聊下&lt;strong&gt;元数据在可观测性多信号关联的重要性&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;从智能驾驶看可观测性未来发展&#34;&gt;从智能驾驶看可观测性未来发展&lt;/h2&gt;
&lt;p&gt;在此之前为大家解释下多信号的概念，该概念来源于 CNCF 可观测性 SIG 推出的 《可观测性白皮书》一文中的译词，当然云原生社区也有我们翻译的中文版白皮书内容，欢迎大家去看往期的文章推送。那从白皮书里总结起来，多信号就是可观测性系统中各种用途不同但具备结构化、标准化数据的总称，例如我们常常听到的 logs， traces， metrics 等数据。&lt;/p&gt;
&lt;p&gt;可观测性在获取到多个信号后，会将其以静态或动态的状态放置于存储内，通过多个不同状态的信号来构建属于自己的可观测性平台，以此来缩短解决错误的时间和透视化软件服务内部的黑盒状态。在这个动态过程中，让多信号之间可以紧密的配合来反馈应用程序或 IT 部署环境的实际运行状态，就是元数据开始发挥作用的时候了。&lt;/p&gt;
&lt;p&gt;当然我们在聊元数据之前，我们先来看两张图。这两张图来源于张城老师在云原生社区 Meetup 北京站演讲的 PPT（已经征求本人同意）《云原生下的可观测性发展方向》。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-智能驾驶分级&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;智能驾驶分级&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/1_hu8d53fd0f3408e9b61472535b8214d673_167535_6c4bbf48a7b5647ba347e99d4b151349.webp 400w,
               /blog/the-importance-of-metadata-in-observability/1_hu8d53fd0f3408e9b61472535b8214d673_167535_246506192f961bde144e8eb40b005452.webp 760w,
               /blog/the-importance-of-metadata-in-observability/1_hu8d53fd0f3408e9b61472535b8214d673_167535_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/1_hu8d53fd0f3408e9b61472535b8214d673_167535_6c4bbf48a7b5647ba347e99d4b151349.webp&#34;
               width=&#34;704&#34;
               height=&#34;281&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      智能驾驶分级
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上面这张图是自动驾驶分级后的表现图。我们可以看到自动驾驶依据分级可分为 6 级，其中 0 - 2 级主要还是靠人工来干预，三级后开始变得无意识起来，之后开始变得更加智能化起来。&lt;/p&gt;
&lt;p&gt;下面这张图则是 IT 系统可观测性参考智能驾驶划分的六级图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-可观测性分级&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;可观测性分级&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/2_hue7f2ae4088f30870744fd3953d531c14_109913_829710bbc51f8d43b2db62658732968f.webp 400w,
               /blog/the-importance-of-metadata-in-observability/2_hue7f2ae4088f30870744fd3953d531c14_109913_640b9692d7861030e236d6c4b6387137.webp 760w,
               /blog/the-importance-of-metadata-in-observability/2_hue7f2ae4088f30870744fd3953d531c14_109913_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/2_hue7f2ae4088f30870744fd3953d531c14_109913_829710bbc51f8d43b2db62658732968f.webp&#34;
               width=&#34;760&#34;
               height=&#34;219&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      可观测性分级
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等级 0：手工分析，依靠基础的 Dashboard、告警、日志查询、分布式链路追踪等方式进行手动告警、分析，也是目前绝大部分公司使用的场景&lt;/li&gt;
&lt;li&gt;等级 1：智能告警，能够自动去扫描所有的可观测性数据，利用机器学习的方式去识别一些异常并进行自动告警，免去人工设置 / 调整各种基线告警的工作&lt;/li&gt;
&lt;li&gt;等级 2：异常关联 + 统一视图，对于自动识别的异常，能够进行上下文的关联，形成一个统一的业务视图，便于快速的定位问题&lt;/li&gt;
&lt;li&gt;等级 3：根因分析 + 问题自愈，自动根据异常以及系统的 CMDB 信息直接定位问题的根因，根因定位准确后那边可以去做问题的自愈。这一阶段相当于是一次质的飞跃，在某些场景下可以在人不用参与的情况下实现问题的自愈。&lt;/li&gt;
&lt;li&gt;等级 4：故障预测，故障发生总会有损失，所以最好的情况是避免故障的发生，因此故障预测技术可以更好的来保证系统的可靠性，利用之前积累的一些故障先兆信息做到 “未卜先知”&lt;/li&gt;
&lt;li&gt;等级 5：变更影响预测，我们知道绝大部分的故障都是由变更引起的，因此如果能够模拟出每个变更对系统带来的影响以及可能产生的问题，我们就能够提前评估出是否能够允许此次变更。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然我们会有一些专业的可观测性团队已经在实践异常关联、根因分析、故障预测等能力。那我们今天以大家最常用的手工分析作为切入点来看下问题排查过程中遇到的问题。&lt;/p&gt;
&lt;h2 id=&#34;用开源产品构建可观测性遇到的痛点&#34;&gt;用开源产品构建可观测性遇到的痛点&lt;/h2&gt;
&lt;p&gt;我们在进行案例分析前来看一个图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-链路拓扑分析&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;链路拓扑分析&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/3_hu53cc3169204408b4cdb26013479eb690_53553_193a8e71e1431d43c145dc73bc9f2dae.webp 400w,
               /blog/the-importance-of-metadata-in-observability/3_hu53cc3169204408b4cdb26013479eb690_53553_329d978d448e79e3ca7640cc6171a4ba.webp 760w,
               /blog/the-importance-of-metadata-in-observability/3_hu53cc3169204408b4cdb26013479eb690_53553_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/3_hu53cc3169204408b4cdb26013479eb690_53553_193a8e71e1431d43c145dc73bc9f2dae.webp&#34;
               width=&#34;760&#34;
               height=&#34;324&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      链路拓扑分析
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;熟悉的&lt;strong&gt;拓扑分析&lt;/strong&gt;，大家一直都在考虑为用户产生一个具体的运行时应用级别的画像，可以清晰的告诉开发者我们的应用关联是怎样的，应用所依赖的中间件运行状态，我们出入口流量等。&lt;/p&gt;
&lt;p&gt;那这样的拓扑分析其实有很很多小技巧，比如我们可以构建一个静态的应用拓扑依赖分析图，也可以构建 Request Scope 级别的运行时应用拓扑分析图。那什么叫做&lt;strong&gt;静态的应用拓扑分析图&lt;/strong&gt;呢？&lt;/p&gt;
&lt;p&gt;比如我们业务应用只想知道自己依赖的上下游服务和相关联的中间件的拓扑，那这种拓扑则当业务应用开始运行时就会确定，不存在有较大的改变的可能，除非在中间件 Client 做了中间件 Server 的&lt;strong&gt;故障动态切换和转移&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那相对的&lt;strong&gt;动态的应用拓扑分析图&lt;/strong&gt;呢？就是指在 Request Scope 下的某一次请求下的应用实时拓扑分析，一般动态应用拓扑分析里面包含了运行时的一些指标数据以及关联的 Span 信息还有一些业务日志的联动。&lt;/p&gt;
&lt;p&gt;当然具体是静态拓扑还是动态拓扑，我们都需要在某一个地方获取到这些关联关系，行业优秀产品 SkyWalking 在旧版本 DashBoard 上绘制出来的链路拓扑分析图则是依赖存储中聚合到的 Span 来构建应用的关联关系，并对关键的 RED 指标做了关联，那其实相对的这种方式对存储也会有一定的压力。&lt;/p&gt;
&lt;p&gt;以 Grafana Loki 中介绍的一个典型问题排查过程来看：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-loki-demo-案例&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Loki Demo 案例&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/4_hua35f252b085fde227e44b1c35e1161df_291072_584a66f59f99bc22b3cb3d1f69cae798.webp 400w,
               /blog/the-importance-of-metadata-in-observability/4_hua35f252b085fde227e44b1c35e1161df_291072_726fd4158d1605be000c327c2c952cc6.webp 760w,
               /blog/the-importance-of-metadata-in-observability/4_hua35f252b085fde227e44b1c35e1161df_291072_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/4_hua35f252b085fde227e44b1c35e1161df_291072_584a66f59f99bc22b3cb3d1f69cae798.webp&#34;
               width=&#34;760&#34;
               height=&#34;345&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Loki Demo 案例
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们通常因为告警而感知系统出现了运行时问题（主要是 metrics，当然会有一些历史项目使用 logs），&lt;/li&gt;
&lt;li&gt;因为大盘而确定异常的模块（metrics/events）和查看一些系统性指标，&lt;/li&gt;
&lt;li&gt;通过拓扑分析/链路信息定位到问题发生的具体应用（topology/traces），&lt;/li&gt;
&lt;li&gt;然后通过应用运行时日志确定具体的细节（logs）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过多信号之间的配合完成问题的定位，有些问题的排查步骤和上述不太一致，有些许改变。但是不影响多信号之间配合发挥的重要作用。&lt;/p&gt;
&lt;p&gt;我们将上述定位问题使用到的&lt;strong&gt;信号解析到数据层面&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-数据层面的多信号&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;数据层面的多信号&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/5_huf979dae63ce8f9d80b2a43d1682d72ed_54524_f64b896ff009d05693144f993629ab64.webp 400w,
               /blog/the-importance-of-metadata-in-observability/5_huf979dae63ce8f9d80b2a43d1682d72ed_54524_c788cc949f46f78d90987970a5fe9328.webp 760w,
               /blog/the-importance-of-metadata-in-observability/5_huf979dae63ce8f9d80b2a43d1682d72ed_54524_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/5_huf979dae63ce8f9d80b2a43d1682d72ed_54524_f64b896ff009d05693144f993629ab64.webp&#34;
               width=&#34;760&#34;
               height=&#34;418&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      数据层面的多信号
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;告警：我们有基本的告警信息，包括告警内容，告警级别，告警时间以及其他一些利于定位问题的信息（行政信息、云资产信息等）。&lt;/li&gt;
&lt;li&gt;Metrics：不同的指标会有不同的 lables/tags，和告警可以匹配到一般是一组依据算子计算好的指标数据。Open Metrics 组织和 Prometheus 是这方面的专家，当然也有一些比较优秀的厂商在做这样的指标产品。&lt;/li&gt;
&lt;li&gt;Traces：各家 trace 产品大同小异，内部包含的元信息也类似。不过我们应该感谢 OTel，让这件事儿变成了标准，并让数据流管道化。&lt;/li&gt;
&lt;li&gt;Logs：logs 里会有一些和其他信号重复的数据，例如 service name, instance name, trace info等。logs 的重点也会在他的 msg 内，一般供大家检索查询。当然也会有一些不需要检索的日志产品， Loki是这方面的实践专家。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然可观测性也是在不断的进化，会有新的信号进来和现有的多信号配合一起来透视化软件黑盒状态和加速解决问题的进度。例如大家一直都在实践的 profiles/ dumps等。&lt;/p&gt;
&lt;p&gt;那这些&lt;strong&gt;多信号间是如何关联的&lt;/strong&gt;呢？我们来看下一张图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-多信号关联&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;多信号关联&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/6_hua69b2a24706826d9fe59afda623fd95e_199117_844b98f0ef94e009b53e86a93cc69e2d.webp 400w,
               /blog/the-importance-of-metadata-in-observability/6_hua69b2a24706826d9fe59afda623fd95e_199117_17108aa45c3dbce7cc537af7275a115e.webp 760w,
               /blog/the-importance-of-metadata-in-observability/6_hua69b2a24706826d9fe59afda623fd95e_199117_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/6_hua69b2a24706826d9fe59afda623fd95e_199117_844b98f0ef94e009b53e86a93cc69e2d.webp&#34;
               width=&#34;760&#34;
               height=&#34;352&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      多信号关联
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们依据时间来缩小问题定位的窗口，依据 多信号间共有的 元信息来关联多信号。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们依据  trace id 来关联 traces 和 logs 以及 metrics 的 Exemplars（是最普遍也是最有效的方式）。&lt;/li&gt;
&lt;li&gt;我们依靠埋点的 service name， instance name， span id 或者其他元信息来关联到更细节的信号（例如我们指标和指标之间的关联通过 labels/tags 中重复的元数据，业务日志通过应用信息关联到 K8s Pod metrics ）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些元信息里面包括 私有云，公有云的实例信息，容器的运行时信息，应用的列表信息，中间件的连接信息，业务自埋点的信息等。但是这样我们一定就能够做到无缝连接了吗？&lt;/p&gt;
&lt;p&gt;我们来看下&lt;strong&gt;多信号关联的难点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-多信号关联难点&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;多信号关联难点&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/7_hu921db17a5b21413a8dfdcee9a890b440_81705_bfff68867550cc936dca1186b04aa6ec.webp 400w,
               /blog/the-importance-of-metadata-in-observability/7_hu921db17a5b21413a8dfdcee9a890b440_81705_9bdbff84735ddea6446fb12017d39912.webp 760w,
               /blog/the-importance-of-metadata-in-observability/7_hu921db17a5b21413a8dfdcee9a890b440_81705_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/7_hu921db17a5b21413a8dfdcee9a890b440_81705_bfff68867550cc936dca1186b04aa6ec.webp&#34;
               width=&#34;760&#34;
               height=&#34;316&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      多信号关联难点
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;不一致的元数据&lt;/strong&gt;：我们能看到多信号关联的重点在于存在同样的元数据，但是其实垂直领域下现阶段我们使用的各家产品在元数据层面并没有达到一致，包括统一产品在不同版本迭代中也会出现 意思相同命名不同的现象，造成准确性和及时性无法保障。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺少 trace info&lt;/strong&gt;：logs, metrics, traces 关联过程最简单也是最高效的方式是通过 trace info 被打点在各个信号中，然后依据 trace info 去将多信号进行关联。但是如果应用级的 trace 中丢失了 span infos ，那将会是一个灾难。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;糟糕的采样&lt;/strong&gt;：采样是一个极具争议的话题，一方面会降低存储压力，但是一方面又会影响产品功能的完整性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺失的元数据&lt;/strong&gt;：我们想从系统层面关联到应用层面，继而再通过网络关联到其他的系统层面以及网络层面，当缺失了某些元数据，对于可观测性系统来说将是灾难性的，对产品的功能有极大的影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，依据多信号内的元数据不能做到 100% 的高度关联，还需要做一些其他的工作来辅助和补充元数据，以此来大幅度提升可观测性的能力。比如统一具备&lt;strong&gt;通用性的元数据&lt;/strong&gt;打入到我们的多信号内，以此来&lt;strong&gt;增强多信号关联性&lt;/strong&gt;。但是因为打入在多信号中的元数据愈发变多，存储的压力及繁琐的工作也常常会让我们头痛。&lt;/p&gt;
&lt;h2 id=&#34;构建元数据平台打通多信号关联&#34;&gt;构建元数据平台打通多信号关联&lt;/h2&gt;
&lt;p&gt;那基于此，如果我们要构建一个健壮的可观测性平台，在这个过程中遇到的散落在各地的元数据，我们应该将他组织并利用起来，以此站在更高纬度的视角去观测我们的系统（当然元数据平台的功能不止于此）。&lt;/p&gt;
&lt;p&gt;依据维基百科中元数据的定义：元数据被定义为提供某些资料单方面或多方面信息的资料，被用来概述资料的基础信息，以简化查找过程与方便使用。&lt;/p&gt;
&lt;p&gt;IT基础设施的元数据构建我们可以考虑以下几点：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-元数据平台能力&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;元数据平台能力&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/8_hud0ebb1311f202a69cb815390fdc7b72b_67079_59ab7158ac948b99bb0f0de960573f1d.webp 400w,
               /blog/the-importance-of-metadata-in-observability/8_hud0ebb1311f202a69cb815390fdc7b72b_67079_b902049e191257ecc4791640174b3788.webp 760w,
               /blog/the-importance-of-metadata-in-observability/8_hud0ebb1311f202a69cb815390fdc7b72b_67079_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/8_hud0ebb1311f202a69cb815390fdc7b72b_67079_59ab7158ac948b99bb0f0de960573f1d.webp&#34;
               width=&#34;760&#34;
               height=&#34;457&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      元数据平台能力
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;网络级别的元数据&lt;/strong&gt;：包括我们使用的网络设施的基础数据和实际运行时挂载的运行时元数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用级别的元数据&lt;/strong&gt;：包括我们业务应用列表信息和应用关联的中间件的连接元数据信息及中间件自身的元数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统级别的元数据&lt;/strong&gt;：包括我们主机列表信息以及虚拟化容器化之后的动态元数据信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然构建这样的系统可能是一件需要持续做下去的事情，但是构建这样的元数据平台对于基础设施建设和 IT 可观测性的重要性不言而喻。那可能有人会问，我们这里的元数据和运维侧的元数据平台的区别是什么呢。&lt;/p&gt;
&lt;p&gt;一些公司内部可能会构建属于自己运维侧的元数据平台，那根据过往经验内部包含的则是一些资产信息和管理信息。我们这里的元数据平台将其归纳到系统级元数据内，并对其做了一定的补充，包括应用级元数据、网络层元数据等，但其实还缺少了行政级元数据。如果有了这样齐全的元数据信息后，这样我们做到什么能力呢。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;精准的告警直达某业务线某小组内某应用的主要开发者、测试人员和负责人，而不是告警泛滥。&lt;/li&gt;
&lt;li&gt;精准的告警直达某中间件中的某表或某队列、某交换机，继而转发至对应团队、对应负责人来处理。&lt;/li&gt;
&lt;li&gt;准确的关联关系构建，细粒度的产品角度去为不同问题筛选出不同的可观测性视角，而不是千篇一律的 DashBoard（举例 Grafana的筛选栏）。&lt;/li&gt;
&lt;li&gt;完整的关联关系、准确无误的为高阶可观测性系统能力做铺垫，例如根因分析、错误自愈、缩容扩容自动化等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，急剧扩充的元数据会让可观测性多信号的数据暴涨，也会带来一些其他的问题，那这些问题该如何解决呢，请&lt;strong&gt;关注我们下期的直播内容&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;那其实我们今天讲的蛮浅的，从&lt;strong&gt;智能驾驶来看可观测性的发展&lt;/strong&gt;作为引入，然后我们依据一个案例来分析在这个过程中，我们&lt;strong&gt;使用开源产品遇到的多信号关联的挑战&lt;/strong&gt;，继而引出了我们构建一个这样的&lt;strong&gt;元数据平台&lt;/strong&gt;，并且需要&lt;strong&gt;维护什么样&lt;/strong&gt;的数据作为结尾，最终我们聊了下构建出这样的元数据平台为我们可观测性平台&lt;strong&gt;带来了什么样的价值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那构建 IT 的可观测性是一件复杂而又重要的事情，元数据为&lt;strong&gt;多信号之间关联&lt;/strong&gt;和&lt;strong&gt;产品的健壮性&lt;/strong&gt;带来了重要的作用。当然 OTel 为这项工作带来了不少便利，但是还会有更多的挑战在等着我们！&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 架构图&#34; srcset=&#34;
               /blog/the-importance-of-metadata-in-observability/9_hue60391dc0787fbfd90bac3b07e419a85_137347_9453e8d9f31a9993b06f3ad68591d029.webp 400w,
               /blog/the-importance-of-metadata-in-observability/9_hue60391dc0787fbfd90bac3b07e419a85_137347_7833fab40cca3e434f851b358afdaf36.webp 760w,
               /blog/the-importance-of-metadata-in-observability/9_hue60391dc0787fbfd90bac3b07e419a85_137347_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-importance-of-metadata-in-observability/9_hue60391dc0787fbfd90bac3b07e419a85_137347_9453e8d9f31a9993b06f3ad68591d029.webp&#34;
               width=&#34;760&#34;
               height=&#34;331&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后重点来啦，&lt;strong&gt;DeepFlow&lt;/strong&gt; 作为新时代的高度自动化的可观测性平台，将为大家带来意想不到的能力。&lt;/p&gt;
&lt;p&gt;大家对我们的产品的第一印象可能是 使用了 eBPF，但是我想告诉大家的是，我们产品&lt;strong&gt;不仅仅使用了一些炫酷的技术&lt;/strong&gt;，也会有比上述更加炫酷的&lt;strong&gt;类似元数据平台的功能&lt;/strong&gt;，并且对比其他产品具备&lt;strong&gt;无侵入的高度观测能力&lt;/strong&gt;、炫酷的 AutoTagging 技术和&lt;strong&gt;大幅度降低存储压力&lt;/strong&gt;的 SmartEncoding 能力等优点，欢迎大家关注我们的 Github 和公众号来了解更多。&lt;/p&gt;
&lt;p&gt;当然刚才提到了，后面几期我们会有专题来介绍 AutoTagging 和 SmartEncoding能力，欢迎大家预定后面的直播。&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&#34;https://ce-demo.DeepFlow.yunshan.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow Online Demo&lt;/a&gt;，体验高度自动化的可观测性新时代。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/blog/cloud-native-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生下的可观测性发展方向&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%85%83%E6%95%B0%E6%8D%AE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;维基百科中的元数据的定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E5%85%83%E6%95%B0%E6%8D%AE/1946090&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;百度百科中的元数据的定义&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>DeepFlow 开启 Kube-OVN CNI Kubernetes 集群的可观测性</title>
      <link>https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/</link>
      <pubDate>Fri, 21 Oct 2022 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/</guid>
      <description>&lt;p&gt;本文为云杉网络原力释放 - 云原生可观测性分享会第十期直播实录。&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzA3ODM4ODIzNQ==&amp;amp;mid=2650725660&amp;amp;idx=1&amp;amp;sn=941fb54698dd8602511741b79fb26f92&amp;amp;chksm=8749f078b03e796ec928cd910aa92291918cb6250f5447eb8f877d9001a64312649ef5914cba#rd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;回看链接&lt;/a&gt;，&lt;a href=&#34;http://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/yunshan-ticket/pdf/6cb85592e56e6c0764e4a2300ae00448_20221017154248.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PPT下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;大家好，我是云杉网络 DeepFlow 的云原生工程师宋建昌，今天给大家带来的主题是 《 DeepFlow 在 Kube-OVN 环境的可观测实践》&lt;/p&gt;
&lt;p&gt;今天讲解的主要内容是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一：DeepFlow 高度自动化的可观测性能力；&lt;/li&gt;
&lt;li&gt;第二：DeepFlow 一键开启 Kube-OVN 的可观测性；&lt;/li&gt;
&lt;li&gt;第三：DeepFlow 在 Kube-OVN 环境下的实际应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x0-deepflow-高度自动化的可观测性能力&#34;&gt;0x0: DeepFlow 高度自动化的可观测性能力&lt;/h1&gt;
&lt;p&gt;为什么需要可观测性，以及可观测的概念前面几期已经讲解过了，我再简单聊一下 DeepFlow 的架构、能力，方便不太熟悉 DeepFlow 的同学快速了解 DeepFlow 的背景：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow架构&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/3_hu7828ddca592c3699ec9a6198663bdedd_320539_e55f9f392fd4a56b86faec2f96f8d96b.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/3_hu7828ddca592c3699ec9a6198663bdedd_320539_28cee15ea3ef206c4231e6c2ae6ff204.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/3_hu7828ddca592c3699ec9a6198663bdedd_320539_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/3_hu7828ddca592c3699ec9a6198663bdedd_320539_e55f9f392fd4a56b86faec2f96f8d96b.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Rust 实现的 deepflow-agent 作为 frontend 采集数据，并与 K8s apiserver 同步资源和 Label 信息；Golang 实现的 deepflow-server 作为 backend 负责管理控制、负载均摊、存储查询。我们使用 MySQL 存储元数据，使用 ClickHouse 存储观测数据并支持扩展替换，使用 Grafana 展示观测数据。目前我们还有一个 Python 实现的 DeepFlow-app 进程用于提供分布式追踪的 API，后续将会使用 Golang 重写并逐步合并到 deepflow-server 中。deepflow-server 向上提供 SQL API，我们基于此开发了 Grafana 的 DeepFlow DataSource 和拓扑、分布式追踪等 Panel。deepflow-agent 可以运行在主机或 K8s 环境下，但 deepflow-server 必须运行在 K8s 中。&lt;/p&gt;
&lt;p&gt;AutoTagging 能力。我们为 DeepFlow 的所有原生数据和集成数据都自动注入了大量的标签，使得数据关联不再有屏障、数据下钻不再有缺陷。这些标签来自云资源、K8s 资源、K8s 自定义 Label，至于和业务相关的动态标签，DeepFlow 也会以非常高效的方式完整的存储下来，支持检索和聚合。&lt;/p&gt;
&lt;p&gt;DeepFlow 基于 BPF 的 AutoMetrics 能力可自动获取每一个微服务的 API 调用在应用函数、系统函数和网络通信等全栈路径上的黄金性能指标，并通过 BPF 和 AF_PACKET/winpcap 将这些能力扩展到更广泛的 Linux 内核版本及 Windows 操作系统。
目前，DeepFlow 已经通过 eBPF 支持了主流应用协议的解析，包括 HTTP 1/2/S、Dubbo、MySQL、Redis、Kafka、MQTT、DNS，未来还将扩展更多应用协议的支持。基于 DeepFlow 的 AutoMetrics 能力，能够零侵扰的获取应用的 RED（Request、Error、Delay）指标、网络协议栈的吞吐、时延、建连异常、重传、零窗等指标。DeepFlow Agent 会维护每个 TCP 连接、每个应用协议 Request 的会话状态，称之为 Flow。所有原始性能指标数据精细至 Flow 粒度，并额外自动聚合为 1s、1min 指标数据。基于这些指标数据，我们可呈现任意服务、工作负载、API 的全栈性能数据，并可绘制任意服务之间的调用关系拓扑图 —— Universal Service Map。&lt;/p&gt;
&lt;p&gt;基于 eBPF，DeepFlow 创新的实现了零侵扰的分布式追踪。DeepFlow 将 eBPF Event、BPF Packet、Thread ID、Coroutine ID、Request 到达时序、TCP 发送时序进行关联，实现了高度自动化的分布式追踪（AutoTracing）。目前 AutoTracing 支持所有同步阻塞调用（BIO，Blocking IO）场景、部分同步非阻塞调用（NIO，Non-blocking IO）场景，支持内核线程调度（kernel-level threading (opens new window)）场景，在这些场景下支持对任意服务组成的分布式调用链进行追踪。除此之外，通过解析请求中的 X-Request-ID 等字段，也支持对采用 NIO 模式的网关（如 Envoy）前后的调用链进行追踪。&lt;/p&gt;
&lt;p&gt;以及自动采集应用调用日志和流日志的 AutoLogging 技术等。&lt;/p&gt;
&lt;p&gt;我平时经常活跃于社群里面，经常有社区同学给我反馈一些问题等，其中有小伙伴反馈说内部推荐都不知道那些点可以用来说，具体解决什么问题。不知道如何界定使用场景，这次站在解决问题这个角度，来看一下DeepFlow可以定位什么具体问题，怎么定位问题。&lt;/p&gt;
&lt;p&gt;第一个场景，可能某天突然有个数据库节点负载、流量的告警发过来了，怎么快速定位到哪个服务请求数据库的流量变多，哪些SQL突然变多，然后下一步怎么去看上游服务的 api 调用情况:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-快速定位异常sql&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;快速定位异常SQL&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/4_hu7828ddca592c3699ec9a6198663bdedd_425998_d51a149432a3b6f053034c06dcc4ce10.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/4_hu7828ddca592c3699ec9a6198663bdedd_425998_807bf10eb600ab3e48e03cf8f94bab1a.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/4_hu7828ddca592c3699ec9a6198663bdedd_425998_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/4_hu7828ddca592c3699ec9a6198663bdedd_425998_d51a149432a3b6f053034c06dcc4ce10.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      快速定位异常SQL
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;以往这类问题单纯从数据库的角度可能不太容易得到客户端分组精确的指标数据，但是现在有了DeepFlow就可以在看数据去定位问题：&lt;/p&gt;
&lt;p&gt;这页PPT中的第一个 panel 可以看到慢查询的 SQL ，找到慢请求；&lt;/p&gt;
&lt;p&gt;第二个 panel 可以看到和数据库有交互的服务请求数据库的流量大小，查找到请求流量较多的服务；&lt;/p&gt;
&lt;p&gt;第三个 panel 可以看到和数据库有交互的服务请求数量，查找到请求数量较多的服务；&lt;/p&gt;
&lt;p&gt;第四个 panel 可以看到和数据库请求 SQL 的 top 数据，查找较多的 SQL 的请求数量，进而快速找到对应的模块和相关研发；
然后切换协议到 ALL 或者 HTTP ，切换 workload 到上游服务，继续排查上游服务的情况：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-快速定位上游服务异常api&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;快速定位上游服务异常API&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/5_hu7828ddca592c3699ec9a6198663bdedd_397565_3b6e4ba194a48e43f97ba82041cea940.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/5_hu7828ddca592c3699ec9a6198663bdedd_397565_86c955d69e197f4f79535c3bd9625e70.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/5_hu7828ddca592c3699ec9a6198663bdedd_397565_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/5_hu7828ddca592c3699ec9a6198663bdedd_397565_3b6e4ba194a48e43f97ba82041cea940.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      快速定位上游服务异常API
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第二个场景，响应变慢：如何判断延迟在应用、网络、还是数据库：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-1663828883603png&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;1663828883603.png&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/6_hu7828ddca592c3699ec9a6198663bdedd_266490_d6f30dcbfdbbd212d17364200b9f4785.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/6_hu7828ddca592c3699ec9a6198663bdedd_266490_a405cc36a7e17deb14ee952839a32c0a.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/6_hu7828ddca592c3699ec9a6198663bdedd_266490_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/6_hu7828ddca592c3699ec9a6198663bdedd_266490_d6f30dcbfdbbd212d17364200b9f4785.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      1663828883603.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过一个 trace ，查看 span 长度即可，图中 S 开头的是 eBPF 采集到的系统 span ， N 是网络 span ，A 是应用 span，最下面有两个很短的紫色的是数据库的系统 span。
我们在内核版本4.14+的环境中会自动开启 eBPF，不需要业务进行任何插码、重启等操作，即可开启这个能力。&lt;/p&gt;
&lt;p&gt;第三个场景，业务异常：如何快速找到服务端口/接口异常：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-快速发现问题接口&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;快速发现问题接口&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/7_hu7828ddca592c3699ec9a6198663bdedd_361355_5598341e35d70e199adbd0d408ffaa12.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/7_hu7828ddca592c3699ec9a6198663bdedd_361355_c6280e2ee5631f8f62259bf6136ff15a.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/7_hu7828ddca592c3699ec9a6198663bdedd_361355_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/7_hu7828ddca592c3699ec9a6198663bdedd_361355_5598341e35d70e199adbd0d408ffaa12.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      快速发现问题接口
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;有同学反馈有些缓存等服务挂掉了，影响了业务的响应情况，但是又不影响业务运行，没有及时发现并响应这个问题，这个场景在 DeepFlow 中就可以通过一个统计错误响应的端口的 Dashboard ，并根据端口、Pod、vm等资源快速找到对应到节点及服务，排查端口挂掉原因，以及我们已经规划了6.1.4版本可以配置Grafana告警，也会内置一些告警策略，可以通过 Grafana 告警来等功能快速感知并响应问题。&lt;/p&gt;
&lt;p&gt;可能会有同学问为什么我部署的 DeepFlow 中没有刚刚的 Dashboard ，我们目前发现了现有的 Grafana 在排障中的一些不足，我们也和 DeepFlow 的用户讨论了实际需求，正在整理相关的 Dashboard ，大家也可以自己构造自己的Dashboard，如果觉着不错也可以提交PR到 DeepFlow 下的 dahsboard 的 repo 中，分享给所有的 DeepFlow 用户。当然也欢迎给我们反馈你的痛点、场景，我们通过 Grafana 展示 出来 DeepFlow 的数据来解决大家的痛点。&lt;/p&gt;
&lt;h1 id=&#34;0x1-deepflow-一键开启-kube-ovn-的可观测性&#34;&gt;0x1: DeepFlow 一键开启 Kube-OVN 的可观测性&lt;/h1&gt;
&lt;p&gt;上面简单聊了一下 DeepFlow 在几个场景中如何排查问题，进入今天的主题 DeepFlow + Kube-OVN 一键可观测：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-ovn-环境中快速部署-deepflow&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kube-OVN 环境中快速部署 DeepFlow&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/9_hu7828ddca592c3699ec9a6198663bdedd_158171_8e0b144a13c5ea58a34ac1d1557f3cc1.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/9_hu7828ddca592c3699ec9a6198663bdedd_158171_3530d5d9a8cdd43e2ea69f64b4b15660.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/9_hu7828ddca592c3699ec9a6198663bdedd_158171_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/9_hu7828ddca592c3699ec9a6198663bdedd_158171_8e0b144a13c5ea58a34ac1d1557f3cc1.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kube-OVN 环境中快速部署 DeepFlow
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;正如同PPT中看到的这样，简单三条命令就可以将 DeepFlow 部署在 Kube-OVN 的集群中，观测你K8s集群上所有数据的同时又不需要业务进行任何改动、任何重启
同时我们还支持接入多集群 agent ，接入云主机、传统服务器的 agent ，接入 Prometheus 、Telegraf 的 Metrics数据，以及可以通过 otel-collector 接入符合 OpenTelemetry 协议的 trace 数据、Skywalking 的trace 数据等等，对这些数据通过 AutoTagging 能力统一打上 DeepFlow 的 label ，和 DeepFlow 的资源关联起来，打通数据孤岛。&lt;/p&gt;
&lt;p&gt;安装完 DeepFlow 之后，会默认内置一些 Dashboard ，这里简单介绍一下这几个 Dashboard ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络可观测
&lt;ul&gt;
&lt;li&gt;Node/Pod 的流量拓扑&lt;/li&gt;
&lt;li&gt;Node/Pod 流日志&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用可观测
&lt;ul&gt;
&lt;li&gt;服务性能总览&lt;/li&gt;
&lt;li&gt;微服务调用拓扑&lt;/li&gt;
&lt;li&gt;服务调用日志&lt;/li&gt;
&lt;li&gt;调用链追踪 (Distributed Tracing)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-node-流量拓扑&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Node 流量拓扑&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/11_hu7828ddca592c3699ec9a6198663bdedd_343962_3a31872e32c436ce1f80307957fcc7a7.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/11_hu7828ddca592c3699ec9a6198663bdedd_343962_c4c0230c8b4457a1caaaaed29c2fe66f.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/11_hu7828ddca592c3699ec9a6198663bdedd_343962_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/11_hu7828ddca592c3699ec9a6198663bdedd_343962_3a31872e32c436ce1f80307957fcc7a7.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Node 流量拓扑
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这一个是我们的 Node 流量拓扑，可以清晰的展示出来 Node 之间、Node 和 Pod 的流量关系，以及右侧的吞吐、重传比例 建联失败比例等指标&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-pod-流量拓扑&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Pod 流量拓扑&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/12_hu7828ddca592c3699ec9a6198663bdedd_318273_3d2cdcf8eadea2beee383222ca6c3611.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/12_hu7828ddca592c3699ec9a6198663bdedd_318273_c87b7832973ffdbf2f64c2351fe0dfe3.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/12_hu7828ddca592c3699ec9a6198663bdedd_318273_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/12_hu7828ddca592c3699ec9a6198663bdedd_318273_3d2cdcf8eadea2beee383222ca6c3611.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Pod 流量拓扑
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第二个是我们的 Pod 流量拓扑，可以清晰的展示出来 Pod 之间的流量关系，以及右侧的吞吐、重传 建联失败等指标&lt;/p&gt;
&lt;p&gt;把鼠标放到两个 Pod 的连线上可以看到两个 Pod 之间的指标，比如可以通过 tap_side 看出采集位置是在客户端和服务端、pps 、重传、建连失败、延迟等指标&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-pod-拓扑中发现的-kube-ovn-配置异常&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Pod 拓扑中发现的 Kube-OVN 配置异常&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/13_hu7828ddca592c3699ec9a6198663bdedd_505484_5a59d90e25d59e8e931bcc0d246616f7.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/13_hu7828ddca592c3699ec9a6198663bdedd_505484_aa56eaf025957d5e4ce55b05ddeea316.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/13_hu7828ddca592c3699ec9a6198663bdedd_505484_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/13_hu7828ddca592c3699ec9a6198663bdedd_505484_5a59d90e25d59e8e931bcc0d246616f7.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Pod 拓扑中发现的 Kube-OVN 配置异常
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里有个小插曲，我上周在做这篇PPT的时候，使用 sealos 一键拉起了一个 Kube-OVN、DeepFlow 的环境，但是发现 Pod 的拓扑图没有连接起来，左侧是异常的拓扑图，右侧是使用Kube-OVN官网脚本部署的 Kube-OVN1.8.8 版本的正常数据，稍微看一下发现所有跨节点的流量在拓扑图里展示的都是客户端节点 ovn0 网卡的 IP，而不是客户端 Pod IP，怀疑是解封装的时候源IP有了问题，梦馨反馈是 sealos 的部署脚本里默认把 ovn-lb 给关了，svc 路径上的处理有的地方被 NAT 了，把 kube-ovn-controller 里的 enable-lb 改成 true 应该就行了，这里也致敬一下 sealos，基于 sealos 的集群镜像功能，可以一键拉起一个部署好 Kube-OVN、DeepFlow、Helm 等应用、工具的 K8s 集群，节省了大量的时间和精力。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-node-流日志展示&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Node 流日志展示&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/14_hu7828ddca592c3699ec9a6198663bdedd_318779_b708e565ede384bec8e82a1ce94483ca.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/14_hu7828ddca592c3699ec9a6198663bdedd_318779_b58f485f245cc8cb118eb94a04af6465.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/14_hu7828ddca592c3699ec9a6198663bdedd_318779_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/14_hu7828ddca592c3699ec9a6198663bdedd_318779_b708e565ede384bec8e82a1ce94483ca.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Node 流日志展示
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这一个是我们的 Node 流日志，可以看到 Node 之间的每个流的情况，所谓流日志是捕获特定位置的流量，将流量转化为流日志记录下来，流日志是记录捕获特定时间窗口的特定五元组的网络流。&lt;/p&gt;
&lt;p&gt;这个 Dashboard 以 Node 维度看流日志总量、错误数量、TCP 建连时延、传输时延等情况，以及每一个流的开始时间、客户端、服务端、流量采集位置、协议、客户端口、服务端口、状态、发送、接收流量大小、客户端、服务端重传、TCP 建连、传输时延等数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-pod-流日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Pod 流日志&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/15_hu7828ddca592c3699ec9a6198663bdedd_324861_19998eb74fb031d80d0ba595e9cf6645.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/15_hu7828ddca592c3699ec9a6198663bdedd_324861_c47ee8cabb5ccdba1eb7a160cd5b7cac.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/15_hu7828ddca592c3699ec9a6198663bdedd_324861_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/15_hu7828ddca592c3699ec9a6198663bdedd_324861_19998eb74fb031d80d0ba595e9cf6645.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Pod 流日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个 Dashboard 以 Pod 维度以看流日志总量、错误数量、TCP 建连时延、传输时延等情况，以及每一个流的开始时间、客户端、服务端、流量采集位置、协议、客户端口、服务端口、状态、发送、接收流量大小、客户端、服务端重传、TCP建连、传输时延等数据。&lt;/p&gt;
&lt;p&gt;前面的 Dashboard 是在网络层面的统计数据，后面几个是在应用层面的统计数据:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务性能总览&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;服务性能总览&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/16_hu7828ddca592c3699ec9a6198663bdedd_358090_fb9f759881f5729ad15e59838331b8bf.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/16_hu7828ddca592c3699ec9a6198663bdedd_358090_1d7f0f170bb5698596584c4f80cd1792.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/16_hu7828ddca592c3699ec9a6198663bdedd_358090_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/16_hu7828ddca592c3699ec9a6198663bdedd_358090_fb9f759881f5729ad15e59838331b8bf.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务性能总览
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务性能总览：上面是有发送的请求数量、错误数量及延迟等，以及 Pod 维度的 协议分组的请求数量、客户端错误比例、服务端错误比例及延迟等:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-微服务调用总览&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;微服务调用总览&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/17_hu7828ddca592c3699ec9a6198663bdedd_317044_ca17e19d3d5e83bce165630a88259aa8.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/17_hu7828ddca592c3699ec9a6198663bdedd_317044_ab8da9d74ea7bca3cfd2fbf50f80ff19.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/17_hu7828ddca592c3699ec9a6198663bdedd_317044_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/17_hu7828ddca592c3699ec9a6198663bdedd_317044_ca17e19d3d5e83bce165630a88259aa8.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      微服务调用总览
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务调用拓扑，和前面 Pod 流量拓扑有什么不同呢，前面的 Pod map 是基于4层流量画出来的拓扑，这个是基于7层请求的流量画出来的，拓扑、请求、错误延迟等指标、以及区分客户端、服务端的请求、错误、延迟的指标数据：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-微服务调用日志展示&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;微服务调用日志展示&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/18_hu7828ddca592c3699ec9a6198663bdedd_353372_4798557773bd02fc1227ea6f1fb852d1.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/18_hu7828ddca592c3699ec9a6198663bdedd_353372_d6f8a1d10a5e5b3a038868560e0c406b.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/18_hu7828ddca592c3699ec9a6198663bdedd_353372_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/18_hu7828ddca592c3699ec9a6198663bdedd_353372_4798557773bd02fc1227ea6f1fb852d1.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      微服务调用日志展示
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;服务调用日志，
上面有7层请求的总量、错误数量、延迟等指标
下面可以看到每一个应用调用的开始时间、客户端、服务端、对应的协议、方法、请求域名、请求资源、状态、响应码等数据&lt;/p&gt;
&lt;p&gt;这个就是我们的一个基于 eBPF 的 AutoTracing 能力，内核大于4.14+ 不需要业务进行任何改动即可开启这个能力：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-调用链追踪-tracing&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;调用链追踪 (tracing)&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/19_hu7828ddca592c3699ec9a6198663bdedd_300944_7e5ad5b54e31515d84e9ca8207977ea2.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/19_hu7828ddca592c3699ec9a6198663bdedd_300944_373515763ea5abb7945d2f78aa9975f4.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/19_hu7828ddca592c3699ec9a6198663bdedd_300944_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/19_hu7828ddca592c3699ec9a6198663bdedd_300944_7e5ad5b54e31515d84e9ca8207977ea2.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      调用链追踪 (tracing)
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;以上所有的截图都是在Kube-OVN的环境中截的，安装DeepFlow后几分钟就能看到上面说的所有数据。&lt;/p&gt;
&lt;h1 id=&#34;0x2-deepflow-对-kube-ovn-的实际应用&#34;&gt;0x2: DeepFlow 对 Kube-OVN 的实际应用&lt;/h1&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-增强-kube-ovn-diagnose-工具的可观测能力&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 增强 Kube-OVN diagnose 工具的可观测能力&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/21_hu7828ddca592c3699ec9a6198663bdedd_454760_7a7064f906edc399ce6451f05e73dc3b.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/21_hu7828ddca592c3699ec9a6198663bdedd_454760_0755b71ae20bc8069272f84a30bf813a.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/21_hu7828ddca592c3699ec9a6198663bdedd_454760_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/21_hu7828ddca592c3699ec9a6198663bdedd_454760_7a7064f906edc399ce6451f05e73dc3b.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 增强 Kube-OVN diagnose 工具的可观测能力
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;diagnose 作为 Kube-OVN 的网络组件状态检查工具，可以一键检测 Kube-OVN 组件的状态、本节点、跨节点的关键服务的连通性和网络延迟情况等，可以快速获得检测数据，定位系统问题。&lt;/p&gt;
&lt;p&gt;DeepFlow 的定位是一个云原生无侵入的可观测平台，可以大幅增强 Kube-OVN 环境的可观测能力，通过丰富的数据可以画出任何想要的 Dashboard，比如前面讲到的接口/SQL调用时延趋势图及端口的错误请求数量趋势图等，可以快速看到有问题的服务、端口、接口等，帮助快速定位到相关有问题的服务/模块，甚至可以通过 Grafana 进行告警，在出现问题的第一时间进行响应，减小损失。也可以观察整个集群/服务的当前状态，统计一个时间段内的服务响应情况等：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-增强-kube-ovn-的观测能力&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 增强 Kube-OVN 的观测能力&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/22_hu7828ddca592c3699ec9a6198663bdedd_222759_f95b3ba063a8b2a4700d5eabb9a39022.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/22_hu7828ddca592c3699ec9a6198663bdedd_222759_315bb2cbbbf989fafee2bdd3dc642ba0.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/22_hu7828ddca592c3699ec9a6198663bdedd_222759_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/22_hu7828ddca592c3699ec9a6198663bdedd_222759_f95b3ba063a8b2a4700d5eabb9a39022.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 增强 Kube-OVN 的观测能力
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;流量采集位置：我们默认会在容器节点的物理网卡及容器内 eth0 网卡在节点的 veth-peer 网卡上采集cBPF流量，通过 eBPF 采集进程 span 信息，Kube-OVN 的默认容器网卡名称为 containerID_h
，并对流量进行关联节点、Pod 等资源，那么这个图是在同子网跨节点场景的一个架构图，实际上在跨 VPC、双栈等场景采集方式都是一样的，并没有任何区别。&lt;/p&gt;
&lt;p&gt;隧道解封装：DeepFlow 会查看所有包是否有封装，一旦看到有封装，就会进行解封装操作，目前默认开启了vxlan和IPIP隧道等解封装，也就是在容器节点的 eth0 网卡上的 Pod 流量是经过了封装的，不过我们会自动解开，并获取解封装后的流量源 IP、目标 IP 等数据关联客户端服务端的 Pod 等资源。
Kube-OVN 的 geneve 隧道如果大家用的比较多，也可以反馈给我们，我们支持一下这个协议的隧道解析.&lt;/p&gt;
&lt;p&gt;跨 Node 流量如何关联：我们的 deepflow-agent 以 daemonset 部署在所有节点上,我们通过五元组等信息可以判断到跨 Node 的同一个流，并统计在每个流量采集位置的网络吞吐到性能，再到时延多个维度的指标量。&lt;/p&gt;
&lt;p&gt;流量关联 Pod、Node 等资源：agent 会 watch K8s 集群的资源，获取 NodeIP、mac、deployment、svc、Pod 等信息,并上报给 server，通过 AutoTagging 能力对 agent 采集到的流量进行关联对应的资源，在 Grafana 上看到的流量就不是枯燥的 IP MAC 等信息了，而是 Pod、Node 等资源：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络通信场景追踪&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络通信场景追踪&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/23_hu7828ddca592c3699ec9a6198663bdedd_268328_9cc634b7a3792de7106859c55250649a.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/23_hu7828ddca592c3699ec9a6198663bdedd_268328_ae663c52e413baa836c4ac497ea9d8b7.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/23_hu7828ddca592c3699ec9a6198663bdedd_268328_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/23_hu7828ddca592c3699ec9a6198663bdedd_268328_9cc634b7a3792de7106859c55250649a.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络通信场景追踪
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;NetworkPolicy 为 Kubernetes 提供的网络策略接口，Kube-OVN 通过 OVN 的 ACL 进行了实现。 使用了 NetworkPolicy 后如果出现网络不通的情况，难以判断是网络故障问题还是 NetworkPolicy 规则设置问题导致的网络中断。 Kube-OVN 提供了 NetworkPolicy 日志功能，帮助管理员快速定位 NetworkPolicy drop 规则是否命中，并记录有哪些非法访问。&lt;/p&gt;
&lt;p&gt;NetworkPolicy 日志功能一旦开启，对每个命中 drop 规则的数据包都需要打印日志，会带来额外性能开销。&lt;/p&gt;
&lt;p&gt;而DeepFlow虽然目前无法判断流量是被 drop 了还是网络问题，但是从 DeepFlow 的多个维度以及熟悉 K8s networkpolicy 功能的同学还是能大概判断出流量是被 networkpolicy drop 掉了，DeepFlow也规划了流状态的功能。&lt;/p&gt;
&lt;p&gt;Kube-OVN 可以的流日志基本判断出流量是被 drop 了还是网络故障，让我想起了之前遇到的场景，研发反馈一个开发环境的一个 Namespace 下的 Pod 突然 Ping 不通了，接到问题后和研发一起开始排查，发现 Node 和除这个 Namespace 下的 Pod 网络都是通的，但是又无法解释为啥从 Node Ping 这个 NS 下的 Pod 网络不通了，然后突然发现我们容器云产品页面上的网络策略功能被打开了，这个功能藏的有些深，一般不去看这个地方，后来确认是产品不熟悉这个功能，就点了一下，但没有及时关闭导致的，现在回头想一下，如果当时有 Kube-OVN 的 networkpolicy 日志功能或者 DeepFlow ，可能10分钟就能知道流量是被网络策略给 drop 掉了：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-自动生成网络流日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;自动生成网络流日志&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/24_hu7828ddca592c3699ec9a6198663bdedd_557315_f08aa04ea71dbd419e9b71550172301d.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/24_hu7828ddca592c3699ec9a6198663bdedd_557315_20e3e1321b9387334c6e383bcf5972e8.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/24_hu7828ddca592c3699ec9a6198663bdedd_557315_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/24_hu7828ddca592c3699ec9a6198663bdedd_557315_f08aa04ea71dbd419e9b71550172301d.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      自动生成网络流日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-网络流日志功能和-kube-ovn-networkpolicy-日志功能的差异&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 网络流日志功能和 Kube-OVN NetworkPolicy 日志功能的差异&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/25_hu7828ddca592c3699ec9a6198663bdedd_255722_4757c3746ae3c15020c4af69f856ae69.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/25_hu7828ddca592c3699ec9a6198663bdedd_255722_8e2ca03303a3facd13c68f180bb69fa7.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/25_hu7828ddca592c3699ec9a6198663bdedd_255722_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/25_hu7828ddca592c3699ec9a6198663bdedd_255722_4757c3746ae3c15020c4af69f856ae69.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 网络流日志功能和 Kube-OVN NetworkPolicy 日志功能的差异
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;DeepFlow对后端分析工具更友好，当然这个功能只在我们企业版本中有，下面是我们 DeepFlow 在流量分发功能上对 Kube-OVN的增强：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-增强-kube-ovn-的流量分发能力&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 增强 Kube-OVN 的流量分发能力&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/26_hu7828ddca592c3699ec9a6198663bdedd_322417_bf4022819bc4de5bdf66c17138e2d111.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/26_hu7828ddca592c3699ec9a6198663bdedd_322417_ca71a5842686b02550cb6a46a546cda4.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/26_hu7828ddca592c3699ec9a6198663bdedd_322417_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/26_hu7828ddca592c3699ec9a6198663bdedd_322417_bf4022819bc4de5bdf66c17138e2d111.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 增强 Kube-OVN 的流量分发能力
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow-增强-kube-ovn-的流量分发能力&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow 增强 Kube-OVN 的流量分发能力&#34; srcset=&#34;
               /blog/enable-the-observability-of-kube-ovn-cni-environment/27_hu7828ddca592c3699ec9a6198663bdedd_188031_a5eb87e260063459a80c1f5a3809a00b.webp 400w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/27_hu7828ddca592c3699ec9a6198663bdedd_188031_11c7fca19fec2e65d625f9b8d576d8be.webp 760w,
               /blog/enable-the-observability-of-kube-ovn-cni-environment/27_hu7828ddca592c3699ec9a6198663bdedd_188031_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/enable-the-observability-of-kube-ovn-cni-environment/27_hu7828ddca592c3699ec9a6198663bdedd_188031_a5eb87e260063459a80c1f5a3809a00b.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow 增强 Kube-OVN 的流量分发能力
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;面向业务的流量过滤&lt;/strong&gt;：用户可设置源端地址、端口号、目的端地址、端口号、协议五元组作为过滤条件，并支持直接输入VPC、子网、云服务器、容器 Pod、自定义资源组等替代IP地址，精准过滤虚拟网络中的流量，最大利用网络带宽和分析工具效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;源端 Payload 截断&lt;/strong&gt;：用户可设置对网包的 L4 Payload 长度进行截断，最大利用网络带宽和分析工具效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多层流量标签&lt;/strong&gt;：分发流量利用隧道封装发送，通过在隧道头中携带特殊的流量标签，用于对不同 VPC 、容器服务、流量采集位置（客户端/服务端）等流量属性进行标记，以帮助后端分析工具解决 VPC 之间 IP 段冲突、容器服务后端 Pod 的 IP 地址频繁变动等问题，并实现对客户端、服务端采集流量进行端到端对比分析。
采集器支持在原始包之前添加 VXLAN 或 ERSPAN 隧道及内层 VLAN 标签，后端汇聚分流设备或 TAP 交换机仅需要做一次性的隧道解封装配置，无需根据不同的隧道标签解封装报文的 VLAN 标签，极大简化分流设备/TAP 交换机的配置复杂度和特性依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;流量全局去重&lt;/strong&gt;：对于同一个网包，采集器会在源端云服务器及目的端云服务器处多次采集到。当发往同一个分发点时，如果不做去重，后端分析工具将收到重复的网包，同时也会占用至少双倍的带宽。DeepFlow 引入分布式去重功能解决重复采集的问题，具体原理可查看场景介绍。
为了最大限度减少对带宽的占用，对发往同一个分发点、设置相同隧道标签的同一个网包，按所有匹配策略的最大Payloady截取长度进行截取。例如两条分发策略 A=Payload截断30、B=Payload 截断20，对于同时匹配这两条策略的网包将会被截取30字节 Payload 后进行发送。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;流量多路分发&lt;/strong&gt;：当一个网包匹配的多条分发策略对应不同分发点或不同隧道标签时，流量将会复制多份分别发送。例如两条策略 A=分发点 C1、B=分发点 C2，对于同时匹配这两条策略的网包，在分发时复制两份，一份分发给 C1，一份分发给 C2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;资源变更感知&lt;/strong&gt;：当云服务器迁移、云服务器IP变更、容器Pod弹性伸缩时，分发策略自动感知，无需用户重新设置，迁移期间的流量持续分发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;0x3-什么是-deepflow&#34;&gt;0x3: 什么是 DeepFlow&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/DeepFlowys/DeepFlow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow&lt;/a&gt; 是一款开源的高度自动化的可观测性平台，是为云原生应用开发者建设可观测性能力而量身打造的全栈、全链路、高性能数据引擎。DeepFlow 使用 eBPF、WASM、OpenTelemetry 等新技术，创新的实现了 AutoTracing、AutoMetrics、AutoTagging、SmartEncoding 等核心机制，帮助开发者提升埋点插码的自动化水平，降低可观测性平台的运维复杂度。利用 DeepFlow 的可编程能力和开放接口，开发者可以快速将其融入到自己的可观测性技术栈中。&lt;/p&gt;
&lt;p&gt;GitHub 地址：https://github.com/DeepFlowys/DeepFlow&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&#34;https://ce-demo.DeepFlow.yunshan.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow Online Demo&lt;/a&gt;，体验高度自动化的可观测性新时代。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DeepFlow AutoLogging 介绍：自动采集应用调用日志和流日志</title>
      <link>https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/</link>
      <pubDate>Fri, 14 Oct 2022 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/</guid>
      <description>&lt;p&gt;本文为云杉网络&lt;code&gt;原力释放 - 云原生可观测性分享会&lt;/code&gt;第九期直播实录。&lt;a href=&#34;https://www.bilibili.com/video/BV1Z14y147XM?spm_id_from=333.337.search-card.all.click&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;回看链接&lt;/a&gt;，&lt;a href=&#34;http://yunshan-guangzhou.oss-cn-beijing.aliyuncs.com/yunshan-ticket/pdf/f9d3931bd360757b30b91d93d1aa9621_20220823171717.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PPT下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;DeepFlow 是一款开源的高度自动化的可观测性平台，是为云原生应用开发者建设可观测性能力而量身打造的全栈、全链路、高性能数据引擎。DeepFlow 使用 eBPF、WASM、OpenTelemetry 等新技术，创新的实现了 AutoTracing、AutoMetrics、AutoTagging、SmartEncoding 等核心机制，帮助开发者提升埋点插码的自动化水平，降低可观测性平台的运维复杂度。利用 DeepFlow 的可编程能力和开放接口，开发者可以快速将其融入到自己的可观测性技术栈中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-deepflow---架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DeepFlow - 架构图&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630472cfdd6cc_huc2aad606b97861a70cfe5cda2c879b2d_243567_1a77528a697b143b907e8033374cb74d.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630472cfdd6cc_huc2aad606b97861a70cfe5cda2c879b2d_243567_1e08ffab7b50e60627cf94ca356034ed.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630472cfdd6cc_huc2aad606b97861a70cfe5cda2c879b2d_243567_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630472cfdd6cc_huc2aad606b97861a70cfe5cda2c879b2d_243567_1a77528a697b143b907e8033374cb74d.webp&#34;
               width=&#34;760&#34;
               height=&#34;431&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DeepFlow - 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今天的内容是云杉网络“云原生可观测性分享会”的直播里面第八期&lt;a href=&#34;https://deepflow.yunshan.net/blog/001-a-new-era-of-automated-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DeepFlow首个开源版本&lt;/a&gt;的分享的延续，上篇主要和大家详细聊了 AutoMetrics 和 AutoTracing 的能力，对于可观测领域三大支柱的的 Logging，在这次博客及直播中给大家带来详细讲解。&lt;/p&gt;
&lt;p&gt;今天从三个方面给大家进行分享：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一：分享应用调用日志，从数据来源、数据抽象到数据使用三个角度和大家谈谈，如何自动采集的 HTTP/MySQL 等多协议调用日志；&lt;/li&gt;
&lt;li&gt;二：分享网络流日志，主要对比公有云的流日志及流日志的应用场景；&lt;/li&gt;
&lt;li&gt;三：讲解 AutoLogging 的实现，基于 BPF/eBPF 的自动日志采集能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;0x0-应用调用日志-数据来源&#34;&gt;0x0: 应用调用日志-数据来源&lt;/h2&gt;
&lt;p&gt;首先强调，应用调用日志与应用在代码层面打的日志不同，例如 Nginx 的 AccessLog，MySQL 的 General Log/Error Log 这些都是调用日志的范畴。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-数据来源&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-数据来源&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/202208236304743fc4697_hu2792be96ffaa8c3369e2e0e31aa9872f_342596_e4a69a3adf5a51a1a0970a53a3dfbd16.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/202208236304743fc4697_hu2792be96ffaa8c3369e2e0e31aa9872f_342596_d518bd38a3c8a345c6d93d9b431f0a02.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/202208236304743fc4697_hu2792be96ffaa8c3369e2e0e31aa9872f_342596_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/202208236304743fc4697_hu2792be96ffaa8c3369e2e0e31aa9872f_342596_e4a69a3adf5a51a1a0970a53a3dfbd16.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-数据来源
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但是这些日志都是单个组件的日志，并不是应用的调用日志，对于应用问题的排查，需要挨个去找组件的负责人看日志，但组件负责人不懂业务，不知道如何快速搜索日志，导致了问题的排查过程中协作成本巨高。&lt;/p&gt;
&lt;p&gt;应用的调用日志是给 Dev 团队建设的，一个站在应用视角快速查看所有的调用详情信息的能力，其实这个能力获取可以将目前现有的组件日志都集中起来查看也是一种思路，但是如何以应用无感知/自动化的形式低成本的接入，以及更符合云原生的这个理念来实现的话，这是目前市面上没有的，这是 DeepFlow 的 AutoLogging 的价值点所在。&lt;/p&gt;
&lt;p&gt;DeepFlow 的调用日志，其实由各种各样的应用协议组成的，目前 DeepFlow 平台上已经包含了例如网络应用的 HTTP 的访问日志、DNS 的查询日志、SQL/NoSQL 的操作日志、RPC 的调用日志、MQ 的 API 调用日志，也会包含可观测领域中 Tracing 的数据，例如 OpenTelmetry 协议的 Span 调用，还会陆续支持一些物联网的协议，例如 MQTT 的日志。&lt;/p&gt;
&lt;h2 id=&#34;0x1-应用调用日志-数据抽象&#34;&gt;0x1: 应用调用日志-数据抽象&lt;/h2&gt;
&lt;p&gt;可以看到数据的来源非常的丰富，随着社区的需求和版本的迭代，将会有更多协议的数据接入。如果需更好的使用这些‘五花八门’的数据，需要对数据进行治理，治理的第一步，对数据进行统一的抽象，数据抽象将从公共字段、请求字段、响应字段、指标量，这四个层面来展开：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-数据抽象&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-数据抽象&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b132d70_hub03109f6e94c1dd13256226bc2b0ded2_125070_69b983a0d6fd5f0422ec9f7ff619a2c2.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b132d70_hub03109f6e94c1dd13256226bc2b0ded2_125070_284527473461cf5335a185e0292801c6.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b132d70_hub03109f6e94c1dd13256226bc2b0ded2_125070_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b132d70_hub03109f6e94c1dd13256226bc2b0ded2_125070_69b983a0d6fd5f0422ec9f7ff619a2c2.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-数据抽象
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公共字段：包含应用协议、协议版本、日志类型，其中日志类型包含请求/响应/会话类型，一般协议都是这三种，也会有一些协议有些例外，例如 OpenTelemetry 协议，仅一个会话类型。&lt;/li&gt;
&lt;li&gt;请求字段：整体抽象为请求类型、请求域名、请求资源、请求ID，例如HTTP的方法，MySQL 的命令类型，DNS 的查询类型都为请求类型，HTTP 的 host 对应请求域名，HTTP 的 Url、MySQL 的命令、DNS 的查询名称都对应请求资源，这个请求资源的抽象是参考各个 APM 的厂商的定义，例如 Datadog 的 Resource，Skywalking 的 Endpoint。&lt;/li&gt;
&lt;li&gt;响应字段：分为响应状态、响应码、响应异常、结果，整体来说基本都是对应响应码映射的。&lt;/li&gt;
&lt;li&gt;指标量：分为吞吐请求长度、响应长度的字段，以及响应时延字段，结合指标量可以更好的分析调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;0x2-应用调用日志-自定义属性&#34;&gt;0x2: 应用调用日志-自定义属性&lt;/h2&gt;
&lt;p&gt;数据抽象的收益是统一管理，可弊端也在统一。在设计之初，其实就考虑了要做自定义属性的扩展，随着 OpenTemetry 的 Tracing 数据接入，这个事情就变的更加重要。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-自定义属性&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-自定义属性&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b43a9f8_huf6ddda08e4c3256565d4f411d44991c9_264617_ab69245383ec3e0b4b3dc78c2dc5e0e5.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b43a9f8_huf6ddda08e4c3256565d4f411d44991c9_264617_8490c6f060868f766fbcb69697876c43.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b43a9f8_huf6ddda08e4c3256565d4f411d44991c9_264617_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b43a9f8_huf6ddda08e4c3256565d4f411d44991c9_264617_ab69245383ec3e0b4b3dc78c2dc5e0e5.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-自定义属性
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;因此除了定义的标准字段外，又定义了 Attribute_Names 和 Attribute_Values 这两个数组，数组里面可以携带自定义属性和自定义属性对应的值，这个是根据不同的需求来携带，没有长度和格式的限制，非常的灵活。&lt;/p&gt;
&lt;p&gt;两个数组里面的 Key 和 Value 按顺序来进行映射，在产品化的时候，通过 Qurey 组件进行转化，用户是无感知数组的存在的，看到的都是 Key，Value 这样的属性关系，通过 Key 查询来获取 Value，这个和使用其他 Tag 查询的逻辑也是一致的。&lt;/p&gt;
&lt;h2 id=&#34;0x3-应用调用日志-autotagging&#34;&gt;0x3: 应用调用日志-AutoTagging&lt;/h2&gt;
&lt;p&gt;刚刚分析的是各种协议如何映射为调用日志，站在应用的视角已经可以统一查看调用日志了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-autotagging&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-AutoTagging&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b1b3c9b_hu60b775c125c154d718ad03e8ac551e94_334563_a087f5cd4c78716cfc9dc4d662b67f13.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b1b3c9b_hu60b775c125c154d718ad03e8ac551e94_334563_9cfafbdc5f0f7d82f88b96778d76dc2b.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b1b3c9b_hu60b775c125c154d718ad03e8ac551e94_334563_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b1b3c9b_hu60b775c125c154d718ad03e8ac551e94_334563_a087f5cd4c78716cfc9dc4d662b67f13.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-AutoTagging
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而如何快速过滤应用呢？这也是一个必须解决的问题，在传统架构中，一般会根据IP段或者根据所在服务器来过滤，但是应用架构逐步迁移到云上，开始使用微服务架构后，IP 已经不再稳定，而资源也不再简单是服务器了，这种时候如何来快速过滤应用呢？&lt;/p&gt;
&lt;p&gt;DeepFlow 的 AutoTagging 能力，可以给调用日志打上各种云厂商的标签，比如租户、区域、子网、云服务器、RDS、负载均衡器、NAT 网关、Kubernetes 的命名空间、容器服务、工作负载、动态 Label 等等，有了这些标签，则可以快速的根据各种云标签过滤应用，然后查看应用的调用日志了。&lt;/p&gt;
&lt;p&gt;以上主要和大家分享了应用调用日志背后数据处理的一些理论能力，接下来带大家感受下基于这样的能力，应用调用日志激发的实际价值。&lt;/p&gt;
&lt;h2 id=&#34;0x4-应用调用日志-总览&#34;&gt;0x4: 应用调用日志-总览&lt;/h2&gt;
&lt;p&gt;这是基于调用日志构建的一张 Grafana 的 Dashboard，这个 Dashboard 主要可查看服务的调用关系、RED 指标量。Dashboard 就是基于前面数据抽象来实现的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-总览&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-总览&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b336e43_hub52690106ad4b3e1f9bfb4445854cb46_219068_9f2c1ced9ac937db2fd41fba3a9f5151.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b336e43_hub52690106ad4b3e1f9bfb4445854cb46_219068_9120dc4d6899aa5e29e29da920693c34.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b336e43_hub52690106ad4b3e1f9bfb4445854cb46_219068_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b336e43_hub52690106ad4b3e1f9bfb4445854cb46_219068_9f2c1ced9ac937db2fd41fba3a9f5151.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-总览
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们可以通过 AutoTagging 打上的标签，Dashboard 主要使用 Kubernetes 相关的标签，快速过滤应用，比如 DeepFlow 这个应用，就直接过滤 Namespace=DeepFlow 就可以了。然后结合 Grafana 的一些阈值能力，就可以快速的在视觉找到需要关注的服务，从而缩小问题定位的范围。&lt;/p&gt;
&lt;h2 id=&#34;0x5-应用调用日志-http访问日志&#34;&gt;0x5: 应用调用日志-HTTP访问日志&lt;/h2&gt;
&lt;p&gt;接下来看看如何查看 HTTP 的调用日志以及 DeepFlow 平台的调用日志与 AccessLog 的差异。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-http访问日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-HTTP访问日志&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b27ffc7_hu3cd5b11e51023acf56987b1314eb84b3_248896_b0500c6f1ea717103908b4fdfde4f964.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b27ffc7_hu3cd5b11e51023acf56987b1314eb84b3_248896_cdfbd53c7a5a66ee857b21de9c4a93d6.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b27ffc7_hu3cd5b11e51023acf56987b1314eb84b3_248896_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b27ffc7_hu3cd5b11e51023acf56987b1314eb84b3_248896_b0500c6f1ea717103908b4fdfde4f964.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-HTTP访问日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;左边是在 Grafana 上构建的应用调用日志的 Dashboard，可根据 TAG 过滤应用，根据 Protocol 过滤 HTTP、HTTPS、HTTP2 协议，即可查看当前服务的 HTTP 的调用日志。&lt;/p&gt;
&lt;p&gt;右边是将 AccessLog 与 DeepFlow 的应用调用日志做的一个映射，通过对比，可看出来除了 remote_user 其他都能映射的非常好。&lt;/p&gt;
&lt;p&gt;HTTP 访问日志除了作为代替 AccessLog，还可以结合调用日志的状态和指标量，快速知道哪些调用存在异常，哪些调用响应慢。&lt;/p&gt;
&lt;h2 id=&#34;0x6-应用调用日志-mysql慢查询日志&#34;&gt;0x6: 应用调用日志-MySQL慢查询日志&lt;/h2&gt;
&lt;p&gt;对于 MySQL 慢查询的日志，在云上数据库实例化后，想看数据库的日志，其实并不容易，需要在云上开启各种设置和权限，及时看到了日志，也比较难快速的去过滤对应的应用日志&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-mysql慢查询日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-MySQL慢查询日志&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b392aa4_hu32b03da4e200016a978ea8945cf5b8dd_278781_8272f3b666809254effd54a3a8994ea5.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b392aa4_hu32b03da4e200016a978ea8945cf5b8dd_278781_20f97ed061bbcc49f0265d095754bb5d.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b392aa4_hu32b03da4e200016a978ea8945cf5b8dd_278781_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b392aa4_hu32b03da4e200016a978ea8945cf5b8dd_278781_8272f3b666809254effd54a3a8994ea5.webp&#34;
               width=&#34;760&#34;
               height=&#34;431&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-MySQL慢查询日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们来看看 DeepFlow 是如何查看慢查询日志的，这个是刚刚 HTTP 调用日志一样的 Dashboard，仅需要切换下搜索条件即可，将协议切换为 MySQL，request_type 输入为 COM_QUREY，以及 request_resource 为 SELECT*。&lt;/p&gt;
&lt;p&gt;设置好这样的过滤条件，得到的就是 MySQL 的查询日志，接着再对响应时延排序过滤，就可以找到慢查询了。&lt;/p&gt;
&lt;h2 id=&#34;0x7-应用调用日志-分布式追踪-span-日志&#34;&gt;0x7: 应用调用日志-分布式追踪 Span 日志&lt;/h2&gt;
&lt;p&gt;除了看网络应用协议的调用日志外，通过前面的数据来源我们也知道，调用日志也支持接入分布式追踪协议的Span信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-分布式追踪-span-日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-分布式追踪 Span 日志&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b4dd0dd_hu68da37370e7e8c038ee666ae1b19803e_278352_ac72f3a839b7b9b56bdb84a6d33a745c.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b4dd0dd_hu68da37370e7e8c038ee666ae1b19803e_278352_3c12a53f517d94d8d172e8f40bb95f35.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b4dd0dd_hu68da37370e7e8c038ee666ae1b19803e_278352_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b4dd0dd_hu68da37370e7e8c038ee666ae1b19803e_278352_ac72f3a839b7b9b56bdb84a6d33a745c.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-分布式追踪 Span 日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;目前 DeepFlow 已经支持对接 OpenTelemtry 的 Span 信息，每个 Span 其实都对应着一个调用，当前展示的就是 Opentelemtry的一个 Span 日志。&lt;/p&gt;
&lt;p&gt;接入 Span 的信息后，除了可以看日志，根据状态、指标量来定位调用问题外，还有一个重要的目的，就是还可以基于目前 DeepFlow 平台已有的网络中采集的调用和通过 eBPF 采集的调用，进行全栈全链路的追踪。&lt;/p&gt;
&lt;h2 id=&#34;0x8-应用调用日志-全栈全链路追踪&#34;&gt;0x8: 应用调用日志-全栈全链路追踪&lt;/h2&gt;
&lt;p&gt;这就是一个最终追踪出来的火焰图，这个火焰图上不仅包含应用代码层面的调用，也包含了系统层面、网络层面，针对如何追踪这个事，由于时间问题，今天就不展开细说，我会利用后续的直播继续给大家详细的去分享，如何对应用进行全栈全链路的追踪。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-全栈全链路追踪&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-全栈全链路追踪&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b56aa4f_hua213e2ee03787a7acf451ae201ca34d6_234727_f670eb49f6aeda2d73ad74b508b89f7f.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b56aa4f_hua213e2ee03787a7acf451ae201ca34d6_234727_c1e7638af28f09d8ccdb908992fde2e1.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b56aa4f_hua213e2ee03787a7acf451ae201ca34d6_234727_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b56aa4f_hua213e2ee03787a7acf451ae201ca34d6_234727_f670eb49f6aeda2d73ad74b508b89f7f.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-全栈全链路追踪
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;应用调用日志，仅能观测到应用层面的一些问题，DeepFlow 可以通过 FlowID 将应用调用背后的网络流日志关联起来。接下来分享网络流日志能有什么样的能力。&lt;/p&gt;
&lt;h2 id=&#34;0x9-网络流日志-功能定义&#34;&gt;0x9: 网络流日志-功能定义&lt;/h2&gt;
&lt;p&gt;先看下公有云对网络流日志的功能说明，这是阿里云的一个定义，是捕获特定位置的流量，将流量转化为流日志记录下来，流日志是记录捕获特定时间窗口的特定五元组的网络流。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络流日志-功能定义&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络流日志-功能定义&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b7ac14f_hu01b3a75c3d695aa81e5d7ff7532a3273_284596_85eaa436c0666f92067948b906a153b8.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b7ac14f_hu01b3a75c3d695aa81e5d7ff7532a3273_284596_f8162fdf79835c7f8cf9fc99f04ec169.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b7ac14f_hu01b3a75c3d695aa81e5d7ff7532a3273_284596_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b7ac14f_hu01b3a75c3d695aa81e5d7ff7532a3273_284596_85eaa436c0666f92067948b906a153b8.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络流日志-功能定义
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于基础功能的定义，DeepFlow 是有遵循公有云的定义的，并在此基础上还有更丰富的能力。&lt;/p&gt;
&lt;h2 id=&#34;0x10-网络流日志-deepflow-与公有云对比&#34;&gt;0x10: 网络流日志-DeepFlow 与公有云对比&lt;/h2&gt;
&lt;p&gt;接下来看看 DeepFlow 流日志与公有云流日志的对比，解读其中的一些差异点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络流日志-deepflow-与公有云对比&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络流日志-DeepFlow 与公有云对比&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b69ae96_hu041b1aaf6f7326c1fcf703d2de33209c_163180_c2259af1f66dc6d317a93767f0c46049.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b69ae96_hu041b1aaf6f7326c1fcf703d2de33209c_163180_d14db8e162d3507f5c30f03ffbd3f930.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b69ae96_hu041b1aaf6f7326c1fcf703d2de33209c_163180_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b69ae96_hu041b1aaf6f7326c1fcf703d2de33209c_163180_c2259af1f66dc6d317a93767f0c46049.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络流日志-DeepFlow 与公有云对比
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;先看看捕获周期，DeepFlow 的粒度能小到1分钟，同时捕获位置 DeepFlow 也更丰富，除了VPC网络，也会覆盖到容器网络、物理网络、也能从网络层面扩展到系统层面。&lt;/p&gt;
&lt;p&gt;接着看看 TAG，配合 DeepFlow 的 AutoTagging 的能力，DeepFlow 流日志的 TAG 是远比公有云更丰富的，除了 VPC 网络的一些 Tag，还包含隧道的 Tag、容器网络，以及更丰富的采集位置 Tag。&lt;/p&gt;
&lt;p&gt;接着指标量，公有云仅有 Packet/Byte 这两个，DeepFlow 则覆盖了从网络吞吐到性能，再到时延多个维度。&lt;/p&gt;
&lt;p&gt;在 DeepFlow 的流日志中，增加了流状态字段，可通过此字段快速过滤异常的流，这是目前公有云上不支持的。当然公有云支持的日志状态字段和安全策略的状态，DeepFlow 目前不支持，不过此功能也已经加入到排期中了。&lt;/p&gt;
&lt;p&gt;其次从成本上看，DeepFlow 开源版本可一键部署于自建环境。&lt;/p&gt;
&lt;p&gt;下面我们来看下 DeepFlow 网络流日志功能，具体能解决什么问题。&lt;/p&gt;
&lt;h2 id=&#34;0x11-网络流日志-总览&#34;&gt;0x11: 网络流日志-总览&lt;/h2&gt;
&lt;p&gt;这是基于网络流日志构建的 Granafa 的 Dashboard，是可以和应用调用日志一样，查看服务的调用关系，但是和应用调用日志不一样的是，这个总览的 Dashboard 查看的是网络层面的指标量，比如吞吐、重传、建连失败、建连时延等指标数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络流日志-总览&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络流日志-总览&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b77ef48_hub0ded50113a6e9891611b222c7d2bff2_241570_deed289debfdeafe38411b13977b756a.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b77ef48_hub0ded50113a6e9891611b222c7d2bff2_241570_a168bec9a44ebe67d58e0a7c57fba239.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b77ef48_hub0ded50113a6e9891611b222c7d2bff2_241570_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b77ef48_hub0ded50113a6e9891611b222c7d2bff2_241570_deed289debfdeafe38411b13977b756a.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络流日志-总览
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;0x12-网络流日志-网络时延&#34;&gt;0x12: 网络流日志-网络时延&lt;/h2&gt;
&lt;p&gt;查看应用调用日志时，经常会关注响应时延慢的调用，可这个响应慢，除了应用本身响应慢以外，还可能是TCP建连慢，也有可能是数据传输，也可能是协议栈慢，对于网络相关时延的排查，需要查看应用调用对应的流日志来分析。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络流日志-网络时延&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络流日志-网络时延&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b8aa56a_hu59c0393a07d86fdc1bb708fb9888f3e5_272163_a601adf26fc2001b9c68dc16a07d51fd.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b8aa56a_hu59c0393a07d86fdc1bb708fb9888f3e5_272163_d042be316067959d97493100446a7205.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b8aa56a_hu59c0393a07d86fdc1bb708fb9888f3e5_272163_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b8aa56a_hu59c0393a07d86fdc1bb708fb9888f3e5_272163_a601adf26fc2001b9c68dc16a07d51fd.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络流日志-网络时延
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先应用调用日志和网络流日志是如何关联的，DeepFlow 平台上是通过一个 FlowID 来将两个日志进行关联，因此可以根据调用日志的 FlowID，在流日志中进行查找，找到这条调用对应的流日志，然后分析流日志中的建连时延、系统时延和数据传输时延指标量，排查网络时延高导致了应用调用响应慢。&lt;/p&gt;
&lt;h2 id=&#34;0x13-网络流日志-流状态异常日志&#34;&gt;0x13: 网络流日志-流状态异常日志&lt;/h2&gt;
&lt;p&gt;应用调用日志是可以根据状态查看异常日志，流日志也是一样，可以对状态进行过滤查看异常的流日志，因此这个时候就能去看看调用异常背后是否因为网络异常导致。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络流日志-流状态异常日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络流日志-流状态异常日志&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b91b3ab_huddc5c36b8ed12ca8bd89c247c2fa4d0d_363743_5e06b098e2072a229c2ed44e5765be8f.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b91b3ab_huddc5c36b8ed12ca8bd89c247c2fa4d0d_363743_bae7eb641f0a58e94549d8ee7185c932.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b91b3ab_huddc5c36b8ed12ca8bd89c247c2fa4d0d_363743_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b91b3ab_huddc5c36b8ed12ca8bd89c247c2fa4d0d_363743_5e06b098e2072a229c2ed44e5765be8f.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络流日志-流状态异常日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;右上角给出来了 DeepFlow 流日志里面的状态定义，主要对流结束类型来进行定义，比如建连时延，因为端口复用可关闭，比如传输过程中，服务端发送 RST 报文导致的结束。&lt;/p&gt;
&lt;h2 id=&#34;0x14-网络流日志-tcp时序日志&#34;&gt;0x14: 网络流日志-TCP时序日志&lt;/h2&gt;
&lt;p&gt;接下来继续深入的结合 TCP 时序日志，分析具体的包的时延和问题。特别说明下：TCP 时序日志目前是 DeepFlow 企业版的增强功能了，现在开源的版本里面是没有的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-网络流日志-tcp时序日志&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;网络流日志-TCP时序日志&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479b9aa702_hub972b571ddfa7861deb76eeae0ca5946_185448_d03c1a1831ed974e01f5dc2816661be8.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b9aa702_hub972b571ddfa7861deb76eeae0ca5946_185448_ed07e2ed9d587ead6803b1af5156f0a2.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479b9aa702_hub972b571ddfa7861deb76eeae0ca5946_185448_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479b9aa702_hub972b571ddfa7861deb76eeae0ca5946_185448_d03c1a1831ed974e01f5dc2816661be8.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      网络流日志-TCP时序日志
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;用一个&lt;a href=&#34;https://ce-demo.deepflow.yunshan.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;简单的 Demo&lt;/a&gt;，讲解开源的调用日志和流日志功能。这是我们给开源社区搭建的一个 Demo 环境，这个 Demo 环境是基于 Grafana 来构建的，已经构建了很多应用和网络相关的 Dashboard。&lt;/p&gt;
&lt;h2 id=&#34;0x15-autologging-采集&#34;&gt;0x15: AutoLogging-采集&lt;/h2&gt;
&lt;p&gt;接下来从日志采集和日志处理两个方面给大家介绍，AutoLogging 是如何基于 BPF/eBPF 来自动采集日志的。&lt;/p&gt;
&lt;p&gt;首先我们来看看采集部分，采集部需分别从调用日志和流日志两个方面来看。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-autologging-采集-1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;AutoLogging-采集-1&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479ba66cf7_hu7838f1a539b661a14c56461242e9de3a_159705_761f1b40e357eacaefc8cb274d19dc46.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479ba66cf7_hu7838f1a539b661a14c56461242e9de3a_159705_fdb222fbd13fd0a0eed842430b0b24fd.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479ba66cf7_hu7838f1a539b661a14c56461242e9de3a_159705_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479ba66cf7_hu7838f1a539b661a14c56461242e9de3a_159705_761f1b40e357eacaefc8cb274d19dc46.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      AutoLogging-采集-1
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流日志：流日志通过前面产品介绍可知，是根据网络流量来生成的日志，因此采集则主要集中在网络层面，目前可覆盖物理网络一直到虚拟网络，可以采集宿主机到虚拟机、一直到容器 POD 的网卡的流量，在实现上流日志通过 BPF + AF_PACKET 技术来完成，其中 Windows 系统的采集则通过使用 Winpcap 来完实现的。&lt;/li&gt;
&lt;li&gt;调用日志：调用日志的数据包含两部分数据，一部分是从网络应用协议来的，还有一部分是可观测的 Tracing 数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-autologging-采集-2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;AutoLogging-采集-2&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479badd87a_hu59a0214204ec17cafcb721b82101bad4_182575_a33ccbd277d811d3bf62ea8d821129e1.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479badd87a_hu59a0214204ec17cafcb721b82101bad4_182575_1b44c1fa3e078a006b4f6f8d4d3ab54d.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479badd87a_hu59a0214204ec17cafcb721b82101bad4_182575_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479badd87a_hu59a0214204ec17cafcb721b82101bad4_182575_a33ccbd277d811d3bf62ea8d821129e1.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      AutoLogging-采集-2
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于网络应用协议这部分的数据，调用日志既包含了网络层面采集的，也扩展到了 Sidecar 和应用进程层面，对于网络层面采集的位置和实现技术与流日志是一致，只是处理逻辑会有一些不一样；而对于 Sidecar 和应用进程层面，则是使用 eBPF 技术来实现的，其中对于非加密和非压缩的协议，则通过 eBPF 的 Kprobe 和 Tracepoints 来完成，而对于 HTTP2、HTTPS 则需要使用 Uprobe 来完成。&lt;/p&gt;
&lt;p&gt;对于 Opentelemetry 的数据接入，是通过 Otel-Collector 将 Traces 的数据发送给 deepflow-agent，就完成了 Tracing的数据接入。采集的部分先分享到这里，接下来我们看看采集完成后，会进行些什么样的处理。&lt;/p&gt;
&lt;h2 id=&#34;0x16-autologging-处理&#34;&gt;0x16: AutoLogging-处理&lt;/h2&gt;
&lt;p&gt;对于日志的处理，分为三个部分：公共处理部分、流日志处理、调用日志处理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-autologging-处理&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;AutoLogging-处理&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479bb95f59_huf6a5649809aee74a8f72345c7502f07d_116232_b95bbb823835a3156a9f066158ec077a.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479bb95f59_huf6a5649809aee74a8f72345c7502f07d_116232_784726316334366380c620559cd0e1a0.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479bb95f59_huf6a5649809aee74a8f72345c7502f07d_116232_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479bb95f59_huf6a5649809aee74a8f72345c7502f07d_116232_b95bbb823835a3156a9f066158ec077a.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      AutoLogging-处理
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于网络流量的处理可分为：隧道拆解，其中对于隧道拆解，基本主流的隧道协议，都已经支持，比如 Vxlan，IPIP，Gre 等等。隧道拆解完成后，则会按协议栈的顺序依次解析协议，从链路层一直到传输层。&lt;/p&gt;
&lt;p&gt;接着需要对于流量进行 AutoTagging 的预处理，这里主要加上唯一的 Tag，方便后面 Server 根据唯一 Tag 增加全量 Tag。到这步，对于不同的日志需要分开处理了，对于网络流日志，此时可以根据产品定义去生成流日志。&lt;/p&gt;
&lt;p&gt;对应用调用日志，还需要完成应用协议识别，确定具体协议后，再进行应用协议解析，最后才能根据定义生成调用日志。&lt;/p&gt;
&lt;p&gt;对于应用调用日志，除了刚刚分享的这个处理流程，还有另外一条路径，主要是因为应用调用日志不仅包含网络应用协议，还包含 APM 定义的 Tracing 数据，对于这部分数据，可以直接接入，接入后直接解析即可。&lt;/p&gt;
&lt;h2 id=&#34;0x17-应用调用日志-协议扩展&#34;&gt;0x17: 应用调用日志-协议扩展&lt;/h2&gt;
&lt;p&gt;额外说下如何扩展一个应用协议。前面一直在说应用调用日志支持接入各种各样的协议，这里大概分享下协议接入需要做一些什么事情。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用调用日志-协议扩展&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用调用日志-协议扩展&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479bc0101a_hu0e5645ce1169f10e6c30d46c7beff9e8_495139_22f8313c9b7b05cb3b5e824c9cd6efae.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479bc0101a_hu0e5645ce1169f10e6c30d46c7beff9e8_495139_c67a59febb905e114f6f874c688312a3.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479bc0101a_hu0e5645ce1169f10e6c30d46c7beff9e8_495139_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479bc0101a_hu0e5645ce1169f10e6c30d46c7beff9e8_495139_22f8313c9b7b05cb3b5e824c9cd6efae.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用调用日志-协议扩展
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第一部分：需要解析协议；&lt;/p&gt;
&lt;p&gt;第二部分：协议解析完成后，需要将协议映射到调用日志中；&lt;/p&gt;
&lt;p&gt;第三部分：除了调用日志外，DeepFlow 还提供预聚合数据的能力，对应用 RED 指标进行计算。&lt;/p&gt;
&lt;p&gt;协议扩展要做的事情就是这些，目前 DeepFlow 已经开源，也欢迎开源社区的小伙伴们来贡献更多的协议，让应用调用日志更丰富。&lt;/p&gt;
&lt;h2 id=&#34;0x18-总结&#34;&gt;0x18： 总结&lt;/h2&gt;
&lt;p&gt;今天的分享主要侧重在框架的讲解，并不涉及太多代码细节，如果大家对实现细节感兴趣的话，可以直接查看 GitHub 上的代码，下方是 DeepFlow GitHub 的链接。&lt;/p&gt;
&lt;p&gt;GitHub地址：https://github.com/deepflowys/deepflow&lt;/p&gt;
&lt;h2 id=&#34;0x18-未来迭代的方向&#34;&gt;0x18: 未来迭代的方向&lt;/h2&gt;
&lt;p&gt;最后分享下未来 DeepFlow 关于日志的一个迭代方向。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-未来迭代的方向&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;未来迭代的方向&#34; srcset=&#34;
               /blog/autologging-for-request-log-and-flow-log/20220823630479bd045b9_hucc459657dbbdc55abd79f20f4e89d82d_98342_ebb8732d0b0c17f154694d752eb31776.webp 400w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479bd045b9_hucc459657dbbdc55abd79f20f4e89d82d_98342_3c9301d329411bfef97631a1d37a0585.webp 760w,
               /blog/autologging-for-request-log-and-flow-log/20220823630479bd045b9_hucc459657dbbdc55abd79f20f4e89d82d_98342_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/autologging-for-request-log-and-flow-log/20220823630479bd045b9_hucc459657dbbdc55abd79f20f4e89d82d_98342_ebb8732d0b0c17f154694d752eb31776.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      未来迭代的方向
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;目前 DeepFlow 在 Logging 方向上，有 AutoLogging 的能力，后面还会持续做日志集成，会接入 Promtail、Fluentd 等等的数据，并利用 AutoTagging 的能力，注入各种标签，更符合云原生设计理念。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>New Relic 开源 Pixie，其 Kubernetes 原生集群内观察平台</title>
      <link>https://cloudnative.to/blog/new-relic-open-sources-pixie-its-kubernetes-native-in-cluster-observability-platform/</link>
      <pubDate>Thu, 06 May 2021 02:04:05 +0800</pubDate>
      <guid>https://cloudnative.to/blog/new-relic-open-sources-pixie-its-kubernetes-native-in-cluster-observability-platform/</guid>
      <description>&lt;p&gt;本文译自 ZDNet 的文章 &lt;a href=&#34;https://www.zdnet.com/article/new-relic-open-sources-pixie-its-kubernetes-native-in-cluster-observability-platform/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;New Relic open sources Pixie, its Kubernetes-native in-cluster observability platform&lt;/a&gt;，译者&lt;a href=&#34;https://jimmysong.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;宋净超&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;好消息是，云计算、&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 和云原生计算结合在一起，使软件开发比以前更快、更强大。坏消息是，保持对所有这些的关注比以往任何时候都更难。这就是为什么 &lt;a href=&#34;https://newrelic.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;New Relic&lt;/a&gt; 将其 Kubernetes 原生集群内观察平台 &lt;a href=&#34;http://px.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pixie&lt;/a&gt; 作为一个新的开源项目，在 &lt;a href=&#34;https://www.apache.org/licenses/LICENSE-2.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache 2.0 许可&lt;/a&gt;下贡献给&lt;a href=&#34;https://www.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生计算基金会（CNCF）的&lt;/a&gt;原因，这是一个好消息。&lt;/p&gt;
&lt;p&gt;Pixie 是一个新的云原生应用程序的可观察性平台。有了它，开发人员可以通过一个 shell 命令看到他们应用程序的所有指标、事件、日志和追踪。有了 Pixie，你不需要添加度量（instrumentation ）代码，设置临时仪表板，或将数据移出集群，就能看到正在发生的事情。这将为你节省宝贵的时间，这样你就可以致力于建立更好的软件，而不是用更好的方法来监控它。&lt;/p&gt;
&lt;p&gt;该程序作为一组 Kubernetes 服务部署在被监控的集群内。简而言之，Pixie 是一个原生的 Kubernetes 程序。它的 Pixie 边缘模块（PEM）被部署为 DaemonSet。在你的集群内，PEM 利用 Pixie 的 &lt;a href=&#34;https://lwn.net/Articles/740157/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 程序来收集网络事务和系统指标，而不需要修改代码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;亚马逊网络服务（AWS）&lt;/a&gt;可观察性服务总经理 Mark Carter 补充说：“有了 &lt;a href=&#34;https://newrelic.com/blog/best-practices/what-is-ebpf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt;，即 Pixie 平台支持的 Linux 中的新度量能力，开发和运维可以利用一种新的可观察性的超级力量。”&lt;/p&gt;
&lt;p&gt;这是非常方便的。正如 New Relic 总裁 Bill Staples 在博客中所说。“这些&lt;a href=&#34;https://newrelic.com/blog/nerd-life/open-source-observability-pixie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生环境&lt;/a&gt;的动态、分布式性质&lt;a href=&#34;https://newrelic.com/blog/nerd-life/open-source-observability-pixie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;带来了一系列新的可观察性挑战&lt;/a&gt;。我们相信开源的、社区驱动是解决这些挑战的最好方法”。因此，通过使用 &lt;a href=&#34;https://opensource.newrelic.com/projects/open-telemetry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 作为度量化标准&lt;/a&gt;，分析和故障排除都变得更加容易。&lt;/p&gt;
&lt;p&gt;Staples 继续说道。“通过一个命令，你可以点亮你的整个云环境并立即获得遥测数据。我们相信所有的开发者都应该获得这种惊人的开发者体验，它可以减少观察的摩擦，节省宝贵的时间以用来开发更好的软件。为了实现这一目标，我们还将 Pixie 的大部分工程资源投入到这个开源项目中。”&lt;/p&gt;
&lt;p&gt;展望未来，New Relic 公司 Pixie 和 New Relic 开源部总经理、最近收购的 &lt;a href=&#34;https://pixielabs.ai/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pixie 实验室&lt;/a&gt;的首席执行官兼联合创始人 Zain Asgar 说，“开源是 New Relic 和 Pixie 的决定性价值，这就是为什么我们正在用 OpenTelemetry 对我们的可观察性产品进行标准化，并正在将 Pixie 作为一个开源项目进行贡献。我们已经亲眼看到了开放治理对开源项目的积极影响，我们期待着通过我们在 CNCF 的 [新] 白金会员资格，在全行业范围内支持这一倡议。”&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/blogs/opensource/gathering-insights-on-kubernetes-applications-services-and-network-traffic-with-pixie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pixie 开源现在也将在 AWS 上运行&lt;/a&gt;，作为 OpenTelemetry 项目的一个安全的、可生产的、由 AWS 支持的发行版。&lt;/p&gt;
&lt;p&gt;CNCF 总经理 Priyanka Sharma 欢迎 New Relic 加入该组织。“我们很高兴欢迎 New Relic 成为白金会员和 Zain Asgar 加入我们的董事会。Zain 和 New Relic 对推进我们的使命和支持我们的社区的承诺将有很大的帮助。我们特别期待着他们在可观察性方面细致入微的专业知识和观点”。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SkyWalking 前端监控的应用</title>
      <link>https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/</link>
      <pubDate>Tue, 13 Apr 2021 18:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/</guid>
      <description>&lt;p&gt;网络应用性能会影响用户的留存率。如果页面加载时间过长，用户就会放弃。所以我们需要监控 Web 应用来了解性能，确保服务稳定、可用、健康。&lt;a href=&#34;https://github.com/apache/skywalking&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache SkyWalking&lt;/a&gt; 是一款专门为云原生和基于容器架构设计的应用性能监控（APM）工具。其 &lt;a href=&#34;https://github.com/apache/skywalking-client-js&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;skywalking-client-js&lt;/a&gt; 是一个轻量级的客户端 JavaScript 异常、性能和追踪库。&lt;/p&gt;
&lt;p&gt;本文介绍了 skywalking-client-js 如何将其监控扩展到浏览器，为 SkyWalking 后端提供性能指标和错误收集。&lt;/p&gt;
&lt;h2 id=&#34;性能指标&#34;&gt;性能指标&lt;/h2&gt;
&lt;p&gt;skywalking-client-js 使用 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Window/performance&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;window.performance&lt;/a&gt; 来收集性能数据。从 MDN 文档来看，性能接口提供了对当前页面的性能相关信息的访问。它是 High Resolution Time API 的一部分，但对 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Performance_Timeline&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Performance Timeline API&lt;/a&gt;、&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Navigation Timing API&lt;/a&gt;、&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;User Timing API&lt;/a&gt; 和 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Resource Timing API&lt;/a&gt; 有所增强。&lt;/p&gt;
&lt;p&gt;在 skywalking-client-js 中，所有的性能指标都是根据 W3C 规范中定义的 &lt;a href=&#34;https://www.w3.org/TR/navigation-timing/?spm=a2c4g.11186623.2.12.2f495c7cmRef8Q#sec-navigation-timing-interface&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Navigation Timing API&lt;/a&gt; 来计算的。我们可以使用 window.performance.timing 属性获得一个描述页面的 PerformanceTiming 对象。PerformanceTiming 接口包含的属性提供了当前页面加载和使用过程中发生的各种事件的性能计时信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3x19976j30oa0bnac9_hu918bca52e71a70dc32960085fbd01a6b_53859_9dae54569b0635d92e48b042c3133131.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3x19976j30oa0bnac9_hu918bca52e71a70dc32960085fbd01a6b_53859_0cdaec79618b87d22d075b7c4aed8020.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3x19976j30oa0bnac9_hu918bca52e71a70dc32960085fbd01a6b_53859_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3x19976j30oa0bnac9_hu918bca52e71a70dc32960085fbd01a6b_53859_9dae54569b0635d92e48b042c3133131.webp&#34;
               width=&#34;760&#34;
               height=&#34;364&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们把这些属性放在一起看，可以更好地理解 &lt;a href=&#34;https://www.w3.org/TR/navigation-timing/?spm=a2c4g.11186623.2.14.2f495c7cmRef8Q#processing-model&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;W3C&lt;/a&gt; 的下图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3xf13fjj30pc0ff74i_hu00b073019b90274ec603b2110931a8f0_66017_74956041b8f58c329b8163b62f389fc3.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3xf13fjj30pc0ff74i_hu00b073019b90274ec603b2110931a8f0_66017_2508b160eeb953d82d0bbc7a156e4f04.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3xf13fjj30pc0ff74i_hu00b073019b90274ec603b2110931a8f0_66017_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3xf13fjj30pc0ff74i_hu00b073019b90274ec603b2110931a8f0_66017_74956041b8f58c329b8163b62f389fc3.webp&#34;
               width=&#34;760&#34;
               height=&#34;463&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;下表包含了 skywalking-client-js 的性能指标。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Metrics 名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;计算公式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redirectTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Page redirection time&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redirectEnd – redirectStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;If the current document and the document that is redirected to are not from the same &lt;a href=&#34;http://tools.ietf.org/html/rfc6454&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;origin&lt;/a&gt;, set redirectStart, redirectEnd to 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ttfbTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to First Byte&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseStart – requestStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;According to &lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/network/reference?spm=a2c4g.11186623.2.16.2f495c7cmRef8Q#timing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Development&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dnsTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to DNS query&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domainLookupEnd – domainLookupStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;tcpTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to TCP link&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connectEnd – connectStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;transTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to content transfer&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseEnd – responseStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sslTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to SSL secure connection&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connectEnd – secureConnectionStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Only supports HTTPS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;resTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to resource loading&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;loadEventStart – domContentLoadedEventEnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Represents a synchronized load resource in pages&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fmpTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to First Meaningful Paint&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Listen for changes in page elements. Traverse each new element, and calculate the total score of these elements. If the element is visible, the score is 1 * weight; if the element is not visible, the score is 0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domAnalysisTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to DOM analysis&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domInteractive – responseEnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fptTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;First Paint Time&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseEnd – fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domReadyTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to DOM ready&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domContentLoadedEventEnd – fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;loadPageTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Page full load time&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;loadEventStart – fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ttlTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to interact&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domInteractive – fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;firstPackTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to first package&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseStart – domainLookupStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;skywalking-client-js 收集这些性能指标，并发送给 &lt;a href=&#34;https://skywalking.apache.org/docs/main/latest/en/concepts-and-designs/backend-overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAP（Observability Analysis Platform）服务器&lt;/a&gt;，服务器在后台汇总数据，然后在 UI 端以可视化的方式展示出来。用户可以根据这些数据来优化页面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3yjrgk5j30q90abwfa_hu6485f23e60e2e8e9568294bae27898e8_43873_51d9ba0ff140a3daf4a5e1680e126575.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3yjrgk5j30q90abwfa_hu6485f23e60e2e8e9568294bae27898e8_43873_a80d9cb8ce0c969da9dfa3f74b19eaa6.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3yjrgk5j30q90abwfa_hu6485f23e60e2e8e9568294bae27898e8_43873_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3yjrgk5j30q90abwfa_hu6485f23e60e2e8e9568294bae27898e8_43873_51d9ba0ff140a3daf4a5e1680e126575.webp&#34;
               width=&#34;760&#34;
               height=&#34;298&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;异常指标&#34;&gt;异常指标&lt;/h2&gt;
&lt;p&gt;在 skywalking-client-js 中可以捕捉到五种错误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;window.addeventlistener (&#39;error &#39;, callback, true)&lt;/code&gt; 捕捉资源加载错误。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;window.onerror&lt;/code&gt; 抓取 JS 执行错误。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;window.addEventListener (&#39;unhandledrejection&#39;, callback)&lt;/code&gt; 用来捕捉Promise错误。&lt;/li&gt;
&lt;li&gt;Vue 错误由 &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; 捕获。&lt;/li&gt;
&lt;li&gt;Ajax 错误由 &lt;code&gt;addEventListener (&#39;error&#39;，callback);addEventListener (&#39;abort&#39;，callback);addEventListener (&#39;timeout&#39;，callback);&lt;/code&gt; 在 send callback 中捕获。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;skywalking-client-js 将错误数据追踪到 OAP 服务器，最后在 UI 端将数据可视化呈现。对于 App 的错误概况，有几个指标可以进行基本的统计和错误的趋势，包括以下指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;App Error Count，选定时间段内的错误总数。&lt;/li&gt;
&lt;li&gt;App JS 错误率，选定时间段内有 JS 错误的 PV 占总 PV 的比例。&lt;/li&gt;
&lt;li&gt;All of Apps Error Count，Top N Apps 错误数排名。&lt;/li&gt;
&lt;li&gt;All of Apps JS Error Rate，前 N 个 Apps JS 错误率排名。&lt;/li&gt;
&lt;li&gt;所选 App 中的版本错误数，所选 App 中的版本错误数排名前 N 名。&lt;/li&gt;
&lt;li&gt;所选 App 中的版本错误率，所选 App 中的版本错误率排名前 N 名 JS 错误率排名。&lt;/li&gt;
&lt;li&gt;所选 App 的出错率，所选 App 的出错率排名前 N 名。&lt;/li&gt;
&lt;li&gt;所选 App 的错误率，所选 App 排名的前 N 个 JS 错误率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3zef9w5j31530rn425_hu1eb7380b447ea5962df15facbcd33cd9_142255_b24611a617b8376bc3f6e27e90b2913d.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3zef9w5j31530rn425_hu1eb7380b447ea5962df15facbcd33cd9_142255_222484a8ced34401520c1456c3a585ce.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3zef9w5j31530rn425_hu1eb7380b447ea5962df15facbcd33cd9_142255_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3zef9w5j31530rn425_hu1eb7380b447ea5962df15facbcd33cd9_142255_b24611a617b8376bc3f6e27e90b2913d.webp&#34;
               width=&#34;760&#34;
               height=&#34;511&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于页面，我们使用多个指标进行基本统计和错误趋势，包括以下指标。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Top Unstable Pages / Error Rate, Top N Error Count pages of the Selected version ranking.&lt;/li&gt;
&lt;li&gt;Top Unstable Pages / Error Count，Top N Error Count 页面的 Selected 版本排名。&lt;/li&gt;
&lt;li&gt;页面错误数布局，一段时间内不同错误的数据显示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4797f9nj31360jxmyo_hu5a5c8522ce261877abce045f2f2e638e_77519_6037a8576204ee1597a4fc11a0454b63.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4797f9nj31360jxmyo_hu5a5c8522ce261877abce045f2f2e638e_77519_024e76c837514425ec19656b0602b4ec.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4797f9nj31360jxmyo_hu5a5c8522ce261877abce045f2f2e638e_77519_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4797f9nj31360jxmyo_hu5a5c8522ce261877abce045f2f2e638e_77519_6037a8576204ee1597a4fc11a0454b63.webp&#34;
               width=&#34;760&#34;
               height=&#34;386&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;用户指标&#34;&gt;用户指标&lt;/h2&gt;
&lt;p&gt;SkyWalking 浏览器监控还提供了访客使用被监控网站的指标，如 PV（页面浏览量）、UV（独立访客）、前 N 名 PV（页面浏览量）等。&lt;/p&gt;
&lt;p&gt;在 SPA（单页应用）中，页面只会被刷新一次。传统方法只在页面加载后报告一次 PV，但无法统计每个子页面的 PV，也无法使其他类型的日志按子页面进行汇总。&lt;/p&gt;
&lt;p&gt;SkyWalking 浏览器监控针对 SPA 页面提供了两种处理方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启用 SPA 自动解析。该方法适用于大多数以 URL 哈希为路由的单页应用场景。在初始化配置项中，将 enableSPA 设置为 true，将开启页面的哈希变化事件监听器（触发重报 PV），在其他数据报送中使用 URL 哈希作为页面字段。&lt;/li&gt;
&lt;li&gt;手动上报。如果第一种方法无法使用，该方法可以用于所有单页应用场景。下面的例子提供了一个设置页面的方法，当数据上报时，可以手动更新页面名称。调用此方法时，页面 PV 将被默认重新上报：&lt;a href=&#34;https://gist.github.com/Fine0830/53d36508671882e210d7fca861555ce9%e3%80%82&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://gist.github.com/Fine0830/53d36508671882e210d7fca861555ce9。&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们来看看下图中的结果。它显示了最受欢迎的应用和版本，以及一段时间内 PV 的变化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4820dzsj30du0n975k_hu677c561ada13b0596391c8c0b2a6f1df_38706_07b96f3b69c45f19d222b8b55a84922f.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4820dzsj30du0n975k_hu677c561ada13b0596391c8c0b2a6f1df_38706_e927181e1ef7d6f35114028b4f730e22.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4820dzsj30du0n975k_hu677c561ada13b0596391c8c0b2a6f1df_38706_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4820dzsj30du0n975k_hu677c561ada13b0596391c8c0b2a6f1df_38706_07b96f3b69c45f19d222b8b55a84922f.webp&#34;
               width=&#34;452&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;让浏览器成为分布式追踪的起点。&lt;/p&gt;
&lt;p&gt;SkyWalking 浏览器监控拦截 HTTP 请求，追踪段（Segment）和跨度（Span）。它支持追踪以下模式的 HTTP 请求。&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;XMLHttpRequest&lt;/a&gt; 和 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fetch.&lt;/a&gt;。它还支持追踪基于 XMLHttpRequest 和 fetch 的库和工具 —— 如 &lt;a href=&#34;https://github.com/axios/axios&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Axios&lt;/a&gt;、&lt;a href=&#34;https://github.com/visionmedia/superagent&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SuperAgent&lt;/a&gt;、&lt;a href=&#34;https://www.openapis.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenApi&lt;/a&gt; 等。&lt;/p&gt;
&lt;p&gt;我们来看看 SkyWalking 浏览器监控是如何拦截 HTTP 请求的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph48ldgzhj30u00uudo1_huf46a547b0f510dcda8a93c21a6643f49_120920_d60766e7be1c3d1b4f0ec44a8ffd5cf3.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph48ldgzhj30u00uudo1_huf46a547b0f510dcda8a93c21a6643f49_120920_4636cecb078fbe1ffa487063b94a8ae8.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph48ldgzhj30u00uudo1_huf46a547b0f510dcda8a93c21a6643f49_120920_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph48ldgzhj30u00uudo1_huf46a547b0f510dcda8a93c21a6643f49_120920_d60766e7be1c3d1b4f0ec44a8ffd5cf3.webp&#34;
               width=&#34;739&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;之后，使用 &lt;code&gt;window.addEventListener (&#39;xhrReadyStateChange&#39;, callback)&lt;/code&gt;，在请求头中设置sw8=xxxx。同时，向后端报告请求信息。最后，我们可以在追踪页面上查看追踪数据。下图展示的追踪页面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49850myj30po0fsaas_hub6bcd5da2e7942531a1f0814eb2edc9d_37018_dd39045c802723fe41773faf44597312.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49850myj30po0fsaas_hub6bcd5da2e7942531a1f0814eb2edc9d_37018_0a4e25bba67ea17c6e86156c53374350.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49850myj30po0fsaas_hub6bcd5da2e7942531a1f0814eb2edc9d_37018_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49850myj30po0fsaas_hub6bcd5da2e7942531a1f0814eb2edc9d_37018_dd39045c802723fe41773faf44597312.webp&#34;
               width=&#34;760&#34;
               height=&#34;467&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了了解我们是如何监听 fetch 请求的，我们来看看 &lt;a href=&#34;https://github.com/github/fetch/blob/90fb680c1f50181782f276122c1b1115535b1603/fetch.js#L506&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fetch&lt;/a&gt; 的源码。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49lzy3wj30v40sq0xk_hu044ea0d2d50d6f53ff6b3c8b5d3fa85d_106454_6a72a8717d0a5ede38b3012a01ddbd89.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49lzy3wj30v40sq0xk_hu044ea0d2d50d6f53ff6b3c8b5d3fa85d_106454_9554d25fc9c1c198381cff14f6ca4ca5.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49lzy3wj30v40sq0xk_hu044ea0d2d50d6f53ff6b3c8b5d3fa85d_106454_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49lzy3wj30v40sq0xk_hu044ea0d2d50d6f53ff6b3c8b5d3fa85d_106454_6a72a8717d0a5ede38b3012a01ddbd89.webp&#34;
               width=&#34;760&#34;
               height=&#34;702&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如你所见，它创建了一个 Promise 和一个新的 XMLHttpRequest 对象。由于 fetch 的代码是内置在浏览器中的，它必须先监控代码执行。因此，当我们添加监听事件时，我们无法监控 fetch 中的代码。只是在监控完代码执行后，我们重写一下 fetch： &lt;code&gt;import {fetch} from &#39;whatwg-fetch&#39;; window.fetch = fetch;&lt;/code&gt; 这样，我们就可以通过上面的方法拦截 fetch 请求了。&lt;/p&gt;
&lt;h2 id=&#34;其他资源&#34;&gt;其他资源&lt;/h2&gt;
&lt;p&gt;从 &lt;a href=&#34;https://skywalking.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方网站&lt;/a&gt;、Tetrate &lt;a href=&#34;https://www.tetrate.io/blog/category/open-source/apache-skywalking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt; 以及可免费下载的 &lt;a href=&#34;https://www.tetrate.io/apache-skywalking-ebook-tetrate/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;电子书&lt;/a&gt; 中阅读更多关于 SKyWalking 的内容。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解读：云原生下的可观测性发展方向</title>
      <link>https://cloudnative.to/blog/cloud-native-observability/</link>
      <pubDate>Wed, 06 Jan 2021 10:47:14 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-observability/</guid>
      <description>&lt;p&gt;非常有幸参加了云原生社区 Meetup 北京站，有机会和众多业内的大牛一起讨论云原生相关的技术和应用，本次 Meetup 上我和大家分享了关于云原生下的可观测性相关的议题，相关的视频可以移步《&lt;a href=&#34;https://www.bilibili.com/video/BV1GK411g7dK&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;B 站视频回放：云原生下的可观测性&lt;/a&gt;》回看，本篇文章主要是视频的文字性总结，欢迎大家留言讨论。&lt;/p&gt;
&lt;h2 id=&#34;可观测性的由来&#34;&gt;可观测性的由来&lt;/h2&gt;
&lt;p&gt;可观测性最早来自于电气工程领域，主要原因是随着系统发展的逐步复杂，必须要有一套机制用来了解系统内部的运行状态以便更好的监控和问题修复，为此工程师们设计了很多传感器、仪表盘用于表现系统内部的状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A system is said to be observable if, for any possible evolution of &lt;a href=&#34;https://en.wikipedia.org/wiki/State_space_representation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;state and control vectors&lt;/a&gt;, the current state can be estimated using only the information from outputs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;电气工程发展了上百年，其中各个子领域的可观测性都在进行完善和升级，例如交通工具（汽车 / 飞机等）也算的是可观测性上的集大成者。抛开飞机这种超级工程不谈，一辆可正常上路的小型汽车内部也有上百种的传感器用来检测汽车内 / 外部的各种状态，以便让汽车可以稳定、舒适、安全地的行驶。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsaewyj7j30df07dtdq_hu49764eab54d2209fa6dc29e3fae00093_35462_189148c7db4c5187f6963488b62e4d64.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsaewyj7j30df07dtdq_hu49764eab54d2209fa6dc29e3fae00093_35462_9d31f2d51abff12da036f037fc267cf3.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsaewyj7j30df07dtdq_hu49764eab54d2209fa6dc29e3fae00093_35462_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsaewyj7j30df07dtdq_hu49764eab54d2209fa6dc29e3fae00093_35462_189148c7db4c5187f6963488b62e4d64.webp&#34;
               width=&#34;483&#34;
               height=&#34;265&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;可观测性的未来&#34;&gt;可观测性的未来&lt;/h2&gt;
&lt;p&gt;随着上百年的发展，电气工程下的可观测性已经不仅仅用来辅助人们进行问题检查和定位问题，我们以汽车工程来看，整个可观测性的发展经历了几个过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;盲目：1886 年 1 月 29 日德国人卡尔・本茨发明了人类史上第一辆汽车，那个时候的汽车仅仅具备行驶的最基础能力，根本没有任何和可观测性相关的事情。&lt;/li&gt;
&lt;li&gt;传感器：随着后来汽车开始正式进入市场，人们需要更好的知道汽车是不是没油了、没水了，因此基础的传感器仪表盘被发明出来。&lt;/li&gt;
&lt;li&gt;告警：为了更好的保证汽车的形式安全性，人们开始使用自检和实时告警系统来主动向驾驶员通知一些异常信息，比如电瓶没电、水温过高、胎压低、刹车片磨损等。&lt;/li&gt;
&lt;li&gt;辅助：虽然告警能够即时发出，但有时候人还是来不及处理或者不想处理，这时候辅助系统就派上了用场，例如定速巡航、主动安全、自主泊车等。这些辅助系统是把传感器 + 自动控制进行结合，能够部分解决驾驶员可能做不到或者不想做的事情。&lt;/li&gt;
&lt;li&gt;自动驾驶：上述这些功能最终还是要人去参与，而自动驾驶可以完全不需要人的参与，直接是可观测性系统 + 控制系统就可以让汽车自动运行起来。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;自动驾驶的核心要素&#34;&gt;自动驾驶的核心要素&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsahom53j315o0lk7uw_hucc7c4fe2c98a0ed305f0c56a1348c4b0_162587_022ae667ca89c9f97cdd4bad6f17cfef.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsahom53j315o0lk7uw_hucc7c4fe2c98a0ed305f0c56a1348c4b0_162587_380bc2c72175f532f0908da45a189d04.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsahom53j315o0lk7uw_hucc7c4fe2c98a0ed305f0c56a1348c4b0_162587_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsahom53j315o0lk7uw_hucc7c4fe2c98a0ed305f0c56a1348c4b0_162587_022ae667ca89c9f97cdd4bad6f17cfef.webp&#34;
               width=&#34;760&#34;
               height=&#34;393&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;作为电气工程上可观测性的巅峰，自动驾驶将汽车获取到的各类内外部数据发挥到极致，总结起来主要有几下几个核心的要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;丰富的数据源：汽车外围遍布多个激光 / 图像雷达，能够实现高帧率、360° 实时观测周围的物体及其状态；内部则能够实时知道当前的车速、车轮角度、胎压等信息，做到知彼知己。&lt;/li&gt;
&lt;li&gt;数据集中化：相对辅助驾驶能力，自动驾驶的一个核心突破是能够将车内外的所有数据集中到一起去处理，真正发挥出数据的价值，而不是每个模块的数据作为孤岛进行独立运作。&lt;/li&gt;
&lt;li&gt;强大算力：集中化的数据也意味着数据量的急剧膨胀，无论哪家自动驾驶背后都有强大的芯片支撑，只有足够的算力才能保证在最短的时间内可以进行足够的计算。&lt;/li&gt;
&lt;li&gt;软件迭代：算力 + 算法构成了智能化的最终目标，然而算法不可能完美无瑕，我们会根据逐渐积累的自动驾驶数据不断进行算法的升级，使软件系统能够不断的升级以获得更佳的自动驾驶效果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;it-系统的可观测性&#34;&gt;IT 系统的可观测性&lt;/h2&gt;
&lt;p&gt;伴随着几十年的发展，IT 系统中的监控、问题排查也逐渐抽象为可观测性工程。在当时，最主流的方式还是使用 Metrics、Logging、Tracing 的组合。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsaecgo3j30is0b4jtd_hu3de3616eee524c70e0cc59261020ac1f_37899_dcac109fe575933a747c3ec32183bf51.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsaecgo3j30is0b4jtd_hu3de3616eee524c70e0cc59261020ac1f_37899_bc2585044959d20bd13816d1b8c584ae.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsaecgo3j30is0b4jtd_hu3de3616eee524c70e0cc59261020ac1f_37899_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsaecgo3j30is0b4jtd_hu3de3616eee524c70e0cc59261020ac1f_37899_dcac109fe575933a747c3ec32183bf51.webp&#34;
               width=&#34;676&#34;
               height=&#34;400&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上面这幅图详细大家非常熟悉，这是 Peter Bourgon 在参加完 2017 Distributed Tracing Summit 后发表的一篇博文，简洁扼要地介绍了 Metrics、Tracing、Logging 三者的定义和关系。这三种数据在可观测性中都有各自的发挥空间，每种数据都没办法完全被其他数据代替。&lt;/p&gt;
&lt;p&gt;以 Grafana Loki 中介绍中的一个典型问题排查过程来看：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最开始我们通过各式各样的预设报警发现异常（通常是Metrics/Logging）&lt;/li&gt;
&lt;li&gt;发现异常后，打开监控大盘查找异常的曲线，并通过各种查询/统计找到异常的模块（Metrics）&lt;/li&gt;
&lt;li&gt;对这个模块以及关联的日志进行查询/统计分析，找到核心的报错信息（Logging）&lt;/li&gt;
&lt;li&gt;最后通过详细的调用链数据定位到引起问题的代码（Tracing）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsabpa1kj31420m8dss_hu6b939189a956c5da1bf54f4f62f7b1ed_132101_c87daaaae1667518fbfc140fbaa6023a.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsabpa1kj31420m8dss_hu6b939189a956c5da1bf54f4f62f7b1ed_132101_788c905c20ca277a5f2ead0c503ab13f.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsabpa1kj31420m8dss_hu6b939189a956c5da1bf54f4f62f7b1ed_132101_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsabpa1kj31420m8dss_hu6b939189a956c5da1bf54f4f62f7b1ed_132101_c87daaaae1667518fbfc140fbaa6023a.webp&#34;
               width=&#34;760&#34;
               height=&#34;422&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上述例子介绍了如何使用 Metric、Tracing、Logging 去联合排查问题，当然根据不同的场景可以有不同的结合方案，例如简单的系统可以直接通过日志的错误信息去告警并直接定位问题，也可以根据调用链提取的基础指标（Latency、ErrorCode）触发告警。但整体而言，一个具有良好可观测性的系统必须具备上述三种数据。&lt;/p&gt;
&lt;h2 id=&#34;云原生下的可观测性&#34;&gt;云原生下的可观测性&lt;/h2&gt;
&lt;p&gt;云原生带来的不仅仅是应用部署能够部署云上而已，其整个的定义是一套新的 IT 系统架构升级，包括开发模式、系统架构、部署模式、基础设施全套的演进和迭代。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsadyme7j315o0kzwp3_hu6ee8d7719a7d5ea1b8b48277752fd1e2_118253_a6c517807fb86850aa4b76f8014bbd1d.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsadyme7j315o0kzwp3_hu6ee8d7719a7d5ea1b8b48277752fd1e2_118253_b9a1acafa6882774a8610a17f522ca8a.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsadyme7j315o0kzwp3_hu6ee8d7719a7d5ea1b8b48277752fd1e2_118253_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsadyme7j315o0kzwp3_hu6ee8d7719a7d5ea1b8b48277752fd1e2_118253_a6c517807fb86850aa4b76f8014bbd1d.webp&#34;
               width=&#34;760&#34;
               height=&#34;383&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;效率要求更高：随着 DevOps 模式的普及，规划、开发、测试、交付.. 的效率要求越来越高，而与之带来的问题是需要更加实时的知道此次的发布是否成功，出现了什么问题，问题在哪里，如何快速去解决。&lt;/li&gt;
&lt;li&gt;系统更加复杂：架构从最开始的一体化发展到分层模式，到现在的微服务模式，架构的升级带来了开发效率、发布效率、系统灵活性、鲁棒性等优势，但随之而来系统的复杂度将更高，问题的定位将更加难。&lt;/li&gt;
&lt;li&gt;环境动态性增强：无论是微服务的架构还是容器化的部署模式，带来的一个特性是环境的动态性会增强，每个实例的生命周期会更短，出现问题后往往现场已经被破坏，登录机器排查问题的方式已经不复存在。&lt;/li&gt;
&lt;li&gt;上下游依赖更多：问题的定位最终都会从上下游来排查，在微服务、云、K8s 的环境中，上下游将更加多，包括各类其他业务应用、云上使用的各类产品、各种中间件、K8s 自身、容器运行时、虚拟机等等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;拯救者opentelemetry&#34;&gt;拯救者：OpenTelemetry&lt;/h2&gt;
&lt;p&gt;上述的这些问题相信很多读者都会深有体会，而业界也针对这种情况退出了各类可观测性相关的产品，包括开源、商业化的众多项目。例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Metrics：Zabbix、Nagios、Prometheus、InfluxDB、OpenFalcon、OpenCensus&lt;/li&gt;
&lt;li&gt;Tracing：Jaeger、Zipkin、SkyWalking、OpenTracing、OpenCensus&lt;/li&gt;
&lt;li&gt;Logging：ELK、Splunk、SumoLogic、Loki、Loggly&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsad11dyj30gb08678x_hu912d523760311966775ab52d3447d93c_43244_87c831a3bbc6d456ceabb329c847735a.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsad11dyj30gb08678x_hu912d523760311966775ab52d3447d93c_43244_8bd1b46038e406c6a8bea5576523ca19.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsad11dyj30gb08678x_hu912d523760311966775ab52d3447d93c_43244_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsad11dyj30gb08678x_hu912d523760311966775ab52d3447d93c_43244_87c831a3bbc6d456ceabb329c847735a.webp&#34;
               width=&#34;587&#34;
               height=&#34;294&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;利用这些项目的组合或多或少可以解决针对性的一类或者几类问题，但真正应用起来你会发现各种问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多套方案交织：可能要使用至少 Metrics、Logging、Tracing3 种方案，维护代价巨大&lt;/li&gt;
&lt;li&gt;数据不互通：虽然是同一个业务组件，同一个系统，产生的数据由于在不同的方案中，数据难以互通，无法充分发挥数据价值&lt;/li&gt;
&lt;li&gt;厂商绑定：无论从数据采集、传输、存储、计算、可视化、告警等都可能会被厂商绑定，可观测性系统一旦上线后替换的代价讲巨大无比&lt;/li&gt;
&lt;li&gt;云原生不友好：这些方案其中很多都是针对传统系统的，对于云原生的支持相对较弱，而且方案本身部署和使用代价都很高，不符合 “云原生” 这种一键部署、开箱即用的使用方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsah5yzmj30wc08gae3_hufc7e49c819f1ad75bf33295b9fe76c8e_39730_73ec588c80f89f985196a1cb70252c6b.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsah5yzmj30wc08gae3_hufc7e49c819f1ad75bf33295b9fe76c8e_39730_39b6f4e6706034dda88a0abbdcdcd8d0.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsah5yzmj30wc08gae3_hufc7e49c819f1ad75bf33295b9fe76c8e_39730_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsah5yzmj30wc08gae3_hufc7e49c819f1ad75bf33295b9fe76c8e_39730_73ec588c80f89f985196a1cb70252c6b.webp&#34;
               width=&#34;760&#34;
               height=&#34;198&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在此背景下，云原生基金会 CNCF 下诞生了 OpenTelemetry 项目，旨在将 Logging、Tracing、Metrics 三者进行统一，实现数据的互通互操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Create and collect telemetry data from your services and software, then forward them to a variety of analysis tools.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OpenTelemetry 最核心的功能是产生、收集可观测性数据，并支持传输到各种的分析软件中，整体的架构如下图所属，其中 Library 用于产生统一格式的可观测性数据；Collector 用来接收这些数据，并支持把数据传输到各种类型的后端系统。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsafamk9j315o0hx46t_hubc211b819bdf7e569d0419eb07aa891b_95955_1a0b46d4d13691fb74a22757880f14d8.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsafamk9j315o0hx46t_hubc211b819bdf7e569d0419eb07aa891b_95955_0a3ee6bd61b1c8565072cc23867fd049.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsafamk9j315o0hx46t_hubc211b819bdf7e569d0419eb07aa891b_95955_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsafamk9j315o0hx46t_hubc211b819bdf7e569d0419eb07aa891b_95955_1a0b46d4d13691fb74a22757880f14d8.webp&#34;
               width=&#34;760&#34;
               height=&#34;327&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OpenTelemetry 给云原生下带来的革命性的进步，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统一协议：OpenTelemetry 为我们带来了 Metric、Tracing、Logging（正在制定中，LogModel 已经定义完毕）的统一标准，三者都有相同的元数据结构，可以轻松实现互相关联&lt;/li&gt;
&lt;li&gt;统一 Agent：使用一个 Agent 即可完成所有可观测性数据的采集和传输，不需要为每个系统都部署各种各样的 Agent，大大降低了系统的资源占用，使整体可观测性系统的架构也变的更加简单&lt;/li&gt;
&lt;li&gt;云原生友好：OpenTelemetry 诞生在 CNCF，对于各类的云原生下的系统支持更加友好，此外目前众多云厂商已经宣布支持 OpenTelemetry，未来云上的使用会更加便捷&lt;/li&gt;
&lt;li&gt;厂商无关：此项目完全中立，不倾向于任何一家厂商，让大家可以有充分的自由来选择 / 更换适合自己的服务提供商，而不需要收到某些厂商的垄断或者绑定&lt;/li&gt;
&lt;li&gt;兼容性：OpenTelemetry 得到了 CNCF 下各种可观测性方案的支持，未来对于 OpenTracing 类、OpenCensus、Prometheus、Fluntd 等都会有非常好的兼容性，可以方便大家无缝迁移到 OpenTelemetry 方案上。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;opentelemetry-限制&#34;&gt;OpenTelemetry 限制&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsafux5gj315o0kv7fz_hu69c0262153efda3a08c2303d7aae4e17_99420_35da7b5bd9d7c07c740537019c92562d.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsafux5gj315o0kv7fz_hu69c0262153efda3a08c2303d7aae4e17_99420_69072590a198a37f5472daa629ddbed8.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsafux5gj315o0kv7fz_hu69c0262153efda3a08c2303d7aae4e17_99420_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsafux5gj315o0kv7fz_hu69c0262153efda3a08c2303d7aae4e17_99420_35da7b5bd9d7c07c740537019c92562d.webp&#34;
               width=&#34;760&#34;
               height=&#34;381&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从上面的分析来看，OpenTelemetry 的定位是作为可观测性的基础设施，解决数据规范与获取的问题，后续部分依赖各个 Vendor 来实现。当然最佳的方式是能够有一个统一的引擎去存储所有的 Metrics、Logging、Tracing，有一个统一的平台去分析、展示、关联这些数据。目前的话还没有一个厂商能够非常好的支持 OpenTelemetry 的统一后端，现在还是需要自己去使用各个厂商的产品来实现。而这个带来的另一个问题是各个数据的关联会更加复杂，还需要去解决每个厂商之间的数据关联性问题。当然这个问题相信在 1-2 年肯定会解决掉，现在有众多厂商开始在努力实现 OpenTelemetry 所有类型数据的统一方案。&lt;/p&gt;
&lt;h2 id=&#34;可观测性的未来方向&#34;&gt;可观测性的未来方向&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsacga6sj30jk07t0yd_hub028f0292d0320f48c7dbf6fad3819ed_43494_75686f1ac9a6f33c6ea402d0f849c8dd.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsacga6sj30jk07t0yd_hub028f0292d0320f48c7dbf6fad3819ed_43494_89fd282adabe76d93f737c95cdd65424.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsacga6sj30jk07t0yd_hub028f0292d0320f48c7dbf6fad3819ed_43494_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsacga6sj30jk07t0yd_hub028f0292d0320f48c7dbf6fad3819ed_43494_75686f1ac9a6f33c6ea402d0f849c8dd.webp&#34;
               width=&#34;704&#34;
               height=&#34;281&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们团队从刚开始 09 年做飞天 5K 项目起，就一直在负责监控、日志、分布式链路追踪等可观测性相关的工作，中间经历过小型机到分布式系统再到微服务、云化的一些架构变更，相关的可观测性方案也经历了很多演变。我们觉得整体上可观测性相关的发展和自动驾驶等级的设定非常吻合。&lt;/p&gt;
&lt;p&gt;自动驾驶一共分为 6 级，其中 0-2 级主要还是靠人来进行决定，到了等级 3 之后就可以进行无意识驾驶，也就是手眼可以暂时性不用关注驾驶，到了等级 5 的话人就可以完全脱离驾驶这个枯燥的工作，在车上可以自由活动。&lt;/p&gt;
&lt;p&gt;在 IT 系统的可观测性上，也可以类似划分 6 级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等级 0：手工分析，依靠基础的 Dashboard、告警、日志查询、分布式链路追踪等方式进行手动告警、分析，也是目前绝大部分公司使用的场景&lt;/li&gt;
&lt;li&gt;等级 1：智能告警，能够自动去扫描所有的可观测性数据，利用机器学习的方式去识别一些异常并进行自动告警，免去人工设置 / 调整各种基线告警的工作&lt;/li&gt;
&lt;li&gt;等级 2：异常关联 + 统一视图，对于自动识别的异常，能够进行上下文的关联，形成一个统一的业务视图，便于快速的定位问题&lt;/li&gt;
&lt;li&gt;等级 3：根因分析 + 问题自愈，自动根据异常以及系统的 CMDB 信息直接定位问题的根因，根因定位准确后那边可以去做问题的自愈。这一阶段相当于是一次质的飞跃，在某些场景下可以在人不用参与的情况下实现问题的自愈。&lt;/li&gt;
&lt;li&gt;等级 4：故障预测，故障发生总会有损失，所以最好的情况是避免故障的发生，因此故障预测技术可以更好的来保证系统的可靠性，利用之前积累的一些故障先兆信息做到 “未卜先知”&lt;/li&gt;
&lt;li&gt;等级 5：变更影响预测，我们知道绝大部分的故障都是由变更引起的，因此如果能够模拟出每个变更对系统带来的影响以及可能产生的问题，我们就能够提前评估出是否能够允许此次变更。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsadf9k4j315o0dewir_hu524aef5f65abbe78f134b23dd9c97629_58934_747d8c1714370f0f5f66c307fa6ed804.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsadf9k4j315o0dewir_hu524aef5f65abbe78f134b23dd9c97629_58934_d47d0860afae8d66b32288e61e35f8b2.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsadf9k4j315o0dewir_hu524aef5f65abbe78f134b23dd9c97629_58934_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsadf9k4j315o0dewir_hu524aef5f65abbe78f134b23dd9c97629_58934_747d8c1714370f0f5f66c307fa6ed804.webp&#34;
               width=&#34;760&#34;
               height=&#34;244&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;阿里云-sls-在可观测性相关的工作&#34;&gt;阿里云 SLS 在可观测性相关的工作&lt;/h2&gt;
&lt;p&gt;目前我们 SLS 正在开展云原生可观测性的工作，基于 OpenTelemetry 这个未来云原生下可观测性的标准，实现各类可观测性数据的统一收集，覆盖各个数据源和各类数据类型，做到多语言支持、多设备支持、类型统一；向上我们会提供能够支持各类可观测性数据的统一存储和计算能力，支持 PB 级存储、ETL、流计算、百亿级数据秒级分析，为上层算法提供强大的算力支撑；IT 系统的问题非常复杂，尤其涉及到不同的场景和架构，因此我们把算法和经验结合起来进行异常的分析，算法包括基础的统计学、逻辑性算法，也包括 AIOp 相关的算法，经验中包括人工输入的专家知识、网上上积累的各类问题解决方案以及外部产生的一些事件；最上层我们会提供一些辅助决策的功能，例如告警通知、数据可视化、Webhook 等，此外会提供丰富的外部集成能力，例如对接三方的可视化 / 分析 / 告警系统，提供 OpenAPI 以便不同的应用方集成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsagsxmij315o0n0dzu_hu82e625f8aee579ea125e68b635919264_180982_adde2dfd6869394e6f4f28a00dae7769.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsagsxmij315o0n0dzu_hu82e625f8aee579ea125e68b635919264_180982_cdca458ee3bc7a1b789f49db51092b81.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsagsxmij315o0n0dzu_hu82e625f8aee579ea125e68b635919264_180982_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsagsxmij315o0n0dzu_hu82e625f8aee579ea125e68b635919264_180982_adde2dfd6869394e6f4f28a00dae7769.webp&#34;
               width=&#34;760&#34;
               height=&#34;419&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;作为 CNCF 下除了 Kubernetes 外最活跃的项目，OpenTelemetry 受到了各大云厂商以及相关解决方案公司的关注，相信未来一定会成为云原生下可观测性的标准。虽然目前还没有到生产可用的程度，但是目前各个语言的 SDK 和 Collector 也基本上稳定，在 2021 年就能够发布生产可用的版本，值得大家期待。&lt;/p&gt;
&lt;p&gt;而 OpenTelemetry 只是定义了可观察的前半部分，后面还有非常多的复杂工作需要我们去实现，任重道远。&lt;/p&gt;
&lt;p&gt;重点来了！！！！SLS 团队长期招聘人才，欢迎对大数据、监控、可观测性、前端可视化、移动端开发、机器学习等有兴趣的同学前来联系我:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邮箱： &lt;a href=&#34;mailto:davidzhang.zc@alibaba-inc.com&#34;&gt;davidzhang.zc@alibaba-inc.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;微信： davidzhang-zc。&lt;/li&gt;
&lt;li&gt;职位： &lt;a href=&#34;https://cloudnative.to/job/aliyun-sls-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://cloudnative.to/job/aliyun-sls-observability/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://opentelemetry.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://opentelemetry.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.aliyun.com/article/766070&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://developer.aliyun.com/article/766070&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aiopsworkshop.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://aiopsworkshop.github.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://landscape.cncf.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.instana.com/blog/observability-vs-monitoring/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.instana.com/blog/observability-vs-monitoring/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
