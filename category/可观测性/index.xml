<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>可观测性 | 云原生社区</title>
    <link>https://cloudnative.to/category/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link>
      <atom:link href="https://cloudnative.to/category/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/index.xml" rel="self" type="application/rss+xml" />
    <description>可观测性</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 06 May 2021 02:04:05 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>可观测性</title>
      <link>https://cloudnative.to/category/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link>
    </image>
    
    <item>
      <title>New Relic 开源 Pixie，其 Kubernetes 原生集群内观察平台</title>
      <link>https://cloudnative.to/blog/new-relic-open-sources-pixie-its-kubernetes-native-in-cluster-observability-platform/</link>
      <pubDate>Thu, 06 May 2021 02:04:05 +0800</pubDate>
      <guid>https://cloudnative.to/blog/new-relic-open-sources-pixie-its-kubernetes-native-in-cluster-observability-platform/</guid>
      <description>&lt;p&gt;本文译自 ZDNet 的文章 &lt;a href=&#34;https://www.zdnet.com/article/new-relic-open-sources-pixie-its-kubernetes-native-in-cluster-observability-platform/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;New Relic open sources Pixie, its Kubernetes-native in-cluster observability platform&lt;/a&gt;，译者&lt;a href=&#34;https://jimmysong.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;宋净超&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;好消息是，云计算、&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 和云原生计算结合在一起，使软件开发比以前更快、更强大。坏消息是，保持对所有这些的关注比以往任何时候都更难。这就是为什么 &lt;a href=&#34;https://newrelic.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;New Relic&lt;/a&gt; 将其 Kubernetes 原生集群内观察平台 &lt;a href=&#34;http://px.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pixie&lt;/a&gt; 作为一个新的开源项目，在 &lt;a href=&#34;https://www.apache.org/licenses/LICENSE-2.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache 2.0 许可&lt;/a&gt;下贡献给&lt;a href=&#34;https://www.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生计算基金会（CNCF）的&lt;/a&gt;原因，这是一个好消息。&lt;/p&gt;
&lt;p&gt;Pixie 是一个新的云原生应用程序的可观察性平台。有了它，开发人员可以通过一个 shell 命令看到他们应用程序的所有指标、事件、日志和追踪。有了 Pixie，你不需要添加度量（instrumentation ）代码，设置临时仪表板，或将数据移出集群，就能看到正在发生的事情。这将为你节省宝贵的时间，这样你就可以致力于建立更好的软件，而不是用更好的方法来监控它。&lt;/p&gt;
&lt;p&gt;该程序作为一组 Kubernetes 服务部署在被监控的集群内。简而言之，Pixie 是一个原生的 Kubernetes 程序。它的 Pixie 边缘模块（PEM）被部署为 DaemonSet。在你的集群内，PEM 利用 Pixie 的 &lt;a href=&#34;https://lwn.net/Articles/740157/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 程序来收集网络事务和系统指标，而不需要修改代码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;亚马逊网络服务（AWS）&lt;/a&gt;可观察性服务总经理 Mark Carter 补充说：“有了 &lt;a href=&#34;https://newrelic.com/blog/best-practices/what-is-ebpf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt;，即 Pixie 平台支持的 Linux 中的新度量能力，开发和运维可以利用一种新的可观察性的超级力量。”&lt;/p&gt;
&lt;p&gt;这是非常方便的。正如 New Relic 总裁 Bill Staples 在博客中所说。“这些&lt;a href=&#34;https://newrelic.com/blog/nerd-life/open-source-observability-pixie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生环境&lt;/a&gt;的动态、分布式性质&lt;a href=&#34;https://newrelic.com/blog/nerd-life/open-source-observability-pixie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;带来了一系列新的可观察性挑战&lt;/a&gt;。我们相信开源的、社区驱动是解决这些挑战的最好方法”。因此，通过使用 &lt;a href=&#34;https://opensource.newrelic.com/projects/open-telemetry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 作为度量化标准&lt;/a&gt;，分析和故障排除都变得更加容易。&lt;/p&gt;
&lt;p&gt;Staples 继续说道。“通过一个命令，你可以点亮你的整个云环境并立即获得遥测数据。我们相信所有的开发者都应该获得这种惊人的开发者体验，它可以减少观察的摩擦，节省宝贵的时间以用来开发更好的软件。为了实现这一目标，我们还将 Pixie 的大部分工程资源投入到这个开源项目中。”&lt;/p&gt;
&lt;p&gt;展望未来，New Relic 公司 Pixie 和 New Relic 开源部总经理、最近收购的 &lt;a href=&#34;https://pixielabs.ai/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pixie 实验室&lt;/a&gt;的首席执行官兼联合创始人 Zain Asgar 说，“开源是 New Relic 和 Pixie 的决定性价值，这就是为什么我们正在用 OpenTelemetry 对我们的可观察性产品进行标准化，并正在将 Pixie 作为一个开源项目进行贡献。我们已经亲眼看到了开放治理对开源项目的积极影响，我们期待着通过我们在 CNCF 的 [新] 白金会员资格，在全行业范围内支持这一倡议。”&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/blogs/opensource/gathering-insights-on-kubernetes-applications-services-and-network-traffic-with-pixie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pixie 开源现在也将在 AWS 上运行&lt;/a&gt;，作为 OpenTelemetry 项目的一个安全的、可生产的、由 AWS 支持的发行版。&lt;/p&gt;
&lt;p&gt;CNCF 总经理 Priyanka Sharma 欢迎 New Relic 加入该组织。“我们很高兴欢迎 New Relic 成为白金会员和 Zain Asgar 加入我们的董事会。Zain 和 New Relic 对推进我们的使命和支持我们的社区的承诺将有很大的帮助。我们特别期待着他们在可观察性方面细致入微的专业知识和观点”。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SkyWalking 前端监控的应用</title>
      <link>https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/</link>
      <pubDate>Tue, 13 Apr 2021 18:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/</guid>
      <description>&lt;p&gt;网络应用性能会影响用户的留存率。如果页面加载时间过长，用户就会放弃。所以我们需要监控 Web 应用来了解性能，确保服务稳定、可用、健康。&lt;a href=&#34;https://github.com/apache/skywalking&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache SkyWalking&lt;/a&gt; 是一款专门为云原生和基于容器架构设计的应用性能监控（APM）工具。其 &lt;a href=&#34;https://github.com/apache/skywalking-client-js&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;skywalking-client-js&lt;/a&gt; 是一个轻量级的客户端 JavaScript 异常、性能和追踪库。&lt;/p&gt;
&lt;p&gt;本文介绍了 skywalking-client-js 如何将其监控扩展到浏览器，为 SkyWalking 后端提供性能指标和错误收集。&lt;/p&gt;
&lt;h2 id=&#34;性能指标&#34;&gt;性能指标&lt;/h2&gt;
&lt;p&gt;skywalking-client-js 使用 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Window/performance&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;window.performance&lt;/a&gt; 来收集性能数据。从 MDN 文档来看，性能接口提供了对当前页面的性能相关信息的访问。它是 High Resolution Time API 的一部分，但对 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Performance_Timeline&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Performance Timeline API&lt;/a&gt;、&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Navigation Timing API&lt;/a&gt;、&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;User Timing API&lt;/a&gt; 和 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Resource Timing API&lt;/a&gt; 有所增强。&lt;/p&gt;
&lt;p&gt;在 skywalking-client-js 中，所有的性能指标都是根据 W3C 规范中定义的 &lt;a href=&#34;https://www.w3.org/TR/navigation-timing/?spm=a2c4g.11186623.2.12.2f495c7cmRef8Q#sec-navigation-timing-interface&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Navigation Timing API&lt;/a&gt; 来计算的。我们可以使用 window.performance.timing 属性获得一个描述页面的 PerformanceTiming 对象。PerformanceTiming 接口包含的属性提供了当前页面加载和使用过程中发生的各种事件的性能计时信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3x19976j30oa0bnac9_hu036958af73a4c58cd47b604adbdaac50_59550_4121cb529d3f5a310add56f8d738f2db.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3x19976j30oa0bnac9_hu036958af73a4c58cd47b604adbdaac50_59550_8a6f0aa86f62469fa31ea6ad39835f26.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3x19976j30oa0bnac9_hu036958af73a4c58cd47b604adbdaac50_59550_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3x19976j30oa0bnac9_hu036958af73a4c58cd47b604adbdaac50_59550_4121cb529d3f5a310add56f8d738f2db.webp&#34;
               width=&#34;760&#34;
               height=&#34;364&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们把这些属性放在一起看，可以更好地理解 &lt;a href=&#34;https://www.w3.org/TR/navigation-timing/?spm=a2c4g.11186623.2.14.2f495c7cmRef8Q#processing-model&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;W3C&lt;/a&gt; 的下图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3xf13fjj30pc0ff74i_hu4a29a54dd8178a67ea343928796a9d32_69367_3415d74b8d64f3f29d3ad03ac1727b0b.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3xf13fjj30pc0ff74i_hu4a29a54dd8178a67ea343928796a9d32_69367_58669b4d9838a1bb08245434866decf3.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3xf13fjj30pc0ff74i_hu4a29a54dd8178a67ea343928796a9d32_69367_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3xf13fjj30pc0ff74i_hu4a29a54dd8178a67ea343928796a9d32_69367_3415d74b8d64f3f29d3ad03ac1727b0b.webp&#34;
               width=&#34;760&#34;
               height=&#34;463&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;下表包含了 skywalking-client-js 的性能指标。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Metrics 名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;计算公式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redirectTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Page redirection time&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;redirectEnd – redirectStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;If the current document and the document that is redirected to are not from the same &lt;a href=&#34;http://tools.ietf.org/html/rfc6454&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;origin&lt;/a&gt;, set redirectStart, redirectEnd to 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ttfbTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to First Byte&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseStart – requestStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;According to &lt;a href=&#34;https://developers.google.com/web/tools/chrome-devtools/network/reference?spm=a2c4g.11186623.2.16.2f495c7cmRef8Q#timing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Development&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dnsTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to DNS query&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domainLookupEnd – domainLookupStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;tcpTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to TCP link&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connectEnd – connectStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;transTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to content transfer&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseEnd – responseStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sslTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to SSL secure connection&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;connectEnd – secureConnectionStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Only supports HTTPS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;resTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to resource loading&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;loadEventStart – domContentLoadedEventEnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Represents a synchronized load resource in pages&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fmpTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to First Meaningful Paint&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Listen for changes in page elements. Traverse each new element, and calculate the total score of these elements. If the element is visible, the score is 1 * weight; if the element is not visible, the score is 0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domAnalysisTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to DOM analysis&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domInteractive – responseEnd&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;fptTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;First Paint Time&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseEnd – fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domReadyTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to DOM ready&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domContentLoadedEventEnd – fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;loadPageTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Page full load time&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;loadEventStart – fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ttlTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to interact&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;domInteractive – fetchStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;firstPackTime&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Time to first package&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;responseStart – domainLookupStart&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;skywalking-client-js 收集这些性能指标，并发送给 &lt;a href=&#34;https://skywalking.apache.org/docs/main/latest/en/concepts-and-designs/backend-overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAP（Observability Analysis Platform）服务器&lt;/a&gt;，服务器在后台汇总数据，然后在 UI 端以可视化的方式展示出来。用户可以根据这些数据来优化页面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3yjrgk5j30q90abwfa_huc82276cb30f693cde10cde237f53a440_45929_c5c622c2786d7c361694abfdf49b2fec.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3yjrgk5j30q90abwfa_huc82276cb30f693cde10cde237f53a440_45929_79d5810175805f82c2bf4ad0e162345b.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3yjrgk5j30q90abwfa_huc82276cb30f693cde10cde237f53a440_45929_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3yjrgk5j30q90abwfa_huc82276cb30f693cde10cde237f53a440_45929_c5c622c2786d7c361694abfdf49b2fec.webp&#34;
               width=&#34;760&#34;
               height=&#34;298&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;异常指标&#34;&gt;异常指标&lt;/h2&gt;
&lt;p&gt;在 skywalking-client-js 中可以捕捉到五种错误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;window.addeventlistener (&#39;error &#39;, callback, true)&lt;/code&gt; 捕捉资源加载错误。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;window.onerror&lt;/code&gt; 抓取 JS 执行错误。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;window.addEventListener (&#39;unhandledrejection&#39;, callback)&lt;/code&gt; 用来捕捉Promise错误。&lt;/li&gt;
&lt;li&gt;Vue 错误由 &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; 捕获。&lt;/li&gt;
&lt;li&gt;Ajax 错误由 &lt;code&gt;addEventListener (&#39;error&#39;，callback);addEventListener (&#39;abort&#39;，callback);addEventListener (&#39;timeout&#39;，callback);&lt;/code&gt; 在 send callback 中捕获。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;skywalking-client-js 将错误数据追踪到 OAP 服务器，最后在 UI 端将数据可视化呈现。对于 App 的错误概况，有几个指标可以进行基本的统计和错误的趋势，包括以下指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;App Error Count，选定时间段内的错误总数。&lt;/li&gt;
&lt;li&gt;App JS 错误率，选定时间段内有 JS 错误的 PV 占总 PV 的比例。&lt;/li&gt;
&lt;li&gt;All of Apps Error Count，Top N Apps 错误数排名。&lt;/li&gt;
&lt;li&gt;All of Apps JS Error Rate，前 N 个 Apps JS 错误率排名。&lt;/li&gt;
&lt;li&gt;所选 App 中的版本错误数，所选 App 中的版本错误数排名前 N 名。&lt;/li&gt;
&lt;li&gt;所选 App 中的版本错误率，所选 App 中的版本错误率排名前 N 名 JS 错误率排名。&lt;/li&gt;
&lt;li&gt;所选 App 的出错率，所选 App 的出错率排名前 N 名。&lt;/li&gt;
&lt;li&gt;所选 App 的错误率，所选 App 排名的前 N 个 JS 错误率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3zef9w5j31530rn425_hu53d82cd1ce8666165a0a2be9bd990440_149373_7f9532e857bb1bc7c48dd18746ea1c9a.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3zef9w5j31530rn425_hu53d82cd1ce8666165a0a2be9bd990440_149373_f6496a2f74549967eca112427273ad9a.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3zef9w5j31530rn425_hu53d82cd1ce8666165a0a2be9bd990440_149373_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph3zef9w5j31530rn425_hu53d82cd1ce8666165a0a2be9bd990440_149373_7f9532e857bb1bc7c48dd18746ea1c9a.webp&#34;
               width=&#34;760&#34;
               height=&#34;511&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于页面，我们使用多个指标进行基本统计和错误趋势，包括以下指标。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Top Unstable Pages / Error Rate, Top N Error Count pages of the Selected version ranking.&lt;/li&gt;
&lt;li&gt;Top Unstable Pages / Error Count，Top N Error Count 页面的 Selected 版本排名。&lt;/li&gt;
&lt;li&gt;页面错误数布局，一段时间内不同错误的数据显示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4797f9nj31360jxmyo_hu9d2ebf8a00ee69d497dbc95026e41897_81254_69e17557e09c6fc94e9a8bd31659fbf3.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4797f9nj31360jxmyo_hu9d2ebf8a00ee69d497dbc95026e41897_81254_bef967aaf6aa09bc801d8f128931e897.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4797f9nj31360jxmyo_hu9d2ebf8a00ee69d497dbc95026e41897_81254_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4797f9nj31360jxmyo_hu9d2ebf8a00ee69d497dbc95026e41897_81254_69e17557e09c6fc94e9a8bd31659fbf3.webp&#34;
               width=&#34;760&#34;
               height=&#34;386&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;用户指标&#34;&gt;用户指标&lt;/h2&gt;
&lt;p&gt;SkyWalking 浏览器监控还提供了访客使用被监控网站的指标，如 PV（页面浏览量）、UV（独立访客）、前 N 名 PV（页面浏览量）等。&lt;/p&gt;
&lt;p&gt;在 SPA（单页应用）中，页面只会被刷新一次。传统方法只在页面加载后报告一次 PV，但无法统计每个子页面的 PV，也无法使其他类型的日志按子页面进行汇总。&lt;/p&gt;
&lt;p&gt;SkyWalking 浏览器监控针对 SPA 页面提供了两种处理方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启用 SPA 自动解析。该方法适用于大多数以 URL 哈希为路由的单页应用场景。在初始化配置项中，将 enableSPA 设置为 true，将开启页面的哈希变化事件监听器（触发重报 PV），在其他数据报送中使用 URL 哈希作为页面字段。&lt;/li&gt;
&lt;li&gt;手动上报。如果第一种方法无法使用，该方法可以用于所有单页应用场景。下面的例子提供了一个设置页面的方法，当数据上报时，可以手动更新页面名称。调用此方法时，页面 PV 将被默认重新上报：&lt;a href=&#34;https://gist.github.com/Fine0830/53d36508671882e210d7fca861555ce9%e3%80%82&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://gist.github.com/Fine0830/53d36508671882e210d7fca861555ce9。&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们来看看下图中的结果。它显示了最受欢迎的应用和版本，以及一段时间内 PV 的变化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4820dzsj30du0n975k_hub800e8cb9bd255e134b8eccaf591e5c1_40812_5e66265e4fae17fa7205da8ccbdf1414.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4820dzsj30du0n975k_hub800e8cb9bd255e134b8eccaf591e5c1_40812_269ba06ad5f24e15567746594b12d211.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4820dzsj30du0n975k_hub800e8cb9bd255e134b8eccaf591e5c1_40812_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph4820dzsj30du0n975k_hub800e8cb9bd255e134b8eccaf591e5c1_40812_5e66265e4fae17fa7205da8ccbdf1414.webp&#34;
               width=&#34;452&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;让浏览器成为分布式追踪的起点。&lt;/p&gt;
&lt;p&gt;SkyWalking 浏览器监控拦截 HTTP 请求，追踪段（Segment）和跨度（Span）。它支持追踪以下模式的 HTTP 请求。&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;XMLHttpRequest&lt;/a&gt; 和 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fetch.&lt;/a&gt;。它还支持追踪基于 XMLHttpRequest 和 fetch 的库和工具 —— 如 &lt;a href=&#34;https://github.com/axios/axios&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Axios&lt;/a&gt;、&lt;a href=&#34;https://github.com/visionmedia/superagent&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SuperAgent&lt;/a&gt;、&lt;a href=&#34;https://www.openapis.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenApi&lt;/a&gt; 等。&lt;/p&gt;
&lt;p&gt;我们来看看 SkyWalking 浏览器监控是如何拦截 HTTP 请求的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph48ldgzhj30u00uudo1_hu5866f2ef945b9d7ce6a4a8721bdce7ba_133694_3f4f42644a5f514462ed32544345e329.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph48ldgzhj30u00uudo1_hu5866f2ef945b9d7ce6a4a8721bdce7ba_133694_577177a680477753a2676fade7f971d2.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph48ldgzhj30u00uudo1_hu5866f2ef945b9d7ce6a4a8721bdce7ba_133694_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph48ldgzhj30u00uudo1_hu5866f2ef945b9d7ce6a4a8721bdce7ba_133694_3f4f42644a5f514462ed32544345e329.webp&#34;
               width=&#34;739&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;之后，使用 &lt;code&gt;window.addEventListener (&#39;xhrReadyStateChange&#39;, callback)&lt;/code&gt;，在请求头中设置sw8=xxxx。同时，向后端报告请求信息。最后，我们可以在追踪页面上查看追踪数据。下图展示的追踪页面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49850myj30po0fsaas_hu23fb1eb96e630a4724f8ee511d75d990_40205_6eac6187a3e4bbf43aadac77f5db5d80.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49850myj30po0fsaas_hu23fb1eb96e630a4724f8ee511d75d990_40205_174fd6e1ed164b6209f0f39f109c41ab.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49850myj30po0fsaas_hu23fb1eb96e630a4724f8ee511d75d990_40205_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49850myj30po0fsaas_hu23fb1eb96e630a4724f8ee511d75d990_40205_6eac6187a3e4bbf43aadac77f5db5d80.webp&#34;
               width=&#34;760&#34;
               height=&#34;467&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了了解我们是如何监听 fetch 请求的，我们来看看 &lt;a href=&#34;https://github.com/github/fetch/blob/90fb680c1f50181782f276122c1b1115535b1603/fetch.js#L506&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fetch&lt;/a&gt; 的源码。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49lzy3wj30v40sq0xk_hu38d05b2abda17b762139a260ffae4fc8_116605_e4a5774a7dd8af3f8a5bb0f834612180.webp 400w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49lzy3wj30v40sq0xk_hu38d05b2abda17b762139a260ffae4fc8_116605_39299593af292520be1e5bb5491a9608.webp 760w,
               /blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49lzy3wj30v40sq0xk_hu38d05b2abda17b762139a260ffae4fc8_116605_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/end-user-tracing-in-a-skywalking-observed-browser/008eGmZEly1gph49lzy3wj30v40sq0xk_hu38d05b2abda17b762139a260ffae4fc8_116605_e4a5774a7dd8af3f8a5bb0f834612180.webp&#34;
               width=&#34;760&#34;
               height=&#34;702&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如你所见，它创建了一个 Promise 和一个新的 XMLHttpRequest 对象。由于 fetch 的代码是内置在浏览器中的，它必须先监控代码执行。因此，当我们添加监听事件时，我们无法监控 fetch 中的代码。只是在监控完代码执行后，我们重写一下 fetch： &lt;code&gt;import {fetch} from &#39;whatwg-fetch&#39;; window.fetch = fetch;&lt;/code&gt; 这样，我们就可以通过上面的方法拦截 fetch 请求了。&lt;/p&gt;
&lt;h2 id=&#34;其他资源&#34;&gt;其他资源&lt;/h2&gt;
&lt;p&gt;从 &lt;a href=&#34;https://skywalking.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方网站&lt;/a&gt;、Tetrate &lt;a href=&#34;https://www.tetrate.io/blog/category/open-source/apache-skywalking/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt; 以及可免费下载的 &lt;a href=&#34;https://www.tetrate.io/apache-skywalking-ebook-tetrate/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;电子书&lt;/a&gt; 中阅读更多关于 SKyWalking 的内容。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解读：云原生下的可观测性发展方向</title>
      <link>https://cloudnative.to/blog/cloud-native-observability/</link>
      <pubDate>Wed, 06 Jan 2021 10:47:14 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-observability/</guid>
      <description>&lt;p&gt;非常有幸参加了云原生社区 Meetup 北京站，有机会和众多业内的大牛一起讨论云原生相关的技术和应用，本次 Meetup 上我和大家分享了关于云原生下的可观测性相关的议题，相关的视频可以移步《&lt;a href=&#34;https://www.bilibili.com/video/BV1GK411g7dK&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;B 站视频回放：云原生下的可观测性&lt;/a&gt;》回看，本篇文章主要是视频的文字性总结，欢迎大家留言讨论。&lt;/p&gt;
&lt;h2 id=&#34;可观测性的由来&#34;&gt;可观测性的由来&lt;/h2&gt;
&lt;p&gt;可观测性最早来自于电气工程领域，主要原因是随着系统发展的逐步复杂，必须要有一套机制用来了解系统内部的运行状态以便更好的监控和问题修复，为此工程师们设计了很多传感器、仪表盘用于表现系统内部的状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A system is said to be observable if, for any possible evolution of &lt;a href=&#34;https://en.wikipedia.org/wiki/State_space_representation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;state and control vectors&lt;/a&gt;, the current state can be estimated using only the information from outputs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;电气工程发展了上百年，其中各个子领域的可观测性都在进行完善和升级，例如交通工具（汽车 / 飞机等）也算的是可观测性上的集大成者。抛开飞机这种超级工程不谈，一辆可正常上路的小型汽车内部也有上百种的传感器用来检测汽车内 / 外部的各种状态，以便让汽车可以稳定、舒适、安全地的行驶。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsaewyj7j30df07dtdq_hu49764eab54d2209fa6dc29e3fae00093_35462_189148c7db4c5187f6963488b62e4d64.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsaewyj7j30df07dtdq_hu49764eab54d2209fa6dc29e3fae00093_35462_9d31f2d51abff12da036f037fc267cf3.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsaewyj7j30df07dtdq_hu49764eab54d2209fa6dc29e3fae00093_35462_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsaewyj7j30df07dtdq_hu49764eab54d2209fa6dc29e3fae00093_35462_189148c7db4c5187f6963488b62e4d64.webp&#34;
               width=&#34;483&#34;
               height=&#34;265&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;可观测性的未来&#34;&gt;可观测性的未来&lt;/h2&gt;
&lt;p&gt;随着上百年的发展，电气工程下的可观测性已经不仅仅用来辅助人们进行问题检查和定位问题，我们以汽车工程来看，整个可观测性的发展经历了几个过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;盲目：1886 年 1 月 29 日德国人卡尔・本茨发明了人类史上第一辆汽车，那个时候的汽车仅仅具备行驶的最基础能力，根本没有任何和可观测性相关的事情。&lt;/li&gt;
&lt;li&gt;传感器：随着后来汽车开始正式进入市场，人们需要更好的知道汽车是不是没油了、没水了，因此基础的传感器仪表盘被发明出来。&lt;/li&gt;
&lt;li&gt;告警：为了更好的保证汽车的形式安全性，人们开始使用自检和实时告警系统来主动向驾驶员通知一些异常信息，比如电瓶没电、水温过高、胎压低、刹车片磨损等。&lt;/li&gt;
&lt;li&gt;辅助：虽然告警能够即时发出，但有时候人还是来不及处理或者不想处理，这时候辅助系统就派上了用场，例如定速巡航、主动安全、自主泊车等。这些辅助系统是把传感器 + 自动控制进行结合，能够部分解决驾驶员可能做不到或者不想做的事情。&lt;/li&gt;
&lt;li&gt;自动驾驶：上述这些功能最终还是要人去参与，而自动驾驶可以完全不需要人的参与，直接是可观测性系统 + 控制系统就可以让汽车自动运行起来。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;自动驾驶的核心要素&#34;&gt;自动驾驶的核心要素&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsahom53j315o0lk7uw_hucc7c4fe2c98a0ed305f0c56a1348c4b0_162587_022ae667ca89c9f97cdd4bad6f17cfef.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsahom53j315o0lk7uw_hucc7c4fe2c98a0ed305f0c56a1348c4b0_162587_380bc2c72175f532f0908da45a189d04.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsahom53j315o0lk7uw_hucc7c4fe2c98a0ed305f0c56a1348c4b0_162587_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsahom53j315o0lk7uw_hucc7c4fe2c98a0ed305f0c56a1348c4b0_162587_022ae667ca89c9f97cdd4bad6f17cfef.webp&#34;
               width=&#34;760&#34;
               height=&#34;393&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;作为电气工程上可观测性的巅峰，自动驾驶将汽车获取到的各类内外部数据发挥到极致，总结起来主要有几下几个核心的要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;丰富的数据源：汽车外围遍布多个激光 / 图像雷达，能够实现高帧率、360° 实时观测周围的物体及其状态；内部则能够实时知道当前的车速、车轮角度、胎压等信息，做到知彼知己。&lt;/li&gt;
&lt;li&gt;数据集中化：相对辅助驾驶能力，自动驾驶的一个核心突破是能够将车内外的所有数据集中到一起去处理，真正发挥出数据的价值，而不是每个模块的数据作为孤岛进行独立运作。&lt;/li&gt;
&lt;li&gt;强大算力：集中化的数据也意味着数据量的急剧膨胀，无论哪家自动驾驶背后都有强大的芯片支撑，只有足够的算力才能保证在最短的时间内可以进行足够的计算。&lt;/li&gt;
&lt;li&gt;软件迭代：算力 + 算法构成了智能化的最终目标，然而算法不可能完美无瑕，我们会根据逐渐积累的自动驾驶数据不断进行算法的升级，使软件系统能够不断的升级以获得更佳的自动驾驶效果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;it-系统的可观测性&#34;&gt;IT 系统的可观测性&lt;/h2&gt;
&lt;p&gt;伴随着几十年的发展，IT 系统中的监控、问题排查也逐渐抽象为可观测性工程。在当时，最主流的方式还是使用 Metrics、Logging、Tracing 的组合。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsaecgo3j30is0b4jtd_hu3de3616eee524c70e0cc59261020ac1f_37899_dcac109fe575933a747c3ec32183bf51.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsaecgo3j30is0b4jtd_hu3de3616eee524c70e0cc59261020ac1f_37899_bc2585044959d20bd13816d1b8c584ae.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsaecgo3j30is0b4jtd_hu3de3616eee524c70e0cc59261020ac1f_37899_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsaecgo3j30is0b4jtd_hu3de3616eee524c70e0cc59261020ac1f_37899_dcac109fe575933a747c3ec32183bf51.webp&#34;
               width=&#34;676&#34;
               height=&#34;400&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上面这幅图详细大家非常熟悉，这是 Peter Bourgon 在参加完 2017 Distributed Tracing Summit 后发表的一篇博文，简洁扼要地介绍了 Metrics、Tracing、Logging 三者的定义和关系。这三种数据在可观测性中都有各自的发挥空间，每种数据都没办法完全被其他数据代替。&lt;/p&gt;
&lt;p&gt;以 Grafana Loki 中介绍中的一个典型问题排查过程来看：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最开始我们通过各式各样的预设报警发现异常（通常是Metrics/Logging）&lt;/li&gt;
&lt;li&gt;发现异常后，打开监控大盘查找异常的曲线，并通过各种查询/统计找到异常的模块（Metrics）&lt;/li&gt;
&lt;li&gt;对这个模块以及关联的日志进行查询/统计分析，找到核心的报错信息（Logging）&lt;/li&gt;
&lt;li&gt;最后通过详细的调用链数据定位到引起问题的代码（Tracing）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsabpa1kj31420m8dss_hu6b939189a956c5da1bf54f4f62f7b1ed_132101_c87daaaae1667518fbfc140fbaa6023a.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsabpa1kj31420m8dss_hu6b939189a956c5da1bf54f4f62f7b1ed_132101_788c905c20ca277a5f2ead0c503ab13f.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsabpa1kj31420m8dss_hu6b939189a956c5da1bf54f4f62f7b1ed_132101_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsabpa1kj31420m8dss_hu6b939189a956c5da1bf54f4f62f7b1ed_132101_c87daaaae1667518fbfc140fbaa6023a.webp&#34;
               width=&#34;760&#34;
               height=&#34;422&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上述例子介绍了如何使用 Metric、Tracing、Logging 去联合排查问题，当然根据不同的场景可以有不同的结合方案，例如简单的系统可以直接通过日志的错误信息去告警并直接定位问题，也可以根据调用链提取的基础指标（Latency、ErrorCode）触发告警。但整体而言，一个具有良好可观测性的系统必须具备上述三种数据。&lt;/p&gt;
&lt;h2 id=&#34;云原生下的可观测性&#34;&gt;云原生下的可观测性&lt;/h2&gt;
&lt;p&gt;云原生带来的不仅仅是应用部署能够部署云上而已，其整个的定义是一套新的 IT 系统架构升级，包括开发模式、系统架构、部署模式、基础设施全套的演进和迭代。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsadyme7j315o0kzwp3_hu6ee8d7719a7d5ea1b8b48277752fd1e2_118253_a6c517807fb86850aa4b76f8014bbd1d.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsadyme7j315o0kzwp3_hu6ee8d7719a7d5ea1b8b48277752fd1e2_118253_b9a1acafa6882774a8610a17f522ca8a.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsadyme7j315o0kzwp3_hu6ee8d7719a7d5ea1b8b48277752fd1e2_118253_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsadyme7j315o0kzwp3_hu6ee8d7719a7d5ea1b8b48277752fd1e2_118253_a6c517807fb86850aa4b76f8014bbd1d.webp&#34;
               width=&#34;760&#34;
               height=&#34;383&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;效率要求更高：随着 DevOps 模式的普及，规划、开发、测试、交付.. 的效率要求越来越高，而与之带来的问题是需要更加实时的知道此次的发布是否成功，出现了什么问题，问题在哪里，如何快速去解决。&lt;/li&gt;
&lt;li&gt;系统更加复杂：架构从最开始的一体化发展到分层模式，到现在的微服务模式，架构的升级带来了开发效率、发布效率、系统灵活性、鲁棒性等优势，但随之而来系统的复杂度将更高，问题的定位将更加难。&lt;/li&gt;
&lt;li&gt;环境动态性增强：无论是微服务的架构还是容器化的部署模式，带来的一个特性是环境的动态性会增强，每个实例的生命周期会更短，出现问题后往往现场已经被破坏，登录机器排查问题的方式已经不复存在。&lt;/li&gt;
&lt;li&gt;上下游依赖更多：问题的定位最终都会从上下游来排查，在微服务、云、K8s 的环境中，上下游将更加多，包括各类其他业务应用、云上使用的各类产品、各种中间件、K8s 自身、容器运行时、虚拟机等等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;拯救者opentelemetry&#34;&gt;拯救者：OpenTelemetry&lt;/h2&gt;
&lt;p&gt;上述的这些问题相信很多读者都会深有体会，而业界也针对这种情况退出了各类可观测性相关的产品，包括开源、商业化的众多项目。例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Metrics：Zabbix、Nagios、Prometheus、InfluxDB、OpenFalcon、OpenCensus&lt;/li&gt;
&lt;li&gt;Tracing：Jaeger、Zipkin、SkyWalking、OpenTracing、OpenCensus&lt;/li&gt;
&lt;li&gt;Logging：ELK、Splunk、SumoLogic、Loki、Loggly&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsad11dyj30gb08678x_hu912d523760311966775ab52d3447d93c_43244_87c831a3bbc6d456ceabb329c847735a.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsad11dyj30gb08678x_hu912d523760311966775ab52d3447d93c_43244_8bd1b46038e406c6a8bea5576523ca19.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsad11dyj30gb08678x_hu912d523760311966775ab52d3447d93c_43244_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsad11dyj30gb08678x_hu912d523760311966775ab52d3447d93c_43244_87c831a3bbc6d456ceabb329c847735a.webp&#34;
               width=&#34;587&#34;
               height=&#34;294&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;利用这些项目的组合或多或少可以解决针对性的一类或者几类问题，但真正应用起来你会发现各种问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多套方案交织：可能要使用至少 Metrics、Logging、Tracing3 种方案，维护代价巨大&lt;/li&gt;
&lt;li&gt;数据不互通：虽然是同一个业务组件，同一个系统，产生的数据由于在不同的方案中，数据难以互通，无法充分发挥数据价值&lt;/li&gt;
&lt;li&gt;厂商绑定：无论从数据采集、传输、存储、计算、可视化、告警等都可能会被厂商绑定，可观测性系统一旦上线后替换的代价讲巨大无比&lt;/li&gt;
&lt;li&gt;云原生不友好：这些方案其中很多都是针对传统系统的，对于云原生的支持相对较弱，而且方案本身部署和使用代价都很高，不符合 “云原生” 这种一键部署、开箱即用的使用方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsah5yzmj30wc08gae3_hufc7e49c819f1ad75bf33295b9fe76c8e_39730_73ec588c80f89f985196a1cb70252c6b.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsah5yzmj30wc08gae3_hufc7e49c819f1ad75bf33295b9fe76c8e_39730_39b6f4e6706034dda88a0abbdcdcd8d0.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsah5yzmj30wc08gae3_hufc7e49c819f1ad75bf33295b9fe76c8e_39730_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsah5yzmj30wc08gae3_hufc7e49c819f1ad75bf33295b9fe76c8e_39730_73ec588c80f89f985196a1cb70252c6b.webp&#34;
               width=&#34;760&#34;
               height=&#34;198&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在此背景下，云原生基金会 CNCF 下诞生了 OpenTelemetry 项目，旨在将 Logging、Tracing、Metrics 三者进行统一，实现数据的互通互操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Create and collect telemetry data from your services and software, then forward them to a variety of analysis tools.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OpenTelemetry 最核心的功能是产生、收集可观测性数据，并支持传输到各种的分析软件中，整体的架构如下图所属，其中 Library 用于产生统一格式的可观测性数据；Collector 用来接收这些数据，并支持把数据传输到各种类型的后端系统。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsafamk9j315o0hx46t_hubc211b819bdf7e569d0419eb07aa891b_95955_1a0b46d4d13691fb74a22757880f14d8.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsafamk9j315o0hx46t_hubc211b819bdf7e569d0419eb07aa891b_95955_0a3ee6bd61b1c8565072cc23867fd049.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsafamk9j315o0hx46t_hubc211b819bdf7e569d0419eb07aa891b_95955_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsafamk9j315o0hx46t_hubc211b819bdf7e569d0419eb07aa891b_95955_1a0b46d4d13691fb74a22757880f14d8.webp&#34;
               width=&#34;760&#34;
               height=&#34;327&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OpenTelemetry 给云原生下带来的革命性的进步，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统一协议：OpenTelemetry 为我们带来了 Metric、Tracing、Logging（正在制定中，LogModel 已经定义完毕）的统一标准，三者都有相同的元数据结构，可以轻松实现互相关联&lt;/li&gt;
&lt;li&gt;统一 Agent：使用一个 Agent 即可完成所有可观测性数据的采集和传输，不需要为每个系统都部署各种各样的 Agent，大大降低了系统的资源占用，使整体可观测性系统的架构也变的更加简单&lt;/li&gt;
&lt;li&gt;云原生友好：OpenTelemetry 诞生在 CNCF，对于各类的云原生下的系统支持更加友好，此外目前众多云厂商已经宣布支持 OpenTelemetry，未来云上的使用会更加便捷&lt;/li&gt;
&lt;li&gt;厂商无关：此项目完全中立，不倾向于任何一家厂商，让大家可以有充分的自由来选择 / 更换适合自己的服务提供商，而不需要收到某些厂商的垄断或者绑定&lt;/li&gt;
&lt;li&gt;兼容性：OpenTelemetry 得到了 CNCF 下各种可观测性方案的支持，未来对于 OpenTracing 类、OpenCensus、Prometheus、Fluntd 等都会有非常好的兼容性，可以方便大家无缝迁移到 OpenTelemetry 方案上。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;opentelemetry-限制&#34;&gt;OpenTelemetry 限制&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsafux5gj315o0kv7fz_hu69c0262153efda3a08c2303d7aae4e17_99420_35da7b5bd9d7c07c740537019c92562d.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsafux5gj315o0kv7fz_hu69c0262153efda3a08c2303d7aae4e17_99420_69072590a198a37f5472daa629ddbed8.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsafux5gj315o0kv7fz_hu69c0262153efda3a08c2303d7aae4e17_99420_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsafux5gj315o0kv7fz_hu69c0262153efda3a08c2303d7aae4e17_99420_35da7b5bd9d7c07c740537019c92562d.webp&#34;
               width=&#34;760&#34;
               height=&#34;381&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从上面的分析来看，OpenTelemetry 的定位是作为可观测性的基础设施，解决数据规范与获取的问题，后续部分依赖各个 Vendor 来实现。当然最佳的方式是能够有一个统一的引擎去存储所有的 Metrics、Logging、Tracing，有一个统一的平台去分析、展示、关联这些数据。目前的话还没有一个厂商能够非常好的支持 OpenTelemetry 的统一后端，现在还是需要自己去使用各个厂商的产品来实现。而这个带来的另一个问题是各个数据的关联会更加复杂，还需要去解决每个厂商之间的数据关联性问题。当然这个问题相信在 1-2 年肯定会解决掉，现在有众多厂商开始在努力实现 OpenTelemetry 所有类型数据的统一方案。&lt;/p&gt;
&lt;h2 id=&#34;可观测性的未来方向&#34;&gt;可观测性的未来方向&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsacga6sj30jk07t0yd_hub028f0292d0320f48c7dbf6fad3819ed_43494_75686f1ac9a6f33c6ea402d0f849c8dd.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsacga6sj30jk07t0yd_hub028f0292d0320f48c7dbf6fad3819ed_43494_89fd282adabe76d93f737c95cdd65424.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsacga6sj30jk07t0yd_hub028f0292d0320f48c7dbf6fad3819ed_43494_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsacga6sj30jk07t0yd_hub028f0292d0320f48c7dbf6fad3819ed_43494_75686f1ac9a6f33c6ea402d0f849c8dd.webp&#34;
               width=&#34;704&#34;
               height=&#34;281&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们团队从刚开始 09 年做飞天 5K 项目起，就一直在负责监控、日志、分布式链路追踪等可观测性相关的工作，中间经历过小型机到分布式系统再到微服务、云化的一些架构变更，相关的可观测性方案也经历了很多演变。我们觉得整体上可观测性相关的发展和自动驾驶等级的设定非常吻合。&lt;/p&gt;
&lt;p&gt;自动驾驶一共分为 6 级，其中 0-2 级主要还是靠人来进行决定，到了等级 3 之后就可以进行无意识驾驶，也就是手眼可以暂时性不用关注驾驶，到了等级 5 的话人就可以完全脱离驾驶这个枯燥的工作，在车上可以自由活动。&lt;/p&gt;
&lt;p&gt;在 IT 系统的可观测性上，也可以类似划分 6 级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等级 0：手工分析，依靠基础的 Dashboard、告警、日志查询、分布式链路追踪等方式进行手动告警、分析，也是目前绝大部分公司使用的场景&lt;/li&gt;
&lt;li&gt;等级 1：智能告警，能够自动去扫描所有的可观测性数据，利用机器学习的方式去识别一些异常并进行自动告警，免去人工设置 / 调整各种基线告警的工作&lt;/li&gt;
&lt;li&gt;等级 2：异常关联 + 统一视图，对于自动识别的异常，能够进行上下文的关联，形成一个统一的业务视图，便于快速的定位问题&lt;/li&gt;
&lt;li&gt;等级 3：根因分析 + 问题自愈，自动根据异常以及系统的 CMDB 信息直接定位问题的根因，根因定位准确后那边可以去做问题的自愈。这一阶段相当于是一次质的飞跃，在某些场景下可以在人不用参与的情况下实现问题的自愈。&lt;/li&gt;
&lt;li&gt;等级 4：故障预测，故障发生总会有损失，所以最好的情况是避免故障的发生，因此故障预测技术可以更好的来保证系统的可靠性，利用之前积累的一些故障先兆信息做到 “未卜先知”&lt;/li&gt;
&lt;li&gt;等级 5：变更影响预测，我们知道绝大部分的故障都是由变更引起的，因此如果能够模拟出每个变更对系统带来的影响以及可能产生的问题，我们就能够提前评估出是否能够允许此次变更。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsadf9k4j315o0dewir_hu524aef5f65abbe78f134b23dd9c97629_58934_747d8c1714370f0f5f66c307fa6ed804.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsadf9k4j315o0dewir_hu524aef5f65abbe78f134b23dd9c97629_58934_d47d0860afae8d66b32288e61e35f8b2.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsadf9k4j315o0dewir_hu524aef5f65abbe78f134b23dd9c97629_58934_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsadf9k4j315o0dewir_hu524aef5f65abbe78f134b23dd9c97629_58934_747d8c1714370f0f5f66c307fa6ed804.webp&#34;
               width=&#34;760&#34;
               height=&#34;244&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;阿里云-sls-在可观测性相关的工作&#34;&gt;阿里云 SLS 在可观测性相关的工作&lt;/h2&gt;
&lt;p&gt;目前我们 SLS 正在开展云原生可观测性的工作，基于 OpenTelemetry 这个未来云原生下可观测性的标准，实现各类可观测性数据的统一收集，覆盖各个数据源和各类数据类型，做到多语言支持、多设备支持、类型统一；向上我们会提供能够支持各类可观测性数据的统一存储和计算能力，支持 PB 级存储、ETL、流计算、百亿级数据秒级分析，为上层算法提供强大的算力支撑；IT 系统的问题非常复杂，尤其涉及到不同的场景和架构，因此我们把算法和经验结合起来进行异常的分析，算法包括基础的统计学、逻辑性算法，也包括 AIOp 相关的算法，经验中包括人工输入的专家知识、网上上积累的各类问题解决方案以及外部产生的一些事件；最上层我们会提供一些辅助决策的功能，例如告警通知、数据可视化、Webhook 等，此外会提供丰富的外部集成能力，例如对接三方的可视化 / 分析 / 告警系统，提供 OpenAPI 以便不同的应用方集成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-observability/0081Kckwly1gmdsagsxmij315o0n0dzu_hu82e625f8aee579ea125e68b635919264_180982_adde2dfd6869394e6f4f28a00dae7769.webp 400w,
               /blog/cloud-native-observability/0081Kckwly1gmdsagsxmij315o0n0dzu_hu82e625f8aee579ea125e68b635919264_180982_cdca458ee3bc7a1b789f49db51092b81.webp 760w,
               /blog/cloud-native-observability/0081Kckwly1gmdsagsxmij315o0n0dzu_hu82e625f8aee579ea125e68b635919264_180982_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-observability/0081Kckwly1gmdsagsxmij315o0n0dzu_hu82e625f8aee579ea125e68b635919264_180982_adde2dfd6869394e6f4f28a00dae7769.webp&#34;
               width=&#34;760&#34;
               height=&#34;419&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;作为 CNCF 下除了 Kubernetes 外最活跃的项目，OpenTelemetry 受到了各大云厂商以及相关解决方案公司的关注，相信未来一定会成为云原生下可观测性的标准。虽然目前还没有到生产可用的程度，但是目前各个语言的 SDK 和 Collector 也基本上稳定，在 2021 年就能够发布生产可用的版本，值得大家期待。&lt;/p&gt;
&lt;p&gt;而 OpenTelemetry 只是定义了可观察的前半部分，后面还有非常多的复杂工作需要我们去实现，任重道远。&lt;/p&gt;
&lt;p&gt;重点来了！！！！SLS 团队长期招聘人才，欢迎对大数据、监控、可观测性、前端可视化、移动端开发、机器学习等有兴趣的同学前来联系我:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邮箱： &lt;a href=&#34;mailto:davidzhang.zc@alibaba-inc.com&#34;&gt;davidzhang.zc@alibaba-inc.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;微信： davidzhang-zc。&lt;/li&gt;
&lt;li&gt;职位： &lt;a href=&#34;https://cloudnative.to/job/aliyun-sls-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://cloudnative.to/job/aliyun-sls-observability/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://opentelemetry.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://opentelemetry.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.aliyun.com/article/766070&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://developer.aliyun.com/article/766070&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aiopsworkshop.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://aiopsworkshop.github.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://landscape.cncf.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.instana.com/blog/observability-vs-monitoring/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.instana.com/blog/observability-vs-monitoring/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
