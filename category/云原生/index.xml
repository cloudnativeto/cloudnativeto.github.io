<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>云原生 | 云原生社区</title>
    <link>https://cloudnative.to/category/%E4%BA%91%E5%8E%9F%E7%94%9F/</link>
      <atom:link href="https://cloudnative.to/category/%E4%BA%91%E5%8E%9F%E7%94%9F/index.xml" rel="self" type="application/rss+xml" />
    <description>云原生</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Fri, 27 May 2022 08:03:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>云原生</title>
      <link>https://cloudnative.to/category/%E4%BA%91%E5%8E%9F%E7%94%9F/</link>
    </image>
    
    <item>
      <title>为什么需要可编程代理</title>
      <link>https://cloudnative.to/blog/what-and-why-programmable-proxy/</link>
      <pubDate>Fri, 27 May 2022 08:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/what-and-why-programmable-proxy/</guid>
      <description>&lt;p&gt;经常会有人问 “当你们说可编程代理的时候，那么什么是可编程代理，为什么需要可编程代理”？本文从不同角度回答这个问题。首先会简单地介绍代理；然后讨论下代理在发展过程中的阶段划分；基于这些阶段的划分，讨论每一个阶段相比于上一个阶段的改进之处，以及为什么需要这些改进，同时我们讨论下 “可编程” 所包含的几个层面；最后我们总结下 “为什么需要可编程代理”。&lt;/p&gt;
&lt;h2 id=&#34;什么是代理及代理的功能&#34;&gt;什么是代理及代理的功能&lt;/h2&gt;
&lt;p&gt;代理是代理服务器的简称，代理服务器通常部署在两个互相隔离的网络的中间处，既能访问一侧网络也能访问另一侧网络，通过把一侧的数据搬运到另一侧，实现了网络的连通。代理是一种串路网络设备，自从计算机网络诞生，代理就存在了。由于代理是串路的，因此代理在实现网络连通功能的同时也衍生出新的功能和使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;路由&lt;/strong&gt;：代理在转发数据的时候，根据数据的特征，转发到不同的目的地&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;：在转发过程中，通过把数据分发到不同的目的地，提高吞吐量、避免目的地单点故障。负载均衡逐渐成为代理细分功能的一个领域&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;故障迁移&lt;/strong&gt;：在转发过程中，当目的地出现故障时候，代理可以把数据转发到备用的目标，对请求方提供不间断的服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问控制&lt;/strong&gt;：代理可以决定某些流量可以通过，哪些流量需要被拦截。WAF 是典型的代理在细分领域的应用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;身份识别&lt;/strong&gt;：访问控制很多时候需要基于身份信息，因此代理通常也具有身份识别的功能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络加速&lt;/strong&gt;：代理通过缓存数据的方式加速网络访问&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指标采集&lt;/strong&gt;：代理对经过的数据进行统计，汇总给 NPM 软件用于网络优化及网络规划&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信息安全&lt;/strong&gt;：除了访问控制外，代理还可以用于安全审计、TLS/SSL 卸载、数据加密等，满足安全需求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;提供桥接两个网络功能的除了代理还有路由器。路由器工作在网络的 3 层；而代理工作在 3 层以上，或者说 4 层和 7 层。&lt;/p&gt;
&lt;h2 id=&#34;软件代理的发展&#34;&gt;软件代理的发展&lt;/h2&gt;
&lt;p&gt;软件代理服务器在发展过程中，大致上经历了如下几个阶段：&lt;/p&gt;
&lt;h3 id=&#34;配置文件时代&#34;&gt;配置文件时代&lt;/h3&gt;
&lt;p&gt;代理类软件（最主要是开源软件），占到了网络基础设施类软件的大多数，这些软件在细分领域提供了不同的功能，比如针对不同协议的代理、比如侧重负载均衡的代理、比如侧重缓存加速的代理。这一大类软件，都是基于配置的。用户在配置文件中设置参数、配置规则，然后启动服务进程执行这些规则&lt;/p&gt;
&lt;h3 id=&#34;配置语言时代&#34;&gt;配置语言时代&lt;/h3&gt;
&lt;p&gt;配置难于表达复杂逻辑，所以很多代理软件在配置基础上引入了很薄的脚本能力，我们一般称为 “配置语言” 或者说 DSL，比如 &lt;a href=&#34;https://www.haproxy.com/documentation/hapee/latest/configuration/acls/syntax/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Haprxoy 的 ACL&lt;/a&gt;，&lt;a href=&#34;https://varnish-cache.org/docs/trunk/users-guide/vcl.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Varnish 的 VCL&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;脚本语言时代&#34;&gt;脚本语言时代&lt;/h3&gt;
&lt;p&gt;当逻辑进一步复杂的时候，配置语言也会难于表达；同时，当配置语言数量多到一定程度时候，配置语言本身的管理，会有很大难度。&lt;/p&gt;
&lt;p&gt;就像 shell 脚本可以写简单的逻辑，但是当 shell 代码多到一定程度的时候，通常会进一步选择 Perl 或者 Python 这些更加结构化的脚本语言。Proxy 支持脚本语言，既有脚本语言的便利性，也有编程语言结构化的优势。&lt;/p&gt;
&lt;p&gt;这类的例子如 &lt;a href=&#34;https://openresty.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Openresty&lt;/a&gt;(Nginx + Lua)、&lt;a href=&#34;https://nginx.org/en/docs/njs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nginx Plus&lt;/a&gt;(Nginx + NJS). 同时，这类例子里也包括大量应用类编程语言实现的代理服务器，比如基于 NodeJS 的 &lt;a href=&#34;https://strongloop.com/projects/#mg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;StrongLoop&lt;/a&gt;、&lt;a href=&#34;https://spring.io/projects/spring-cloud-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud Gateway&lt;/a&gt; 等，这些应用类编程语言往往自己就有脚本支持能力。&lt;/p&gt;
&lt;h3 id=&#34;集群时代&#34;&gt;集群时代&lt;/h3&gt;
&lt;p&gt;脚本语言解决了代理中复杂逻辑的模块化、结构化实现难点。此时进一步的需求是把代理和其他的管理控制工具集成，因此需要有 REST 接口。外部的控制平面可以通过 REST 接口动态的设置脚本中的逻辑。&lt;/p&gt;
&lt;p&gt;同时，人们对代理的使用也从单实例上升到集群化，因此这一类代理通常都自身支持集群能力，比如 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Enovy&lt;/a&gt; 和基于 Openresty 的 &lt;a href=&#34;https://konghq.com/kong&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;，他们通过某种集中或者共享方式实现集群能力，同时对外提供 REST 接口。&lt;/p&gt;
&lt;p&gt;对于这个时代的代理，通过配置管理，一般也可以实现集群管理；并且配置管理工具也可以对外暴露 REST 接口。比如使用 &lt;a href=&#34;https://www.ansible.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ansible&lt;/a&gt; + &lt;a href=&#34;https://www.nginx.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nginx&lt;/a&gt; 的方案，实现了和云时代的能力。相比之下，集群时代的方案需要要更多的组件形成方案，而云时代的方案更收敛。&lt;/p&gt;
&lt;h3 id=&#34;云时代&#34;&gt;云时代&lt;/h3&gt;
&lt;p&gt;在 #5 的基础上，代理采用分布式的方式部署，最常见的场景是为每个应用进程部署一个代理，也就是 &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sidecar proxy 模式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在采用分布式以后，针对不同的上游服务，采用不同的规则和策略，也就是多租户能力。不同上游服务，不仅在逻辑上有独立的规则和策略；在物理上也进一步提供了隔离，实现进程级和接口级的细粒度管理。如果我们把服务网格的控制平面和数据平面看作一个整体，那么服务网格是这个领域的代表，典型的比如 &lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio+Envoy&lt;/a&gt;，&lt;a href=&#34;https://linkerd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt;+&lt;a href=&#34;https://github.com/linkerd/linkerd2-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd Proxy&lt;/a&gt;。&lt;a href=&#34;https://flomesh.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pipy&lt;/a&gt; 就是这个阶段的产物。&lt;/p&gt;
&lt;h3 id=&#34;代理发展总结&#34;&gt;代理发展总结&lt;/h3&gt;
&lt;p&gt;在如上的各个阶段里，每一个阶段都比上一个阶段有所改进，概要的说：&lt;/p&gt;
&lt;p&gt;配置语言时代比配置文件增加了基本的脚本能力。这种基本的脚本能力，在配置文件的基础上，增加了动态能力。比如在运行期获取请求的特征（如获取 HTTP Header），然后根据这些特征做动态的逻辑判断，进行特定的操作。&lt;/p&gt;
&lt;p&gt;脚本语言时代比配置语言时代增加完整的脚本能力，此时可以结构化和模块化的编写脚本逻辑。在配置语言的时代，当逻辑复杂的时候，脚本的量也会大幅增加，此时结构化的脚本能力成为一种必需
集群时代比脚本语言时代多了 REST 接口和集群能力。当需要水平扩容代理能力的时候，需要把多个代理实例组成集群；集群内的实例共享配置和脚本，并且用户可以通过 REST 接口去管理配置和脚本。&lt;/p&gt;
&lt;p&gt;云时代比集群时代多了分布式能力，主要体现在同一个集群内不同的实例所运行的脚本和配置是不同的。在集群模式下，对于不同的上游服务，通常会有不同的配置和策略，比如不同的认证方式、不同的访问控制机制等；当上游服务逐渐增多的时候，这些不同上游服务的配置在逻辑上是分离的，但是在物理上都运行在同一个代理进程里。这种逻辑上分离的配置和策略运行在同一个物理进程中的情况，带来一些弊端：更多的逻辑运行在一个进程内，带来了更多的复杂性；不同上游服务的共享 CPU 和内存等资源，导致互相影响；如果某一个上游服务的脚本出现了安全漏洞，会导致其他上游服务的配置泄漏，存在安全隐患。&lt;/p&gt;
&lt;p&gt;云模式对于集群模式的改进在于每个上游服务的代理进程是独立的、彼此隔离的。他们受同一个集群管理者管理，但是在运行中的配置和脚本是独立和隔离的。这种隔离的特性，是多租户环境中的一种强需求 &amp;ndash; 不同的上游服务属于不同的租户，租户之间不应该互相影响，也不应该知道彼此的配置。云时代可以认为是集群时代多集群的极限模式 &amp;ndash; 最极端情况下，每一个进程都有自己的配置。&lt;/p&gt;
&lt;h2 id=&#34;代理的需求演化&#34;&gt;代理的需求演化&lt;/h2&gt;
&lt;p&gt;让我再从另一个视角看下代理的演化过程&amp;ndash;需求的演化。&lt;/p&gt;
&lt;h3 id=&#34;配置文件时代-1&#34;&gt;配置文件时代&lt;/h3&gt;
&lt;p&gt;第一代的代理主要是实现了代理功能，并且提供了基础的&lt;strong&gt;可配置&lt;/strong&gt;能力；同时，网络设备，尤其是串路网络设备的特性，要求代理是&lt;strong&gt;高可靠&lt;/strong&gt;的；网络的海量数据实时传输的特性，要求代理高吞吐、低延迟、低资源。和所有的软件一样，代理也需要支持模块化和可扩展，这个阶段的代理主要采用 C 语言开发，相应的开发扩展模块也使用 C 语言，模块在进程启动时加载。概括起来说，这个阶段的代理需求是：&lt;strong&gt;连通性&lt;/strong&gt;（网络功能）、&lt;strong&gt;易用性&lt;/strong&gt;（可以通过配置文件配置）、&lt;strong&gt;可靠性&lt;/strong&gt;（串路设备的要求）、&lt;strong&gt;高性能&lt;/strong&gt;、&lt;strong&gt;扩展性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;配置语言时代-1&#34;&gt;配置语言时代&lt;/h3&gt;
&lt;p&gt;第二代代理的改进体现在进一步提高了扩展性和灵活性，如一些动态的数据获取和配套的逻辑判断。脚本的引入，进一步增强了&lt;strong&gt;易用性&lt;/strong&gt;；对于组合逻辑和动态数据获取的支持，提供了&lt;strong&gt;灵活性&lt;/strong&gt;，同时改进了&lt;strong&gt;扩展性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;脚本语言时代-1&#34;&gt;脚本语言时代&lt;/h3&gt;
&lt;p&gt;第三代代理相比于第二代代理的改进主要是&lt;strong&gt;可管理性&lt;/strong&gt;、&lt;strong&gt;开发者友好&lt;/strong&gt;和&lt;strong&gt;可编程&lt;/strong&gt;。脚本大量地使用，一方面是因为使用 C 语言等做扩展开发难度大、维护难度大，一方面是脚本在现场开发的效率要优于编译型语言。&lt;/p&gt;
&lt;p&gt;开发者的开发效率和大量脚本维护带来的难度，要求这一代代理使用更为结构化的脚本语言，并且需要保持不低于上一代的性能、资源占用等核心能力。&lt;/p&gt;
&lt;p&gt;结构化和模块化的脚本语言的使用，开启了代理的&lt;strong&gt;可编程&lt;/strong&gt;时代，此时扩展代理服务器的功能就包含了两个层面和可能性，一个是使用 C 语言等开发&lt;em&gt;核心模块&lt;/em&gt;，一个是使用脚本开发&lt;em&gt;动态逻辑&lt;/em&gt;；或者说&lt;strong&gt;可编程&lt;/strong&gt;包含了&lt;em&gt;核心模块&lt;/em&gt; &lt;strong&gt;可编程&lt;/strong&gt; 和&lt;em&gt;动态逻辑&lt;/em&gt; &lt;strong&gt;可编程&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;集群时代-1&#34;&gt;集群时代&lt;/h3&gt;
&lt;p&gt;第四代代理开始了集群支持能力，属于&lt;strong&gt;可管理性&lt;/strong&gt;的改进。&lt;/p&gt;
&lt;p&gt;对 REST 接口的支持，使得代理作为网络基础设施（network infra），开始融入到了整体的管理中，是 infra as code 的一个落地点。REST 接口能力，提升了代理的&lt;strong&gt;被管理&lt;/strong&gt;能力，也是&lt;strong&gt;管理易用性&lt;/strong&gt;的一部分。&lt;em&gt;外部接口&lt;/em&gt;也是&lt;strong&gt;可编程&lt;/strong&gt;的一个重要特征，而 REST 作为最常用的接口形式也广泛的出现在代理服务器领域。&lt;/p&gt;
&lt;p&gt;此时&lt;strong&gt;可编程&lt;/strong&gt;就包含了三个层面：#3 中描述的&lt;em&gt;核心模块&lt;/em&gt;可编程，&lt;em&gt;动态逻辑&lt;/em&gt;可编程，以及提供对外接口供调用的&lt;em&gt;外部接口&lt;/em&gt; &lt;strong&gt;可编程&lt;/strong&gt;。代理服务器集群的出现，体现了&lt;strong&gt;扩展性&lt;/strong&gt;从&lt;em&gt;功能扩展&lt;/em&gt;向&lt;em&gt;资源扩展&lt;/em&gt;的变化。REST 接口的出现，为进一步的&lt;strong&gt;自服务&lt;/strong&gt;与&lt;strong&gt;托管服务&lt;/strong&gt;提供了技术基础&lt;/p&gt;
&lt;h3 id=&#34;云时代-1&#34;&gt;云时代&lt;/h3&gt;
&lt;p&gt;第五代代理的演化是云计算普及和高速发展驱动的。云的弹性、自服务、租户、隔离、计量，要求代理服务软件具备&lt;strong&gt;云化&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;p&gt;如果说第四代代理是面向&lt;em&gt;系统管理员&lt;/em&gt;的，那么第五代代理就是面向&lt;em&gt;云服务&lt;/em&gt;的。在充分保持了之前几代代理软件特征的同时，进一步实现了&lt;strong&gt;Cloud Ready&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;随着云计算向边缘侧拓展，第五代代理也向着硬件异构、软件异构、低能耗的方向发展，因此这一代代理开始呈现了&lt;strong&gt;云边一体&lt;/strong&gt;的能力。&lt;/p&gt;
&lt;p&gt;第五代代理在&lt;strong&gt;可编程&lt;/strong&gt;方面进一步演化，从&lt;em&gt;核心模块&lt;/em&gt;、&lt;em&gt;动态逻辑&lt;/em&gt;、&lt;em&gt;外部接口&lt;/em&gt;，增加了&lt;em&gt;云化&lt;/em&gt;的能力；包括支持分布式、多租户、可计量等。可计量是多租户的衍生需求，多租户一方面要求隔离，另一方面要求资源可以被尽可能小的粒度进行计量&lt;/p&gt;
&lt;p&gt;我们把如上的讨论汇总成一个表格，第一列标识代理所满足的某方面需求；第一行表示不同阶段的代理；在每个单元格里，我们用&lt;em&gt;来表示是否有该类能力，以及能力的程度（1-5个&lt;/em&gt;，5个&lt;em&gt;表示充分支持，1个&lt;/em&gt;表示基本支持）。同时，我们还列出了各个阶段的标志性软件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置文件阶段：Squid、Httpd、Nginx。&lt;/li&gt;
&lt;li&gt;配置语言阶段：Varnish、Haproxy&lt;/li&gt;
&lt;li&gt;脚本语言阶段：Nginx+Lua、Nginx+JS&lt;/li&gt;
&lt;li&gt;集群阶段：Kong、Envoy&lt;/li&gt;
&lt;li&gt;云时代：Istio+Envoy、Linkerd、Pipy&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;需求&lt;/th&gt;
&lt;th&gt;配置文件阶段&lt;/th&gt;
&lt;th&gt;配置语言阶段&lt;/th&gt;
&lt;th&gt;脚本语言阶段&lt;/th&gt;
&lt;th&gt;集群阶段&lt;/th&gt;
&lt;th&gt;云时代&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;连通性&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;连通性在云时代开始使用内核技术，如 iptables 和 ebpf；之前都只有 user space 进程模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;可靠性&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;可靠性一直是代理软件的最重要的基础能力&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;高性能&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;性能包括吞吐率、延迟、错误率、偏离均值的幅度。其中延迟采用 P99，P999 等度量指标。早期代理软件有长尾效应，因此 P99 以上指标没有后期软件好。采用高性能脚本的代理，在返回相同内容时，通常性能优于前一代。采用 proactive 技术的代理，在提供相同性能的同时更稳定（偏离均值的幅度更小）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;灵活性&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;* *&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;第五代代理相比第四代显著的增强了多协议支持能力，因此我们给这一代五星的评价。并且第五代的处理模型可以适配多种协议，具有通用性，这方面要优于第四代&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;扩展性&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;* *&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;和 灵活性 类似，第五代代理除了支持核心功能扩展开发、7 层逻辑扩展开发，还支持多协议，因此我们给出比第四代多一星的评价&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;硬件兼容性&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;使用 C 或者 C++ 开发的代理，通常在硬件兼容性上都更好一些，社区也更活跃的迁移程序到新的硬件架构。使用 RUST 和 Go 和 Lua 开发的代理，在硬件兼容的迁移进度向相对缓慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;系统兼容性&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;系统 主要包括两个方面，一个是操作系统，一个是云平台。在操作系统兼容性方面，每一代的代理相差不多；但是在云平台兼容性方面，第四代和第五代代理都更充分的考虑并实现了和云的兼容。相比之下，第五代比第四代显著的差异是对多租户的支持能力&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;管理易用性&lt;/td&gt;
&lt;td&gt;* *&lt;/td&gt;
&lt;td&gt;* *&lt;/td&gt;
&lt;td&gt;* *&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;管理易用性是指针对运维和管理员角色的功能。第一二代主要以配置文件为主，基于此使用配置管理工具实现了自动化和批量的管理。第三代除了管理配置文件，需要进一步管理脚本源文件；但本质上和第一二代的管理易用性没有有显著差异。第四代提供 REST 接口，显著提升了管理的易用性。第五代除了 REST 以外，通常提供了针对云的控制平面，用来管理代理；同时对外提供多种接口以适配其他的管理需求，如监控、审计、统计等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;用户易用性&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;* *&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;前三代代理主要用户就是运维和管理员。第四代时候，管理员开始把部分功能对用户提供，开始出现 as-a-Service 的模式。第五代则更多的考虑了用户使用的场景，更多的提供了面向租户的能力&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;开发易用性&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;* *&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;围绕代理的开发包括两个方面，一个是在代理内部实现功能，一个是在代理外边实现对代理的管理能力。前三代都提供了内部开发的接口；后两代同时提供了内外接口。第五代相比第四代显著的改进是提供了云接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;核心接口可编程&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;每一代代理都提供了核心接口扩展的能力，但是这些接口过于底层，掌握难度较大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;功能扩展可编程&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;* *&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;* * * * *&lt;/td&gt;
&lt;td&gt;提供更高效的功能扩展能力，是每一代代理都在进步的部分。是 可编程 代理的核心指标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;协议扩展可编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;* *&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;前三代主要面向单一协议，或者固定协议。从第四代开始，用户开始寻求多协议和定制协议的支持。第五代则把协议扩展作为核心能力在设计中就做了充分的考虑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;结构化脚本编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;第三代代理开始显著的关注脚本的结构化问题；而第四代和第五代则努力为更加结构化的编程做了准备，如 Envoy 尝试通过 WASM 提供对多语言的支持；pipy 则是引入高性能 JS 脚本，提供更好的结构化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;配置管理可编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;* *&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;前三代代理的配置主要面向运维管理人员，外部的配置管理工具都是基于这个前提。第四代开始支持 REST 管理接口；第五代则进一步提供了标准的云接口做配置管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;资源扩展可编程&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;* *&lt;/td&gt;
&lt;td&gt;* * * *&lt;/td&gt;
&lt;td&gt;前三代代理扩容主要是增加线程或者进程的数量。第四代提供了进程的横向扩展能力，也就是集群能力。第五代在第四代基础上，一方面提供了横向扩展能力，一方面提供了更小资源下的能力，以支持更细粒度的计量与计费；也就是不仅支持增量扩展，也提供了减量扩展的能力，而这些能力，都提供编程接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;租户扩展可编程&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;* * *&lt;/td&gt;
&lt;td&gt;云是和第四代代理同步出现的事物，租户 作为云的核心特征，并没有在第四代中获得很好的支持。第五代则以云为大前提进行了设计，考虑和提供了租户自己编程扩展的可能性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;上表中的 #11～#17 是代理 &lt;strong&gt;可编程&lt;/strong&gt; 的具体的多个方面，这些方面也同时构成了 &lt;strong&gt;Why Programming Proxy&lt;/strong&gt; 的答案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代理的内部功能需要扩展，既包括底层核心能力的扩展，也包括支持更多协议的扩展，还包括面向七层的处理能力（转发、路由、判断、访问控制等）；这些七层的处理能力，要求更为便捷的编程方式，也就是脚本化、结构化的编程能力&lt;/li&gt;
&lt;li&gt;代理需要对外部提供接口，以集成到更大的管理体系中（如云平台），包括配置管理、资源管理等&lt;/li&gt;
&lt;li&gt;代理需要提供面向不同角色的扩展能力，包括运维、管理员、资源提供者、租户，这些扩展能力在某种程度上都需要 &lt;strong&gt;可编程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;同时，就像任何 &lt;strong&gt;可编程&lt;/strong&gt; 组件一样，&lt;strong&gt;可编程代理&lt;/strong&gt; 需要有配套的文档、开发手册、代码管理、依赖管理、构建和部署工具，并且最好有可视化的开发、调试环境。这些得到充分满足以后，用户才能够更好的管理网络流量，以及流量之上所承载的业务&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>避免在微服务上失败的 7 个关注点</title>
      <link>https://cloudnative.to/blog/7-ways-to-fail-at-microservices/</link>
      <pubDate>Fri, 18 Feb 2022 16:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/7-ways-to-fail-at-microservices/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://www.infoq.com/articles/microservices-seven-fail/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;7 Ways to Fail at Microservices&lt;/a&gt;，作者总结了她见过的导致微服务落地失败的一些情况，并提出了 7 个重要的关注点以引导大家来尽量避免。译者是在工作闲暇时间完成的翻译，其中难免有不当之处，请读者指正。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文主要观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务是一种手段，而不是目标&lt;/li&gt;
&lt;li&gt;分布式并不能保证解耦性&lt;/li&gt;
&lt;li&gt;合约测试（Contract Testing）是任何微服务架构的重要组成部分&lt;/li&gt;
&lt;li&gt;分解（Decomposition）需要发生在前端、后端和集成层，以及业务逻辑中&lt;/li&gt;
&lt;li&gt;如果企业没有能力快速、独立地发布微服务，那么微服务的许多好处就会丧失&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我（Holly Cummins）是 IBM 的一名 &lt;a href=&#34;https://www.linkedin.com/in/holly-k-cummins&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;技术顾问&lt;/a&gt;，我的一部分工作是帮助企业实现云原生。在去年 11 月的 QCon Plus 上，我介绍了 &lt;a href=&#34;https://plus.qconferences.com/plus2021/presentation/7-ways-fail-microservices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一些不正确的微服务使用方式&lt;/a&gt;。这些问题是基于我的经验来整理的，它们是我在客户现场反复看到的一些问题。&lt;/p&gt;
&lt;p&gt;我看到的第一个问题是，我们有时甚至不知道问题出在哪里。人们觉得我们应该做 &lt;a href=&#34;https://microservices.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务&lt;/a&gt;，但我们并没有真正花足够的时间来定义我们为什么要做微服务。&lt;/p&gt;
&lt;p&gt;我们要解决的是什么问题？现在是什么问题在困扰我们？我们做了微服务之后，什么会更好？这是一个很自然的本能问题，尤其是对于我们这些技术人员来说。我们想直接开始用微服务去解决问题，同时想玩一些这样新的酷炫的技术。尽管这些也非常重要，但更应该清楚我们要通过微服务去解决什么问题。&lt;/p&gt;
&lt;p&gt;容器技术使这种 “直接开始用微服务去解决问题” 的情况变得更糟：因为容器是一种近乎神奇的技术，这使得它本身就是一个伟大的解决方案 —— 它是如此轻巧，它是如此的便携，它使许多事情变得更好。于是我们最终决定：“因为我已经有了这些容器，如果只在一个容器中运行我的应用程序，那将是对容器能力的严重浪费。我应该在尽可能多的容器中运行它！” 不幸的是，“没有足够的容器（来发挥伟大的容器技术的能力）” 并不是一个合理（分辨为什么我们需要微服务）的问题陈述。&lt;/p&gt;
&lt;h2 id=&#34;简历驱动的开发&#34;&gt;简历驱动的开发&lt;/h2&gt;
&lt;p&gt;我看到的另一个问题是 &lt;a href=&#34;http://radar.oreilly.com/2014/10/resume-driven-development.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;简历驱动的开发&lt;/a&gt;。我们在看自己的简历时，有时会觉得在应该在 “微服务” 这部分写点什么。既然什么都不写肯定是不好的，所以我们会想：“我可以通过重新架构我公司的技术架构来让我的个人简历变得更漂亮啊”。 读到这里时你可能在想，“不会吧，这也太功利了吧。应该没有人真的会为了完善他们的个人简历来做公司的架构决策吧？” 然而事实证明 &amp;hellip;&amp;hellip; 确实是有人会这么做的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/cv-driven-development_hu766a9303bf962c35a6437fa7c10bbe04_277881_3608ca00272da140d91b38ae64530f25.webp 400w,
               /blog/7-ways-to-fail-at-microservices/cv-driven-development_hu766a9303bf962c35a6437fa7c10bbe04_277881_b50a912cd2d56cb78a85df69c96e37c5.webp 760w,
               /blog/7-ways-to-fail-at-microservices/cv-driven-development_hu766a9303bf962c35a6437fa7c10bbe04_277881_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/cv-driven-development_hu766a9303bf962c35a6437fa7c10bbe04_277881_3608ca00272da140d91b38ae64530f25.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.redhat.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat&lt;/a&gt; 公司最近做了一项调查，调查了 &lt;a href=&#34;https://www.redhat.com/en/blog/red-hat-survey-reveals-career-progression-driving-developer-hunger-containers-and-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于容器的开发的主要驱动因素&lt;/a&gt;。职业发展是头号驱动力。职业发展是简历驱动发展的一种更好的说法。&lt;/p&gt;
&lt;p&gt;避免在简历上出现微服务部分的缺口是一件重要的事，因为目前微服务几乎是一种新的主流技术理念。即使我们此刻没有寻找新的工作，我们也不希望成为异类 —— 当我们环顾四周，似乎其 TA 人都在做微服务。于是一种很自然的想法是，如果 TA 们都在做微服务，那我为什么不去做做微服务呢？我把这称为 “微服务嫉妒”（Microservice Envy）。&lt;/p&gt;
&lt;h2 id=&#34;微服务不是目标&#34;&gt;微服务不是目标&lt;/h2&gt;
&lt;p&gt;“微服务嫉妒” 是一个问题，因为微服务并不是我们应该羡慕的那种东西。我们的一位技术顾问同事有一个讲法，如果一个客户一直在谈论 Netflix 的技术并要求使用微服务，他就知道这个合作可能有问题了。几乎可以肯定的是，他们转向微服务的原因并不正确。如果对话更深入一些，涵盖了耦合和聚合等内容，那么他就知道客户他们转向微服务的原因确实存在问题。&lt;/p&gt;
&lt;p&gt;微服务转型的出发点不应该是微服务本身。微服务是实现业务敏捷性或弹性或同等的更高层次目标的手段。实际上，微服务甚至不是唯一的手段；它只是一种手段而已。&lt;/p&gt;
&lt;h3 id=&#34;分布式单体&#34;&gt;分布式单体&lt;/h3&gt;
&lt;p&gt;重要的是要问：“你是有微服务，还是有一个分布在数百个 Git 仓库的单体？” 不幸的是，这就是我们经常看到的情况。一个分布式的单体是一个可怕的东西 —— 很难说它到底怎样，它比纯粹单体更容易出错。在传统的单体中，所有的东西都包含在一个单一的开发环境中，你可以得到一些好处，如编译时检查和 IDE 重构支持。因为你总是在一个进程中执行，你可以得到有保障的函数执行。你不必担心记住分布式计算的谬误和服务发现，以及处理你试图调用的东西已经停止存在的情况，事情是比较安全的。另一方面，如果我们去掉了单体的安全性，但保留了耦合性，我们最终会得到 “云原生意大利面条”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;术语 “意大利面条架构”（Spaghetti Architecture）可以被定义为一个信息技术问题，它阻碍了企业快速解码和转换其应用程序和数据以满足不断变化的需求的能力。“意大利面条架构” 是一个源自一盘意大利面条外观的比喻。每根意大利面条代表每个业务工具，它们被纠结成无限的复杂线。—— 摘自《 &lt;a href=&#34;https://data-sleek.com/what-is-spaghetti-architecture-and-how-to-avoid-it/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;什么是 “意大利面架构” 和如何避免它&lt;/a&gt; 》。&lt;/p&gt;
&lt;p&gt;【编者按】“意大利面条” 这个比喻似乎可以理解为：各个服务虽然看似分离了，但却各种层面上耦合、混合在一起，同时还容易断裂、崩坏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;分布式不等同于解耦&#34;&gt;分布式不等同于解耦&lt;/h2&gt;
&lt;p&gt;几年前，我被邀请到一个陷入困境的项目中去提供援助。当我进入项目时，团队对我说的第一件事就是 “每当我们改变一个微服务时，另一个服务就会出现故障”。如果你一直在关注微服务的优势，你就会知道，这与应该发生的事情完全相反。微服务应该是相互独立的，解耦的。然而，如果你把你的系统做成分布式，&lt;a href=&#34;https://en.wikipedia.org/wiki/Decoupling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;解耦&lt;/a&gt; 就变得不那么容易了（它是有代价的）。虽然 “分布式”（Distributed）和 “解耦”（Decoupled）都以 D 开头，但它们本身不是一回事。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu1e73b4b5955c9ead3e320289c0062335_135194_422f29376770997452732744d9ed4a45.webp 400w,
               /blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu1e73b4b5955c9ead3e320289c0062335_135194_5d9480d824f59fdc77ed0b9f3627a15f.webp 760w,
               /blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu1e73b4b5955c9ead3e320289c0062335_135194_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu1e73b4b5955c9ead3e320289c0062335_135194_422f29376770997452732744d9ed4a45.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;拥有一个高度分布式的系统是很有可能既具有分布式所带来的所有痛苦，同时又仍然是完全纠缠和耦合的。上面提到的困境就是在这种情况下发生的事情。当我开始探索代码库的时候，我不断地在每个代码仓库中看到相同的代码。这个应用程序的对象模型是相当复杂的，有大约 20 个类，其中一些类有 70 个字段。这是一个非常复杂的结构体。&lt;/p&gt;
&lt;p&gt;微服务开发的原则之一是充分的 DRY（Don&amp;rsquo;t Repeat Yourself），避开公共库，因为它们是耦合的来源。在这种情况下，为了避免中央对象库的耦合，每个微服务在其代码中都有一个剪切和粘贴的对象模型副本。但如果领域结构体（Domain Schema）仍然是共享的，就仍然存在耦合。复制对象代码并不能消除耦合，它只是消除了编译时检查的可能性。如果一个字段名改变了，它仍然会破坏所有人，但这种破坏直到运行时才会发生。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hu0d6a3b4f5fede532086d79c72ae057b6_190032_be84c1a06db2639725014378608e779f.webp 400w,
               /blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hu0d6a3b4f5fede532086d79c72ae057b6_190032_cd8b592d461819acb9263fdee2c5c8b0.webp 760w,
               /blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hu0d6a3b4f5fede532086d79c72ae057b6_190032_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hu0d6a3b4f5fede532086d79c72ae057b6_190032_be84c1a06db2639725014378608e779f.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个悲伤的故事表明了领域驱动设计（Domain-Driven Design）原则在微服务中的重要性。我们要实现的理想情况是，每个微服务都能整齐地映射到一个领域。这样做的一个副作用，也是你做得对的一个标志，就是你的微服务的接口粒度很小。如果我们沿着技术边界而不是领域边界划分，我们最终会出现像我看到的情况；每个微服务都有一个巨大的、脆弱的接口。 其结果是一个支离破碎的 “意大利面条” 式的混乱状态。&lt;/p&gt;
&lt;h3 id=&#34;火星气候轨道飞行器&#34;&gt;火星气候轨道飞行器&lt;/h3&gt;
&lt;p&gt;虽然从技术上讲它是一个航天器，而不是一个微服务平台，但 &lt;a href=&#34;https://en.wikipedia.org/wiki/Mars_Climate_Orbiter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;火星气候轨道器&lt;/a&gt; 很好地展示了分布式和解耦之间的区别。NASA 在 1998 年发射了火星气候轨道器，其任务是研究火星气候。遗憾的是，轨道器没有成功绕过火星；相反，探测器坠入火星。NASA 的事后调查发现，问题源于两个不同的控制系统之间的关系，这两个系统由不同的团队建造。大多数时候，转向是由探测器本身的一个系统完成的。每隔几天，当轨道飞行器进入地球的视野时，佛罗里达州的监督控制系统就会发出航线修正。这大约是一个系统可以做到的分布式；它的一部分在太空中。但这两个系统之间的领域实际上是相似的：都在处理发动机推力的计算。 这两个团队在沟通中对界面的样子还不够清楚，所以他们最终使用了不同的单位。太空中的部分使用公制单位，地球上的部分使用英制单位，所以灾难发生了。我们可以肯定地说，在这种情况下，系统是非常分布式的，然而这种分布式并没有帮助。&lt;/p&gt;
&lt;h2 id=&#34;以消费者为导向的合约测试&#34;&gt;以消费者为导向的合约测试&lt;/h2&gt;
&lt;p&gt;这种微妙的沟通问题在有多个团队参与的时候经常发生。令人高兴的是，有一个很好的缓解措施：&lt;a href=&#34;https://pactflow.io/what-is-consumer-driven-contract-testing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;消费者驱动的合约测试&lt;/a&gt;。在 IDE 没有帮助我们进行类型检查的系统中，我们需要测试我们的集成，但我们希望尽量减少全面的集成测试。集成测试很重，运行成本很高，而且本身就是耦合的。 如果我们已经投资开发了微服务，我们不想在测试时倒退并制造一个大的集成单体。那么，我们如何让自己得到信心，让我们确信我们正在建立一个真正有效的东西呢？&lt;/p&gt;
&lt;p&gt;数据模拟（Mock）是一种常见的解决方案，但数据模拟本身也有一个问题。为了建立数据模拟，生产团队和消费团队在开发之初就会就接口的情况进行对话。他们达成了一个协议，然后消费团队就去尝试写一个数据模拟，这个模拟看起来就像他们对生产团队所说的代码的理解。在理想的情况下，他们会做得很好。问题是，消费团队经常会把自己的假设也写进了模拟中，而他们也许不是知道其他代码是什么样子的，是否是合适这部分模拟的，毕竟不是消费团队编写的代码。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/problems-with-mocks_hu2945884495b6956335ece91a44eb541d_137655_6c9a3f1369d7c4339974eb3a87456da6.webp 400w,
               /blog/7-ways-to-fail-at-microservices/problems-with-mocks_hu2945884495b6956335ece91a44eb541d_137655_da811cbcf823cc4f2ceb9069f056b0f5.webp 760w,
               /blog/7-ways-to-fail-at-microservices/problems-with-mocks_hu2945884495b6956335ece91a44eb541d_137655_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/problems-with-mocks_hu2945884495b6956335ece91a44eb541d_137655_6c9a3f1369d7c4339974eb3a87456da6.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在顺利的情况下，他们得到了正确的结果。单元测试全部通过，而且在集成阶段也继续通过，一切都很好。不幸的是，这并不总是发生。有时，实际的实现与消费团队所理解的不同，要么是因为生产团队改变了他们的想法，要么是因为某个地方的人做了一个不正确的假设。在这种情况下，测试仍然会通过。然而，当我们真正整合真实的服务时，它就会失败。问题是，模拟的行为没有经过真实服务的验证。生产团队很可能甚至从未见过已经创建的模拟。&lt;/p&gt;
&lt;p&gt;一个更好的选择是有一个消费者驱动的合约测试。合约测试的美妙之处，以及为什么它与模拟不同，是双方都与合约测试互动。对于消费者来说，合约测试就像一个方便的模拟。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/contract-testing_hu1bd3cf410c038ddf2815b60f5f55be6c_146401_e79f0c95672291e49838a5c045447fb7.webp 400w,
               /blog/7-ways-to-fail-at-microservices/contract-testing_hu1bd3cf410c038ddf2815b60f5f55be6c_146401_0bf41567b04eddad609826fe15e0ed43.webp 760w,
               /blog/7-ways-to-fail-at-microservices/contract-testing_hu1bd3cf410c038ddf2815b60f5f55be6c_146401_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/contract-testing_hu1bd3cf410c038ddf2815b60f5f55be6c_146401_e79f0c95672291e49838a5c045447fb7.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在另一方面，合约测试对于生产团队也是一个方便的功能测试。它是一个更深刻的验证，而不仅仅是像 &lt;a href=&#34;https://swagger.io/specification/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenAPI&lt;/a&gt; 的语法检查。合约测试实际上也会检查语义和行为，这节省了生产团队编写功能测试的时间。&lt;/p&gt;
&lt;p&gt;如果所有的东西都是兼容的并且工作的，所有的合约测试都会通过。这是一个快速的信心提升，因为它们运行起来成本很低、也很轻便。如果生产团队破坏了什么，他们的测试将失败，并提供早期警报，在破坏性变化逃逸到集成环境之前。如果 API 发生变化，新版本的合约就会被双方（或连接的中间人）提出。&lt;/p&gt;
&lt;p&gt;现在有几个不同的合约测试系统。如果你在 Spring 的生态系统中，&lt;a href=&#34;https://spring.io/projects/spring-cloud-contract&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud Contract&lt;/a&gt; 工作得非常好。如果你是一个多面手，那么我非常喜欢 &lt;a href=&#34;https://pact.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pact&lt;/a&gt;。它有几乎所有你可能使用的语言的绑定。&lt;/p&gt;
&lt;h2 id=&#34;企业的毛球&#34;&gt;企业的毛球&lt;/h2&gt;
&lt;p&gt;当然，即使我们理清了所有的测试，即使我们在业务逻辑层有一套漂亮的解耦微服务，也不能保证成功。在我们的系统中还会有许多其他的元素，这些元素可能是我们在制定真正干净的微服务架构时没有考虑到的。我们对业务逻辑的开发非常投入，而忘记了前台和后台，以及所有的胶水层。在企业架构中，胶水层是非常可能存在的，而且是粘性的。我们的一位架构师把这称为 “企业毛球”（Enterprise Hairball）。&lt;/p&gt;
&lt;p&gt;如果我们把所有的功能分解工作都集中在业务层，我们最终往往会得到一堆整齐的解耦的微服务，夹在一个单体的前端和一个单体的数据库层之间。在这些类型的系统中，变革将是一个挑战。然而，作为一个行业，我们正在更好地分解数据库，以便将其映射到各个微服务上，并且我们正在开发微前端。&lt;/p&gt;
&lt;p&gt;但我们还没有完成分解。如果系统不是很复杂，我们将有一个集成层。这可能是消息传递系统，也可能是一些其他的集成解决方案，将复杂的系统拉到一起。即使在架构的其他部分实现现代化架构之后，集成层往往仍然是单体的，不灵活的。团队本身可能处于重大的负荷之下 —— 正如我的同事所称呼的 “恐慌的三明治”。因为集成层是单体的，他们必须小心翼翼地安排所有的变化，这就阻碍了其他所有人。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hucd7e81af8a83fee1109ea893c254407c_451655_d4569a5f47edae666cf8ee4c109f900c.webp 400w,
               /blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hucd7e81af8a83fee1109ea893c254407c_451655_691b31b72863d15079bcf6e7a1d9e4f9.webp 760w,
               /blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hucd7e81af8a83fee1109ea893c254407c_451655_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hucd7e81af8a83fee1109ea893c254407c_451655_d4569a5f47edae666cf8ee4c109f900c.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这可能会带来很多挫折感，特别是对集成团队来说。在外界看来，他们似乎反应迟钝，速度缓慢，尽管他们正在努力工作。为了理清这种耦合，我们需要采用模块化的集成模式。&lt;/p&gt;
&lt;p&gt;如果我们不把集成层、数据库和前端层分割开来，会发生什么？几乎可以肯定的是，我们的微服务不会达到我们想要的效果。“毛球” 各部分之间的依赖关系将使任何部分都无法快速移动。业务层的微服务将不能独立部署，部署的速度将明显地不连续。&lt;/p&gt;
&lt;h3 id=&#34;阻碍发布的拖累&#34;&gt;阻碍发布的拖累&lt;/h3&gt;
&lt;p&gt;你们有多少人经历过这种情况？你非常努力地工作，你创造了一些惊人的东西；你知道用户会喜欢它，但它还没有到他们手中。价值被摆在台面上了，但你那令人惊奇的东西却不能被发布。即使你有一个微服务架构，你也会有一个发布看板。所有其它的微服务都需要同时发布，因为它们需要一起测试，这样做的成本太高，除非正好是大批量服务同时发布。即使填写发布清单也很昂贵。大家时常会害怕发布，因为可能在过去曾被低劣的发布所深深地伤害。发布检查表、发布委员会、单线程测试和其它发布方法都是为了减少那些已知的风险。 因为整个组织的发布期限是共同的，所以我们最终不得不争分夺秒地在最后期限前把功能塞进去。当然，这也使得发布的风险更大。某个人正在跟踪一个电子表格，上面有所有微服务之间的依赖关系，这些微服务的耦合度比它们应该的要高。然而，发布还是得按期执行。当我们选择微服务时，这并不是我们所希望发生的！所有这些用心良苦设计的流程都成为了拖累，阻碍了价值到达用户手中，而且往往实际上又增加了风险。&lt;/p&gt;
&lt;h2 id=&#34;测试自动化&#34;&gt;测试自动化&lt;/h2&gt;
&lt;p&gt;通常情况下，我们如此害怕发布的原因是在发布中涉及到大量的手工工作。特别是，真正能给我们带来信心的测试并不是自动化的，所以我们需要做大量的工作来弄清楚我们的应用程序是否能工作。当我访问一个客户，听到 “我们的测试没有自动化” 时，我听到的是 “我们不知道我们的代码目前是否工作，它可能工作。上次我们做人工 QA 的时候它是有效的；我们希望它仍然有效”。这是一个可悲的情况。&lt;/p&gt;
&lt;p&gt;如果你关心你们的测试，就把它自动化 —— 质量是你应该关心的东西。特别是如果架构已经偏向于 “意大利面条”，并且耦合性已经悄然出现，那么就很可能出现断裂。去 “意大利面条化” 是很困难的，所以我们要在一个快速反馈的地方，尽可能早地发现断裂。如果你要成为 “意大利面条”，至少要成为经过测试的 “意大利面条”。&lt;/p&gt;
&lt;h2 id=&#34;发布周期&#34;&gt;发布周期&lt;/h2&gt;
&lt;p&gt;手动测试只是发布过程中涉及的手动流程的一部分。 在受监管或以合规性为重点的行业，几乎总是有一堆人工合规性工作。合规性是我们非常关心的事情 —— 所以我们应该把它自动化。&lt;/p&gt;
&lt;p&gt;有了所有这些手工流程和所有这些造成减速的流程，这意味着即使我们正在上云，但我们没有实际得到上云的红利。我们在使用云，但它好像又不是云。讽刺的是，在云中，我们曾经做过的事情、曾经是一个好主意的东西、曾经让我们更安全的事情，实际上正在伤害我们。旧式的治理在云中是行不通的，它不能实现我们所希望的商业结果，而且它失去了很多上云应得的商业利益。&lt;/p&gt;
&lt;p&gt;通过观察发布周期，很容易发现一个企业是否实现了上云的目标。几年前，我的一位同事与一家大型的传统银行进行了一次销售会谈。他们的市场被金融科技公司和新兴的挑战者银行吃掉了，这个企业明白他们为什么会输 —— 他们无法快速地跟上。他们来找我们，解释说他们有大量的 COBOL 资产，而这正是拖累他们的原因（很可能确实如此）。然后他们补充说，他们显然需要摆脱所有的 COBOL 并转向微服务，因为其他人都在做微服务。然后他们又说，他们的发布委员会一年只开两次会。讲到这里的时候，我的同事感觉不妙。如果你的发布委员会每六个月才开一次会，你就知道你的发布节奏将是每六个月一次。你有多少个可独立部署的微服务并不重要，你不可能在这种情况下获得敏捷性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hu8a2bbcdb6da0b8ebf69cbaebe5010923_261655_e7a4f6f8c887ca7cf6aa5dff9ddd5fbb.webp 400w,
               /blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hu8a2bbcdb6da0b8ebf69cbaebe5010923_261655_d4b63da91497a90648f83da5316ce947.webp 760w,
               /blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hu8a2bbcdb6da0b8ebf69cbaebe5010923_261655_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hu8a2bbcdb6da0b8ebf69cbaebe5010923_261655_e7a4f6f8c887ca7cf6aa5dff9ddd5fbb.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这家银行需要的帮助并不是真正的技术帮助；他们需要改变他们对风险的思考方式，以及他们的运营方式，他们的发布计划需要进行彻底的改革，他们需要一大堆的自动化。缺乏持续交付的纪律性是阻碍他们获取敏捷的原因，而不是 COBOL。&lt;/p&gt;
&lt;p&gt;“我想进行分解” 是一个常见的客户要求，但分解有不止一个意思。当我们希望有一个分解的应用服务时，这并不能保证模块化 —— 有时它只是意味着乱七八糟的东西被分散得更广。如果有一些外部约束，比如发布看板和陈旧的工作流程，让我们总是被限制住，那在我们解决这些问题之前，我们如何分解都可能是徒劳无功的。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Holly Cummins&lt;/strong&gt; 是 IBM 企业战略部的创新领导者，并在 IBM Garage 担任顾问多年。作为 Garage 的一员，她为各行各业的客户提供技术驱动的创新，从银行业到餐饮业，从零售业到非政府组织。Holly 是 Oracle Java 冠军、IBM Q 大使和 JavaOne Rock Star。她与人合著了 Manning 的《Enterprise OSGi in Action》。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生关乎文化，而不是容器</title>
      <link>https://cloudnative.to/blog/cloud-native-culture-not-container/</link>
      <pubDate>Thu, 18 Mar 2021 11:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-culture-not-container/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://www.infoq.com/articles/cloud-native-culture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud-Native Is about Culture, Not Containers&lt;/a&gt;，文章洋洋洒洒上万字，作者总结了她见过的云原生失败的各种经验教训，还用生动的示例说明了什么不是云原生。译者是在周末闲暇时间仓促间翻译的，其中难免有不当之处，请读者指正。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文主要观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要一味的微服务，就可以做到非常的云原生。&lt;/li&gt;
&lt;li&gt;在开始云原生转型之前，必须明确云原生对你的团队意味着什么，以及要解决的真正问题是什么。&lt;/li&gt;
&lt;li&gt;如果发布涉及繁琐的仪式，不经常发布，而且所有的微服务都必须同时发布，那么微服务架构的好处将无法得到落实。&lt;/li&gt;
&lt;li&gt;持续集成和部署是你要做的事情，而不是你买的工具。&lt;/li&gt;
&lt;li&gt;过度的治理扼杀了云的效率，但如果你对消耗的东西不够重视，就会造成严重的浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在去年的伦敦 QCon 大会上，我提供了一个关于文化而非容器的云原生会议。让我开始思考文化在云原生中的作用的是 &lt;a href=&#34;https://www.infoq.com/articles/microservices-post-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bilgin Ibryam&lt;/a&gt; 一篇很棒的 &lt;a href=&#34;https://www.infoq.com/articles/microservices-post-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfoQ 文章&lt;/a&gt;。Bilgin 做的其中一件事是将云原生架构定义为很多微服务，通过智能管道连接。我看了之后，觉得它看起来完全不像我写的应用，尽管我认为我在写云原生应用。我是 IBM Garage 的一员，帮助客户实现云原生，然而我很少在我的应用中使用微服务。我创建的应用大多看起来和 Bilgin 的图完全不一样。这是否意味着我做错了，或者说云原生的定义可能有点复杂？&lt;/p&gt;
&lt;p&gt;我不想把 Bilgin 单列出来，因为 Bilgin 的文章叫《后 Kubernetes 时代的微服务》，所以如果他在那篇文章中不是经常说到微服务，那就有点可笑了。事实也是如此，几乎所有关于云原生的定义都把它等同于微服务。无论在哪里，我都不断看到这样的假设：微服务等于云原生，云原生等于微服务。就连云原生计算基金会（CNCF）也曾经把云原生定义为：都是微服务，都是容器，还有一点动态编排在里面。说云原生并不总是涉及微服务，这让我陷入了这个特殊的境地，因为我不仅说 Bilgin 错了，我还说云原生计算基金会错了 —— 他们对云原生了解过什么？我相信我知道的比他们多得多吧？&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_hu6485f23e60e2e8e9568294bae27898e8_77282_5509d02b952b9531339a5de94c9a080b.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_hu6485f23e60e2e8e9568294bae27898e8_77282_b110f24432a7c1170fa439f8e55241a5.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_hu6485f23e60e2e8e9568294bae27898e8_77282_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_hu6485f23e60e2e8e9568294bae27898e8_77282_5509d02b952b9531339a5de94c9a080b.webp&#34;
               width=&#34;760&#34;
               height=&#34;510&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;显然我不知道在这个问题上，我站在了历史的错误一边。我承认这一点。虽然我站错了历史的一边，但我注意到 CNCF 已经更新了他们对云原生的定义，虽然微服务和容器仍然存在，但它们似乎不像以前那样必须，所以这一点历史可能在我这边！）。不管对不对，我还是要死在我的小山头上，那个 Cloud Native 是关于比微服务更大的东西。微服务是一种方式。它们不是唯一的方式。&lt;/p&gt;
&lt;p&gt;事实上，在我们的社区中，你确实看到了一系列的定义。如果你问一堆人 Cloud Native 是什么意思，有些人会说 &amp;ldquo;生长在云上&amp;rdquo;。这是非常原始的 Cloud Native 定义，早在微服务还没有出现的时候就已经有了。有人会说这是微服务。&lt;/p&gt;
&lt;p&gt;有人会说，&amp;ldquo;哦，不对，不只是微服务，是 Kubernetes 上的微服务，这样才有 Cloud Native&amp;rdquo;。这个我不喜欢，因为在我看来，Cloud Native 不应该是一个技术选择的问题。有时候我看到 Cloud Native 被当做 DevOps 的同义词，因为很多云原生的原则和实践和 DevOps 教的东西很相似。&lt;/p&gt;
&lt;p&gt;有时，我看到云原生的用法只是作为一种说 &amp;ldquo;我们正在开发现代软件&amp;rdquo; 的方式。&amp;ldquo;我们将使用最佳实践；它将是可观察的；它将是健壮的；我们将经常发布，并使一切自动化；简而言之，我们将采用过去 20 年所学到的一切，并以这种方式开发软件，这就是云原生的原因&amp;rdquo;。在这个定义中，云只是一种必然 —— 当然是在云上，因为我们是在 2021 年开发的。&lt;/p&gt;
&lt;p&gt;有时候我看到 Cloud Native 只是用来指云。我们听惯了 Cloud Native，以至于每次说到 Cloud 的时候，都觉得要在后面加上一个 &amp;ldquo;Native&amp;rdquo;，但其实我们只是在说 Cloud。最后，当人们说 Cloud Native 的时候，有时候他们的意思是 idempotent（幂等的）。这个问题是，如果你说 Cloud Native 的意思是 idempotent，其他人就会说：&amp;quot; 什么？我们说的 idempotent 真正的意思是可复用？如果我把它拿去，把它关了，然后再启动，运行结果跟之前也是一样的。这是对云上服务的一个基本要求。”&lt;/p&gt;
&lt;p&gt;有了这些不同的定义，难怪我们在做 Cloud Native 的时候，并不能完全确定我们要做的是什么。&lt;/p&gt;
&lt;h2 id=&#34;为什么&#34;&gt;为什么？&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;我们到底想实现什么？&amp;rdquo; 这是一个非常重要的问题。当我们在思考技术选择和技术风格的时候，我们要从 &amp;ldquo;我做 Cloud Native 是因为别人都在做退到思考我到底想解决什么问题？&amp;rdquo; 为了公平对待 CNCF，他们在对云原生的定义前面就有这个 &amp;ldquo;为什么&amp;rdquo;。他们说：&amp;quot; 云原生就是使用微服务来更快地构建伟大的产品。我们使用微服务不仅仅是因为我们想使用，我们使用微服务是因为微服务帮助我们更快地构建伟大的产品。”&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_huf6bb2087ac2d66cdd5a940f08cea5ded_23634_7bdb211c3193503a67731a2bfa9b815c.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_huf6bb2087ac2d66cdd5a940f08cea5ded_23634_5d5c6edcff1b095520d579a1870222a0.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_huf6bb2087ac2d66cdd5a940f08cea5ded_23634_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_huf6bb2087ac2d66cdd5a940f08cea5ded_23634_7bdb211c3193503a67731a2bfa9b815c.webp&#34;
               width=&#34;760&#34;
               height=&#34;674&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们退一步确保我们理解要解决的问题。为什么我们之前不能更快地打造出优秀的产品？很容易跳过这一步，我想我们所有人有时候都会犯这样的毛病。有时候我们真正要解决的问题是，别人都在做，所以我们害怕错过，除非我们开始做。一旦我们这样说，FOMO（错失恐惧症）就不是一个很好的决策标准。更糟糕的是，&amp;ldquo;我的简历看起来很沉闷&amp;rdquo; 绝对不是选择技术的正确理由。&lt;/p&gt;
&lt;h2 id=&#34;为什么是云&#34;&gt;为什么是云？&lt;/h2&gt;
&lt;p&gt;我认为要想知道为什么我们应该以云原生的方式来做事情；我们要退一步说：&amp;ldquo;为什么我们在云上做事情？&amp;rdquo; 以下是原因。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;成本&lt;/strong&gt;：当我们刚开始把东西放在云上的时候，价格是主要的动机。我们说：&amp;ldquo;我有这个数据中心，我必须支付电费，我必须支付人员维护它。而且我必须购买所有的硬件。当我可以使用别人的数据中心时，我为什么要这么做呢？&amp;rdquo; 在自己的数据中心和别人的数据中心之间形成成本节约的原因是，自己的数据中心必须为最大需求储备足够的硬件。这有可能是大量的容量，而这些容量在大部分时间是没有使用的。如果是别人的数据中心，你可以集中资源。当需求低迷时，你不会为额外的容量付费。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;弹性&lt;/strong&gt;。云计算为你省钱的原因就是因为它的弹性。你可以扩大规模；你可以缩小规模。当然，这已经是旧闻了。我们都认为弹性是理所当然的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;速度&lt;/strong&gt;：我们现在之所以对云感兴趣，是因为速度。不一定是硬件的速度，虽然有些云硬件的速度可以快得让人眼花缭乱。云是使用 GPU 的一个很好的方式，这多少也是使用量子计算机的唯一方式。不过，更普遍的是，我们可以通过云端将一些东西以某种方式、某种方式更快地推向市场，这比我们不得不将软件打印到光盘上，然后邮寄给人们，甚至比我们不得不在自己的数据中心站立实例的时候还要快。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-因素&#34;&gt;12 因素&lt;/h2&gt;
&lt;p&gt;节约成本、弹性和交付速度都很好，但我们只要在云端就能得到这些。为什么我们需要云原生？我们需要云原生的原因是，很多公司发现他们试图上云，结果被电死了。&lt;/p&gt;
&lt;p&gt;事实证明，云上的东西需要用不同的方式来编写和管理。把这些不同的地方阐述出来，就形成了 12 因素。这 12 个因素是对你应该如何编写云应用的一系列规定，这样你就不会被电死。&lt;/p&gt;
&lt;p&gt;你可以说这 12 个因素描述了如何编写云原生应用 —— 但这 12 个因素与微服务完全没有关系。它们都是关于你如何管理应用的状态。它们是关于如何管理你的日志。12 个因素帮助应用程序变得幂等化，但 &amp;ldquo;12 因素&amp;rdquo; 比 &amp;ldquo;幂等化因素&amp;rdquo; 更吸引人。&lt;/p&gt;
&lt;p&gt;这 12 个因素是在 Docker 进入市场前两年发布的。Docker 容器彻底改变了云的使用方式。容器如此之好，很难夸大其重要性。它们解决了很多问题，创造了新的架构可能性。因为容器是如此的简单，所以可以将一个应用分布在许多容器上。有些公司在 100、200、300、400 或 500 个不同的容器上运行单个应用。与这样的工程实力相比，一个应用如果仅仅分布在 6 个容器上，似乎有点不够用。面对如此少的复杂性，人们很容易想到 &amp;ldquo;我一定是做错了。我还不如那边的开发者呢&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_huc0ebb44421fd993ebbc2037dd932e4d7_125286_afe2053b264bf0dba9f587692199434b.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_huc0ebb44421fd993ebbc2037dd932e4d7_125286_535aa348f17d44ef34e7355137b0b9c2.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_huc0ebb44421fd993ebbc2037dd932e4d7_125286_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_huc0ebb44421fd993ebbc2037dd932e4d7_125286_afe2053b264bf0dba9f587692199434b.webp&#34;
               width=&#34;760&#34;
               height=&#34;534&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;事实上，这不是比拼你能拥有多少个容器。容器是很好的，但你拥有的容器数量应该根据你的需求进行调整。&lt;/p&gt;
&lt;h2 id=&#34;速度&#34;&gt;速度&lt;/h2&gt;
&lt;p&gt;让我们试着回忆一下 —— 你的需求又是什么？当我们想到云的时候，我们通常要考虑的是速度。我们之所以想要大量的容器，是因为我们想要更快地将新的东西推向市场。如果我们有很多容器，我们要么把完全一样的东西推向市场，要么以同样的速度推向市场，那么突然之间，这些容器只是一种成本。它们并没有帮助我们，我们正在消耗周期来管理将应用分散在基础设施上的小块应用所带来的复杂性。如果我们有这个神奇的架构，可以让我们对市场做出反应，但我们没有做出反应，那就是一种浪费。如果我们有这个架构，意味着我们可以快速发展，但是我们没有快速发展，那么这也是一种浪费。&lt;/p&gt;
&lt;h2 id=&#34;如何在云原生中失败&#34;&gt;如何在云原生中失败&lt;/h2&gt;
&lt;p&gt;这让我想到了如何在云原生中失败。关于我的背景，我是一个顾问。我是 IBM Garage 的全栈开发人员。我们与初创公司和大公司合作，帮助他们上云，并从云中获得最大的好处。作为其中的一部分，我们帮助他们解决有趣的、艰难的问题，我们帮助他们以比以前更快的速度做软件。为了确保我们真的能从云端获得最大的收益，我们做了精益创业、极限编程、设计思维、DevOps；以及云原生。因为我是一个顾问，所以我看到很多客户都在云计算的旅程中。有时候很顺利，有时候也会有这些陷阱。以下是我看到聪明的客户掉进的一些陷阱。那么，什么是云原生？&lt;/p&gt;
&lt;p&gt;最早的一个陷阱就是关于云原生的意思。如果我说云原生，我是一个意思，而你说云原生，又是另一个意思，我们的沟通就会有问题&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;有时候这并不重要，但有时候却有很大的不同。如果一个人认为目标是微服务，然后另一个人觉得目标是拥有一个幂等的系统，呃哦。或者说，如果一个组织的一部分人想上云，因为他们认为云可以让他们更快地进入市场，但另一部分人上云只是为了和以前完全一样的速度，但更具成本效益，那么我们可能会在以后的道路上发生一些冲突。&lt;/p&gt;
&lt;h2 id=&#34;微服务环境&#34;&gt;微服务环境&lt;/h2&gt;
&lt;p&gt;通常情况下，促使人们对目标产生一些困惑的原因之一是，我们有一种自然的倾向，即看到其他人做着奇妙的事情，并想效仿他们。我们想自己去做那些奇妙的事情，而没有真正思考我们的环境和它们是否适合。我们的一位 IBM 研究员在去和客户谈微服务的时候，有一个启发式的方法。他说：&amp;ldquo;如果他们开始谈论 Netflix，而他们只是一直在谈论 Netflix，他们从来没有提到连贯性，也没有提到耦合，那么可能他们做这件事的原因并不正确。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;有时候我们和客户聊天，他们说：&amp;ldquo;对，我想现代化到微服务。&amp;rdquo; 好吧，微服务不是目标。没有客户会看着你的网站说，&amp;ldquo;哦，微服务。这很好。&amp;rdquo; 客户会看你的网站，并根据它是否满足他们的需求，是否简单和令人愉快，以及，所有这些其他事情来判断它。微服务可以是达到这个目的的一个很好的手段，但它们本身并不是一个目标。我还应该说：微服务是一种手段。它们不一定是实现这一目标的唯一手段。&lt;/p&gt;
&lt;p&gt;我在 IBM Garage 的一位同事与亚太地区的一家银行进行了一些对话。这家银行在响应客户时遇到了问题，因为他们的软件都很老旧、沉重和钙化。他们也遇到了人员问题，因为他们所有的 COBOL 开发人员都老了，而且都要离开工作岗位。因此，银行知道他们必须进行现代化改造。在这个案例中，主要的驱动力不是劳动力的老化，而是竞争力和灵活性。他们被竞争对手打败了，因为他们拥有大量的 COBOL 代码，而每次改变都是昂贵而缓慢的。他们说：&amp;ldquo;好吧，为了解决这个问题，我们需要摆脱所有的 COBOL，我们需要切换到现代微服务架构。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;到目前为止，还不错。我们正准备跳进一些云原生的好东西时，银行又说他们的发布板一年只开两次会。这时，我们又收手了。不管银行的新架构会有多少微服务，这些微服务都会被组装成一个大的单体发布包，每年部署两次。这就是拿了微服务的开销，却没有好处。因为这不是一场看你有多少容器的比赛，大量的容器和缓慢的发布将是一个绝对没有人赢的堆栈。&lt;/p&gt;
&lt;p&gt;大量的微服务被锁定在一个迟缓的发布节奏中，不仅不会是一种胜利，还可能是一种糟糕的损失。当组织尝试微服务时，他们并不总是像图片中的那样，最终得到一个美丽的解耦微服务架构。相反，他们最终得到的是一个分布式单体。这就像一个普通的单体，但要糟糕得多。之所以说这是格外可怕的坏事，是因为一个正常的、非分布式的单体有诸如编译时检查类型和同步的、有保证的内部通信。在单进程中运行会损害你的可扩展性，但这意味着你不能被分布式计算的谬误所困扰。如果你把同样的应用程序，然后只是在互联网上涂抹，不投入任何类型检查或投资于网络问题的错误处理，你不会有更好的客户体验，你会有更糟糕的客户体验。&lt;/p&gt;
&lt;p&gt;在很多情况下，微服务是错误的答案。如果你是一个小团队，你不需要有很多自主的团队，因为每个独立的团队会有大约四分之一的人。假设你没有任何计划，也不希望独立发布部分应用，那么你不会从微服务的独立性中获益。&lt;/p&gt;
&lt;p&gt;为了在你的应用程序的所有这些组件之间提供安全和可靠的通信和可发现性，你刚刚抹过云的一部分，你将需要类似服务网格的东西。你可能在技术曲线上很先进，或者对这个技术曲线有点陌生。你要么不知道服务网格是什么，要么你说：&amp;ldquo;我都知道服务网格是什么。那么复杂，那么夸张。我不需要服务网格。我只想自己搞一个服务网格。&amp;rdquo; 这不一定会给你带来你所希望的结果。你最终还是会得到一个服务网格，但你必须维护它，因为它是你写的！不做微服务的另一个很好的理由是，有时候领域模型就是没有那些天然的断裂点，让你得到漂亮整洁的微服务。在这种情况下，完全有理由说：&amp;ldquo;你知道吗？我就不做了。&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;云原生面条&#34;&gt;云原生面条&lt;/h2&gt;
&lt;p&gt;如果你不从杂乱中走出来，那么你最终会遇到下一个问题，那就是云原生面条。当我看 Netflix 微服务的通信图时，我总觉得有些恐慌。我确信他们知道自己在做什么，而且他们已经想好了，但在我眼里，它看起来完全像意大利面条。让它发挥作用需要很多真正扎实的工程和专门的技能。如果你不具备这种专业性，那么你最终会陷入混乱的局面。&lt;/p&gt;
&lt;p&gt;我被邀请去给一个正在苦苦挣扎的客户做一些支持工作。他们正在开发一个绿地应用，所以他们当然选择了微服务，以尽可能的现代化。他们对我说的第一句话就是：&amp;ldquo;只要我们修改任何代码，其他的东西就会坏掉。&amp;rdquo; 这不是微服务应该发生的事情。事实上，这与我们都被告知如果我们实现微服务会发生的情况完全相反。微服务的梦想是它们是解耦的。遗憾的是，解耦并不是免费的。它当然不会因为你分布式的东西而神奇地发生。当你分布式的东西时，所发生的是你有两个问题而不是一个问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hudd46e8abbf8269aa97aa0a18c770a287_65385_4a74bcaf626df1169f607eb6b462655a.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hudd46e8abbf8269aa97aa0a18c770a287_65385_22290bf68eb58ee511b607171e6ff5f6.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hudd46e8abbf8269aa97aa0a18c770a287_65385_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hudd46e8abbf8269aa97aa0a18c770a287_65385_4a74bcaf626df1169f607eb6b462655a.webp&#34;
               width=&#34;760&#34;
               height=&#34;550&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生面条还是面条。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的客户的代码之所以这么脆弱，耦合性这么强，其中一个原因是他们的对象模型相当复杂，大约有 20 个类，部分类中有 70 个字段。在微服务系统中处理这种复杂的对象模型是很难的。在这种情况下，他们看了看他们复杂的对象模型，决定：&amp;ldquo;我们知道在我们的微服务之间有共同的代码是非常不好的，因为这样我们就没有解耦。相反，我们要在我们所有的六个微服务中复制和粘贴这个共同的对象模型。因为我们剪切和粘贴它，而不是链接到它，所以我们是解耦的。&amp;rdquo; 嗯，不，你不是解耦的。如果当一件事情发生变化的时候，不管是链接还是复制代码，事情就会中断，这就是耦合。&lt;/p&gt;
&lt;p&gt;在这种情况下，什么是 &amp;ldquo;正确&amp;rdquo; 的做法？在理想的情况下，每个微服务都会整齐地映射到一个域上，而且它们很有区别。如果你有一个大域和很多微小的微服务，那就会有问题了。解决的办法是，要么决定领域真的很大，然后合并微服务，要么做更深层次的领域建模，尝试把对象模型解开，变成不同的边界上下文。&lt;/p&gt;
&lt;p&gt;即使是最干净的域分离，在任何系统中，组件之间总会有一些接触点 —— 这才是系统的本质。这些接触点很容易出错，即使它们是最小的，尤其是当它们是隐藏的。你还记得 &amp;ldquo;火星气候轨道器&amp;rdquo; 吗？与 &amp;ldquo;毅力号&amp;rdquo; 不同的是，它被设计为在安全距离内绕着火星运行，而不是在火星上着陆。遗憾的是，它离火星太近了，被火星的引力拉了进去，然后坠毁了。探测器的失利令人惋惜，根本原因就是个悲剧。轨道器由两个模块控制，一个是探测器，一个是地球上的模块。探测模块是半自主的，因为从地球上大部分时间看不到轨道器。大约每隔三天，行星就会对准，它就会出现在视野中，地球上的团队就会微调它的运行轨迹我猜想当时的指令是这样的：&amp;ldquo;哦，我想你需要向左移动一点，哦，如果你不向右移动一点，你就会错过火星。&amp;rdquo; 除了数字。&lt;/p&gt;
&lt;p&gt;数字是导致问题的原因。地球模块和探测模块是由两个不同的团队建造的两个不同的系统。探测器使用的是英制单位，而 JPL 地面团队使用的是公制单位。尽管这两个系统看起来是独立的，但它们之间有一个非常重要的耦合点。每次地面团队传送指令时，他们发送的指令都会以一种谁也想不到的方式进行解释。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu3fb4d088e7fc4c12550328faaea6f578_62162_339d7161355a0b9d54778d2bf5c1fe48.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu3fb4d088e7fc4c12550328faaea6f578_62162_29757808cb3625d7b85708c2c92dee66.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu3fb4d088e7fc4c12550328faaea6f578_62162_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu3fb4d088e7fc4c12550328faaea6f578_62162_339d7161355a0b9d54778d2bf5c1fe48.webp&#34;
               width=&#34;760&#34;
               height=&#34;567&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个故事的寓意是，分布式系统没有帮助。一部分系统在火星上，一部分系统在地球上，你不能比这更分散。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;微服务需要消费者驱动的接触测试&#34;&gt;微服务需要消费者驱动的接触测试&lt;/h2&gt;
&lt;p&gt;在这种情况下，解决方案，正确的做法是真正明确耦合点是什么，双方各自的期望值是什么。一个很好的方法就是消费者协议驱动的测试（Contract-driven Test）。尽管接触测试（Contract Test）是解决一个大问题的干净利落的办法，但在我们这个行业还没有被广泛使用。我认为部分问题是，它们可能有点棘手，难以学习，这减缓了采用的速度。关于测试的跨团队谈判也会很复杂 —— 尽管如果关于测试的谈判太难，关于实际交互参数的谈判会更难。如果你正在考虑探索接触测试，Spring Contract 或 Pact 是不错的起点。哪一个适合你，取决于你的环境。Spring Contract 很好地集成到了 Spring 生态系统中，而 Pact 是框架无关的，并且支持大量的语言，包括 Java 和 Javascript。&lt;/p&gt;
&lt;p&gt;接触测试远远超出了 OpenAPI 验证的作用，因为它检查的是 API 的语义，而不仅仅是语法。它比 &amp;ldquo;好吧，两边的字段都有相同的名字，所以我们很好。&amp;rdquo; 这是个更有用的检查，它允许你检查，&amp;ldquo;当我得到这些输入时，我的行为是否是预期的行为？我在那边命名的关于那个 API 的假设是否仍然有效？&amp;rdquo; 这些都是你需要检查的东西，因为如果它们不是真的，事情就会变得非常糟糕。&lt;/p&gt;
&lt;p&gt;很多公司都意识到了这个风险，也意识到做微服务的时候系统有不稳定的地方。为了有信心这些东西能一起工作，他们在发布之前会施加一个 UAT 阶段。在任何微服务发布之前，需要有人花几周时间测试它在更广泛的系统中是否正常工作。有了这样的开销，发布不会经常发生。那么这就引出了经典的反模式，那就是不连续的持续集成和持续部署，或者说 I/D。&lt;/p&gt;
&lt;h3 id=&#34;为什么持续集成而不持续部署&#34;&gt;为什么持续集成而不持续部署&lt;/h3&gt;
&lt;p&gt;我和很多客户交流，他们会说：&amp;ldquo;我们有一个 CI/CD。&amp;rdquo; 这给我们敲响了警钟，因为 CI/CD，不应该是你买了一个工具，放在服务器上，然后欣赏，说 &amp;ldquo;有 CI/CD。&amp;ldquo;CD/CD 是你必须要做的事情。这两个字母分别代表持续集成和持续部署或交付。连续在这里意味着 &amp;ldquo;真的经常集成&amp;rdquo; 和 &amp;ldquo;真的经常部署&amp;rdquo;，如果你没有做到这一点，那么根本就不是连续。&lt;/p&gt;
&lt;p&gt;有时候我会无意中听到这样的评论：&amp;ldquo;下周我就把我的分支合并到我们的 CI 系统中&amp;rdquo;。这完全忽略了 &amp;ldquo;CI&amp;rdquo; 中的 &amp;ldquo;C&amp;rdquo;，它代表的是持续。如果你每周合并一次，那就不是连续。这几乎是连续的反义词。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;D&amp;rdquo; 部分可能会更加困难。如果软件每半年才部署一次，CI/CD 服务器可能很有用，但是没有人做 CD。可能有 &amp;ldquo;D&amp;rdquo;，但大家都忘记了 &amp;ldquo;C&amp;rdquo; 的部分。&lt;/p&gt;
&lt;p&gt;到底多长时间推送一次才是合理的？连续性得有多连续？甚至我也承认，一些严格定义的连续会是一个团队中写软件的可笑方式。如果你把每一个角色都推到 main，这在技术上是连续的，但它会在团队中造成混乱。如果你每次提交都集成，并且目标是每小时提交几次，这可能是一个很好的节奏。如果你经常提交，每隔几次提交就集成一次，那么你每天推送几次，这样也是很好的。如果你做的是测试驱动的开发，那么当你得到一个合格的测试时，集成是一个很好的模式。我很提倡基于主干的开发（TBD）。TBD 在调试、实现机会主义重构、避免同事出现大的意外等方面有很多好处。基于主干的开发的技术定义是，你需要每天至少集成一次才算。我有时会听到 &amp;ldquo;每天一次&amp;rdquo; 被描述为 &amp;ldquo;还好&amp;rdquo; 和 &amp;ldquo;就是不连续&amp;rdquo; 之类的。一周一次就真的很成问题了。&lt;/p&gt;
&lt;p&gt;一旦你每个月一次，那就太可怕了。当我加入 IBM 的时候，我们用的是一个构建系统和一个代码仓库，叫 CMVC。对于背景来说，这大概是二十年前的事情，我们整个行业都比较年轻，比较愚蠢。我在 IBM 的第一份工作是帮助构建 WebSphere 应用服务器。我们有一个大型的多站点构建，团队每周有六天开会，包括周六，讨论任何构建失败的问题。那个电话有很多重点，你不希望在 WebSphere 构建电话中被叫起来。我刚从大学毕业，对团队中的软件开发一窍不通，所以一些资深的开发人员把我收在了他们的手下。我至今还记得的一个建议是，避免被 WebSphere 构建调用的方法是将你所有的修改在本地机器上保存半年，然后全部批量推送。&lt;/p&gt;
&lt;p&gt;在这个项目上，我还小，我想，好吧，这似乎不是很正确的建议，但我想你最清楚。事后看来，我意识到 WebSphere 的构建破坏得很严重，因为人们将他们的变化保存了六个月，然后才试图与他们的同事进行整合。很明显，那是行不通的，我们改变了做事的方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_huca0cae54aee87cd6d3ef6aab02295aac_68194_56c13ed0b6eced85963dfa16ad7a0571.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_huca0cae54aee87cd6d3ef6aab02295aac_68194_f5fc89ac841249eed7401518adcb53b0.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_huca0cae54aee87cd6d3ef6aab02295aac_68194_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_huca0cae54aee87cd6d3ef6aab02295aac_68194_56c13ed0b6eced85963dfa16ad7a0571.webp&#34;
               width=&#34;760&#34;
               height=&#34;479&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你应该多久整合一次？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下一个更难的问题是，你应该多久发布一次？和集成一样，有一个合理的选择范围。你可以每次推送都发布。许多技术公司都这样做。如果你每次迭代部署一次，你还是很有优势的。一个季度发布一次就有点悲哀了。你可以每两年发布一次。现在看来慢得荒唐，但在糟糕的过去，这是我们行业的标准模式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hu317f5fbf466ae1af43500c1807287a02_69950_a6cad236d7ff1d1b7a1027f926e292fc.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hu317f5fbf466ae1af43500c1807287a02_69950_64622f3b11b84d133a52caa1f0e841fc.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hu317f5fbf466ae1af43500c1807287a02_69950_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hu317f5fbf466ae1af43500c1807287a02_69950_a6cad236d7ff1d1b7a1027f926e292fc.webp&#34;
               width=&#34;760&#34;
               height=&#34;392&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多久应该部署到生产中一次？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之所以每次推送都能部署到生产中，是因为部署不等于发布。如果我们的新代码太不完整或者太吓人，无法真正展示给用户，我们仍然可以部署它，但要把它隐藏起来。我们可以让代码实际存在于生产代码库中，但没有任何东西与之相连。这样就很安全了。如果我们已经有点太纠结了，我们可以使用功能标志来翻开和关闭功能。如果我们感觉更冒险，我们可以做 A/B 或亲朋好友测试，这样只有一小部分用户看到我们可怕的代码。金丝雀部署是另一种变化，用于预先检测噩梦，在它们进入主流使用之前。&lt;/p&gt;
&lt;p&gt;不发布有两个不好的后果。它延长了反馈周期，这会影响决策，并使工程师感到悲伤。从经济上讲，这也意味着有库存（工作软件）坐在货架上，而不是送到客户手中。精益原则告诉我们，有库存放在那里，不产生退货，就是浪费。&lt;/p&gt;
&lt;p&gt;那么话题就是，为什么我们不能发布这个？是什么阻止了更频繁的部署？很多组织害怕他们的微服务，他们希望对整个组件进行集成测试，通常是手动集成测试。有一个客户，有大约 60 个微服务，他们希望确保不存在某个聪明的工程师火花可以发布一个微服务而不发布其他 59 个微服务的可能性。为了强制执行这一点，他们为所有的微服务大批量地设置了一个单一的管道。这显然不是微服务的价值取向，即微服务是可以独立部署的。可悲的是，这是他们觉得最安全的方式。&lt;/p&gt;
&lt;p&gt;我们也看到了因为对质量和完整性的担忧，实际上不愿意交付。当然，这些并不荒唐。你不想激怒你的客户。另一方面，就像里德・霍夫曼所说的那样，如果你没有因为第一次发布而感到尴尬，那就太晚了。持续改进是有价值的，让东西被使用也是有价值的。&lt;/p&gt;
&lt;p&gt;如果发布的频率不高，而且是单体的，你就有了这些漂亮的微服务架构，可以让你走得更快，然而你走得很慢。这是坏的业务，也是坏的工程。&lt;/p&gt;
&lt;p&gt;假设你选择了频繁部署。所有保护你的用户不受半成品功能影响的东西，比如自动测试、功能标志、A/B 测试、SRE，都需要大量的自动化。通常当我开始与客户合作时，我们有一个关于测试的问题，他们说：&amp;ldquo;哦，我们的测试不是自动化的。&amp;rdquo; 这意味着他们实际上不知道代码是否在任何特定的点上工作。他们希望它能工作，而且上次检查时可能已经工作了，但我们没有任何办法在不运行手动测试的情况下知道它现在是否工作。&lt;/p&gt;
&lt;p&gt;问题是，退步是会发生的。即使所有的工程师都是最完美的工程师，也有一个不那么完美的外部世界。他们所依赖的系统可能会有意想不到的行为。如果一个依赖更新改变了行为，即使没有人做错任何事情，也会有一些东西被破坏。这就回到了 &amp;ldquo;我们不能交付是因为我们对质量没有信心&amp;rdquo; 的问题上。好吧，让我们解决对质量的信心问题，然后我们就可以交付了。&lt;/p&gt;
&lt;p&gt;我谈到了合同测试。这很便宜，也很简单，可以在单元测试层面进行，当然，你也需要自动化集成测试。你不希望依赖手动集成测试，否则它们会成为瓶颈。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;CI/CD&amp;rdquo; 似乎已经取代了我们词汇中的 &amp;ldquo;构建&amp;rdquo;，但在这两种情况下，它都是你作为一个工程组织所拥有的最有价值的东西之一。它应该是你的朋友，它应该是这种无处不在的存在。有时候构建的方式是，它在某个地方的 Jenkins 系统上被关闭了。稍微勤快一点的人时不时去检查一下网页，发现是红色的，就去告诉同事，最后有人把问题解决了。更好的是只是一个被动的构建指标，大家都可以看到，而不需要单独打开一个页面来查看。如果显示器红了，真的很明显，那就是有变化了，而且很容易看最近的变化。如果你有一个项目，红绿灯就可以用。如果你有微服务，你可能会需要类似一组磁贴的东西。即使你没有微服务，你可能会有好几个项目，所以你需要比红绿灯更完整一点的东西，尽管红绿灯很可爱。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu1d7c4fde505f04b999839c126b79c9cb_41727_9c54ba484a9c632407a517d5ea00619d.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu1d7c4fde505f04b999839c126b79c9cb_41727_e0ed0113d2fa8f3ed5cb32c2b0a995a0.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu1d7c4fde505f04b999839c126b79c9cb_41727_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu1d7c4fde505f04b999839c126b79c9cb_41727_9c54ba484a9c632407a517d5ea00619d.webp&#34;
               width=&#34;760&#34;
               height=&#34;573&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们不知道什么时候构建好了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你投资你的构建监控，那么你最终会出现破窗的情况。我到了客户那里，第一件事就是看了一下构建，我说：&amp;ldquo;哦，这个构建好像坏了。&amp;rdquo; 他们说：&amp;ldquo;是啊，已经坏了几个星期了。&amp;rdquo; 这时，我就知道我有很多工作要做了！&lt;/p&gt;
&lt;p&gt;为什么一个“破窗”的构建是不好的？这意味着你无法进行自动化集成测试，因为没有任何东西能从构建中做出来。事实上，你甚至无法进行手动集成测试，所以服务间的兼容性可能会恶化，而且没有人会知道。&lt;/p&gt;
&lt;p&gt;新的回归没有被发现，因为这个构建已经红了。也许最糟糕的是，它创造了一种文化，所以当其他构建中的一个红色时，人们并不那么担心，因为它更多的是相同的：&amp;ldquo;现在我们有两个红色。也许我们可以弄到整套的，然后如果我们把它们都弄红了，就能匹配了。&amp;rdquo; 嗯，不，不应该是这样的。&lt;/p&gt;
&lt;h2 id=&#34;锁定的完全僵化的不灵活的云雾缭绕的云端&#34;&gt;锁定的完全僵化的、不灵活的、云雾缭绕的云端&lt;/h2&gt;
&lt;p&gt;这些都是发生在团队层面的挑战。它们是关于我们作为工程师如何管理自己和我们的代码。但当然，尤其是当你到了一定规模的组织，你最终会面临另一系列的挑战，那就是组织如何使用云。我注意到，有些组织喜欢把云，变成一个锁定的、完全僵化的、灵活的、没有云的云。&lt;/p&gt;
&lt;p&gt;如何让一个云端不云端？你说：&amp;ldquo;好吧，我知道你可以走得很快，我知道你所有的自动化支持都走得很快，但是我们有一个流程。我们有一个架构评审委员会，它的会议相当不频繁。&amp;rdquo; 它将在项目准备交付后一个月开会，或者在最坏的情况下，它将在项目已经交付后一个月开会。虽然东西已经交付了，但我们还是在走流程。架构将在已经在现场验证后进行纸面审查，这是愚蠢的。&lt;/p&gt;
&lt;p&gt;有人曾经给我讲过一个故事。一个客户向他们抱怨说，IBM 卖给他们的一些配置软件不能用。当时我们承诺我们的精巧的配置软件可以让他们在十分钟内创建虚拟机。这是几年前的事了，当时 &amp;ldquo;10 分钟创建一个虚拟机&amp;rdquo; 是很先进很酷的。我们向他们承诺，这将是美好的。&lt;/p&gt;
&lt;p&gt;当客户安装好它并开始使用时，他们并没有发现它的美妙。他们以为他们会得到 10 分钟的供应时间，但他们看到的是，他们花了三个月的时间来供应一个云实例。他们回来找我们，他们说：&amp;ldquo;你们的软件完全坏了。你卖错了。你看，花了三个月的时间。&amp;rdquo; 我们对此感到疑惑，于是我们进去做了一些调查。事实证明，发生了什么事，他们创建了一个 84 步的预批准程序，以获得其中的一个实例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_hu6485f23e60e2e8e9568294bae27898e8_68226_c9dc6e3920d5e808b90bc612634cc6b3.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_hu6485f23e60e2e8e9568294bae27898e8_68226_9a3fb8686fbc5ae6d4e4f32c6f664b1e.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_hu6485f23e60e2e8e9568294bae27898e8_68226_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_hu6485f23e60e2e8e9568294bae27898e8_68226_c9dc6e3920d5e808b90bc612634cc6b3.webp&#34;
               width=&#34;760&#34;
               height=&#34;612&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这款供应软件已经坏了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术有了，但文化没有，所以技术没有用。这是可悲的。我们把这个云，这是一个美丽的云，它有所有这些神奇的属性，它让一切都变得非常简单，然后组织的另一部分人说，&amp;ldquo;哦，这有点可怕。我们不会希望人们真的能够做事情。让我们把它关进笼子里吧！&amp;rdquo; 那种老式的重文案的治理方式是行不通的 —— 同时也是真的让大家很烦。它不会给出结果。更糟糕的是，它实际上不会让事情变得更安全。它可能会使他们更不安全。它肯定会让事情变得更慢，而且要花钱。我们不应该这样做。&lt;/p&gt;
&lt;p&gt;我和另一个客户聊过，那是一家大型汽车公司，他们在云计算供应方面遇到了真正的问题。他们花了很长的时间来获得实例。他们认为，&amp;ldquo;我们要解决这个问题的方法是我们要从供应商 A 转移到供应商 B。&amp;rdquo; 这可能会奏效，但实际上缓慢的问题是他们的内部采购。切换供应商会绕过他们既定的采购流程，所以可能会加快一段时间，但最终，他们的治理团队会注意到新的供应商，并实施控制。一旦发生这种情况，他们就会将监管落实到位，然后恢复现状。他们所有的成本会改变，但实际上没有任何的好处。这有点像，我很抱歉地说，我有时会受到这样的诱惑 —— 如果你看着你的炉子，你决定，&amp;ldquo;哦，那个烤箱很脏。清理很困难，所以我要搬家，所以我没有清洁烤箱。&amp;rdquo; 但后来，当然，同样的事情发生在其他房子，和新的烤箱变得肮脏。你需要一个更可持续的过程，而不是仅仅更换供应商来试图超越自己的采购。&lt;/p&gt;
&lt;p&gt;如果只有开发者在改变，如果只有开发者在走 Cloud Native 的道路，那么就是行不通的。这并不意味着开发者驱动的自由竞争是正确的模式。如果周围没有一些治理，那么云就会变成一个神秘的钱坑。我们很多人都遇到过这样的问题：看着云账单，觉得 &amp;ldquo;嗯。是啊，这么多，我也不明白钱都花到了哪里，也不明白是谁花的。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;用云端配置硬件是如此简单，但这并不意味着硬件是免费的。还是要有人为它付费。硬件很容易配置，也不能保证硬件有用。&lt;/p&gt;
&lt;p&gt;当我刚开始学习 Kubernetes 的时候，我当然也尝试过。我创建了一个集群，但后来我就偏离了轨道，因为我有太多的工作在进行。过了两个月，我又回到我的集群，发现这个集群一个月大约 1000 英镑&amp;hellip;&amp;hellip; 而且是完全没有价值的。太浪费了，我现在想起来还觉得恶心。&lt;/p&gt;
&lt;p&gt;我们的技术使我们能够做的很多事情都是为了提高效率。伟大的管理顾问彼得・德鲁克说过：&amp;ldquo;没有什么比高效地做那些根本不应该做的事情更无用的了。&amp;rdquo; 高效地创建没有价值的 Kubernetes 集群，这不是好事。除了成本高，还有对生态环境的影响。让一个 Kubernetes 集群消耗价值 1000 英镑的电力，什么都不做，对地球不是很好。&lt;/p&gt;
&lt;p&gt;对于我说的很多问题，最初看起来是技术问题，其实是人的问题。我觉得这个有点不一样，因为这个看似是人的问题，其实是技术问题。这个领域其实工具可以帮助我们。比如说，工具可以帮助我们管理浪费，可以检测到闲置的服务器，帮助我们把服务器追溯到发起人。这方面的工具还没有，但已经越来越成熟了。&lt;/p&gt;
&lt;h2 id=&#34;云管理你的云&#34;&gt;云管理你的云&lt;/h2&gt;
&lt;p&gt;这个云管理的工具化最后是在云上，所以你最后是在递归的情况下，要有一些云来管理你的云。我的公司有一个多云管理器，它会看你的工作负载，找出工作负载的形状，从财务上来说，你能让它上的最优化的供应商是什么，然后自动进行这种迁移。我预计我们可能会开始看到越来越多这样的软件，它在看它，然后说：&amp;ldquo;顺便说一下，我可以告诉他的 Kubernetes 集群其实没有流量，它已经在那里待了两个月了。你为什么不去和 Holly 说几句话呢？&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;微服务运维混乱&#34;&gt;微服务运维混乱&lt;/h2&gt;
&lt;p&gt;管理云成本越来越复杂，这反映了一个更普遍的事情，就是云运维越来越复杂。我们正在使用越来越多的云供应商。有越来越多的云实例涌现出来。我们到处都有集群，那么我们到底该如何为这些集群做运维呢？这就是 SRE (Site Reliability Engineering) 的作用。&lt;/p&gt;
&lt;p&gt;网站可靠性工程的目的是使操作更加可重复，减少繁琐，以使服务更加可靠。它实现这一目标的方法之一是将一切自动化，我认为这是一个令人钦佩的目标。像发布这样的事情，我们越是自动化，我们就越能做到，这对工程师和消费者来说都是好事。最终的目标应该是，发布不是一个事件，而是一切照旧。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu7414d2a7e47878e3356e657421723a4b_53162_8b9ac6e4f9b623345f319846a38cf79a.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu7414d2a7e47878e3356e657421723a4b_53162_df07a107b5d6a6c1888890e73a3ad8f7.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu7414d2a7e47878e3356e657421723a4b_53162_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu7414d2a7e47878e3356e657421723a4b_53162_8b9ac6e4f9b623345f319846a38cf79a.webp&#34;
               width=&#34;760&#34;
               height=&#34;711&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使发布深感无聊。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之所以能够有这种无聊的感觉，是我们对可回收性有信心，是 SRE 让我们对可回收性有信心。&lt;/p&gt;
&lt;p&gt;我有另一个悲伤的太空故事，这次是来自苏联。在 80 年代，一位工程师想对苏联一个叫 &amp;ldquo;Phobos&amp;rdquo; 的太空探测器的代码进行更新。当时，它是机器代码，都是 0 和 1，而且都是手写的。很显然，你不想用手写的机器代码对一个绕着地球飞驰的航天器进行实时更新，而不进行一些检查。在任何推送之前，代码都会经过验证器，验证器相当于机器代码的 linter。&lt;/p&gt;
&lt;p&gt;这样做很好，直到自动检查器坏了，这时需要进行更改。一位工程师说：&amp;ldquo;哦，但我真的想做这个改动。我就绕过自动检查器，直接把我的代码推送给空间探测器，因为，我的代码当然是完美的。&amp;rdquo; 于是，他们用手写的机器代码，在没有检查的情况下，对绕着地球飞驰的航天器进行了实时更新。能出什么问题呢？&lt;/p&gt;
&lt;p&gt;发生的是一个非常微妙的 bug。一切似乎都在正常工作。不幸的是，工程师忘记了其中一个指令的零点。这就改变了指令，从原来的指令变成了停止探测器的充电鳍旋转的指令。Phobos 号的翅片会转向太阳方向，这样无论它朝向哪个方向，都能收集太阳能。两天来一切都很好，直到电池没电了。一旦探测器没电了，他们就没办法恢复它，因为整个东西都死了。&lt;/p&gt;
&lt;p&gt;这就是一个完全无法恢复的系统的例子。一旦它死了，你就再也找不回来了。你不能只是做一些事情，然后把它恢复到一个干净的空间探测代码副本，因为它在太空中。&lt;/p&gt;
&lt;p&gt;这样的系统是真正无法恢复的。我们很多人认为，我们所有的系统几乎都和空间探测器一样无法恢复，但事实上，只有极少数系统可以恢复。&lt;/p&gt;
&lt;p&gt;我们真正想做的是在这个频谱的顶端，我们可以在几毫秒内恢复，没有数据丢失。 如果有任何问题，只是，&amp;ldquo;ping，它被修复&amp;rdquo;。如果有什么问题，它只是，&amp;ldquo;ping，它的固定&amp;rdquo;。这真的很难达到，但有一大堆中间点是现实的目标。&lt;/p&gt;
&lt;p&gt;如果我们恢复的速度很快，但是数据丢失了，那就不太好了，但是我们可以接受。如果我们有交接和人工干预，那对于恢复的速度会慢很多。当我们在考虑频繁部署和部署的时候，非常无聊 —— 我们要有信心，我们在那个上端。我们到达那里的方式，交接不好，自动化，好。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu43e33ad35029ec816752700c94282909_58285_359c19a4e32dbe2649fbfd0c1d632eee.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu43e33ad35029ec816752700c94282909_58285_cae6a356397f7fe793d80781db6bfbe8.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu43e33ad35029ec816752700c94282909_58285_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu43e33ad35029ec816752700c94282909_58285_359c19a4e32dbe2649fbfd0c1d632eee.webp&#34;
               width=&#34;760&#34;
               height=&#34;610&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;云原生成功的方法&#34;&gt;云原生成功的方法&lt;/h2&gt;
&lt;p&gt;这篇文章包含了一大堆关于我所看到的可能出错的事情的悲惨故事。我不想给你留下一个印象，即所有的事情都会出错，因为很多时候，事情确实非常正确。云原生是一种奇妙的软件开发方式，它可以让团队感觉更好，降低成本，让用户更快乐。作为工程师，我们可以把更少的时间花在辛苦和繁琐的事情上，而把更多的时间花在真正想做的事情上&amp;hellip;&amp;hellip; 我们可以更快地进入市场。&lt;/p&gt;
&lt;p&gt;要想达到这种快乐的状态，我们必须在整个组织中保持一致。我们不能让一群人说微服务，一群人说快，一群人说老式治理。这几乎肯定是行不通的，会有很多脾气暴躁的工程师和委屈的财务人员。相反，一个组织应该在整体层面上达成共识，它要实现的目标是什么。一旦同意了这个目标，就应该对反馈进行优化，确保反馈回路尽可能短，因为这才是合理的工程。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu713fd8b961028a83210edb2affad3583_8912_bacf2ad67ad49d1a5b5060d50e6f4bce.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu713fd8b961028a83210edb2affad3583_8912_7b7060ad5c3f81c7c34036d4186db903.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu713fd8b961028a83210edb2affad3583_8912_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu713fd8b961028a83210edb2affad3583_8912_bacf2ad67ad49d1a5b5060d50e6f4bce.webp&#34;
               width=&#34;177&#34;
               height=&#34;208&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Holly Cummins&lt;/strong&gt; 是 IBM 企业战略部的创新领导者，并在 IBM Garage 担任顾问多年。作为 Garage 的一员，她为各行各业的客户提供技术驱动的创新，从银行业到餐饮业，从零售业到非政府组织。Holly 是 Oracle Java 冠军、IBM Q 大使和 JavaOne Rock Star。她与人合著了 Manning 的《Enterprise OSGi in Action》。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>“寒武纪大爆发” 之后的云原生，2021 年走向何处？</title>
      <link>https://cloudnative.to/blog/cloud-native-2021/</link>
      <pubDate>Thu, 28 Jan 2021 11:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-2021/</guid>
      <description>&lt;p&gt;很荣幸收到 CSDN 的邀请，接受” 云原生人物志 “专栏采访，其实我从 2017 年起就已经在撰写 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/appendix/kubernetes-and-cloud-native-summary-in-2017-and-outlook-for-2018.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 和云原生年度总结和新年展望&lt;/a&gt;，今天在此聊抒己见，欢迎大家讨论和指正。&lt;/p&gt;
&lt;h2 id=&#34;云原生在演进&#34;&gt;云原生在演进&lt;/h2&gt;
&lt;p&gt;云原生是一种行为方式和设计理念，究其本质，凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的。云计算的发展史就是一部云原生化的历史。Kubernetes 开启了云原生 1.0 的序幕，服务网格 Istio 的出现，引领了后 Kubernetes 时代的微服务，serverless 的再次兴起，使得&lt;strong&gt;云原生从基础设施层不断向应用架构层挺进&lt;/strong&gt;，我们正处于一个云原生 2.0 的新时代。&lt;/p&gt;
&lt;h2 id=&#34;业界动向&#34;&gt;业界动向&lt;/h2&gt;
&lt;p&gt;最近国内的一些云厂商，如阿里云、腾讯云、华为云陆续发布了各自的云原生相关的架构和实践白皮书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2020 年 7，中国信通院发布了《云原生产业白皮书（2020）》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 20 日，在腾讯 2020 Techo Park 开发者大会上，腾讯云正式发布了《云原生最佳实践路线图》，同时发布的还有一份 3 万多字的《腾讯云原生路线图手册》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 23 日，阿里云原生实战峰会上发布了《云原生架构白皮书》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 30 日，华为云在深圳的 TechWave 云原生 2.0 技术峰会上联合 Forrester 发布了《云原生白皮书：拥抱云原生优先战略》。&lt;/li&gt;
&lt;li&gt;2021 年初，阿里巴巴达摩院发布 2021 十大科技趋势，其中将 “云原生重塑 IT 技术体系” 作为 2021 年技术预测之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;云原生项目的-寒武纪大爆发&#34;&gt;云原生项目的 “寒武纪大爆发”&lt;/h2&gt;
&lt;p&gt;云原生已历经” 寒武纪大爆发 “，标志是从 2018 年 Kubernetes 毕业 后走向深耕路线。云原生领域的开源项目层出不穷，令人眼花缭乱，见我收集的 Awesome Cloud Native。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk_hu77e1435a9e181e9cc063a70f81a805ab_28410_3815328d645961702b96d217d72198d7.webp 400w,
               /blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk_hu77e1435a9e181e9cc063a70f81a805ab_28410_052d6001ffd15c3ec1906c7aa558020f.webp 760w,
               /blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk_hu77e1435a9e181e9cc063a70f81a805ab_28410_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk_hu77e1435a9e181e9cc063a70f81a805ab_28410_3815328d645961702b96d217d72198d7.webp&#34;
               width=&#34;760&#34;
               height=&#34;184&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;2020 年 CNCF 共接纳了 35 个项目加入基金会，并且有多个项目毕业或晋级，CNCF 托管的项目总数达到了 80 多个。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh_huc75e20abcc0f566c75d569880b55a916_150398_47ea8b577b135390f205a7470af050d3.webp 400w,
               /blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh_huc75e20abcc0f566c75d569880b55a916_150398_356b378adc552b0516d1900c9a0c9900.webp 760w,
               /blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh_huc75e20abcc0f566c75d569880b55a916_150398_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh_huc75e20abcc0f566c75d569880b55a916_150398_47ea8b577b135390f205a7470af050d3.webp&#34;
               width=&#34;760&#34;
               height=&#34;546&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图片来自 CNCF 年度报告 2020&lt;/p&gt;
&lt;h2 id=&#34;云原生之争实际上是标准之争&#34;&gt;云原生之争实际上是标准之争&lt;/h2&gt;
&lt;p&gt;PC 端操作系统 Windows 占据上风，移动端是 iOS 和 Android，服务器端是 Linux，而云计算商用分布式操作系统呢？答案是 Kubernetes。&lt;/p&gt;
&lt;p&gt;2020 年 Kubernete 宣布将&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/110520682&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 v1.20 版本之后弃用 Docker&lt;/a&gt;，实际上 Docker 本来就不是 Kubernetes 中默认和唯一的的容器运行时了，实际上只要是支持 CRI（Container Runtime Interface）或 OCI（Open Container Initiative）标准的容器运行时都可以在 Kubernetes 中运行。如下图所示，容器，英文是 container，也是集装箱的意思，其实集装箱不止一种型号，根据运送的货物的不同特性可以制定了多种集装箱类型。而这个容器类型是标准只能是由 Kubernetes 来定，否则只能是削足适履。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-2021/008eGmZEly1gn38p94t5sj30q90enq52_huc46789bec12c0d58e484ab54335d02f1_88874_4391105d8c4610e70338f82cc779dfab.webp 400w,
               /blog/cloud-native-2021/008eGmZEly1gn38p94t5sj30q90enq52_huc46789bec12c0d58e484ab54335d02f1_88874_d07cd4ab94d9cd1f12935220ca1edd38.webp 760w,
               /blog/cloud-native-2021/008eGmZEly1gn38p94t5sj30q90enq52_huc46789bec12c0d58e484ab54335d02f1_88874_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-2021/008eGmZEly1gn38p94t5sj30q90enq52_huc46789bec12c0d58e484ab54335d02f1_88874_4391105d8c4610e70338f82cc779dfab.webp&#34;
               width=&#34;760&#34;
               height=&#34;424&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes 统一了云上的资源对象制定和调度的标准，只要在其标准之上开发 CRD 和 Operator 即可。但是这也仅限于单个应用的管理，如何管理复杂的多集群和混合云环境，如何管理应用间流量，如何如何保证调用链的安全？以 Istio 为代表的服务网格就是为了解决这个问题。&lt;/p&gt;
&lt;h2 id=&#34;云原生趋势云上应用管理&#34;&gt;云原生趋势：云上应用管理&lt;/h2&gt;
&lt;p&gt;Kubernetes 奠定了云原生基础设施的基础，随着而来的监控、存储、AI、大数据等技术的迁移，从单个应用层面来说已经日趋成熟，而在&lt;strong&gt;使用云原生架构尤其是对云上应用的管理&lt;/strong&gt;，而在异构环境、多集群、混合云等已成为常态的情况下，&lt;strong&gt;如何对云上的应用进行管理，成为棘手的事情&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Kubernetes 以其开创新的声明式 API 和调节器模式，奠定了云原生的基础。我们看到 Google 的项目 Anthos，Azure 的 Arc，AWS 最近开源的 EKS-D，它们都是着重在混合云管理，让云无处不在。另外，服务网格（Service Mesh）经过两年的推广和发酵，将会看到越来越多的应用。&lt;/p&gt;
&lt;h2 id=&#34;云原生与开源社区&#34;&gt;云原生与开源社区&lt;/h2&gt;
&lt;p&gt;目前&lt;strong&gt;企业云原生化转型最缺乏的东西 —— 套路和组合拳&lt;/strong&gt;。对于基础软件，企业往往会选择开源项目并根据自身需求进行改造，而云原生的开源项目又有很多，企业不是没有选择，而是选择太多，以致于无从下手。就像下面教你如何画猫头鹰的示例。我们可以将企业的云原生化的愿景想象成是这只猫头鹰，这些开源项目就像步骤一中圆，你可能想当然的认为只要用了 Kubernetes 就是云原生了，这就像画了两个圆，而剩余部分没有人教你如何完成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y_hu18e77de0aeb9907df74ac42d6b90d8de_36525_d5779855e661c4e22a4a05fa090336db.webp 400w,
               /blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y_hu18e77de0aeb9907df74ac42d6b90d8de_36525_45572d2634a23e99aff269e4631da6e7.webp 760w,
               /blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y_hu18e77de0aeb9907df74ac42d6b90d8de_36525_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y_hu18e77de0aeb9907df74ac42d6b90d8de_36525_d5779855e661c4e22a4a05fa090336db.webp&#34;
               width=&#34;760&#34;
               height=&#34;506&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;开源社区的核心是面向开发者，就是向开发者灌输如何来画好这只 “猫头鹰” 的。开源不意味着免费和做慈善，使用开源也是有代价的。&lt;strong&gt;开源社区存在的意义是平衡开发者、终端用户及供应商之间的共同利益&lt;/strong&gt;，而一个中立的开源社区有利于发挥开源的生态优势。&lt;/p&gt;
&lt;p&gt;近年来随着云原生大热，在美国诞生了大量该领域的初创公司，他们基于 AWS、谷歌云、Azure 等提供各种云原生的解决方案，从每次 KubeCon 的赞助商规模上就可以窥知一二。国内该领域的公司目前还不多，而云原生终端用户社区的公司规模上依然跟国外的公司数量有不小的差距。&lt;/p&gt;
&lt;p&gt;云原生社区就是在这样的背景下于 2020 年初由我发起，开始筹备并在 5 月 12 号正式成立，致力于推广云原生技术，构建开发者生态。云原生社区采取 SIG（特别兴趣小组）和 WG（工作组）的组织形式，基于开源项目和不同的专业领域构建研讨组，与厂商合作定期举办线下 meetup，并邀请社区的专家们定期在 B 站的云原生学院进行直播。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;开源应该关注的是终端用户和开发者生态，用 Apache Way 来说就是 “社区大于代码”，没有社区的项目是难以长久的。因此我们可以看到国内一些云厂商开源项目之后也会积极投入运营，举行各种各样的活动。我们看到在云原生的推广过程中，CNCF 起到的相当大的作用，2020 年国内也有类似的基金会成立，我们希望看到更多中立的基金会和社区的成立，更多的厂商参与其中，为终端用户提供更佳的解决方案。&lt;/p&gt;
&lt;p&gt;最后感谢 CSDN 宋慧编辑和 「CSDN 云计算」的邀请。&lt;/p&gt;
&lt;p&gt;往期报道见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/112293560&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;梁胜：做开源项目的贡献者没有意义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/FL63Zv9Zou86950w/article/details/110433443&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;华为云 CTO 张宇昕：云原生已经进入深水区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/110508201&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;APISIX 温铭：开源的本质是要拿开发者的杠杆&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;个人介绍&#34;&gt;个人介绍&lt;/h2&gt;
&lt;p&gt;在我的职业生涯里先后从事过 Java 开发、大数据运维、DevOps、开源管理等工作，个人爱好是研究并推广开源技术及理念，摄影和旅行。目前在企业级服务网格初创公司 Tetrate 担任 Developer Advocate，同时作为中立的云原生终端用户社区 —— 云原生社区（Cloud Native Community）的负责人。&lt;/p&gt;
&lt;p&gt;我的整个职业生涯都是与开源息息相关的，渊源可以追溯到大学时期。大学时我就开始使用 Linux 系统（Ubuntu）学习，刚进入职场的时候面向的也是 Hadoop 的开源生态及各种开源中间件，2015 起开始接触 Docker，2016 年开始进入云原生领域，2017 年开始写 Kubernetes 领域的第一本开源中文电子书《&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生应用架构实践手册&lt;/a&gt;》，本书直到如今仍在更新，2018 年在蚂蚁集团做开源管理及服务网格社区 ServiceMesher，2020 年加入基于 Istio、Envoy 和 Apache SkyWalking 等开源项目而构建企业级服务网格的初创公司 Tetrate。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生初学者入门必读</title>
      <link>https://cloudnative.to/blog/must-read-for-cloud-native-beginner/</link>
      <pubDate>Fri, 23 Oct 2020 14:18:40 +0800</pubDate>
      <guid>https://cloudnative.to/blog/must-read-for-cloud-native-beginner/</guid>
      <description>&lt;h2 id=&#34;为什么写这篇文章&#34;&gt;为什么写这篇文章&lt;/h2&gt;
&lt;p&gt;看到这个标题后，大家可能会问“都已经 2020 年了，Kubernetes 开源有 6 年时间了，为什么还要写一篇 Kubernetes 入门的文章？”我想说的是，Kubernetes 还远远没有达到我们想象的那么普及。众多的开发者，平时忙于各自的业务开发，学习新技术的时间有限；还有大量的学生群体，可能还仅仅停留在“知道有这门技术”的阶段，远远没有入门。这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。&lt;/p&gt;
&lt;p&gt;因为云原生的知识体系过于庞杂，本文主要讲解容器、Kubernetes 及服务网格的入门概念，关于云原生的更多细节将在后续文章中推出。另外大家也可以关注云原生社区推出的 &lt;a href=&#34;https://github.com/cloudnativeto/cloudnative-knowledge-map&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生知识图谱&lt;/a&gt; 项目，进一步了解云原生。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 一词来自希腊语，意思是“飞行员”或“舵手”。这个名字很贴切，Kubernetes 可以帮助你在波涛汹涌的容器海洋中航行。&lt;/p&gt;
&lt;p&gt;Kubernetes 是做什么的？什么是 Docker？什么是容器编排？Kubernetes 是如何工作和扩展的？你可能还有很多其他的问题，本文将一一为你解答。&lt;/p&gt;
&lt;p&gt;这篇文章适合初学者，尤其是那些工作忙碌，没有办法抽出太多时间来了解 Kubernetes 和云原生的开发者们，希望本文可以帮助你进入 Kubernetes 的世界。&lt;/p&gt;
&lt;p&gt;简而言之，Kubernetes 提供了一个平台或工具来帮助你快速协调或扩展容器化应用，特别是在 &lt;a href=&#34;https://docker.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker&lt;/a&gt; 容器。让我们深入了解一下这些概念。&lt;/p&gt;
&lt;h2 id=&#34;容器和容器化&#34;&gt;容器和容器化&lt;/h2&gt;
&lt;p&gt;那么什么是容器呢？&lt;/p&gt;
&lt;p&gt;要讨论容器化首先要谈到虚拟机 (VM)，顾名思义，虚拟机就是可以远程连接的虚拟服务器，比如 AWS 的 EC2 或阿里云的 ECS。&lt;/p&gt;
&lt;p&gt;接下来，假如你要在虚拟机上运行一个网络应用——包括一个 MySQL 数据库、一个 Vue 前端和一些 Java 库，在 Ubuntu 操作系统 (OS) 上运行。你不用熟悉其中的每一个技术——你只要记住，一个应用程序由各种组件、服务和库组成，它们运行在操作系统上。&lt;/p&gt;
&lt;p&gt;现在，将应用程序打包成一个虚拟机镜像，这个镜像中包括了 Ubuntu 操作系统。这使得虚拟机变得非常笨重——通常有几个 G 的大小。&lt;/p&gt;
&lt;p&gt;虚拟机镜像包含了整个操作系统及所有的库，对应用程序来说，这个镜像过于臃肿，其中大部分组件并没有被应用程序直接调用。如果你需要重新创建、备份或扩展这个应用程序，就需要复制整个环境（虚拟机镜像），在新环境中启动应用通常需要几十秒甚至几分钟时间。如果你想单独升级应用中的某个组件，比如说 Vue 应用，就需要重建整个虚拟机镜像。另外，如果你的两个应用依赖同一个底层镜像，升级底层镜像会同时影响这两个应用，而有时候，你只需要升级其中一个应用的依赖而已。这就是所谓的“依赖陷阱”。&lt;/p&gt;
&lt;p&gt;解决这个问题的办法就是容器。容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）。所以在上面的例子中，Ubuntu 操作系统就是一个单元（容器）。MySQL 数据库是另一个容器，Vue 环境和随之而来的库也是一个容器。&lt;/p&gt;
&lt;p&gt;但是，MySQL 数据库是如何自己“运行”的？数据库本身肯定也要在操作系统上运行吧？没错！&lt;/p&gt;
&lt;p&gt;更高层次的容器，比如 MySQL 容器，实际上会包含必要的库来与底层的操作系统容器通信和集成。所以你可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。&lt;/p&gt;
&lt;p&gt;与容器相关的一个重要概念是&lt;strong&gt;微服务&lt;/strong&gt;。将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。上面的例子中，我们会为 Vue 前端创建一个微服务，为 MySQL 数据库创建另一个微服务，为 Java 中间件部分创建另一个微服务，以此类推。很明显，微服务与容器化是相辅相成的。&lt;/p&gt;
&lt;h2 id=&#34;从-docker-开始&#34;&gt;从 Docker 开始&lt;/h2&gt;
&lt;p&gt;现在你已经对容器有一定了解了吧？Docker 是最常用的容器化工具，也是最流行的容器运行时。&lt;/p&gt;
&lt;p&gt;Docker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macOS 都支持 Docker。&lt;/p&gt;
&lt;p&gt;还有其他的容器化工具，如 &lt;a href=&#34;https://coreos.com/rkt/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CoreOS rkt&lt;/a&gt;、&lt;a href=&#34;http://mesos.apache.org/documentation/latest/mesos-containerizer/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mesos Containerizer&lt;/a&gt; 和 &lt;a href=&#34;https://linuxcontainers.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LXC&lt;/a&gt;。但是目前，绝大多数的容器化应用都是在 Docker 上运行的。&lt;/p&gt;
&lt;h2 id=&#34;再到-kubernetes&#34;&gt;再到 Kubernetes&lt;/h2&gt;
&lt;p&gt;首先，简单介绍一下历史。Kubernetes 是 Google 基于其内部容器调度平台 Borg 的经验开发的。2014 年开源，并作为 CNCF（云原生计算基金会）的核心发起项目。&lt;/p&gt;
&lt;p&gt;那么 Kubernetes 又跟容器是什么关系呢？让我们再回到上面的例子。假设我们的应用爆火，每天的注册用户越来越多。&lt;/p&gt;
&lt;p&gt;现在，我们需要增加后端资源，使浏览我们网站的用户在浏览页面时加载时间不会过长或者超时。最简单的方式就是增加容器的数量，然后使用负载均衡器将传入的负载（以用户请求的形式）分配给容器。&lt;/p&gt;
&lt;p&gt;这样做虽然行之有效，但也只能在用户规模有限的情况下使用。当用户请求达到几十万或几百万时，这种方法也是不可扩展的。你需要管理几十个也许是几百个负载均衡器，这本身就是另一个令人头疼的问题。如果我们想对网站或应用进行任何升级，也会遇到问题，因为负载均衡不会考虑到应用升级的问题。我们需要单独配置每个负载均衡器，然后升级该均衡器所服务的容器。想象一下，当你有 20 个负载均衡器和每周 5 或 6 个小的更新时，你将不得不进行大量的手工劳动。&lt;/p&gt;
&lt;p&gt;我们需要的是一种可以一次性将变更传递给所有受控容器的方法，同时也需要一种可以轻松地调度可用容器的方法，这个过程还必须要是自动化的，这正是 Kubernetes 所做的事情。&lt;/p&gt;
&lt;p&gt;接下来，我们将探讨 Kubernetes 究竟是如何工作的，它的各种组件和服务，以及更多关于如何使用 Kubernetes 来编排、管理和监控容器化环境。为了简单起见，假设我们使用的是 Docker 容器，尽管如前所述，Kubernetes 除了支持 Docker 之外，还支持其他几种容器平台。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-架构和组件&#34;&gt;Kubernetes 架构和组件&lt;/h2&gt;
&lt;p&gt;首先，最重要的是你需要认识到 Kubernetes 利用了“期望状态”原则。就是说，你定义了组件的期望状态，而 Kubernetes 要将它们始终调整到这个状态。&lt;/p&gt;
&lt;p&gt;例如，你想让你的 Web 服务器始终运行在 4 个容器中，以达到负载均衡的目的，你的数据库复制到 3 个不同的容器中，以达到冗余的目的。这就是你想要的状态。如果这 7 个容器中的任何一个出现故障，Kubernetes 引擎会检测到这一点，并自动创建出一个新的容器，以确保维持所需的状态。&lt;/p&gt;
&lt;p&gt;现在我们来定义一些 Kubernetes 的重要组件。&lt;/p&gt;
&lt;p&gt;当你第一次设置 Kubernetes 时，你会创建一个集群。所有其他组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间 (namespace)，它们是同一个物理集群的一部分。这与你可以在同一物理服务器上创建多个虚拟机的方式非常相似。如果你不需要，也没有明确定义的命名空间，那么你的集群将在始终存在的默认命名空间中创建。&lt;/p&gt;
&lt;p&gt;Kubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。&lt;/p&gt;
&lt;p&gt;主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。&lt;/p&gt;
&lt;p&gt;Master 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。&lt;/p&gt;
&lt;p&gt;Woker 节点是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的逻辑而非物理的工作单位称为 pod。一个 pod 类似于 Docker 中的容器。记得我们在前面讲到，容器可以让你创建独立、隔离的工作单元，可以独立运行。但是要创建复杂的应用程序，比如 Web 服务器，你经常需要结合多个容器，然后在一个 pod 中一起运行和管理。这就是 pod 的设计目的——一个 pod 允许你把多个容器，并指定它们如何组合在一起来创建应用程序。而这也进一步明确了 Docker 和 Kubernetes 之间的关系——一个 Kubernetes pod 通常包含一个或多个 Docker 容器，所有的容器都作为一个单元来管理。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的 service 是一组逻辑上的 pod。把一个 service 看成是一个 pod 的逻辑分组，它提供了一个单一的 IP 地址和 DNS 名称，你可以通过它访问服务内的所有 pod。有了服务，就可以非常容易地设置和管理负载均衡，当你需要扩展 Kubernetes pod 时，这对你有很大的帮助，我们很快就会看到。&lt;/p&gt;
&lt;p&gt;ReplicationController 或 ReplicaSet 是 Kubernetes 的另一个关键功能。它是负责实际管理 pod 生命周期的组件——当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubectl&#34;&gt;什么是 Kubectl？&lt;/h2&gt;
&lt;p&gt;kubectl 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-中的自动扩展&#34;&gt;Kubernetes 中的自动扩展&lt;/h2&gt;
&lt;p&gt;请记住，我们使用 Kubernetes 而不是直接使用 Docker 的原因之一，是因为 Kubernetes 能够自动扩展应用实例的数量以满足工作负载的需求。&lt;/p&gt;
&lt;p&gt;自动缩放是通过集群设置来实现的，当服务需求增加时，增加节点数量，当需求减少时，则减少节点数量。但也要记住，节点是 “物理” 结构——我们把“物理”放在引号里，因为要记住，很多时候，它们实际上是虚拟机。&lt;/p&gt;
&lt;p&gt;无论如何，节点是物理机器的事实意味着我们的云平台必须允许 Kubernetes 引擎创建新机器。各种云提供商对 Kubernetes 支持基本都满足这一点。&lt;/p&gt;
&lt;p&gt;我们再继续说一些概念，这次是和网络有关的。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubernetes-ingress-和-egress&#34;&gt;什么是 kubernetes Ingress 和 Egress？&lt;/h2&gt;
&lt;p&gt;外部用户或应用程序与 Kubernetes pod 交互，就像 pod 是一个真正的服务器一样。我们需要设置安全规则允许哪些流量可以进入和离开“服务器”，就像我们为托管应用程序的服务器定义安全规则一样。&lt;/p&gt;
&lt;p&gt;进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 egress。我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 / 流量的地方。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ingress-controller&#34;&gt;什么是 Ingress Controller？&lt;/h2&gt;
&lt;p&gt;但是在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。&lt;/p&gt;
&lt;h2 id=&#34;什么是-replica-和-replicaset&#34;&gt;什么是 Replica 和 ReplicaSet？&lt;/h2&gt;
&lt;p&gt;为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是“让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。&lt;/p&gt;
&lt;p&gt;所需状态是在 deployment 中定义的。 Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。&lt;/p&gt;
&lt;p&gt;因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。&lt;/p&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://jimmysong.io/blog/what-is-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格 (Service Mesh)&lt;/a&gt; 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 &lt;a href=&#34;https://jimmysong.io/blog/post-kubernetes-era/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 次世代的云原生应用&lt;/a&gt; 的重要组成部分。&lt;/p&gt;
&lt;p&gt;服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）——就是 MySQL 数据库、Node.js 前端、负载均衡器等。&lt;/p&gt;
&lt;p&gt;所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更——这些变更对其他容器是完全透明的。&lt;/p&gt;
&lt;p&gt;如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。&lt;/p&gt;
&lt;p&gt;在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。关于服务网格的更多内容请参考 &lt;a href=&#34;https://www.servicemesher.com/istio-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Handbook——Istio 服务网格进阶实战&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在下一部分中，我们将展开更多关于 Kubernetes 的话题：如何开始学习 Kubernetes，如何在本地安装和测试 Kubernetes，以及 Kubernetes 的一些优秀的监控工具。&lt;/p&gt;
&lt;h2 id=&#34;如何学习-kubernetes&#34;&gt;如何学习 Kubernetes？&lt;/h2&gt;
&lt;p&gt;自学 Kubernetes 知识基本上有三种不同的途径，我们在这里只提供了一个指导大纲。&lt;/p&gt;
&lt;h3 id=&#34;一从零开始学习和安装-kubernetes&#34;&gt;一、从零开始学习和安装 Kubernetes&lt;/h3&gt;
&lt;p&gt;要想真正掌握 Kubernetes，最好的办法莫过于自己从头开始安装 Kubernetes。不过要注意的是，从零开始安装 Kubernetes 并不是一件容易的事情。安装 Kubernetes 并不是简单的“下载文件 -&amp;gt; 点击安装”式的操作，Kubernetes 由多个组件组成，这些组件必须单独安装和配置。而在此之前，你也需要相当的技术储备来做安装前的准备，比如熟悉 Linux 操作系统。如果你决定使用这种方式学习的话，推荐你阅读 &lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。此外，请记住，尽管 Kubernetes 作为一个开源解决方案在技术上是免费的，但它确实有一些隐藏的成本，只不过对初学者来说可能并不明显。&lt;/p&gt;
&lt;h3 id=&#34;二kubernetes-自托管解决方案&#34;&gt;二、Kubernetes 自托管解决方案&lt;/h3&gt;
&lt;p&gt;这些解决方案样是一些工具和实用程序，大大简化了在本地计算机上安装和配置小型 Kubernetes 集群的任务。它们是学习 Kubernetes 的好方法，同时对于新手来说也不会太难，又足够小巧可以到安装在个人电脑上。最流行的自托管 Kubernetes 工具和环境是 &lt;a href=&#34;https://github.com/kubernetes/minikube&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Minikube&lt;/a&gt;、&lt;a href=&#34;https://github.com/ubuntu/microk8s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MicroK8s&lt;/a&gt;、&lt;a href=&#34;https://docs.docker.com/docker-for-windows/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Desktop&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/kubernetes-sigs/kind&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kind&lt;/a&gt;。这些解决方案往往有一些限制，例如，Minikube 只允许创建一个节点。尽管有这些缺点，但这些工具还是非常值得推荐，因为它们将易学性和成本效益结合起来，对于刚开始使用 Kubernetes 的初学者来说，是一个很好的选择。&lt;/p&gt;
&lt;h3 id=&#34;三云托管的解决方案&#34;&gt;三、云托管的解决方案&lt;/h3&gt;
&lt;p&gt;如今各大云供应商都提供了定制化的 Kubernetes 解决方案来。你也可以通过线上教学平台如 &lt;a href=&#34;https://katacoda.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Katacoda&lt;/a&gt; 上的免费课程来学习 Kubernetes，它们都是云托管的，你不需要自己安装，只不过你需要云供应商的集群需要付费。&lt;/p&gt;
&lt;h2 id=&#34;本地测试和调试-kubernetes&#34;&gt;本地测试和调试 Kubernetes&lt;/h2&gt;
&lt;p&gt;作为本地安装 Kubernetes 的一部分，你很可能还需要一些测试和调试能力，以确保一切都在顺利运行，特别是定义入口和出口策略等棘手的任务。此外，还有 Kubernetes 附加组件的生态系统，你可能想使用这些组件来扩展 Kubernetes 集群的功能。添加所有这些都需要进行更多的测试，以确保它们能与你的 Kubernetes 集群完美的集成。&lt;/p&gt;
&lt;p&gt;用于在本地开发和调试 Kubernetes 服务的工具有：&lt;a href=&#34;https://github.com/microsoft/mindaro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microsoft Bridge to Kubernetes&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/telepresenceio/telepresence&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;telepresence&lt;/a&gt;。这些工具可以让你在本地运行单个服务，同时将该服务连接到远程 Kubernetes 集群。这样你就可以让自己的本地机器作为 Kubernetes 集群中的一部分来运行——这对于在本地而不是在生产集群上开发服务非常有用。&lt;/p&gt;
&lt;p&gt;Kubernetes 项目也了解到了 Kubernetes 安装对端到端 (E2E) 测试的需求。为此，项目核心团队一直在确保在最近的版本中更恰当地支持 E2E 测试。这包括诸如允许测试重用和纳入更多附加组件和驱动程序的测试等。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-监控工具&#34;&gt;Kubernetes 监控工具&lt;/h2&gt;
&lt;p&gt;Kubernetes 提供了应用程序在集群的每个层次上的资源使用情况的详细信息——容器、pod、服务。这些详细信息使你能够评估应用程序的性能，确定哪些瓶颈可以解决以提高整体性能。&lt;/p&gt;
&lt;p&gt;毕竟，监控可以帮助你了解应用和集群运行情况的详细信息，这对于学习 Kubernetes 是十分有帮助的。&lt;/p&gt;
&lt;p&gt;Kubernetes 包含两个内置度量收集工具用于监控：&lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;资源管道和全度量管道&lt;/a&gt;。资源管道是一个较低级和较有限的工具，主要集中在与各种控制器相关的指标上。全指标管道，顾名思义，从几乎所有集群组件中获取并显示更丰富的指标。&lt;/p&gt;
&lt;p&gt;还有一些第三方工具可以安装并集成到 Kubernetes 集群中。对于 Kubernetes 来说，最普遍使用的两个工具是 Prometheus 和 Grafana。&lt;/p&gt;
&lt;h3 id=&#34;prometheus-监控&#34;&gt;Prometheus 监控&lt;/h3&gt;
&lt;p&gt;Prometheus 是一个功能丰富的开源监控和警报工具。Prometheus 包含一个内部数据存储用来收集指标，如生成的时间序列数据。Prometheus 还拥有众多插件，允许它将数据暴露给各种外部解决方案，并从其他数据源导入数据，包括所有主要公有云监控解决方案。&lt;/p&gt;
&lt;h3 id=&#34;grafana-仪表盘&#34;&gt;Grafana 仪表盘&lt;/h3&gt;
&lt;p&gt;Grafana 是一个优秀的仪表盘、分析和数据可视化工具。它没有 Prometheus 的全功能数据收集能力，但 Prometheus 又没有 Grafana 的数据呈现界面。事实上，他们最好是结合在一起使用——Prometheus 负责数据收集和汇总，Grafana 负责数据展示。它们共同创造了一个强大的组合，涵盖了数据收集、基本警报和可视化。&lt;/p&gt;
&lt;h3 id=&#34;高级警报&#34;&gt;高级警报&lt;/h3&gt;
&lt;p&gt;对于高级警报，你可以添加 &lt;a href=&#34;https://www.nagios.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nagios&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/prometheus/alertmanager&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus Alertmanager&lt;/a&gt; 等工具。这些警报工具通常有大量的集成。你可以为自定义值班团队，然后定义你想要监控的参数，例如“当任何 pod 不可用时”或“当任何节点无法访问时”、“当容量达到 90%”等，然后通过电子邮件、短信、手机应用提醒、电话呼叫等方式向值班人员发送自定义通知。你还可以创建升级策略，比如，如果一个被定义为“危急”的警报在 10 分钟内没有值班人员确认，那么就将警报升级（发送警报）到该人员的经理。&lt;/p&gt;
&lt;p&gt;现在，你应该已经对 Docker 和 Kubernetes 有了大体的认识。了解了 Kubernetes 的作用，知道它是如何进行容器化应用部署和管理的。&lt;/p&gt;
&lt;p&gt;调试和监控技术不仅仅是运维需要，你也可以把它当作学习方式。有什么比边做边学更好呢？&lt;/p&gt;
&lt;p&gt;请记住，如果你的应用规模太小，而且预计用户需求不会有太大变化或重大波动（比如一个只在公司内部使用的应用），那么 Kubernetes 对你来说可能没有必要，这种情况下，直接使用 Docker 就足够了。&lt;/p&gt;
&lt;h2 id=&#34;更多&#34;&gt;更多&lt;/h2&gt;
&lt;p&gt;云原生领域的开源项目众多（见 &lt;a href=&#34;https://jimmysong.io/awesome-cloud-native&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Awesome Cloud Native/云原生开源项目大全&lt;/a&gt;），其中有大量的优秀项目可供我们学习。此外，Kubernetes 开源已经多年时间，网上有大量的学习资料，业界出版过很多 &lt;a href=&#34;https://jimmysong.io/cloud-native/note/books/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;书籍&lt;/a&gt;，建议大家通过阅读 &lt;a href=&#34;https://kubernetes.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt; 和实践来学习，也可以参考我编写的 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;推荐大家加入我发起创办的 &lt;a href=&#34;https://cloudnative.to&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区&lt;/a&gt;，这是一个立足中国，放眼世界的云原生终端用户社区，致力于云原生技术的传播和应用。云原生社区主办的 &lt;a href=&#34;https://github.com/cloudnativeto/academy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生学院&lt;/a&gt; 定期邀请云原生和开源领域的大咖在 B 站上进行直播分享，成员自发组织了多个 SIG（特别兴趣小组）进行讨论学习。欢迎加入我们，共同学习和交流云原生技术。如果你想从事服务网格领域，加入一家由开源技术而构建的全球化公司，欢迎大家关注我所在的服务网格公司 &lt;a href=&#34;https://mp.weixin.qq.com/s/_da1ZgA9-wnT5t_bFuw6AQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>利用 OAM 和 Dapr 的云原生应用的未来</title>
      <link>https://cloudnative.to/blog/the-future-of-cloud-native-applications-with-oam-and-dapr/</link>
      <pubDate>Sun, 26 Jan 2020 10:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/the-future-of-cloud-native-applications-with-oam-and-dapr/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://hugomsbarona.medium.com/the-future-of-cloud-native-applications-with-oam-and-dapr-ed5766c8d583&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Future of Cloud Native Applications With OAM and Dapr&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在2019年11月4日至8日于佛罗里达州奥兰多举办的&lt;a href=&#34;https://www.microsoft.com/en-us/ignite&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2019年微软Ignite大会上&lt;/a&gt;，Azure首席技术官Mark Russinovich介绍了微软开发的两个创新和革命性的项目，旨在解决当今IT专业人士和开发人员在试图构建基于微服务的应用程序时的一系列现有问题。这场会议被命名为《基于开放应用模型（OAM）和分布式应用运行时（Dapr）的云原生应用的未来》。&lt;/p&gt;
&lt;h2 id=&#34;开放式应用模型oam&#34;&gt;开放式应用模型（OAM）&lt;/h2&gt;
&lt;p&gt;因此，其中一个项目与开放应用模型（OAM）有关。它代表了一个开放的标准，允许我们建立云原生应用程序，与平台无关，并遵循关注点分离的原则，通过将应用程序的定义与应用程序的部署和托管基础设施的细节分离，为我们提供一些好处。&lt;/p&gt;
&lt;p&gt;将应用程序的定义与操作细节分开，使应用程序开发人员能够专注于其应用程序的关键要素，并将其从部署地点和方式的操作细节中抽象出来。另外，关注点的分离允许平台架构师开发可重复使用的组件，而应用开发者则专注于将这些组件与他们的代码集成，以快速、轻松地构建可靠的应用。在所有这些方面，OAM在那些有不同角色的场景中特别有用，比如在下面的图片中，构建和管理应用程序，因为它允许你有一个关注点的分离，所以开发和管理你的应用程序的不同角色可以专注于他们任务的关键因素。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用程序开发和部署生命周期中的角色&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用程序开发和部署生命周期中的角色&#34; srcset=&#34;
               /blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tisc22aj30vp0hoq5q_hu0d3de83f9f9eac719806e96f1d883145_113475_641573f7fcd730b3f845020843b0c572.webp 400w,
               /blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tisc22aj30vp0hoq5q_hu0d3de83f9f9eac719806e96f1d883145_113475_651269881847fcb94ada262e6f322dea.webp 760w,
               /blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tisc22aj30vp0hoq5q_hu0d3de83f9f9eac719806e96f1d883145_113475_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tisc22aj30vp0hoq5q_hu0d3de83f9f9eac719806e96f1d883145_113475_641573f7fcd730b3f845020843b0c572.webp&#34;
               width=&#34;760&#34;
               height=&#34;424&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用程序开发和部署生命周期中的角色
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OAM引入了几个概念，组成了你的应用程序。其中一个概念是代表你的应用程序的Component（组件）。这些组件可能是服务，如SQL数据库或带有相应负载均衡器的.NET WebAPI。开发人员可以创建代码，将其打包成一个组件，然后创建清单，描述不同组件和其他应用程序之间的关系。有了这个，你就把组件的实现和这些组件如何在一个完整的分布式应用架构中结合起来的描述分开了。&lt;/p&gt;
&lt;p&gt;为了将这些组件转化为具体的应用程序，应用程序运维使用这些组件的配置来形成一个可以被部署的应用程序的具体实例。配置资源是使应用程序运维能够从开发人员提供的组件中运行一个真正的应用程序。&lt;/p&gt;
&lt;p&gt;最后一个概念是Trait（特征），而你使用它们的集合来描述你的应用环境的特征和它的能力，如自动扩展和入口等等。这些特征允许你根据要求和背景，将你的应用程序部署到具有不同特征的不同环境。然后，这些特征可以由基础设施运维进行配置，以满足其环境的独特操作要求。&lt;/p&gt;
&lt;p&gt;最后但同样重要的是，该规范在设计上是可扩展的。同样，OAM使平台提供者能够通过Trait（特征）系统公开其平台的独特特征，这种方式使应用开发者能够在支持必要特征的地方建立跨平台的应用。&lt;/p&gt;
&lt;h2 id=&#34;分布式应用程序运行时dapr&#34;&gt;分布式应用程序运行时（Dapr）&lt;/h2&gt;
&lt;p&gt;Dapr是一个可移植的、事件驱动的运行时，它使开发人员能够轻松地建立弹性的、无状态和有状态的微服务应用程序，并在云和边缘上运行，并拥抱语言和开发人员框架的多样性。它遵循&lt;strong&gt;Sidecar架构&lt;/strong&gt;，所以它使用一个连接到你的每个组件的Sidecar节点，所以它可以扩展和增强你的应用程序的功能，如服务发现、负载均衡、流量管理等。&lt;/p&gt;
&lt;p&gt;使用这种编程模型，开发人员能够创建微服务应用程序，而不需要携带那么多在构建分布式应用程序过程中引入复杂性的因素，如弹性、可扩展性、服务身份和发现、负载均衡、状态管理等等。Dapr将这些复杂的因素从开发人员那里抽象出来，这样他们就可以专注于他们正在编写的代码。&lt;/p&gt;
&lt;p&gt;Dapr的另一个重要方面是与托管我们应用程序的平台有关。Dapr使我们能够在云端、企业内部、甚至是边缘的多种环境中运行我们的应用程序，包括任何可用于托管应用程序的Kubernetes集群。&lt;/p&gt;
&lt;p&gt;最后，同样重要的是，Dapr允许你利用你最喜欢的编程语言来构建你的分布式应用，并克服你在现今的一些服务中可能面临的编程语言和版本的限制，以构建基于微服务的应用。&lt;/p&gt;
&lt;p&gt;下面的图片提供了一个使用Dapr的微服务应用架构的概述。基本上，你使用你喜欢的编程语言或框架，如Java、Node.js、Python、.NET Core等，构建构成你的应用程序的服务，然后你的服务使用其可用的标准API，并使用HTTP或gRPC协议与Dapr通信。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-使用-dapr-的微服务应用架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;使用 Dapr 的微服务应用架构&#34; srcset=&#34;
               /blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tov7gp1j312w0ie40c_hu9d3847e755d1821c64e7f7bd21768390_78008_f90ba2282b6b06d9c4d479ded35cb01e.webp 400w,
               /blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tov7gp1j312w0ie40c_hu9d3847e755d1821c64e7f7bd21768390_78008_dcdc56b4ec42f1889bde0bd488189a29.webp 760w,
               /blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tov7gp1j312w0ie40c_hu9d3847e755d1821c64e7f7bd21768390_78008_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tov7gp1j312w0ie40c_hu9d3847e755d1821c64e7f7bd21768390_78008_f90ba2282b6b06d9c4d479ded35cb01e.webp&#34;
               width=&#34;760&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      使用 Dapr 的微服务应用架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;因此，我们有OAM，它代表了一种规范，允许你定义和建立跨平台的应用程序，在云和边缘上运行，为你提供关注点的分离，让你的团队专注于他们任务和责任的关键要素。&lt;/p&gt;
&lt;p&gt;然后，我们把Dapr作为一个运行时，通过提供关注点的分离和促进一些影响构建这种应用的复杂性的因素，降低了构建基于微服务的分布式应用的复杂性。此外，Dapr允许应用程序在 &amp;ldquo;云和边缘 &amp;ldquo;计算基础设施之间进行移植，并克服目前开发人员在构建此类应用程序时面临的移植问题。&lt;/p&gt;
&lt;p&gt;如果你想获得与这些项目有关的更多细节，请看以下资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/en-au/resources/videos/ignite-2019-mark-russinovich-presents-the-future-of-cloud-native-applications-with-oam-and-dapr/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mark Russinovich介绍OAM和Dapr的云原生应用的未来&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;开放应用模式（OAM）官方网站 - &lt;a href=&#34;https://oam.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://oam.dev/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;分布式应用程序运行时（Dapr）官方网站 - &lt;a href=&#34;https://dapr.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dapr.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
