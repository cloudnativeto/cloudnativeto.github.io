<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Faas | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/tag/faas/</link>
      <atom:link href="https://cloudnativecn.com/tag/faas/index.xml" rel="self" type="application/rss+xml" />
    <description>Faas</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 09 Apr 2019 22:42:29 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/media/sharing.png</url>
      <title>Faas</title>
      <link>https://cloudnativecn.com/tag/faas/</link>
    </image>
    
    <item>
      <title>选择 FaaS 还是微服务？</title>
      <link>https://cloudnativecn.com/blog/faas-vs-microservices/</link>
      <pubDate>Tue, 09 Apr 2019 22:42:29 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/faas-vs-microservices/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://dzone.com/articles/faas-vs-microservices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在做项目的云原生改造时我们可以采用微服务架构。DevOps 和自动化构建两方面的成功经验对微服务的实践很有帮助。经过一段时间的实践，你可能会有将微服务架构推广到其他部门的想法。而你担心微服务本身的复杂性和分布式系统的高维护成本会让其他部门难以接受它。可能在我们想方设法解决微服务带来的问题时，总会有些人觉得这样做毫无意义。因为现在技术发展如此之快，总会出现更好的技术方案，你能保证自己在微服务领域所做的工作最后没有白费吗？&lt;/p&gt;
&lt;p&gt;我认为不会白费！&lt;/p&gt;
&lt;p&gt;现在“serverless”和“functions-as-a-service”（FAAS）还处于早期的炒作阶段。有些人觉得 serverless 就是下一代的微服务，所以我们应该跳过当前的微服务模式而直接采用 serverless。其实这种说法是有点夸大其词。作为架构师或开发者，我们通过学习新技术来提升自身能力让自己变得更&amp;quot;值钱&amp;quot;并没有错。但我们也要以务实态度来判断是否应该采用新技术。虽然持续跟进最新技术是我们作为架构师的职责所在，但掌握在之前的产品和 IT 部门引用新技术的时机也很重要。我们可以通过下面的模块来理解微服务架构和 serverless，从而让它们可以更好的融入我们的技术栈。&lt;/p&gt;
&lt;p&gt;首先，我们需要知道为什么我们需要微服务。选用微服务架构的主要原因就是避免项目的体量阻碍产品的迭代，所有微服务其他的优势都是基于这点。更快的迭代速度意味着可以更快的为客户交付新功能/修改，从而更快的验证这些改动能够带来的效果。我们需要快速的知道自己所做的努力是否能够带来好的效果，如果不能就要马上调整方向。快速迭代就是微服务架构的核心优势。&lt;/p&gt;
&lt;p&gt;对于大多数的团队而言，至少有一部分应用能从微服务的迭代过程中获益。因此作为架构师或开发者，我们不要因为采用微服务有门槛就对其失去信心。实践微服务的重要步骤就是确定和测量改进指标。改进指标一般可以为每天迭代应用的次数、保证迭代应用稳定性的方法等。&lt;/p&gt;
&lt;p&gt;另一方面，不是所有的应用都需要用这种松散而复杂的方式来保证服务的迭代速度。如果只想简单做个应用来验证自己创意的商业价值，那你完全可以选择更加适合的架构。这时采用 MVP 测试（最小可行性测试）就是个很好的方案。如果你因为商业价值很低而打算放弃的话，那也只是放弃了一个 MVP 应用。你可以非常快的迭代它并从潜在的用户中获得反馈。在这种情况下，你可能需要根据反馈反复修改 API、功能边界、组件等。所以过早就将组件功能做成分布式的服务也会拖慢产品的发布速度。你想修改分布式组件和它的 api 就必须在各个团队间进行协调。&lt;/p&gt;
&lt;p&gt;上述观点能够反映出微服务架构和单体架构适用不同的场景。而事实上并没有所谓&amp;quot;一招鲜吃遍天“的方案。当我们在微服务架构和单体架构之间纠结时，还需要考虑到所需服务是否已经存在以及它提供服务的方式（第三方服务/公司内部服务）。我们完全可以充分利用当前已有服务来构建我们的应用，不必重新购买硬件、安装和修补操作系统，以及优化服务从而达到最高吞吐量，而这也正是云及其服务存在的意义。云供应商和他们的合作伙伴能提供数据库、消息队列、缓存、CDN 和其他更高级的功能：例如语言翻译、地图/地理空间地图、天气等。我们可以组合各种按量付费的服务来构建自己的应用。如果在使用某个服务的时候无需关心安装、参数和容量等问题，其实我们就已经在采用 serverless 架构了。serverless 架构的特点就是可以重用已经存在的 service，而无需关心运行服务需要消耗些什么。&lt;/p&gt;
&lt;p&gt;函数即服务和 serverless 具有某种联系，因为它利用了缩小到单个应用程序函数的范围的计算模型，而这有助于将各种服务组合在一起构建应用。在这种模型下，功能按需分解，你只需为使用的功能付费。它特别适合对我们使用的服务进行按需计费和按量付费。这样一来我们能够构建弹性应用，而不需要考虑复杂的技术问题。将这些复杂的技术问题外包给别人可以让你更专注于为客户提供商业价值。&lt;/p&gt;
&lt;p&gt;但是将这部分能力外包不总是可行的。如果选择云服务，我们就丧失了对程序运行时、具体功能、bug 修复和接受监管的控制力。这也是需要考虑的一部分。&lt;/p&gt;
&lt;p&gt;serverless 不一定是完整的“公有云或无云”方案。如果以单个组织的角度来看，&amp;ldquo;serverless&amp;quot;可能只是代表整个体系的其他部分。例如：零售业务可以为组织内部其他服务或第三方提供“购买“服务以支持诸如分析、推荐以及其他使用“购买”服务的应用。利用定义良好的 API 和订阅并消费 API 的工作负载，你可以在自己的基础设施为微服务应用或单体应用提供 serverless 能力。在很多时候这其实就是服务向 SOA 架构进化的方向。但它们之间最大的不同就是在你将组织看作一个整体时，自己给自己的其他部分提供服务并不算 serverless。因为此时还是需要自己手动的去安装、管理和更新应用。&lt;/p&gt;
&lt;p&gt;最终采用哪种方案其实取决于很多因素，例如：业务、商业目标、软件部门对该技术的熟练度和历史遗留问题等。如果你觉得应该采用微服务架构，那就不要因为其他新技术而分心。我们可以持续跟进最新技术，从而保证适时的采用它们。总的来讲，不管是微服务架构、单体架构还是 serverless 架构，它们都有自己的应用场景。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes 的无服务器框架的评估</title>
      <link>https://cloudnativecn.com/blog/evaluation-of-serverless-frameworks-for-kbe/</link>
      <pubDate>Thu, 08 Nov 2018 13:20:46 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/evaluation-of-serverless-frameworks-for-kbe/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtshzvvdnj20m808ct8v_hu5420353441727717783.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtshzvvdnj20m808ct8v_hu14631969021372761468.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtshzvvdnj20m808ct8v_hu7342748165447370470.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtshzvvdnj20m808ct8v_hu5420353441727717783.webp&#34;
               width=&#34;760&#34;
               height=&#34;285&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://rancher.com/blog/2018/2018-04-23-evaluation-of-serverless-frameworks-for-kbe/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Rancher 1.6 和 Rancher 2.0 底层容器编排引擎的术语和概念略微有所不同。想要了解这些差异就需要先了解 Cattle 和 Kubernetes 之间的根本区别。对于使用过 Cattle 或者 Kubernetes 的新手来说，这篇文章比较适合您。同时你也可以从这里获取到容器编排引擎 Cattle 到 Kubernetes 的对应关系词汇表 cheatsheet。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://rancher.com/tags/serverless&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;无服务器&lt;/a&gt; &lt;a href=&#34;https://rancher.com/tags/kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubernetes&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在 Pokemon Go 的早期，我们都惊讶于 Niantic 如何在全球范围内扩展其用户群，现在看来他们应该是以无缝地向其容器集群添加额外的节点以容纳更多的玩家和环境，所有这一切都可以通过使用 Kubernetes 作为容器编排工具来实现。Kubernetes 在扩展和管理容器基础架构中，能够从开发者角度抽象出部分过程和低级依赖关系。这使它成为一个非常有效的平台，用于开发和维护跨多个容器的应用程序服务。本文将探讨如何利用 K8S 的设计参数和服务编排功能，并将它们与无服务器框架和函数即服务（FaaS）结合起来。特别是，我们将深入研究其特性和功能，分析在 K8s 架构上构建的三个无服务器框架的运行性能和效率：（i）Fission; （ii）OpenFaaS; （iii）Kubeless。&lt;/p&gt;
&lt;h2 id=&#34;a-为什么-kubernetes-是无服务器的优秀编排系统&#34;&gt;A. 为什么 Kubernetes 是无服务器的优秀编排系统？&lt;/h2&gt;
&lt;p&gt;无服务器体系结构指的是从开发人员中抽象出服务器管理任务的应用程序体系结构，并通过动态分配和管理计算资源来提高开发速度和效率。函数即服务（FaaS）是一个运行时被构建的无服务架构，可以在其上构建无服务器体系结构。FaaS 框架作为短暂的容器运行，它们已经安装了公共语言运行时，并允许在这些运行时内执行代码。&lt;/p&gt;
&lt;p&gt;FaaS 框架应该能够在各种基础架构上运行，以实现真正有用，包括公共云，混合云和内部部署环境。在真实生产环境中基于 FaaS 运行时构建的无服务器框架应该能够依靠经过验证和测试的编排和管理功能来大规模部署容器和分布式工作负载。&lt;/p&gt;
&lt;p&gt;对于编排和管理，无服务器 FaaS 框架依赖 Kubernetes，因为它能够：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨主机群集编排容器。&lt;/li&gt;
&lt;li&gt;最大化程度的利用企业应用程序所需的硬件资源。&lt;/li&gt;
&lt;li&gt;管理和自动化应用程序部署并提供声明式更新。&lt;/li&gt;
&lt;li&gt;通过挂载存储运行有状态应用程序。&lt;/li&gt;
&lt;li&gt;秒级扩容容器化应用程序并提供支持它们的资源。&lt;/li&gt;
&lt;li&gt;声明式地管理服务。&lt;/li&gt;
&lt;li&gt;提供一个大盘，来检查应用的健康情况，并通过自动重启，自动复制和自动缩放来进行应用程序的自我修复。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn1842j20ao07idgj_hu7904463815441315927.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn1842j20ao07idgj_hu14470886180623711848.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn1842j20ao07idgj_hu2687682897170354090.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn1842j20ao07idgj_hu7904463815441315927.webp&#34;
               width=&#34;384&#34;
               height=&#34;270&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;无服务器系统可以包括通过客户端请求触发的功能或作为业务服务的一部分执行的功能这两个过程都可以使用容器集群管理器如-kubernetes进行编排资料来源dzonecom&#34;&gt;无服务器系统可以包括通过客户端请求触发的功能或作为业务服务的一部分执行的功能。这两个过程都可以使用容器集群管理器（如 Kubernetes）进行编排。资料来源：dzone.com&lt;/h4&gt;
&lt;p&gt;我们将在本文中介绍三个无服务器框架各自的优点和缺点。这些 FaaS 框架之间的共同点是，它们能够（1）将函数转化为服务; （2）利用 Kubernetes 平台管理这些服务的生命周期。这些框架背后的设计，会由于其用于实现的具体方式的不同而有差异，我们将在下一节中探讨。我们将在以下部分中重点介绍这些框架之间的一些差异：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;框架是在源码级别或 Docker 镜像级别还是在中间运行，例如 buildpacks？&lt;/li&gt;
&lt;li&gt;由于使用公共语言运行库启动容器，冷启动性能的延迟或执行函数期间的延迟分别是多少？&lt;/li&gt;
&lt;li&gt;它们如何为服务分配内存或资源？&lt;/li&gt;
&lt;li&gt;它们如何访问和部署 Kubernetes 的编排和容器管理功能？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;b-openfaas-和部署-spring-boot-模板&#34;&gt;B. OpenFaaS 和部署 Spring Boot 模板&lt;/h2&gt;
&lt;p&gt;OpenFaaS 是一个无服务器平台，允许使用 Docker 或 Kubernetes 管理函数，因为它是基于 OCI 格式的容器。OpenFaaS 可以支持企业级扩展的功能，如 Docker Universal Control Plane 企业级集群管理解决方案与 Docker Enterprise 或 Tectonic for Kubernetes。OpenFaaS 继承了现有的容器安全功能，例如 r/o 文件系统，权限下降和内容信任。它能够使用 Docker 或 K8s 调度程序/容器编排的管理功能，并且可以使用其相关的丰富的商业和社区供应商生态系统。同样，由于其多语言特性，任何可执行文件都可以打包到 OpenFaas 中的函数中。&lt;/p&gt;
&lt;p&gt;SpringBoot 和 Vertx 是开发微服务的非常流行的框架，它们的易用性已经通过 OpenFaaS 模板扩展到 OpenFaaS。这些模板允许在 OpenFaaS 平台上无缝地开发和部署无服务器函数。模板在&lt;a href=&#34;https://github.com/tmobile/faas-java-templates&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;的 github 存储库中可用。让我们来看看如何在 OpenFaaS 平台上部署 SpringBoot 模板。&lt;/p&gt;
&lt;h3 id=&#34;在本地安装-openfaas&#34;&gt;在本地安装 OpenFaaS&lt;/h3&gt;
&lt;h4 id=&#34;在本地计算机上下载和安装模板&#34;&gt;在本地计算机上下载和安装模板&lt;/h4&gt;
&lt;p&gt;我们需要安装和配置 FaaS CLI 以与本地或远程 K8S 或 Docker 配合使用。在本练习中，我们将使用本地 Docker 客户端，并在后续工作中将其扩展到基于云的 GKE 集群。&lt;/p&gt;
&lt;p&gt;对于最新版本的 CLI 类型：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ curl -sL https://cli.openfaas.com | sudo sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;[或通过 MacOS 上的 brew install faas-cli。]&lt;/p&gt;
&lt;p&gt;使用以下命令验证本地安装的模板：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;faas-cli new --list&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在我们创建无服务器函数之前，我们必须在本地计算机上安装这些模板。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; faas-cli template pull https://github.com/tmobile/faas-java-templates.git
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;查看帮助菜单&#34;&gt;查看帮助菜单&lt;/h4&gt;
&lt;p&gt;可以为所有命令调用-help 标志。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ faas-cli --help&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从命令行管理您的 OpenFaaS 功能&lt;/p&gt;
&lt;p&gt;用法： &lt;code&gt;faas-cli&lt;/code&gt; [flags] &lt;code&gt;faas-cli&lt;/code&gt; [command]&lt;/p&gt;
&lt;p&gt;可用命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;build&lt;/code&gt; 构建 OpenFaaS 功能容器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deploy&lt;/code&gt; 部署 OpenFaaS 功能&lt;/p&gt;
&lt;p&gt;&lt;code&gt;help&lt;/code&gt; 有关任何命令的帮助&lt;/p&gt;
&lt;p&gt;&lt;code&gt;push&lt;/code&gt; 将 OpenFaaS 功能推送到远程仓库（Docker Hub）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;remove&lt;/code&gt; 删除已部署的 OpenFaaS 功能&lt;/p&gt;
&lt;p&gt;&lt;code&gt;version&lt;/code&gt; 显示客户端版本信息&lt;/p&gt;
&lt;p&gt;参数： &lt;code&gt;-h&lt;/code&gt;，&lt;code&gt;--help&lt;/code&gt; 帮助 FAAS-CLI &lt;code&gt;-f&lt;/code&gt;，&lt;code&gt;--yaml string&lt;/code&gt; 描述函数的 yaml 文件的路径&lt;/p&gt;
&lt;p&gt;有关命令的更多信息，请使用 &lt;code&gt;faas-cli&lt;/code&gt; [command] &lt;code&gt;--help&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;用已安装的模板创建函数&#34;&gt;用已安装的模板创建函数&lt;/h4&gt;
&lt;p&gt;使用来自Vertx/SpringBoot模板的github存储库中我们感兴趣的函数，我们可以创建一个函数（用我们的函数替换大括号内的文本，我们使用springboot但你可以用vertx模板代替它）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;faas-cli new {function of function} --lang springboot&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用 mvnw，命令是&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;faas-cli new mvnw --lang vertx | springboot 
Folder: mvnw created.
Function created in folder: mvnw 
Stack file written: mvnw.yml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;mvnw.yml 的内容现在可以与 CLI 一起使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果您的群集是远程的或未在 8080 端口上运行 - 请在继续之前在 YAML 文件中对其进行编辑。为我们的函数生成了 handler.java 文件。您可以编辑 pom.xml 文件，并在“build”步骤中安装所有依赖项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;构建函数&#34;&gt;构建函数&lt;/h4&gt;
&lt;p&gt;现在我们已经创建了函数逻辑，我们可以使用 faas cli build 命令构建函数。我们将使用本地 Docker 客户端将该函数构建到 docker 镜像中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ faas-cli build -f mvnw.yml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Building: mvnw.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Clearing temporary build folder: ./build/mvnw/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Preparing ./mvnw/ ./build/mvnw/function
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Building: mvnw with node template. Please wait..
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker build -t mvnw .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Sending build context to Docker daemon  8.704kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Step 1/19 : FROM node:6.11.2-alpine
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; 16566b7ed19e
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Step 19/19 : CMD fwatchdog
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; Running in 53d04c1631aa
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; f5e1266b0d32
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Removing intermediate container 53d04c1631aa
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Successfully built f5e1266b0d32
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Successfully tagged mvnw:latest
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Image: mvnw built.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;推送您的函数可选因为我们正在进行本地安装&#34;&gt;推送您的函数（可选，因为我们正在进行本地安装）&lt;/h4&gt;
&lt;p&gt;为了部署我们的函数，我们将编辑 mvnw.yml 文件并将“image”行设置为 Docker Hub 上适用的用户名，例如：hishamhasan/mvnw。然后我们将再次构建该函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ faas-cli push -f mvnw.yml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Pushing: mvnw to remote repository.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;The push refers to a repository &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;docker.io/hishamhasan/mvnw&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完成此操作后，镜像将被推送到 Docker Hub 或远程 Docker registry，我们可以部署并运行该函数。&lt;/p&gt;
&lt;h4 id=&#34;部署函数&#34;&gt;部署函数&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ faas-cli deploy -f mvnw.yml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Deploying: mvnw.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;No existing service to remove
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Deployed.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;URL: &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;http://localhost:8080/function/mvnw&lt;span class=&#34;o&#34;&gt;](&lt;/span&gt;http://localhost:8080/function/mvnw&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;调用函数&#34;&gt;调用函数&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
$ faas-cli invoke -f mvnw.yml callme
Reading from STDIN - hit (Control + D) to stop.
This is my message

{&amp;#34;status&amp;#34;:&amp;#34;done&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们还可以将命令传递给函数，例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ date | faas-cli invoke -f mvnw.yml mvnw
{&amp;#34;status&amp;#34;:&amp;#34;done&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;在-google-cloud-platform-上安装-openfaas&#34;&gt;在 Google Cloud Platform 上安装 OpenFaaS&lt;/h3&gt;
&lt;p&gt;在使用 OpenFaaS 时，我们不限于任何本地或云基础架构。现在我们已经在本地 Docker 集群中部署了模板，我们可以通过在 GCP 中的 GKE 上设置它来利用 OpenFaaS 的多功能性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个名为的 GCP 项目&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/sdk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在此处&lt;/a&gt; 下载并安装 Google Cloud SDK。安装 SDK 后，运行 gcloud init，然后将默认项目设置为 openfaas。&lt;/li&gt;
&lt;li&gt;使用 gcloud 安装 kubectl： &lt;code&gt;gcloud components install kubectl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;导航到 API Manager&amp;gt;凭据&amp;gt;创建凭据&amp;gt;服务帐户密钥。&lt;/li&gt;
&lt;li&gt;选择 JSON 作为密钥类型。将文件重命名为 json 并将其放在项目中&lt;/li&gt;
&lt;li&gt;添加刚刚在 ComputeEngine&amp;gt; Metadata&amp;gt; SSH Keys 下创建的 SSH 密钥，并使用您的公共 SSH 密钥作为值创建名为 sshKeys 的元数据条目。&lt;/li&gt;
&lt;li&gt;创建一个三节点 Kubernetes 集群，每个节点位于不同的区域中。在&lt;a href=&#34;https://kubernetes.io/docs/concepts/cluster-administration/federation/#selecting-the-right-number-of-clusters&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此处&lt;/a&gt; 阅读 有关群集联合的信息，以了解如何选择每个群集中的群集数和节点数，这些群集可能会根据负载或增长频繁更改。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;k8s_version&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;gcloud container get-server-config --format&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;json &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; jq -r &lt;span class=&#34;s1&#34;&gt;&amp;#39;.validNodeVersions[0]&amp;#39;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gcloud container clusters create demo &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --cluster-version&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;k8s_version&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --zone&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;us-west1-a &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --additional-zones&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;us-west1-b,us-west1-c &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --num-nodes&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --machine-type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;n1-standard-2 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --scopes&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;default,storage-rw
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将默认节点池的大小增加到所需的节点数（在此示例中，我们将按比例增加 3 到 9 个节点）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcloud container clusters resize --size=3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;您可以通过调用此 &lt;a href=&#34;https://cloud.google.com/sdk/gcloud/reference/container/clusters/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;页面中&lt;/a&gt; 所述的合适的 SDK 命令来执行集群管理功能，例如删除集群。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcloud container clusters delete demo -z=us-west1-a&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;完整的管理设置&#34;&gt;完整的管理设置&lt;/h3&gt;
&lt;p&gt;设置 kubectl 的凭据：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcloud container clusters get-credentials demo -z=us-west1-a&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;创建集群管理员用户：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl create clusterrolebinding &lt;span class=&#34;s2&#34;&gt;&amp;#34;cluster-admin-&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;whoami&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--clusterrole&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cluster-admin &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--user&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;gcloud config get-value core/account&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;授予 kubernetes-dashboard 管理员权限（确保在非生产环境中完成）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl create clusterrolebinding &lt;span class=&#34;s2&#34;&gt;&amp;#34;cluster-admin-&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;whoami&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--clusterrole&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cluster-admin &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--user&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;gcloud config get-value core/account&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您可以通过使用 kubectl 反向代理在浏览器（或在 &lt;a href=&#34;http://localhost:9099/ui&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http//localhost:9099/ui&lt;/a&gt; ）上调用 &lt;code&gt;kubectl proxy --port=8080&lt;/code&gt; 和导航到 &lt;a href=&#34;http://localhost:8080/ui&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http//localhost:8080/ui&lt;/a&gt; 来访问 port-8080 上的 kubernetes-dashboard：&lt;a href=&#34;http://localhost:9099/ui&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://localhost:9099/ui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubectl proxy --port=9099 &amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 集群由主节点和节点资源组成 - 主节点协调集群，节点运行应用程序，并通过 Kubernetes API 进行通信。我们使用 OpenFaaS CLI 构建了容器化应用程序并编写了.yml 文件来构建和部署该函数。通过在 Kubernetes 集群中的节点之间部署该函数，我们允许 GKE 分发和调度我们的节点资源。我们的节点已经配置了处理容器操作的工具，可以通过 kubectl CLI。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn3annj20d80apmy6_hu11415281114652771162.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn3annj20d80apmy6_hu4969309593255260382.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn3annj20d80apmy6_hu4256356590883393405.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn3annj20d80apmy6_hu11415281114652771162.webp&#34;
               width=&#34;476&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;资料来源dzonecom&#34;&gt;资料来源：dzone.com&lt;/h4&gt;
&lt;h3 id=&#34;使用基本身份验证部署-openfaas&#34;&gt;使用基本身份验证部署 OpenFaaS。&lt;/h3&gt;
&lt;p&gt;克隆 openfaas-gke 存储库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/tmobile/faas-java-templates.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; openfaas-gke
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建 openfaas 和 openfaas-fn 名称空间以在多租户设置中部署 OpenFaaS 服务：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubectl apply -f ./namespaces.yaml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要在 openfaas 命名空间中部署 OpenFaaS 服务：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubectl apply -f ./openfaas&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这将为 OpenFaaS 网关，FaaS-netesd（K8S 控制器），Prometheus，警报管理器，Nats 和队列工作者提供 K8s pods，部署和服务。&lt;/p&gt;
&lt;p&gt;我们需要在通过设置身份验证在 Internet 上公开 OpenFaaS 之前保护我们的网关。我们可以使用一组凭据创建一个通用的 basic-auth 秘密：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl -n openfaas create secret generic basic-auth &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--from-literal&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;admin &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--from-literal&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;admin
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后我们可以为我们的 OpenFaaS 网关部署 Caddy，它既可以作为反向代理，又可以作为强大的负载均衡器，并支持 WebSocket 连接：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubectl apply -f ./caddy&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后，我们将使用 K8s 服务对象公开的外部 IP 访问 OpenFaaS 网关 UI，并使用我们的凭据访问 http://&amp;lt;EXTERNAL-IP&amp;gt;。我们可以通过运行 kubectl get svc 来获取外部 IP。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;get_gateway_ip&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; kubectl -n openfaas describe service caddy-lb &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep Ingress &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; awk&lt;span class=&#34;s1&#34;&gt;&amp;#39;{ print $NF }&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;until&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;get_gateway_ip&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; sleep1&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; -n &lt;span class=&#34;s2&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;gateway_ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;get_gateway_ip&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;OpenFaaS Gateway IP: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;gateway_ip&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注意：如果外部 IP 地址显示为&lt;pending&gt;，请等待一分钟再次输入相同的命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果您尚未执行上一个练习，请通过调用安装 OpenFaaS CLI。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;curl-sL cli.openfaas.com | sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后使用 CLI，凭据和 K8s 服务公开的外部 IP 登录：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;faas-cli login -u admin -p admin --gateway http://&amp;lt;EXTERNAL-IP&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：（a）您可以通过创建 Ingress 资源，使用 Google Cloud L7 HTTPS 负载均衡器公开 OpenFaaS 网关。您可以在 &lt;a href=&#34;https://cloud.google.com/kubernetes-engine/docs/tutorials/http-balancer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此处&lt;/a&gt; 找到有关创建负载均衡器的详细指南。（b）您可以使用密码创建文本文件，并将该文件与-password-stdin 标志一起使用，以避免在 bash 历史记录中输入密码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;您可以使用先前在上一个练习中发布的镜像并部署无服务器功能&#34;&gt;您可以使用先前在上一个练习中发布的镜像并部署无服务器功能。&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ faas-cli deploy -f mvnw.yml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;deploy 命令在当前目录中查找 mvnw.yml 文件，并部署 openfaas-fn 命名空间中的所有函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：（a）您可以使用 com.openfaas.scale.min 标签设置最小运行 pod 数，并为 autoscaler com.openfaas.scale.max 设置最小副本数。OpenFaaS 的默认设置是每个功能运行一个 pod，并且在负载下最多可扩展到 20 个 pod&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;调用无服务器功能&#34;&gt;调用无服务器功能。&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;faas-cli invoke mvnw--gateway=http://&amp;lt;GATEWAY-IP&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;您可以随时注销&#34;&gt;您可以随时注销：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;faas-cli logout -gateway http://&amp;lt;EXTERNAL-IP&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;c-fission-和部署简单的-http-请求&#34;&gt;C. Fission 和部署简单的 HTTP 请求&lt;/h2&gt;
&lt;p&gt;Fission 是一个无服务器框架，它进一步抽象出容器镜像，并允许仅通过函数在 K8s 上创建 HTTP 服务。Fission 中的容器镜像包含语言运行时，一组常用的依赖项和一个用于函数的动态加载器。可以定制这些图像，例如打包二进制依赖项。Fission 能够通过维护一个正在运行的容器池来优化冷启动开销。当新请求来自客户端应用程序或业务服务时，它会将该函数复制到容器中，动态加载它，并将请求路由到该实例。因此，对于 NodeJS 和 Python 函数，它能够最小化 100 毫秒的冷启动开销。&lt;/p&gt;
&lt;p&gt;通过在源码级别进行操作，Fission 使用户不必处理容器的镜像构建，将镜像推送到注册表，管理注册表凭据，镜像版本控制和其他管理任务。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn7oehj20hs0dcglu_hu10311777757427491641.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn7oehj20hs0dcglu_hu10973092970722510306.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn7oehj20hs0dcglu_hu352298457978439969.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn7oehj20hs0dcglu_hu10311777757427491641.webp&#34;
               width=&#34;640&#34;
               height=&#34;480&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;httpskubernetesioblog201701fission-serverless-functions-as-service-for-kubernetes&#34;&gt;&lt;a href=&#34;https://kubernetes.io/blog/2017/01/fission&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubernetes.io/blog/2017/01/fission&lt;/a&gt;-serverless-functions-as-service-for-kubernetes&lt;/h4&gt;
&lt;p&gt;如上图所示，Fission 被设计为一组微服务，主要组件如下所述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跟踪功能，HTTP 路由，事件触发器和环境镜像的控制器;&lt;/li&gt;
&lt;li&gt;管理空闲环境容器池的池管理器，将函数加载到这些容器中，并定期杀死函数实例以管理容器开销;&lt;/li&gt;
&lt;li&gt;一种路由器，它接收 HTTP 请求并将它们路由到 poolmgr 或已在运行的实例中的新鲜函数实例。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以使用在上一个练习中 GCP 上创建的 K8s 群集在 Fission 上部署 HTTP 请求。让我们走过这个过程吧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装 Helm CLI，Helm 是一个 Kubernetes 包管理器。让我们初始化 Helm：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ helm init
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 GKE 命名空间中安装 Fission&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ helm install --namespace fission https://github.com/fission/fission/releases/download/0.7.0/fission-all-0.7.0.tgz
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 Fission CLI&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSX&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl -Lo fission https://github.com/fission/fission/releases/download/0.7.0/fission-cli-osx&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; chmod +x fission &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo mv fission /usr/local/bin/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt; 在 &lt;a href=&#34;https://github.com/fission/fission/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此处&lt;/a&gt; 下载 Windows 可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 HTTP 服务我们将创建一个简单的 HTTP 服务来打印 Hello World。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat &amp;gt; hello.py
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;def main&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;context&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    print &lt;span class=&#34;s2&#34;&gt;&amp;#34;Hello, world!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Fission 上部署 HTTP 服务&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ fission &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; create --name hello --env python --code hello.py --route /hello
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl http://&amp;lt;fission router&amp;gt;/hello
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Hello, world!
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;d-kubeless-和部署-spring-boot-模板&#34;&gt;D. Kubeless 和部署 Spring Boot 模板&lt;/h2&gt;
&lt;p&gt;Kubeless 是一个 Kubernetes 原生无服务器框架，可以将功能部署在 K8s 集群上，同时允许用户利用 Kubernetes 资源提供自动扩展，API 路由，监控和故障排除。Kubeless 使用 Kubernetes 自定义资源定义来创建自定义 kubernetes 资源的功能。自定义资源是 &lt;a href=&#34;https://kubernetes.io/docs/reference/api-overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes API&lt;/a&gt; 中的端点，用于存储&lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 对象&lt;/a&gt;的集合某种类型的 K8s pod 对象，它代表了特定 K8s 安装的自定义。自定义资源非常有用，因为它们可以通过动态注册进行配置然后在正在运行的集群中删除，集群管理员可以独立于集群本身更新自定义资源。Kubeless 利用这些功能并运行集群内控制器，可以跟踪这些自定义资源并按需启动运行时。&lt;/p&gt;
&lt;p&gt;我们可以使用在上一个练习中 GCP 上创建的 K8s 群集在 Fission 上部署 HTTP 请求。让我们走过这个过程吧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;访问 Kubernetes 仪表板&lt;/p&gt;
&lt;p&gt;在 K8s 集群正在运行的情况下，我们可以使用 kubectl 在 8080 端口上使用仪表板：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubectl proxy --port=8080&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsjw13nsj218g0jrq81_hu8146819199494895755.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsjw13nsj218g0jrq81_hu6554973127486725531.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsjw13nsj218g0jrq81_hu762937371751097118.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsjw13nsj218g0jrq81_hu8146819199494895755.webp&#34;
               width=&#34;760&#34;
               height=&#34;337&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以通过浏览器导航到&lt;a href=&#34;http://localhost8080/ui&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://localhost8080/i&lt;/a&gt;来访问仪表板&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 Kubeless CLI&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSX&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl -L https://github.com/kubeless/kubeless/releases/download/0.0.20/kubeless_darwin-amd64.zip &amp;gt; kubeless.zip
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ unzip kubeless.zip
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo cp bundles/kubeless_darwin-amd64/kubeless /usr/local/bin/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://github.com/kubeless/kubeless/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此处&lt;/a&gt; 下载 Windows 可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 K8s 群集中部署 Kubeless&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug1ieuj20jr0c3dgl_hu9945609035800016656.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug1ieuj20jr0c3dgl_hu8312316010963278602.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug1ieuj20jr0c3dgl_hu5755865410993365687.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug1ieuj20jr0c3dgl_hu9945609035800016656.webp&#34;
               width=&#34;711&#34;
               height=&#34;435&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们将使用此&lt;a href=&#34;https://github.com/kubeless/kubeless/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;链接中&lt;/a&gt; 的清单在 K8s 群集中部署 Kubless。根据清单创建一个 kubeless 命名空间，一个函数 ThirdPartyResource，一个 kubeless 控制器，并在进程中设置一个 kafka，zookeeper StatefulSet。Kubless 的一个主要优点是它具有高度的 Kubernetes 原生特性，它可以设置非 rbac 和 rbac 特定环境。下面的屏幕截图显示了如何使用 kubectl 命令在非 rbac 环境中部署 kubeless。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug4tx0j20hr05bwew_hu77309699975000167.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug4tx0j20hr05bwew_hu3891028060046040854.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug4tx0j20hr05bwew_hu13782409559035292937.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug4tx0j20hr05bwew_hu77309699975000167.webp&#34;
               width=&#34;639&#34;
               height=&#34;191&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建函数&lt;/p&gt;
&lt;p&gt;我们可以创建一个服务函数，并从请求中接受方法，URL，标题和请求体。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;const &lt;span class=&#34;nv&#34;&gt;http&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; require&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;http&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    http.createServer&lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;request, response&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      const &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; headers, method, url &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; request&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nb&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      request.on&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;error&amp;#39;&lt;/span&gt;, &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;err&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        console.error&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;err&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;.on&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;, &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;chunk&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        body.push&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;chunk&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;.on&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;, &lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nv&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; Buffer.concat&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;body&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;.toString&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // 此时，我们有标题，方法，网址和请求体，现在可以做任何我们需要的事情来回应这个要求。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;.listen&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;8080&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; // 激活此服务器，监听 &lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt; 端口。
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Kubeless 环境中运行函数&lt;/p&gt;
&lt;p&gt;我们可以通过提供以下信息向 Kubeless 注册该函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用于通过 Web 访问该函数的名称&lt;/li&gt;
&lt;li&gt;用于访问该函数的协议&lt;/li&gt;
&lt;li&gt;要执行以运行代码的语言运行时&lt;/li&gt;
&lt;li&gt;包含函数代码的文件的名称&lt;/li&gt;
&lt;li&gt;文件内部函数的名称&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过添加上面的变量 1-5，我们调用以下命令在 Kubeless 中注册和部署函数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt; kubeless function deploy serverequest--trigger-http --runtime nodejs6 --handler serverequest.createServer --from-file /tmp/serverequest.js&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;e无服务器平台的评估&#34;&gt;E.无服务器平台的评估&lt;/h2&gt;
&lt;p&gt;我们评估的每个无服务器平台都有其独特的价值主张。使用 OpenFaas，任何进程或容器都可以打包为 Linux 或 Windows 的无服务器功能。对于企业而言，OpenFaaS 使用的体系结构提供了无缝插入计划群集和现有微服务的 CI/CD 工作流的能力，因为 OpenFaaS 是围绕 Docker 构建的，所有功能都打包到 Docker 镜像中。OpenFaaS 还为企业提供了一种通过外部 API，网关管理和执行函数的无缝方式，并管理函数的生命周期，包括通过提供商进行部署，扩展和 secret 管理。&lt;/p&gt;
&lt;p&gt;Fission 具有事件驱动架构，使其成为短期无状态应用程序的理想选择，包括 REST API 或 webhook 实现以及 DevOps 自动化。使用 Fission 的一个很好的用例可能是开发聊天机器人的后端，因为 Fission 可以实现良好的冷启动性能，并在需要时通过保持运行时的容器池来提供快速响应时间。&lt;/p&gt;
&lt;p&gt;最后，Kubeless 架构利用原生 Kubernetes 概念来部署和管理功能，例如自定义资源定义，用于定义功能和自定义控制器来管理函数，将其部署为 Kubernetes 部署并通过 Kubernetes 服务公开它。与 Kubernetes 原生功能的紧密结合将吸引现有的 Kubernetes 用户，降低所需的学习曲线并无缝插入现有的 Kubernetes 架构。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-hisham&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Hisham&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn5g0oj206y06y74m_hu4279035181160486482.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn5g0oj206y06y74m_hu15762099948745350220.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn5g0oj206y06y74m_hu8493447471109812705.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn5g0oj206y06y74m_hu4279035181160486482.webp&#34;
               width=&#34;250&#34;
               height=&#34;250&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Hisham
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Hisham 是一位咨询企业解决方案架构师，在利用容器技术解决基础架构问题和更快地部署应用程序以及更高级别的安全性，性能和可靠性方面拥有丰富的经验 最近，Hisham 一直在为各种中间件应用程序利用容器和云原生架构，以在整个企业中部署复杂的关键任务服务。在进入咨询领域之前，Hisham 曾在 Aon Hewitt，Lexmark 和 ADP 从事软件实施和技术支持工作。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
