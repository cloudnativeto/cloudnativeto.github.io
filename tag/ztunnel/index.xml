<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ztunnel | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/tag/ztunnel/</link>
      <atom:link href="https://cloudnativecn.com/tag/ztunnel/index.xml" rel="self" type="application/rss+xml" />
    <description>Ztunnel</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 24 Apr 2025 18:09:59 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/media/sharing.png</url>
      <title>Ztunnel</title>
      <link>https://cloudnativecn.com/tag/ztunnel/</link>
    </image>
    
    <item>
      <title>Ambient Mesh 中的授权策略指南</title>
      <link>https://cloudnativecn.com/blog/ambient-mesh-authorization-policy/</link>
      <pubDate>Thu, 24 Apr 2025 18:09:59 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/ambient-mesh-authorization-policy/</guid>
      <description>&lt;p&gt;服务网格最受欢迎的功能之一，就是能够对网络流量强制执行访问控制策略。由于所有流量都经过代理服务器，因此你可以确保没有人能够绕过某个强制点直接访问服务，而且这些强制点可以位于每个服务前，而不是仅在网络边缘。&lt;/p&gt;
&lt;p&gt;与传统的防火墙或 Kubernetes 的 NetworkPolicy 功能不同，服务网格还可以访问应用层（第七层，L7）信息，例如请求是 HTTP 的 GET 还是 POST，以及请求中携带的 cookie 中的用户身份。&lt;/p&gt;
&lt;p&gt;Ambient Mesh（由 Istio 的 Ambient 模式和 Gloo Mesh 实现）极大地简化了服务网格的交付方式，并显著降低了成本。它的做法是&lt;a href=&#34;https://ambientmesh.io/docs/about/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;将 L4 和 L7 的处理拆分为两个不同的代理组件&lt;/a&gt;。但这也意味着我们必须改变对访问控制的默认假设：我们不再默认每个工作负载前都有一个 L7 感知的强制执行点。好消息是，大多数情况下我们并不需要它，如果确实需要，也可以按需部署，仅作用于需要保护的工作负载。&lt;/p&gt;
&lt;h3 id=&#34;ambient-mesh-中的身份认证与授权&#34;&gt;Ambient Mesh 中的身份认证与授权&lt;/h3&gt;
&lt;p&gt;运行在服务网格中的每个工作负载都有一个基于命名空间和 ServiceAccount 的身份。这些身份在网格内会被自动验证：这是 mTLS 提供的特性，Ambient 模式默认启用 mTLS。&lt;/p&gt;
&lt;p&gt;我们使用 &lt;code&gt;AuthorizationPolicy&lt;/code&gt; 来控制流量。此类策略指定网格中的目标，并包含规则，用于基于来源（from）、操作（to）以及条件（when）来允许或拒绝访问。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ztunnel&lt;/code&gt; 代理始终可以强制执行策略，但它只了解 L3/L4 层的信息（如主机与端口）；而 &lt;code&gt;waypoint&lt;/code&gt; 代理还可感知 L7 信息（如路径与方法），但不是默认部署的。为了兼顾 Ambient 模式的优势与安全性，我们需要为这两类代理分别定义不同粒度的策略。幸运的是，这并不复杂。&lt;/p&gt;
&lt;h3 id=&#34;两类不同的授权策略&#34;&gt;两类不同的授权策略&lt;/h3&gt;
&lt;p&gt;考虑某个部署在 Ambient Mesh 中的工作负载，没有使用 Waypoint。这时策略只能在服务端的 ztunnel 上强制执行。而 ztunnel 无法识别 L7 信息，因此只能强制 L4 层的策略。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ambient-mesh-authorization-policy/f1_hu_f3f250e26fe4f503.webp 400w,
               /blog/ambient-mesh-authorization-policy/f1_hu_47cda3e656a287dc.webp 760w,
               /blog/ambient-mesh-authorization-policy/f1_hu_77fdf6cb978db31a.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ambient-mesh-authorization-policy/f1_hu_f3f250e26fe4f503.webp&#34;
               width=&#34;760&#34;
               height=&#34;316&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当你为该工作负载&lt;a href=&#34;https://ambientmesh.io/docs/setup/configure-waypoints/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;引入 Waypoint&lt;/a&gt; 时，策略就可以在两个位置被执行：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ambient-mesh-authorization-policy/f2_hu_42b4867cc14f936e.webp 400w,
               /blog/ambient-mesh-authorization-policy/f2_hu_ee3f68c15aa45293.webp 760w,
               /blog/ambient-mesh-authorization-policy/f2_hu_26d72b1a87811898.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ambient-mesh-authorization-policy/f2_hu_42b4867cc14f936e.webp&#34;
               width=&#34;760&#34;
               height=&#34;316&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当系统存在多个策略执行点时，应该&lt;strong&gt;始终在最早的执行点&lt;/strong&gt;上应用策略。&lt;/p&gt;
&lt;p&gt;例如，若将所有策略都设置在 Waypoint 上，则直接访问工作负载的流量将绕过策略。而对于公开访问的服务，策略可能已在网关处执行。为了避免重复处理，&lt;a href=&#34;https://ambientmesh.io/docs/traffic/gateways/#gateways-and-waypoints&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;默认情况下 Gateway 会直接将流量转发给服务&lt;/a&gt;，绕过 Waypoint。&lt;/p&gt;
&lt;p&gt;因此，推荐的做法是：在 ztunnel 上定义“基础设施策略”，强制使用 Waypoint，然后在 Waypoint 或 Gateway 上定义“应用层策略”。&lt;/p&gt;
&lt;h3 id=&#34;策略的作用目标与绑定&#34;&gt;策略的作用目标与绑定&lt;/h3&gt;
&lt;p&gt;上面的示意图未涉及实际场景中工作负载与 waypoint 实例的多副本情况。我们在写策略时，需要明确它的作用目标：即它是对哪个服务或工作负载生效。&lt;/p&gt;
&lt;p&gt;Istio 会自动将策略绑定到正确的代理上：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ambient-mesh-authorization-policy/f3_hu_72aaf51948e34e94.webp 400w,
               /blog/ambient-mesh-authorization-policy/f3_hu_bc5544521b8c41dc.webp 760w,
               /blog/ambient-mesh-authorization-policy/f3_hu_e1317dbbf2760728.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ambient-mesh-authorization-policy/f3_hu_72aaf51948e34e94.webp&#34;
               width=&#34;760&#34;
               height=&#34;431&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果策略由 ztunnel 执行，你可以通过指定 &lt;code&gt;AuthorizationPolicy&lt;/code&gt; 所在的 namespace 和 label selector 选择其作用的工作负载。这类似于 Kubernetes 的 NetworkPolicy，或 Istio sidecar 模式下的策略绑定方式：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;应用对象&lt;/th&gt;
          &lt;th&gt;Namespace&lt;/th&gt;
          &lt;th&gt;Selector&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;网格中所有工作负载&lt;/td&gt;
          &lt;td&gt;istio-system&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;default 命名空间下的所有工作负载&lt;/td&gt;
          &lt;td&gt;default&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;匹配特定标签的工作负载&lt;/td&gt;
          &lt;td&gt;任意命名空间&lt;/td&gt;
          &lt;td&gt;matchLabels&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;而 Waypoint 使用 Kubernetes Gateway API 配置，策略通过 &lt;code&gt;targetRefs&lt;/code&gt; 字段&lt;a href=&#34;https://ambientmesh.io/docs/setup/configure-waypoints/#attach-policies-and-routes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;绑定到 Gateway&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么 Waypoint 使用不同的绑定方式？&lt;/strong&gt;
使用不同的绑定方式可以明确区分不同层级的策略含义，而 &lt;code&gt;targetRefs&lt;/code&gt; 遵循了 Kubernetes Gateway API 的语义。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;请注意，我们并未直接使用“L4 策略”或“L7 策略”的说法，因为 Waypoint 也可以执行 L4 策略。后文将说明为什么你可能希望这么做。&lt;/p&gt;
&lt;h3 id=&#34;访问控制的基础&#34;&gt;访问控制的基础&lt;/h3&gt;
&lt;p&gt;如果某个工作负载没有配置任何授权策略，则默认允许所有访问。一旦存在至少一个包含 &lt;code&gt;ALLOW&lt;/code&gt; 操作的策略，则&lt;strong&gt;所有未匹配任何 &lt;code&gt;ALLOW&lt;/code&gt; 的流量都会被拒绝&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这点非常重要。例如，你允许来自 Gateway 的流量访问某工作负载，后来引入了 Waypoint，则来自 Waypoint 的流量将会被拒绝，除非你更新策略。&lt;/p&gt;
&lt;h3 id=&#34;使用-ztunnel-强制执行策略&#34;&gt;使用 ztunnel 强制执行策略&lt;/h3&gt;
&lt;p&gt;在很多场景下，不部署 Waypoint，仅使用 Ambient Mesh 的 &lt;em&gt;安全叠加层（secure overlay layer）&lt;/em&gt; 是合理的选择。Istio 的 L4 属性（IP、端口、命名空间、身份主体）即可用于授权策略。&lt;/p&gt;
&lt;p&gt;这使得我们能实现最小权限的微分段：即仅允许必要的服务之间互相通信。当某个服务被攻破时，攻击流量也会携带其真实身份。例如，图像处理服务无权访问支付服务后端，可以轻松通过策略限制这种访问。&lt;/p&gt;
&lt;h3 id=&#34;非法策略属性与拒绝流量&#34;&gt;非法策略属性与拒绝流量&lt;/h3&gt;
&lt;p&gt;前面提到，L4 策略属性可以用于 ztunnel 绑定的策略。你甚至可以复用 Istio sidecar 模式下的策略到 ambient 模式中，其中可能包含 L7 属性（如 HTTP 方法或路径）。但由于 ztunnel 无法识别 L7 属性，会发生什么呢？&lt;/p&gt;
&lt;p&gt;简而言之：&lt;strong&gt;ztunnel 会安全失败（fail-safe）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于包含 L7 属性的 &lt;code&gt;DENY&lt;/code&gt; 策略：忽略 L7 部分，仅保留其余部分。&lt;/li&gt;
&lt;li&gt;对于包含 L7 属性的 &lt;code&gt;ALLOW&lt;/code&gt; 策略：L7 匹配规则会被移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样做的结果比原策略更严格。因为只要有 &lt;code&gt;ALLOW&lt;/code&gt; 策略存在，未被匹配的流量就会被默认拒绝。所以最终结果是，所有流量都匹配默认拒绝规则。&lt;/p&gt;
&lt;h3 id=&#34;引入-waypoint-的策略执行&#34;&gt;引入 Waypoint 的策略执行&lt;/h3&gt;
&lt;p&gt;绑定在 Waypoint 与 ztunnel 上的策略存在两个主要区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;targetRefs&lt;/code&gt; 替代 selector；&lt;/li&gt;
&lt;li&gt;支持 L7 属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你将某个工作负载配置为使用 Waypoint 后，它就成为了该工作负载最合适的策略执行位置，即使仅是执行 L4 策略。原因在于 Ambient 模式下的身份工作机制：&lt;/p&gt;
&lt;p&gt;工作负载间的 mTLS 通信是由两端的 ztunnel 管理的：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ambient-mesh-authorization-policy/f4_hu_b31bb5181e403d4f.webp 400w,
               /blog/ambient-mesh-authorization-policy/f4_hu_b9a8b9e01cea2b70.webp 760w,
               /blog/ambient-mesh-authorization-policy/f4_hu_5ef274a3335ee58a.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ambient-mesh-authorization-policy/f4_hu_b31bb5181e403d4f.webp&#34;
               width=&#34;760&#34;
               height=&#34;161&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了让 Waypoint 能够解密和检查流量，它必须终止原有的 mTLS，重新发起一次连接：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ambient-mesh-authorization-policy/f5_hu_bddfcbe26157fcf.webp 400w,
               /blog/ambient-mesh-authorization-policy/f5_hu_393ba6007e31457f.webp 760w,
               /blog/ambient-mesh-authorization-policy/f5_hu_800904b04429a1ce.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ambient-mesh-authorization-policy/f5_hu_bddfcbe26157fcf.webp&#34;
               width=&#34;760&#34;
               height=&#34;161&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这意味着，服务器端 ztunnel 所见到的源身份是 &lt;strong&gt;Waypoint 的身份&lt;/strong&gt;，而非原始客户端。如果你希望根据真实源身份做出策略判断，策略应部署在 Waypoint 上。&lt;/p&gt;
&lt;h3 id=&#34;只允许来自-waypoint-的连接&#34;&gt;只允许来自 Waypoint 的连接&lt;/h3&gt;
&lt;p&gt;为了确保策略真正通过 Waypoint 执行，必须防止流量绕过 Waypoint。默认情况下，Ambient Mesh 会自动将服务流量路由到 Waypoint，但服务端的 ztunnel 仍接受来自任何客户端的连接。&lt;/p&gt;
&lt;p&gt;某些场景下这没问题，比如 Prometheus 采集某个 Pod 的 metrics，通常是直接连接，而不经过 Waypoint。&lt;/p&gt;
&lt;p&gt;若你需要阻止其他流量，应在 ztunnel 上定义策略，只&lt;a href=&#34;https://ambientmesh.io/docs/security/waypoint-authz/#restricting-workloads-to-only-accept-traffic-from-waypoints&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;允许来自指定 Waypoint 的连接&lt;/a&gt;。必要时可&lt;a href=&#34;https://ambientmesh.io/docs/security/waypoint-authz/#exceptions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;添加例外&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Istio 社区公布 ztunnel 安全审计结果，零信任通道通过严格考验</title>
      <link>https://cloudnativecn.com/blog/ztunnel-security-audit/</link>
      <pubDate>Mon, 21 Apr 2025 10:31:26 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/ztunnel-security-audit/</guid>
      <description>&lt;p&gt;近日，Istio 项目安全工作组正式发布了其 Ambient 模式核心组件 &lt;a href=&#34;https://istio.io/latest/blog/2025/ztunnel-security-assessment/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ztunnel 的安全审计报告&lt;/a&gt;，结果令人振奋：&lt;strong&gt;代码未发现任何漏洞，审计结果为“高度可信”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;ztunnel 是 Istio 在 Ambient 模式下用于构建零信任网络的新型轻量级数据平面组件，由 Rust 编写，旨在提供更高性能、更易部署的 L4 连接安全能力。此前，Istio 已展示了 ztunnel 在性能方面的卓越表现，&lt;strong&gt;其 TCP 吞吐量甚至超过内核级方案 IPsec 和 WireGuard&lt;/strong&gt;，并在过去四个版本中性能提升高达 75%。而本次安全审计，则进一步印证了其在安全性方面的可用性与稳定性。&lt;/p&gt;
&lt;h2 id=&#34;三方审计机构确认代码安全可靠&#34;&gt;三方审计机构确认代码安全可靠&lt;/h2&gt;
&lt;p&gt;此次审计由知名安全公司 &lt;a href=&#34;https://www.trailofbits.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Trail of Bits&lt;/a&gt; 执行，审计内容覆盖了 ztunnel 的 L4 授权、TLS 传输安全、证书管理、入站代理等关键路径。值得注意的是，此次审计聚焦于 Ambient 模式中新引入的 Rust 代码，并未重复审查已接受过多次审计的 Envoy 本体部分。&lt;/p&gt;
&lt;p&gt;审计报告明确指出：&lt;strong&gt;“ztunnel 代码结构良好，未发现任何漏洞。”&lt;/strong&gt; 三项审计意见中，仅有一项中等级别问题，其他为信息类建议，且均与依赖项管理和测试策略相关。&lt;/p&gt;
&lt;p&gt;本次审计工作由 &lt;a href=&#34;https://www.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 基金会&lt;/a&gt; 提供资助，&lt;a href=&#34;https://ostif.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OSTIF&lt;/a&gt; 协调执行。这也体现出 Istio 社区在安全方面的开放态度和持续投入。&lt;/p&gt;
&lt;h2 id=&#34;安全建议与改进措施&#34;&gt;安全建议与改进措施&lt;/h2&gt;
&lt;h3 id=&#34;引入自动化依赖管理工具&#34;&gt;引入自动化依赖管理工具&lt;/h3&gt;
&lt;p&gt;审计期间，ztunnel 的依赖项中存在三项已知安全通报的库版本，尽管不会直接触发漏洞，但社区仍采取主动响应，&lt;strong&gt;引入 GitHub Dependabot 自动更新依赖项&lt;/strong&gt;，并替换了两项维护状态不佳的 Rust crates。&lt;/p&gt;
&lt;h3 id=&#34;加强异常路径测试覆盖&#34;&gt;加强异常路径测试覆盖&lt;/h3&gt;
&lt;p&gt;Trail of Bits 指出部分异常处理路径未涵盖在现有测试中。Istio 社区回应称，这些路径多为非关键逻辑，如日志行为或性能路径，&lt;strong&gt;将通过 mutation testing 与新型测试机制持续完善测试覆盖&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;自研-header-解析器提升健壮性&#34;&gt;自研 Header 解析器提升健壮性&lt;/h3&gt;
&lt;p&gt;ztunnel 原先使用的 HTTP &lt;code&gt;Forwarded&lt;/code&gt; header 解析库未经过 fuzz 测试。社区为此 &lt;strong&gt;专门开发了定制化解析器，并引入 fuzzing 测试机制&lt;/strong&gt;，确保 Header 解析的安全性与稳定性。&lt;/p&gt;
&lt;h2 id=&#34;云原生服务网格迈入更安全的未来&#34;&gt;云原生服务网格迈入更安全的未来&lt;/h2&gt;
&lt;p&gt;ztunnel 是 Istio 社区拥抱 Rust 安全生态、构建可插拔数据面架构的重要一步。其简化的部署模式、卓越的性能表现，以及经受审计验证的安全性，正在为 Istio Ambient 模式铺设坚实的技术基础。&lt;/p&gt;
&lt;p&gt;随着社区对零信任架构、性能优化、安全可观测等维度的持续打磨，&lt;strong&gt;ztunnel 将成为 Kubernetes 云原生网络中值得信赖的通用安全入口组件&lt;/strong&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无需 Kubernetes 测试 Kubernetes 网络实现</title>
      <link>https://cloudnativecn.com/blog/ztunnel-testing/</link>
      <pubDate>Mon, 22 Jul 2024 18:46:32 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/ztunnel-testing/</guid>
      <description>&lt;p&gt;由于在开发过程中我&lt;a href=&#34;https://blog.howardjohn.info/posts/ideal-ci/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;真的不喜欢等待&lt;/a&gt;，所以在构建 Ztunnel（一个为 Istio 的新&lt;a href=&#34;https://istio.io/latest/blog/2022/introducing-ambient-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambient 模式&lt;/a&gt;设计的底层网络代理）时，我的首要任务之一便是确保测试的快速进行（包括运行和编写测试），并且易于调试。&lt;/p&gt;
&lt;p&gt;这一任务颇为棘手，因为在大多数真实场景中，Ztunnel 高度依赖 Kubernetes。虽然它能够完全独立于 Kubernetes 运行，但许多关键代码路径的行为完全不同，使得仅通过这种方式进行测试变得不可行。&lt;/p&gt;
&lt;p&gt;下图为典型的 Ztunnel 部署架构：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ztunnel-架构概览&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Ztunnel 架构概览&#34;
           src=&#34;https://cloudnativecn.com/blog/ztunnel-testing/ztunnel-architecture.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Ztunnel 架构概览
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在此架构中，用户将运行一个包含多个节点的 Kubernetes 集群。每个节点上都运行着一个 Ztunnel，配置了宿主机和每个 pod 的网络栈。&lt;/p&gt;
&lt;p&gt;此外，Ztunnel 实际上进入了每个 pod 的网络命名空间，并代表其发送/接收流量。这一点非常奇特且酷炫，但也大大增加了测试的难度！（&lt;a href=&#34;https://www.youtube.com/watch?v=cuMeEhpyH5s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;详细信息&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&#34;加速测试&#34;&gt;加速测试&lt;/h2&gt;
&lt;p&gt;启动完整的 Kubernetes 环境、重建镜像、部署到每个节点的过程非常缓慢且难以调试。&lt;/p&gt;
&lt;p&gt;黄金标准应该是将所有操作运行在一个简单的单一二进制文件中——仅需执行 &lt;code&gt;cargo test&lt;/code&gt;。这种方式避开了复杂的设置和缓慢的重建，并使调试变得轻而易举（当然，你可以将调试器连接到正在运行的 pod，但这很麻烦）。&lt;/p&gt;
&lt;h2 id=&#34;设置网络&#34;&gt;设置网络&lt;/h2&gt;
&lt;p&gt;如果我们去除无尽的抽象层，Kubernetes pods 实际上只是几个 Linux 命名空间和挂载的组合。Docker 在这方面管理得很好，&lt;a href=&#34;https://github.com/p8952/bocker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bash&lt;/a&gt;也可以。&lt;/p&gt;
&lt;p&gt;我们特别关注的是&lt;a href=&#34;https://man7.org/linux/man-pages/man7/network_namespaces.7.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络命名空间&lt;/a&gt;，它可以实现网络栈的隔离。每个 pod 都有自己的网络命名空间，通过各种机制连接，允许与同一节点上的其他 pod、其他节点以及外部目的地通信。&lt;/p&gt;
&lt;p&gt;好消息是创建网络命名空间非常简单。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo ip netns add testing
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们的最终目标是设置一系列的网络命名空间，外观与我们在 Kubernetes 上的真实架构类似：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-所需的网络命名空间设置&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;所需的网络命名空间设置&#34;
           src=&#34;https://cloudnativecn.com/blog/ztunnel-testing/ztunnel-network-namespaces.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      所需的网络命名空间设置
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在网络命名空间之间建立连接稍微复杂一些。像 &lt;a href=&#34;https://www.cni.dev/docs/cnitool/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;cnitool&lt;/code&gt;&lt;/a&gt; 这样的工具可以帮助我们完成（它实际上执行了一些 Kubernetes 环境中用于设置网络的相同逻辑，但作为 CLI 工具），但你也可以完全手动操作。我们选择了后者。&lt;/p&gt;
&lt;p&gt;最终，我们的设置如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个测试都拥有自己的网络命名空间，通过一个桥接设备（&lt;code&gt;br0&lt;/code&gt;）来促进节点之间的流量。&lt;/li&gt;
&lt;li&gt;每个节点配置了一个 &lt;code&gt;veth&lt;/code&gt; 设备。一端成为节点上的 &lt;code&gt;eth0&lt;/code&gt;，另一端连接到根命名空间中的 &lt;code&gt;br0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;每个 pod 都配置了一个 &lt;code&gt;veth&lt;/code&gt; 设备。一端成为 pod 上的 &lt;code&gt;eth0&lt;/code&gt;，另一端位于节点网络命名空间中。&lt;/li&gt;
&lt;li&gt;为每个 pod 设置路由以将流量发送到节点。&lt;/li&gt;
&lt;li&gt;为每对节点设置路由，以实现跨节点流量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-所需的网络连接设置&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;所需的网络连接设置&#34;
           src=&#34;https://cloudnativecn.com/blog/ztunnel-testing/ztunnel-network-devices.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      所需的网络连接设置
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了根命名空间/桥接设备外，这与许多现实世界中的 Kubernetes 集群的运行方式相同（在现实世界中，根命名空间是两台机器之间的物理网络）。&lt;/p&gt;
&lt;p&gt;你可以在&lt;a href=&#34;https://github.com/istio/ztunnel/blob/34fce85a6a2b2a85eb170a04096731e2ea4e0e9f/src/test_helpers/netns.rs#L194&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;找到所有细节。&lt;/p&gt;
&lt;h2 id=&#34;运行测试&#34;&gt;运行测试&lt;/h2&gt;
&lt;p&gt;一旦我们有了这些命名空间，我们仍然需要一种实际使用它们的方法。幸运的是，Linux 允许在运行时更改当前命名空间线程（这是接下来重要的内容）。这让我们建立了一个基本的帮助函数（真实的代码稍微更复杂）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;run_in_namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;namespace&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;: &lt;span class=&#34;nb&#34;&gt;Fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;original_namespace&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_current_namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;enter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;original_namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;enter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有了这个，我们可以轻松地从任意的“pods”或“nodes”执行代码。&lt;/p&gt;
&lt;p&gt;然而，我们仍然面临一个问题。我们的所有代码都运行在 &lt;a href=&#34;https://tokio.rs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tokio&lt;/a&gt; 异步运行时中，它会根据需要将我们的各种任务安排到物理操作系统线程上（类似于 Go 运行时的工作方式）。由于网络命名空间是线程相关的，所以当我们的任务在线程之间跳转时，这一切都会崩溃。&lt;/p&gt;
&lt;p&gt;幸运的是，Rust 给了我们比 Go 更多的关于异步运行时的灵活性——我们可以同时拥有多个！借此，我们能够构建一个能够异步执行 &lt;code&gt;run_in_namespace&lt;/code&gt;。对于我们想要执行的每个函数，我们启动一个新线程并构建一个专用的单线程异步运行时来处理它：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;async&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;async_run_in_namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;namespace&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;Namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;: &lt;span class=&#34;nc&#34;&gt;async&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Fn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thread&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;spawn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;||&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run_in_namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;||&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rt&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tokio&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;runtime&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;Builder&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;new_current_thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;enable_all&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;block_on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们为每个命名空间运行一次这个函数，因此这里的开销是最小的。如果我们想要运行许多小函数，可以在顶层构建一个抽象来发送工作到线程以执行。&lt;/p&gt;
&lt;p&gt;我们需要的最后一件事是一种合理的方法来识别如何调用每个目的地。虽然它们都会被分配一个 IP（基于我们代码中的简单 IPAM 策略），但我们不希望每个测试都必须猜测 IP。为了处理这个问题，我们构建了一个简单的名称解析器。这就像 DNS，但简单得多：对于我们创建的每个“pod”，我们记录一个&lt;code&gt;name -&amp;gt; IP&lt;/code&gt;的映射，并允许查找 IP。&lt;/p&gt;
&lt;p&gt;将所有这些放在一起，一个简单的测试启动了3个 pods（客户端、服务器和 ztunnel）在一个单一节点上看起来像这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#[tokio::test]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;async&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fn&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simple_test&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ztunnel&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;manager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;deploy_ztunnel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;DEFAULT_NODE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;await&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;manager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;workload_builder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;server&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;no&#34;&gt;DEFAULT_NODE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;await&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run_tcp_server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;manager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;workload_builder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;client&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;no&#34;&gt;DEFAULT_NODE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;await&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run_tcp_client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;manager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resolve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;server&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ... some assertions here }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;放弃权限&#34;&gt;放弃权限&lt;/h2&gt;
&lt;p&gt;上述设置效果很好，但也带来了一些问题。&lt;/p&gt;
&lt;p&gt;基本上设置的每一步都需要提升的 root 权限；这让简单的 &lt;code&gt;cargo test&lt;/code&gt; 案例的开箱即用变得乏味，通常也不可取。&lt;/p&gt;
&lt;p&gt;此外，这会在主机环境中污染大量的命名空间。虽然我们有一些清理过程，但这些并不是100%可靠，可能会导致悬挂的命名空间阻碍未来的执行。&lt;/p&gt;
&lt;p&gt;解决拥有太多命名空间的问题的方法？更多的命名空间！为此，我们需要的不仅仅是网络命名空间。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://man7.org/linux/man-pages/man7/user_namespaces.7.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;用户命名空间&lt;/a&gt; 允许我们实质上假装是 UID 0 (root)，同时实际上将其映射回我们原始的 UID。这里的力量在于，在该命名空间中，我们可以做一些本来需要 root 权限的事情——特别是创建新的网络命名空间。&lt;/p&gt;
&lt;p&gt;然而，我们不能做的一件事是修改主机-root 拥有的文件（这将是明显的权限违规）。尽管我们可能可以绕过它们，但我们在测试中使用的很多工具喜欢触摸 root 文件。这再次可以通过 &lt;a href=&#34;https://man7.org/linux/man-pages/man7/mount_namespaces.7.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mount 命名空间&lt;/a&gt; 解决，它允许我们将我们拥有的文件绑定挂载到主机-root 拥有的文件上，而不会影响命名空间外的事物。&lt;/p&gt;
&lt;p&gt;将所有这些放在一起，我们有这样的东西：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;original_uid&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 首先，进入一个新的用户命名空间。 unshare(CloneFlags::CLONE_NEWUSER).unwrap(); // 将用户命名空间中的 root 映射到我们原始的 UID File::create(&amp;#34;/proc/self/uid_map&amp;#34;).write(format!(&amp;#34;0 {original_uid} 1&amp;#34;)); // 设置一个新的网络命名空间 unshare(CloneFlags::CLONE_NEWNET).unwrap(); // 设置一个新的挂载命名空间 unshare(CloneFlags::CLONE_NEWNS).unwrap(); // 将一个文件夹在我们的每个测试目录中挂载到 /var/run/netns mount(tmp_dir.join(&amp;#34;netns&amp;#34;), &amp;#34;/var/run/netns&amp;#34;, MS_BIND); // 一个方便手动调试的好帮手信息，如果需要的话。 let pid = get_pid(); eprintln!(&amp;#34;Starting test in {tmp_dir}. Debug with `sudo nsenter --mount --net -t {pid}`&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上所述，一个技巧是，进入命名空间是按线程进行的。我们需要在生成任何额外线程之前设置这一点。&lt;/p&gt;
&lt;p&gt;Rust 实际上为我们提供了这样做的能力，但这意味着我们失去了 &lt;code&gt;#[tokio::test]&lt;/code&gt; 宏帮助。我们可以写自己的宏，但这有点痛苦。幸运的是，通过 &lt;a href=&#34;https://crates.io/crates/ctor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;链接器的花招&lt;/a&gt; 我们可以迫使我们的代码在进程执行的非常早期运行。&lt;/p&gt;
&lt;p&gt;Go 中的类似方法也有效（请参见 &lt;a href=&#34;https://github.com/howardjohn/unshare-go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我写的帮助库&lt;/a&gt;），实际上在那里是必需的，因为设置必须在 Go 运行时启动之前完成（这通常在任何用户代码运行之前很久）。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;有了所有这些设备，一个完整的测试只需要大约 200 毫秒。一切都在一个单一进程中运行，使调试变得轻而易举。所有的测试也都是完全隔离的，因此可以完全并行运行测试（包括相同的测试，用于压力测试以消除测试缺陷）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Istio Ambient Mesh 中基于 Rust 的 Ztunnel 组件介绍</title>
      <link>https://cloudnativecn.com/blog/rust-based-ztunnel/</link>
      <pubDate>Tue, 07 Mar 2023 19:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/rust-based-ztunnel/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;译者注：这篇文章介绍了 Istio 的 Rust-Based Ztunnel，它是一种基于 Rust 语言的轻量级代理，用于 Istio 的 ambient mesh。在文章中，作者解释了为什么需要一种新的代理，以及 Rust 语言是如何成为最佳选择的。文章还讨论了如何使用 workload xDS 配置来管理工作负载，以及如何查看 ztunnel 日志和 L4 指标。作者表示，Rust-Based Ztunnel 显著简化了 Istio 的 ambient mesh，并提高了性能。此外，Istio ambient mesh 已经合并到了上游主干，可以通过遵循入门指南来尝试 Rust-Based Ztunnel。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Ztunnel（零信任隧道）组件是为 Istio Ambient Mesh 专门构建的每节点代理。它负责安全地连接和验证 Ambient Mesh 中的工作负载。Ztunnel 旨在专注于 Ambient Mesh 中工作负载的一小组功能，例如 mTLS、身份验证、L4 授权和遥测，而无需终止工作负载 HTTP 流量或解析工作负载 HTTP 标头。Ztunnel 确保流量高效、安全地传输到 Waypoint Proxy，Istio 的全套功能（如 HTTP 遥测和负载平衡）在这里实现。&lt;/p&gt;
&lt;p&gt;由于 ztunnel 设计为在所有 Kubernetes 工作节点上运行，因此保持其资源足迹较小至关重要。Ztunnel 被设计为服务网格的不可见（或“Ambient”）部分，对你的工作负载的影响最小。&lt;/p&gt;
&lt;h2 id=&#34;ztunnel-架构&#34;&gt;Ztunnel 架构&lt;/h2&gt;
&lt;p&gt;与 sidecar 类似，ztunnel 也充当 xDS 客户端和 CA 客户端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在启动期间，它使用其服务帐户令牌安全地连接到 Istiod 控制平面。一旦使用 TLS 安全地建立了从 ztunnel 到 Istiod 的连接，它就会开始作为 xDS 客户端获取 xDS 配置。这类似于 sidecar、网关或路点代理的工作方式，不同之处在于 Istiod 识别来自 ztunnel 的请求并发送专为 ztunnel 构建的 xDS 配置，稍后你将了解更多信息。&lt;/li&gt;
&lt;li&gt;它还充当 CA 客户端，代表其管理的所有并置工作负载管理和提供 mTLS 证书。&lt;/li&gt;
&lt;li&gt;当流量传入或传出时，它充当核心代理，为其管理的所有并置工作负载处理入站和出站流量（纯文本网格外或 HBONE 网格内）。&lt;/li&gt;
&lt;li&gt;它提供 L4 遥测（指标和日志）和带有调试信息的管理服务器，以帮助你在需要时调试 ztunnel。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ztunnel-架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Ztunnel 架构&#34; srcset=&#34;
               /blog/rust-based-ztunnel/ztunnel-architecture_hu_78579086bd8aa418.webp 400w,
               /blog/rust-based-ztunnel/ztunnel-architecture_hu_2df922f1eb80fced.webp 760w,
               /blog/rust-based-ztunnel/ztunnel-architecture_hu_58b9fde8fe7993ab.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/rust-based-ztunnel/ztunnel-architecture_hu_78579086bd8aa418.webp&#34;
               width=&#34;760&#34;
               height=&#34;515&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Ztunnel 架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;为什么不重用-envoy&#34;&gt;为什么不重用 Envoy？&lt;/h2&gt;
&lt;p&gt;当 Istio Ambient Mesh 于 2022 年 9 月 7 日发布时，ztunnel 是使用 Envoy 代理实现的。鉴于我们将 Envoy 用于 Istio 的其余部分——sidecar、网关和 Waypoint Proxy——我们开始使用 Envoy 实施 ztunnel 是很自然的选择。&lt;/p&gt;
&lt;p&gt;然而，我们发现虽然 Envoy 非常适合其他用例，但在 Envoy 中实现 ztunnel 具有挑战性，因为许多权衡、要求和用例与 sidecar 代理或入口网关有很大不同。此外，大多数使 Envoy 非常适合其他用例的东西，例如其丰富的 L7 功能集和可扩展性，都浪费在不需要这些功能的 ztunnel 中。&lt;/p&gt;
&lt;h2 id=&#34;专门构建的-ztunnel&#34;&gt;专门构建的 ztunnel&lt;/h2&gt;
&lt;p&gt;在 Envoy 因我们的需求而失败后，我们开始考虑构建 ztunnel 的专用实现。我们的假设是，通过从一开始就考虑一个单一的重点用例进行设计，我们可以开发一个比将通用项目塑造成自定义用例更简单、性能更高的解决方案。使 ztunnel 简单化的明确决定是这一假设的关键；例如，类似的逻辑不适用于具有大量支持功能和集成的重写网关。&lt;/p&gt;
&lt;p&gt;这个专门建造的 ztunnel 涉及两个关键领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ztunnel 与其 Istiod 之间的配置协议&lt;/li&gt;
&lt;li&gt;ztunnel 的运行时实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;配置协议&#34;&gt;配置协议&lt;/h3&gt;
&lt;p&gt;Envoy 代理使用 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xDS 协议&lt;/a&gt; 配置。这是使 Istio 良好运行的关键部分，提供丰富且动态的配置更新。然而，随着规模的扩大，配置变得越来越定制化，这意味着生成它更大、更昂贵。在 sidecar 中，具有 1 个 pod 的单个服务会生成大约 350 行 xDS（在 YAML 中），这已经很难扩展。基于 Envoy 的 ztunnel 甚至更糟，并且在某些区域具有 N^2 缩放属性。&lt;/p&gt;
&lt;p&gt;为了使 ztunnel 配置尽可能小，我们研究了使用一种专门构建的配置协议，该协议以一种有效的格式准确包含我们需要的信息（仅此而已）。例如，可以简洁地表示单个 pod：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld-v1-55446d46d8-ntdbk&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceAccount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ambient-worker2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Healthy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;waypointAddresses&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;workloadIp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.244.2.8&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;canonicalName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;canonicalRevision&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;workloadName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld-v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;workloadType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此信息通过 xDS 传输 API 传输，但使用特定于环境的自定义类型。请参阅&lt;a href=&#34;https://preliminary.istio.io/latest/blog/2023/rust-based-ztunnel/#workload-xds-configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;工作负载 xDS 配置部分&lt;/a&gt; 以了解有关配置详细信息的更多信息。&lt;/p&gt;
&lt;p&gt;使用专门构建的 API，我们可以将逻辑推送到代理中，而不是在 Envoy 配置中。例如，要在 Envoy 中配置 mTLS，我们需要添加相同的大型配置集来调整每个服务的精确 TLS 设置；使用 ztunnel，我们只需要一个枚举来声明是否应该使用 mTLS。其余的复杂逻辑直接嵌入到 ztunnel 代码中。&lt;/p&gt;
&lt;p&gt;借助 Istiod 和 ztunnel 之间的这种高效 API，我们发现我们可以使用有关大型网格（例如具有 100,000 个 pod 的网格）的信息来配置 ztunnel，配置数量减少几个数量级，这意味着 CPU、内存和网络成本更低。&lt;/p&gt;
&lt;h3 id=&#34;运行时实现&#34;&gt;运行时实现&lt;/h3&gt;
&lt;p&gt;顾名思义，ztunnel 使用 &lt;a href=&#34;https://preliminary.istio.io/latest/blog/2022/introducing-ambient-mesh/#building-an-ambient-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTPS 隧道&lt;/a&gt; 承载用户请求。虽然 Envoy 支持这种隧道，但我们发现配置模型限制了我们的需求。简单地说，Envoy 的工作方式是通过一系列“过滤器”发送请求，从接受请求开始到发送结束。根据我们的要求，它有多层请求（隧道本身和用户的请求），以及负载均衡后需要应用 per-pod 策略，我们发现每个连接需要循环通过这些过滤器 4 次才能实现我们的基于在 Envoy 上当 ztunnel。虽然 Envoy 对内存中的“向自身发送请求”进行了 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/other_features/internal_listener&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一些优化 &lt;/a&gt;，但这仍然非常复杂且昂贵。&lt;/p&gt;
&lt;p&gt;通过构建我们自己的实现，我们可以从头开始围绕这些约束进行设计。此外，我们在设计的各个方面都有更大的灵活性。例如，我们可以选择跨线程共享连接或围绕服务账户之间的隔离实现更多自定义需求。在确定专用代理可行后，我们开始选择实现细节。&lt;/p&gt;
&lt;h4 id=&#34;基于-rust-的-ztunnel&#34;&gt;基于 Rust 的 ztunnel&lt;/h4&gt;
&lt;p&gt;为了使 ztunnel 快速、安全和轻量级，&lt;a href=&#34;https://www.rust-lang.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Rust&lt;/a&gt; 是一个显而易见的选择。然而，这不是我们第一次。鉴于 Istio 目前对 Go 的广泛使用，我们曾希望我们可以使基于 Go 的实现满足这些目标。在最初的原型中，我们构建了一些基于 Go 的实现和一个简单版本的基于 Rust 的实现。从我们的测试中，我们发现基于 Go 的版本不满足我们的性能和占用空间要求。虽然我们可能会进一步优化它，但我们认为基于 Rust 的代理从长远来看将为我们提供最佳实现。&lt;/p&gt;
&lt;p&gt;还考虑了 C++ 实现——可能会重用 Envoy 的部分内容。但是，由于缺乏内存安全、开发人员体验问题以及 Rust 的一般行业趋势，此选项未被采用。&lt;/p&gt;
&lt;p&gt;这个淘汰过程给我们留下了 Rust，这是一个完美的选择。Rust 在高性能、低资源利用率的应用程序方面有着悠久的成功历史，尤其是网络应用程序，包括服务网格。我们选择在 &lt;a href=&#34;https://tokio.rs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tokio&lt;/a&gt; 和 &lt;a href=&#34;https://hyper.rs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hyper&lt;/a&gt; 库之上构建，这两个生态系统中的事实标准已经经历了广泛的验证——经过测试且易于编写高性能异步代码。&lt;/p&gt;
&lt;h2 id=&#34;快速了解基于-rust-的-ztunnel&#34;&gt;快速了解基于 Rust 的 ztunnel&lt;/h2&gt;
&lt;h3 id=&#34;工作负载-xds-配置&#34;&gt;工作负载 xDS 配置&lt;/h3&gt;
&lt;p&gt;工作负载 xDS 配置非常易于理解和调试。你可以通过从你的一个 ztunnel pod 发送请求 &lt;code&gt;localhost:15000/config_dump&lt;/code&gt; 或使用方便的 &lt;code&gt;istioctl pc workload&lt;/code&gt; 命令来查看它们。有两个关键的工作负载 xDS 配置：工作负载和策略。&lt;/p&gt;
&lt;p&gt;在你的工作负载包含在 Ambient Mesh 中之前，你仍然可以在 ztunnel 的配置转储中看到它们，因为 ztunnel 知道所有工作负载，无论它们是否启用了 Ambient Mesh。例如，以下包含新部署的 helloworld v1 pod 的示例工作负载配置，由 &lt;code&gt;protocol: TCP&lt;/code&gt; 指示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;workloads&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;10.244.2.8&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;workloadIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.244.2.8&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;protocol&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;TCP&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;helloworld-v1-cross-node-55446d46d8-ntdbk&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;namespace&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;default&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;serviceAccount&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;helloworld&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;workloadName&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;helloworld-v1-cross-node&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;workloadType&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;deployment&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;canonicalName&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;helloworld&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;canonicalRevision&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;node&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;ambient-worker2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;authorizationPolicies&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;status&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Healthy&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Pod 被包含在 ambient 中后（默认将命名空间标记为 &lt;code&gt;istio.io/dataplane-mode=ambient&lt;/code&gt; ），protocol 值将被替换为 HBONE，表示 ztunnel 将来自所有 helloworld -v1 pod 传入和传出通信升级到 HBONE。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;workloads&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;10.244.2.8&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;workloadIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.244.2.8&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;protocol&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;HBONE&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在部署任何工作负载级别的授权策略后，策略配置作为 xDS 配置从 Istiod 推送到 ztunnel，并出现在 &lt;code&gt;policies&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;policies&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;default/hw-viewer&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;hw-viewer&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;namespace&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;default&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;scope&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;WorkloadSelector&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;action&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Allow&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;groups&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[[[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;principals&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;Exact&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;}]]]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;工作负载的配置已参考授权策略进行了更新：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;workloads&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;10.244.2.8&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;workloadIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.244.2.8&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;authorizationPolicies&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/hw-viewer&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;ztunnel-提供的-l4-遥测&#34;&gt;ztunnel 提供的 L4 遥测&lt;/h3&gt;
&lt;p&gt;你可能会惊喜地发现 ztunnel 日志很容易理解。例如，你将在目标 ztunnel 上看到一个 HTTP 连接请求，指示源 pod IP (&lt;code&gt;peer_ip&lt;/code&gt;) 和目标 pod IP。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2023-02-15T20:40:48.628251Z  INFO inbound{id=4399fa68cf25b8ebccd472d320ba733f peer_ip=10.244.2.5 peer_id=spiffe://cluster.local/ns/default/sa/sleep}: ztunnel::proxy::inbound: got CONNECT request to 10.244.2.8:5000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以通过访问位于“localhost:15020/metrics”的 API 查看工作负载的 L4 指标，它提供了全套 TCP &lt;a href=&#34;https://istio.io/latest/docs/reference/config/metrics/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标准指标&lt;/a&gt; 集，具有与 sidecar 暴露的相同标签。例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;istio_tcp_connections_opened_total{
  reporter=&amp;#34;source&amp;#34;,
  source_workload=&amp;#34;sleep&amp;#34;,
  source_workload_namespace=&amp;#34;default&amp;#34;,
  source_principal=&amp;#34;spiffe://cluster.local/ns/default/sa/sleep&amp;#34;,
  destination_workload=&amp;#34;helloworld-v1&amp;#34;,
  destination_workload_namespace=&amp;#34;default&amp;#34;,
  destination_principal=&amp;#34;spiffe://cluster.local/ns/default/sa/helloworld&amp;#34;,
  request_protocol=&amp;#34;tcp&amp;#34;,
  connection_security_policy=&amp;#34;mutual_tls&amp;#34;
  ...
} 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你安装了 Prometheus 和 Kiali，你可以从 Kiali 的 UI 轻松查看这些指标。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kiali-dashboard由-ztunnel-提供的-l4-遥测&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kiali dashboard：由 ztunnel 提供的 L4 遥测&#34; srcset=&#34;
               /blog/rust-based-ztunnel/kiali-ambient_hu_8e359bfea2a816e2.webp 400w,
               /blog/rust-based-ztunnel/kiali-ambient_hu_7e0514f51ef31e0a.webp 760w,
               /blog/rust-based-ztunnel/kiali-ambient_hu_441520f4fbd58fea.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/rust-based-ztunnel/kiali-ambient_hu_8e359bfea2a816e2.webp&#34;
               width=&#34;760&#34;
               height=&#34;357&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kiali dashboard：由 ztunnel 提供的 L4 遥测
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们感到非常兴奋的是，新的 &lt;a href=&#34;https://github.com/istio/ztunnel/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Rust 的 ztunnel&lt;/a&gt; 比之前基于 Envoy 的 ztunnel 更简单、重量更轻且性能更高。借助专门为基于 Rust 的 ztunnel 设计的工作负载 xDS，你不仅可以更轻松地了解 xDS 配置，还可以大大降低 Istiod 控制平面和 ztunnel 之间的网络流量和成本。随着 Istio ambient 现在合并到上游 master，你可以按照我们的&lt;a href=&#34;http://istio.io/latest/docs/ops/ambient/getting-started/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;入门指南&lt;/a&gt; 尝试新的基于 Rust 的 ztunnel。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
