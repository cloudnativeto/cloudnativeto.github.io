<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sofamesh | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/tag/sofamesh/</link>
      <atom:link href="https://cloudnativecn.com/tag/sofamesh/index.xml" rel="self" type="application/rss+xml" />
    <description>Sofamesh</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 04 Dec 2018 17:32:44 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/media/sharing.png</url>
      <title>Sofamesh</title>
      <link>https://cloudnativecn.com/tag/sofamesh/</link>
    </image>
    
    <item>
      <title>蚂蚁金服 Service Mesh 新型网络代理的思考与实践</title>
      <link>https://cloudnativecn.com/blog/microservice-with-service-mesh-at-ant-financial/</link>
      <pubDate>Tue, 04 Dec 2018 17:32:44 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/microservice-with-service-mesh-at-ant-financial/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(136, 136, 136)&#34;&gt;&lt;strong&gt;朵晓东&lt;/strong&gt;&lt;/span&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(62, 58, 57)&#34;&gt;，&lt;/span&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(62, 58, 57)&#34;&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(49, 70, 89)&#34;&gt;花名奕杉，蚂蚁金服高级技术专家。专注企业云计算技术及产品，蚂蚁金融云 PaaS 创始团队核心成员，Antstack 网络产品负责人。开源爱好者，Apache Kylin 创始团队核心成员；SOFAMesh 创始团队核心成员，SOFAMosn 项目负责人。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(62, 58, 57)&#34;&gt;本文根据晓东在 GIAC 上海站的&lt;/span&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(25, 31, 37)&#34;&gt;演讲内容整理&lt;/span&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(62, 58, 57)&#34;&gt;，完整的分享 PPT 获取方式见文章底部。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng--left--720x4811881188118812&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2018/png/156645/1543544928743-c397c665-a542-490e-9a13-9ccf4b468d5f.png&#34; alt=&#34;image.png | left | 720x481.1881188118812&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png | left | 720x481.1881188118812
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，我是蚂蚁金服系统部的高级技术专家奕杉，今天分享的内容是：《蚂蚁金服在 ServiceMesh 推进落地过程中对新型网络代理的思考和实践》&lt;/p&gt;
&lt;h2 id=&#34;内容结构&#34;&gt;内容结构：&lt;/h2&gt;
&lt;p&gt;主要的分享顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;背景概述&lt;/li&gt;
&lt;li&gt;架构设计及功能特性&lt;/li&gt;
&lt;li&gt;技术案例&lt;/li&gt;
&lt;li&gt;总结展望&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1背景概览&#34;&gt;1、背景、概览：&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218438360-fd1bb4df-7b7f-45b1-a84e-b124fad9eebd.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;ServiceMesh 作为云原生之上的服务网格技术在今年引起了业界的广泛关注，首先我们来看一下目前 ServiceMesh 数据平面的一些方案。&lt;/p&gt;
&lt;p&gt;最为大家熟知的是老牌七层代理 Nginx 和 ISTIO 原生的数据平面 Envoy。Nginx 早已在国内外广泛使用，近两年积极探索 K8S、ServiceMesh 微服务场景，并推出了与  ISTIO 集成的微服务解决方案，试图扩展其场景边界，拿下新的领域，从单纯的 7 层流量代理到云原生时代的智能数据平面转型。但目前看“NgMesh”研发不够活跃，已知的使用方也不多。Envoy 作为 Google 和 Lyft 联合开发的 ISTIO 原生数据平面产品，近两年借助 ServiceMesh 微服务场景快速打开了市场，并在一些互联网公司推广使用，同时引入了一批开发者进行 API 网关等功能网关的开发，发展势头非常好。&lt;/p&gt;
&lt;p&gt;其次 LINKERD 是基于 Rust 的一种高性能数据平面，但其发展空间受到了 Envoy 挤压，业界使用的公司也比较有限。&lt;/p&gt;
&lt;p&gt;蚂蚁金服基于自身诉求自研了基于 Golang 的数据平面 SOFAMosn（后简称 MOSN），并在蚂蚁、UC 等公司落地使用。&lt;/p&gt;
&lt;p&gt;同时对业界开源，提供了一种新的数据平面产品选择。&lt;/p&gt;
&lt;p&gt;此外国内的华为、新浪等公司都基于自身场景提出了数据平面方案并先后进行了开源，数据平面竞争已经从独霸业界的基于 Nginx 二开方案逐步转变为目前的多样化产品同场竞技的局面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218443233-7b74f903-c3e6-4bf4-b5c5-b56d427cc9f0.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么众多大厂纷纷投入研发数据平面呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我个人认为新生技术栈、云原生、微服务快速发展等契机对数据平面提出了场景多样化、功能服务化、云原生亲和等多重挑战。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以往从未像现在这样对数据平面提出过如此多的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据平面需要执行部署运维中的流量切换；&lt;/li&gt;
&lt;li&gt;需要提供云亲和的细粒度流量调度功能；&lt;/li&gt;
&lt;li&gt;需要提供微服务亲和的服务发现、路由组网特性；&lt;/li&gt;
&lt;li&gt;需要以云原生的方式感知资源；&lt;/li&gt;
&lt;li&gt;需要支撑服务粒度、高度自定义的压测、故障测试、线上灰度流量管理；&lt;/li&gt;
&lt;li&gt;需要提供链路级、服务级的安全隔离保护，需要支持多种语言、多种协议的转换分发能力；&lt;/li&gt;
&lt;li&gt;需要能享受系统层面、硬件层面的红利；&lt;/li&gt;
&lt;li&gt;需要为复杂的运维架构（如蚂蚁的 LDC 等）提供可扩展的流量调拨能力等等；&lt;/li&gt;
&lt;li&gt;当然根据每个公司的业务场景可能还有其他的因素。
最后，如何要将这些能力都汇聚在统一的数据平面产品上，弥合南北向、东西向数据平面由于技术栈、团队等差异带来的鸿沟，变成了另一个更为复杂的问题。这里所提到的问题中任何一点扩展开来都可以是一个丰富独立的 Topic，受限于篇幅本次分享只能介绍我们在解决这些问题中的一小部分思考和实践。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2sofamesh-架构--重点特性&#34;&gt;2、SOFAMesh 架构 &amp;amp; 重点特性&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218452941-9329810d-b6a7-484e-a493-a549c70a6181.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先，蚂蚁已经将基于 ISTIO 的 ServiceMesh 方案 &amp;ldquo;SOFAMesh&amp;rdquo; 开源，在控制面我们选择克隆 ISTIO 官方版本并研发符合蚂蚁需求的控制面，在数据面我们选择使用 Golang 研发数据平面 MOSN，目前已经支持了微服务场景所需的大量常用功能。&lt;/p&gt;
&lt;p&gt;这里我根据 ISTIO 的 Task 文档总结了目前 SOFAMesh 支持的一些能力，如：透明拦截适配，细粒度的流控，故障注入，双向链路加密等。对于一些暂时存疑的功能，如 Mixer Check 等，暂时没有支持。目前 SOFAMesh 已在 UC 生产环境落地使用，满足了 Sidecar、Ingress、Egress 多种场景的使用需求。在这里附上  SOFAMesh，SOFAMosn 的 Github 地址，也欢迎大家使用交流。
SOFAMesh：&lt;a href=&#34;https://github.com/alipay/sofa-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/alipay/sofa-mesh&lt;/a&gt;
SOFAMosn：&lt;a href=&#34;https://github.com/alipay/sofa-mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/alipay/sofa-mosn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218458578-9f7bd036-eb1d-489a-bbb8-5c40031def35.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;再来看看蚂蚁内部，由于目前蚂蚁生产环境尚未大量铺开 K8S，并且已经存在一套完善的管控技术体系，加上目前 ISTIO 的性能和稳定性还不满足大规模微服务场景等原因，我们暂时没有选择直接升级到 ISTIO，而是通过优先落地 Sidecar 的方式来赢得 ServiceMesh 解决方案带来的红利。在蚂蚁内部，MOSN 接管了 SOFABoot 应用，代理了服务发现、路由/负载均衡、通信等工作，构成了微服务网格，通过自有的中间件及管控平面进行微服务的管理、治理。同时，我们积极的推进 MOSN 与  SOFA 中间件，网络接入层，安全防护及监控体系的整合，以提供更统一更强大的数据平面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218465864-1a4c61d2-6b0e-45b8-8252-a49d0409bd6e.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来我将介绍 MOSN 支持多协议的方案。&lt;/p&gt;
&lt;p&gt;为了在内部快速落地试错，我们首先支持了内部使用最广泛的 SOFARPC 协议，并对其进行了深度优化。随后我们根据 UC Mesh 化推进遇到的普遍问题提出了 XProtocol 方案，以在不解包的场景下提供路由能力。最后我们深度改造了三方 HTTP/1.1 实现及官方 HTTP/2.0 实现。到目前为止，MOSN 已提供了多种协议的支持。同时 MOSN 提供了两种自定义协议的能力支持使用者通过扩展的方式自定义协议实现，满足需要解包、不需要解包的协议扩展需求。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218470502-0ddf8529-a953-4f5b-a19d-0c8e0940934d.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除协议之外，性能是大家比较关心的另一个问题。为了提供满足生产要求的 7 层转发性能，我们在 IO、协议、内存、协程、网络处理等方面进行了优化，从目前通过 SOFARPC 通信应用的上线情况来看可以满足生产使用要求，在案例分析中我将展示一些性能数据，后续我们也将继续推进性能优化，以达到更好的性能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218475631-74f2953b-9687-4269-bc2f-429f80247dbe.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在安全能力上，SOFAMesh 支持 mTLS，并在蚂蚁内部集成蚂蚁内部的 KMS 完成了 mTLS 落地，同时 RBAC 功能在研发中，此外 WAF、流量镜像能功能也在规划中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218480670-4d7ace4c-7eac-40a7-9a9d-6143c02ddb4e.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在蚂蚁内部基于 MOSN 的网关产品正在研发中，将会在稳定验证后开源。网关场景相对于 Sidecar 场景有一些特性需求，比如说一般会 Hold 住大量长链接，比如说会根据请求内容动态选择后端应用，由于网关可能代理了不同的后端应用，就会需要动态选择后端协议。此外还有一些网关类的通用能力需求，如签名，授权，限流等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218485802-9e65b38f-40fa-4feb-9563-ba068c8da594.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了能基于开源版建设蚂蚁内部的 Sidecar 及网关产品，我们充分考虑了开源版 MOSN 的扩展性，在路由、后端管理、TLS、网络、流处理等各方面提供了扩展性支持。对于其他使用 MOSN 的场景，也可以通过类似的方式来满足自身业务定制需求。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218492236-d4608e03-9513-4267-9067-46276b86c093.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218496748-cd4ed37c-c654-4f3d-ba1b-f0631c268588.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218501467-8d454bcd-9f6b-4803-8fed-fcfd0e692020.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218505963-16adc24e-25b9-4dfa-a481-a5916133664d.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218511973-3e79c724-03b8-43b8-8a01-b994f5a017b9.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了更清晰的展示 MOSN 功能特性，这里将 MOSN 0.4.0 的功能特性通过表格的方式展示出来。可以说 0.4.0 版本已经初步具备了生产所需的大部分功能点，支持云原生场景下的多协议、路由&amp;amp;LB、后端管理、TLS、遥感监测、XDS 对接等功能，并充分优化了性能，目前已经在蚂蚁、UC 生产环境进行了验证。同时在蚂蚁内部我们通过扩展的方式支持了&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(25, 31, 37)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;灰度路由、&lt;/span&gt;&lt;/span&gt; LDC 路由、弹性路由，支持了配置中心等定制需求。后续我们会继续完善功能点，如果有发现未支持的功能可以在 Github 给我们提 Issue，或者直接加入我们 commit code。由于 MOSN 在扩展性上提供了比较好的能力支持，在特定的场景都可以通过扩展的方式来满足需求。&lt;/p&gt;
&lt;h2 id=&#34;3技术案例解析&#34;&gt;3、技术案例解析&lt;/h2&gt;
&lt;p&gt;在介绍了架构、功能特性以后，我将介绍一些落地过程中的技术案例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218522468-7fa7d941-96ee-42e5-afcf-0b1f63ba0c51.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先我们来看在蚂蚁在非 K8S 场景下将 MOSN 作为 Sidecar 接入应用的姿势。
在我们推进落地初期，需要接入 MOSN 的 SOA 应用还没有通过原生 K8S 的方式运行起来，服务发现是基于典型的服务发现中间件来做，也没有直接使用 ISTIO 来落地。在这种情况下，我们通过扩展开源版 MOSN 支持服务发现，将 MOSN 作为服务代理，由其完成服务 Pub/Sub，并代理服务完成 RPC 通信。这里有几个要点，首先由于内核限制我们没有第一时间使用 Iptables 拦截请求，而是通过升级 SOFA 的方式来支持应用切换访问地址，这里需要应用方升级 SOFA 依赖，但不需要改业务代码。&lt;/p&gt;
&lt;p&gt;其次，我们通过扩展开源版服务发现实现的方式支持从蚂蚁配置中心获取后端服务列表。在路由生成上，MOSN 基于完善的服务间依赖关系生成服务路由，由于 SOFA 应用在编码阶段已明确定义了服务依赖并在服务启动时由 MOSN 代理完成 Pub/Sub，MOSN 感知所需的服务依赖关系，并动态生成了出向/入向路由。如果你的使用场景服务之间没有明确的依赖关系，则需要扩展路由机制支持基于完全请求内容的动态路由机制。其次，SOFA 服务寻址基于明确的 id:version 信息，所以这样的服务发现、路由方案同时也适用于类似的 SOA 服务，同时也可以支持标准微服务寻址。这样的扩展方式可以实现基于服务发现中间件的非 K8S 的 Sidecar 注入，来享受 Mesh 思路落地的便利。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218528415-f554183c-9756-43d5-94e6-88bda76fb9b5.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了通过以上方式支持 SOA 化服务外，__SOFAMesh 标准方案提供了一种基于 DNS 的寻址方案，__以在不修改应用的情况下支持标准微服务寻址。
首先通过 DNS 将服务名转化为 IP，同时在 MOSN 路由的 Virtual Host 中配置服务 IP，以及与后端的匹配关系。Client 请求被 Iptables 拦截并转发给 MOSN，MOSN 在处理请求时通过 Tcp Option 的 Original Destination 项拿到目标 IP，并作为 Host 与 Virtual Host 匹配寻址到 Cluster 并做后端 LB 及转发。这样在不进行微服务化改造的情况下就可以进行服务名完成寻址通信了。这里更多细节可以参考敖小剑老师写的 XProtocol 完整&lt;a href=&#34;https://yq.aliyun.com/articles/650936&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;方案&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218533752-5a8d4702-2360-4de0-b636-9d6647849c65.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来我们一起分析另一个在生产环境非常有用的特性，无损平滑升级。
大部分 7 层流量代理，包括 Nginx、Envoy 等，在升级过程中通常会让老进程静默等待一段时间后再退出、或等待时机由新进程控制退出，通过这种方式来保证老进程不再处理到请求。这种方式对于 HTTP/1.x 短链接是比较有用的，但对于 HTTP/1.1长链接、RPC 长链接最终不得不通过暴力断链的方式让 Client 重连、重试，对业务是有一定影响的。凡会造成业务抖动一般都会造成业务方紧张，这会导致新功能升级推动困难。针对这个问题，MOSN 提出了自己的解决方案，在升级过程中无损迁移存量链接，目前支持 HTTP/1.1、无状态 RPC、TLS，后续将基于 Goaway 帧支持 HTTP/2.0。下面我们来看看MOSN 是怎么实现这样能力的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218539299-6752b969-ff5e-4a05-b603-984def368d41.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里我把典型场景抽象成 Client 请求处理和 Server 回复处理两部分，我们先来看看 Client 请求处理。在升级阶段，同时存在新老两个 MOSN 进程，此时可能存在 Client 正在访问老进程的情况，此时老进程会通过 Domian Socket 将 &lt;span data-type=&#34;color&#34; style=&#34;color:rgb(38, 38, 38)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;TCP1 的 FD 及链接状态数据&lt;/span&gt;&lt;/span&gt;传递给新进程，由新进程&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(38, 38, 38)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;创建 TCP3 链接&lt;/span&gt;&lt;/span&gt;并将数据发送到后端 Server 并接收 Server 响应，新进程在收到响应后不再转发给老进程，直接转发给 Client 完成本次请求。此后老进程退出 &lt;span data-type=&#34;color&#34; style=&#34;color:rgb(38, 38, 38)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;Read 流程，不再接受该 TCP1 连接上的数据，同时新进程开始 Read 流程，接受该 TCP1 连接上的数据，完成 Reload 过程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218544265-94ef075e-e737-49c5-9f29-509ae5d57369.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;再来看看第二种情况，在第一步链接迁移完成后仍然可能出现 Server  通过 TCP2 将残留响应发送到老进程的情况，此时老进程会通过 Domian Socket 将请求数据传递给新进程，由新进程回复到 Client。这样就避免了两个 MOSN 进程同时写到 Client 造成乱序的问题。延伸一下，未来基于这样的思考可以与容器 fork 结合提供容器、Pod 层面的无损迁移方案。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218550949-a623f6d9-7082-4c57-a917-34dc4b4760d5.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在迁移过程中我们发现，对于无状态的 HTTP/1.1 长链接，RPC 长链接迁移较为简单，但对于有多回合握手的 TLS 迁移则比较麻烦，这里主要涉及到 TLS 的状态数据迁移，如&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(38, 38, 38)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;加密秘钥，Seq 序列，读缓存数据，Cipher 类型等状态数据都需要做特殊的处理以保证迁移过程不会破坏握手过程。此外，MOSN 还支持对请求链接做明、密文检测，来保证上游可以灰度的开启链路加密。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218555173-754e294d-96e7-4f98-b87a-be20d6e8625e.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我将介绍一下我们在性能优化方面的一些实践。数据来源于 2018 年 8 月份的 0.2.1 开源版。
先介绍一下在 Sidecar 模式下的性能数据，测试场景是一个典型的服务间通信场景，服务 A 通过 MOSN 访问服务 B。这里选用的机型是蚂蚁内部的测试机器。我们测试的场景包括了  SOFARPC、HTTP/1.1、HTTP/2.0 三种协议，测试的工具分别是蚂蚁内部的压测平台、ab、h2load，其中 HTTP/2.0 压测 5 条链接的场景，并且是 H2C，无 TLS 加密。数据场景是 1K 的请求、响应。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218559351-a0af582a-e7a9-4786-9bd5-6ff4bbc38d45.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们来看一下测试结果，可以看到 SOFARPC 性能远好于其他两个协议。需要说明的是，HTTP/1.1 在 0.2.1 版本中直接使用了开源的 FastHTTP，MOSN 没有接管 IO 处理，协议解析等工作，未做任何优化；HTTP/2.0 直接使用了官方实现，MOSN 没有接管 IO 处理，协议解析等工作，未做任何优化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218563811-b588d066-772e-4815-9c54-645552f18d09.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 SOFARPC 的优化上我们从 IO，协议到上层处理做了不少优化，这里简单介绍一些优化经验。首先分享一个踩过的坑，在基于 Golang Connection API 编写读数据代码时，一个常用的方式是通过 SetReadDeadline 来设置读超时，我们发现在读超时很短的情况下，在 2.6.2 内核会比 4.13.0 内核性能下降 30%，而通过绑核可以解决此问题。此外，有很多有用的手段可以用来优化性能，比如说读合并减少协议处理次数，writev 减少系统调用写的次数可以有效提升整体吞吐量。我们通过对比 Golang 和 OS 的 perf 数据发现 Golang 系统调用耗时比 OS 系统调用耗时要多（原因还需要进一步明确），减少 Golang 系统调度总是有效的优化手段。在内存优化方案，首先可以尽量减少内存入堆，对于 100K 以下的内存入栈比入堆更快，并且不会影响 GC，对于不得不入堆的内存，可以通过有效的内存回收复用减少内存创建，减少 GC 压力。其次，在可控的范围内池化协议可以减少 Golang runtime 调度，并减少为了 Golang 为了保证连续栈而调用 morestack 造成的开销。对于单核的场景，需要关注协程数量及协程使用率，避免协程饥饿的情况。对于 perf 发现的热点，需要有针对性的进行优化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218567975-bb82422c-f9b4-4e65-b8a1-f75aa9ea2299.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来看看网关的场景，Client 通过 MOSN 访问 Server，测试条件与单核类似，不过没有限制 MOSN 的 P，也没有绑核。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218573591-604a2ef8-6d26-4a70-b964-6602a0933b03.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从实验结果上看，SOFARPC，HTTP/1.1 的结果基本在预期内，但 HTTP/2.0 性能远低于预期。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218583099-2b7d3d27-4ce1-4fb2-9d60-4e91675ae25d.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们看到 Golang 官方的 HTTP/2.0 实现在多核场景下性能不佳，在 0.4.0 中对官方 HTTP/2.0 进行了性能优化，我们将在 0.4.0 正式发布后更新性能数据。在多核场景下我们仍然选择了单进程模型，根据连接数、负载等变化可以压到 4-8 核。我们也尝试了多进程绑核+reuse port 的方案，多核吞吐量高于单进程 15% 以上，但从容器的适配性，进程模型简单等角度考虑我们仍然选择了单进程模型。在多核场景下需要特别关注全局锁的性能和 IO 的优化，这也是官方 Golang HTTP/2.0 实现性能不佳的重要原因。此外，需要在压测时关注 G 是否频繁切换，P 是否有饥饿等问题，有针对性的进行多核性能优化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218587543-7fecc16f-8a8c-4495-9f8b-f2c9c64ce894.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们再来看看长链接的模式，在这种模式下会有大量链接，但不会出现同时有大量流量的情况。MOSN 针对这种场景提供了基于 NetPoll 的使用模式，我们重点压测了在 10K 链接场景下 SOFARPC 的性能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218592084-9d0ed763-f275-4cf5-a1a8-ed48a3c444ec.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从压测结果上可以看看到，基于 Raw Epoll 的 NetPoll 模式在资源消耗上明显少于原生 Golang IO 的模式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218598786-a27aa543-967c-49ec-b4f8-a0765b53e5bf.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从结果上看，原生  IO 模式还无法高性能的满足 C10K  场景的要求，针对高性能网关场景还是需要通过更有针对性的方案来支持。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218603100-d08d0a74-86a7-4d27-921d-dea4ee8f45c7.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我将介绍 TLS 性能数据，这里通过 Nginx+OpenSSL，Caddy，Caddy+BoringSSL 三种实现来测试 SSL 处理的性能数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218606522-539145be-913f-49c3-a3c4-8a94db917157.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从测试结果可以看到，对于 RSA 加密，使用了 Golang 原生支持的 Caddy 性能明显弱与 OpenSSL 及 Caddy+BoringSSL，但对于 ECDSA 来说 Caddy 弱于 OpenSSL，但明显略好于通过 cgo 调用 BoringSSL 的方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218610013-d5ceba6c-eb5b-455a-95e2-0b9d9e1f01a6.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过进一步分析发现，Golang 对 RSA 的实现是基于 Golang 的，但对 ECDSA 等现代加密算法有汇编优化，比如说对 p256 的一些重点实现方法是移植了 OpenSSL 实现。同时 Golang 对 AES-GCM，SHA，MD 等算法都有汇编优化。如果你需要使用的算法正好在 Golang 的优化范围内，那么完全可以直接使用 Golang 原生实现，可以省去对接 OpenSSL、BoringSSL 的麻烦。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218613994-4ba290e3-8237-4640-8360-71a08e0b23be.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最终总结一些性能优化的结果，到目前为止，在 SOFARPC 协议上对 0.1.0 版本 QPS 提升了 50%，内存使用减少了 40%；HTTP/2.0 经过一轮优化，QPS 提升了一倍，后续会继续推进优化；HTTP/1.1 也有 30%  以上的性能提升。&lt;/p&gt;
&lt;p&gt;此外，Golang 性能优化与 C/C++ 还是有比较大的区别，在 C/C++ 优化过程中，重点观察系统 perf 进行优化，但 Golang 的话需要既需要了解、观察 Golang runtime 的 perf、调度数据，也需要观察 OS 层面 的 perf 数据，并且需要进行结合分析。一些 C/C++ 常用的方式在 Golang 也无法直接使用，比如说在 C 中做无锁替换经常通过整块内存替换指针的方式来保证原子性，但在 Golang 里指针替换并不是原子的，如果分析汇编会发现实际上执行了多条汇编，在实现层面就需要一些特殊的处理。&lt;/p&gt;
&lt;p&gt;由于 Golang 从编译到运行时，从运行单元到系统调用都是一个非常独立并且自包含的体系，他并没有基于 C  的开发套件建立，可以说是非常自成一体了，所以在系统层面的集成上仍然有不少问题需要克服，比如说 cgo  性能，但是由于他的优点也是非常明显的，可以在更多系统软件场景去探索挖掘，完善实现，建立出基于 Golang 世界的系统软件体系。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218618062-dfebd151-3d05-4cb5-b61c-e3cceeef9b37.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，在解决具体问题的过程中我们积累了不少有值得分享的案例，比如说在大流量场景下动态更新存量链接的配置风险策略，Metrics 平滑迁移，支持多层路由判断的可扩展链式路由等，受限于篇幅无法一一展开，后续我们将通过 blog 或 meetup 的方式与大家分享。&lt;/p&gt;
&lt;h2 id=&#34;4总结--展望&#34;&gt;4、总结 &amp;amp; 展望&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218626784-cec880b1-1ccd-447f-8cc6-96302681fd23.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们再看看微服务场景下 SOFAMosn 落地的方案，首先 SOFAMosn 作为 Sidecar 与 SOFABoot APP 融合代理服务、通信、配置等功能，与蚂蚁的 Control Plane 通信完成服务配置更新。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218632502-24c5e08f-cee2-48ae-a27d-744388ef0c7a.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们再从整体视角看看 MOSN、MOSNG 在蚂蚁架构中的位置。MOSN 作为蚂蚁全新的数据平面，会贯穿网络接入、微服务、安全、Serverless 等场景的落地中。我们将推进东西向，南北向技术架构的融合，形成统一的负载网络。在安全方向上，我们将会在微服务级别的安全保障上做更细致的工作，从 2、3、4、7 层做更多的安全隔离工作，例如做到微服务粒度的流量拦截、牵引。在 Serverless 场景，MOSN 将作为 Serving 的前置提供服务。最后 MOSN 将积极地与用户态加速技术，7 层流量拦截服务等基础能力集成，更好的服务于统一负载网络。
从蚂蚁技术栈演进的视角看，在下一代微服务架构、下一代接入网络、零可信微隔离的技术发展的萌芽之下，MOSN 的出现是必然也是偶然，最终将成为新生技术体系落地过程的重点环节，我们将继续探索，逐步形成适合蚂蚁业务场景的数据平面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218637610-ec08e4e0-420c-4f1f-af82-264c87076597.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我今天要介绍的内容就是这些，欢迎大家关注“金融级分布式架构”，“ServiceMesher”公众号，我们将会有更多技术干货发布在公众号中。同时这里有 SOFAMesh、SOFAMosn 的 Github 地址，欢迎大家 star，或试用，更欢迎大家为我们提出宝贵意见。谢谢大家。
地址：
SOFAMesh: &lt;a href=&#34;https://github.com/alipay/sofa-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/alipay/sofa-mesh&lt;/a&gt;
SOFAMosn: &lt;a href=&#34;https://github.com/alipay/sofa-mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/alipay/sofa-mosn&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ppt-下载&#34;&gt;PPT 下载&lt;/h2&gt;
&lt;p&gt;地址：
&lt;a href=&#34;http://www.sofastack.tech/posts/2018-12-04-01&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.sofastack.tech/posts/2018-12-04-01&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng--left--720x4811881188118812&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2018/png/156645/1543544969503-0a284b24-0a6f-4ff2-9706-093c0cc5cf6b.png&#34; alt=&#34;image.png | left | 720x481.1881188118812&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png | left | 720x481.1881188118812
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（3）——TCP 协议扩展</title>
      <link>https://cloudnativecn.com/blog/x-protocol-tcp-protocol-extension/</link>
      <pubDate>Sun, 14 Oct 2018 14:53:04 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/x-protocol-tcp-protocol-extension/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是 SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列文章之一。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（1）——DNS 通用寻址方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/x-protocol-rapid-decode-forward/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（2）——快速解码转发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/x-protocol-tcp-protocol-extension/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（3）——TCP 协议扩展&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;在 Istio 和 Envoy 中，对通讯协议的支持，主要体现在 HTTP/1.1 和 HTTP/2 上，这两个是 Istio/Envoy 中的一等公民。而基于 HTTP/1.1 的 REST 和基于 HTTP/2 的 gRPC，一个是目前社区最主流的通讯协议，一个是未来的主流，google 的宠儿，CNCF 御用的 RPC 方案，这两个组成了目前 Istio 和 Envoy（乃至 CNCF 所有项目）的黄金组合。&lt;/p&gt;
&lt;p&gt;而我们 SOFAMesh，在第一时间就遇到和 Istio/Envoy 不同的情况，我们需要支持 REST 和 gRPC 之外的众多协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOFARPC：这是蚂蚁金服大量使用的 RPC 协议 (已开源)&lt;/li&gt;
&lt;li&gt;HSF RPC：这是阿里集团内部大量使用的 RPC 协议 (未开源)&lt;/li&gt;
&lt;li&gt;Dubbo RPC: 这是社区广泛使用的 RPC 协议 (已开源)&lt;/li&gt;
&lt;li&gt;其他私有协议：在过去几个月间，我们收到需求，期望在 SOFAMesh 上运行其他 TCP 协议，部分是私有协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为此，我们需要考虑在 SOFAMesh 和 SOFAMosn 中增加这些通讯协议的支持，尤其是要可以让我们的客户非常方便的扩展支持各种私有 TCP 协议：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/x-protocol-tcp-protocol-extension/supported-protocol_hu8922947825122230872.webp 400w,
               /blog/x-protocol-tcp-protocol-extension/supported-protocol_hu7277406872245682737.webp 760w,
               /blog/x-protocol-tcp-protocol-extension/supported-protocol_hu9228957397269479448.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-tcp-protocol-extension/supported-protocol_hu8922947825122230872.webp&#34;
               width=&#34;594&#34;
               height=&#34;485&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;实现分析&#34;&gt;实现分析&lt;/h2&gt;
&lt;p&gt;我们来大体看一下，在 SOFAMesh/Istio 中要新增一个通讯协议需要有哪些工作：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/x-protocol-tcp-protocol-extension/tbd_hu148373051036648928.webp 400w,
               /blog/x-protocol-tcp-protocol-extension/tbd_hu17773021746254140319.webp 760w,
               /blog/x-protocol-tcp-protocol-extension/tbd_hu9512056212887822031.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-tcp-protocol-extension/tbd_hu148373051036648928.webp&#34;
               width=&#34;760&#34;
               height=&#34;327&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;protocol decoder：负责解析协议，读取协议字段&lt;/li&gt;
&lt;li&gt;protocol encoder：负责生成请求报文，注意通常会有改动，比如修改某些 header&lt;/li&gt;
&lt;li&gt;在 pilot 中需要为新协议生成 Virtual Host 等配置，有 inbound 和 outbound 两份，分别下发到 Sidecar&lt;/li&gt;
&lt;li&gt;在 Sidecar 中，根据下发的 Virtual Host 等配置，进行请求匹配，以决定请求该转发到何处&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：实际下发的配置不止 Virtual Host 配置，为了简单起见，我们仅以 Virtual Host 为例做讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中，protocol encoder 和 protocol decoder 是容易理解的，对于新的通讯协议肯定需要有协议编解码层面的工作必须要完成，这块有工作量是很自然的。&lt;/p&gt;
&lt;p&gt;我们来看看第三块的工作量是什么，inbound 和 outbound 的 Virtual Host 配置示例如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/x-protocol-tcp-protocol-extension/outbound_hu9183275080841250750.webp 400w,
               /blog/x-protocol-tcp-protocol-extension/outbound_hu17188554199718176298.webp 760w,
               /blog/x-protocol-tcp-protocol-extension/outbound_hu13251745042161154333.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-tcp-protocol-extension/outbound_hu9183275080841250750.webp&#34;
               width=&#34;760&#34;
               height=&#34;593&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;outbound 配置中，注意 domains 字段是各种域名和 ClusterIP，而 routes 中，match 是通过 prefix 来匹配。我们结合 HTTP/1.1，domains 字段是用来和请求的 Host header 进行域名匹配的，比如 &lt;code&gt;Host: istio-telemetry&lt;/code&gt;，这决定了哪些请求是要转发到 istio-telemetry 这个服务的。routes 的 match 用来进行路由匹配的，通过 HTTP 请求的 path 进行匹配。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/x-protocol-tcp-protocol-extension/inbound_hu11331400421315493730.webp 400w,
               /blog/x-protocol-tcp-protocol-extension/inbound_hu17190055243913245327.webp 760w,
               /blog/x-protocol-tcp-protocol-extension/inbound_hu15766408145321837216.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-tcp-protocol-extension/inbound_hu11331400421315493730.webp&#34;
               width=&#34;760&#34;
               height=&#34;526&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;inbound 配置类似，只是 inbound 更简单，domains 匹配&lt;code&gt;*&lt;/code&gt;就可以。&lt;/p&gt;
&lt;p&gt;从上面的例子中可以看到，Istio 和 Envoy 的设计有非常浓重的 HTTP 协议的味道，各种语义都是和 HTTP 直接相关。而当我们进行 TCP 协议的转发时，就需要将请求的协议字段进行映射，映射到 HTTP 的相应语义。&lt;/p&gt;
&lt;p&gt;比如，最基本的 Destination，原始语义是请求的目的地，在前面的文章中我们指出过这是请求转发最关键的字段。在 HTTP 协议中，通常是通过 Host header 和 Path 表示，对于 REST 而言还有重要的 Method 字段。&lt;/p&gt;
&lt;p&gt;下面的格式是其他各种协议对这个 Destination 原始语义的实际实现方式：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;协议&lt;/th&gt;
          &lt;th&gt;实现&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;原始语义&lt;/td&gt;
          &lt;td&gt;请求的目的地 (Destination)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;HTTP/1.1&lt;/td&gt;
          &lt;td&gt;Host header，Method，Path&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;HTTP/2&lt;/td&gt;
          &lt;td&gt;Header 帧中的伪 header &lt;code&gt;:authority&lt;/code&gt;，&lt;code&gt;:path&lt;/code&gt;和&lt;code&gt;:method&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Bolt 协议&lt;/td&gt;
          &lt;td&gt;header map 中 key 为”service”的字段&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;HSF 协议&lt;/td&gt;
          &lt;td&gt;协议头中的服务接口名和服务方法名&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Dubbo 协议&lt;/td&gt;
          &lt;td&gt;data 字段（payload）中的 path/method&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些通讯协议在下发规则和进行请求匹配时，就需要进行协调：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义好 Virtual Host 配置中的 domains 字段和 route 中的 match 用到的字段在当前通讯协议中的实际语义&lt;/li&gt;
&lt;li&gt;在 protocol encoder 中读取请求的协议字段，和上面的字段对应&lt;/li&gt;
&lt;li&gt;然后进行请求路由规则匹配（参照 HTTP/1.1 中的 domain 和 route match 的匹配）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这些都是需要以代码的方式进行实现，以满足新通讯协议的要求。正规的做法，是每次新增一个通讯协议就将上述的工作内容重复一遍。这会直接导致大量的高度类似的重复代码。&lt;/p&gt;
&lt;h2 id=&#34;x-protocol-的实现&#34;&gt;x-protocol 的实现&lt;/h2&gt;
&lt;p&gt;在上述需要在协议扩展时修改的四个内容中，有一块是特别的：生成 Virtual Host 配置的工作是在 Pilot 中实现的，而其他三个是在 Sidecar（Envoy 或 MOSN）中。考虑到 protocol encoder 和 protocol decoder 的工作是必不可少的，必然会修改 Sidecar 来增加实现代码，因此简化开发的第一个想法就是：能不能做到不修改 Pilot？&lt;/p&gt;
&lt;p&gt;基本思路就是固定好原始语义，避免每个通讯协议都映射一遍。从前面我们列出来的各个协议的映射情况看，对于 RPC 协议而言，一般目的地信息都是服务名 (有些是接口名)+方法名居多，因此可以考虑直接将服务名和方法名固定下来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RPC 协议在 Virtual Host 配置中就固定为服务名对应 domains 字段，方法名对应 route 中的 match 用到的字段，这样只要修改一次然后各个 RPC 协议公用此配置，以后就不用再重复修改 Pilot。&lt;/li&gt;
&lt;li&gt;protocol encoder 在解析通讯协议完成之后，就直接将协议中对应服务名和方法名的字段提取出来，后面的匹配处理过程就可以公用一套通用实现，这样路由匹配这块也可以不用在重复开发。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在 x-protocol 中，如果需要引入一个新的通讯协议，需要的工作内容只有必不可少的 protocol encoder 和 protocol decoder，和实现以下几个接口：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/x-protocol-tcp-protocol-extension/xprotocol-interfaces_hu4203426381438260097.webp 400w,
               /blog/x-protocol-tcp-protocol-extension/xprotocol-interfaces_hu3048577906709066114.webp 760w,
               /blog/x-protocol-tcp-protocol-extension/xprotocol-interfaces_hu5573556725073365288.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-tcp-protocol-extension/xprotocol-interfaces_hu4203426381438260097.webp&#34;
               width=&#34;503&#34;
               height=&#34;517&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;X-protocol 在支持新通讯协议上的做法并无新奇之处，只是由于需求特殊有众多通讯协议需要支持，在开发时发现大量重复工作，因此我们选择了一条可以让后面更舒服一点的道路。&lt;/p&gt;
&lt;p&gt;目前这个方案在 SOFAMesh 中采用，我们将进一步检验实际效果，也会和合作的小伙伴时验证，看他们在自行扩展新协议时是否足够理想。这个方案理论上应该可以同样适用于 Istio、Envoy 体系，随着社区对 Istio 的接受程度的提高，在 Istio 上支持各种 TCP 通讯协议的需求会越来越多，有理由相信 Istio 后续可能也会出现类似的方案。毕竟，每次都改一大堆类似的东西，不是一个好做法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（2）——快速解码转发</title>
      <link>https://cloudnativecn.com/blog/x-protocol-rapid-decode-forward/</link>
      <pubDate>Wed, 10 Oct 2018 11:45:26 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/x-protocol-rapid-decode-forward/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是 SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列文章之一。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（1）——DNS 通用寻址方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/x-protocol-rapid-decode-forward/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（2）——快速解码转发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/x-protocol-tcp-protocol-extension/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（3）——TCP 协议扩展&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 Istio 和 Envoy 中，对通讯协议的支持，主要体现在 HTTP/1.1 和 HTTP/2 上，而我们 SOFAMesh，则需要支持以下几个 RPC 协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOFARPC：这是蚂蚁金服大量使用的 RPC 协议（已开源）&lt;/li&gt;
&lt;li&gt;HSF RPC：这是阿里集团内部大量使用的 RPC 协议（未开源）&lt;/li&gt;
&lt;li&gt;Dubbo RPC: 这是社区广泛使用的 RPC 协议（已开源）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;更适合的平衡点性能和功能&#34;&gt;更适合的平衡点：性能和功能&lt;/h3&gt;
&lt;p&gt;对于服务间通讯解决方案，性能永远是一个值得关注的点。而 SOFAMesh 在项目启动时就明确要求在性能上要有更高的追求，为此，我们不得不在 Istio 标准实现之外寻求可以获取更高性能的方式，比如支持各种 RPC 协议。&lt;/p&gt;
&lt;p&gt;期间有两个发现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Istio在处理所有的请求转发如REST/gRPC时，会解码整个请求的header信息，拿到各种数据，提取为Attribute，然后以此为基础，提供各种丰富的功能，典型如Content Based Routing。&lt;/li&gt;
&lt;li&gt;而在测试中，我们发现：解码请求协议的 header 部分，对 CPU 消耗较大，直接影响性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，我们有了一个很简单的想法：是不是可以在转发时，不开启部分功能，以此换取转发过程中的更少更快的解码消耗？毕竟，不是每个服务都需要用到 Content Based Routing 这样的高级特性，大部分服务只使用 Version Based Routing，尤其是使用 RPC 通讯协议的服务，没有 HTTP 那么表现力丰富的 header，对 Content Based Routing 的需求要低很多。&lt;/p&gt;
&lt;p&gt;此外，对于部分对性能有极高追求的服务，不开启高级特性而换取更高的性能，也是一种满足性能要求的折中方案。考虑到系统中总存在个别服务对性能非常敏感，我们觉得 Service Mesh 提供一种性能可以接近直连的方案会是一个有益的补充。为了满足这些特例而不至于因此整体否决 Service Mesh 方案，我们需要在 Service Mesh 的大框架下提供一个折中方案。&lt;/p&gt;
&lt;h2 id=&#34;请求转发&#34;&gt;请求转发&lt;/h2&gt;
&lt;p&gt;在我们进一步深入前，我们先来探讨一下实现请求转发的技术细节。&lt;/p&gt;
&lt;p&gt;有一个关键问题：当 Envoy/SOFA MOSN 这样的代理程序，接收到来自客户端的 TCP 请求时，需要获得哪些信息，才可以正确的转发请求到上游的服务器端？&lt;/p&gt;
&lt;h3 id=&#34;最关键的信息destination&#34;&gt;最关键的信息：destination&lt;/h3&gt;
&lt;p&gt;首先，毫无疑问的，必须拿到 destination/目的地，也就是客户端请求必须通过某种方式明确的告之代理该请求的 destination，这样代理程序才能根据这个 destionation 去找到正确的目标服务器，然后才有后续的连接目标服务器和转发请求等操作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zu0jen9j30vs0d475q_hu16595229090798416673.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zu0jen9j30vs0d475q_hu1937889132407382780.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zu0jen9j30vs0d475q_hu7331189859521832309.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zu0jen9j30vs0d475q_hu16595229090798416673.webp&#34;
               width=&#34;760&#34;
               height=&#34;314&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Destination 信息的表述形式可能有：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. IP 地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能是服务器端实例实际工作的 IP 地址和端口，也可能是某种转发机制，如 Nginx/HAProxy 等反向代理的地址或者 Kubernetes 中的 ClusterIP。&lt;/p&gt;
&lt;p&gt;举例：“192.168.1.1:8080”是实际 IP 地址和端口，“10.2.0.100:80”是 ngxin 反向代理地址，“172.168.1.105:80”是 Kubernetes 的 ClusterIP。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 目标服务的标识符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可用于名字查找，如服务名，可能带有各种前缀后缀。然后通过名字查找/服务发现等方式，得到地址列表（通常是 IP 地址 + 端口形式）。&lt;/p&gt;
&lt;p&gt;举例：“userservice”是标准服务名， “com.alipay/userservice”是加了域名前缀的服务名， “service.default.svc.cluster.local”是 k8s 下完整的全限定名。&lt;/p&gt;
&lt;p&gt;Destination 信息在请求报文中的携带方式有：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 通过通讯协议传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是最常见的形式，标准做法是通过 header 头，典型如 HTTP/1.1 下一般使用 host header，举例如“Host: userservice”。HTTP/2 下，类似的使用“:authority”header。&lt;/p&gt;
&lt;p&gt;对于非 HTTP 协议，通常也会有类似的设计，通过协议中某些字段来承载目标地址信息，只是不同协议中这个字段的名字各有不同。如 SOFARPC，HSF 等。&lt;/p&gt;
&lt;p&gt;有些通讯协议，可能会将这个信息存放在 payload 中，比如后面我们会介绍到的 dubbo 协议，导致需要反序列化 payload 之后才能拿到这个重要信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 通过 TCP 协议传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一种非常特殊的方式，通过在 TCP option 传递，上一节中我们介绍 Istio DNS 寻址时已经详细介绍过了。&lt;/p&gt;
&lt;h3 id=&#34;tcp-拆包&#34;&gt;TCP 拆包&lt;/h3&gt;
&lt;p&gt;如何从请求的通讯协议中获取 destination？这涉及到具体通讯协议的解码，其中第一个要解决的问题就是如何在连续的 TCP 报文中将每个请求内容拆分开，这里就涉及到经典的 TCP 沾包、拆包问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuc1molj30vw0ayaax_hu7111372456793468023.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuc1molj30vw0ayaax_hu2136221526930679236.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuc1molj30vw0ayaax_hu12841472227534542920.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuc1molj30vw0ayaax_hu7111372456793468023.webp&#34;
               width=&#34;760&#34;
               height=&#34;261&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;转发请求时，由于涉及到负载均衡，我们需要将请求发送给多个服务器端实例。因此，有一个非常明确的要求：就是必须以单个请求为单位进行转发。即单个请求必须完整的转发给某台服务器端实例，负载均衡需要以请求为单位，不能将一个请求的多个报文包分别转发到不同的服务器端实例。所以，拆包是请求转发的必备基础。&lt;/p&gt;
&lt;p&gt;由于篇幅和主题限制，我们不在这里展开 TCP 沾包、拆包的原理。后面针对每个具体的通讯协议进行分析时再具体看各个协议的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;多路复用的关键参数requestid&#34;&gt;多路复用的关键参数：RequestId&lt;/h3&gt;
&lt;p&gt;RequestId 用来关联 request 和对应的 response，请求报文中携带一个唯一的 id 值，应答报文中原值返回，以便在处理 response 时可以找到对应的 request。当然在不同协议中，这个参数的名字可能不同（如 streamid 等）。&lt;/p&gt;
&lt;p&gt;严格说，RequestId 对于请求转发是可选的，也有很多通讯协议不提供支持，比如经典的 HTTP1.1 就没有支持。但是如果有这个参数，则可以实现多路复用，从而可以大幅度提高 TCP 连接的使用效率，避免出现大量连接。稍微新一点的通讯协议，基本都会原生支持这个特性，比如 SOFARPC、Dubbo、HSF，还有 HTTP/2 就直接內建了多路复用的支持。&lt;/p&gt;
&lt;p&gt;HTTP/1.1不支持多路复用（http1.1有提过支持幂等方法的pipeline机制但是未能普及），用的是经典的ping-pong模式：在请求发送之后，必须独占当前连接，等待服务器端给出这个请求的应答，然后才能释放连接。因此HTTP/1.1下，并发多个请求就必须采用多连接，为了提升性能通常会使用长连接+连接池的设计。而如果有了requestid和多路复用的支持，客户端和Mesh之间理论上就可以只用一条连接（实践中可能会选择建立多条）来支持并发请求：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zujxeh7j313x0dwtaz_hu2986955239755459081.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zujxeh7j313x0dwtaz_hu4890038539582506680.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zujxeh7j313x0dwtaz_hu9215134684468927202.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zujxeh7j313x0dwtaz_hu2986955239755459081.webp&#34;
               width=&#34;760&#34;
               height=&#34;264&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而 Mesh 与服务器（也可能是对端的 Mesh）之间，也同样可以受益于多路复用技术，来自不同客户端而去往同一个目的地的请求可以混杂在同一条连接上发送。通过 RequestId 的关联，Mesh 可以正确将 reponse 发送到请求来自的客户端。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuxvz4lj310r0dzwgj_hu10516678681157447745.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuxvz4lj310r0dzwgj_hu3997528419108751635.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuxvz4lj310r0dzwgj_hu6184136219352741526.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zuxvz4lj310r0dzwgj_hu10516678681157447745.webp&#34;
               width=&#34;760&#34;
               height=&#34;289&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;由于篇幅和主题限制，我们不在这里展开多路复用的原理。后面针对每个具体的通讯协议进行分析时再具体看各个协议的支持情况。&lt;/p&gt;
&lt;h3 id=&#34;请求转发参数总结&#34;&gt;请求转发参数总结&lt;/h3&gt;
&lt;p&gt;上面的分析中，我们可以总结到，对于 Sidecar，要正确转发请求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须获取到 destination 信息，得到转发的目的地，才能进行服务发现类的寻址&lt;/li&gt;
&lt;li&gt;必须要能够正确的拆包，然后以请求为单位进行转发，这是负载均衡的基础&lt;/li&gt;
&lt;li&gt;可选的 RequestId，这是开启多路复用的基础&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，这里我们的第一个优化思路就出来了：尽量只解码获取这三个信息，满足转发的基本要求。其他信息如果有性能开销则跳过解码，所谓“快速解码转发”。基本原理就是牺牲信息完整性追求性能最大化。&lt;/p&gt;
&lt;p&gt;而结合上一节中我们引入的 DNS 通用寻址方案，我们是可以从请求的 TCP options 中得到 ClusterIP，从而实现寻址。这个方式可以实现不解码请求报文，尤其是 header 部分解码 destination 信息开销大时。这是我们的第二个优化思路：跳过解码 destination 信息，直接通过 ClusterIP 进行寻址。&lt;/p&gt;
&lt;p&gt;具体的实现则需要结合特定通讯协议的实际情况进行。&lt;/p&gt;
&lt;h2 id=&#34;主流通讯协议&#34;&gt;主流通讯协议&lt;/h2&gt;
&lt;p&gt;现在我们开始，以 Proxy、Sidecar、Service Mesh 的角度来看看目前主流的通讯协议和我们前面列举的需要在 SOFAMesh 中支持的几个协议。&lt;/p&gt;
&lt;h3 id=&#34;sofarpcbolt协议&#34;&gt;SOFARPC/bolt协议&lt;/h3&gt;
&lt;p&gt;SOFARPC 是一款基于 Java 实现的 RPC 服务框架，详细资料可以查阅 官方文档。SOFARPC 支持 bolt，rest，dubbo 协议进行通信。REST、dubbo 后面单独展开，这里我们关注 bolt 协议。&lt;/p&gt;
&lt;p&gt;bolt 是蚂蚁金服集团开放的基于 Netty 开发的网络通信框架，其协议格式是变长，即协议头+payload。具体格式定义如下，以 request 为例（response 类似）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zv3sqhij312j0833zq_hu11316910219480969855.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zv3sqhij312j0833zq_hu11030177307992353777.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zv3sqhij312j0833zq_hu2422683456690569084.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zv3sqhij312j0833zq_hu11316910219480969855.webp&#34;
               width=&#34;760&#34;
               height=&#34;160&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们只关注和请求转发直接相关的字段：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP 拆包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bolt 协议是定长 + 变长的复合结构，前面 22 个字节长度固定，每个字节和协议字段的对应如图所示。其中 classLen、headerLen 和 contentLen 三个字段指出后面三个变长字段 className、header、content 的实际长度。和通常的变长方案相比只是变长字段有三个。拆包时思路简单明了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先读取前 22 个字节，解出各个协议字段的实际值，包括 classLen，headerLen 和 contentLen&lt;/li&gt;
&lt;li&gt;按照 classLen、headerLen 和 contentLen 的大小，继续读取 className、header、content&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Destination&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bolt 协议中的 header 字段是一个 map，其中有一个 key 为“service”的字段，传递的是接口名/服务名。读取稍微麻烦一点点，需要先解码整个 header 字段，这里对性能有影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RequestId&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Blot 协议固定字段中的&lt;code&gt;requestID&lt;/code&gt;字段，可以直接读取。&lt;/p&gt;
&lt;p&gt;SOFARPC 中的 bolt 协议，设计的比较符合请求转发的需要，TCP 拆包，读取 RequestID，都没有性能问题。只是 Destination 的获取需要解码整个 header，性能开销稍大。&lt;/p&gt;
&lt;p&gt;总结：适合配合 DNS 通用解码方案，跳过对整个 header 部分的解码，从而提升性能。当然由于这个 header 本身也不算大，优化的空间有限，具体提升需要等对比测试的结果出来。&lt;/p&gt;
&lt;h3 id=&#34;hsf-协议&#34;&gt;HSF 协议&lt;/h3&gt;
&lt;p&gt;HSF 协议是经过精心设计工作在 4 层的私有协议，由于该协议没有开源，因此不便直接暴露具体格式和字段详细定义。&lt;/p&gt;
&lt;p&gt;不过基本的设计和 bolt 非常类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用变长格式，即协议头+payload&lt;/li&gt;
&lt;li&gt;在协议头中可以直接拿到服务接口名和服务方法名作为 Destination&lt;/li&gt;
&lt;li&gt;有 RequestID 字段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本和 bolt 一致，考虑到 Destination 可以直接读取，比 bolt 还要方便一些，HSF 协议可以说是对请求转发最完美的协议。&lt;/p&gt;
&lt;p&gt;总结：目前的实现方案也只解码了这三个关键字段，速度足够快，不需要继续优化。&lt;/p&gt;
&lt;h3 id=&#34;dubbo-协议&#34;&gt;Dubbo 协议&lt;/h3&gt;
&lt;p&gt;Dubbo 协议也是类似的协议头+payload 的变长结构，其协议格式如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvfi4g9j30oh03gmxj_hu2177621619828147734.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvfi4g9j30oh03gmxj_hu14623112270670110204.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvfi4g9j30oh03gmxj_hu3993479085226785374.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvfi4g9j30oh03gmxj_hu2177621619828147734.webp&#34;
               width=&#34;760&#34;
               height=&#34;107&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其中 long 类型的&lt;code&gt;id&lt;/code&gt;字段用来把请求 request 和返回的 response 对应上，即我们所说的&lt;code&gt;RequestId&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这样 TCP 拆包和多路复用都轻松实现，稍微麻烦一点的是：Destination 在哪里？Dubbo 在这里的设计有点不够理想，在协议头中没有字段可以直接读取到 Destination，需要去读取 data 字段，也就是 payload，里面的 path 字段通常用来保存服务名或者接口名。method 字段用来表示方法名。&lt;/p&gt;
&lt;p&gt;从设计上看，path 字段和 method 字段被存放在 payload 中有些美中不足。庆幸的是，读取这两个字段的时候不需要完整的解开整个 payload，好险，不然，那性能会没法接受的。&lt;/p&gt;
&lt;p&gt;以 hession2 为例，data 字段的组合是：dubbo version + path + interface version + method + ParameterTypes + Arguments + Attachments。每个字段都是一个 byte 的长度 + 字段值的 UTF bytes。因此读取时并不复杂，速度也足够快。&lt;/p&gt;
&lt;p&gt;基本和 HSF 一致，就是 Destination 的读取稍微麻烦一点，放在 payload 中的设计让人吓了一跳，好在有惊无险。整体说还是很适合转发的。&lt;/p&gt;
&lt;p&gt;总结：同 HSF，不需要继续优化。&lt;/p&gt;
&lt;h3 id=&#34;http11&#34;&gt;HTTP/1.1&lt;/h3&gt;
&lt;p&gt;HTTP/1.1的格式应该大家都熟悉，而在这里，不得不指出，HTTP/1.1协议对请求转发是非常不友好的（甚至可以说是恶劣！）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP 请求在拆包时，需要先按照 HTTP header 的格式，一行一行读取，直到出现空行表示 header 结束&lt;/li&gt;
&lt;li&gt;然后必须将整个 header 的内容全部解析出来，才能取出&lt;code&gt;Content-Length header&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Content-Length&lt;/code&gt; 值，才能完成对 body 内容的读取，实现正确拆包&lt;/li&gt;
&lt;li&gt;如果是 chunked 方式，则更复杂一些&lt;/li&gt;
&lt;li&gt;Destination 通常从&lt;code&gt;Host&lt;/code&gt; header 中获取&lt;/li&gt;
&lt;li&gt;没有 RequestId，完全无法实现多路复用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这意味着，为了完成最基本的 TCP 拆包，必须完整的解析全部的 HTTP header 信息，没有任何可以优化的空间。对比上面几个 RPC 协议，轻松自如的快速获取几个关键信息，HTTP 无疑要重很多。这也造成了在 ServiceMesh 下，HTTP/1.1 和 REST 协议的性能总是和其他 RPC 方案存在巨大差异。&lt;/p&gt;
&lt;p&gt;对于注定要解码整个 header 部分，完全没有优化空间可言的 HTTP/1.1 协议来说，Content Based Routing 的解码开销是必须付出的，无论是否使用 Content Based Routing。因此，快速解码的构想，对 HTTP/1.1 无效。&lt;/p&gt;
&lt;p&gt;总结：受 HTTP/1.1 协议格式限制，上述两个优化思路都无法操作。&lt;/p&gt;
&lt;h3 id=&#34;http2和grpc&#34;&gt;HTTP/2和gRPC&lt;/h3&gt;
&lt;p&gt;作为HTTP/1.1的接班人，HTTP/2则表现的要好很多。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：当然 HTTP/2 的协议格式复杂多了，由于篇幅和主题的限制，这里不详细介绍 HTTP/2 的格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先HTTP/2是以帧的方式组织报文的，所有的帧都是变长，固定的9个字节+可变的payload，Length字段指定payload的大小：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvsjz65j30jg0650tg_hu13677856098877281023.webp 400w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvsjz65j30jg0650tg_hu3474016938300522598.webp 760w,
               /blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvsjz65j30jg0650tg_hu10402703608312404714.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-rapid-decode-forward/006tNbRwly1fw2zvsjz65j30jg0650tg_hu13677856098877281023.webp&#34;
               width=&#34;700&#34;
               height=&#34;221&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;HTTP2 的请求和应答，也被称为 Message，是由多个帧构成，在去除控制帧之外，Message 通常由 Header 帧开始，后面接 CONTINUATION 帧和 Data 帧（也可能没有，如 GET 请求）。每个帧都可以通过头部的 Flags 字段来设置 END_STREAM 标志，表示请求或者应答的结束。即 TCP 拆包的问题在 HTTP/2 下是有非常标准而统一的方式完成，完全和 HTTP/2 上承载的协议无关。&lt;/p&gt;
&lt;p&gt;HTTP/2通过Stream內建多路复用，这里的&lt;code&gt;Stream Identifier&lt;/code&gt; 扮演了类似前面的&lt;code&gt;RequestId&lt;/code&gt;的角色。&lt;/p&gt;
&lt;p&gt;而 Destination 信息则通过 Header 帧中的伪 header &lt;code&gt;:authority&lt;/code&gt; 来传递，类似 HTTP/1.1 中的&lt;code&gt;Host&lt;/code&gt; header。不过 HTTP/2 下 header 会进行压缩，读取时稍微复杂一点，也存在需要解压缩整个 header 帧的性能开销。考虑到拆包和获取 RequestId 都不需要解包（只需读取协议头，即 HTTP/2 帧的固定字段），速度足够快，因此存在很大的优化空间：不解码 header 帧，直接通过 DNS 通用寻址方案，这样性能开销大为减少，有望获得极高的转发速度。&lt;/p&gt;
&lt;p&gt;总结：HTTP/2 的帧设计，在请求转发时表现的非常友好。唯独 Destination 信息放在 header 中，会造成必须解码 header 帧。好在 DNS 通用寻址方案可以弥补，实现快速解码和转发。&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-时代的-rpc-理想方案&#34;&gt;Service Mesh 时代的 RPC 理想方案&lt;/h2&gt;
&lt;p&gt;在文章的最后，我们总结并探讨一下，对于 Service Mesh 而言，什么样的 RPC 方案是最理想的？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须可以方便做 TCP 拆包，最好在协议头中就简单搞定，标准方式如固定协议头+length 字段 + 可变 payload。HSF 协议、bolt 协议和 dubbo 协议表现完美，HTTP/2 采用帧的方式，配合 END_STREAM 标志，方式独特但有效。HTTP/1.1 则是反面典型。&lt;/li&gt;
&lt;li&gt;必须可以方便的获取 destination 字段，同样最好在协议头中就简单搞定。HSF 协议表现完美，dubbo 协议藏在 payload 中但终究还是可以快速解码有惊无险的过关，bolt 协议和 HTTP/2 协议就很遗憾必须解码 header 才能拿到，好在 DNS 通用寻址方案可以弥补，但终究丢失了服务名和方法名信息。HTTP/1.1 依然是反面典型。&lt;/li&gt;
&lt;li&gt;最好有 RequestId 字段，同样最好在协议头中就简单搞定。这方面 HSF 协议、dubbo 协议、bolt 协议表现完美，HTTP/2 协议更是直接內建支持。HTTP/1.1 继续反面典型。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，仅以方便用最佳性能进行转发，对 Service Mesh、sidecar 友好而言，最理想的 RPC 方案是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统的变长协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;固定协议头+length 字段 + 可变 payload，然后在固定协议头中直接提供 RequestId 和 destination。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于帧的协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以HTTP/2为基础，除了请求结束的标志位和RequestId外，还需要通过帧的固定字段来提供destination信息。&lt;/p&gt;
&lt;p&gt;或许，在未来，在 Service Mesh 普及之后，对 Service Mesh 友好成为 RPC 协议的特别优化方向，我们会看到表现完美更适合 Service Mesh 时代的新型 RPC 方案。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（1）——DNS 通用寻址方案</title>
      <link>https://cloudnativecn.com/blog/x-protocol-common-address-solution/</link>
      <pubDate>Mon, 08 Oct 2018 14:58:03 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/x-protocol-common-address-solution/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是 SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列文章之一。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（1）——DNS 通用寻址方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/x-protocol-rapid-decode-forward/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（2）——快速解码转发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/x-protocol-tcp-protocol-extension/&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列（3）——TCP 协议扩展&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 2018 年上半年，蚂蚁金服决定基于 Istio 订制自己的 ServiceMesh 解决方案，在 6 月底对外公布了 SOFAMesh，详情请见之前的文章：&lt;a href=&#34;https://skyao.io/publication/201806-service-mesh-explore/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大规模微服务架构下的 Service Mesh 探索之路&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;在 SOFAMesh 的开发过程中，针对遇到的实际问题，我们给出了一套名为 x-protocol 的解决方案，定位是云原生、高性能、低侵入性的通用 Service Mesh 落地方案，依托 Kubernetes 基座，利用其原生的服务注册和服务发现机制，支持各种私有 RPC 协议低成本、易扩展的接入，快速享受 Service Mesh 所带来的红利。&lt;/p&gt;
&lt;p&gt;具体解决的问题包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多通讯协议支持问题，减少开发工作量，简单快捷的接入新协议&lt;/li&gt;
&lt;li&gt;尽量提升性能，提供更灵活的性能与功能的平衡点选择，满足特定高性能场景&lt;/li&gt;
&lt;li&gt;兼容现有 SOA 体系，提供通过接口进行访问的方式，实现不修改业务代码也能顺利接入 Service Mesh&lt;/li&gt;
&lt;li&gt;支持单进程多服务的传统 SOA 程序，可以在微服务改造之前，先受益于 Service Mesh 带来的强大功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本系列文章中，我们将对此进行详细的讲解，首先是“DNS 通用寻址方案”。&lt;/p&gt;
&lt;h2 id=&#34;背景和需求&#34;&gt;背景和需求&lt;/h2&gt;
&lt;h3 id=&#34;soa-的服务模型&#34;&gt;SOA 的服务模型&lt;/h3&gt;
&lt;p&gt;在 SOFAMesh 计划支持的 RPC 框架中，SOFARPC、HSF、Dubbo 都是一脉相承的 SOA 体系，也都支持经典的 SOA 服务模型，通常称为”单进程多服务”，或者叫做”单进程多接口”。（备注：由于服务一词使用过于频繁，下文都统一称为接口以便区分）&lt;/p&gt;
&lt;p&gt;SOA 标准的服务注册，服务发现和调用流程如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201809-xprotocol-common-address-solution/images/soa-standard-process.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在单个 SOA 应用进程内，存在多个接口&lt;/li&gt;
&lt;li&gt;服务注册时，以接口为单位进行多次独立的服务注册&lt;/li&gt;
&lt;li&gt;当客户端进行调用时，按照接口进行服务发现，然后发起调用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当我们试图将这些 SOA 架构的应用搬迁到 ServiceMesh 时，就会遇到服务模型的问题：微服务是单服务模型，也就是一个进程里面只承载一个服务。以 Kubernetes 的服务注册为例，在单进程单服务的模型下，服务名和应用名可以视为一体，Kubernetes 的自动服务注册会将应用名作为服务注册的标示。&lt;/p&gt;
&lt;p&gt;这就直接导致了 SOA 模型和微服务模型的不匹配问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOA 以接口为单位做服务注册和服务发现，而微服务下是服务名&lt;/li&gt;
&lt;li&gt;SOA 是”单进程多接口”，而微服务是”单进程单服务”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一步接一步的需求&#34;&gt;一步接一步的需求&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先上车后补票&lt;/p&gt;
&lt;p&gt;最理想的做法当然是先进行微服务改造，实现微服务拆分。但是考虑到现有应用数量众多，我们可能更愿意在大规模微服务改造之前，先想办法让这些应用可以运行在 ServiceMesh 下，提前受益于 Service Mesh 带来的强大功能。因此，我们需要找到一个合适的方案，让 ServiceMesh 支持没有做微服务改造依然是”单进程多接口”形式的传统 SOA 应用，所谓”先上车后补票”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不修改代码&lt;/p&gt;
&lt;p&gt;考虑到原有的 SOA 应用，相互之间错综复杂的调用关系，最好不要修改代码，即保持客户端依然通过接口名来访问的方式。当然，SOA 架构的客户端 SDK 可能要进行改动，将原有的通过接口名进行服务发现再自行负载均衡进行远程调用的方式，精简为标准的 Servicemesh 调用（即走 Sidecar），因此修改 SDK 依赖包和重新打包应用是不可避免。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持带特殊字符的接口名&lt;/p&gt;
&lt;p&gt;Kubernetes 的服务注册，Service 名是不能携带”.“号的。而 SOA 架构下，接口名有时出于管理方便，有可能是加了域名前缀，如”com.alipay.demo.interface-2”。为了实现不修改原有代码，就只能想办法支持这种带特殊字符的接口名。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考-kubernetes-和-istio&#34;&gt;参考 Kubernetes 和 Istio&lt;/h2&gt;
&lt;p&gt;在进一步讨论解决方案之前，我们先来看一下 kubernetes 和 Istio 中的标准请求寻址方式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：过程稍显复杂，涉及到 Kubernetes/Istio 的一些底层细节。但是了解这个过程对后续的理解非常重要，也可以帮助大家了解 Kubernetes 和 Kubernetes 的工作原理，强烈推荐阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;kubernetes-下的-dns-寻址方式&#34;&gt;Kubernetes 下的 DNS 寻址方式&lt;/h3&gt;
&lt;p&gt;在 Kubernetes 下，如图所示，假定我们部署了一个名为 userservice 的应用，有三个实例，分别在三个 pod 中。则应用部署之后，Kubernetes 会为这个应用分配 ClusterIP 和域名，并在 DNS 中生成一条 DNS 记录，将域名映射到 ClusterIP：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kubernetes-下的-dns-寻址方式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kubernetes 下的 DNS 寻址方式&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u1crhhoj30zz0grad5_hu5245460484958402320.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u1crhhoj30zz0grad5_hu5260408240694602437.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u1crhhoj30zz0grad5_hu15606559864490243573.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/006tNbRwly1fw0u1crhhoj30zz0grad5_hu5245460484958402320.webp&#34;
               width=&#34;760&#34;
               height=&#34;354&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kubernetes 下的 DNS 寻址方式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当部署在 Kubernetes 下的某个充当客户端的应用发起请求时，如图中的 HTTP GET 请求，目标 URL 地址为“&lt;a href=&#34;http://userservice/id/1000221&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://userservice/id/1000221&lt;/a&gt;&amp;quot;。请求的寻址方式和过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先进行域名解析，分别尝试解析”userservice”/“userservie.default.svc.cluster.local”等域名，得到 ClusterIP&lt;/li&gt;
&lt;li&gt;然后客户端发出请求的报文，目标地址为 ClusterIP，源地址为当前客户端所在的 pod IP（简单起见，端口先忽略）&lt;/li&gt;
&lt;li&gt;请求报文随即被 kube-proxy 拦截，kube-proxy 根据 ClusterIP，拿到 ClusterIP 对应的多个实际服务实例所在的 pod ip，取其中一个，修改目标地址为这个 pod IP&lt;/li&gt;
&lt;li&gt;请求报文最终就被发送到服务实例所在的 pod IP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应答回来的方式类似，userservice 发出的应答报文会被 kube-proxy 拦截并修改为发送到客户端所在的 pod IP。&lt;/p&gt;
&lt;p&gt;我们详细看一下请求和应答全称的四个请求包的具体内容（简单起见继续忽略端口）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kubernetes-dns-寻址&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kubernetes DNS 寻址&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u1t6ucmj31an0hs79k_hu5731002030198952502.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u1t6ucmj31an0hs79k_hu13676932617114857849.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u1t6ucmj31an0hs79k_hu17363668050287708838.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/006tNbRwly1fw0u1t6ucmj31an0hs79k_hu5731002030198952502.webp&#34;
               width=&#34;760&#34;
               height=&#34;290&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kubernetes DNS 寻址
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;重点关注请求和应答报文的源地址和目标地址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发出的请求，为”客户端到 ClusterIP”&lt;/li&gt;
&lt;li&gt;kube-proxy 拦截到请求后，将请求修改为”客户端到服务器端”&lt;/li&gt;
&lt;li&gt;服务器端收到请求时，表现为”客户端到服务器端”，ClusterIP 被 kube-proxy 屏蔽&lt;/li&gt;
&lt;li&gt;服务器端发送应答，因为收到的请求看似来自客户端，因此应答报文为”服务器端到客户端”&lt;/li&gt;
&lt;li&gt;应答报文被 kube-proxy 拦截，将应答修改为”ClusterIP 到服务器端”&lt;/li&gt;
&lt;li&gt;客户端收到应答，表现为”ClusterIP 到服务器端”，服务器端 IP 被 kube-proxy 屏蔽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;kube-proxy 在客户端和服务器端之间拦截并修改请求和应答的报文，联通两者，但各自屏蔽了一些信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在客户端看来它是在和 ClusterIP 交互，userservice 的具体服务器端实例对客户端是无感知的&lt;/li&gt;
&lt;li&gt;在服务器端看来，客户端是直接在和它交互，ClusterIP 的存在对服务器端是无感知的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更深入一步，看 kube-proxy 在两个拦截和修改报文中的逻辑处理关系，即 kube-proxy 是如何在收到应答时正确的找回原有的 ClusterIP：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-与-clusterip&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kube-proxy 与 ClusterIP&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u2dtdpuj317q0fhtcw_hu2029006950029865122.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u2dtdpuj317q0fhtcw_hu4352448221679612734.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u2dtdpuj317q0fhtcw_hu14046169307936967205.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/006tNbRwly1fw0u2dtdpuj317q0fhtcw_hu2029006950029865122.webp&#34;
               width=&#34;760&#34;
               height=&#34;269&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      kube-proxy 与 ClusterIP
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在拦截并修改请求报文之后，kube-proxy 会保存报文修改的 5 元组对应关系（5 元组指源 IP 地址，源端口，协议，目的地 IP 地址，目的地端口）&lt;/li&gt;
&lt;li&gt;在收到应答报文后，根据应答报文中的 5 元组，在保存的 5 元组对应关系中，找到对应信息，得到原有的 ClusterIP 和端口，然后修改应答报文&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结，通过上述 Kubernetes 下的寻址方式，客户端只需发送带简单寻址信息的请求（如“&lt;a href=&#34;http://userservice/id/1000221%22&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://userservice/id/1000221&amp;quot;&lt;/a&gt; 中的”userservice” ），就可以寻址到正确的服务器端。这期间有两个关注点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过 DNS，建立了域名和 ClusterIP 的关系。&lt;/p&gt;
&lt;p&gt;对于客户端，这是它能看到的内容，非常的简单，域名、DNS 是非常容易使用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而通过 kube-proxy 的拦截和转发，又打通了 ClusterIP 和服务器端实际的 Pod IP&lt;/p&gt;
&lt;p&gt;对于客户端，这些是看不到的内容，不管有多复杂，都是 Kubernetes 在底层完成，对客户端，或者说使用者透明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以客户端的视角看来，这个 DNS 寻址方式非常的简单直白：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-与-dns&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kube-proxy 与 DNS&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u2vhim9j319d0c8goz_hu1492205272194606524.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u2vhim9j319d0c8goz_hu13137042730641756976.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u2vhim9j319d0c8goz_hu14768077507583255774.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/006tNbRwly1fw0u2vhim9j319d0c8goz_hu1492205272194606524.webp&#34;
               width=&#34;760&#34;
               height=&#34;204&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      kube-proxy 与 DNS
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;istio-的-dns-寻址方式&#34;&gt;Istio 的 DNS 寻址方式&lt;/h2&gt;
&lt;p&gt;Istio 的请求寻址方式和普通 kubernetes 非常相似，原理相同，只是 kube-proxy 被 sidecar 取代，然后 sidecar 的部署方式是在 pod 内部署，而且客户端和服务器端各有一个 sidecar。其他基本一致，除了图中红色文本的部分：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-的-dns-寻址方式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio 的 DNS 寻址方式&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u3qux0gj31bg0ijgrw_hu9063441160744045683.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u3qux0gj31bg0ijgrw_hu5201133850897809455.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u3qux0gj31bg0ijgrw_hu18397010341504573636.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/006tNbRwly1fw0u3qux0gj31bg0ijgrw_hu9063441160744045683.webp&#34;
               width=&#34;760&#34;
               height=&#34;297&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio 的 DNS 寻址方式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iptables 在劫持流量时，除了将请求转发到 localhost 的 Sidecar 处外，还额外的在请求报文的 TCP options 中将 ClusterIP 保存为 original dest。&lt;/li&gt;
&lt;li&gt;在 Sidecar（Istio 默认是 Envoy）中，从请求报文 TCP options 的 original dest 处获取 ClusterIP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 TCP options 的 original dest，iptables 就实现了在劫持流量到 Sidecar 的过程中，额外传递了 ClusterIP 这个重要参数。Istio 为什么要如此费力的传递这个 ClusterIP 呢？&lt;/p&gt;
&lt;p&gt;看下图就知道了，这是一个 Virtual Host 的示例，Istio 通过 Pilot 将这个规则发送给 Sidecar/Envoy，依靠这个信息来匹配路由请求找到处理请求的 cluster：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-中的-pilot-注册信息&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio 中的 Pilot 注册信息&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u495625j30rd0ldgot_hu17785581867930629578.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u495625j30rd0ldgot_hu1588201009244461265.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u495625j30rd0ldgot_hu17785845907660687928.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/006tNbRwly1fw0u495625j30rd0ldgot_hu17785581867930629578.webp&#34;
               width=&#34;760&#34;
               height=&#34;593&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio 中的 Pilot 注册信息
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;domains 中，除了列出域名外，还有一个特殊的 IP 地址，这个就是 Kubernetes 服务的 ClusterIP！因此，Sidecar 可以通过前面传递过来的 ClusterIP 在这里进行路由匹配（当然也可以从报文中获取 destination 然后通过域名匹配）。&lt;/p&gt;
&lt;p&gt;总结，Istio 延续了 Kubernetes 的寻址方式，客户端同样只需发送带简单寻址信息的请求，就可以寻址到正确的服务器端。这期间同样有两个关注点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过 DNS，建立了域名和 ClusterIP 的关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 ClusterIP 和 Pilot 下发给 Virtual Host 的配置，Sidecar 可以完成路由匹配，将 ClusterIP 和目标服务器关联起来&lt;/p&gt;
&lt;p&gt;同样，对于客户端，这些是看不到的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，以客户端的视角看来，Istio 的这个 DNS 寻址方式同样的简单直白！&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-客户端请求&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;客户端请求&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5cxd61j30st03wmxk_hu2175575208555374296.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5cxd61j30st03wmxk_hu6748251830230891580.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5cxd61j30st03wmxk_hu8569468339991494317.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/006tNbRwly1fw0u5cxd61j30st03wmxk_hu2175575208555374296.webp&#34;
               width=&#34;760&#34;
               height=&#34;103&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      客户端请求
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;dns-通用寻址方案&#34;&gt;DNS 通用寻址方案&lt;/h2&gt;
&lt;h3 id=&#34;解决问题的思路&#34;&gt;解决问题的思路&lt;/h3&gt;
&lt;p&gt;在详细讲述了 Kubernetes 和 Istio 的 DNS 寻址方案之后，我们继续回到我们的主题，我们要解决的问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何在不修改代码，继续使用接口的情况下，实现在 Service Mesh上运行现有的Dubbo/HSF/SOFA等传统SOA应用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-dns-通用寻址方案&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;DNS 通用寻址方案&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5kyafgj30zz0grad5_hu5245460484958402320.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5kyafgj30zz0grad5_hu5260408240694602437.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5kyafgj30zz0grad5_hu15606559864490243573.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/006tNbRwly1fw0u5kyafgj30zz0grad5_hu5245460484958402320.webp&#34;
               width=&#34;760&#34;
               height=&#34;354&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      DNS 通用寻址方案
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里有一个关键点：Kubernetes 的服务注册是以基于 Service 或者说基于应用 (app name)，而我们的客户端代码是基于接口的。因此，在 Virtual Host 进行路由匹配时，是不能通过域名匹配的。当然，这里理论上还有一个思路，就是将接口注册为 Kubernetes Service。但是，还记得要支持接口特殊字符的需求吗？带点号的接口名，Kubernetes 是不能接受它作为 Service Name 的，直接堵死了将接口名注册到 Kubernetes Service 的道路。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-中注册的服务名称&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio 中注册的服务名称&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5v7kktj30rd0ldgot_hu17785581867930629578.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5v7kktj30rd0ldgot_hu1588201009244461265.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u5v7kktj30rd0ldgot_hu17785845907660687928.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/006tNbRwly1fw0u5v7kktj30rd0ldgot_hu17785581867930629578.webp&#34;
               width=&#34;760&#34;
               height=&#34;593&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio 中注册的服务名称
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这样，我们就只有一条路可以走了：效仿 Istio 的做法，通过 ClusterIP 匹配！&lt;/p&gt;
&lt;p&gt;而要将接口名（如”com.alipay.demo.interface-1”）和 ClusterIP 关联，最简单直接的方式就是&lt;strong&gt;打通 DNS&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sidecar-注册-dns-名称&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Sidecar 注册 DNS 名称&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u6cxesmj31fn0ffgqm_hu2244197986115660717.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u6cxesmj31fn0ffgqm_hu2545333944335600773.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u6cxesmj31fn0ffgqm_hu4961338099553871936.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/006tNbRwly1fw0u6cxesmj31fn0ffgqm_hu2244197986115660717.webp&#34;
               width=&#34;760&#34;
               height=&#34;227&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Sidecar 注册 DNS 名称
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;只需要在 DNS 记录中，增加接口到 ClusterIP 的映射，然后就可以完全延续 Istio 的标准做法！其他的步骤，如域名解析到 ClusterIP，iptables 拦截并传递 ClusterIP，sidecar 读取 ClusterIP 并匹配路由，都完全可以重用原有方案。&lt;/p&gt;
&lt;h3 id=&#34;具体实现方案&#34;&gt;具体实现方案&lt;/h3&gt;
&lt;p&gt;实现时，我们选择了使用 CoreDNS 作为 Kubernetes 的 DNS 解决方案，然后通过 Service Controller 操作 CoreDNS 的记录来实现 DNS 解析。&lt;/p&gt;
&lt;p&gt;为了收集到 SOA 应用的接口信息，我们还提供了一个 Register Agent 给 Service Controller 收集信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-通过-coredns-注册接口名称&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;通过 CoreDNS 注册接口名称&#34; srcset=&#34;
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u6rzjygj30lb0dc75f_hu15858468167016016920.webp 400w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u6rzjygj30lb0dc75f_hu12819776995245023727.webp 760w,
               /blog/x-protocol-common-address-solution/006tNbRwly1fw0u6rzjygj30lb0dc75f_hu4537872358302529612.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/x-protocol-common-address-solution/006tNbRwly1fw0u6rzjygj30lb0dc75f_hu15858468167016016920.webp&#34;
               width=&#34;760&#34;
               height=&#34;476&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      通过 CoreDNS 注册接口名称
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;详细的实现方案，不在本文中重复讲述，请参阅我们之前的分享文章 &lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzUzMzU5Mjc1Nw==&amp;amp;mid=2247484175&amp;amp;idx=1&amp;amp;sn=5cb26b1afe615ac7e06b2ccbee6235b3&amp;amp;chksm=faa0ecd5cdd765c3f285bcb3b23f4f1f3e27f6e99021ad4659480ccc47f9bf25a05107f4fee2&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0828t5isWXmyeWhTeoAoeogw&amp;amp;pass_ticket=DqnjSkiuBZW9Oe68Fjiq%2Bqa6fFCyysQTR7Qgd8%2BX9FfooybAg7NXVAQdLmfG6gRX#rd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFAMesh 的通用协议扩展&lt;/a&gt; 中的 DNS 寻址方案一节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：暂时修改 CoreDNS 记录的方式是直接修改 CoreDNS 的底层数据，不够优雅。未来将修改为通过 CoreDNS 的 Dynamic updates API 接口进行，不过 CoreDNS 的这个 API 还在开发中，需要等待完成。详情见&lt;a href=&#34;https://github.com/coredns/coredns/pull/1822&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;单进程多接口问题的解决&#34;&gt;单进程多接口问题的解决&lt;/h3&gt;
&lt;p&gt;上面的解决方案，在解决通过接口实现访问的同时，也将”单进程多接口”的问题一起解决了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原 SOA 应用上 Kubernetes 时，可以注册为标准的 Kubernetes Service，获取 ClusterIP。此时使用应用名注册，和接口无关。&lt;/li&gt;
&lt;li&gt;通过操作 CoreDNS，我们将该 SOA 应用的各个接口都添加为 DNS 记录，指向该应用的 ClusterIP&lt;/li&gt;
&lt;li&gt;当客户端代码使用不同的接口名访问时，DNS 解析出来的都是同一个 ClusterIP，后续步骤就和接口名无关了&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;欠缺微服务改造带来的限制&#34;&gt;欠缺微服务改造带来的限制&lt;/h3&gt;
&lt;p&gt;需要特别指出的是，DNS 通用寻址方案虽然可以解决使用接口名访问和支持单进程多接口的问题，但是这种方案只是完成了“寻址”，也就是打通端到端的访问通道。由于应用没有进行微服务改造，部署上是依然一个应用（体现为一个进程，在 Kubernetes 上体现为一个 Service）中包含多个接口，本质上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务注册依然是以应用名为基础，对应的 Kubernetes service 和 service 上的 label 也是应用级别&lt;/li&gt;
&lt;li&gt;因此提供的服务治理功能，也是以 Kubernetes 的 Service 为基本单位，包括灰度，蓝绿，版本拆分等所有的 Version Based Routing 功能&lt;/li&gt;
&lt;li&gt;这意味着，只能进行&lt;strong&gt;应用级别&lt;/strong&gt;的服务治理，而不能继续细分到&lt;strong&gt;接口级别&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个限制来源于应用没有进行微服务改造，没有按照接口将应用拆分为多个独立的微服务，因此无法得到更小的服务治理粒度。这也就是我们前面说的“先上车后补票”的含义：在微服务改造前，先获得 Service Mesh 的服务治理的绝大部分功能，再慢慢进行微服务改造。&lt;/p&gt;
&lt;h2 id=&#34;dns-通用寻址方案-1&#34;&gt;DNS 通用寻址方案&lt;/h2&gt;
&lt;p&gt;我们将这个方案称为”DNS 通用寻址方案”，是因为这个方案真的非常的通用，体现在以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对使用者来说，通过域名和 DNS 解析的方式来访问，是非常简单直白而易于接受的，同时也是广泛使用的，适用于各种语言、平台、框架&lt;/li&gt;
&lt;li&gt;这个方案延续了 Kubernetes 和 Istio 的做法，保持了一致的方式，对用户提供了相同的体验&lt;/li&gt;
&lt;li&gt;这个寻址方案，不仅仅可以用于 Dubbo、SOFA、HSF 等 RPC 框架往 Service Mesh 的迁移，也可以适用于基于 HTTP/REST 协议的 SOA 应用，甚至最传统的 web 应用（例如 tomcat 下部署多个 war 包）迁移到 Service Mesh&lt;/li&gt;
&lt;li&gt;我们也在考虑在未来的 Serverless 项目中，将 Function 的寻址也统一到这套方案中，而无需要求每个 Function 都进行一次服务注册&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;概括的说，有了这套 DNS 通用寻址方案，不管需要寻址的实体是什么形态，只要它部署在 Service Mesh 上，满足以下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有正常注册为 Kubernetes Service，分配有 ClusterIP&lt;/li&gt;
&lt;li&gt;为实体（或者更细分的子实体）分配域名或子域名，然后添加到 DNS，解析到 ClusterIP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么我们的 DNS 通用寻址方案，就可以工作，从而将请求正确的转发到目的地。而在此基础上，Service Mesh 所有的强大功能都可以为这些实体所用，实现我们前面的目标：在不修改代码不做微服务改造的情况下，也能提前受益于 Service Mesh 带来的强大服务治理功能。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dubbo on x-protocol——SOFAMesh 中的 x-protocol 示例演示</title>
      <link>https://cloudnativecn.com/blog/dubbo-on-x-protocol-in-sofa-mesh/</link>
      <pubDate>Tue, 11 Sep 2018 19:06:22 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/dubbo-on-x-protocol-in-sofa-mesh/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文作者：彭泽文，阿里巴巴 UC 事业部高级开发工程师。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sofamesh-x-protocol-dubbo&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;sofamesh x-protocol dubbo&#34; srcset=&#34;
               /blog/dubbo-on-x-protocol-in-sofa-mesh/0069RVTdgy1fv5t8by8rsj30kk0bkwez_hu13772695293062302726.webp 400w,
               /blog/dubbo-on-x-protocol-in-sofa-mesh/0069RVTdgy1fv5t8by8rsj30kk0bkwez_hu2822249926064381648.webp 760w,
               /blog/dubbo-on-x-protocol-in-sofa-mesh/0069RVTdgy1fv5t8by8rsj30kk0bkwez_hu9744902139409707663.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/dubbo-on-x-protocol-in-sofa-mesh/0069RVTdgy1fv5t8by8rsj30kk0bkwez_hu13772695293062302726.webp&#34;
               width=&#34;740&#34;
               height=&#34;416&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      sofamesh x-protocol dubbo
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;X-protocol 的定位是云原生、高性能、低侵入性的通用 Service Mesh 落地方案，依托 Kubernetes 基座，利用其原生的服务注册和服务发现机制，支持各种私有 RPC 协议低成本、易扩展的接入，快速享受 Service Mesh 所带来的红利。&lt;/p&gt;
&lt;p&gt;本文将以 &lt;a href=&#34;https://dubbo.incubator.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dubbo&lt;/a&gt; 为例，演示 Dubbo on x-protocol 场景下 Service Mesh 路由功能，涵盖 Version route、Weighted route 功能。&lt;/p&gt;
&lt;p&gt;关于 x-protocol 的介绍请参考 &lt;a href=&#34;http://www.servicemesher.com/blog/ant-financial-sofamesh-common-protocol-extension/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;蚂蚁金服开源的 SOFAMesh 的通用协议扩展解析&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;前期准备&#34;&gt;前期准备&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;安装 Minikube，推荐使用 Minikube v0.28 以上来体验，请参考 &lt;a href=&#34;https://github.com/kubernetes/minikube&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/kubernetes/minikube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安装 kubectl 命令行工具，请参考 &lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安装 VM Driver，推荐安装 Virtual Box、Mac 用户也可以选择 hyperkit&lt;/li&gt;
&lt;li&gt;了解 Istio Traffic Management 相关概念，相关链接：&lt;a href=&#34;https://istio.io/zh/docs/tasks/traffic-management/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://istio.io/zh/docs/tasks/traffic-management/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;部署&#34;&gt;部署&lt;/h2&gt;
&lt;p&gt;先看部署效果图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-mosn-x-protocol-部署图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;MOSN x-protocol 部署图&#34; srcset=&#34;
               /blog/dubbo-on-x-protocol-in-sofa-mesh/1536291419546-2aa160de-69cd-497f-a280-fae20a1f87a3_hu10885486757185231350.webp 400w,
               /blog/dubbo-on-x-protocol-in-sofa-mesh/1536291419546-2aa160de-69cd-497f-a280-fae20a1f87a3_hu15508053632650053798.webp 760w,
               /blog/dubbo-on-x-protocol-in-sofa-mesh/1536291419546-2aa160de-69cd-497f-a280-fae20a1f87a3_hu926973158096425820.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/dubbo-on-x-protocol-in-sofa-mesh/1536291419546-2aa160de-69cd-497f-a280-fae20a1f87a3_hu10885486757185231350.webp&#34;
               width=&#34;760&#34;
               height=&#34;389&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      MOSN x-protocol 部署图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本示例中 dubbo-consumer 的部署方式采用直连模式，即不走注册中心，完全依托 kubernetes 平台提供的服务注册及服务发现能力。&lt;/p&gt;
&lt;h3 id=&#34;1-安装-kubernetes&#34;&gt;1. 安装 Kubernetes&lt;/h3&gt;
&lt;p&gt;安装 kubectl 命令行工具
推荐使用 Kubernetes 1.10 版本，并使用合适的 VM Driver，推荐使用默认的 VirtualBox。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;minikube start --memory&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8192&lt;/span&gt; --cpus&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; --kubernetes-version&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;v1.10.0 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --extra-config&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;controller-manager.cluster-signing-cert-file&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/var/lib/localkube/certs/ca.crt&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --extra-config&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;controller-manager.cluster-signing-key-file&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/var/lib/localkube/certs/ca.key&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Mac OSX 用户使用的 hyperkit 需要特别指定：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;minikube start --memory&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8192&lt;/span&gt; --cpus&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; --kubernetes-version&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;v1.10.0 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --extra-config&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;controller-manager.cluster-signing-cert-file&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/var/lib/localkube/certs/ca.crt&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --extra-config&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;controller-manager.cluster-signing-key-file&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/var/lib/localkube/certs/ca.key&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --vm-dirver&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;hyperkit
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等待 Kubernetes 启动完毕，通过 kubectl 命令检查&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl get pods --namespace&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;kube-system
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-部署-sofamesh&#34;&gt;2. 部署 SOFAMesh&lt;/h3&gt;
&lt;p&gt;本示例演示从源代码的 master 分支直接安装最新的 SOFAMesh，安装过程使用 Helm 完成。&lt;/p&gt;
&lt;p&gt;从 GitHub 拉取最新代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/alipay/sofa-mesh.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; sofa-mesh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建 SOFAMesh 需要的 CRD：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f install/kubernetes/helm/istio/templates/crds.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f install/kubernetes/helm/istio/charts/certmanager/templates/crds.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 Helm 安装 SOFAMesh：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f install/kubernetes/helm/helm-service-account.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm init --service-account tiller
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install install/kubernetes/helm/istio --name istio --namespace istio-system
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装 istioctl 命令行工具：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 使用 make 工具安装 istioctl&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make istioctl-install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;3-创建示例的命名空间&#34;&gt;3. 创建示例的命名空间&lt;/h3&gt;
&lt;p&gt;以下示例都将运行在 e2e-dubbo 命名空间下，如无 e2e-dubbo 命名空间，需先创建该命名空间：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f samples/e2e-dubbo/platform/kube/e2e-dubbo-ns.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;4-注入-mosn&#34;&gt;4. 注入 MOSN&lt;/h3&gt;
&lt;p&gt;部署 dubbo-consumer 和 dubbo-provider，部署前需要先使用 istioctl 进行 sidecar 注入，以下示例采用手动注入方式，也可以通过 istio namespace inject 功能来自动注入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# mosn sidecar inject and deploy&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f &amp;lt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;istioctl kube-inject -f samples/e2e-dubbo/platform/kube/dubbo-consumer.yaml&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f &amp;lt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;istioctl kube-inject -f samples/e2e-dubbo/platform/kube/dubbo-provider-v1.yaml&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f &amp;lt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;istioctl kube-inject -f samples/e2e-dubbo/platform/kube/dubbo-provider-v2.yaml&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;5-部署示例应用&#34;&gt;5. 部署示例应用&lt;/h3&gt;
&lt;p&gt;部署 dubbo consumer service 及 dubbo provider service。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# http service for dubbo consumer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f samples/e2e-dubbo/platform/kube/dubbo-consumer-service.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# dubbo provider service&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f samples/e2e-dubbo/platform/kube/dubbo-provider-service.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;检查部署状态：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#kubectl get pods -n e2e-dubbo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                                     READY     STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;e2e-dubbo-consumer-589d8c465d-cp7cx      2/2       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          13s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;e2e-dubbo-provider-v1-649d7cff94-52gfd   2/2       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          13s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;e2e-dubbo-provider-v2-5f7d5ff648-m6c45   2/2       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          13s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#kubectl get svc -n e2e-dubbo    &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;     AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;e2e-dubbo-consumer   ClusterIP   192.168.1.7     &amp;lt;none&amp;gt;        8080/TCP    10s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;e2e-dubbo-provider   ClusterIP   192.168.1.62    &amp;lt;none&amp;gt;        12345/TCP   10s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;e2e-dubbo-consumer 是一个 Dubbo 客户端应用，它暴露了一个 8080 端口的 HTTP 服务，方便我们进行验证，e2e-dubbo-provider 是一个 Dubbo 应用。
当 e2e-dubbo-consumer 通过 12345 端口调用 e2e-dubbo-provider 时，流量会被 IPtable 规则拦截，导流给 SOFAMosn。&lt;/p&gt;
&lt;h2 id=&#34;验证路由能力&#34;&gt;验证路由能力&lt;/h2&gt;
&lt;p&gt;本示例将验证 Version route 和 Weighted route 能力。&lt;/p&gt;
&lt;h3 id=&#34;1-验证-version-route-能力&#34;&gt;1. 验证 Version Route 能力&lt;/h3&gt;
&lt;p&gt;本例将演示控制 dubbo-consumer 的所有请求指向 dubo-provider-v1
配置 DestinationRule:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl create -f samples/e2e-dubbo/platform/kube/dubbo-consumer.destinationrule.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;dubbo-consumer.destinationrule.yaml&lt;/code&gt; 内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DestinationRule&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo-provider&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo-provider&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subsets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v2 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;配置 VirtualService：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl create -f samples/e2e-dubbo/platform/kube/dubbo-consumer.version.vs.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;dubbo-consumer.version.vs.yaml&lt;/code&gt; 内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;VirtualService&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo-provider&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;e2e-dubbo-provider&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo-provider&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;路由策略已经生效，可以 http 请求 dubbo consumer 来触发 rpc 请求观察效果，由于使用 Minikube 的关系，需要启动一个 Pod 用来测试&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 启动一个 busybox Pod 并登陆&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl run -i -t busybox --image&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;yauritux/busybox-curl --restart&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;Never
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 使用 e2e-dubbo-consumer 的域名访问服务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl e2e-dubbo-consumer.e2e-dubbo.svc.cluster.local:8080/sayHello?name&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;dubbo-mosn
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;清理路由策略：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl delete -f samples/e2e-dubbo/platform/kube/dubbo-consumer.destinationrule.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl delete -f samples/e2e-dubbo/platform/kube/dubbo-consumer.version.vs.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;退出 Minikube shell&lt;/p&gt;
&lt;h3 id=&#34;2-验证-weight-route-能力&#34;&gt;2. 验证 Weight Route 能力&lt;/h3&gt;
&lt;p&gt;本例将演示控制 dubbo-consumer 的请求指向 dubo-provider-v1，dubo-provider-v2。并控制流量分配比例为 v1:20%，v2:80%。&lt;/p&gt;
&lt;p&gt;配置 DestinationRule:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 如果在上一示例中已经创建好了，请跳过这一步&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl create -f samples/e2e-dubbo/platform/kube/dubbo-consumer.destinationrule.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;dubbo-consumer.destinationrule.yaml&lt;/code&gt; 内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DestinationRule&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo-provider&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo-provider&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subsets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v2 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;配置 VirtualService：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl create -f samples/e2e-dubbo/platform/kube/dubbo-consumer.weight.vs.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;dubbo-consumer.weight.vs.yaml&lt;/code&gt; 内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;VirtualService&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo-provider&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;e2e-dubbo-provider&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo-provider&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e2e-dubbo-provider&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;路由策略已经生效，可以 http 请求 dubbo consumer 来触发 rpc 请求观察效果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 启动一个 busybox Pod 并登陆&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl run -i -t busybox --image&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;yauritux/busybox-curl --restart&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;Never
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 使用 e2e-dubbo-consumer 的域名访问服务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl e2e-dubbo-consumer.e2e-dubbo.svc.cluster.local:8080/sayHello?name&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;dubbo-mosn
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;清理路由策略：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl delete -f samples/e2e-dubbo/platform/kube/dubbo-consumer.destinationrule.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl delete -f samples/e2e-dubbo/platform/kube/dubbo-consumer.weight.vs.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;更多功能，敬请期待。&lt;/p&gt;
&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://preliminary.istio.io/zh/docs/setup/kubernetes/quick-start/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Kubernetes 中快速开始 - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://preliminary.istio.io/zh/docs/setup/kubernetes/sidecar-injection/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;注入 Istio sidecar - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dubbo.incubator.apache.org/en-us/docs/user/quick-start.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dubbo quick start - dubbo.incubator.apache.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服开源的 SOFAMesh 的通用协议扩展解析</title>
      <link>https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/</link>
      <pubDate>Fri, 31 Aug 2018 12:27:25 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文作者：邵俊雄（熊啸），蚂蚁金服中间件团队高级技术专家，目前主要负责 SOFAMesh 的开发工作。&lt;/p&gt;
&lt;p&gt;本文是基于作者在 &lt;a href=&#34;https://cloudnativecn.com/blog/service-mesh-meetup-shenzhen-20180825&#34;&gt;Service Mesh Meetup #3 深圳&lt;/a&gt;的主题分享《SOFAMesh 的通用协议扩展》部分内容所整理，完整内容见文末的直播回放&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-邵俊雄-蚂蚁金服-service-mesh-sofa-mosn&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;邵俊雄 蚂蚁金服 Service Mesh SOFA MOSN&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusppz003uj318w0u0qdx_hu8686434977478781799.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusppz003uj318w0u0qdx_hu16317789507722809845.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusppz003uj318w0u0qdx_hu4419985129027291163.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusppz003uj318w0u0qdx_hu8686434977478781799.webp&#34;
               width=&#34;760&#34;
               height=&#34;508&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      邵俊雄 蚂蚁金服 Service Mesh SOFA MOSN
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本次分享主要介绍蚂蚁金服在 SOFAMesh 上开发对 SOFARPC 与 HSF 这两个 RPC 框架的支持过程中总结出来的通用协议扩展方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspj4xg2uj30k00b9wfc_hu8396971962923905460.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspj4xg2uj30k00b9wfc_hu10677483950821610675.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspj4xg2uj30k00b9wfc_hu14611262841055703360.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspj4xg2uj30k00b9wfc_hu8396971962923905460.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;1-sofamesh-介绍&#34;&gt;1. SOFAMesh 介绍&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmec6l4j30k00b9aax_hu7818483957906707615.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmec6l4j30k00b9aax_hu13571827726758085169.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmec6l4j30k00b9aax_hu10508560563799315260.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmec6l4j30k00b9aax_hu7818483957906707615.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFAMesh 是蚂蚁从 ISTIO 上游克隆的开源项目，目的是在 ISTIO 的基础上进行控制平面的发展和创新，同时保持和上游 ISTIO 的同步更新，跟随 ISTIO 的发布节奏，当然也会把一些有价值能力贡献给 ISTIO 社区。&lt;/p&gt;
&lt;p&gt;SOFAMesh 的一个重要目标是用蚂蚁自研的 Golang 版 L4/L7 层代理服务器 SOFAMosn 作为数据平面，取代 C++ 开发的 ENVOY。之前的 Meetup 中我们已经探讨过了一个 Golang 版本的数据平面的重要性，我们相信统一控制平面和数据平面的开发语言可以加快 Service Mesh 的技术创新和产品化落地的速度。&lt;/p&gt;
&lt;p&gt;目前我们已经完成了集成 SOFAMosn 的前期开发工作，打包，安装，部署和测试的脚本都已经从 ENVOY 迁移到了 SOFAMosn，所有的镜像也都推到了公开的镜像仓库。下一步 SOFAMesh 将会整体在 UC 内部基于 Kubernetes 的 PAAS 平台中落地，在实际的生产环境中打磨。未来，SOFAMesh 还将在蚂蚁主站落地，在金融级的生产环境中进一步打磨。&lt;/p&gt;
&lt;p&gt;ISTIO 目前仅能支持 TCP/REDIS/MONGO/HTTP 协议，其服务治理规则主要针对 HTTP 服务制定，对于业界目前大量在高并发、低延迟环境下使用的 RPC 框架及通信协议，例如 DUBBO/HSF/SOFA 没有很好的支持，SOFAMesh 把对于 RPC 通信协议的支持作为重点来看待，SOFAMosn 默认就提供对于 SOFA BOLT 协议的支持。&lt;/p&gt;
&lt;p&gt;SOFAMesh 也是控制平面创新发生的地方，我们已经规划了的创新包括 Mesh Operator，RPC Service Controller 等等。未来的 Serverless 平台也会考虑基于 SOFAMesh 打造，SOFAMesh 将为 Serverless 平台提供基于 Reversion 的服务治理能力。Google Cloud 最近联合 CloudFoundry 和 IBM 发布的 Serverless 平台 Knative 同样也是基于 ISTIO 打造，和我们的想法也是不谋而合。&lt;/p&gt;
&lt;p&gt;SOFAMesh 的下一步也是要融合到 PAAS 平台里面去，成为 PAAS 平台基础网络能力的一部分，用于支撑上层的业务更快速的创新，我们还会加强文档和快速上手方面，方便大家试用 SOFAMesh。&lt;/p&gt;
&lt;h2 id=&#34;2-service-mesh-落地中的问题&#34;&gt;2. Service Mesh 落地中的问题&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmm8hvij30k00b93zo_hu14314177116509383937.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmm8hvij30k00b93zo_hu9133943658203582183.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmm8hvij30k00b93zo_hu13570821494157741057.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmm8hvij30k00b93zo_hu14314177116509383937.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二部分是这次分享的重点，主要介绍蚂蚁金服在集成 SOFA/DUBBO 和 HSF 这些框架的过程中碰到的问题和我们的一套通用的解决方案，希望能够加速 Service Mesh 在实际生产中的落地。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总的来说，业界在 Service Mesh 落地的时候主要有下面四种做法，基本上每种我们都思考和尝试过，最后我们也是走了一条循序渐进的道路。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种做法，比较常见，就是不用 ISTIO 只参考它的设计理念，用 ENVOY/MOSN 或者自研的 SIDECAR 结合已经成熟并且大规模部署的注册中心/配置中心组件，快速上线，拿到多语言，灰度发布，安全这些红利，比如唯品会的 OSP Local Proxy, 华为的 Mesher 都是这个套路。其实 ENVOY 最早也是如此，希望用户在 ENVOY 上直接扩展对 Consul, Eurkea 这些注册中心的支持。但是社区没有走这条路，反而对其 XDS API 进行了适配，由此诞生除了 Service Mesh 的控制平面，并进一步演化出了 ISTIO。目前看来这么做的主要问题是无法利用 ISTIO 社区在服务治理上的创新和工作，存在重复的建设，所以后来有了第二种思路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种做法，更进一步，使用 ISTIO，但是把 Kubernetes 剥离出去，适用于很多短期内无法上 Kubernetes 的企业。ISTIO 控制平面本来就提供了这个能力，ISTIO 有两个扩展点，一个通过 Platform Adapter 对接第三方注册中心，另一个 通过 Config Adapter 对接不通的配置存储。这个做法业界最典型的是 Ucloud 的轻量级 Service Mesh 方案，他们把 Pilot Discovery 模块从 ISTIO 里面剥离了出来，增加第三方注册中心的 Platform Adapter，Cofig Store 直接对接 ETCD 集群，可以通过 docker compose 直接跑起来整个 ISTIO。好处是入门更简单了，但是失去了 Kubernetes 提供了基础能力，ISTIO 的武功已经废了大半。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后来又了第三种做法，据说也有不少公司采用，具体做法是把 Kubernetes 做一个虚拟机用，阉割其服务发现，DNS 等能力，用注册中心/配置中心等成熟且大规模应用的产品替代。唯品会前几天发的文章说明他们已经把这个做法在生产中落地了。这种做法一般只使用 POD 和 StatfuleSet，不创建服务和 Endpoints。一般来说，ISTIO 通过 Platform Adapter 对接注册中心，Config Adapter 对应配置中心。相比前两种做法，这个做法更加复杂，好处是成熟的配置中心和注册中心能够快速的落地 ISTIO，不用解决 ISTIO 由于 ETCD 存贮带来的扩展性问题。这个做法还有个变种就是完全不用 ISTIO，直接在 ENVOY/MOSN 上对接注册中心和配置中心，甚至完成 MIXER 的检查和遥测上报的能力。比如唯品会，用的是 DaemonSet，在同一个 Node 上共享 SIDECAR，其 SIDERCAR 组件 OSP Local Proxy 直接集成注册中心/配置中心。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后一个做法是我们努力的方向，向 Kubernetes 原生的方向发展，在生产环境中落地打磨，并和社区一起解决碰到的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;uc-的-uae-20-平台&#34;&gt;UC 的 UAE 2.0 平台&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspr1ugjqj30k00b9q4c_hu8818955179781058787.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspr1ugjqj30k00b9q4c_hu8492945078342692828.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspr1ugjqj30k00b9q4c_hu14566672893380864334.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspr1ugjqj30k00b9q4c_hu8818955179781058787.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;充分利用 Kubernetes 基础设施的能力是未来的方向，只要路走对了，就不怕远，比如说透明路由网络流量是方向，IPTABLES 是一个实现手段，它的性能不够好，那我们就通过引入 Cilium，用 EBPF 代替 IPTABLES。由于 BYPASS 了两次 TCP 协议栈道穿透，转发性能比常用的 loopback 地址 Workaround 方案还要好。更进一步，我们还能把 ISTIO 数据平面的同步检查逻辑，比如访问控制，通过 Cilium 推到内核的虚拟机中执行，从而解决 ISTIO 的另一的性能瓶颈。&lt;/p&gt;
&lt;p&gt;Kubernetes 已经成为了云原生的事实标准，我们应该充分利用 Kubernetes 的能力，借用社区的力量发展自己的技术。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprblc3fj30k00b975n_hu16220362156365582807.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprblc3fj30k00b975n_hu11159521711965864464.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprblc3fj30k00b975n_hu4763018455813835084.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprblc3fj30k00b975n_hu16220362156365582807.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Spring cloud kubernetes 项目给 Spring cloud 项目落地 Kubernetes 提供了支持，但是在整合 ISTIO 的时候碰到了问题，即便使用 Kubernetes 作为注册中心，客户端的负载均衡和服务发现组件也会破坏 ISTIO 对请求规格的依赖，经过负载均衡之后发送给 ISTIO 数据平面的 PODIP 无法被正确的路由的后端的集群，既无法匹配到 Virtual Host。我们通过 BeanFactoryPostProcesser 在请求中带上了 Host 头，指向服务在 Kubernetes 中的域名，从而解决了这个问题，也因此认识到，给微服务框架的 SDK 打补丁，或者说推动微服务框架轻量化可能是一个实现对业务代码无侵入性，必须的代价。&lt;/p&gt;
&lt;p&gt;Envoy 社区目前还没有对非 HTTP 的 RPC 通信协议提供扩展支持，SOFAMosn 目前内部已经基本完成了 DUBBO 扩展的开发工作。&lt;/p&gt;
&lt;p&gt;由于 ISTIO 的服务治理，路由规则都是针对 HTTP 协议定义的，当应用到基于接口，方法调用的 RPC 服务时，会有概念模型匹配的问题，比方说在定义 Content Based Routing 规则的时候。这里，我们选择了把 RPC 协议映射到 HTTP 上去而不是重新定义新的 RPC 路由的 CRD。&lt;/p&gt;
&lt;p&gt;RPC 服务的容器模型也是个麻烦问题，目前大规模使用的 RPC 框架都是从 SOA 发展过来的，基于的还是传统的容器模型。一个容器中往往同时存在多个服务，各自有自己的版本，ISTIO 基于版本的路由要求每个服务都有自己的 POD 和 Service 定义，否则的话 Traffic Splitting 功能就无法完成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprfuxzsj30k00b9q4d_hu6834315005988421866.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprfuxzsj30k00b9q4d_hu16300114127432366663.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprfuxzsj30k00b9q4d_hu8735329342328408307.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprfuxzsj30k00b9q4d_hu6834315005988421866.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;ISTIO 的控制平面抽象，顶层路由对象是 Virtual Host，Virtual Host 包含一组 Domain，通过 Domain 来选择 Virtual Host，Rate limit 也是定义在 Virtual Host 上面。&lt;/p&gt;
&lt;p&gt;在 Outbound，也就是客户端的 SIDECAR 收到请求的时候，ISTIO 为服务生成的 Virtual Host 包含了服务的域名，Cluster VIP 和 端口的多种组合形式，这个形式确保了对 Host 头和 DNS 寻址的支持。Inbound，也就是服务端的 SIDECAR 收到请求的时候因为所有流量都去到后面的服务实例，所以域名是通配所有。&lt;/p&gt;
&lt;p&gt;Route 上定义了超时，熔断，错误注入的策略。Route 上定义的 Header Matcher，Query Parameter Matcher, Path Matcher 等等都是针对 HTTP 协议的，RPC 协议需要进行映射以支持 Content Based Routing。&lt;/p&gt;
&lt;p&gt;Route Action 指向后端集群，支持重定向和直接返回，集群通过名字路由，集群的变动受到 Destination Rule 的影响，主要是反应在 Subset 的变化上，权重信息就定义在这里。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspruhzvvj30k00b9myc_hu6707057259151498689.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspruhzvvj30k00b9myc_hu497097143998307488.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspruhzvvj30k00b9myc_hu2822741639023362081.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspruhzvvj30k00b9myc_hu6707057259151498689.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFA 的注册中心使用 Interface 来识别服务的，服务的配置信息，消费者和提供者列表，以及超时等服务治理信息也定义在注册中心里面，可以认为是一个具备一定服务治理能力的注册中心。&lt;/p&gt;
&lt;p&gt;我们希望能够用 Interface 来调用服务，就是为了适应 RPC 框架的这个基于接口名字识别服务的概念模型。体现在 Kubernetes 里面就是用 Interface 名字当做域名，把请求头映射到 HTTP 头，请求参数映射到 Query Parameter，方法名映射到 Path 上。这样，基于 RPC 请求内容的服务治理就可以定义到方法和参数级别了，即便是蚂蚁金服站内复杂路由规则，比如 LDC 单元化流量调拨，也是可以支持的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusps37dvtj30k00b9gmv_hu13047260444244308097.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusps37dvtj30k00b9gmv_hu12636633453173127165.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusps37dvtj30k00b9gmv_hu1084801489110843602.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusps37dvtj30k00b9gmv_hu13047260444244308097.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们暂不考虑非 Kubernetes 平台的情况，以支持 DUBBO 作为例子&lt;/p&gt;
&lt;p&gt;如果不适用 k8 作为注册中心，需要引入 ZK。&lt;/p&gt;
&lt;p&gt;因为 ISTIO 目前还不支持 ZK，因此需要针对 DUBBO 的注册模型，与 SOFA 类似，通过 Platform Adapter 的方式加入对 DUBBO 的支持。&lt;/p&gt;
&lt;p&gt;如前所述，我们还需要修改 Pilot Discovery 的代码，正确的为 DUBBO 服务生成 Inbound 和 Outbound 的配置，比如 Listener 和 Cluster 的配置信息。我们还需要为把 ISTIO 的路由规则正确的转成 XDS 的路由配置信息。&lt;/p&gt;
&lt;p&gt;当然，我们还需要扩展 MOSN/ENVOY 来支持 DUBBO 协议，这里面有比较大的重复工作，而且还需要保证代码的执行性能。对于 MOSN 来说，需要自行实现 codec 和 stream 模块。&lt;/p&gt;
&lt;h2 id=&#34;3-sofamesh-的统一解决方案&#34;&gt;3. SOFAMesh 的统一解决方案&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspsg3qh9j30k00b9jsu_hu16312618883400769906.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspsg3qh9j30k00b9jsu_hu14907738259447040991.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspsg3qh9j30k00b9jsu_hu2398149953409114497.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspsg3qh9j30k00b9jsu_hu16312618883400769906.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;考虑到支持不同 RPC 框架的大量重复工作和实现过程中的性能保障，我们希望能提供一个统一的解决方案，以高性能和插件化做为重点来支持，并允许用户在性能和功能之间做平衡。&lt;/p&gt;
&lt;p&gt;这个方案是基于 Kubernetes Native 的方式来做的，使用 interface 来寻址服务，因此需要对客户端做轻量化，以做到不侵入用户的业务代码。&lt;/p&gt;
&lt;p&gt;轻量化客户端是要解决客户端 Loadbalance 引起的问题。&lt;/p&gt;
&lt;h2 id=&#34;4-dns-服务寻址方案&#34;&gt;4. DNS 服务寻址方案&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspt4o5olj30k00b9jsg_hu13441666143682676993.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspt4o5olj30k00b9jsg_hu17525694096838239829.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspt4o5olj30k00b9jsg_hu15439647577625112807.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspt4o5olj30k00b9jsg_hu13441666143682676993.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们会在 Kubernetes 的 DNS 之外额外做一层域名抽象，不受 Kubernetes 的规则的限制，比如，允许用户直接使用 interface 作为域名或者按照组织结构来规划域名的层级关系。Kubernetes 的 namespace 往往被用来作为多租户的解决方案，并不适合用来作为企业内不同部门的逻辑划分。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptd7pmnj30k00b9tab_hu13688558573679076632.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptd7pmnj30k00b9tab_hu11790562590045869109.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptd7pmnj30k00b9tab_hu9622582216435160738.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptd7pmnj30k00b9tab_hu13688558573679076632.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;有些微服务应用本身没有版本，版本反应在应用中的服务接口上，往往每个接口服务都有其独立的版本，比如 SOFA 应用，其版本体现在服务接口的实例上（参考 SOFA 应用注册中心结构）。&lt;/p&gt;
&lt;p&gt;蚂蚁主站内部在做蓝绿部署和灰度的时候，往往一次蓝绿发布会有多个应用参与，为了保证引流的准确性，我们会要求流量在整个调用的链路里面全部落到蓝或者绿的实例上，不允许出现交叉调用的情况。所以对于单应用多服务的场景，我们通过 POD label 把接口区分开来，从而做到流量在 POD 间调拨的粘性。&lt;/p&gt;
&lt;p&gt;服务将会被按照接口维度创建，接口的版本和名字会反应在 POD 的 Label 上，这样做会增加运维的工作量，但是可以通过 PAAS 平台提供的工具解决这个痛点。这里面一个隐含的要求是，一个 POD 只会提供一个接口的服务，推动业务走向 Kubernetes Native。&lt;/p&gt;
&lt;p&gt;对于按照 Kubernetes Native 方式创建的应用，应用只暴露一个接口，无需加上 interface 的标签。&lt;/p&gt;
&lt;p&gt;通过 CoreDNS 的 PDSQL 插件支持，为 Cluster VIP 额外添加一个 interface name 的记录。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptj489lj30k00b9759_hu16433665886122965081.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptj489lj30k00b9759_hu3872217267332257917.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptj489lj30k00b9759_hu16680495208647282009.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptj489lj30k00b9759_hu16433665886122965081.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们通过在 Destination Rule 中同时使用 Interface 和 Version 这两个 Label 来选择 Subset，每一个 Subset 都会在 Pilot Discovery 中形成一个可被路由的集群，这样通过 Subset 就可以完成 Traffic Splitting 的功能了。这样一来，蓝绿发布，灰度等能力都可基于这个 RPC 接口和版本来做了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptuwzptj30k00b9q4c_hu4107495960729917432.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptuwzptj30k00b9q4c_hu17135891330970984576.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptuwzptj30k00b9q4c_hu6706347651883611281.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptuwzptj30k00b9q4c_hu4107495960729917432.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;客户端向 Interface 域名发起请求，通过本地的 resolv.conf 文件指引到 CoreDNS 服务器进行域名解析，得到服务的 Cluster VIP。&lt;/p&gt;
&lt;p&gt;客户端以 Cluser VIP 发起请求，经过 IPTables 转发到 SOFAMosn 的 12220 端口。&lt;/p&gt;
&lt;p&gt;SOFAMosn 通过 socket 拿到 original destination 后，在此端口监听的 SOFA 协议 Listener，通过 Virtual Host 的域名找到正确的 Virtual Host。&lt;/p&gt;
&lt;p&gt;SOFAMosn 将请求按照 Pilot Discovery 下发的 Destination Rule 按照权重转发到不通的后端集群。&lt;/p&gt;
&lt;p&gt;Virtual Host 在生成的时候，其域名列表中会包含 Cluster VIP。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspucuaxcj30k00b9my3_hu451573533941362252.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspucuaxcj30k00b9my3_hu6379273054668459084.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspucuaxcj30k00b9my3_hu163569700659489113.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspucuaxcj30k00b9my3_hu451573533941362252.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在寻址方案中，我们为 RPC Service 创建了一个新的 CRD，并创建一个 RPC Service Controller 来 Watch RPC Service。&lt;/p&gt;
&lt;p&gt;RPC Service Controller 监听到 RPC Service 更新后，通过关联的 Service，按策略找到其中一个 POD，向其发起服务列表查询。请求到达 Register Agent，Agent 通过其协议插件从 APP 实例中获取到服务列表信息后返回给 RPC Service Controller。RPC Service Conroller 使用 RPC Service 接口和 Cluster VIP 更新 CoreDNS 中的域名记录。&lt;/p&gt;
&lt;h2 id=&#34;5-x-protocol-通用协议&#34;&gt;5. X-PROTOCOL 通用协议&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspul1v8bj30k00b9jsf_hu17284062735508450001.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspul1v8bj30k00b9jsf_hu9348056867570564781.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspul1v8bj30k00b9jsf_hu17875425300241092499.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspul1v8bj30k00b9jsf_hu17284062735508450001.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;七层代理的性能瓶颈往往是出现在协议数据包的解析上，由于 SIDECAR 的特殊性，它本身往往得不到足够的资源，不得不运行在资源首先的环境，以避免影响应用本身的运行。在实际的部署中，我们常常会把 SIDECARE 限定在单核心上运行，并且限制它能使用的最大内存，这些都让 SIDECAR 的转发性能面临极大的压力。考虑到 ISTIO 的复杂路由规则在实际的业务场景中很多时候并不会全部都用到，我们允许用户在性能和功能之间找到一个平衡。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusput21o3j30k00b9abg_hu9684513422796529262.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusput21o3j30k00b9abg_hu7517392465067516322.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusput21o3j30k00b9abg_hu1756168939180936597.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusput21o3j30k00b9abg_hu9684513422796529262.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个 Listener 的配置是参考 ISTIO 的 HTTP Connection Manager 做的，我们增加了 Downstream Protocol 和 Upstream Protocol 的配置，允许控制层面选择 SOFAMosn 之间的长连接的通行协议，比如使用 HTTP2，利用 HTTP2 的头部压缩能力提高协议的转发性能。x-protocol 配置项对应服务使用的真是通信协议，下发到 SOFAMosn 之后，SOFAMosn 通过分解 x-protocol 协议来进行适配真是请求协议，正确的加载协议插件进行协议处理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspv01mc0j30k00b93zp_hu11507408656968189489.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspv01mc0j30k00b93zp_hu10931303549045497438.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspv01mc0j30k00b93zp_hu897683235188365334.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspv01mc0j30k00b93zp_hu11507408656968189489.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先操作员在 Kubernetes 中创建 DUBBO 应用的服务，指定其 Port Name 为 x-dubbo-user，这很重要，也是 ISTIO 对 POD 的基本要求。SOFAMesh 监听到服务创建之后，开始在 Pilot 中创建 DUBBO 应用集群的 x-protocol 协议的监听器和集群配置，请参考上文的 x-protocol 配置。&lt;/p&gt;
&lt;p&gt;SOFAMosn SIDECAR 启动后，使用期静态配置的 Pilot 集群地址连接到 Pilot 并开始以 SIDECAR 模式，通过 ADS 接口监听配置的变化。&lt;/p&gt;
&lt;p&gt;SOFAMesh 把 Outbound / Inbound 的配置数据通过 ADS 接口发送给监听的 SOFAMosn 实例。&lt;/p&gt;
&lt;p&gt;Inbound 和 Outbound 的 SOFAMosn 之间建立 x-protocol/http2 协议的长连接，协议可以由下发的 x-protocol 配置指定，比如 HTTP2。目前 SOFAMosn 的 HTTP2 实现并还是 PingPong 模型，不推荐用作 SOFAMosn 之间的通信协议，下个 Milestone 改进后，应该是个更好的选择。&lt;/p&gt;
&lt;p&gt;DUBBO 请求数据进入 Outbound 的 Downstream 后，SOFAMosn 会生成一个自增的 stream id，并且从插件中拿到 request id，建立两个 id 的映射表，同时利用插件把 stream id 写到请求数据中。请求经过路由计算，路由到集群，到达 Upstream 后 SOFAMosn 创建一个 x-protocol 的请求对象，把整个 DUBBO 请求数据作为 Payload，附上自定义的头，发送给 上游 Inbound 的 SOFAMosn，并把从插件中拿到的 class name 和 method name 等信息记录到自定义的头中。&lt;/p&gt;
&lt;p&gt;请求数据到达 Inbound 的 Downstream 后，MOSN 会再生成一个自增的 stream id 并通过插件取出 request id，建立映射关系，并写入 stream id。经过路由匹配之后，请求通过 Upstream 发送给后端的服务实例。&lt;/p&gt;
&lt;p&gt;服务实例返回响应，Inbound 的 SOFAMosn 从响应中拿出 request id，通过 ID 映射找回实际的 request id，写回响应对象，然后把请求用 x-protocol 打包，通过 Downstream 返回给 Outbound 的 SOFAMosn。&lt;/p&gt;
&lt;p&gt;Outbound 的 SOFAMosn 收到响应后，拿出响应对象，并通过插件拿回 request id，最后通过 ID 映射关系找回实际的 request id，写回响应对象后，通过 Downstream 返回给应用实例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvmkhhvj30k00b9t9s_hu7234793034854938082.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvmkhhvj30k00b9t9s_hu6569544621153073128.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvmkhhvj30k00b9t9s_hu6662084023719539870.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvmkhhvj30k00b9t9s_hu7234793034854938082.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvsaykoj30k00b9dgv_hu4521163841925068360.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvsaykoj30k00b9dgv_hu9603127121451780024.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvsaykoj30k00b9dgv_hu17400788418378001115.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvsaykoj30k00b9dgv_hu4521163841925068360.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;获得不同层次的能力，所付出的性能开销和接入成本也会不同，可以根据实际情况做出取舍。Golang 的接口特性允许协议插件的开发人员根据需要实现接口，还可以进行接口的组合。&lt;/p&gt;
&lt;p&gt;开箱即用模式作为不解包方案，提供 LabelRouting，LabelAccessControl，LabelFaultInjection，TLS，RateLimits，Metrics 的能力，以高性能和低成本为亮点。&lt;/p&gt;
&lt;p&gt;轻度解包可以获得更多能力，如多路复用，Accesslog，流控，熔断等（视具体协议而定），是性能和能力间的权衡选择。&lt;/p&gt;
&lt;p&gt;更进一步，完全解除协议的头，可以获得将能力最大化，相对的性能开销和成本也同样最大化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvwky7ej30k00b93z9_hu7611410104593945482.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvwky7ej30k00b93z9_hu12950092997318766404.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvwky7ej30k00b93z9_hu12742739208590813439.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvwky7ej30k00b93z9_hu7611410104593945482.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;8 月底发布的 SOFMesh 版本默认将会用 SOFAMosn 代替 ENVOY 做数据平面，ISTIO 自带的 BookInfo 的例子可以提供给大家试用。我们后续还会提供 SOFA/DUBBO 应用的例子。&lt;/p&gt;
&lt;p&gt;目前 SOFAMosn 还不能在 Gateway 模式中使用，即不能用于 Ingress，而且部分高级路由功能，以及熔断，限流等高级治理能力目前还不支持。另外这个版本的 Mixer 节点也去除了，我们会在 9 月份的版本中持续完善 SOFAMosn 和 SOFAMesh，加入高级服务治理能力，同时我们也会完成 Mixer 的 Report 部分能力，放到开源版本中。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文首先介绍蚂蚁金服开源的 SOFAMesh，然后分享在 SOFAMesh 上落地 UC 的 HSF 应用和蚂蚁的 SOFA 应用碰到的问题，以及我们总结出来的解决方案和最佳实践。最后分别就其中有代表性的 DNS 寻址方案和 X-PROTOCOL 协议分享一下做法。希望大家内部的 DUBBO 或者其他功能内部的 RPC 应用在 Service Mesh 落地的时候，能够有个参考。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh 数据平面 SOFAMosn 深层揭秘</title>
      <link>https://cloudnativecn.com/blog/sofa-mosn-deep-dive/</link>
      <pubDate>Thu, 02 Aug 2018 14:31:43 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/sofa-mosn-deep-dive/</guid>
      <description>&lt;p&gt;MOSN GitHub 地址：https://github.com/sofastack/mosn&lt;/p&gt;
&lt;p&gt;本文作者：朵晓东，花名奕杉，蚂蚁金服高级技术专家，专注云计算技术及产品。Apache Kylin 创始团队核心成员，蚂蚁金融云 PaaS 创始团队核心成员，Antstack 网络产品负责人，SOFAMesh 创始团队核心成员。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-朵晓东-service-mesh-meetup&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;朵晓东 service mesh meetup&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvf883plij30sg0j0n1e_hu6242168963494692018.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvf883plij30sg0j0n1e_hu8009748751443730616.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvf883plij30sg0j0n1e_hu922402134037771932.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvf883plij30sg0j0n1e_hu6242168963494692018.webp&#34;
               width=&#34;760&#34;
               height=&#34;508&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      朵晓东 service mesh meetup
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本文是基于作者在第二届 Service Mesh Meetup 的主题分享《蚂蚁金服 Service Mesh 数据平面 SOFAMosn 深层解密》部分内容所整理，以下是具体内容。关于本次 meetup 的情况请访问&lt;a href=&#34;https://cloudnativecn.com/blog/beijing-meetup-20180729/&#34;&gt;第二届 Service Mesh Meetup 北京站回顾&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;今天给大家带来的分享内容是蚂蚁金服 Service Mesh 数据平面 SOFAMosn 深层揭秘。&lt;/p&gt;
&lt;p&gt;承接小剑老师月初《大规模微服务架构下的 ServiceMesh 探索之路》对 SOFAMosn 的分享，本次聚焦在数据平面在蚂蚁落地的思考和探索。&lt;/p&gt;
&lt;h3 id=&#34;背景&#34;&gt;背景&lt;/h3&gt;
&lt;p&gt;上一次分享小剑老师已经介绍了 SOFAMesh 的技术选型，以及我们在开源和自研方面的一些权衡。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;呼应这个话题我们首先来看一下为什么蚂蚁会选择 Service Mesh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;重点归纳为-4-个方面&#34;&gt;重点归纳为 4 个方面：&lt;/h4&gt;
&lt;p&gt;蚂蚁正在全面拥抱微服务，云原生，不管是 SOFA5，还是兼容 K8S 的容器平台 Sigma 落地，Service Mesh 都是不可获取的重要组件。&lt;/p&gt;
&lt;p&gt;其次，蚂蚁的运维体系在服务层面基于流量调度工作，比如说 LDC 架构在逻辑 zone 间的调度流量，再比如弹性伸缩，本质上也是在异构机房间调度流量，此外还有像逻辑 zone 蓝绿发布，机房容灾等都需要在流量调度能力上更健壮，更灵活，更具扩展性。&lt;/p&gt;
&lt;p&gt;此外，由于蚂蚁的金融属性，我们在服务鉴权等方面有更严格的要求，比如说国密的落地，加密卡内的证书管理，加解密等方面，不止要求更高的安全级别，还要有承载大流量的能力。同时我们看到，zero trust 网络架构也在加速发展，这与我们的诉求不谋而合。&lt;/p&gt;
&lt;p&gt;最后，蚂蚁内部技术栈多样，但多种语言体系融合仍然成本很高。举个例子，非 SOFA 语言与 SOFA 互通要理解配置中心，SOFARPC 的序列化等逻辑，如果在生产环境部署还要理解 LDC 路由规则，而这些共性需求都可以通过下沉到 Mesh 体系来解决。&lt;/p&gt;
&lt;p&gt;了解 SOFAMesh 的同学应该知道，蚂蚁选择了使用 Golang 自研数据平面，做这个决定我们重点考虑了未来的技术选型，跨团队研发效率，蚂蚁现有技术体系，运维体系等因素；同时通过调研和验证，Golang 版本的性能也是我们可以接受的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接下来，我会向大家介绍由蚂蚁和 UC 联合研发的 Mesh 数据平面，我们为它取名 &lt;strong&gt;SOFAMosn&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;架构设计&#34;&gt;架构设计&lt;/h3&gt;
&lt;p&gt;首先我们由浅入深看一下 &lt;strong&gt;SOFAMosn&lt;/strong&gt; 的架构设计&lt;/p&gt;
&lt;h4 id=&#34;1-sofamesh-的整体架构&#34;&gt;1. SOFAMesh 的整体架构&lt;/h4&gt;
&lt;p&gt;大家看到的图示是基于 Istio 的架构，在数据平面我们使用 SOFAMosn 替代了 Envoy，同时加入了一些蚂蚁实践中摸索的改进，比如说 Mixer 的位置，我们考虑把 Mixer 下沉到 SOFAMosn，比如说对 SOFA，DUBBO 协议的支持等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcgxiw5cj31kw0zk45v_hu18098472500891371317.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcgxiw5cj31kw0zk45v_hu2583400818598488899.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcgxiw5cj31kw0zk45v_hu1894932208068549724.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcgxiw5cj31kw0zk45v_hu18098472500891371317.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;0.1.0 版本的 SOFAMosn 支持了 xDS V0.4 api 核心能力，重点支持了 SOFARPC 协议，并在蚂蚁内部在生产环境使用；同时支持了 HTTP/1.1，HTTP/2.0 的基本功能，但目前暂未在生产环境使用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchc91q9j31kw0zkgs2_hu9578178937322324276.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchc91q9j31kw0zkgs2_hu10394852240535598213.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchc91q9j31kw0zkgs2_hu18165818015230543494.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchc91q9j31kw0zkgs2_hu9578178937322324276.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;2-sofamosn-的核心设计思路&#34;&gt;2. SOFAMosn 的核心设计思路&lt;/h4&gt;
&lt;p&gt;首先，将 SOFAMosn 作为代理处理的数据流划分为 4 层，在入方向数据依次经过网络 IO 层，二进制协议处理层，协议流程处理层，转发路由处理层；出向与入向过程基本相反。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchpmtzoj31kw0zkq9h_hu10708909369678717538.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchpmtzoj31kw0zkq9h_hu4249286923747128654.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchpmtzoj31kw0zkq9h_hu13056512626564519203.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchpmtzoj31kw0zkq9h_hu10708909369678717538.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;了解了分层的基本思路，具体介绍一下各层的具体职能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IO 层&lt;/strong&gt;提供了 IO 读写的封装以及可扩展的 IO 事件订阅机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PROTOCOL 层&lt;/strong&gt;提供了根据不同协议对数据进行序列化/反序列化的处理能力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STREAMING 层&lt;/strong&gt;提供向上的协议一致性，负责 STREAM 生命周期，管理 Client / Server 模式的请求流行为，对 Client 端 stream 提供池化机制等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Proxy 层&lt;/strong&gt;提供路由选择，负载均衡等的能力，让前后端 stream 流转起来。大家可以从这张图清晰的看到单向请求流转的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcj3iaa9j31kw0zkn5w_hu16617897863525435079.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcj3iaa9j31kw0zkn5w_hu2451777179279780049.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcj3iaa9j31kw0zkn5w_hu17053003911829703678.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcj3iaa9j31kw0zkn5w_hu16617897863525435079.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;3-了解了分层设计及转发流程我们再看一下线程模型&#34;&gt;3. 了解了分层设计及转发流程，我们再看一下线程模型&lt;/h4&gt;
&lt;p&gt;我们先看看 0.1.0 版本的线程模型，可以看到每个链接的 IO 协程是成对出现的，读协程负责读取，事件机制及 Codec 逻辑，数据上升到 steam 层，具体的 stream 事件由独立的常驻 worker 协程池负责处理。在 0.2.0 版本中我们将会进行多核优化，读协程将不再负责 codec 逻辑，将转发由 codec worker pool 来进行。从发展方向上看，我们会借鉴 SEDA 的思路，将转发流程中每一阶段的处理抽象为一个 stage，通过 task queue，worker 协程池，controller 的机制来对每一个阶段进行处理。从技术实现上看，Golang 实现 SEDA 机制的组件也更简单。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjbqg8zj31kw0zkn5c_hu10350450550900637399.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjbqg8zj31kw0zkn5c_hu5801734796829727921.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjbqg8zj31kw0zkn5c_hu2357041168925447899.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjbqg8zj31kw0zkn5c_hu10350450550900637399.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjhuyiuj31kw0zkgu6_hu1657740405236911433.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjhuyiuj31kw0zkgu6_hu17566035800523799376.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjhuyiuj31kw0zkgu6_hu491309615219245674.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjhuyiuj31kw0zkgu6_hu1657740405236911433.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;4-sofamosn-的模块划分&#34;&gt;4. SOFAMosn 的模块划分&lt;/h4&gt;
&lt;p&gt;除了刚才介绍了 4 个核心模块，还有如路由模块负责请求的路由寻址，后端管理模块负责管理后端的生命周期，健康度等。其中蓝色的框是 SOFAMosn 0.1.0 会涉及到的功能模块，红色的虚线框是我们规划去实现，或实验的一些 topic。这方面也欢迎大家加入我们一起来建设。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjr017oj31kw0zkqju_hu6900901711139304089.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjr017oj31kw0zkqju_hu12220287180586625008.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjr017oj31kw0zkqju_hu5838007405200783066.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjr017oj31kw0zkqju_hu6900901711139304089.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后总结一下，模块化，分层解耦是 SOFAMosn 设计的初衷，此外可编程性，事件机制，扩展性，高吞吐量，都是设计中的重要考量因素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;sofamosn-核心能力&#34;&gt;SOFAMosn 核心能力&lt;/h3&gt;
&lt;p&gt;介绍完结构设计方面的一些思路，我们来看看 SOFAMosn 0.1.0 的核心能力。&lt;/p&gt;
&lt;p&gt;在网络核心能力方面，我们将 IO 处理相关能力封装抽象成可编程接口，这部分我们已经做过性能优化，可以单独使用；SOFAMosn 提供了内置的 TCP 代理功能，也做过性能优化，可单独使用；此外 SOFAMosn 支持 TLS 链路加密，目前复用了 Golang 的实现，后面的章节会介绍 Golang TLS 性能实验。SOFAMosn 可以配合 iptables 透明转发支持 TProxy 模式。同时，MOSN 支持平滑 reload，平滑升级。&lt;/p&gt;
&lt;p&gt;在多协议方面，0.1.0 版本中 SOFAMosn 重点支持 SOFARPC，并已运用在蚂蚁生产环境中。同时 SOFAMosn 支持HTTP/1.1，HTTP/2.0 的基本功能，实现方式是使用开源的 HTTP/1.1实现 FastHTTP 和 Golang 自带的 HTTP2 实现。由于 FastHTTP 和 HTTP2 都自带了 IO，链接池等功能，所以这两个协议的支持暂时是脱离 SOFAMosn 整体设计的，性能等方面也还没有做优化，我们会在后续版本迭代考虑将其纳入到 SOFAMosn 的框架体系，并进行性能优化。此外，我们正在研发 Dubbo，HSF 的支持，会在后续版本中推出。同时，目前已支持的 SOFARPC，HTTP/1.1，HTTP/2.0 都支持 Mes h 间的 TLS 链路加密。&lt;/p&gt;
&lt;p&gt;此处，在核心路由方面，0.1.0 版本 SOFAMosn 在核心功能上对齐 Envoy，支持 virtual host 匹配，支持 route match 匹配，支持 subset 路由匹配/负载均衡。&lt;/p&gt;
&lt;p&gt;在后端管理功能方面，支持基础负载均衡算法，支持主动健康检查等必须功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvck8jjfgj31kw0zkgu4_hu12066339168969462893.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvck8jjfgj31kw0zkgu4_hu5239803965960529371.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvck8jjfgj31kw0zkgu4_hu8809168948492953733.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvck8jjfgj31kw0zkgu4_hu12066339168969462893.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除核心功能外，SOFAMosn 根据我们落地的一些经验提供了一些亮点功能。&lt;/p&gt;
&lt;p&gt;首先，SOFAMosn 支持 X-PROTOCOL，一种更轻量级的方式支持自定义 RPC 协议，对于无需解包的相对简单的场景，将 RPC 数据作为 TCP 或者 HTTP/2.0 的 payload 进行转发，同时支持所有无需解包的路由负载策略。&lt;/p&gt;
&lt;p&gt;同时我们计划在 X-PROTOCOL 中加入编解码扩展点，支持需要解包的场景。在平滑升级的支持上，除了经典的传递 listener fd+ 协议层等待方式，SOFAMosn 支持对存量链接进行协议无关的迁移。同时为了部署升级，SOFAMosn 支持指定 / 更新前后端通信协议。&lt;/p&gt;
&lt;p&gt;在 Istio 集成方案上，SOFAMosn 0.1.0 支持 Istio 0.8 版本 Pilot V0.4API 全动态配置运行，支持 xDS on ADS 核心功能，后续版本会不断补齐功能。SOFAMosn 同时支持静态配置模型运行。&lt;/p&gt;
&lt;p&gt;除了能力支持，SOFAMosn 在网络层，协议处理层，基于 TCP 的私有协议层都提供了可扩展的能力，使得自定义业务可以优雅集成。在蚂蚁落地的过程中我们内部的 SOFAMosn 依赖于开源版本，通过可扩展的方式来实现蚂蚁内部的自有业务，在工程落地上提供了可行的方案。&lt;/p&gt;
&lt;h3 id=&#34;性能&#34;&gt;性能&lt;/h3&gt;
&lt;p&gt;在介绍了核心功能以后，我们再看另一个大家非常关注的问题，性能，这也是目前关注度较高的问题之一。&lt;/p&gt;
&lt;p&gt;在 SOFAMosn 0.1.0 版本，我们重点优化了基于 SOFAMosn 整体框架的协议在 Sidecar 模式下单核转发的性能，即 TCP，SOFARPC 的单核转发性能。&lt;/p&gt;
&lt;p&gt;首先我们分享一下我们在单核场景下优化的一些手段和经验。我们使用的方式主要是独占绑核，内存，IO，调度等方面进行优化。&lt;/p&gt;
&lt;p&gt;首先看绑核，在指定 P=1 的情况下，独占绑核不论在系统调用执行效率，cache locality affinity 两个方面都比更表现更好，整体吞吐量提升大约 30%。其次是内存优化，我们采样了 SLAB-style 的回收机制来提高复用，减少内存 copy；&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckkrfijj31kw0zkam1_hu7827382368799083324.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckkrfijj31kw0zkam1_hu12305420187729447814.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckkrfijj31kw0zkam1_hu2805476789601602024.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckkrfijj31kw0zkam1_hu7827382368799083324.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;同时在内存分配上需要考虑 Golang 内存模型的亲和性，尽量减少 arena 区内存申请；最后，大家都知道 Golang 的 GC 需要是你要去熟悉并适应他的，很多细节需要关注，尽量减少 GC scanobject 的压力。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckray2rj31kw0zk7ek_hu13166811526249963553.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckray2rj31kw0zk7ek_hu2668977473407394653.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckray2rj31kw0zk7ek_hu17981241682463726296.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckray2rj31kw0zk7ek_hu13166811526249963553.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 IO 方案，Golang 的 IO 模型是同步化的，在读方面既要尽可能多读，又要避免频繁调用 SetReadDeadline 造成的的影响，在我们压测下面频繁调用 SetReadDeadline 会对吞吐量有一定影响。在写方面需要适度 buffer，例如由多 worker 协程驱动造成某个 IO 协程频繁写系统 IO 也会造成吞吐量下降。另一个需要注意的方面是，在多协程场景下需要避免读写频率不均衡，这也是造成整体吞吐量下降的一个潜在原因。另外，如果读或写大量触发，会造成大量系统调用，这会引起 Golang runtime 调度成本升高。在 Golang runtime 调度方面，首先会触发协程调度造成时间消耗，同时 runtime 调度本身没有 OS 线程调度灵敏，也会有一定的时间损耗。同时 OS 系统调用本身也有会耗时，会造成性能下降。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里我分享一些我们在性能优化过程中遇到的真实的 case&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;除了 IO 方面的思考，还要关注一下调度均衡方面的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们利用协程池化来避免 runtime.morestack 的问题，其次在单核场景下需要重点关注 G 是否在饥饿状态，造成资源浪费。&lt;/p&gt;
&lt;p&gt;介绍完性能优化的一些过程，我们来看一下目前我们在性能优化上的一些结果，即单核 TCP 转发的性能，和单核 SOFARPC 转发的性能。可以看到，在单核 TCP 转发场景，SOFAMosn 0.1.0 版本和 Envoy 1.7 版本转发性能差距可控，后续版本我们会继续优化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcl25xaej31kw0zkdmu_hu18090935774821982131.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcl25xaej31kw0zkdmu_hu1292977998135530810.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcl25xaej31kw0zkdmu_hu1632212800982697429.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcl25xaej31kw0zkdmu_hu18090935774821982131.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclh0lu9j31kw0zktgn_hu13876980465614908623.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclh0lu9j31kw0zktgn_hu14558319777267219653.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclh0lu9j31kw0zktgn_hu16489833130773119366.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclh0lu9j31kw0zktgn_hu13876980465614908623.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，前面提到过 TLS 的实现，我们再来看一下性能方面的一些探索。首先介绍了一下测试的场景。在这个场景下，我们发现对于 ECDHE 算法，Golang 原生的实现性能虽然低于 Ningx（使用 OpenSSL），但是高于 Golang with boring SSL。通过对具体算法和协议的性能压测，代码调研我们得出如下结论。可以看出对于 ECDHE-P256 加密套件，Golang 原生实现的性能是很不错的，可以放心使用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclp075yj31kw0zkdm4_hu11168591108216843221.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclp075yj31kw0zkdm4_hu6777181870359558538.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclp075yj31kw0zkdm4_hu13308726128602543069.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclp075yj31kw0zkdm4_hu11168591108216843221.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了这些优化点以后，我们会在后续版本持续进行性能优化，多核优化，内存优化，同时利用用户态，内核态的加速技术来提升 SOFAMosn 的转发性能。在 TLS 加解密方面，我们将会尝试基于本地加速卡和 Keyless 架构的 Offload 加速，这也是我们在蚂蚁网络从中已经落地的一些技术手段。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclv2763j31kw0zkn4s_hu16457416032041821258.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclv2763j31kw0zkn4s_hu3872326076786011173.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclv2763j31kw0zkn4s_hu16335960443483736136.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclv2763j31kw0zkn4s_hu16457416032041821258.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;roadmap&#34;&gt;RoadMap&lt;/h3&gt;
&lt;p&gt;最后我介绍一下 SOFAMosn 的 RoadMap（时间为大体范围，具体发布请关注本公众号）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcm43sg5j31kw0sp1kx_hu17396866437187217410.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcm43sg5j31kw0sp1kx_hu16224828891650852280.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcm43sg5j31kw0sp1kx_hu16587062960677746521.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcm43sg5j31kw0sp1kx_hu17396866437187217410.webp&#34;
               width=&#34;760&#34;
               height=&#34;383&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;8 月第一周我们将发布 SOFAMesh 0.1.0 版本，这个版本重点支持 Proxy 核心能力，支持 xDS V0.4 API 核心功能，支持 SOFARPC 等通信协议。&lt;/p&gt;
&lt;p&gt;8 月底我们将发布 0.2.0 版本，在不断完善提升核心能力的基础上，我们会完善 X-Protocol 的功能和扩展性，以支持私有 RPC 协议扩展；同时我们将支持 Dubbo/HSF 通讯协议，并接入基于 ZK 的服务注册中心。同时我们将重点加强 HTTP/2.0 的功能，性能优化。我们还将支持 K8S operator，使得 SOFA Mesh 可以接入 K8S 资源。&lt;/p&gt;
&lt;p&gt;除功能性补强以外，我们会持续优进行性能优化，重点在多核性能，整体内存优化。此外，我们会持续推进代码优化，完善测试等基础性工作。&lt;/p&gt;
&lt;p&gt;9 月底我们将发布 0.3.0，重点提供 Mixer 集成，提供 precondition，quota，report 功能。同时在 9 月提供熔断和限流的能力。&lt;/p&gt;
&lt;p&gt;目前 SOFAMosn 仍然是一个初级版本，我们将持续投入补充，改进，优化，也欢迎开源社区感兴趣的朋友一起加入 SOFAMesh 开源版的建设。&lt;/p&gt;
&lt;h3 id=&#34;补充&#34;&gt;补充&lt;/h3&gt;
&lt;p&gt;本文基于作者在 Service Mesh Meetup #2 分享的部分内容所整理，现场分享的 PPT 以及视频，可以在 &lt;a href=&#34;https://www.itdks.com/eventlist/detail/2455&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IT 大咖说&lt;/a&gt;观看；&lt;/p&gt;
&lt;p&gt;PPT 下载地址：https://github.com/servicemesher/meetup-slides&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服开源 SOFAMesh—一款基于 Istio 改进和扩展而来的 Service Mesh 大规模落地实践方案</title>
      <link>https://cloudnativecn.com/blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/</link>
      <pubDate>Mon, 16 Jul 2018 15:51:34 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/</guid>
      <description>&lt;p&gt;4 月，蚂蚁金服自主研发的分布式中间件（Scalable Open Financial Architecture，以下简称 SOFA）启动开源计划，并开放多个组件，（相关背景请点击链接阅读《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI0Nzc3MTQyMw==&amp;amp;mid=2247484729&amp;amp;idx=1&amp;amp;sn=0d8dbee2739fb0eef3e4ad699661fd13&amp;amp;chksm=e9abbd49dedc345fd5d6898fd1989710f249d6386bf3d52ae1603365a4a1c3696538bc8b9a8f&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开源 |蚂蚁金服启动分布式中间件开源计划，用于快速构建金融级云原生架构&lt;/a&gt;》、《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI0Nzc3MTQyMw==&amp;amp;mid=2247485026&amp;amp;idx=1&amp;amp;sn=0a367bc67d5fe3a268e3715b17e020ab&amp;amp;chksm=e9abbe12dedc370489102d9307b832457891fdb0530eec5c35c0fb82bc2a3e6dbbc7db8436c4&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开源 | 蚂蚁金服分布式中间件开源第二弹：丰富微服务架构体系&lt;/a&gt;》），这一系列的动作受到大家的关注和支持，SOFA 社区也日益壮大。&lt;/p&gt;
&lt;p&gt;在两轮开源之后，蚂蚁金服自主研发的分布式中间件（Scalable Open Financial Architecture，以下简称 SOFA）在今天推出了&lt;strong&gt;第三轮的开源产品：SOFAMesh&lt;/strong&gt;。和前两轮开源的历经多年沉淀和打磨的成熟产品不同，本轮的开源主角 SOFAMesh，将探索一条和以往产品有所不同的开源道路。下面我们就来看看到底有哪些不同吧！&lt;/p&gt;
&lt;h2 id=&#34;sofamesh-的开源探索之路&#34;&gt;SOFAMesh 的开源探索之路&lt;/h2&gt;
&lt;p&gt;SOFAMesh 尝试在以下几个方面进行自我突破和勇敢探索：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全新的技术领域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Service Mesh 是目前技术社区最为炙手可热的新技术方向，有下一代微服务的明显趋势。但是目前 Service Mesh 技术还处于发展早期，暂时还没有成熟的产品，尤其缺乏大规模的落地实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;较早的开源时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上述背景下，我们选择了将启动不久的 Service Mesh 产品开源在开发早期，也就是还未成熟之时，就对社区开放，开放源码并寻求社区合作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更加开放的态度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 SOFAMesh 上，我们愿意以开源共建的方式来和社区一起推进 Service Mesh 技术的更好发展和实现落地实践，共同打造一个技术先进，功能丰富，具备良好的性能和稳定性，可以实实在在的生产落地的优秀产品。欢迎国内技术社区的朋友们和我们开展不同层面的交流与合作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;务实的产品路线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SOFAMesh 在产品路线上，选择了跟随社区主流，我们选择了目前 Service Mesh 中最有影响力和前景的 Istio。SOFAMesh 会在 Istio 的基础上，提升性能，增加扩展性，并在落地实践上做探索和补充，以弥补目前 Istio 的不足，同时保持与 Istio 社区的步骤一致和持续跟进。&lt;/p&gt;
&lt;h3 id=&#34;sofamesh-介绍&#34;&gt;SOFAMesh 介绍&lt;/h3&gt;
&lt;p&gt;SOFAMesh 将在兼容 Istio 整体架构和协议的基础上，做出部分调整：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sofamesh-architecture&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SOFAMesh architecture&#34; srcset=&#34;
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tNbRwgy1fuyr4vizzwj31kw1biq98_hu13045568273907294865.webp 400w,
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tNbRwgy1fuyr4vizzwj31kw1biq98_hu12133529127151143290.webp 760w,
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tNbRwgy1fuyr4vizzwj31kw1biq98_hu15553107502916656035.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tNbRwgy1fuyr4vizzwj31kw1biq98_hu13045568273907294865.webp&#34;
               width=&#34;760&#34;
               height=&#34;635&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SOFAMesh architecture
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;使用 Golang 语言开发全新的 Sidecar，替代 Envoy&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为了避免 Mixer 带来的性能瓶颈，合并 Mixer 部分功能进入 Sidecar&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pilot 和 Citadel 模块进行了大幅的扩展和增强&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们的目标：打造一个更加务实的 Istio 落地版本！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：以上架构调整的细节以及我们做调整的出发点和原因，请浏览 &lt;a href=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/&#34;&gt;蚂蚁金服大规模微服务架构下的 Service Mesh 探索之路&lt;/a&gt;（可点击查看）一文，有非常详尽的解释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;开源内容&#34;&gt;开源内容&lt;/h3&gt;
&lt;p&gt;在本轮开源中，我们将推出 SOFAMesh 目前正在开发的两大模块：MOSN 和 SOFAPilot。&lt;/p&gt;
&lt;h4 id=&#34;1mosn&#34;&gt;1.MOSN&lt;/h4&gt;
&lt;p&gt;SOFAMesh 中 Golang 版本的 Sidecar，是一个名为 MOSN(Modular Observable Smart Netstub) 的全新开发的模块，实现 Envoy 的功能，兼容 Envoy 的 API，可以和 Istio 集成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sofamesh-mosn&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SOFAMesh MOSN&#34; srcset=&#34;
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75ot24lzj31ec18479s_hu17347057104099349195.webp 400w,
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75ot24lzj31ec18479s_hu11814029116279666506.webp 760w,
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75ot24lzj31ec18479s_hu1930245410041566199.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75ot24lzj31ec18479s_hu17347057104099349195.webp&#34;
               width=&#34;760&#34;
               height=&#34;666&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SOFAMesh MOSN
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，我们会增加对 SOFARPC、Dubbo 等通讯协议的支持，以便更好的迎合国内用户包括我们自身的实际需求。&lt;/p&gt;
&lt;p&gt;由于 Sidecar 相对独立，而且我们也预期会有单独使用 MOSN 的场景，因此 MOSN 的代码仓库是独立于 SOFAMesh 的，地址为：https://github.com/alipay/sofa-mosn&lt;/p&gt;
&lt;p&gt;欢迎大家使用，提供需求、反馈问题、贡献代码或者合作开发。&lt;/p&gt;
&lt;h3 id=&#34;2sofapilot&#34;&gt;2.SOFAPilot&lt;/h3&gt;
&lt;p&gt;我们将大幅扩展和增强 Istio 中的 Pilot 模块：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sofamesh-pilot-architecture&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SOFAMesh Pilot architecture&#34; srcset=&#34;
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75pq8rplj31kw19sn5q_hu3382465311163099153.webp 400w,
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75pq8rplj31kw19sn5q_hu7505699493610745020.webp 760w,
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75pq8rplj31kw19sn5q_hu3227025147099373762.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75pq8rplj31kw19sn5q_hu3382465311163099153.webp&#34;
               width=&#34;760&#34;
               height=&#34;612&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SOFAMesh Pilot architecture
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;增加 SOFARegistry 的 Adapter，提供超大规模服务注册和发现的解决方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增加数据同步模块，以实现多个服务注册中心之间的数据交换。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增加 Open Service Registry API，提供标准化的服务注册功能&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;MOSN 和 SOFAPilot 配合，将可以提供让传统侵入式框架（如 Spring Cloud，Dubbo，SOFA RPC 等）和 Service Mesh 产品可以相互通讯的功能，以便可以平滑的向 Service Mesh 产品演进和过渡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pilot 和后面会陆续开放的 Mixer，Citadel 等 Istio 模块&lt;/strong&gt;，会统一存放在同一个从 Istio Fork 出来的代码仓库中。未来会持续更新 Istio 最新代码，以保持和 Istio 的一致。&lt;/p&gt;
&lt;h2 id=&#34;附录&#34;&gt;附录&lt;/h2&gt;
&lt;p&gt;本文中提到的链接地址合辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alipay/sofa-mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFA MOSN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alipay/sofa-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFAMesh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sofastack.tech/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFAMesh 官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sofastack.tech/sofa-mesh/docs/Hom&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFAMesh 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/&#34;&gt;蚂蚁金服大规模微服务架构下的 Service Mesh 探索之路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服大规模微服务架构下的 Service Mesh 探索之路</title>
      <link>https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/</link>
      <pubDate>Wed, 04 Jul 2018 19:56:20 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文是根据蚂蚁金服 Service Mesh 布道师敖小剑在 Service Mesher 社区进行的第一次 Meetup 上分享的《大规模微服务架构下的 Service Mesh 探索之路》现场演讲内容实录整理编辑而成，希望能给关注 Service Mesh 产品的朋友们带来帮助和了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;讲师 PPT 下载地址&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/servicemesher/meetup-slides&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/servicemesher/meetup-slides&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dc36ywj30qo0f0wfd_hu2259631539253417189.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dc36ywj30qo0f0wfd_hu15132173316835732811.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dc36ywj30qo0f0wfd_hu4701359373135267747.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dc36ywj30qo0f0wfd_hu2259631539253417189.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-敖小剑-蚂蚁金服-service-mesh-杭州-meetup&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;敖小剑 蚂蚁金服 service mesh 杭州 meetup&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d1qg75j30u00k1tcu_hu3382731709403572288.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d1qg75j30u00k1tcu_hu4927766048173388777.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d1qg75j30u00k1tcu_hu4100942946079937391.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d1qg75j30u00k1tcu_hu3382731709403572288.webp&#34;
               width=&#34;760&#34;
               height=&#34;508&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      敖小剑 蚂蚁金服 service mesh 杭州 meetup
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;今天给大家带来的内容叫做 Service Mesh 探索之路，但是在前面加了一个定语：&lt;strong&gt;大规模微服务架构下&lt;/strong&gt;。之所以加上这个词，是因为我们这个体系是在蚂蚁金服这样一个大的架构下进行的，蚂蚁金服的体量大家可以想象，所以这个探索会带有一个非常隆重的色彩：对性能/规模/高可用等方面的思考。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dewe11j30qo0f0jsq_hu9774419382973889787.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dewe11j30qo0f0jsq_hu2621678895964806719.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dewe11j30qo0f0jsq_hu5454127123219326778.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dewe11j30qo0f0jsq_hu9774419382973889787.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今年 6 月初，在深圳的 GIAC 大会，我们同事披露了这个正在开发中的 Service Mesh 产品，我们现在暂时命名为 SOFA Mesh。我们目前的产品都在 SOFA 品牌下，比如 SOFA RPC，SOFA Boot 等。今天我们详细介绍 SOFA Mesh 这个单独产品，上次大会只是简单披露，也就是给大家介绍说我们有这样一个产品，而我今天的内容是把这个产品详细展开。&lt;/p&gt;
&lt;p&gt;主要是三个内容：一是 SOFA Mesh 的技术选型，二是它的架构设计，以及在最后跟大家聊一下，蚂蚁金服在 SOFA Mesh 上的开源策略。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5yw0aj30qo0f0gm1_hu6487640589260794462.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5yw0aj30qo0f0gm1_hu6913714483517763590.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5yw0aj30qo0f0gm1_hu6822509707330837732.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5yw0aj30qo0f0gm1_hu6487640589260794462.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;一技术选型&#34;&gt;一、技术选型&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpr6w3j30qo0f0tbh_hu9523863768090529134.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpr6w3j30qo0f0tbh_hu10213842170772678783.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpr6w3j30qo0f0tbh_hu18241419275369606518.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpr6w3j30qo0f0tbh_hu9523863768090529134.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;先上来一堆要求，刚才我们提到过的，因为是大规模，而蚂蚁金服的体量，大家可以想象到的。实际上在性能，稳定性上，我们的衡量标准，我们考虑的基石，都是以蚂蚁金服这样的一个规模来考虑的。&lt;/p&gt;
&lt;p&gt;在这样一个规模下，我们会涉及到一些跟其他公司不太一样的地方，比如说：我们在&lt;strong&gt;性能&lt;/strong&gt;的考量上会比较重一些。因为如果性能不高的话，可能没法支撑我们这样一个规模。在考虑性能的时候，就有另外一层考量：架构和性能之间的这个权衡和取舍是要非常谨慎的。性能要求不太高的情况下，架构可能的选择，和需要比较高性能的情况下，可能会有完全不一样的取舍。稳定性就不必说了。&lt;/p&gt;
&lt;p&gt;部署方面的要求，首先是我们会用于多种场合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主站是指我们蚂蚁金服内部，比如大家用的最多的支付宝。&lt;/li&gt;
&lt;li&gt;金融云，可能有一部分和我们有联系的同学会有所了解，这个是我们推出的针对金融行业的云。&lt;/li&gt;
&lt;li&gt;然后还有我们的外部客户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;部署上会要求这三个场合都能使用。&lt;/p&gt;
&lt;p&gt;部署环境也会有多种，刚才我们调查到，有部分同学相对比较前沿一些，现在就已经上 k8s 了。有部分同学还是停留在以前的虚拟机以及物理机这种状态，也有一部分自己上了容器，还有部分同学可能会使用不同的公有云和私有云。这几种不同的环境，我们都是需要满足的。&lt;/p&gt;
&lt;p&gt;第三点可能要特殊一些，需要满足各种体系。刚才我们在调查的时候了解到，有部分同学是在做旧有系统改造，那在改造的时候就会遇到一个问题：除了 Service Mesh 之外，还需要跟原来的体系，比如说 SOFA，或者社区主流框架如 Dubbo，Spring Cloud，相互之间打通和过渡。怎么在技术转型期间平滑的让业务做变更，是我们在整个技术选型之前提出的实际要求。整个技术选型是在这样一个背景下进行的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2da5k87j30qo0f0djw_hu18138840212205777579.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2da5k87j30qo0f0djw_hu13642715753895476867.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2da5k87j30qo0f0djw_hu15207231318637898091.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2da5k87j30qo0f0djw_hu18138840212205777579.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们做技术选型的时候，有两大方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一个选择是在开源产品上做&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先看右边的路线，起点是找一个开源产品，fork 出来，做增强/扩展/定制，和内部集成。因为开源产品还在继续往前走，所以我们会持续做版本更新，也可以从社区拿到最新版本。相当于是从开源社区做&lt;strong&gt;获取&lt;/strong&gt;，然后接下来做反馈，让我们的一些产品，我们做的东西反馈回去。&lt;/p&gt;
&lt;p&gt;这条路线比较大的好处是从一开始就可以得到社区的支持，社区往前走的时候也跟着往前走。如果做的比较好，愿意让自己的产品反哺社区，那么社区也可以从中受益。&lt;/p&gt;
&lt;p&gt;当然这里面有一个小问题，就是说可能我们自己这个产品路线和开源产品路线可能会有一些分歧，可能我们领先一步，也可能他们领先一步，或者一个事情可能有两个做法。这种情况下，如何让社区的接受我们的改动，会变成这条路线上比较头疼的一个问题。&lt;/p&gt;
&lt;p&gt;这是两条路线上的第一条，选择以开源产品为起点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;另外一种思路全新打造&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;或者，如果手上已经有一套类库或者框架，可以在这个基础上做包装。&lt;/p&gt;
&lt;p&gt;这条路线有一个好处，&lt;strong&gt;可控性&lt;/strong&gt;比较强。因为整个体系是全新打造或者在原有体系上演进而来的，整套体系基本上都是自己的开发团队完全可控的。&lt;/p&gt;
&lt;p&gt;这条路线会遇到一个问题，因为长期上看我们也是希望开源的，而开源就意味着不能将自己内部太多的定制化的东西直接做进去，所以在架构上需要考虑可扩展性，可以定制化。因为开源出去的应该是一个标准产品，这样的产品才可以得到社区和客户的认可。客户希望看到一个干净的东西，也需要做扩展，整个体系在设计上会有所不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两条路线的终点，从图上看，我们有两个目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;第一个目标是内部落地&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面提到的，我们需要在蚂蚁金服主站这样的一个巨大规模的场景下落地，这是蚂蚁金服自身的需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;第二个目标是技术输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为蚂蚁金服在公司策略上有科技输出的内容，不仅仅我们自己用，我们还需要给出去。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在我们来看这个问题：目标在这里，然后有左右两条路线，我们该怎么选择？在做的技术选型的时候，这是一个非常大的分歧点，到底是从左边走，还是从右边走？&lt;/p&gt;
&lt;p&gt;在公布结果之前，我们先来看一下有什么可选方案。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ded119j30qo0f0acl_hu13887531649297475302.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ded119j30qo0f0acl_hu12812208654433207294.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ded119j30qo0f0acl_hu11109985652315671122.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ded119j30qo0f0acl_hu13887531649297475302.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是开源方案的选择，第一代的 Service Mesh。&lt;/p&gt;
&lt;p&gt;左边的 Linkerd，这个基本上，目前看，大家都已经有点嫌弃了。因为它没有控制平面，用 Scala 写的，基于 JVM，资源消耗比较大。它的可扩展性比较有限的，相对于 Envoy 的扩展性。然后它里面有个 dtab，有接触到的同学就会有认识：dtab 的语法，非常的不人性，很难理解，使用不太方便。另外它的功能是远远不够的，对于蚂蚁金服来说。另外这个产品本身的发展前景已经很暗淡了，所以这个选项就被淘汰了。&lt;/p&gt;
&lt;p&gt;Envoy 是非常不错的，做了一些令我们意外的事情：安心的去做好数据平面，没有往上面做很多的东西，而是创造性的提出了 XDS API。整个设计是非常优秀的，性能和稳定性也表现得非常好，甚至看到业界有一个趋势，有一部分的公司开始把他们的 nginx 替换了，不再用 nginx 了，而是用 envoy。也就是说，现在它的稳定性和性能达到和 nginx 一个级别，nginx 大家应该都有听说过，envoy 已经是这样一个工业成熟度。&lt;/p&gt;
&lt;p&gt;我们当时选型时是比较头疼的，因为它是 c++写的，c++14。和我们技术栈的差异会比较大，因为蚂蚁的技术栈是以 Java 为主，长期的话，我们可能部分转到 Golang 上去。在这种情况下，C++的技术栈，会让我们比较尴尬，也不是说我们找不到会 c++的同学，而是说，长期上会和我们的方向不一致，我们要在 Java 和 Golang 的技术栈之外再加一个 c++，这就比较难受。&lt;/p&gt;
&lt;p&gt;然后我们内部会有大量扩展和定制化的需求。因为我们内部有我们自己的产品，我们自己的需求，我们的通讯方案，我们内部的追踪，监控，日志方案，所以工作量非常大。&lt;/p&gt;
&lt;p&gt;总结说，我们觉得 Envoy 很好，但是我们不能简单用。但是它在数据平面上的表现我们是非常认可的，Envoy 在这点做得非常好。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6vxq4j30qo0f076f_hu14717074842691654906.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6vxq4j30qo0f076f_hu14619187698930718661.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6vxq4j30qo0f076f_hu4851506407747058640.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6vxq4j30qo0f076f_hu14717074842691654906.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;开源方案里面的第二代，istio 是我们当时的第一选择，重点关注对象。Istio 现在最大的问题在于它迟迟不能发布生产可用版本，大家如果对 istio 有了解的话，会知道 istio 刚刚发布了 0.8 版本，第一个长期支持版本，但是这个版本也不是生产可用。不出意外的话，按照目前的进度，istio 应该会在 7 月份发布它的 1.0 版本，但是从我们目前的感受上看，1.0 估计可能还是不能工业级的使用。所以需要等，而我们没法等，但是 Istio 的理念和方向我们非常认可。大家看一看，我们这个技术选型有多纠结。&lt;/p&gt;
&lt;p&gt;右边的 Conduit，现在 Conduit 的最大限制是它只支持 k8s。而现在蚂蚁金服还没有普及 k8s，我们现在还有很多系统是跑在非 k8s 上的。第二是它的数据平面是 Rust 编写的，这个语言更加小众了，在座的同学有没有人了解 Rust 这门语言？或者听过。（备注：现场大概十几个人举手）大概 10% 左右的同学听过。好，Rust 语言排名大概在 50 名左右。这个语言本身还是蛮认可的，我还很喜欢这个语言，它的一些特性还是非常有道理，如果掌握好还是可以写出非常好的产品，但是它的入门台阶会比较高一点。这个地方比较讨厌的事情是说，因为这个语言本身比较小众，所以基本上是没办法从社区借力的。这里可以举个例子，大家可以看一下 Conduit 的 committer 的人数，大概是 25 个左右，还包括像我这种只提交了几行代码的。Conduit 从 12 月份开源到现在已经有半年时间，半年时间只有这么多的 committer，其中真正有贡献大概 9 到 10 个人，基本上都是他自己的员工。也就说这个产品基本上没办法从社区借力，一个产品，如果大家一起来帮忙，其实很多的细节是可以完善的，但是 Conduit 就卡在 Rust 语言上。&lt;/p&gt;
&lt;p&gt;然后还是同样有技术栈的问题，因为这个原因，基本上 Conduit 我们也没法用了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddej49j30qo0f076w_hu16107585130709094939.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddej49j30qo0f076w_hu497940207688518686.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddej49j30qo0f076w_hu7814211392902486687.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddej49j30qo0f076w_hu16107585130709094939.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们再看一下国内的在 Service Mesh 领域，其他的一些比较前卫的同学，他们的选择会是什么？&lt;/p&gt;
&lt;p&gt;首先是华为，华为自己做了一套 Golang 版本，名字叫做 Mesher。这是由他们之前的一套类库演进而来。它走的路线是，先有类库和框架，然后加 proxy，proxy 打通了之后再慢慢的开始添加控制平面。这是一条非常非常标准的路线，我这边给一个词叫做&lt;strong&gt;老成持重&lt;/strong&gt;，因为这条路是最安全的：每一步都是基于现有的产品，很快就可以到下一个里程碑，然后每个里程碑都可以解决一些实际问题，可以直接得到一些红利，这个方案是比较比较稳妥的。比如说第一步是把 proxy 做进去，有了这个切入口之后，就在第一时间获取跨语言的红利，还有技术栈下沉的好处。然后控制平面的创新，可以在这个基础上慢慢往前做。&lt;/p&gt;
&lt;p&gt;在对接 Istio 这一条上，现在华为的策略，我们现在从公开途径了解到的是：部分对接 istio，也就是有一部分的 API 兼容 Istio。但是细节上还不太清楚，因为它的开源还没出来，目前得到的消息是，会在 7 月份开源。&lt;/p&gt;
&lt;p&gt;第二个是新浪微博的 Motan Mesh，他们也是 Golang 的，但他不太一样，是全新实现。他们用 Go 语言重新写了一把，主要原因是因为它没有 golang 类库，Motan 是基于 Java 的。&lt;/p&gt;
&lt;p&gt;刚才看到的这两个产品，他们的思路大体上是相同的，差异在哪里？就是启动的时候是用已有的类库还是重新写？这两个选择之间最大的麻烦在于编程语言，华为原来有 go 的类库，所以继续用 golang 包装一下就好了。但是新浪的类库用的是 Java，而 sidecar 选择的是 go 语言，所以只能重新做了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dao36ej30qo0dm0u2_hu582309646463656842.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dao36ej30qo0dm0u2_hu3150815062062523042.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dao36ej30qo0dm0u2_hu7654180567839653299.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dao36ej30qo0dm0u2_hu582309646463656842.webp&#34;
               width=&#34;760&#34;
               height=&#34;388&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们再看腾讯，最近看到他们有类似的产品出来。我们看看他们的资料：在数据平台上继续选择 Envoy，因为它比较成熟。腾讯的话大家比较熟悉，尤其是腾讯有非常深厚的 c++背景，所以 Envoy 对他们来说，技术栈是非常 OK 的。而且之前内部其他领域 Envoy 也是在用的，所以底层非常自然的选择了 Envoy。然后控制平面上，据传是&amp;quot;挣扎了一下&amp;quot;。这个词是我抄过的，&amp;ldquo;他们挣扎了一下&amp;rdquo;，最后还是选了 Istio。然后自己做定制和扩展，然后注意到他们也解耦了 k8s。这也是其中一个关键的点：要不要绑定 k8s？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d8l3mqj30qo0f0myg_hu5761351508457398469.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d8l3mqj30qo0f0myg_hu351649815808999184.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d8l3mqj30qo0f0myg_hu8804464229177548848.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d8l3mqj30qo0f0myg_hu5761351508457398469.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里还有 UCloud 的一个很有意思的做法，另辟蹊径啊。他的方案很有意思，是一个轻量级的实践：从 Istio 里面，将 Envoy 和 Pilot 单独剥离出来。就是说不用 Istio 整体，把 Mixer 和 Auth 的模块去掉，只要最重要的 Envoy，然后把 Pilot 剥离出来。然后这个 Pilot 还是个定制版，把其他的 adapter 干掉了。Pilot 主要是做服务发现，它底层用 ETCD，做了一个 ETCD 的 adapter，把其他的 adapter 从 Pilot 中去掉。做完这几个事情之后，整个体系就可以脱离 k8s 了，这是一个比较有意思的实践。&lt;/p&gt;
&lt;p&gt;总结：在讲我们技术决策过程之前，我们过了一下目前市场上的主要产品，以及一部分实践者的做法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dbkzxxj30qo0f0jto_hu14704771778668686754.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dbkzxxj30qo0f0jto_hu4265158241447812137.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dbkzxxj30qo0f0jto_hu13320918369730399501.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dbkzxxj30qo0f0jto_hu14704771778668686754.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们现在来详细讲一下，SOFA Mesh 在技术选型上的考虑。&lt;/p&gt;
&lt;p&gt;首先第一个，数据平台上 Envoy 是最符合我们要求的，Envoy 确实好。第二个事情是 Envoy 提出的 XDS API 设计是非常令人称道的，我们现在对这个的评价是非常高的。它实际上是一套通用的 API，由于时间的缘故，我今天就不在现场展开 API 的细节。只能说 XDS API 基本上已经成为数据平面和控制平面之间的一个事实标准。&lt;/p&gt;
&lt;p&gt;在这种情况下，我们其实是想用 Envoy 的，但是刚才提到我们有个技术栈选择的问题：我们不愿意将 c++纳入到我们主流的技术栈。然后我们本身有太多的扩展和定制，逼得我们不得不去改 Envoy，我们不能简单的拿过去用，我们需要做很多扩展的。&lt;/p&gt;
&lt;p&gt;另外一个事情是，我们这个 proxy 不仅仅是用于 Mesh，我们有可能把它引入到 API Gateway 里头，以及后面会提到的名为 Edge Sidecar 的模块。因为这个原因，所以，怎么说呢，想用，但是不合适用。&lt;/p&gt;
&lt;p&gt;第二就是在 Istio 上，控制平面这一块 Istio 可以说是做的最好的。基本上，到目前为止，在控制平面上，暂时我们还没有看到做的比 Istio 更好的产品，或者说思路。目前 Istio 整个设计理念，包括它的产品方向，也是我们非常认可的。&lt;/p&gt;
&lt;p&gt;但是 Istio 的性能是目前最大的问题，而我们有一个重要的前提：大规模应用。要用在蚂蚁金服主站这样一个场景下，性能和稳定性对我们非常非常的重要。第二个问题是它对非 k8s 的支持不够理想，因为我们还涉及到一个 k8s 没有完全上线的问题。第三个是和侵入式框架互通的问题，我们内部用的是 SOFA，对外推出的时候我们的客户用的可能是 Dubbo 或者 Spring Cloud，Mesh 上去之后，两个系统现在走不通，这是大问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpc73yj30qo0f00ur_hu983467906103683668.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpc73yj30qo0f00ur_hu5948240151454036660.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpc73yj30qo0f00ur_hu3814857006178049578.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gpc73yj30qo0f00ur_hu983467906103683668.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最终我们的策略是这样的，这是我们 SOFA Mesh 的技术选型：左边是 Istio 现有的架构，Envoy/Pilot/Mixer/Auth，右边是我们 SOFA Mesh 的架构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最重要的第一点：我们用 Golang 开发的 Sidecar 替换 Envoy，用 Golang 重写整个数据平面。&lt;/li&gt;
&lt;li&gt;第二点是我们会合并一部分的 Mixer 内容进到 Sidecar，也就是 Mixer 的一部分功能会直接做进 Sidecar。&lt;/li&gt;
&lt;li&gt;第三点是我们的 Pilot 和 Auth 会做扩展和增强。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是我们整个的技术选型方案，实际上是 Istio 的一个增强和扩展版本，我们会在整个 Istio 的大框架下去做这个事情，但是会做一些调整。&lt;/p&gt;
&lt;h2 id=&#34;二架构设计&#34;&gt;二、架构设计&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcxvr1j30qo0f0jru_hu6793886994948311814.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcxvr1j30qo0f0jru_hu2175340137019760632.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcxvr1j30qo0f0jru_hu11646750881432463586.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcxvr1j30qo0f0jru_hu6793886994948311814.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然后我们来详细介绍一下在这个技术选型上我们怎么去做实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d34esij30qo0f075z_hu523005859670650527.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d34esij30qo0f075z_hu14439554784329914054.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d34esij30qo0f075z_hu16157616719662794570.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d34esij30qo0f075z_hu523005859670650527.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先是 Golang 版本的 Sidecar，我们会参考 Envoy，非常明确的实现 XDS API。因为 XDS API 是目前的事实标准，所以我们选择遵循，然后我们会让它兼容 Istio。&lt;/p&gt;
&lt;p&gt;在协议支持上，我们会支持标准的 HTTP/1.1 和 HTTP/2，也就是大家常见的 REST 和 gRPC 协议。然后我们会增加一些特殊的协议扩展，包括 SOFA 协议，Dubbo 协议，HSF 协议。我们现在正在做这几个协议的扩展，然后 XDS API 我们支持，mixer service 我们没有改动，遵循现有实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dg7rw3j30qo0f0gnm_hu15527825236281541010.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dg7rw3j30qo0f0gnm_hu5705132077125683500.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dg7rw3j30qo0f0gnm_hu11346702669725814810.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dg7rw3j30qo0f0gnm_hu15527825236281541010.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最大的变化在 Mixer，其实刚才的 Sidecar 虽然是全新编写，但是说白了是做 Envoy 的替换，在架构上没有什么变化。但是第二步的变化就非常大，我们会合并一部分的 Mixer 功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mixer 的三大功能：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;check。也叫 precondition，前置条件检查，比如说黑白名单，权限。&lt;/li&gt;
&lt;li&gt;quota。比如说访问次数之类。&lt;/li&gt;
&lt;li&gt;report。比如说日志，度量等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三大功能里面，注意到，前两个功能是同步阻塞的，就是一定要检查通过，或者是说 quota 验证 OK，才能往下走。如果结果没回来只能等，因为这是业务逻辑，必须要等。而 Report 是可以通过异步和批量的方式来做的。&lt;/p&gt;
&lt;p&gt;在这里，我们现在的决策是：我们会将其中的两个部分 (check 和 quota) 合并进来，原有 report 部分我们会继续保留在 mixer 里面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dgq9tzj30qo0f0q59_hu4136933332235418818.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dgq9tzj30qo0f0q59_hu15438939178695464198.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dgq9tzj30qo0f0q59_hu2701906994535238688.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dgq9tzj30qo0f0q59_hu4136933332235418818.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可能大家会问：为什么我们要选择用这个方案，而不是遵循 Istio 的标准做法？我们之前聊到，我们会尽量去和 Istio 做兼容，跟随 Istio 的设计理念和产品方向，但是我们在它的架构上做了一个重大的调整。为什么？&lt;/p&gt;
&lt;p&gt;最大的问题就是&lt;strong&gt;对性能的影响&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给大家解释一下，看右边这个图，Envoy 在每次请求进来的时候，要去做两次调用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次在请求转发之前要做一次 check，这个 check 里面包含了 quota。Check 完成通过，才能把请求转发过去。&lt;/li&gt;
&lt;li&gt;请求转发完成之后，再调用 report，报告一下响应时间，日志，度量等信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每次 traffic 都会有两次调用：一次 check，一次 report。而这是远程调用，因为这两个模块是两个进程，Mixer 是单独部署的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步阻塞&lt;/strong&gt;意味着必须要等，&lt;strong&gt;远程调用&lt;/strong&gt;意味着有开销而且有延迟。这个事情是发生在&lt;strong&gt;每一次&lt;/strong&gt;请求里面，意味着整个的性能一定会受影响。而考虑到我们蚂蚁金服这样一个体量，其实我们是很难承受。所以我们有自己的观点：我们不是太认可这样的一个方式，我们的想法是说我们要把它拆分出来想一想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果是需要请求做同步阻塞的功能，比如说黑白名单的验证，可能要检查 IP 地址，可能检查 quota。这些逼请求一定要做同步阻塞等待结果的功能，就&lt;strong&gt;不应该放在 Mixer 中&lt;/strong&gt;去完成去远程调用，而应该在 Sidecar 中完成。&lt;/p&gt;
&lt;p&gt;这是我们的观点，原因就是远程调用带来的系统开销，这个代价实在是太高了！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后其他的功能，比如说可以优化为异步的，或者可以以批量方式来提交的，最典型的就是 Report。Report 其实是可以异步提交，可以把十个请求打包到一个 report 同时提交，这些都是 OK 的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是我们的基本想法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d4iuw2j30qo0e5jtm_hu1841193172386835935.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d4iuw2j30qo0e5jtm_hu14329121875737978389.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d4iuw2j30qo0e5jtm_hu16807397327045341869.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d4iuw2j30qo0e5jtm_hu1841193172386835935.webp&#34;
               width=&#34;760&#34;
               height=&#34;403&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个问题其实在 Istio 里面是给了一个解决方案的。最早的时候，Istio 0.1 版本中，一出来就发现这个问题。从去年 5 月份开始到现在，13 个月的时间里，他只给了一个解决方案，就是在 Mixer 上的这个位置加了一个 Cache。这个的 Cache 的想法是：把这些结果缓存在 Envoy 的内存里面，如果下次的检查参数是相同的，那我们可以根据这样一个缓冲的设计，拿到已经缓存的结果，就可以避免远程调用。这个方式是很理想的，对吧？只要缓存能够命中，那就可以避免这一次远程调用。&lt;/p&gt;
&lt;p&gt;然后第二个优化是 report，现在的 report 是通过异步模式完成的，而且是批量。&lt;/p&gt;
&lt;p&gt;理论上说，如果这两个事情做到足够理想，Mixer 应该就不是瓶颈。对吧？&lt;/p&gt;
&lt;p&gt;问题在于：这个 Cache 真的搞得定吗？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5hscdj30qo0f00ul_hu1550326212382661359.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5hscdj30qo0f00ul_hu2978284629323164349.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5hscdj30qo0f00ul_hu16598313810350299465.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d5hscdj30qo0f00ul_hu1550326212382661359.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们给一个简单的例子，我现在假设 Mixer 有三个 adapter。然后它的输入值是不同的属性，属性是 istio 的概念，理解为若干个输入值。假设，需要三个 adapter 分别检查 A/B/C。如果这三个属性 A/B/C，他们只有 100 个取值范围，每个都是从 0 到 100，我们假设这种最简单的场景。&lt;/p&gt;
&lt;p&gt;如果这三个 adapter 分别做缓存的话，需要多少个缓存项？很容易计算吧？100 个 a，100 个 b，100 个 c，非常容易计算，这种情况下，其实就是 a+b+c 等于 300 嘛。理解一下：有三个输入，每个输入只有一百个取值范围，我们要把他们缓存起来。这些缓存大小，就是允许的范围，然后加起来。只要有 300 个 key，就都可以缓存起来。&lt;/p&gt;
&lt;p&gt;但是，这个方法中，缓存是做在 mixer 这边，每个 adapter 单独缓存。但是，在 Istio 中，缓存是做在 Envoy 这端的，因为做在 mixer 这端是没有用的，还是要远程调用过去。它做缓存的很重要的目标是要在客户端避免远程调用。所以，这种情况下，把缓存放到这里（备注，图中绿色方块）。&lt;/p&gt;
&lt;p&gt;大家现在想一想，现在这里只有一个缓存，只有一个 key/value。现在还有刚才的这个场景，A/B/C 各自的取值范围都是一百。但是现在缓存放在这边的话，实际上的这个 key 要考虑三个值了，A/B/C 的组合。这种情况下，它的最大缓存个数是多少？&lt;/p&gt;
&lt;p&gt;（备注：现场回答，a 乘 b 乘 c）&lt;/p&gt;
&lt;p&gt;a * b * c？还能 a + b + c 吗？做不到了，对不对？现在是 a * b * c，从 300 变成这么大的数了。为什么？因为缓存是在这个地方做的，根本没有办法像这样分开做，所以这里就变成了一个笛卡尔乘积。&lt;/p&gt;
&lt;p&gt;这个笛卡尔乘积有一个很大的麻烦，也就是说，如果 adapter 检查的某个属性，它的取值范围比较大，比如说要检查客户端的 IP 地址？你想想，这个 IP 地址有多少个取值范围？数以几十万几百万计，对吧？这种情况，哪怕在前面再乘以特别小的值，哪怕只是十，二十，如果是加 20 根本没所谓的，加 200，加 2000 都没所谓的，那乘个 200，乘个 2000 试一下？瞬间就被干掉。IP 地址可能只是百万级别，再在前面乘个 100，乘个 1000，瞬间就疯掉了。这个 key 值基本上已经是大到不能接受：要么就全放内存，内存爆掉；要不然限制缓存大小，就放 1 万个，缓存的命中率会非常低，整个缓存相当于失效了。&lt;/p&gt;
&lt;p&gt;这个细节，因为时间原因，不在这里详细讲了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6h2fgj30qo0dzq50_hu18090362109142685591.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6h2fgj30qo0dzq50_hu1587999155316501906.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6h2fgj30qo0dzq50_hu5183591816288738481.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d6h2fgj30qo0dzq50_hu18090362109142685591.webp&#34;
               width=&#34;760&#34;
               height=&#34;398&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里讲第二点，我们的反省：隔离怎么做？&lt;/p&gt;
&lt;p&gt;Mixer 有一个基本的设计目标，就是希望提供一个统一的抽象（就是这个 adapter 的概念），用它来隔离基础设施后端和 Istio 的其他部分。但是在这个点上我们的反思是：我们认可这样一个隔离。大家理解基础设施后端的概念吧？举个例子，日志处理如 prometheus，各种后端监控系统。这些系统和应用之间，我们认为这种情况下的确应该做隔离，没必要每个应用都去和基础设施后端产生直接的联系。这个观点是我们是赞许的。&lt;/p&gt;
&lt;p&gt;但是我们现在的意见是，我们把这条线 (备注：连接应用和基础设施后端的标记有红叉的线) 从应用里面拿下来之后，我们把它下沉。下沉到 Sidecar，够不够？Istio 的做法是，它觉得这个地方应该再往前走一步，到 Mixer 里面。由 Mixer 去完成和基础设施后端的连接，走这根线（备注：图中连接 Mixer 和基础设施后端的线）。但是多了这样一个隔离之后的代价，就是在中间的这根红线上，会多一次远程调用。&lt;/p&gt;
&lt;p&gt;现在只有两个选择：和基础设施怎么连？这条线（备注：最左边的）大家都认为没必要，这两条线（备注：中间和右边的线）之间选，两条线的差异，就是要付出一次远程调用的代价。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcki7oj30qo0f0dim_hu10243054460757786271.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcki7oj30qo0f0dim_hu12794350836494604112.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcki7oj30qo0f0dim_hu1138152597363942199.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dcki7oj30qo0f0dim_hu10243054460757786271.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;继续反省：什么是基础设施后端？&lt;/p&gt;
&lt;p&gt;这里我们做一个列表，整个 Istio 现有的 adapter，大家可以看到，大概是这些。前面这两个部分是实现 check 和 quota 的 adapter，后面这些 adapter 是实现 report 功能。&lt;/p&gt;
&lt;p&gt;在这里，我们的反省是：这些功能，比如说黑白名单，比如说基于内存的 quota，或者基于外部 redis 的 quota。我们认为这些功能不太应该视为后端基础设施，因为这些功能更应该是说是体系内置的基本能力，应该直接把它们做成 Mesh 的内置产品，或者说可以做标准化，然后和外部系统集成。这些我认为应该是 Mesh 的最基础的功能，比如说我们 SOFA Mesh 可以提供基于 Redis 的 quota 方案，直接就把这个功能给出来了。我不认为应该再去跟外界的一个所谓的基础设施后端发生联系。&lt;/p&gt;
&lt;p&gt;但是下面这些我们是觉得 OK 的。这些 adapter 大家有概念吧，prometheus 大家应该都接触过的。剩下的这些在国内可能用的不多，是各种日志和 metric 相关的功能。把这些视为基础设施后端，我们是非常理解的。包括我们内部，我们蚂蚁也有很多这样的系统，相信各位自家的监控方案也是不一样的。&lt;/p&gt;
&lt;p&gt;这些视为基础设施，和系统隔离开，我们认为这是非常有必要，可以理解，可以接受。&lt;/p&gt;
&lt;p&gt;这是我们在这一点（备注：何为基础设施后端）上和 istio 的差异。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d3qprxj30qo0f0juf_hu15357110675602466814.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d3qprxj30qo0f0juf_hu9164627453872443416.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d3qprxj30qo0f0juf_hu7469500731471754858.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d3qprxj30qo0f0juf_hu15357110675602466814.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;因为时间原因，我们就不再深入去讲，这里我给了一些我博客上的文章。前段时间，我们在做技术选型，在做前面整个架构设计时，在这一点上有些讨论。以及我们最重要的决策：为什么要把 Mixer 合并进去。细节都在这几篇文章里面，大家如果有兴趣，可以去详细了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注链接地址&lt;/strong&gt;（请复制网址到浏览器打开）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://skyao.io/post/201804-servicemesh-architecture-introspection/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh 架构反思：数据平面和控制平面的界线该如何划定？&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://skyao.io/post/201804-istio-achilles-heel/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mixer Cache: Istio 的阿克琉斯之踵&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://skyao.io/post/201804-istio-mixer-cache-concepts/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Mixer Cache 工作原理与源码分析 (1)－基本概念&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://skyao.io/post/201806-istio-mixer-cache-principle/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Mixer Cache 工作原理与源码分析 (2)－工作原理&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://skyao.io/post/201806-istio-mixer-cache-main/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Mixer Cache 工作原理与源码分析 (3)－主流程&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://skyao.io/post/201806-istio-mixer-cache-signature/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Mixer Cache 工作原理与源码分析 (4)－签名&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0rypsj30qo0f0mza_hu8294782486495809526.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0rypsj30qo0f0mza_hu12239494412446531200.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0rypsj30qo0f0mza_hu5930130581670420654.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0rypsj30qo0f0mza_hu8294782486495809526.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们还有一部分现在没有合并进来的 adapter 和 mixer，report 的这部分。但是这块不是说完全没有问题，我们现在有一个担心，report 这块可能会存在一个叫做&lt;strong&gt;网络集中&lt;/strong&gt;的问题。比如说，大家会注意到，应用和 Sidecar 是一对一部署的，有一万个应用，就有一万个 Sidecar。基础设施后端也是多机部署的。&lt;/p&gt;
&lt;p&gt;而现在的方式，流量会先打到 Mixer 来，Mixer 也是高可用的，也是会部署多台。但是这个数量肯定不是一万这个级别，跟这个肯定会有很大的差异。这样流量会先集中，通道会突然间收缩一下。总的流量没变，但是通道的口径要小很多。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7f735j30qo0f00uz_hu12396090418326244317.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7f735j30qo0f00uz_hu5602710769481261638.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7f735j30qo0f00uz_hu10508575828155324588.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7f735j30qo0f00uz_hu12396090418326244317.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对网络吞吐量也会有影响。比如最简单的，如果应用直连，走交换机直接就过去了。&lt;/p&gt;
&lt;p&gt;如果是 Sidecar 模式，是在这个位置上（备注：应用和 sidecar 之间的绿色连线）加一个远程调用，但是应用和 Sidecar 之间走的是 localhost，localhost 根本就不走网卡，直接环回地址就走了。对性能不会有什么影响，对网络流量的影响就为零了。所以这两个方案相比，吞吐量不会有变化。&lt;/p&gt;
&lt;p&gt;但是，如果在 Sidecar 和 Backend 之间再加一个 Mixer，这意味着要走两次网络，这样的话会有一个流量翻倍的问题。&lt;/p&gt;
&lt;p&gt;所以这个地方可能会带来一些问题，但暂时我们现在还没做决策，我们现在还不是很确定这个问题会不会导致质的影响。所以我们现在暂时还是把它放在这里，就是说我们后面会做验证，如果在我们的网络方案下，这个方式有问题的话，我们可能再合进去。但是如果没问题的话，我们认为分开之后架构确实会更理想一些，所以我们现在暂时先不合并。&lt;/p&gt;
&lt;p&gt;给大家一些参考，目前 Conduit 最新版本已经把 report 的功能合并进来，然后 check 的功能，会在后续的计划中合并。我们在国内做一些技术交流，华为新浪微博他们现在通通都是选择在 Sidecar 里面实现功能，不走 mixer。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dh5nayj30qo0f00w1_hu7703442203878661555.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dh5nayj30qo0f00w1_hu16687063141164085539.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dh5nayj30qo0f00w1_hu9900912831531149052.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dh5nayj30qo0f00w1_hu7703442203878661555.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是我们称之为梦幻级别的服务注册和治理中心，我们对他的要求是比较多的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们需要他支持跨集群，比如说我们现在有多个注册中心，多个注册中心之间可以相互同步信息，然后可以做跨注册中心的调用&lt;/li&gt;
&lt;li&gt;还有支持异构，注册中心可能是不一样的东西。能理解吧，有些是 Service Mesh 的注册中心，比如 Istio 的，有些是 Spring Cloud 的注册中心，比如 Consul。&lt;/li&gt;
&lt;li&gt;然后终极形态，我们希望在两种场景都可以支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;右边的这个图，是我们构想中的比较理想化的注册中心的架构，我们会有各种 adapter 实现，会有一个抽象的模型，把他们抽象起来，然后有一些接口。后来，在我们实现的时候发现，Istio 的路线跟我们有点像，Istio 本身也是做了跨平台的 Adapter，也做了一层抽象，然后它也提出了一些 API。所以我们最终的决策是：往 Pilot 靠。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d2nt63j30qo0f0mzb_hu1211632967603182894.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d2nt63j30qo0f0mzb_hu11109710744696705689.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d2nt63j30qo0f0mzb_hu18162147823729619155.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d2nt63j30qo0f0mzb_hu1211632967603182894.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们以 Istio 的 Pilot 模块为基础去做扩展和增强：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加 SOFA Registry 的 Adapter，SOFA Registry 是我们内部的服务注册中心，提供超大规模的服务注册和服务发现的解决方案。所谓超大规模，大家能理解吧？服务数以万计。&lt;/li&gt;
&lt;li&gt;再加一个数据同步的模块，来实现多个服务注册中心之间的数据交换。&lt;/li&gt;
&lt;li&gt;然后第三点就是希望加一个 Open Service Registry API，增加服务注册，因为现在 Istio 的方案只有服务发现，它的服务注册是走 k8s 的，用的是 k8s 的自动服务注册。如果想脱离 k8s 环境，就要提供服务注册的方案。在服务发现和服务模型已经标准化的情况下，我们希望服务注册的 API 也能标准化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d97ijxj30qo0f00ve_hu263899772797155411.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d97ijxj30qo0f00ve_hu18008759513247093402.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d97ijxj30qo0f00ve_hu16498493876641546241.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d97ijxj30qo0f00ve_hu263899772797155411.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里还有一个比较特殊的产品，因为时间限制，给大家简单了解一下。&lt;/p&gt;
&lt;p&gt;我们计划的 Edge Sidecar 这个产品，它是东西向服务间通讯的一个特殊桥梁。所谓东西向，大家能理解吧？东西向指服务间通讯，也就是 A 服务调用 B 服务。对应的还有南北向，南北向通常是指从外部网络进来调用服务，如走 API Gateway 调用服务。在东西向通讯中，我们有时会需要一个比较特殊的途径，比如说在这个图中，我们有两个集群，两个集群各有各自的服务注册中心。我们通过增强 Pilot 的方式打通两个注册中心，可以知道对方有什么服务。&lt;/p&gt;
&lt;p&gt;当 A 服务发出一个请求去调用 B 服务的时候，由于两个集群是隔离的，网络无法相通，肯定直接调用不到的。这时 local sidecar 会发现，服务 B 不在本集群，而在右边这个集群里，Local Sidecar 就会将请求转发给 Edge Sidecar，然后由 Edge Sidecar 接力完成后续的工作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2db3805j30qo0f0tas_hu13452475383429894367.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2db3805j30qo0f0tas_hu7161354625836806111.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2db3805j30qo0f0tas_hu10702510564354025075.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2db3805j30qo0f0tas_hu13452475383429894367.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个模块的功能会比较特殊一点，因为时间限制，在今天的过程当中，Pilot 和 Edge Sidecar 就不再详细展开。&lt;/p&gt;
&lt;p&gt;下个月在北京的 meetup 上，我们这边负责这一块工作的专家，俊雄同学，会给大家详细展开。&lt;/p&gt;
&lt;h2 id=&#34;三开源策略&#34;&gt;三、开源策略&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddv17cj30qo0f074r_hu2916489401729592870.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddv17cj30qo0f074r_hu15750321111847533783.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddv17cj30qo0f074r_hu2787439079356167419.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2ddv17cj30qo0f074r_hu2916489401729592870.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFA Mesh 的开源策略，可能会和大家之前接触到的一些开源产品，有质的差异，非常的不一样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0glyij30qo0f077i_hu10233846316508625678.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0glyij30qo0f077i_hu12713749595257793803.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0glyij30qo0f077i_hu3194516193544240466.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d0glyij30qo0f077i_hu10233846316508625678.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;备注：这块就不整理了，直接看图中文字。&lt;/p&gt;
&lt;p&gt;这是整个大的愿景。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfat8jj30qo0f0n00_hu11846608500716851646.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfat8jj30qo0f0n00_hu5750766371113999100.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfat8jj30qo0f0n00_hu6919131487657168388.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfat8jj30qo0f0n00_hu11846608500716851646.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFA Mesh 的开源态度，其实我写左边这些的时候是有很大压力的。用官方话语说，不针对任何人和任何项目，我们不影射任何人。&lt;/p&gt;
&lt;p&gt;但是，大家如果经常用各种开源产品的话，会发现一些问题。比如说，开源的时机。大家接触的开源产品，尤其是国内的，不管是多大的公司，通常都是产品完成之后，甚至是使用好多年。好处是相对稳，缺点是什么？（备注：现场回答，老）对，技术可能已经很老了，十年前的！还有可能是它都已经放弃了，开源出来时自己不再使用。或者说是一个很新的产品，真的很新，他自己不用，说就是做出来给你用的。（备注：现场哄笑）自己不用的产品给你用，你的第一反应是什么？小白鼠是吗？你愿意做小白鼠吗？你敢把公司的这个产品放上面吗？&lt;/p&gt;
&lt;p&gt;SOFA Mesh 这次比较特殊，非常非常特殊。我们这个产品，会在非常早的时间点上开源给大家。我甚至可以跟大家说，其实在这个点上，我们更重要的是摆明态度：我们要开源，我们要把这个产品开源给大家，甚至早到我们自己都不认为这是一个完整的产品。为什么？&lt;/p&gt;
&lt;p&gt;有几个事情，这几点大家认可吧？业界最新的技术，Mesh 是最新技术大家都已经达成共识了吧？业界最好的架构，当然这个我们还在努力中，尽量做好。然后我们会给大家一个承诺，大家不用担心做小白鼠，你能拿到的产品，我们已经趟过一遍了。&lt;/p&gt;
&lt;p&gt;开源动机，这个地方我们也不说大话，就是我们希望能吸引整个社区，谋求这样一个合作，走开源共建的方式。这是为什么我们会选择在现在这个时间点上开源出来。&lt;/p&gt;
&lt;p&gt;整个产品的维护，什么样的产品会让你有信心，不用担心中间断掉？最重要的一点是我们自己在用。想想，如果支付宝在用，你担心这个项目死掉吗？对不对？如果这个产品本身是蚂蚁金服这样级别的公司，在它的线上将会使用的产品，而且是同样一个核心的版本。相信在这种情况下，大家就放心了吧？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gq7wlrj30qo0f076u_hu3829506033761808923.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gq7wlrj30qo0f076u_hu17831476838271481125.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gq7wlrj30qo0f076u_hu4509276693295211817.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2gq7wlrj30qo0f076u_hu3829506033761808923.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFA Mesh 的合作模式，我称之为&amp;quot;多层次全方位开放&amp;quot;。&lt;/p&gt;
&lt;p&gt;中间这幅图，最底下的是&lt;strong&gt;基础类库&lt;/strong&gt;，实现各种功能。我们希望有这样一套基础类库，类比 Netflix 的 OSS 套件。因为 Golang 的类库做的不是很好，没有 Java 沉淀的那么好。目标是希望在这个产品做完之后，能给整个社区沉淀出一套 Golang 的微服务基础类库。最重要的一点，是希望最好能大家合力，在这个点上做出一套成熟稳定性能足够好的产品。这是在类库层面。&lt;/p&gt;
&lt;p&gt;在类库之上，功能模块层面，比如说 Golang 版本的 Sidecar，我们希望它能替换 Envoy 的功能。在原来使用 Envoy 的情况下可以使用这个 Sidecar 来替代。体现在什么层次？就是说，如果想用 Envoy，也很喜欢它，但是可能又受限于 C++语言栈，更希望是 Golang 语言栈的时候，可以选择我们这一套。或者如果我们抱有同样的想法，比如想把 Mixer 合进来，可以在 Sidecar 这个层面上来重用我们的产品，跟我们做合作。或者我们刚才提到的这个产品，增强版本的 Pilot，大家有印象吧？我们会实现一个非常强大的，跨各种集群，各种异构的服务注册机制。然后是 Edge Sidecar，在两个不同的区域之间，比如两个不同的机房，IP 地址不通的情况下，帮你打通服务间调用。这些功能模块，会以单独的产品和项目出现，你可以在某一个产品上跟我们合作。&lt;/p&gt;
&lt;p&gt;第三点就是完整的产品，如果你需要一个完整的 Service Mesh 的产品，把这些所有的功能都包括进来，没问题，SOFA Mesh 可以拿来用。&lt;/p&gt;
&lt;p&gt;有些同学可能会需要更完整的解决方案，我们的金融云会提供 SOFA Mesh 的支持，这是我们的目标。你可以将你的系统，架构在金融云之上。&lt;/p&gt;
&lt;p&gt;今天的几位讲师来自不同的公司，我们非常欢迎业界参与。如果大家有意在 Service Mesh 领域做一些事情，大家可以相互之间做技术的沟通，技术的交流，在社区合作上做一些事情。&lt;/p&gt;
&lt;p&gt;有些同学说，我只是用一下，好像没法做什么贡献。其实，&amp;ldquo;用&amp;quot;是一个很重要的合作，你能够用，你就会遇到问题，有你的诉求，遇到什么样的 bug，有什么样需求没有满足。这些对我们来说，是非常重要的输入。在这一点上，欢迎和我们保持合作。 















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d18aozj30qo0f0406_hu16328704810095191069.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d18aozj30qo0f0406_hu2009673910984748862.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d18aozj30qo0f0406_hu17471746923470488419.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d18aozj30qo0f0406_hu16328704810095191069.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFA Mesh 的开源宣言，写的比较狗血。但是在这一点上，我觉得这一次 SOFA Mesh 在开源上还是做的比较有诚意。&lt;/p&gt;
&lt;p&gt;首先我们认可这个大方向，我们看好 Service Mesh 的前景。体现在什么上呢？我们现在规划，未来整个蚂蚁金服内部的大部分应用都会逐渐的往 Service Mesh 上落。这个内部已经达成一致了，会往这个方向走。&lt;/p&gt;
&lt;p&gt;第二是说，&amp;ldquo;勇敢探索&amp;rdquo;，&amp;ldquo;耐心填坑&amp;rdquo;，有在 1.0 版本之前用过大型开源产品的同学，对这两个词都应该有深刻体验，对吧？包括前两年用 0.*版本和 1.1/1.2 版本的 k8s 的同学。任何一个新的技术，一个大的方案出来，前期的时候，这些事情是一定会遇到的。但是我们觉得还是要去趟这个事情。&lt;/p&gt;
&lt;p&gt;我们要继续推进这样一个技术进步，包括 Service Mesh 技术社区的推广。大家如果有注意的话说，Service Mesh 技术社区已经重新启动了，我们在跟很多的公司，包括甚至我们一些竞争对手合作。从技术进步的角度说，我们欢迎大家在一个公平的基础上做技术交流。&lt;/p&gt;
&lt;p&gt;然后我们是愿意做分享的，整个产品，我们接下来所有能开源的东西都会开源出来。除了一些内部定制化的东西，内部没有开源的产品的集成。基本上，你们能看到的东西，也就是我们内部用的东西。&lt;/p&gt;
&lt;p&gt;我们寻求和大家的合作，包括刚才讲过的各个层面的合作，哪怕是简单的使用，发现问题给我们提交一些 bug，也是非常好的合作契机。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfuqcij30qo0f0wg4_hu18005089303896320045.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfuqcij30qo0f0wg4_hu4208637637766965054.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfuqcij30qo0f0wg4_hu4633324848969402047.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2dfuqcij30qo0f0wg4_hu18005089303896320045.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里我喊一个口号，这个口号有点大，&amp;ldquo;集结中国力量，共建开源精品&amp;rdquo;。这里面有个词，比较大一点，我也斟酌了一下，中国这两个字敢不敢用。最后我觉得还是用吧，至少到目前为止，Service Mesh 这个技术领域，在全世界目前都还没有成熟的场景落地的情况下，我们目前在这方面的探索，已经是走在最前面的了。&lt;/p&gt;
&lt;p&gt;在这一点上，我们是希望能联合国内在这个领域做探索的同学，我们一起来做这个事情。我们开源的一个重要目的，是说不管大家在商业上有什么样的竞争，至少在技术领域上，包括刚才说的可以在类库层面，产品层面，或者社区合作方面，开展合作。我们希望能够尽可能的联合国内的合作伙伴，包括竞争对手一起来营造整个技术氛围，把整个 Service Mesh 技术体系的基本水准提升上来。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7u1q9j30qo0bwjru_hu8154725271960870220.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7u1q9j30qo0bwjru_hu15878192607078999163.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7u1q9j30qo0bwjru_hu15299250143092659742.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d7u1q9j30qo0bwjru_hu8154725271960870220.webp&#34;
               width=&#34;760&#34;
               height=&#34;339&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这一点应该是大家比较关注的，什么时候开源？我们只能告诉大家说，on the way，正在路上。&lt;/p&gt;
&lt;p&gt;本来这一页的写法应该是贴个地址给大家的，但是因为进度的原因还没有实现，有可能会在一到两个星期之后，在 7 月份的时候开源给大家。&lt;/p&gt;
&lt;p&gt;需要澄清的一点，大家的期望值不要太高，因为我们开源出来的第一个版本，主要是释放姿态，把我们的开源共建的姿态释放出来。我们的第一个版本，肯定不是一个完善的版本。（备注：现场有同学问，有在用吗？）内部有用一部分，Sidecar 内部已经在用了，但是第二部分的内容，比如说 XDS API 的集成，我们现在正在做。我们不希望等把产品做完善了，比如说两年之后非常成熟的情况下再来开源。我们希望尽可能早的开源。&lt;/p&gt;
&lt;p&gt;（备注：现场提问，7 月份的版本，不一定是生产环境可用？）对，是的。有一部分功能是生产可用的，有一部分功能不是，因为我们是迭代上去的。&lt;/p&gt;
&lt;h2 id=&#34;四官方社区网站&#34;&gt;四、官方社区网站&lt;/h2&gt;
&lt;p&gt;这是我们刚刚开通的&lt;a href=&#34;https://www.servicemesher.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh 技术社区的官方网站&lt;/a&gt;，欢迎访问。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d27g5jj30qo0f00ui_hu695955941887222196.webp 400w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d27g5jj30qo0f00ui_hu12122091292375566243.webp 760w,
               /blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d27g5jj30qo0f00ui_hu4306820335595108834.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/006y8mN6ly1g8g2d27g5jj30qo0f00ui_hu695955941887222196.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服是如何实现经典服务化架构向 Service Mesh 方向演进的？</title>
      <link>https://cloudnativecn.com/blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/</link>
      <pubDate>Wed, 13 Jun 2018 18:58:33 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/</guid>
      <description>&lt;p&gt;















&lt;figure  id=&#34;figure-黄挺在-giac-演讲&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;黄挺在 GIAC 演讲&#34; srcset=&#34;
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rcu78elj30u00knql3_hu15307433024144272168.webp 400w,
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rcu78elj30u00knql3_hu1519776747655159661.webp 760w,
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rcu78elj30u00knql3_hu9900567979290221730.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rcu78elj30u00knql3_hu15307433024144272168.webp&#34;
               width=&#34;760&#34;
               height=&#34;523&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      黄挺在 GIAC 演讲
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;蚂蚁金服在服务化上面已经经过多年的沉淀，支撑了每年双十一的高峰峰值。Service Mesh 作为微服务的一个新方向，在最近两年成为领域的一个大热点，但是如何从经典服务化架构往 Service Mesh 的方向上演进，中间可能会遇到什么样的问题，几乎没有可以借鉴的经验。&lt;/p&gt;
&lt;p&gt;本文会给大家分享 Service Mesh 在蚂蚁金服的演进历程和在 2018 年 6 月举办的 GIAC 全球互联网架构大会中蚂蚁金服高级技术专家与现场人员关于 Service Mesh 的热门 QA 互动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在过去的一段时间中蚂蚁金服已经开始采用 Service Mesh 来帮助解决一些架构上的问题，并且在 Service Mesh 如何更好地与经典的服务化架构结合上有一定的经验，希望借此分享和大家交流我们这部分的实践。使大家对蚂蚁金服当前的服务化架构有更多了解，并对 Service Mesh 如何解决经典服务化架构中的问题以及蚂蚁金服实际在落地 Service Mesh 中的时候的一些设计考虑和未来展望有更进一步的了解，也希望能与行业分享蚂蚁金服服务化架构现状。&lt;/p&gt;
&lt;p&gt;蚂蚁金服从单体应用转移到服务化的架构下已经经过了差不多 10 年的时间，在整个过程中，为了满足蚂蚁金服金融级的要求，我们也构建了一整套地面向金融级的分布式架构的解决方案，也就是 SOFA。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SOFA 其实包含了金融级分布式中间件，CICD 以及 PAAS 平台&lt;/strong&gt;。SOFA 中间件部分包含的内容包括 SOFABoot 研发框架、SOFA 微服务相关的框架（RPC，服务注册中心，批处理框架，动态配置等等）、消息中间件、分布式事务和分布式数据访问等等中间件。&lt;/p&gt;
&lt;p&gt;以上的这些中间件都是基于 Java 技术栈的，目前 SOFA 在蚂蚁金服内部大概超过 90% 的系统在使用，除了这些系统之外，还有剩下的 10% 的系统，采用 NodeJS，C++，Python 等等技术栈研发的。这剩下的 10% 的系统想要融入到 SOFA 的整个体系中，一种办法是用对应的语言再去写一遍 SOFA 中间件的各个部分对应的客户端。&lt;/p&gt;
&lt;p&gt;事实上，之前我们正是这么干的，蚂蚁金服内部之前就有一套用 NodeJS 搞的 SOFA 各个组件的客户端，但是最近几年随着 AI 等领域的兴起，C++ 也在蚂蚁金服内部也在被应用到越来越多的地方，那么我们是否也要用 C++ 再来写一遍 SOFA 中间件的各个客户端？如果我们继续采用这种方式去支持 C++ 的系统，首先会遇到成本上的问题，每个语言一套中间件的客户端，这些中间件的客户端就像一个个烟囱，都需要独立地去维护，去升级。另一方面，从稳定性上来讲，之前 Java 的客户端踩过的一些坑，可能其他的语言又得重新再踩一遍坑。&lt;/p&gt;
&lt;p&gt;对于多语言的问题来说，Service Mesh 其实就很好地解决了这部分的问题，通过 Service Mesh 的方案，我们可以尽量把最多的功能从中间件的客户端中移到 Sidecar 中，这样就可以做到一次实现，就搞定掉所有语言，这个对于基础设施团队来说，在成本和稳定性上都是一个提升。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sofa&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SOFA&#34; srcset=&#34;
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rdr5b6qj30u00c9djg_hu16565239967107851887.webp 400w,
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rdr5b6qj30u00c9djg_hu11452510032790028067.webp 760w,
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rdr5b6qj30u00c9djg_hu1530873627584923960.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rdr5b6qj30u00c9djg_hu16565239967107851887.webp&#34;
               width=&#34;760&#34;
               height=&#34;310&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SOFA
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;另外的一个问题其实是所有在往云原生架构中转型的公司都会遇到的问题，云原生看起来非常美好，但是我们怎么渐进式的演进到云原生的架构下？特别是对于遗留系统，到底怎么做比较好。当然，一种简单粗暴的方式就是直接用云原生的设施和架构重新写一套，但是这样，投入的成本就非常高，而且重写就意味着可能会引入 Bug，导致线上的稳定性的问题。那么有没有一种方式可以让这些遗留系统非常便捷地享受到云原生带来的好处呢？Service Mesh 其实为我们指明了一个方向，&lt;strong&gt;通过 Service Mesh，我们为遗留系统安上一个 Sidecar，少量地修改遗留系统的配置甚至不用修改遗留系统的配置就可以让遗留系统享受到服务发现，限流熔断，故障注入等等能力。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sofa&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SOFA&#34; srcset=&#34;
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9redau0pj30u00dgtcv_hu11466387861563843170.webp 400w,
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9redau0pj30u00dgtcv_hu2807317686293491508.webp 760w,
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9redau0pj30u00dgtcv_hu16602082221955925339.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9redau0pj30u00dgtcv_hu11466387861563843170.webp&#34;
               width=&#34;760&#34;
               height=&#34;340&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SOFA
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们在蚂蚁金服的服务化的过程中遇到的问题是中间件升级的问题，蚂蚁金融从单体应用演进到服务化的架构，再演进到单元化的架构，再演进到弹性架构，其实伴随了大量中间件升级，每次升级，中间件不用说要出新的版本去提供新的能力，业务系统也需要升级依赖的中间件，这中间再出个 Bug，又得重新升级一遍，不光是中间件研发同学痛苦，应用的研发同学也非常痛苦。&lt;/p&gt;
&lt;p&gt;我们从单体应用演进到了服务化的架构，从原来好几个团队维护同一个应用，到各个团队去维护各自领域的应用，团队之间通过接口去沟通，已经将各个业务团队之间做到了最大程度的解耦，但是对于基础设施团队来说，还是和每一个业务团队耦合在一起。&lt;/p&gt;
&lt;p&gt;我们中间尝试过用各种方法去解决升级过程中的耦合的问题，一种是通过我们自己研发的应用服务器 CloudEngine 来管理所有的基础类库，尽量地去减少给用户带来的升级成本，不用让用户一个个升级依赖，一次升级就可以。&lt;/p&gt;
&lt;p&gt;但是随着蚂蚁的业务的不断发展，规模地不断扩大，团队的数量，业务的规模和我们交付的效率已经成为了主要的矛盾，所以我们期望以更高的效率去研发基础设施，而不希望基础设施的迭代受制于这个规模。&lt;/p&gt;
&lt;p&gt;后来蚂蚁自己研发的数据库 OceanBase 也在用一个 Proxy 的方式来屏蔽掉 OceanBase 本身的集群负载，FailOver 切换等方面的逻辑，而刚好 Service Mesh 的这种 Sidecar 的模式也是这样的一个思路，这让我们看到将基础设施的能力从应用中下移到 Sidecar 这件事情是一个业界的整体的趋势和方向，通过这种方式应用和中间件的基础设施从此成了两个进程，我们可以针对中间件的基础设施进行单独的升级，而不用和应用的发布升级绑定在一起，这不仅解放了应用研发和基础设施团队，也让基础设施团队的交付能力变地更强，以前可能需要通过半年或者一年甚至更长时间的折腾，才能够将基础设施团队提供的新的能力铺到所有的业务系统中去，现在我们通过一个月的时间，就可以将新能力让所有的业务系统享受到。这也让基础设施团队的中台能力变得更强了。这样我们就可以把我们还是把一些架构当中非常关键的支撑点以及一些逻辑下沉到 Sidecar 上面去，因为整个蚂蚁金服的整体架构有非常多的逻辑和能力承载在这一套架构上面的。这些东西我们有一个最大的职责是要支撑它快速向前演进和灵活。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sofa-service-mesh&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;sofa service mesh&#34; srcset=&#34;
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rewl7baj30u00snn2v_hu8601410687152343134.webp 400w,
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rewl7baj30u00snn2v_hu13501811452881659626.webp 760w,
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rewl7baj30u00snn2v_hu16521326596006617340.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rewl7baj30u00snn2v_hu8601410687152343134.webp&#34;
               width=&#34;760&#34;
               height=&#34;726&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      sofa service mesh
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-的选型&#34;&gt;Service Mesh 的选型&lt;/h2&gt;
&lt;p&gt;前面讲到了蚂蚁金服当前服务化架构下遇到的问题以及我们希望能够通过 Service Mesh 能够去解决的一些问题，接下来就面临一个很现实的问题，Service Mesh 的框架我们到底应该怎么选，我们应该用什么样的标准去衡量，那接下来，我就给大家分享一下蚂蚁金服在 Service Mesh 的框架上的选型上的一些思考。&lt;/p&gt;
&lt;p&gt;首先，所有的架构的演进都不是一蹴而就的，都是一个渐进式地演进的一个过程，越大的公司在架构演进的过程中其实越需要考虑这一点。所以我们在选型的时候就需要去考虑这一点，考虑目标框架能否很好地和当前的架构融合在一起。另一个点，作为一个和钱打交道的公司，我们需要特别地去关注目标框架是否在生产环境经过大规模的验证，在场景上，是否经过了各类场景的验证。&lt;/p&gt;
&lt;p&gt;目前，业界主流的 Service Mesh 相关的框架有三个，分别是 Google，IBM，Lyft 都参与其中的 Istio，以及 Bouyant 公司下的两个开源的 Service Mesh 的框架 Linkerd 以及 Conduit。&lt;/p&gt;
&lt;p&gt;首先我们来看下 Istio，Istio 应该是目前被关注最高的一个 ServiceMesh 框架，本身又有顶尖公司的光环加持，比如 Google，IBM 等等，他也完整地包含了一个 Data Plane 以及 Control Plane，但是 Istio 一直以来被挑战的地方其实在于他的 Control Plane 的 Mixer 的部分，Istio 的 Mixer 承担了服务鉴权，Quota 控制，Tracing，Metrics 等等能力，它是一个中央的节点，如果不开启缓存的情况下，所有的调用都需要从 Mixer 中去过，即使开启了缓存的情况，也不可避免的有请求一定要从 Mixer 中去过，而在全蚂蚁，有 20000 多的服务，服务之间的调用是非常频繁的，如果都需要过 Mixer，那 Mixer 就成了一个单点，这个单点的运维和高可用又成了一个问题。&lt;/p&gt;
&lt;p&gt;另外，Istio 的性能是我们一直以来比较担心的问题，虽然 Istio 每个版本的发布，性能都有了一定程度的提升。但是我们来看下 Istio 的性能数据，0.5.1 的时候是 700 的 TPS，0.6.0 的时候是 1000 个 TPS，0.7.1 的时候是 1700 个 TPS，相对于一般的 RPC 通信框架，最低最低都是万级别的 TPS，Istio 的这个性能数据的确是有点儿惨淡，完全无法满足蚂蚁这边的性能要求。&lt;/p&gt;
&lt;p&gt;接下来我们来看 Linkerd，Linkerd 算是业界几个 Service Mesh 的框架里面最成熟的一个了，但是他也有一个问题，首先就是他脱胎于 Twitter 的 Finagle，架构上其实不够开放，没法很好的适配到蚂蚁的环境里面去，另外 Linkerd 也没有 Control Plane 这一层，只有 Sidecar，再者 Linkerd 的路由规则 DTab 其实是挺难理解的。最后，其实也是我们当时选型的时候最关心的一个问题，Linkerd 是用 Scala 写的，跑在 JVM 上面，我从 Linkerd 的一篇博客上摘录出了一张图片，这篇博客主要讲的是如何优化 JVM 的内存使用，这种文章一般上是的确有这个问题，才会去写这样的文章，从这张图片中我们可以看到 Linkerd 所需要的内存至少都需要 100M，这也是 Bouyant 官方不推荐 Linkerd 和应用做一对一的部署，而是采用 DaemonSet 的方式进行部署。而我们期望的一个部署方式是和应用做一对一的部署，这样的内存占用对于我们来说成本太过，我们期望将 Sidecar 的内存占用控制在 10M 左右。&lt;/p&gt;
&lt;p&gt;最后，我们来看下 Conduit，首先 Conduit 也是 Linkerd 不久之前推出的一个 Service Mesh 的框架，其实不太成熟，其次，Conduit 选择的语言是 Rust，我们来看下 Rust 在 Tiebo 上的排名，Java 长时间高居第一位，C++在第三位，Golang 经过这几年云基础设施的蓬勃发展，到了 14 位，而 Rust，和一众语言的占用率没有太大的差别，排在了 50 位往后。&lt;/p&gt;
&lt;p&gt;所以，我们最后选择了自研 Service Mesh，一方面当然是我们基于前面的两个准则去衡量目前业界流行的 Service Mesh 框架，没有能够完全满足我们的要求的，另一方面蚂蚁金服服务化上有长期以及深厚的积累，这部分的一些经验也可以支持我们能够更好地去自研我们自己的 Service Mesh 的框架。&lt;/p&gt;
&lt;p&gt;当然，我们也不是说完全从零开始搞 Service Mesh 框架，对于业界的 Service Mesh 的框架中的优秀理念，我们是希望能够吸收过来的，另一方面，我们也希望能够尽量地去 Follow Service Mesh 目前社区中的一些规范。&lt;/p&gt;
&lt;h2 id=&#34;sofa-mesh-的设计&#34;&gt;SOFA Mesh 的设计&lt;/h2&gt;
&lt;p&gt;首先，SOFA Mesh 其实直接采用了 Istio 的 Control Plane 的 Pilot 和 Auth，因为我们觉得 Istio 在这块上没有太大的问题甚至里面也有一些非常不错的设计，比如 Pilot 这部分的 Universal Data API 就是非常不错的设计。Istio 的 Auth 这部分也充分地利用了 Kubernetes 的安全机制。&lt;/p&gt;
&lt;p&gt;而 Mixer 这部分，其实我之前就提到我们是觉得有设计上问题的，所以我们的想法是直接把 Mixer 搬到 Sidecar 中实现。&lt;/p&gt;
&lt;p&gt;再者，大家都知道 Istio 的 Sidecar 是 Envoy，它是一个用 C++ 写的，那么我们怎么把 Mixer 移入到 Sidecar 中去呢，其实我们的 SOFA Mesh 的 Sidecar 是采用了 Golang 来写的，所以才给把 Mixer 移入 Sidecar 提供了可能性，当然，我们选择用 Golang 来研发 Sidecar 不仅仅是为了把 Mixer 移入到 Sidecar 而已，其实也有其他的考虑，一方面，在云计算的时代，Golang 以及成为构建基础设施的首选语言，我们看到大量的基础设施都是用 Golang 写的，包括 Docker，Kubernetes 等等，选择 Golang，其实也是希望能够更好地和云原生时代的这些基础设施贴合。&lt;/p&gt;
&lt;p&gt;另外，相比于 Envoy 采用的 C++，Golang 显然更加容易上手，也更加容易找到这方面的人才，另外，Golang 相对于 JVM 来说，Memory Footprint 低了非常多，我们用 Golang 写的 Sidecar，目前的峰值  TPS 下的内存在用在 11M，虽然还有一定的优化空间，但是相比于 JVM 来说，已经降低了 10 倍。&lt;/p&gt;
&lt;p&gt;另外，虽然我们采用了 Istio 的 Pilot，但是在内部使用的时候，直接使用 Pilot 并不能满足我们的诉求。首先，Pilot 在 Kubernetes 上是直接对接到 Kubernetes 的服务发现机制上的，无论是 SOFARPC，还是微博的 Motan 等等国内的服务框架，其实都是单个应用多个服务这样的模型，而 Kubernetes 的服务发现机制实际上针对的是单个应用单个服务的模型，在模型上就不太一致。另外，SOFA 的服务注册中心 SOFARegistry 在蚂蚁金服内部经过了多年的实践，面对内部大规模的服务化的场景，SOFARegistry 的扩展能力以及可靠性已经经过了大量的实践证明，这里说一下 SOFARegistry 上的一些数据，上面大约注册了 2W 多个服务，一个机房里面的 Pub 和 Sub 的加起来在千万级别。基于以上的考虑，我们选择了用 Pilot 上增加 SOFARegistry 的 Adapter，使之能够拿到 SOFARegistry 上的服务注册信息。&lt;/p&gt;
&lt;p&gt;然后，Pilot 还有一个问题，就是原来 Pilot 会把所有的服务注册相关的数据都同步到 Pilot 上，这个对于 Pilot 的集群的压力是非常大的，所以我们选择了只同步必要的数据到一个 Pilot 的节点上，介绍 Pilot 本身的内存压力。&lt;/p&gt;
&lt;p&gt;最后，我再分享一个蚂蚁金服的场景，在蚂蚁金服，因为事业部众多以及监管的问题，不用的事业部之间的一些机器可能是网络不通的，那么他们要做服务访问，就必须有一个角色来做跨环境之间的服务访问，所以我们基于 Sidecar 的概念，提出了 EdgeSidecar 的角色，他在技术的实现细节上其实和和应用部署在一起的 Sidecar 是非常类似的，只是这个 Sidecar 作为一个“边缘”的角色，来负责跨环境的服务通信问题。&lt;/p&gt;
&lt;p&gt;所以，SOFA Mesh 在整体的大图上大概是这样的，我们自研了一个 Golang 的 Sidecar，并且把 Mixer 纳入到 Sidecar 中，来防止出现类似于 Istio 那样的性能问题，在 Pilot 和 Auth 这两个角色了，我们选择直接使用 Istio 的，然后在上面做一定程度的适配，适配到蚂蚁内部的环境中，然后我们在整个部署上，新增了一个 EdgeSidecar 的角色，来解决跨环境的服务调用的问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sofa-service-mesh&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;sofa service mesh&#34; srcset=&#34;
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rguhx74j30u00ii78w_hu5932849118419638704.webp 400w,
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rguhx74j30u00ii78w_hu4053977414424023363.webp 760w,
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rguhx74j30u00ii78w_hu3359053311991322820.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rguhx74j30u00ii78w_hu5932849118419638704.webp&#34;
               width=&#34;760&#34;
               height=&#34;469&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      sofa service mesh
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我知道大家一定对 SOFA Mesh 在蚂蚁内部的落地情况非常感兴趣，目前我们已经落地的场景主要是多语言的场景，解决其他的语言和 SOFA 的通信问题，大约上了二三十个系统。然后我们正在尝试用 SOFA Mesh 去更好地解决服务间调用的安全，以及蓝绿发布的问题，在异构系统通信的这件事情上，我们也在不久的将来会尝试用 SOFA Mesh 去解决。&lt;/p&gt;
&lt;p&gt;当然，SOFA Mesh 在蚂蚁内部的落地其实离不开开源社区，&lt;strong&gt;所以在未来的两三个月内，我们也会将 SOFA Mesh 开源出来，将蚂蚁内部实践 Service Mesh 的成果开源出来&lt;/strong&gt;，给大家更多在这方面的参考。&lt;/p&gt;
&lt;p&gt;对于未来，其实我觉得中间件作为基础设施未来和云平台融合是一个不可阻挡地趋势，除了 Service Mesh，未来还可能会出现 Message Mesh，DB Mesh 等等产品，我知道业界有些同学已经开始做这方面的努力了。最后总结一下我今天演讲的内容，一个是 Service Mesh 给蚂蚁金服解决的问题，包括多语言，遗留系统以及基础设施团队和业务团队耦合的问题。在 ServiceMesh 的选型上，我们主要考量和当前架构的可融合性，以及框架的高可用，稳定性。未来除了 ServiceMesh，可能还会出现其他的 Mesh，中间件和底层云平台进一步融合的趋势不可挡。多谢大家！&lt;/p&gt;
&lt;p&gt;下面带来的是 GIAC 大会中蚂蚁金服高级技术专家与现场参会人员进行关于 Service Mesh 的问答互动，我们精选了几个比较热门的问答分享给大家。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sofa-演讲会场&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SOFA 演讲会场&#34; srcset=&#34;
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rhdorabj30u00gu1g5_hu9560943119890924456.webp 400w,
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rhdorabj30u00gu1g5_hu11229279741420359810.webp 760w,
               /blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rhdorabj30u00gu1g5_hu1227936609527992656.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/migrating-from-classical-soa-to-service-mesh-in-ant-financial/00704eQkgy1fs9rhdorabj30u00gu1g5_hu9560943119890924456.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SOFA 演讲会场
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;一mesh-的高可用和安全能否详细说明一下&#34;&gt;一、Mesh 的高可用和安全，能否详细说明一下？&lt;/h3&gt;
&lt;p&gt;答：我们最近正在做安全这件事情，安全涉及到两个方面，一个方面是 RPC 的整个服务调用健全的问题，这个是可以直接在 Mesh 中去做的，可以直接利用 Istio 的 RBAC 来实现，另外是 Mesh 和 Mesh 之间的 TLS 双向认证的事情。这个其实 Istio 里面会有一些现成的方案，它与 K8S 融合的也非常好，这些东西是可以直接拿过来去用的。&lt;/p&gt;
&lt;h3 id=&#34;二如何解决服务的多版本路由和数据单元的多版本路由的问题&#34;&gt;二、如何解决服务的多版本路由和数据单元的多版本路由的问题？&lt;/h3&gt;
&lt;p&gt;答：ServiceMesh 主要关注的是服务调用这一块，我来解释一下多版本的路由，其实我们在内部的话，服务版本这件事情用得会比较少，用得更多的是同一服务不同的实现。但是其实多版本路由这一块，如果说大家知道 K8S 的 Label 的话，可以把它的这种设计来借鉴到整个 Mesh 当中，然后通过不同的标签来做区分，后面也会有一些这方面的分享出来。&lt;/p&gt;
&lt;h3 id=&#34;三service-mesh-主要是解决了请求的可靠传输和服务治理的问题吗&#34;&gt;三、Service Mesh 主要是解决了请求的可靠传输和服务治理的问题吗？&lt;/h3&gt;
&lt;p&gt;答：应该是说 Service Mesh 提出了更好的方式去解决请求的可靠传输和服务治理的问题。其实想像一下，如果说你要上一整套的服务治理的架构的话，在原来的方式下可能需要你们所有的上层业务系统都接入你们对应的服务治理的组件，现在的话，只要有一个 Service Mesh，在这个 Sidecar 当中就可以把服务治理的这件事情做掉。它没有去解决新的问题，只是把一些老的问题用更好的方式去解决。&lt;/p&gt;
&lt;h3 id=&#34;四为什么-control-plane-对于-mesh-来说很重要&#34;&gt;四、为什么 Control Plane 对于 Mesh 来说很重要？&lt;/h3&gt;
&lt;p&gt;答：其实这个就涉及到整个云平台和我们整个服务化体系的融合的问题。其实目前大家可以看到，Pilot 这部分的东西，在原来 Istio 设计当中是非常强的和 K8S 这个东西融合在一起的，如果说你没有这套东西存在的话，对于 Mesh 来说还是一个非常上层的中间件这样的东西。当然你可以说不用 Control Plane 这一层，只有 Sidecar，对接到原来的一整套的服务治理体系当中去，这样做也是可以的，没有太大的问题。但是有了 Control Plane 这一层东西，它定义了非常通用的 API，本身这个架构又是和云平台整个架构是绑定得比较紧的，有更好的融合度。所以我们觉得整个 Control Plane 这一层是非常重要的。&lt;/p&gt;
&lt;p&gt;另外，Istio 提出 Control Plane，其实是在往微服务标准化方面迈进了很大一层。它里面有非常多的服务发现的标准，治理的标准，虽然说他大胆提出了这样的概念和假设，我们也看到了它的一些不足，所以我们希望和社区一起推进这一层的标准化。就像我一开始分享的，基础设施一层一层的向上包。像我们觉得越来越多的中间件的部分，其实是会被沉淀到基础设施当中的。现在也有云原生语言，我们编译了一下，发现很慢，问题也很多，但是我们觉得这是一个方向。大家在写的时候，可能就用这样的语言去写，很多能力就提升上去了。我们希望把基础设施向上再推一下，去扮演这样一个角色。这也是我们认为 Control Plane 的最大的价值。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
