<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tetrate | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/tag/tetrate/</link>
      <atom:link href="https://cloudnativecn.com/tag/tetrate/index.xml" rel="self" type="application/rss+xml" />
    <description>Tetrate</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 29 Feb 2024 20:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/media/sharing.png</url>
      <title>Tetrate</title>
      <link>https://cloudnativecn.com/tag/tetrate/</link>
    </image>
    
    <item>
      <title>如何在 Istio 中按路径配置全局速率限制</title>
      <link>https://cloudnativecn.com/blog/how-to-configure-global-rate-limits-by-path-in-istio/</link>
      <pubDate>Thu, 29 Feb 2024 20:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/how-to-configure-global-rate-limits-by-path-in-istio/</guid>
      <description>&lt;p&gt;本文是为那些刚开始使用 Istio 速率限制功能，希望了解基于请求路径的速率限制如何工作的人而写的。它源于我的实践，并澄清了关于&lt;code&gt;rate_limit&lt;/code&gt;操作中 AND/OR 操作的困惑。我花了比预期更多的时间来弄清楚我将在这里为你总结的内容，以便你在几分钟内学习。&lt;/p&gt;
&lt;h2 id=&#34;基础知识&#34;&gt;基础知识&lt;/h2&gt;
&lt;p&gt;Istio 在 Envoy 之上运行，而我们将讨论的主要技术是 Envoy。Envoy 有在代理本身上实现的本地速率限制和在 L4 或 L7 上调用外部服务的全局速率限制的选项。&lt;/p&gt;
&lt;h2 id=&#34;外部速率限制服务&#34;&gt;外部速率限制服务&lt;/h2&gt;
&lt;p&gt;外部速率限制服务（RLS）与 Redis 数据库配合使用，通过 gRPC 与 envoy 实例连接。该 RLS 是由 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/rate_limit_filter#rate-limit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;filter&lt;/a&gt; 在 HTTP 路由过滤器之前的侦听器链中添加而被调用的。&lt;/p&gt;
&lt;p&gt;这个外部过滤器将描述符组织成域组。每个描述符都是一个键值对，由速率限制过滤器填充，并传递给 RLS 供其在规则执行逻辑中使用。请参阅 &lt;a href=&#34;https://github.com/envoyproxy/ratelimit#overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/envoyproxy/ratelimit#overview&lt;/a&gt; 进行实现。&lt;/p&gt;
&lt;p&gt;RLS 需要由集群操作员（你）安装和管理，并且不会随 Istio 一起提供，尽管可以在你安装时从 Istio 包的示例目录中找到它。&lt;/p&gt;
&lt;h2 id=&#34;envoy-http-速率限制过滤器&#34;&gt;Envoy HTTP 速率限制过滤器&lt;/h2&gt;
&lt;p&gt;Envoy 的设置由应用于入口网关的两个 Envoy 配置组成，一个在侦听器组件中添加速率限制过滤器，另一个在动态路由组件中定义虚拟主机级别的操作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-envoy-http-速率限制过滤器&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Envoy HTTP 速率限制过滤器&#34; srcset=&#34;
               /blog/how-to-configure-global-rate-limits-by-path-in-istio/f1_hu_8a6565c9529b1688.webp 400w,
               /blog/how-to-configure-global-rate-limits-by-path-in-istio/f1_hu_d7f58167a22f77d9.webp 760w,
               /blog/how-to-configure-global-rate-limits-by-path-in-istio/f1_hu_b0935660dfe619da.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-configure-global-rate-limits-by-path-in-istio/f1_hu_8a6565c9529b1688.webp&#34;
               width=&#34;760&#34;
               height=&#34;603&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Envoy HTTP 速率限制过滤器
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;带有速率限制过滤器的侦听器组件 filter_chains.filters[] 在路由器之前。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-虚拟主机httpbincom80的路由组件中的速率限制操作&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;虚拟主机“httpbin.com:80”的路由组件中的速率限制操作&#34; srcset=&#34;
               /blog/how-to-configure-global-rate-limits-by-path-in-istio/f2_hu_7817348f90a94e12.webp 400w,
               /blog/how-to-configure-global-rate-limits-by-path-in-istio/f2_hu_97c022e3e10df035.webp 760w,
               /blog/how-to-configure-global-rate-limits-by-path-in-istio/f2_hu_e0c4f1061a66f589.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-configure-global-rate-limits-by-path-in-istio/f2_hu_7817348f90a94e12.webp&#34;
               width=&#34;760&#34;
               height=&#34;730&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      虚拟主机“httpbin.com:80”的路由组件中的速率限制操作
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意：你可以通过以下方式从任何 envoy 代理（当然是网关）获取此转储：&lt;/em&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;k exec &amp;lt;POD&amp;gt; -c istio-proxy -- curl &amp;#39;localhost:15000/config_dump&amp;#39; &amp;gt; config_dump.json
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;侦听器过滤器配置了如何到达 RLS、它正在监视的域以及一些其他设置。当满足路由中定义的操作时，此过滤器将访问在路由中定义的操作，并触发到 RLS 上游的 gRPC 调用，其中包括域、描述符键和值，以便它返回一个判断。&lt;/p&gt;
&lt;h2 id=&#34;istio-中按请求路径设置速率限制的示例&#34;&gt;Istio 中按请求路径设置速率限制的示例&lt;/h2&gt;
&lt;p&gt;你需要按照&lt;a href=&#34;https://istio.io/latest/docs/tasks/policy-enforcement/rate-limit/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此&lt;/a&gt;开始。花点时间分析基于前文介绍的配置。供你参考，我使用的是你也可以在 Istio 包的示例目录中访问的 &lt;code&gt;httpbin&lt;/code&gt; 服务。&lt;/p&gt;
&lt;h3 id=&#34;错误的方法&#34;&gt;错误的方法&lt;/h3&gt;
&lt;p&gt;所以，我希望根据两个路径 &lt;code&gt;/delay&lt;/code&gt; 和 &lt;code&gt;/status&lt;/code&gt; 进行速率限制。看起来很容易，所以我配置了我的 Envoy Filter 和 RLS 如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;# EnvoyFilter 配置路由操作&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;patch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;operation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;MERGE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rate_limits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;actions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;header_value_match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;descriptor_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;PATH&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;descriptor_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;yes&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;:path&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;safe_regex_match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;google_re2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;regex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;.*delay.*&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;header_value_match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;descriptor_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;PATH&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;descriptor_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;no
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;:path&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;safe_regex_match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;google_re2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;regex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;.*status.*&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# RLS configmap&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;config.yaml&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    domain: tetrate-ratelimit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    descriptors:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      - key: PATH
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        value: &amp;#34;yes&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        rate_limit:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          unit: minute
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          requests_per_unit: 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      - key: PATH
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        value: &amp;#34;no&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        rate_limit:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          unit: minute
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          requests_per_unit: 1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有了这个，我期望通过调用以下命令来使其工作：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl http://127.0.0.1:8080/delay/1 -H&amp;#34;host: httpbin.com&amp;#34; -v -o /dev/null
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是 RLS 甚至没有注意到这个调用，所以速率限制没有发生：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# k logs -n default -f ratelimit-57bf5688c-f8q5k
time=&amp;#34;2023-11-29T17:34:10Z&amp;#34; level=debug msg=&amp;#34;[gostats] Flush() called, all stats would be flushed&amp;#34;
time=&amp;#34;2023-11-29T17:34:20Z&amp;#34; level=debug msg=&amp;#34;[gostats] flushing counter ratelimit.go.mallocs: 460&amp;#34;
time=&amp;#34;2023-11-29T17:34:20Z&amp;#34; level=debug msg=&amp;#34;[gostats] flushing counter ratelimit.go.frees: 26&amp;#34;
time=&amp;#34;2023-11-29T17:34:20Z&amp;#34; level=debug msg=&amp;#34;[gostats] flushing counter ratelimit.go.totalAlloc: 15624&amp;#34;
time=&amp;#34;2023-11-29T17:34:20Z&amp;#34; level=debug msg=&amp;#34;[gostats] flushing gauge ratelimit.go.sys: 0&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;为了设置调试模式，你可以编辑 ratelimit-server 部署的容器参数。在那里，你将找到日志级别标志。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我尝试了所有种类的组合在 &lt;code&gt;rate_limits.actions&lt;/code&gt; 设置中，使用 &lt;code&gt;string_match&lt;/code&gt; 和 &lt;code&gt;prefix_match&lt;/code&gt; 替代了 &lt;code&gt;safe_regex_match&lt;/code&gt;，但没有成功。&lt;/p&gt;
&lt;p&gt;还尝试使用单个 &lt;code&gt;descriptor_key&lt;/code&gt;，不同的值以及甚至不设置它并使用默认的 &lt;code&gt;header_match&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;顿悟时刻&#34;&gt;顿悟时刻&lt;/h2&gt;
&lt;p&gt;我发现过滤器没有发送任何东西到 RLS，因为前者在任何请求上都保持沉默。然后，通过文档我读到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;如果操作不能添加描述符条目，则不会为配置生成描述符&amp;rdquo;，见&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#config-route-v3-ratelimit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;然后，发起调用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl http://127.0.0.1:8080/status/delay -H&amp;#34;host: httpbin.com&amp;#34; -v -o /dev/null
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;time=&amp;#34;2023-11-29T16:07:07Z&amp;#34; level=debug msg=&amp;#34;got descriptor: (PATH=yes),(PATH=no)&amp;#34;
time=&amp;#34;2023-11-29T16:07:07Z&amp;#34; level=debug msg=&amp;#34;starting get limit lookup&amp;#34;
time=&amp;#34;2023-11-29T16:07:07Z&amp;#34; level=debug msg=&amp;#34;looking up key: PATH_yes&amp;#34;
time=&amp;#34;2023-11-29T16:07:07Z&amp;#34; level=debug msg=&amp;#34;found rate limit: PATH_yes&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以，只有当我的路径满足 &lt;em&gt;两个&lt;/em&gt; &lt;code&gt;header_value_match&lt;/code&gt; 时，描述符才会传递给 RLS。我的当前配置正如一个 AND 运算符一样工作。&lt;/p&gt;
&lt;p&gt;然后，一切都归结为：&lt;em&gt;如何在 rate_limit 操作中设置 OR 逻辑而不是 AND？&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;原始配置略有变化，如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# EnvoyFilter 配置路由操作   
        value:
          rate_limits:
            - actions: # 任何操作在此处
              - header_value_match:
                  descriptor_key: &amp;#34;PATH_DELAY&amp;#34;
                  descriptor_value: &amp;#34;yes&amp;#34;
                  headers:
                    - name: &amp;#34;:path&amp;#34;
                      safe_regex_match:
                        google_re2: {}
                        regex: &amp;#34;.*delay.*&amp;#34;
            - actions:
              - header_value_match:
                  descriptor_key: &amp;#34;PATH_STATUS&amp;#34;
                  descriptor_value: &amp;#34;yes&amp;#34;
                  headers:
                    - name: &amp;#34;:path&amp;#34;
                      safe_regex_match:
                        google_re2: {}
                        regex: &amp;#34;.*status.*&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来像一个有效的配置，就像：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;❯ curl http://127.0.0.1:8080/delay/1 -H&amp;#34;host: httpbin.com&amp;#34; -v -s -o /dev/null 
*   Trying 127.0.0.1:8080...
* Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0)
&amp;gt; GET /delay/1 HTTP/1.1
&amp;gt; Host: httpbin.com
&amp;gt; User-Agent: curl/7.81.0
&amp;gt; Accept: */*
&amp;gt; 
* Mark bundle as not supporting multiuse
&amp;lt; HTTP/1.1 200 OK
&amp;lt; server: istio-envoy
&amp;lt; date: Wed, 29 Nov 2023 20:17:02 GMT
&amp;lt; content-type: application/json
&amp;lt; content-length: 703
&amp;lt; access-control-allow-origin: *
&amp;lt; access-control-allow-credentials: true
&amp;lt; x-envoy-upstream-service-time: 1005
&amp;lt; 
{ [703 bytes data]
* Connection #0 to host 127.0.0.1 left intact

❯ curl http://127.0.0.1:8080/delay/1 -H&amp;#34;host: httpbin.com&amp;#34; -v -s -o /dev/null 
*   Trying 127.0.0.1:8080...
* Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0)
&amp;gt; GET /delay/1 HTTP/1.1
&amp;gt; Host: httpbin.com
&amp;gt; User-Agent: curl/7.81.0
&amp;gt; Accept: */*
&amp;gt; 
* Mark bundle as not supporting multiuse
&amp;lt; HTTP/1.1 429 Too Many Requests &amp;lt;---------- 参见
&amp;lt; x-envoy-ratelimited: true
&amp;lt; date: Wed, 29 Nov 2023 20:17:06 GMT
&amp;lt; server: istio-envoy
&amp;lt; content-length: 0
&amp;lt; 
* Connection #0 to host 127.0.0.1 left intact
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和 RLS 日志：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;time=&amp;#34;2023-11-29T16:33:57Z&amp;#34; level=debug msg=&amp;#34;starting cache lookup&amp;#34;
time=&amp;#34;2023-11-29T16:33:57Z&amp;#34; level=debug msg=&amp;#34;looking up cache key: tetrate-ratelimit_PATH_DELAY_yes_1701275580&amp;#34;
time=&amp;#34;2023-11-29T16:33:57Z&amp;#34; level=debug msg=&amp;#34;cache key: tetrate-ratelimit_PATH_DELAY_yes_1701275580 current: 1&amp;#34;
time=&amp;#34;2023-11-29T16:33:57Z&amp;#34; level=debug msg=&amp;#34;returning normal response&amp;#34;
time=&amp;#34;2023-11-29T16:33:57Z&amp;#34; level=debug msg=&amp;#34;[gostats] flushing time ratelimit_server.ShouldRateLimit.response_time: 0.000000&amp;#34;
time=&amp;#34;2023-11-29T16:33:59Z&amp;#34; level=debug msg=&amp;#34;got descriptor: (PATH_DELAY=yes)&amp;#34;
time=&amp;#34;2023-11-29T16:33:59Z&amp;#34; level=debug msg=&amp;#34;starting get limit lookup&amp;#34;
time=&amp;#34;2023-11-29T16:33:59Z&amp;#34; level=debug msg=&amp;#34;looking up key: PATH_DELAY_yes&amp;#34;
time=&amp;#34;2023-11-29T16:33:59Z&amp;#34; level=debug msg=&amp;#34;found rate limit: PATH_DELAY_yes&amp;#34;
time=&amp;#34;2023-11-29T16:33:59Z&amp;#34; level=debug msg=&amp;#34;applying limit: 1 requests per MINUTE, shadow_mode: false&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相信我，&lt;code&gt;/status&lt;/code&gt; 的限制也是存在的。&lt;/p&gt;
&lt;p&gt;AND/OR逻辑用于速率限制 &lt;code&gt;rate_limits&lt;/code&gt; 配置在其数组中支持多个位置，因此 AND/OR 逻辑操作取决于动作是否嵌套到相同的 &lt;code&gt;actions&lt;/code&gt; 子集中。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：可能有一种更安全、更有效的路径匹配方式，而不是像这个例子中那样打开正则表达式。它很简单，所以我们专注于主题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tetrate 推出针对 Amazon EKS 设计的服务网格解决方案 TSE</title>
      <link>https://cloudnativecn.com/blog/introducing-tetrate-service-express/</link>
      <pubDate>Thu, 13 Apr 2023 16:13:33 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/introducing-tetrate-service-express/</guid>
      <description>&lt;p&gt;Tetrate Service Express (TSE) 是一款基于开源软件的服务连接、安全和弹性自动化解决方案，专为 Amazon EKS 设计。&lt;/p&gt;
&lt;p&gt;本文译自：&lt;a href=&#34;https://tetrate.io/blog/introducing-tetrate-service-express/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Service Express 介绍&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;快速实现-amazon-eks-上安全和弹性的服务网格&#34;&gt;快速实现 Amazon EKS 上安全和弹性的服务网格&lt;/h2&gt;
&lt;p&gt;今天我们很高兴地宣布 Tetrate Service Express (TSE)，这是一款针对 Amazon EKS 的服务连接、安全和弹性自动化解决方案。我们基于 Istio 和 Envoy 等开源服务网格组件构建了 TSE，并针对 AWS 对 TSE 进行了简化安装、配置和操作的优化。如果您的团队正在 AWS 上进行服务网格实验，并且需要快速证明投资回报率，而无需掌握复杂的 Istio 和 AWS 基元，那么 TSE 就是适合您的选择！如果您的团队已经在单个集群上拥有了服务网格，但希望将网格扩展到多个集群甚至区域，那么 TSE 也可以帮助您。事实上，TSE 是唯一一款基于开源软件并针对 AWS 进行优化的产品，预先集成了最受欢迎的 AWS 服务，可在几分钟内让您上手。&lt;/p&gt;
&lt;p&gt;如果您想快速了解 Tetrate Service Express 的功能，在&lt;a href=&#34;https://tetr8.io/tse&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此处&lt;/a&gt;加入等待列表以获取您的评估副本。&lt;/p&gt;
&lt;p&gt;如果您想深入了解 Tetrate Service Express 的新功能，请继续阅读。&lt;/p&gt;
&lt;h2 id=&#34;为什么选择-tetrate-service-express&#34;&gt;为什么选择 Tetrate Service Express&lt;/h2&gt;
&lt;p&gt;如果您的组织想要创造更好的客户体验、提高运营效率或保护知识产权，那么很可能必须构建和运行软件——更高质量、更快速的发布、更好的正常运行时间。而且很可能，应用程序开发团队、运营团队和平台团队正在借助两种创新趋势来实现这些目标：云基础设施的灵活性和微服务。&lt;/p&gt;
&lt;p&gt;在云中构建微服务时，许多团队选择 Amazon EKS 的便利性。然而，随着他们扩展 EKS 工作负载，他们会发现自己面临以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何保护分布在 AWS 上的微服务组件？&lt;/li&gt;
&lt;li&gt;如何在更新或负载下单个组件失败时保持可靠性？&lt;/li&gt;
&lt;li&gt;当一切都是动态的，手动配置不再起作用时，如何管理服务之间的流量？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;越来越多的平台运营团队会在微服务之上创建一个专用的基础设施层——服务网格——它提供了跨微服务组件的服务发现、安全性、认证和可观测性。Istio 和 Envoy 是服务网格控制平面和数据平面的开源标准，但 Istio 和 Envoy 只是部分解决方案，因为它们为运行 Amazon EKS 的团队添加了新的操作复杂性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-amazon-eks-上的服务网格挑战&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Amazon EKS 上的服务网格挑战&#34; srcset=&#34;
               /blog/introducing-tetrate-service-express/image_hu_10e3d5135ca0352b.webp 400w,
               /blog/introducing-tetrate-service-express/image_hu_31e8e3efa1070fc2.webp 760w,
               /blog/introducing-tetrate-service-express/image_hu_98d3ed46985ef505.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/introducing-tetrate-service-express/image_hu_10e3d5135ca0352b.webp&#34;
               width=&#34;760&#34;
               height=&#34;452&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Amazon EKS 上的服务网格挑战
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Tetrate Service Express 为平台团队提供了 Istio 和 Envoy 之上的服务网格自动化。它处理在 Amazon EKS 上安装和配置开源组件，与 AWS 服务集成，并为平台运营商提供管理控制台，以快速配置服务网格以实现安全、弹性和可观察性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-tetrate-service-express-提供了一种一致的可自动化的方法用于在-amazon-eks-内部和跨-amazon-eks-连接保护和观察服务&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Tetrate Service Express 提供了一种一致的、可自动化的方法，用于在 Amazon EKS 内部和跨 Amazon EKS 连接、保护和观察服务&#34; srcset=&#34;
               /blog/introducing-tetrate-service-express/image-1_hu_8364e4bf04b35891.webp 400w,
               /blog/introducing-tetrate-service-express/image-1_hu_ce402f1a3fac3840.webp 760w,
               /blog/introducing-tetrate-service-express/image-1_hu_bce9cc903b9f1470.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/introducing-tetrate-service-express/image-1_hu_8364e4bf04b35891.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Tetrate Service Express 提供了一种一致的、可自动化的方法，用于在 Amazon EKS 内部和跨 Amazon EKS 连接、保护和观察服务
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;快速安装-amazon-eks-和集成-aws-服务&#34;&gt;快速安装 Amazon EKS 和集成 AWS 服务&lt;/h2&gt;
&lt;p&gt;让 Istio 在 EKS 上运行可能变得更加容易（例如使用&lt;a href=&#34;https://tetrate.io/blog/tid-add-on-for-eks/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Istio Distro EKS add-on&lt;/a&gt;），但在您可以操作功能性服务网格之前，还需要完成更多的工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何确保所有服务网格组件都已正确安装和配置？&lt;/li&gt;
&lt;li&gt;如何定义 Istio 和 Envoy 周围的网络基础架构，以实现安全的跨集群连接和可用性？&lt;/li&gt;
&lt;li&gt;如何观察和排查网格上的服务，以协助扩展和优化？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TSE 可以使用 Helm chart 轻松安装在 EKS 上，并与 Route 53 和 NLB（或其他 AWS 负载平衡器类型）轻松集成，以便您可以快速：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定位服务的边缘和入口网关，以管理和安全地控制入口和出口流量。&lt;/li&gt;
&lt;li&gt;通过内置身份验证、速率限制、HA 和安全性提供应用程序的 API。&lt;/li&gt;
&lt;li&gt;获取服务和应用程序的 MELT（度量、事件、日志、跟踪）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-使用-tetrate-service-express-和示例配置开始&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;使用 Tetrate Service Express 和示例配置开始&#34; srcset=&#34;
               /blog/introducing-tetrate-service-express/image-2_hu_ba6a0e3a1a55efb3.webp 400w,
               /blog/introducing-tetrate-service-express/image-2_hu_143ddeee54b1c00.webp 760w,
               /blog/introducing-tetrate-service-express/image-2_hu_5b26b81b114348e.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/introducing-tetrate-service-express/image-2_hu_ba6a0e3a1a55efb3.webp&#34;
               width=&#34;760&#34;
               height=&#34;372&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      使用 Tetrate Service Express 和示例配置开始
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;一步式服务间的-mtls-加密&#34;&gt;一步式服务间的 mTLS 加密&lt;/h2&gt;
&lt;p&gt;服务网格的第一个用例之一是使用 mTLS 启用服务间加密，但一旦你扩展到多个集群，事情就会很快变得复杂：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何在各个集群之间建立和管理单个信任根？&lt;/li&gt;
&lt;li&gt;如何在全面支持零信任姿态的情况下，强制执行 mTLS？&lt;/li&gt;
&lt;li&gt;如何定期轮换证书，并在泄漏或损坏证书的情况下做出响应？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tetrate Service Express 通过提供以下内容使服务易于加密并应用零信任姿态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内置的易于使用的证书颁发机构，可在所有群集中轮换和管理证书。&lt;/li&gt;
&lt;li&gt;在管理级别上定义对所有服务的 mTLS 需求。&lt;/li&gt;
&lt;li&gt;从默认的拒绝所有姿态开始创建细粒度的访问策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-默认设置-mtls&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;默认设置 mTLS&#34; srcset=&#34;
               /blog/introducing-tetrate-service-express/image-3_hu_2fc5050502585fbb.webp 400w,
               /blog/introducing-tetrate-service-express/image-3_hu_ecae7e347824795d.webp 760w,
               /blog/introducing-tetrate-service-express/image-3_hu_b04fff5f0f50132b.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/introducing-tetrate-service-express/image-3_hu_2fc5050502585fbb.webp&#34;
               width=&#34;760&#34;
               height=&#34;372&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      默认设置 mTLS
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;集群和区域之间的易于故障转移设置&#34;&gt;集群和区域之间的易于故障转移设置&lt;/h2&gt;
&lt;p&gt;在定义应用程序基础架构时，设置服务的内部高可用性可能是比较复杂的事情，特别是在不同的区域内。一些可能遇到的问题包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何配置 Route53、Amazon 负载均衡和其他负载均衡服务，以在不同的集群之间实现可靠的 HA？&lt;/li&gt;
&lt;li&gt;如何在没有 Hairpinning 的情况下设置跨集群通信和内部高可用性？&lt;/li&gt;
&lt;li&gt;当服务失败时如何自动化网络配置更改？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tetrate Service Express 通过提供以下功能使获取服务 HA 易于实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对服务发布进行自动配置的入口、Amazon 负载均衡和 Route 53。&lt;/li&gt;
&lt;li&gt;为内部高可用性自动配置内部和东/西网关。&lt;/li&gt;
&lt;li&gt;动态重新配置网络规则，以在最小中断的情况下在集群之间和之间传输流量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-配置跨区域故障转移&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;配置跨区域故障转移&#34; srcset=&#34;
               /blog/introducing-tetrate-service-express/image-4_hu_ab1a640b56e68762.webp 400w,
               /blog/introducing-tetrate-service-express/image-4_hu_b4f284ee8d682f34.webp 760w,
               /blog/introducing-tetrate-service-express/image-4_hu_10a7cb97e1d1a23a.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/introducing-tetrate-service-express/image-4_hu_ab1a640b56e68762.webp&#34;
               width=&#34;760&#34;
               height=&#34;391&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      配置跨区域故障转移
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;接下来&#34;&gt;接下来&lt;/h2&gt;
&lt;p&gt;这只是我们要从 Tetrate Service Express 中突出显示的一些功能。Tetrate Service Express 将在本月晚些时候发布技术预览版，但是您现在可以加入等待列表，以在发布时获取评估副本。一旦您加入等待列表，我们将与您联系，向您提供访问评估软件、新文档门户网站和 Slack 社区频道的信息。&lt;/p&gt;
&lt;p&gt;我们还计划推出一系列额外的博客、视频和网络研讨会，以展示更多 TSE 的功能。下一场网络研讨会定于 5 月举行，请&lt;a href=&#34;https://app.livestorm.co/p/06a20bee-58b0-4976-977d-c2e4b16dbe68&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;立即注册&lt;/a&gt;。最后，请不要忘记在&lt;a href=&#34;https://twitter.com/Tetrateio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Twitter&lt;/a&gt;或&lt;a href=&#34;https://www.linkedin.com/company/tetrate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LinkedIn&lt;/a&gt;上关注 Tetrate，以便在新的 TSE 内容可用时获得即时更新！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tetrate 开源项目 Wazero 简介</title>
      <link>https://cloudnativecn.com/blog/introducing-wazero-from-tetrate/</link>
      <pubDate>Mon, 20 Mar 2023 12:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/introducing-wazero-from-tetrate/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;译者注：本文译自 &lt;a href=&#34;https://tetrate.io/blog/introducing-wazero-from-tetrate/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate 博客&lt;/a&gt;。这篇文章介绍了 wazero，一个由 Tetrate 开发的用 Go 语言编写的 WebAssembly 运行时。wazero 可以让开发者用不同的编程语言编写代码，并在安全的沙箱环境中运行。wazero 有以下几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;纯 Go，无依赖，支持跨平台和跨架构&lt;/li&gt;
&lt;li&gt;遵循 WebAssembly 核心规范 1.0 和 2.0&lt;/li&gt;
&lt;li&gt;支持 Go 的特性，如并发安全和上下文传递&lt;/li&gt;
&lt;li&gt;提供了丰富的编程接口和命令行工具&lt;/li&gt;
&lt;li&gt;性能优异，超过了其他同类运行时&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;WebAssembly，也称为 Wasm，是一种编译用一种编程语言（例如 C 或 Rust）编写的代码并在不同的运行时（例如 Web 浏览器或微服务）上运行它的方法。这使得它成为编写插件、扩展以及在安全沙箱环境中运行任意用户定义代码的绝佳选择。&lt;/p&gt;
&lt;p&gt;WebAssembly 经常被误认为是一种仅限浏览器的技术，而实际上 Wasm 是一种跨平台的二进制文件，可以由任何 WebAssembly 运行时执行。从历史上看，Go 程序员没有太多好的选择，但这种情况已经改变。&lt;/p&gt;
&lt;p&gt;本文介绍了 &lt;a href=&#34;https://wazero.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wazero&lt;/a&gt;，它在用 Go 编程语言编写的基础设施中很重要，并涵盖了其最引人注目的功能。&lt;/p&gt;
&lt;h2 id=&#34;在-go-中运行-webassembly-的简史&#34;&gt;在 Go 中运行 WebAssembly 的简史&lt;/h2&gt;
&lt;p&gt;最初，大多数 WebAssembly 运行时是用 C/C++ 和 Rust 编程语言编写的。许多云原生项目，包括 Docker、Istio 和 Kubernetes 都是用 Go 编写的。不是用 Go 编写的运行时可通过称为 CGO 的机制获得。然而，CGO 不是 Go，通过选择 CGO，您就放弃了 Go 运行时的许多杀手级功能，例如对广泛平台交叉编译的一流支持。围绕 CGO 的复杂性，尤其是隐含的本机库，是将 wasm 扩展到 Kubernetes 调度程序的请求被拒绝的原因。总之，Go 缺乏原生运行时延迟或限制了将 WebAssembly 引入核心基础设施。&lt;/p&gt;
&lt;h2 id=&#34;wazero-是为-go-开发人员编写的&#34;&gt;wazero 是为 Go 开发人员编写的&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://wazero.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wazero&lt;/a&gt; 是唯一用 Go 编写的&lt;strong&gt;零依赖 WebAssembly 运行时&lt;/strong&gt;。这个开源项目最初是由 &lt;strong&gt;Takeshi Yoneda&lt;/strong&gt; 作为爱好开始的。2021 年底，Tetrate 认识到其战略价值并投入了几名全职员工，以期有朝一日发布 1.0 版。&lt;/p&gt;
&lt;p&gt;在过去的几个月里，该团队孜孜不倦地工作以支持多种平台、架构和编程接口。我们很高兴地宣布 wazero 1.0 发布！&lt;/p&gt;
&lt;p&gt;Wazero 是一个功能齐全、符合标准、丰富且经过实战检验的 WebAssembly 运行时，它与 Go 运行时的最佳特性无缝集成，例如安全并发和上下文传播。它包括一个面向 Go 开发人员的编程接口和一个面向那些只想运行 Wasm 的人的 CLI。&lt;/p&gt;
&lt;h2 id=&#34;wazero-有什么不同之处&#34;&gt;Wazero 有什么不同之处？&lt;/h2&gt;
&lt;p&gt;你可能想知道 wazero 的优势在哪里，考虑到 Go 与其他语言具有良好的互操作性。这允许您通过 CGO 选择多个不是用 Go 编写的运行时。以下是考虑 Wazero 的五个理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;最佳 Go 支持&lt;/strong&gt;。Wazero 是纯 Go 语言，不引入任何依赖，但支持更进一步。Wazero 包括惯用的 Go 函数，例如上下文集成。这允许您重用传入的截止日期，例如来自 gRPC 请求以限制在 wasm 函数中花费的时间。运行时是专门为 Go 设计的，因此在 Go 开发人员关注的问题（例如 goroutine security /wazero）方面&lt;a href=&#34;https://pkg.go.dev/github.com/tetratelabs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;记录很好&lt;/a&gt;。比如很多库可以同时使用 wazero 而不互相冲突，这些都是在 Go 中测试过的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API 兼容性&lt;/strong&gt;。WebAssembly 运行时嵌入在项目的底层位置，因此兼容性的变化可能会导致版本锁定，尤其是在中间件中。Wazero 是唯一已知的提供语义版本控制的运行时。函数可以制作成 1.1 版本，它们不会破坏 1.0 用户。Wazero 承诺保持零依赖并与 Go 的前两个版本一起工作。总之，wazero 的兼容性方法是模仿 Go 本身，为其用户引入最少的维护问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;平台兼容性&lt;/strong&gt;。wazero 完全支持 amd64、arm64、FreeBSD、Linux、macOS 和 Windows 在最新三个版本的 Go 上的任意组合。它还通过其“解释器运行时”将对 Go 的支持扩展到其他平台，它的执行速度比本机“编译器运行时”慢。wazero 在 Windows 上非常棒，因为它不仅是一流的平台，而且我们还在发布时生成签名的 MSI 安装程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;坚如磐石的测试方法&lt;/strong&gt;。Wazero 通过多项规范测试来测试平台支持，包括 WebAssembly 核心规范的 1.0 和 2.0 草案版本以及用于测试 I/O 功能的 WASI 测试套件。我们还运行由 Zig 和 TinyGo 编写的标准库测试。最后，我们运行基准测试并对每个更改进行“模糊测试”。所有这些都使得 wazero 的错误易于识别和修复。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;活跃的终端用户社区。&lt;/strong&gt; wazero 的社区包括许多公司的极强的开发人员。我们涉及一些与 Go 支持 WebAssembly 有关的方面，并为 Go 和 TinyGo 编译器做出贡献。请查看我们的&lt;a href=&#34;https://wazero.io/community/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;社区&lt;/a&gt;和&lt;a href=&#34;https://wazero.io/community/users/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;用户&lt;/a&gt;页面，了解更多关于我们以及您如何融入其中的信息！&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;将-wazero-嵌入您的项目中&#34;&gt;将 wazero 嵌入您的项目中&lt;/h2&gt;
&lt;p&gt;Wazero 显然也是一个 Go 库，其主要目标是让您与运行时环境无缝集成，并使用 WebAssembly 扩展您的 Go 应用程序。例如，假设您想运行&lt;a href=&#34;https://en.wikipedia.org/wiki/Cowsay&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;经典的 Unix 程序 cowsay&lt;/a&gt;（最初是用 Perl 编写的）。那么您可以输入：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Download the executable from:
// https://github.com/evacchi/cowsay/releases/download/0.1.0/cowsay.wasm
//go:embed &amp;#34;cowsay.wasm&amp;#34;
var cowsay []byte

func main() {
	ctx := context.Background()
	r := wazero.NewRuntime(ctx)
	wasi_snapshot_preview1.MustInstantiate(ctx, r)
	r.InstantiateWithConfig(ctx, cowsay,
		wazero.NewModuleConfig().
			WithArgs(&amp;#34;cowsay&amp;#34;, // first arg is usually the executable name
				&amp;#34;wazero is awesome!&amp;#34;).
			WithStdout(os.Stdout))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行它会显示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; ____________________
&amp;lt; wazero is awesome! &amp;gt;
 --------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
               ||----w |
                ||     ||
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;使用-wazero-cli-入门&#34;&gt;使用 wazero CLI 入门&lt;/h2&gt;
&lt;p&gt;该项目现在包括一个 CLI，用于运行 WebAssembly 二进制文件。我们发现许多用户无论使用哪种编程语言都选择它，因此我们决定使用这个例子。&lt;/p&gt;
&lt;p&gt;现在，您可以使用一个简单的命令下载和安装 wazero CLI：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ curl https://wazero.io/install.sh | sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者在 Windows 上，您可以&lt;a href=&#34;https://github.com/tetratelabs/wazero/releases/download/v1.0.0-rc.2/wazero_1.0.0-rc.2_windows_amd64.msi&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;下载有 MSI 签名的&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;然后您可以使用以下命令运行您的 WebAssembly 二进制文件：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ./bin/wazero run someApp.wasm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如，假设您想在 CLI 上运行 cowsay，那么只需键入&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ curl -LO https://github.com/evacchi/cowsay/releases/download/0.1.0/cowsay.wasm
$ wazero run cowsay.wasm wazero is awesome!
 ____________________
&amp;lt; wazero is awesome! &amp;gt;
 --------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
               ||----w |
                ||     ||
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者，也许你更想玩 1977 年的 Infocom 文本冒险游戏 Zork。&lt;/p&gt;
&lt;p&gt;你可以从 &lt;a href=&#34;https://github.com/evacchi/zork-1/releases/tag/v0.0.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/evacchi/zork-1/releases/tag/v0.0.1&lt;/a&gt; 获取一个 Wasm 二进制文件，然后使用以下命令调用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ curl -L https://github.com/evacchi/zork-1/releases/download/v0.0.1/zork-wasm-wasi.tgz | tar xzf -
$ wazero run -mount=.:/ zork.wasm
Welcome to Dungeon.			This version created 11-MAR-91.
You are in an open field west of a big white house with a boarded
front door.
There is a small mailbox here.
&amp;gt;open mailbox
Opening the mailbox reveals:
  A leaflet.
&amp;gt;read leaflet
Taken.
		    Welcome to Dungeon!

   Dungeon is a game of adventure, danger, and low cunning.  In it
you will explore some of the most amazing territory ever seen by mortal
man.  Hardened adventurers have run screaming from the terrors contained
within.

   In Dungeon, the intrepid explorer delves into the forgotten secrets
of a lost labyrinth deep in the bowels of the earth, searching for
vast treasures long hidden from prying eyes, treasures guarded by
fearsome monsters and diabolical traps!

   No DECsystem should be without one!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;尽情玩吧！&lt;/p&gt;
&lt;h2 id=&#34;最后的话&#34;&gt;最后的话&lt;/h2&gt;
&lt;p&gt;这是我们的第一个重大发布，但我们才刚刚开始！&lt;strong&gt;有许多值得期待的事情&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;WebAssembly 规范正在不断更新，我们将密切关注它：例如，&lt;a href=&#34;https://github.com/WebAssembly/tail-call/blob/main/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tail call proposal&lt;/a&gt; 刚刚进入第 4 阶段，&lt;a href=&#34;https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GC proposal&lt;/a&gt; 则是许多编程语言（如 Java）的支持者，最近进入了第 3 阶段。Wazero 将继续通过所有测试，随着 WebAssembly 的发展而发展。&lt;/p&gt;
&lt;p&gt;我们还希望作为您 WebAssembly 运行时的战略性选择。您可以期待持续致力于性能，可观测性和可扩展性。一个例子是我们即将推出的低级文件系统插件。它支持比 Go 的 fs.FS 更多的功能，现在就可以使用，例如创建目录和文件。该设计支持自定义审计和访问控制，并可用于第三方主机函数。&lt;/p&gt;
&lt;p&gt;最后，如果您在 3 月 23 日和 24 日参加巴塞罗那的 Wasm I/O 活动，就有机会认识我们团队的一部分！&lt;/p&gt;
&lt;p&gt;如果您在会议结束后留在那里，或者您只是在那个晚上在城市里，&lt;strong&gt;在 3 月 24 日星期五&lt;/strong&gt;，我们也很高兴&lt;a href=&#34;https://www.eventbrite.com/e/wazero-10-launch-party-tickets-585204150367&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;邀请您参加 wazero 1.0 自己的官方发布派对&lt;/a&gt;。我们将提供小吃，饮料和许多社区贡献者，他们将展示他们如何使用我们所钟爱的 WebAssembly 运行时！一位幸运的参会者将有机会按下 1.0 的发布按钮！&lt;/p&gt;
&lt;p&gt;我们很兴奋地看到您将如何使用 Wazero 构建项目。&lt;a href=&#34;https://wazero.io/community/users/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;加入我们不断增长的社区用户列表&lt;/a&gt;，并让我们知道您正在创造什么！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Envoy API Gateway——推动网关的进一步发展</title>
      <link>https://cloudnativecn.com/blog/the-gateway-to-a-new-frontier/</link>
      <pubDate>Tue, 17 May 2022 11:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/the-gateway-to-a-new-frontier/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;今天，Envoy 社区&lt;a href=&#34;https://www.cncf.io/blog/2022/05/16/introducing-envoy-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;宣布了&lt;/a&gt;一个令人兴奋的新项目：&lt;a href=&#34;https://github.com/envoyproxy/gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Gateway&lt;/a&gt;。该项目将行业领导者联合起来，精简由 Envoy 驱动的应用网关的好处。这种方法使 Envoy Gateway 能够立即为快速创新打下坚实的基础。该项目将提供一套服务来管理 Envoy 代理机群，通过易用性来推动采用，并通过定义明确的扩展机制来支持众多的用例。&lt;/p&gt;
&lt;h2 id=&#34;我们为什么要这样做&#34;&gt;我们为什么要这样做？&lt;/h2&gt;
&lt;p&gt;Tetrate 是 Envoy Proxy 的第一贡献者（按提交量计算），也是 Envoy Gateway 指导小组的成员，其贡献者涵盖技术和管理领域。我们相信，我们强大的伙伴关系和在开源软件方面的深厚经验将有助于确保 Envoy Gateway 的成功。Tetrate 推动了 EG 计划，因为我们致力于上游项目，因为我们相信这将降低 Envoy Proxy 用户的进入门槛，也因为这与我们开发服务网格作为零信任架构基础的使命相一致。Tetrate 将大力投资建设 Envoy Gateway 的安全功能，包括支持 OAuth2 和 &lt;a href=&#34;https://letsencrypt.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Let’s Encrypt&lt;/a&gt; 集成等 API 功能。&lt;/p&gt;
&lt;h3 id=&#34;对上游项目的承诺&#34;&gt;对上游项目的承诺&lt;/h3&gt;
&lt;p&gt;Tetrate 从第一天起就站在服务网格的最前沿，始终相信上游项目和它们的社区。因此，我们一直在为 Istio 和 Envoy 的上游项目提供帮助和支持。我们看到不同的人在使用 Envoy，并创建他们自己的控制平面和 API 网关实现，导致碎片化，创新速度慢，功能差距大，以及缺乏对一个代码库的支持。由于我们与 Matt Klein 和 Envoy 社区长期以来关系密切，当我们提议将其纳入 Envoy 的标准化实现，并将其整合到一个官方的上游实现中时，我们得到了 Matt 和其他 CNCF 项目的强烈支持。我们一直在幕后与其他指导委员会成员（&lt;a href=&#34;https://www.getambassador.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambassador Labs&lt;/a&gt;、&lt;a href=&#34;https://www.fidelity.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fidelity Investments&lt;/a&gt;、&lt;a href=&#34;https://projectcontour.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Project Contour&lt;/a&gt; 和 &lt;a href=&#34;https://www.vmware.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VMware&lt;/a&gt; 辛勤工作，以定义 Envoy Gateway。&lt;/p&gt;
&lt;p&gt;我们知道，艰苦的工作才刚刚开始，我们致力于这个项目以及 CNCF 内其他几个项目的长期成功。&lt;/p&gt;
&lt;h3 id=&#34;实现控制平面的标准化&#34;&gt;实现控制平面的标准化&lt;/h3&gt;
&lt;p&gt;在很短的时间内，Envoy 已经成为现代云原生应用的首选网络层。随着 Envoy 获得关注，大量的上游项目开始利用它来实现服务网格、入口、出口和 API 网关功能。这些项目中有许多能力重叠、功能差距、专有特性，或者缺乏社区多样性。这种支离破碎的状态是由于 Envoy 社区没有提供控制平面的实现而产生的副作用。&lt;/p&gt;
&lt;p&gt;因此，创新的速度降低了，企业被要求辨别利用 Envoy 作为其应用网络数据平面的最佳方法。现在，社区正在提供 Envoy Gateway，更多的用户可以享受 Envoy 的好处，而无需决定控制平面。Envoy Gateway 的&lt;a href=&#34;https://github.com/envoyproxy/gateway/blob/main/GOALS.md#goals&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;目标&lt;/a&gt;是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;&amp;hellip;&amp;hellip; 通过支持众多入口和 L7/L4 流量路由使用案例的表达式、可扩展、面向角色的 API，降低采用障碍，吸引更多用户使用 Envoy；并为供应商建立增值产品提供共同基础，而无需重新设计基本交互。&amp;rdquo;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;易用性和运营效率&#34;&gt;易用性和运营效率&lt;/h3&gt;
&lt;p&gt;Envoy Proxy 是由 &lt;a href=&#34;https://github.com/cncf/xds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xDS API&lt;/a&gt; 驱动的，这些 APIs 暴露了大量的功能，并被控制平面广泛采用。虽然这些 API 功能丰富，但对于用户来说，要快速学习并开始利用 Envoy 的功能是非常困难的。Envoy Gateway 将为用户抽象出这些复杂的功能，同时支持现有的运营和应用管理模式。&lt;/p&gt;
&lt;p&gt;Envoy Gateway 将利用 &lt;a href=&#34;https://gateway-api.sigs.k8s.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway API&lt;/a&gt; 来实现这些目标，而不是开发一个新的项目专用 API。Gateway API 是一个由 &lt;a href=&#34;https://github.com/kubernetes/community/tree/master/sig-network&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 网络特别兴趣小组&lt;/a&gt;管理的项目，正在迅速成为提供用户接口以管理应用网络基础设施和流量路由的首选方法。这个开源项目有一个丰富、多样的社区，有几个知名的实施方案。我们期待着作为社区的一部分开展工作，使 Envoy Gateway 成为业界首选的网关 API 实现。&lt;/p&gt;
&lt;h2 id=&#34;为什么这比传统的-api-网关更好&#34;&gt;为什么这比传统的 API 网关更好？&lt;/h2&gt;
&lt;p&gt;传统的代理不是轻量级的、开放的，也不是动态可编程的、类似 xDS 的 API，因此 Envoy 很适合成为当今动态后端的 API 网关 —— 尤其是在增加安全功能的情况下。我们设想将 Envoy 网关作为不断发展的 API 管理领域的一个关键组成部分。API 网关是 API 管理的核心组件，提供透明地策略执行和生成详细遥测数据的功能。这种遥测技术提供了强大的可观测性，为企业提供了更好的洞察力，以排除故障、维护和优化其 API。&lt;/p&gt;
&lt;p&gt;在我们看来，由于 Envoy 的设计、功能设置、安装基础和社区，它是业内最好的 API 网关。有了 Envoy Gateway，企业可以在将 Envoy 嵌入其 API 管理策略方面增加信心。&lt;/p&gt;
&lt;h3 id=&#34;无边界的零信任&#34;&gt;无边界的零信任&lt;/h3&gt;
&lt;p&gt;当你的所有应用服务都在一个服务网格中运行时，实现&lt;a href=&#34;https://www.tetrate.io/zero-trust/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;零信任架构&lt;/a&gt;就不那么难了。然而，现实中不都是服务网格。服务在虚拟机上运行，在无代理容器中运行，作为无服务器函数运行，等等。Envoy Gateway 将突破这些运行时的界限，为跨异构环境的统一策略执行提供基础。&lt;/p&gt;
&lt;p&gt;这一基础的关键是 Envoy Gateway 的可扩展性，它提供了暴露 Envoy 和非 Envoy 安全功能的灵活性。这些扩展点将被用来提供实现零信任架构所需的功能，包括用户和应用认证、授权、加密和速率限制。Envoy Gateway 将很快成为寻求实现零信任架构的组织的一个关键组件。&lt;/p&gt;
&lt;p&gt;同样，Tetrate 致力于上游项目和它们的长期可行性。这一举措又一次证明了这一点，并表明上游的 Envoy 和 Istio 现在正成为构建服务网格的事实上的支柱。Envoy Gateway 将使服务网格成为主流，架构师们应该把网格看作是 ZTA 的基础。为了帮助架构师进行论证，我们最近出版了《&lt;a href=&#34;https://www.tetrate.io/service-mesh-handbook/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格手册&lt;/a&gt;》。我们很快就会发布一种带有上游 Envoy Gateway 和 Istio 的架构方法，可以看作是你的应用网络的基础。&lt;/p&gt;
&lt;h3 id=&#34;探索-envoy-gateway&#34;&gt;探索 Envoy Gateway&lt;/h3&gt;
&lt;p&gt;在 Tetrate，我们正在领导基于 Envoy Gateway 和 Istio 的零信任架构的定义，并将在后续博文中阐述设想的架构。如果你想和我们一起讨论架构，并了解更多关于如何为传统和云原生应用程序进行架构，请加入 &lt;a href=&#34;http://tetrate-community.slack.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tetrate-community&lt;/a&gt; Slack 频道。&lt;/p&gt;
&lt;p&gt;要了解更多关于 Tetrate 的信息，请访问 &lt;a href=&#34;https://www.tetrate.io/envoy-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tetrate.io&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>利用服务网格和智能应用感知网络增强应用弹性</title>
      <link>https://cloudnativecn.com/blog/resiliency-app-aware-network/</link>
      <pubDate>Mon, 21 Feb 2022 16:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/resiliency-app-aware-network/</guid>
      <description>&lt;p&gt;我是 Vrun Talwar，Tetrate 公司的联合创始人。我们是一家企业级服务网格公司。我要谈的是弹性，更准确地说，是运行时的弹性，是内置于你的网络中的东西。我喜欢从历史上的一个技术话题开始谈起。Cloud 1.0 是云的第一个时代。当时我们看到了虚拟化的浪潮，人们基本上从他们的硬件中获得更多。在我们进入当前的云时代之前，这已经持续了好几年，也就是 Cloud 2.0 时代，这基本上是从别人那里获得计算资源。你不需要在数据中心运行机器，别人为你更有效地运行它们。你刷一下信用卡，就可以得到他们管理的资源。这对配置灵活性和在我们想要的任何地方提供计算有很大的帮助。实际上，下一阶段就是 Cloud 3.0，这是一个更加动态和分布式的计算。从容器和自动伸缩的意义上讲，动态的，通过 Kubernetes 这样的协调器进行调度。分布式是指不同的区域：私有云、公有云、混合云等等。以及在应用组件分布的意义上的分布式。在一个计算如此动态的世界里，我们的网络和安全堆栈是滞后的。这些都是需要迎头赶上的。&lt;/p&gt;
&lt;h2 id=&#34;cloud-30-转型--网络的创新&#34;&gt;Cloud 3.0 转型 —— 网络的创新&lt;/h2&gt;
&lt;p&gt;在创办 Tetrate 之前，我曾有机会在谷歌工作了大约 11 年。很多人都在谈论，谷歌的基础设施怎么会如此可靠和安全？为什么它如此有弹性？尽管推出了更多的服务，尽管每年有数以千计的新开发者加入，但基础设施始终是正常的，可用的。这其中的核心之一是对核心网络的投资。谷歌的网络创新相当少，并不是所有的创新都被谈论过。我有幸参与了其中的两项重要创新，即 gRPC 和 Istio，我是这两个创新的共同创造者。这些都是网络栈被带到应用层面的地方。gRPC 是这个现代 RPC 结构，在 2016 年推出。Istio 是这种基于代理的方法，将代理注入到网络中，并使其成为 L7 代理，知道什么是通过它们进行的。这是在 2017 年推出的。这两个都是今天蓬勃发展的开源项目。&lt;/p&gt;
&lt;h2 id=&#34;背景介绍&#34;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;回到这次谈话的背景，弹性是超级重要的。随着越来越多的公司转向公有云，任何一个云供应商出现故障时，受到影响的品牌名单就会不断增加。这大大阻碍了他们的正常运行时间，不仅仅是正常运行时间，还有他们的业务和品牌形象。&lt;/p&gt;
&lt;h2 id=&#34;弹性不仅仅与软件有关&#34;&gt;弹性不仅仅与软件有关&lt;/h2&gt;
&lt;p&gt;我们如何才能做得更好？在我们讨论这个问题之前，让我们先来看看弹性问题的范围。这是一个多层次的问题，从基础设施层开始，然后延伸到网络层。它们的分布越多，网络层的可靠性就越关键。显然，也延伸到数据层，以及你的人、实践和操作。故障可能是不同类型的。你可以从一个主机到一个节点，到一个特定的服务，到一个特定的数据中心，到一个特定的区域。很明显，在物理层面上，在布线、交换机和路由器方面也是如此。所有这些都会给你的应用程序造成故障模式和可用性问题。问题是，你如何设计你的应用程序以适应它们？我们可以做得更好，而不仅仅是两种部署，主 - 主，或主 - 被？&lt;/p&gt;
&lt;p&gt;在一个计算无处不在的世界里，我的观点是，你应该在多个可用区部署应用程序。无论如何，它们现在更容易配置、运行和管理。部署流水线更加自动化。我们真正需要的是一个智能的、连接的网络，它可以将流量一直路由到正确的健康部署，我们将有弹性的应用程序。说起来容易做起来难，我们如何才能在实践中真正做到这一点？让我们看看一些场景。&lt;/p&gt;
&lt;h2 id=&#34;情景-1服务实例失败&#34;&gt;情景 1：服务实例失败&lt;/h2&gt;
&lt;p&gt;想象一下一个简单的三层应用程序的场景。你有你的前端 Web 服务器数据库，你有流量进入一些边缘。它可能是一个数据中心或一个云区域，进入一些应用代理或入口代理，然后进入你的应用程序。第一件事是应用程序应该部署在多个可用区。这是使其更具弹性的第一个前提。第二是模拟故障，并加强你的服务代码库处理故障的能力。像服务网格和 Istio 有一定的能力，你可以注入和模拟故障，并使它准备好更多的容错。一旦你在可用性区域部署了应用程序，你需要它有故障转移的东西是区域之间的连接，所以你实际上可以将流量路由过去。这些是提高可用性的一些良好做法。&lt;/p&gt;
&lt;h2 id=&#34;服务代理---通往更健康的实例的路由&#34;&gt;服务代理 - 通往更健康的实例的路由&lt;/h2&gt;
&lt;p&gt;比方说，你有一个特定的服务实例在一个给定的节点上停机。它可能是数据库。它可能是网络服务器。它可能是前端。这个弹性网络的方法是在每个服务旁边有一个服务代理，或者在整个应用面前有一个应用代理，它可以检测到一个特定的实例正在发生错误。也许这可以通过更高的延迟或更高的错误率，或其他信号来检测，而且是来自该实例。它通常来自运行在它们旁边的 Sidecar 代理。这可以发出信号说，好吧，我应该把负载均衡到另一个更健康的实例，它有更健康的计算池，它有更健康的 pod，如果你遵循 Kubernetes。这是一个保持可用性和弹性的简单方法。另一个是关于，故障会发生。你如何确保代理足够聪明，内置超时和快速重试，所以他们可以从这些模式中恢复？这些也是很好的提示和做法。&lt;/p&gt;
&lt;h2 id=&#34;情景-2服务失败&#34;&gt;情景 2：服务失败&lt;/h2&gt;
&lt;p&gt;假设整个服务瘫痪了，而且在那个特定的区域或特定的数据中心，没有一个实例是实际可用的。那你该怎么办呢？那么，你需要做的是将其路由到一个不同的可用区。这说起来容易，做起来难。要做到这一点，你需要知道每个服务和所有区域的状态和健康状况，并实时输入控制器，然后可以决定，好吧，我应该把流量发送到哪里？你需要它们之间的连接，以便它能够真正地路由流量。数据的一致性是另一个层面的问题，需要解决的是你要有一个一致的结果。另一个问题是，让这些东西在自动扩展的基础设施上运行总是可取的，所以资源容量不会成为我们可用性的一个问题。&lt;/p&gt;
&lt;h2 id=&#34;可用性数学&#34;&gt;可用性数学&lt;/h2&gt;
&lt;p&gt;有一件事我们都知道，但有时会忘记，用数字来表示是很好的，那就是，什么是可用性？可用性的定义是我在任何一年的平均停机时间是多少。我们经常谈论两个九、四个九、五个九的可用性，但实际上，只要在一到两个可用性区域内有可用性，就可以大大减少我们的停机时间，并提高我们的弹性。即使是一到两个可用区，也是非常有意义的影响。&lt;/p&gt;
&lt;h2 id=&#34;情景-3应用失败&#34;&gt;情景 3：应用失败&lt;/h2&gt;
&lt;p&gt;继续这一趋势，让我们说，不是一个服务或服务实例，而是整个应用系统瘫痪了。那么，你如何将流量路由到该应用程序的一个完全不同的实例？如何设置两层的负载均衡，这样上面的一层，在这种情况下，边缘代理实际上可以知道，将流量发送到哪个应用代理。在这里，重要的是，你的所有其他安全控制，你已经建立的合规控制，你需要操作的应用程序，实际上在所有这些可用性区域都可用。这是通过服务网格的配置来完成的，这些 L7 网格，可以确保相同的配置被发送到所有的区域，因此你可以保证相同的行为。这看起来很容易，但对每个人来说，要实现这样的设置并不容易，即健康信号传播到边缘代理，代理做出正确的决定，你以正确的方式进行负载均衡。&lt;/p&gt;
&lt;h2 id=&#34;情景-4区域故障&#34;&gt;情景 4：区域故障&lt;/h2&gt;
&lt;p&gt;你可以把这个问题提升到不仅仅是一个应用程序，而是整个区域的故障，整个数据中心的故障或容量不足。在这些情况下，你要把路由到一个完全不同的数据中心。在云设置中，它甚至可能意味着到一个完全不同的云。只要你有应用程序部署在这些区域，问题的解决方案是类似的，也就是你有一个上面的层，它在任何时候都有健康和性能的信号，并可以做出路由决策，将流量路由到最佳区域。然后从那里到最佳应用实例，再从那里到实际服务。&lt;/p&gt;
&lt;h2 id=&#34;通过动态自动伸缩的-l7-网络实现复原能力&#34;&gt;通过动态自动伸缩的 L7 网络实现复原能力&lt;/h2&gt;
&lt;p&gt;总之，我的主要观点是，我们可以有这种动态的自动伸缩，应用程序感知的网络。之所以称之为自动伸缩，是因为所有这些负载均衡器也可以在计算中运行，它可以自动伸缩，而且它们也可以是弹性的，就像你的计算节点。这种设置如果部署得当，架构合理，可以做两件事，第一，大大改善你的应用程序的弹性。二，你的开发人员不需要在他们的每个服务和应用程序中建立所有这些，并使其成为服务网格本身的一部分。我们在 Tetrate 是以这个为生的。我们有一个平台来实现这一点。在很多地方做了这些工作后，我们有不少最佳实践和蓝图架构，在实际的、真实的环境中很适合。&lt;/p&gt;
&lt;h2 id=&#34;问答&#34;&gt;问答&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;当你讲述谷歌的网络进化故事时，我想到的是，是什么导致了 gRPC 和 Istio 的诞生？你以前有什么不理想的地方，然后导致了最初 gRPC 的创建？什么问题没有得到解决？你也许想谈一谈这个问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Talwar：gRPC 是谷歌内部一个叫 Stubby 的东西的下一代演绎。Stubby 在谷歌成立之初就存在了，也就是 1999 年。实际上，任何两个服务都可以通过这个 Stubby 机制相互通信。它存在了很长时间。在大约 12 年的时间里经历了一系列的迭代。那么需要它的原因有两个方面。在这种规模下，如果你在 HTTP 上做 JSON，这是客户端流量的经典方式，对于我们的规模来说，这还不够理想。只是给你一些例子，只是通过做 protobuf，也就是通过二进制，比通过文本，与通过 HTTP 的 JSON 相比，你在许多情况下得到 10 倍的改进。这意味着在我们的规模上可以节省数百万甚至数十亿美元的费用。&lt;/p&gt;
&lt;p&gt;然后，渐渐地，发生了很多事情，比如负载均衡，重试，以及发送一些跨度进行追踪。gRPC 只不过是它的下一个版本，它被开放了源代码。原因是在一个组织中，你可以非常有主见，就像，好吧，我只支持三种语言或四种语言，在某些情况下，只支持一种语言，然后这些是我的库。这是好的。当我们把它放在外面的时候，你不能有那种一个组织的意见。谷歌实际上是用三种语言运行的。C++、Java 和 Python。然后一切都在这里面。当我们不得不进入多语言世界，并支持许多现有的服务时，这就是为什么需要一些不基于库和代理的东西，这导致了 Istio。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有一种争论是，对于断路器来说，最好是避免回退或重试，而典型的情况是，它们需要在应用中实现，而不是在网络层。你有什么想法？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Talwar：我们正在经历这样一个有趣的时代，什么是在应用程序中，什么是在网络中，在许多情况下，需要合作。与追踪不同的是，对于传递标头值，这是一个很好的例子，你必须在应用中做到这一点。断路器，核心代理，无论是 Envoy，还是其他代理，它们都有这些内置的概念，能够检查上游的健康状况，或者你要把它发送到哪里。定义我何时破坏它的规则，并通过配置做所有这些，所以这些范式存在于这些代理和控制平面中。显然，这一切只是基于代理，而不是基于通过代理的所有流量，就通过代理的请求的延迟和错误率而言。他们不知道你底层计算的其他方面。比方说，你的 CPU 超载了，就像那个应用程序正在消耗，这不会被知道。现在发生的更多的是这些事情被添加到了上面，也就是，从你的节点传递信号，比如 CPU 内存信号，这些被传递到了上面，以做出一些决定，或者能够从应用中获取外部信号，让代理做出决定。&lt;/p&gt;
&lt;p&gt;显然，应用程序本身知道，有最多的背景，但人们在理解方面实际发展了多少，从节点开始，一直到可能出错的不同事情。我认为这很难。我们至少看到的两件事是代理与底层节点和应用程序之间的互动，以及反向的互动。这基本上意味着代理向底层自动扩展基础设施发出信号以进行扩展，所以这实际上也在更多地发生。我知道健康状况正在下降，因为延迟上升，信号下降到像 Kubernetes 这样的自动伸缩基础设施，或者只是云供应商的实例组。这是一个没有被使用的信号，应该被使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有一种观点认为，Istio 没有被企业完全采用。你怎么看？企业需要认识到哪些事情，然后利用你所说的这种智能应用感知网络的优势？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Talwar：Istio 在技术势头之前就已经有了营销的势头。这是其反馈循环的原因之一。它现在变得更好了。现在已经好了很多。另一件事是，它有太多的旋钮和太多的配置，等等，它只是让人们摸索和采用时变得复杂。另一件事是你需要对谁能做什么进行非常干净的控制。我经常告诉人们，与 Kubernetes 和其他类似的东西不同，&lt;strong&gt;Istio 和服务网格总体上是一个多角色的问题&lt;/strong&gt;。这不是一个单一角色的问题。在企业内部，一个平台团队如何管理网关，管理 Sidecar？Sidecar 通常与应用结合在一起，所以现在，如何进行应用升级？这是应用团队的事。网关通常由一个不同的团队管理。如果你要一直走到边缘，通常有边缘代理团队。然后，安全希望总是作为其他人在那里，至少有可见性。在许多情况下，甚至想强制执行必须发生的策略，以及可选择发生的策略。他们甚至希望在工作流程中向外部暴露服务。&lt;/p&gt;
&lt;p&gt;总之，你必须解决的问题是，每个团队在他们的观点和控制方面得到什么？你如何使旋钮更简单地使用？如果你问我，这里有太多的旋钮和太多的 YAML。有一件事是，只要让它简单，这是我的 API，这是我想要的行为。这应该就这样发生。像 Istio 这样的东西只是在平台上实现的，在基础设施中也是如此。这就是我们在 Tetrate 采取的方法。我认为这是一个长期的方法，如果这将被真正地大规模采用，而且时间更长。这就是它将成为的方式。像大多数技术一样，它将变得枯燥和不可见，将有一种方法可以直接使用它们，而不必对它们的细节进行搔扰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当我们谈论服务网格和 Istio，当然还有其他技术时，人们总是担心这与传统的 API 网关有什么关系。路线图变得模糊了。比如，什么是边缘代理？什么是 API 网关？它们有区别吗？它们应该是不同的吗？你对此有什么想法？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Talwar：这里显然是有偏见的。我认为它们不应该是不同的。我们正在建立和构建的平台是这样的，全程使用 Envoy，因为你可以把它部署为一级负载均衡器，作为边缘代理。每个应用都可以有一个代理和一个应用代理在前面。然后，你可以拥有同样基于同一数据平面的 Sidecar。一个数据平面贯穿始终，然后每个应用程序，一个应用程序是我们的第一类概念，做它需要做的事情。在某些情况下，你会想，只要在入口层做认证，这就是我想要的一切。这就是我需要做的一切。我暂时不会去做 Sidecar 业务，这很正常。而其他人会想，不，我已经准备好了。这都是 HTTP，我很舒服。它不像超级性能敏感，延迟的东西对我来说并不重要。你也可以走这条路。&lt;/p&gt;
&lt;p&gt;我思考的方式是，人们建立服务。人们部署服务。你可以通过内部 API 将它们暴露给你的内部团队成员，和 / 或你的合作伙伴。你可以通过公共 API 将其暴露给公众。你需要的控制是类似的。传统上的南北和东西之间的界限正在模糊化。人们做更多的微服务和 API 协议，你需要基于内部 API 的互动。唯一的区别是内部 API，你会在那里做基于令牌的认证。在外部 API 中，你会要求像，我需要有 OAuth，你需要通过这个流程。在外部 API 中，你要做的是，不，我想要 WAF 风格的策略，即批量保护这些 IP 的类型。而在内部 API 中，你将只是说，来自这个团队的测试流量不应该对我进行 DoS，所以只是速率限制。场景有一点不同，但技术层面的控制是相似的。我认为把它放在一个平台上是很有意义的，这就是唯一的区别。&lt;/p&gt;
&lt;p&gt;事实上，Istio 所来自的团队，实际上被称为 One Platform，这是谷歌的说法，这是内部 API，外部 API。你只要告诉我们你在你的 API 中想要什么。这些是行为。我们以前在谷歌的团队所做的是，每个团队只是提交他们的 API 规格和他们想要的东西，事情就会发生。今天它是一个内部的，明天就变成了一个外部的 API。你可以在 API 规格上添加一些东西，仅此而已。在推广方面没有其他变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网格的网格，这到底是不是同一个东西？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Talwar：我不太喜欢这个词，但这个概念确实是真的。我们在 Tetrate 所做的，以及我认为更普遍的，在工业界，它正在成为事实，这就是，有三个层次，这还没有被很好地解释。有一个数据平面，它必须通信的地方。还有一个控制平面，需要在它的附近，也就是在同一个集群或同一个 VPC 中，但不能太远。然后还有第三层，也就是我们所说的管理平面，也就是你在上面看，说，好的，我需要为每个应用做什么，做路由决定，做弹性决定，等等。我们正在建立管理平面。Istio 仍然是按原样使用的，随着它的功能不断增加，以及所有这些，作为附近的控制平面。&lt;/p&gt;
&lt;p&gt;当然，它是以一种与计算和云无关的方式完成的。如果我在微软云有 N 个集群，在亚马逊云有 N 个集群，每个集群都可以用 Istio 作为控制平面。你真的能做出那些有弹性的决定，而不是路由到这个微软区，而是路由到这个亚马逊区？人们来问我，为了成本、性能、安全或其他原因选择他们喜欢的云服务，我们可以这样做吗？这绝对是可能的，但对人们来说并不那么容易实现。我们想让这个目标容易实现。我认为我们正在走向那个世界。网格的网格听起来是一个不好的名字，但从架构上看，我们正在走向那里。&lt;/p&gt;
&lt;p&gt;是的，它可以在任何地方。这就是管理机的魅力所在。它可以在任何一个地方，无论你决定它在哪里。问题是，所需的边缘或入口要放在更接近其应用的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我喜欢你的智能应用感知网络的说法，你认为它是否总是可以自动等同于一般的服务网格？如果我不使用边缘技术，那么我的替代方案是什么，如果有的话？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Talwar：服务网格成为这个一切的术语。这个概念就是你的网络和你的平台层更加智能。例如，gRPC 是我的另一个宝贝，它支持 xDS，所以你可以在 gRPC 中建立东西，没有任何代理，并要求控制层有同样的行为，这一切都可以。我认为更多的语言栈和框架将开始支持这些类似 xDS 的功能。一旦他们这样做了，我想我们就可以进入事情本身的构建方式了。这还没有发生。我认为这才是应该发生的。今天是 Envoy 代理。明天可能是更好的东西。这个概念在语言框架和这些代理中都是一样的。让它们更智能，这样你就不会在应用中做了，而且你可以在不加重应用开发者负担的情况下，在你的应用中持续地做。我认为这个概念是非常有用的，而且会继续存在。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在 Istio 中引入 Wasm 意味着什么？</title>
      <link>https://cloudnativecn.com/blog/importance-of-wasm-in-istio/</link>
      <pubDate>Wed, 16 Feb 2022 09:24:17 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/importance-of-wasm-in-istio/</guid>
      <description>&lt;p&gt;WasmPlugin API 最近被添加到 Istio 项目中，作为一种新改进的可扩展性机制。在 Tetrate，我们最近成功举办了一个名为 Istio Wasm workshop 的研讨会。&lt;a href=&#34;https://tetrate-io.zoom.us/webinar/register/WN_OJG0hpo-RXSEJcH_SutlPQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击这里&lt;/a&gt;观看研讨会的录音，并加入 &lt;a href=&#34;https://tetr8.io/tetrate-edu-slack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slack 上的对话&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们谈论了 WebAssembly 及其在 Istio 和 Envoy 项目中的重要性，并通过使用 &lt;a href=&#34;https://github.com/tetratelabs/proxy-wasm-go-sdk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy-Wasm Go SDK&lt;/a&gt; 和 &lt;a href=&#34;https://func-e.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;func-e&lt;/a&gt; 进行了多个演示。&lt;/p&gt;
&lt;p&gt;我们在 Tetrate 关注 Istio 的可扩展性已经有很长一段时间了。Tetrate 的工程师 Takeshi Yoneda 和周礼赞在为此做出了巨大的贡献，我们非常高兴地看到 Istio 的可扩展性因此而得到了极大的改善。&lt;/p&gt;
&lt;p&gt;在这篇博文中，我描述了在引入 WasmPlugin API 之前 Istio 和 Envoy 可扩展性的状况；目前大为改善的情况；以及将或多或少完成这条可扩展性改进弧线的变化，我们预计这些变化将在即将到来的版本中出现。&lt;/p&gt;
&lt;h2 id=&#34;istio-和-wasm-的历史&#34;&gt;Istio 和 Wasm 的历史&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Istio 1.4 之前&lt;/th&gt;
          &lt;th&gt;Istio 1.5&lt;/th&gt;
          &lt;th&gt;Istio 1.12 和未来&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;用 C++ 扩展维护自己的 Envoy 代理构建&lt;/td&gt;
          &lt;td&gt;使用 EnvoyFilter 资源引入新的 Wasm 可扩展性模型（仍然复杂）&lt;/td&gt;
          &lt;td&gt;引入专用的 WasmPlugin API&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;使用 Mixer（效率低）&lt;/td&gt;
          &lt;td&gt;仅支持本地或 HTTP 位置&lt;/td&gt;
          &lt;td&gt;包括对 OCI 注册表的支持&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在 Istio 1.4（2019 年 11 月发布）之前，没有良好的机制来运行插件。当时，Istio 维护了他们自己的 Envoy 代理的分支，以运行自定义插件，如用 C++ 编写并与 Envoy 代理一起构建的 RBAC 和 JWT 过滤器。&lt;/p&gt;
&lt;p&gt;当时，Istio 使用 Mixer 组件，在应用程序代码和基础设施后端之间提供一个层。使用 Mixer，人们能够执行授权策略，收集遥测数据，并管理配额。在这种模式下，Envoy 代理在向后端发出请求之前会调用 Mixer 组件，以执行任何前提条件检查 —— 例如，“服务 A 能否调用服务 B”，并在每个请求完成后再次调用 Mixer 以报告遥测数据。使用这种模式导致了资源的低效使用，也导致了延迟。&lt;/p&gt;
&lt;p&gt;Envoy 的扩展性依赖于开发者知道如何用 C++ 编写扩展。此外，任何 C++ 扩展都必须用 Envoy 代理来构建。这就是当时 Istio 维护他们自己的 Envoy 代理构建的原因。&lt;/p&gt;
&lt;p&gt;在这种模式下，人们必须用新的二进制文件替换整个现有的 Envoy 代理实例。&lt;/p&gt;
&lt;h2 id=&#34;envoy-和-wasm-的历史&#34;&gt;Envoy 和 Wasm 的历史&lt;/h2&gt;
&lt;p&gt;Envoy 希望将依赖一个单一的可扩展性堆栈，使 Envoy 的发布与扩展生态系统脱钩，并使扩展开发者能够使用 C++ 以外的东西。在 Envoy 中加入这个功能，可以让 Istio（以及其他 Envoy 代理用户）随时推出新的特性和功能，而不需要单独维护 Envoy 的构建。在 Envoy 和 Istio 双方的强烈推动下，在 Envoy 中&lt;a href=&#34;https://github.com/envoyproxy/envoy/issues/4272&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;支持&lt;/a&gt; WebAssembly 的&lt;a href=&#34;https://github.com/envoyproxy/envoy/issues/4272&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;工作&lt;/a&gt;于 2018 年开始。&lt;/p&gt;
&lt;h2 id=&#34;在-envoy-中引入-webasssembly&#34;&gt;在 Envoy 中引入 WebAsssembly&lt;/h2&gt;
&lt;p&gt;在 Envoy 和 Istio 中所做的关于可扩展性的艰苦工作被纳入了 Istio 1.5 版本（2020 年）。Istio 1.5 版本包括一个使用 WebAssembly 的可扩展性新模型。随着 WebAssembly 的引入，不再需要运行单独的 Mixer 组件，这也导致了 Istio 部署的简化 —— 少了一件部署的东西，也少了一件需要担心的东西。&lt;/p&gt;
&lt;p&gt;该版本包括通用的应用二进制接口（ABI）和 C++、Rust 和 AssemblyScript SDK。现有的 Istio 功能，如统计、元数据交换和其他功能也被实现为 WebAssembly 扩展。一个名为 EnvoyFilter 的资源被引入，以处理这些扩展的部署。&lt;/p&gt;
&lt;p&gt;EnvoyFilter 资源是对 Envoy 配置的一个非常简单的抽象，它允许 Istio 操作者修改 Envoy 代理行为。然而，这种轻量级的抽象仍然意味着操作者必须熟悉 Envoy API 的细节以及如何有效地配置它们。&lt;/p&gt;
&lt;p&gt;为了让 Envoy 代理加载和使用扩展，你必须把 Wasm 二进制文件放在与 Envoy 代理容器相同的 pod 内。运维人员可以选择指向一个本地文件（即集群内的文件，Envoy 代理容器可以访问）或提供一个 HTTP 位置，代理可以从那里下载扩展。&lt;/p&gt;
&lt;p&gt;在 Istio 的后续版本中有多项改进，特别是 Istio 代理开始拦截 EnvoyFilter 资源并代表 Envoy 代理获取二进制文件的变化。&lt;/p&gt;
&lt;h2 id=&#34;istio-112-和-wasmplugin-api&#34;&gt;Istio 1.12 和 WasmPlugin API&lt;/h2&gt;
&lt;p&gt;最近在 Istio 1.12 中引入了最重要的突破性功能。为 Wasm 插件引入了一个专门的 API，称为 WasmPlugin API，它使用一种新的方法从符合 OCI 的注册表中获取 Wasm 二进制文件。&lt;/p&gt;
&lt;p&gt;新 API 的引入消除了使用 EnvoyFilter 来部署扩展的需要。扩展开发者现在可以使用一个名为 WasmPlugin 的资源来指定要部署插件的工作负载。对符合 OCI 标准的注册表的新支持允许开发人员使用现有的工具（例如，Docker）来构建包含其扩展的镜像，并将其推送到符合 OCI 标准的注册表。这允许以对待容器镜像的相同方式对待 Wasm 插件。例如，使用镜像标签和不同的存储库。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;WasmPlugin API 的工作仍在进行中。一些功能，包括对镜像拉取 secret 的支持，更好的镜像缓存支持，以及对 singleton 扩展的支持还不能使用。&lt;/p&gt;
&lt;p&gt;要开始使用 Wasm，请&lt;a href=&#34;https://tetrate-io.zoom.us/webinar/register/WN_OJG0hpo-RXSEJcH_SutlPQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;观看&lt;/a&gt; Wasm 研讨会的&lt;a href=&#34;https://tetrate-io.zoom.us/webinar/register/WN_OJG0hpo-RXSEJcH_SutlPQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;录音&lt;/a&gt;并加入 &lt;a href=&#34;https://tetr8.io/tetrate-edu-slack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slack 上的 Wasm 对话&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>零信任网络的微服务基本要素概述</title>
      <link>https://cloudnativecn.com/blog/zero-trust-network-for-microservices/</link>
      <pubDate>Mon, 17 Jan 2022 09:24:17 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/zero-trust-network-for-microservices/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;编者按&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本博客将向您介绍零信任网络及其基本要素，这是 CISO（首席信息安全官）必须考虑的，以使网络强大，在当今的数字转型中没有安全漏洞，并减少潜在的财务损失。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;当今所有主要组织都在经历大规模的数字化转型，采用云、移动、微服务和容器技术来高效地提供服务，满足关键业务需求，赶上市场预期。企业的平台和 DevOps 团队必须对分布式和多云的应用程序和服务进行建模，以便随时随地进行访问，从而实现敏捷性。这在组织内部产生了两个重要的趋势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随着越来越多的组织采用多云，他们将其应用程序部署到公有云（谷歌、亚马逊、Azure 等），这意味着数据离开了他们所认为的安全的内部数据中心。&lt;/li&gt;
&lt;li&gt;企业使用微服务和分布式架构来实现大规模和敏捷。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然而，应用程序开发人员现在需要解决一系列新的可靠性和安全性问题，因为越来越多的依赖性是通过网络调用消耗的。当集中式系统在使用时，网络和端点安全在十年前很容易实现和管理。安全团队可以利用防火墙充分保障周边的安全。随着多云中的分散数据和微服务导致的分布式工作负载的新趋势，IT 安全组织需要评估他们的安全态势，并重新思考他们的网络架构。当然，安全不是一个人或一个部门的工作，它是一个组织中的 IT 安全、DevOps 和 Ops 团队的共同责任。&lt;/p&gt;
&lt;h2 id=&#34;什么是零信任网络&#34;&gt;什么是零信任网络？&lt;/h2&gt;
&lt;p&gt;零信任是一个指导原则，它强调 IT 组织在构建网络架构时不信任任何个人、应用程序或设备。在这里，“零 &amp;ldquo;信任意味着&amp;rdquo; 不隐含 &amp;quot; 信任。企业 IT 部门不能假设外部和内部实体是值得信任的，或者对任何实体的安全风险进行一次性评估就足够了（实体可以是应用、人或流量）。&lt;/p&gt;
&lt;p&gt;零信任通常与网络安全相关，因为只有在有数据交换的情况下，信任才会出现。零信任网络是一种通过认证和监控每个网络访问来识别任何外部实体的可信度的方法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.tetrate.io/white-paper-zero-trust-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击下载零信任架构白皮书&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;为什么我们比以往任何时候都更需要零信任网络&#34;&gt;为什么我们比以往任何时候都更需要零信任网络？&lt;/h2&gt;
&lt;p&gt;我们想强调零信任网络比以往任何时候都更重要的最常见原因。&lt;/p&gt;
&lt;h3 id=&#34;云中的数据泄露现在很普遍&#34;&gt;云中的数据泄露现在很普遍&lt;/h3&gt;
&lt;p&gt;数据泄露事件在逐年上升，损害了公司的声誉。我仍然记忆犹新，一个分水岭事件是 2020 年的 Solarwinds 攻击事件。Solarwinds Orion 是一个基于 SaaS 的网络监控工具，它被入侵了，木马使用恶意软件攻击来掌握整个网络基础设施。虽然没有任何企业的敏感数据或文件被窃取等附带损害，但入侵是跨领域和跨地域的。即使是先进的公司，对云的网络钓鱼攻击和恶意软件攻击通常也很难发现，而且在未来可能会上升。根据 Verizon &lt;a href=&#34;https://www.verizon.com/business/resources/reports/dbir/2021/masters-guide/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最近的研究结果&lt;/a&gt;，云计算漏洞已经超过了内部数据漏洞 ——2021 年 73% 的网络安全事件涉及外部云资产。而 CISO 的一个标准建议是尽快应用零信任网络的原则以避免安全漏洞。&lt;/p&gt;
&lt;h3 id=&#34;分布式工作负载也不安全由于运行时矢量攻击&#34;&gt;分布式工作负载也不安全，由于运行时矢量攻击&lt;/h3&gt;
&lt;p&gt;虽然企业采用 Kubernetes 技术的速度比以往任何时候都快，但它们并不是 100% 安全的。Kubernetes 和容器化应用经常出现漏洞和黑客攻击的情况。根据 &lt;a href=&#34;https://www.redhat.com/en/resources/kubernetes-adoption-security-market-trends-2021-overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2021 年 RedHat 的报告&lt;/a&gt;，90% 的受访者在过去一年中经历了涉及其容器和 Kubernetes 环境的安全事件。&lt;/p&gt;
&lt;p&gt;分布式系统失败的常见原因之一是 Kubernetes 集群在运行时（或实时）的矢量攻击，并带来了一系列新的安全挑战。如果黑客攻破一个 Kubernetes 容器，他们将试图攻破整个集群，这是一种复杂的矢量攻击。美国国家安全局（NSA）指出，黑客针对 Kubernetes 来&lt;a href=&#34;https://www.zdnet.com/article/hacker-target-kubernetes-to-steal-data-and-processing-power-now-the-nsa-has-tips-to-protect-yourself/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;窃取数据和计算能力&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;根本原因往往是隐性信任，假设集群间的资源是可信的，集群内不安全的网络通信是安全的。&lt;/p&gt;
&lt;h3 id=&#34;安全配置不是开发人员的核心能力&#34;&gt;安全配置不是开发人员的核心能力&lt;/h3&gt;
&lt;p&gt;尽管 Kubernetes 给基础设施和应用交付领域带来了敏捷性和规模，但要确保安全是个挑战。有人可能会说，Kubernetes 中有一些固有的安全功能，如使用 ClusterRoleBinding 的 RBAC，Kubernetes 服务的 TLS 等，应该足够了。然而，Kubernetes 需要大量的配置来使工作负载免受外部和内部威胁。例如，在 pod 之间强制执行 TLS，在某些时候需要维护数百个 TLS 证书。&lt;/p&gt;
&lt;p&gt;而那些已经专注于开发业务功能的开发人员可能不会优先考虑安全问题。红帽公司最近发布的一份关于 &lt;a href=&#34;https://www.redhat.com/en/blog/state-kubernetes-security&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 安全状况&lt;/a&gt;的报告显示，大型企业面临的安全事件大多与错误配置、重大漏洞有关，并遭遇到运行时安全事件。&lt;/p&gt;
&lt;h3 id=&#34;应用程序的交付在-cicd-的帮助下获得了快速发展而安全问题却没有&#34;&gt;应用程序的交付在 CI/CD 的帮助下获得了快速发展，而安全问题却没有&lt;/h3&gt;
&lt;p&gt;通过 CI/CD 流程、交付协调工具、GitOps 风格的部署，DevOps 团队加快了软件交付速度。许多组织可以每天将应用程序部署到生产中（如果需要，往往在几个小时内）。这种创新速度适合于组织的蓬勃发展和成长，但如果不注重强大的安全性和合规性，就会带来漏洞。&lt;/p&gt;
&lt;p&gt;我们所接触的大多数组织都在他们的 DevOps 流程中逐步发展并开始采用 DevSecOps，将安全检查整合到他们的 SDLC 过程中。作为一种实践，他们的 DevOps 团队、合规经理、安全经理、网络管理员在部署前合作讨论安全要求和构建威胁模型。&lt;/p&gt;
&lt;h2 id=&#34;实施零信任网络的关键因素&#34;&gt;实施零信任网络的关键因素&lt;/h2&gt;
&lt;p&gt;不同的安全组织、分析师和作者提出了许多框架。例如，Forrester 建议零信任扩展（ZTX 模型），并主张保护不同的数据管道以保护数据本身。Gartner 有一个概念，叫做持续适应性风险和信任评估（CARTA），它主要侧重于分析与身份和设备相关的风险态势。&lt;/p&gt;
&lt;p&gt;我们相信，没有任何一个放之四海而皆准的框架能适用于所有的场景和所有的组织。我们为使用微服务范式开发和部署应用程序的企业提供一个零信任框架，以确保网络和应用程序的安全。&lt;/p&gt;
&lt;p&gt;Tetrate 与&lt;a href=&#34;https://www.nist.gov/news-events/events/2022/01/zta-and-devsecops-cloud-native-applications-virtual&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;美国国家标准与技术研究所（NIST）&lt;/a&gt;合作，为联邦机构开发标准，以便为其微服务实施零信任架构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你可以在 NIST 和 Tetrate 共同编写的 NIST 特别出版物中阅读在微服务中实现零信任的详细指南：《&lt;/strong&gt;&lt;a href=&#34;https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-204.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;微服务的安全策略&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;》、《&lt;/strong&gt;&lt;a href=&#34;https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-204A.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;使用服务网格构建安全的微服务&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;》、《&lt;/strong&gt;&lt;a href=&#34;https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-204B-draft.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;使用服务网格的基于属性的微服务访问控制&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;》、《&lt;/strong&gt;&lt;a href=&#34;https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-204C-draft.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;使用服务网格实现微服务的 DevSecOps&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;》和《&lt;/strong&gt;&lt;a href=&#34;https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;零信任架构&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;》。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于 CISO 和 CTO 来说，基于上述研究文件，我们主张采用持续安全框架，以实现其微服务和服务网格的零信任，避免数据泄露。在这个框架下，有 4 个关键因素需要考虑。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-微服务的零信任网络框架&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;微服务的零信任网络框架&#34; srcset=&#34;
               /blog/zero-trust-network-for-microservices/008i3skNly1gygh9tlkvlj31gw0skgnr_hu_6feabec7dfe69f2f.webp 400w,
               /blog/zero-trust-network-for-microservices/008i3skNly1gygh9tlkvlj31gw0skgnr_hu_f8b26fb3b4ebaf81.webp 760w,
               /blog/zero-trust-network-for-microservices/008i3skNly1gygh9tlkvlj31gw0skgnr_hu_c19dd2bf0a4ed057.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/zero-trust-network-for-microservices/008i3skNly1gygh9tlkvlj31gw0skgnr_hu_6feabec7dfe69f2f.webp&#34;
               width=&#34;760&#34;
               height=&#34;410&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      微服务的零信任网络框架
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务的零信任网络框架&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 安全网络&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DevSecOps 团队的首要任务是确保网络和数据的完整性。到你的应用程序的流量可以来自任何地方：包括企业自有网络内部和外部。任何设备或请求都不应该被信任，不管它们是否属于企业网络。所有的通信都应该以加密、认证和授权的方式进行，以保护数据的机密性，防止恶意行为者从网络中窃取数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 保障资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;资源可以是小型应用（服务或工作负载），可以向网络内的其他应用发送流量。一个网络可能由多个服务组成，每个服务将通过网络使用 API 调用与其他服务对话，以执行某些业务功能和逻辑。在授予访问权以发送处理请求之前，必须根据已建立的资源身份，对每个服务的信任进行评估。认证和授权检查服务身份必须发生在一个会话中，而且服务不应该默认继承对所有资源的访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 确保用户安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对一个应用程序的威胁可能是由内部或外部用户造成的。这就是为什么在授予访问权之前要通过适当的认证来评估每个请求者的可信度。就像保护资源一样，对用户的访问应该以完成任务所需的最小权限来授予，而且应该是基于会话的。当然，各种用户会根据他们的角色获得访问权限。DevOps 团队和安全部门应该谨慎地分配权限，定义角色，并对用户进行治理，以避免安全和合规性威胁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 最大限度地提高可见性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了实施零信任网络，IT 安全组织必须不断实时评估其 IT 环境的安全态势，特别是微服务。为了对任何安全事件做出反应，安全团队必须配备适当的信息和可见性，以加快诊断和分流。应该有一个适当的机制，从企业网络的资源中追踪和隔离损坏的或脆弱的资源或用户或设备。&lt;/p&gt;
&lt;h2 id=&#34;tetrate-service-bridgetsb如何帮助开箱即用&#34;&gt;Tetrate Service Bridge（TSB）如何帮助开箱即用？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.tetrate.io/tetrate-service-bridge/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Service Bridge(TSB)&lt;/a&gt; 通过一个与云无关的集中式平台为所有从边缘到工作负载的应用和 API 实现安全、敏捷和可观察性。它为平台所有者提供所有环境的内置安全和集中的可见性和治理，同时授权开发人员为其应用程序做出本地决定。&lt;/p&gt;
&lt;p&gt;TSB 通过为您的应用程序和云平台提供 FIPS 认证的构建，Istio 和 Envoy 的生命周期管理，以及其他增强功能以提高可用性，将 Istio 和 Envoy 增强为企业级服务网格。&lt;/p&gt;
&lt;p&gt;Tetrate Service Bridge（TSB）位于应用边缘，负责控制所有计算集群的请求级流量、多云、Kubernetes 和传统计算集群之间的流量转换，并提供南北 API 网关功能。TSB 还提供了一个带有 &lt;a href=&#34;https://www.tetrate.io/blog/unpacking-next-generation-access-control-ngac-and-tetrate-q/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NGAC&lt;/a&gt; 框架的全局管理平面，以定义安全策略和配置，获取遥测数据，并在整个网络拓扑结构中处理 Istio 和 Envoy 的生命周期。有了 TSB，安全团队可以将安全从应用代码栈中剥离出来，放在属于他们的透明网络层中 —— 避免开发人员为安全而耗费精力修改代码。&lt;/p&gt;
&lt;p&gt;DevOps 团队仍然可以继续执行他们的计划，根据业务需求更快地将应用程序部署到多云中，而安全方面可以对微服务的安全策略进行集中控制。让我们看看 TSB 组件如何帮助实现安全。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-微服务的零信任网络的-tetrate-实现&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;微服务的零信任网络的 Tetrate 实现&#34; srcset=&#34;
               /blog/zero-trust-network-for-microservices/008i3skNly1gyggs2hdtaj30wi0q20uz_hu_659f3a43926263a6.webp 400w,
               /blog/zero-trust-network-for-microservices/008i3skNly1gyggs2hdtaj30wi0q20uz_hu_2e5be0b4470d42d4.webp 760w,
               /blog/zero-trust-network-for-microservices/008i3skNly1gyggs2hdtaj30wi0q20uz_hu_829bae53221b1d21.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/zero-trust-network-for-microservices/008i3skNly1gyggs2hdtaj30wi0q20uz_hu_659f3a43926263a6.webp&#34;
               width=&#34;760&#34;
               height=&#34;610&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      微服务的零信任网络的 Tetrate 实现
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务的零信任网络的 Tetrate 实现&lt;/p&gt;
&lt;p&gt;TSB 提供保护您的资源、网络、用户和最大限度地提高可见性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 安全命名，用于服务间的授权，以确保资源安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于 Tetrate Service Bridge（TSB）建立在 Istio 上，默认情况下它提供安全命名，以确保工作负载（VM 和 Pod）属于同一个微服务。TSB 为每个工作负载（VM 或 Pod）创建服务身份，并将信息存储在安全名称信息中。服务器身份在证书中进行编码，但服务名称是通过发现服务或 DNS 检索的。安全命名信息将服务器身份映射到服务名称。从（例如）服务 A 到服务名称 B 的身份映射意味着 &amp;ldquo;A 被授权与服务 B 对话”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 基于 mTLS 的服务认证，确保网络安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TSB 提供 Istio 点对点认证资源，以验证客户端与安全工作负载的连接。它使你能够通过 Envoy 代理在你的服务网格中实现 mTLS 认证，这是一个与每个服务一起工作的小应用程序（也被称为 sidecar 代理）。客户端 Envoy 代理与服务端 Envoy 代理进行握手，只有当相互的 TLS 连接建立后，流量才从客户端转移到服务器端。&lt;/p&gt;
&lt;p&gt;基于 mTLS 的认证被称为点对点（P2P）认证，不需要改变任何服务代码。基于 mTLS 的 p2p 认证为每个服务提供了一个强大的识别，以实现跨集群和多云的互操作性。安全管理人员现在可以在 TSB 管理平面中定义基于 mTLS 的认证策略，对网络中的服务间的通信进行加密。有了安全的网络，就没有中间人攻击的机会。&lt;/p&gt;
&lt;p&gt;TSB 提供了一个证书管理系统，自动生成、分发和轮换私钥和证书，以解密请求中的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 基于 JWT 的认证，以确保来自内部和外部用户的应用安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于终端用户的认证，以验证附加在请求上的凭证，TSB 提供现有的 Istio 资源（也称为请求认证）。安全管理人员现在可以利用 Istio 资源，通过验证 JSON 网络令牌（JWT）来验证凭证。该令牌将有令牌的位置、发行者的详细信息和公共 JSON 网络密钥集。安全经理可以根据他们的组织标准指定认证策略和规则，TSB 将根据令牌与策略的匹配程度拒绝或接受用户请求。&lt;/p&gt;
&lt;p&gt;由于 TSB 全局管理使用 Istio，它提供了灵活性，可以与您选择的认证供应商连接，如 OpenID Connect 供应商，例如，KeyCloak、OAuth 2.0、Google Auth、Firebase Auth 等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 对安全资源和用户进行访问控制的授权策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TSB 授权策略允许安全经理创建跨服务网格、命名空间和工作负载的访问控制。比如说，一个真实的用户已经进入了一个系统，但是应该限制他在该系统下采取任何行动。&lt;/p&gt;
&lt;p&gt;安全经理现在可以使用单一资源定义工作负载之间和最终用户之间授权的细化规则（如允许、拒绝或自定义请求）；易于使用和维护。最重要的是，TSB 中的 Istio 授权策略支持通信框架，如 gRPC、HTTP、HTTPS 和 HTTP/2、TCP。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 可观察性和实时可见性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Tetrate Service Bridge（TSB）允许安全管理人员主动监控和测量微服务的完整性和安全态势。TSB 控制平面产生运行时遥测数据，帮助安全人员、网络管理员和 SRE 不断跟踪服务的行为。除了生成指标，TSB 还提供运行时的可观察性，如每个服务的流量和服务依赖关系。TSB 管理平面提供对信息的可见性，如谁被授权使用什么服务，什么被加密等。&lt;/p&gt;
&lt;p&gt;安全团队现在可以看到每个服务是如何与其他服务互动的，在发生恶意攻击的情况下，他们可以迅速隔离被破解的应用程序，以免损害其声誉，然后准备发布补丁。此外，TSB 为选定的时间段生成审计日志，提供每个访问信息的方式、内容、时间和地点的完整视图。审计日志帮助审计人员和安全经理追踪潜在的安全漏洞或任何违反策略的行为，并帮助迅速找到问题的根源。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;如果安全团队能够保护网络，在每笔交易中验证服务和用户的身份，并获得 360 度的可见性，以便在发生事故时做出更快的反应，他们就达到了微服务的零信任。通过零信任架构，安全团队可以消除从网络中窃取数据（用户凭证、网络访问和横向移动能力）的风险。另一方面，终端用户可以获得一致的、稳定的，更重要的是安全的体验，无论他们在什么地方，使用什么终端，或者他们的应用程序是在企业内部还是在云中。&lt;/p&gt;
&lt;p&gt;如果你对此感兴趣的话，你可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册参加即将举行的关于 &lt;a href=&#34;https://www.tetrate.io/zta-devsecops-conference-2022/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ZTA 和云原生应用的 DevSecOps 的&lt;/a&gt;安全会议&lt;/li&gt;
&lt;li&gt;阅读更多关于 &lt;a href=&#34;https://www.tetrate.io/zero-trust/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TSB 提供的服务&lt;/a&gt;如何&lt;a href=&#34;https://www.tetrate.io/zero-trust/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;帮助您在微服务中实现零信任的信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;下载我们的白皮书，了解&lt;a href=&#34;https://www.tetrate.io/white-paper-zero-trust-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为什么使用 Istio 服务网格来实现零信任安全&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Istio 1.12 引入 Wasm 插件配置 API 用于扩展 Istio 生态</title>
      <link>https://cloudnativecn.com/blog/istio-wasm-extensions-and-ecosystem/</link>
      <pubDate>Wed, 24 Nov 2021 18:03:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/istio-wasm-extensions-and-ecosystem/</guid>
      <description>&lt;p&gt;Istio 1.12 中新的 WebAssembly 基础设施使其能够轻松地将额外的功能注入网格部署中。&lt;/p&gt;
&lt;p&gt;经过三年的努力，Istio 现在有了一个强大的扩展机制，可以将自定义和第三方 Wasm 模块添加到网格中的 sidecar。Tetrate 工程师&lt;a href=&#34;https://github.com/mathetake&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;米田武（Takeshi Yoneda）&lt;/a&gt;和&lt;a href=&#34;https://github.com/lizan&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;周礼赞（Lizan Zhou）&lt;/a&gt;在实现这一目标方面发挥了重要作用。这篇文章将介绍 Istio 中 Wasm 的基础知识，以及为什么它很重要，然后是关于建立自己的 Wasm 插件并将其部署到网格的简短教程。&lt;/p&gt;
&lt;h2 id=&#34;为什么-istio-中的-wasm-很重要&#34;&gt;为什么 Istio 中的 Wasm 很重要&lt;/h2&gt;
&lt;p&gt;使用 Wasm，开发人员可以更容易的扩展网格和网关。在 Tetrate，我们相信这项技术正在迅速成熟，因此我们一直在投资上游的 Istio，使配置 API、分发机制和从 Go 开始的可扩展性体验更加容易。我们认为这将使 Istio 有一个全新的方向。&lt;/p&gt;
&lt;h2 id=&#34;有何期待新的插件配置-api可靠的获取和安装机制&#34;&gt;有何期待：新的插件配置 API，可靠的获取和安装机制&lt;/h2&gt;
&lt;p&gt;有一个新的顶级 API，叫做 &lt;a href=&#34;https://istio.io/latest/docs/reference/config/proxy_extensions/wasm-plugin/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WasmPlugin&lt;/a&gt;，可以让你配置要安装哪些插件，从哪里获取它们（OCI 镜像、容器本地文件或远程 HTTP 资源），在哪里安装它们（通过 &lt;a href=&#34;https://istio.io/latest/docs/reference/config/type/workload-selector/#WorkloadSelector&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Workload 选择器&lt;/a&gt;），以及一个配置结构体来传递给插件实例。&lt;/p&gt;
&lt;p&gt;istio-agent 中的镜像提取机制（在 Istio 1.9 中引入），从远程 HTTP 源可靠地检索 Wasm 二进制文件，已被扩展到支持从任何 OCI 注册处检索 Wasm OCI 镜像，包括 Docker Hub、Google Container Registry（GCR）、Amazon Elastic Container Registry（Amazon ECR）和其他地方。&lt;/p&gt;
&lt;p&gt;这意味着你可以创建自己的 Wasm 插件，或者从任何注册处选择现成的插件，只需几行配置就可以扩展 Istio 的功能。Istio 会在幕后做所有的工作，为你获取、验证、安装和配置它们。&lt;/p&gt;
&lt;h2 id=&#34;istio-wasm-扩展&#34;&gt;Istio Wasm 扩展&lt;/h2&gt;
&lt;p&gt;Istio 的扩展机制使用 &lt;a href=&#34;https://github.com/proxy-wasm/spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Proxy-Wasm 应用二进制接口（ABI）&lt;/a&gt;规范，该规范由周礼赞和米田武带头制定，提供了一套代理无关的流媒体 API 和实用功能，可以用任何有合适 SDK 的语言来实现。截至目前，Proxy-Wasm 的 SDK 有 AssemblyScript（类似 TypeScript）、C++、Rust、Zig 和 Go（使用 TinyGo WebAssembly 系统接口「WASI」，米田武也是其主要贡献者）。&lt;/p&gt;
&lt;h2 id=&#34;如何获取tetrate-istio-distro&#34;&gt;如何获取：Tetrate Istio Distro&lt;/h2&gt;
&lt;p&gt;获得 Istio 的最简单方法是使用 Tetrate 的开源 &lt;a href=&#34;https://istio.tetratelabs.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;get-mesh&lt;/code&gt; CLI 和 Tetrate Istio Distro&lt;/a&gt;，这是一个简单、安全的上游 Istio 的企业级发行版。&lt;/p&gt;
&lt;h2 id=&#34;wasm-实战构建你自己的速率限制-webassembly-插件&#34;&gt;Wasm 实战：构建你自己的速率限制 WebAssembly 插件&lt;/h2&gt;
&lt;p&gt;在我们之前关于 &lt;a href=&#34;https://www.tetrate.io/blog/wasm-modules-and-envoy-extensibility-explained-part-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 中的 Wasm 扩展&lt;/a&gt;的博客中，我们展示了如何开发 WebAssembly 插件来增强服务网格的能力。新的 Wasm 扩展 API 让它变得更加简单。本教程将解释如何使用 Istio Wasm 扩展 API 来实现 Golang 中的速率限制。&lt;/p&gt;
&lt;h3 id=&#34;先决条件&#34;&gt;先决条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;熟悉 &lt;a href=&#34;https://www.tetrate.io/blog/wasm-modules-and-envoy-extensibility-explained-part-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 和 Envoy 中的 Wasm&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;安装 &lt;a href=&#34;https://tinygo.org/getting-started/install/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TinyGo 0.21.0&lt;/a&gt; 并使用 Golang 构建 Wasm 扩展。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;
&lt;p&gt;在这个例子中，我们将在集群中部署两个应用程序（sleep 和 httpbin）。我们将从一个容器向另一个容器发送几个请求，而不部署任何 Wasm 扩展。&lt;/p&gt;
&lt;p&gt;接下来，我们将在 Go 中创建一个 Wasm 模块，为响应添加一个自定义头，并拒绝任何请求率超过每秒两个的请求。&lt;/p&gt;
&lt;p&gt;我们将把 Wasm 模块推送到 Docker 镜像仓库，并使用新的 WasmPlugin 资源，告诉 Istio 从哪里下载 Wasm 模块，以及将该模块应用于哪些工作负载。&lt;/p&gt;
&lt;h3 id=&#34;第-1-步安装-istio-并部署应用程序&#34;&gt;第 1 步：安装 Istio 并部署应用程序&lt;/h3&gt;
&lt;p&gt;首先，我们将下载并安装 Istio 1.12，并标记 Kubernetes 的 default 命名空间，以便自动注入 sidecar。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -L https://git.io/getLatestIstio &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;ISTIO_VERSION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;1.12 sh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; istio-1.12/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./bin/istioctl install --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo -y
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl label namespace default istio-injection&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;enabled --overwrite
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，我们将部署 httpbin 和 sleep 应用程序的示例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f samples/httpbin/httpbin.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f samples/sleep/sleep.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用程序部署并运行后，我们将每秒从 &lt;strong&gt;sleep&lt;/strong&gt; 容器向 &lt;strong&gt;httpbin&lt;/strong&gt; 容器发送 4 个请求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nv&#34;&gt;SLEEP_POD&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get pod -l &lt;span class=&#34;nv&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;sleep -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;={&lt;/span&gt;.items..metadata.name&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;SLEEP_POD&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; -c sleep -- sh -c &lt;span class=&#34;s1&#34;&gt;&amp;#39;for i in $(seq 1 3); do curl --head -s httpbin:8000/headers; sleep 0.25; done&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HTTP/1.1 &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;server: envoy
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;date: Tue, &lt;span class=&#34;m&#34;&gt;16&lt;/span&gt; Nov &lt;span class=&#34;m&#34;&gt;2021&lt;/span&gt; 22:18:32 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-type: application/json
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-length: &lt;span class=&#34;m&#34;&gt;523&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;access-control-allow-origin: *
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;access-control-allow-credentials: &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x-envoy-upstream-service-time: &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HTTP/1.1 &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;server: envoy
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;date: Tue, &lt;span class=&#34;m&#34;&gt;16&lt;/span&gt; Nov &lt;span class=&#34;m&#34;&gt;2021&lt;/span&gt; 22:18:32 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-type: application/json
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-length: &lt;span class=&#34;m&#34;&gt;523&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;access-control-allow-origin: *
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;access-control-allow-credentials: &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x-envoy-upstream-service-time: &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HTTP/1.1 &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;server: envoy
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;date: Tue, &lt;span class=&#34;m&#34;&gt;16&lt;/span&gt; Nov &lt;span class=&#34;m&#34;&gt;2021&lt;/span&gt; 22:18:32 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-type: application/json
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-length: &lt;span class=&#34;m&#34;&gt;523&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;access-control-allow-origin: *
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;access-control-allow-credentials: &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x-envoy-upstream-service-time: &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你会发现所有的请求都成功了，并返回了 HTTP 200。&lt;/p&gt;
&lt;h3 id=&#34;第-2-步开发编译和推送-wasm-模块&#34;&gt;第 2 步：开发、编译和推送 Wasm 模块&lt;/h3&gt;
&lt;p&gt;我们将使用 Golang 和 Proxy Wasm Golang SDK 来开发 Wasm 模块。我们将使用 SDK 资源库中的一个现有例子，叫做 istio-rate-limiting。要开始，请先克隆 Github 仓库。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/tetratelabs/wasm-rate-limiting
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; wasm-rate-limiting/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们来看看 &lt;code&gt;main.go&lt;/code&gt; 中的代码。这就是我们使用 Proxy Wasm Golang SDK 实现速率限制逻辑的地方。Wasm 模块做了两件事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在响应中添加一个自定义的头。&lt;/li&gt;
&lt;li&gt;执行 2 个请求 / 秒的速率限制，拒绝超额的请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是 &lt;code&gt;main.go&lt;/code&gt; 的片段，显示了功能是如何实现的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Modify the header&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;httpHeaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;OnHttpResponseHeaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;numHeaders&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;endOfStream&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;types&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Action&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;additionalHeaders&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;proxywasm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddHttpResponseHeader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;types&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ActionContinue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Perform rate limiting&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;httpHeaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;OnHttpRequestHeaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;types&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Action&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;current&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;UnixNano&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;// We use nanoseconds() rather than time.Second() because the proxy-wasm has the known limitation.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;// TODO(incfly): change to time.Second() once https://github.com/proxy-wasm/proxy-wasm-cpp-host/issues/199&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;// is resolved and released.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;current&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pluginContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lastRefillNanoSec&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;1e9&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pluginContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;remainToken&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pluginContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lastRefillNanoSec&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;current&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;proxywasm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;LogCriticalf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Current time %v, last refill time %v, the remain token %v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nx&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pluginContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lastRefillNanoSec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pluginContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;remainToken&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pluginContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;remainToken&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;proxywasm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;SendHttpResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;403&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[][&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;powered-by&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;proxy-wasm-go-sdk!!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;rate limited, wait and retry.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nx&#34;&gt;proxywasm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;LogErrorf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;failed to send local response: %v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nx&#34;&gt;proxywasm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ResumeHttpRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;types&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ActionPause&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pluginContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;remainToken&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;types&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ActionContinue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;OnHttpResponseHeaders&lt;/code&gt; 函数中，我们正在迭代 &lt;code&gt;extraHeaders&lt;/code&gt; 变量，并将头文件添加到响应中。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;OnHttpRequestHeaders&lt;/code&gt; 函数中，我们得到当前的时间戳，将其与最后一次补给时间的时间戳进行比较（对于速率限制器），如果需要的话，就补给令牌。&lt;/p&gt;
&lt;p&gt;如果没有剩余的令牌，我们就发送一个带有额外头的 403 响应（&lt;strong&gt;由：proxy-wasm-go-sdk！！&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;让我们用 tinygo 将 Golang 程序编译成 Wasm 模块，并将其打包成一个 Docker 镜像。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tinygo build -o main.wasm -scheduler&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;none -target&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;wasi main.go
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们构建一个 Docker 镜像，并将其推送到镜像仓库（用你自己的 Docker 镜像仓库和镜像名称替换 &lt;code&gt;${YOUR_DOCKER_REGISTRY_IMAGE}&lt;/code&gt;）。在这之后，你的 Wasm 插件就可以在你的服务网格中使用了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker build -t &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;YOUR_DOCKER_REGISTRY_IMAGE&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;:v1 .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker push -t &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;YOUR_DOCKER_REGISTRY_IMAGE&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;:v1 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外，你也可以使用一个预构建的 Docker 镜像，它有相同的代码，位于 &lt;a href=&#34;http://ghcr.io/tetratelabs/wasm-rate-limiting:v1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ghcr.io/tetratelabs/wasm-rate-limiting:v1&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;第-3-步配置-istio-wasm-扩展-api&#34;&gt;第 3 步：配置 Istio Wasm 扩展 API&lt;/h3&gt;
&lt;p&gt;Istio Wasm Extension API 和新的 WasmPlugin 资源允许我们将我们推送到 Docker 镜像仓库的速率限制 Wasm 模块添加到 httpbin 工作负载中。下面是 WasmPlugin 资源的 YAML 配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;extensions.istio.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;WasmPlugin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin-rate-limiting&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;oci://ghcr.io/tetratelabs/wasm-rate-limiting:v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个配置部署后，Istiod 就会把相应的配置推送到 Envoy sidecar（与我们在 &lt;code&gt;matchLabels&lt;/code&gt; 字段中指定的标签相匹配的那些）。Sidecar 中的 Istio 代理将执行远程获取，下载我们刚刚推送的 Wasm 模块，然后将其加载到 Envoy 运行时的 Wasm 引擎中执行。&lt;/p&gt;
&lt;p&gt;让我们把上述 YAML 保存为 wasm.yaml，并将其部署到集群中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f ./wasm.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wasmplugin.extensions.istio.io/httpbin-rate-limiting created
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;第-4-步验证速率限制的效果&#34;&gt;第 4 步：验证速率限制的效果&lt;/h3&gt;
&lt;p&gt;在我们部署了 WasmPlugin 资源和 Istio 从注册表中获取了 Wasm 模块后，我们现在可以验证 Wasm 插件中实现的速率限制是如何工作的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nv&#34;&gt;SLEEP_POD&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl get pod -l &lt;span class=&#34;nv&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;sleep -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;={&lt;/span&gt;.items..metadata.name&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;SLEEP_POD&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; -c sleep -- sh -c &lt;span class=&#34;s1&#34;&gt;&amp;#39;for i in $(seq 1 3); do curl --head -s httpbin:8000/headers; sleep 0.25; done&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HTTP/1.1 &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;server: envoy
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;date: Tue, &lt;span class=&#34;m&#34;&gt;16&lt;/span&gt; Nov &lt;span class=&#34;m&#34;&gt;2021&lt;/span&gt; 22:16:34 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-type: application/json
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-length: &lt;span class=&#34;m&#34;&gt;523&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;access-control-allow-origin: *
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;access-control-allow-credentials: &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x-envoy-upstream-service-time: &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;who-am-i: wasm-extension
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;injected-by: istio-api!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HTTP/1.1 &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;server: envoy
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;date: Tue, &lt;span class=&#34;m&#34;&gt;16&lt;/span&gt; Nov &lt;span class=&#34;m&#34;&gt;2021&lt;/span&gt; 22:16:35 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-type: application/json
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-length: &lt;span class=&#34;m&#34;&gt;523&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;access-control-allow-origin: *
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;access-control-allow-credentials: &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x-envoy-upstream-service-time: &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;who-am-i: wasm-extension
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;injected-by: istio-api!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HTTP/1.1 &lt;span class=&#34;m&#34;&gt;403&lt;/span&gt; Forbidden
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;powered-by: proxy-wasm-go-sdk!!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-length: &lt;span class=&#34;m&#34;&gt;29&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-type: text/plain
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;who-am-i: wasm-extension
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;injected-by: istio-api!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;date: Tue, &lt;span class=&#34;m&#34;&gt;16&lt;/span&gt; Nov &lt;span class=&#34;m&#34;&gt;2021&lt;/span&gt; 22:16:35 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;server: envoy
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x-envoy-upstream-service-time: &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就像以前一样，我们从 sleep 容器向 httpbin 容器发送 3 个请求。这一次，Wasm 插件代码被执行，我们可以注意到输出中的一些差异。首先，&lt;code&gt;who-am-i&lt;/code&gt; 头被 Wasm 插件注入了。前两个请求以 HTTP 200 的响应代码成功，剩下的请求则以 HTTP 429 失败。此外，我们可以注意到一个名为 &lt;code&gt;powered-by&lt;/code&gt; 的额外头，它也被 Wasm 插件注入了。&lt;/p&gt;
&lt;h2 id=&#34;教程摘要&#34;&gt;教程摘要&lt;/h2&gt;
&lt;p&gt;总而言之，本教程演示了如何轻松实现插件功能，以扩展 Istio 的功能，满足你的特定需求。这需要三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Golang 中实现你的插件功能。&lt;/li&gt;
&lt;li&gt;编译、构建，并将 Wasm 模块推送到符合 OCI 标准的 Docker 镜像仓库。&lt;/li&gt;
&lt;li&gt;使用 WasmPlugin 资源配置服务网格工作负载，以便从远程镜像仓库中拉取 Wasm 模块。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该教程实现了一个单一的 Wasm 插件来处理 HTTP 请求。除此之外，你可以有多个 Wasm 插件，每个单独的插件负责某一部分的功能。&lt;/p&gt;
&lt;p&gt;例如，&lt;a href=&#34;https://github.com/istio/api/blob/master/extensions/v1alpha1/wasm.proto#L254&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AUTHN&lt;/a&gt; 阶段的一个插件获取或验证认证凭证；&lt;a href=&#34;https://github.com/istio/api/blob/master/extensions/v1alpha1/wasm.proto#L257&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AUTHZ&lt;/a&gt; 阶段的另一个插件实现你自己定制的授权逻辑，等等。&lt;/p&gt;
&lt;p&gt;Istio Wasm 扩展还允许我们生成插件指标，或在多个 Wasm 插件中汇总。该插件提供了一个日志功能，允许我们将日志信息写到 Envoy sidecar。这对 Wasm 插件的调试和开发特别有帮助。&lt;/p&gt;
&lt;p&gt;目前的 Istio Wasm API 处于 alpha 阶段，将在未来的 Istio 版本中得到增强和稳定。这包括通过验证签名来安全地验证 Wasm 插件本身，支持用存储为 Kubernetes Secret 的秘密来拉取 Wasm 插件等。&lt;/p&gt;
&lt;h2 id=&#34;进一步阅读和补充资源&#34;&gt;进一步阅读和补充资源&lt;/h2&gt;
&lt;p&gt;在 Tetrate，我们正在努力改善开发者的体验，&lt;a href=&#34;https://github.com/tetratelabs/proxy-wasm-go-sdk/tree/main/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tetratelabs/proxy-wasm-golang-sdk&lt;/a&gt; 包含本教程使用的 Golang SDK 库。你可以找到更多的例子，如 http &lt;a href=&#34;https://github.com/tetratelabs/proxy-wasm-go-sdk/blob/main/examples/http_routing/main.go#L70-L80&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;头的操作&lt;/a&gt;、样例&lt;a href=&#34;https://github.com/tetratelabs/proxy-wasm-go-sdk/tree/main/examples/http_auth_random&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;授权&lt;/a&gt;、&lt;a href=&#34;https://github.com/tetratelabs/proxy-wasm-go-sdk/tree/main/examples/http_routing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;改变路由&lt;/a&gt;行为等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://istio.tetratelabs.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Istio Distro&lt;/a&gt; 是安装、操作和升级 Istio 的最简单方法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.tetrate.io/istio-wasm-workshop/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;报名参加 Tetrate 的 Istio Wasm 插件研讨会，向 Istio 中的 Wasm 插件的创造者学习&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>零信任架构白皮书</title>
      <link>https://cloudnativecn.com/blog/zero-trust-architecture/</link>
      <pubDate>Thu, 22 Apr 2021 12:03:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/zero-trust-architecture/</guid>
      <description>&lt;p&gt;本文译自 Tetrate 发布的&lt;a href=&#34;https://www.tetrate.io/white-paper-zero-trust-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《零信任架构白皮书》&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;背景介绍&#34;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;传统的数据中心网络安全架构试图在一个优美的内部花园周围建立强大的围墙。这种堡垒模型长久以来存在一个固有的弱点，即当（而不是如果）入侵者渗透到周边时，他们就可以控制整个花园。虽然这个弱点早就存在，但随着进入数据中心的入口的增加及工作负载的扩展的趋势增加，这个弱点越发严重。&lt;/p&gt;
&lt;p&gt;零信任网络架构提供了一条前进的道路，它解决了基于周界安全的弱点，采取的立场是网络本身就是敌对的；周界背后的安全是一种幻觉，野蛮人已经撞开了大门。&lt;/p&gt;
&lt;p&gt;虽然零信任需要对现状进行重大反思，但它远不是一个崇高的、不可实现的目标。现在就有一些工具可以开始实施零信任网络架构。这些工具和实践可以逐步实施，以满足你的需要，而不是要求你全盘重新构建你的整个网络安全基础设施。&lt;/p&gt;
&lt;h2 id=&#34;传统安全模式的弱点&#34;&gt;传统安全模式的弱点&lt;/h2&gt;
&lt;p&gt;周边安全薄弱的原因与现代军队放弃大规模固定防御的原因类似：一旦被渗透，战斗就会失败；而周边安全最终也会被渗透。&lt;/p&gt;
&lt;p&gt;**单纯的周边安全提供了糟糕的控制粒度。**如果周界内的所有流量都是可信的，那么一个漏洞就会使周界内的一切都变得脆弱。当网络服务只有几十种时，这可能是可控的，而且可以通过物理位置严格限制访问，但服务激增到几十万种，而且都是以相同的访问水平相互通信，这使得目前的技术状态无法维持，特别是由于一个被破坏的服务可以转移到许多其他服务。&lt;/p&gt;
&lt;p&gt;多年来，业务需求已经削弱了外围的完整性。出于需要，防火墙上被打了很多洞，导致了多个暴露的入口点和难以管理的防火墙规则的扩散，使外围更像是一条马奇诺防线，而不是围墙和城堡。&lt;/p&gt;
&lt;p&gt;面对周界几乎消失的情况，为改善周界安全模式所做的新努力，如微分割和软件定义网络，有助于减少服务周围的攻击面。但是，它们也只是部分解决方案，其代价是复杂性的增加和配置规则的爆炸。分割仍然提供了糟糕的粒度。例如，隔离网络服务器和数据库服务器可以减少这些服务周围的攻击面，但网络服务器可能支持许多应用程序，它们各自可能引入的漏洞仍然是不透明的。&lt;/p&gt;
&lt;h2 id=&#34;零信任的信条&#34;&gt;零信任的信条&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;&lt;em&gt;信任不是理想的状态，信任是你想避免的失败点&lt;/em&gt;&amp;quot;——约翰·金德瓦格&lt;/p&gt;
&lt;p&gt;零信任是一种方法，一种对网络安全的思考方式，而不是任何特定的架构或实现。它从一个假设开始，即网络上没有安全的地方。你应该把你的数据中心，不管它是否喜欢，当作它所有的数据和服务都暴露在公共互联网上。&lt;/p&gt;
&lt;p&gt;在零信任模式中，与传统的周边安全不同，可及性并不意味着授权。零信任旨在缩小资源周围的隐性信任区域，最好是缩小到零。在一个零信任的网络中，所有对资源的访问都应该是这样的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;经过认证和动态授权&lt;/strong&gt;：不仅在网络层和服务间层，而且在应用层。网络位置并不意味着信任。在允许任何访问之前，服务身份和终端用户凭证是经过认证和动态授权的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有时间限制&lt;/strong&gt;：认证和授权被约束在一个短暂的会话中，之后必须重新建立。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在空间上有界限&lt;/strong&gt;：一个服务周围的信任周界应该尽可能小。加密，既是为了防止窃听，也是为了确保信息的真实性和未被篡改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可观察&lt;/strong&gt;：所以所有资产的完整性和安全态势可以被持续监控，策略的执行可以持续得到保证。另外，从观察中获得的洞察力应该被反馈到改进策略上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么它更好&#34;&gt;为什么它更好？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可访问性不是授权——与周边安全不同，对一个服务的访问并不仅仅是因为该服务是可以到达的，它还必须经过明确的认证和授权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;经过认证和授权的工作负载受到保护，不受周边漏洞的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在时间上的约束限制了凭证受损的风险。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在空间上的约束允许策略执行的高颗粒度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态策略执行确保授权策略是最新的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加密限制了侦查，并提供了通信的真实性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;细粒度的可观察性允许实时保证策略的执行，以及对历史上如何执行策略的事后审计，还有用于故障排除和分析的必要数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;零信任系统的试金石是，部署在该系统中的应用程序在公开曝光时不会有任何变化。如果实施得当，一个零信任的安全架构在公开的互联网上运行时与在防火墙后面运行时一样安全。&lt;/p&gt;
&lt;h3 id=&#34;我什么时候需要它&#34;&gt;我什么时候需要它？&lt;/h3&gt;
&lt;p&gt;虽然每个组织都可能从采用零信任原则中受益，但期望几十年的基础设施和业务流程全盘转变为新模式是不现实的。&lt;/p&gt;
&lt;p&gt;特定的压力可能会促使你尽早这样做。当你的基础设施跨越不同的供应商时，例如，分裂的企业内部和云部署或混合云部署，在这些扩展的网络上大规模应用 VPN 和 NAT 的复杂性和脆弱性可能使得在短期内对这些部署应用零信任网络原则具有成本效益和风险效率。&lt;/p&gt;
&lt;h2 id=&#34;zta-组件&#34;&gt;ZTA 组件&lt;/h2&gt;
&lt;p&gt;NIST 提出了三个逻辑组件来实现动态授权和认证。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个策略引擎（Policy Engine，简称 PE），负责确定授权。&lt;/li&gt;
&lt;li&gt;一个策略管理员（Policy Aadminstrator，简称 PA），用于根据策略引擎的结果建立和/或关闭通往资源的通信路径。&lt;/li&gt;
&lt;li&gt;策略执行点（Policy Enforcement Point，简称 PEP），位于提出请求的主体和目标资源之间，启用、监测和终止它们之间的连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图一&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图一&#34; srcset=&#34;
               /blog/zero-trust-architecture/008i3skNly1gpsrzpm3cvj31n40u0whm_hu_3d9fa826638c55e1.webp 400w,
               /blog/zero-trust-architecture/008i3skNly1gpsrzpm3cvj31n40u0whm_hu_c38b61b92d320a4b.webp 760w,
               /blog/zero-trust-architecture/008i3skNly1gpsrzpm3cvj31n40u0whm_hu_20c1a7a8726e33ec.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/zero-trust-architecture/008i3skNly1gpsrzpm3cvj31n40u0whm_hu_3d9fa826638c55e1.webp&#34;
               width=&#34;760&#34;
               height=&#34;386&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图一
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这种模式下，主体要求的所有工作负载必须有一个身份，可以在 PEP 进行认证和授权。策略决策点对这些身份执行策略，并在允许访问之前执行认证和授权。在这里，授权是基于细粒度的策略；可及性不算作授权。数据平面的 PEP 允许在运行时对系统进行观察，并确保持续的合规性和治理控制。&lt;/p&gt;
&lt;h2 id=&#34;实施&#34;&gt;实施&lt;/h2&gt;
&lt;p&gt;由于零信任不是一个蓝图，而更像是一种设计理念，因此有许多潜在的方法来实现零信任架构。作为服务网格和下一代访问控制（NGAC）技术的创始人和实施者，我们认为服务网格与 NGAC 相结合，为建立零信任架构网络提供了最佳基础。&lt;/p&gt;
&lt;p&gt;服务网格提供了你所需要的重要基元：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集中管理的策略授权&lt;/li&gt;
&lt;li&gt;分布式策略执行点——PEP 与资源访问点（RAP 共同部署）&lt;/li&gt;
&lt;li&gt;内置支持基于运行时身份而非网络位置的工作负载身份&lt;/li&gt;
&lt;li&gt;内置支持终端用户的应用级认证和授权，允许对网状结构中的每个应用进行全局和一致的策略执行&lt;/li&gt;
&lt;li&gt;对线上数据进行加密&lt;/li&gt;
&lt;li&gt;内置可观察性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网格提供了操作上的保证，你可以在部署认证和授权系统时使用网格，使它们更安全，更容易管理。我们可以很容易地用服务网格中的组件来重新绘制图一中所代表的 NIST 的逻辑架构。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图二&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图二&#34; srcset=&#34;
               /blog/zero-trust-architecture/008i3skNly1gpsrzq4xikj31da0u0acq_hu_aeae2c625b2b8e71.webp 400w,
               /blog/zero-trust-architecture/008i3skNly1gpsrzq4xikj31da0u0acq_hu_88b4f6fe4751220d.webp 760w,
               /blog/zero-trust-architecture/008i3skNly1gpsrzq4xikj31da0u0acq_hu_8889e79b2f5225aa.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/zero-trust-architecture/008i3skNly1gpsrzq4xikj31da0u0acq_hu_aeae2c625b2b8e71.webp&#34;
               width=&#34;760&#34;
               height=&#34;463&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图二
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;服务网格的透明性允许我们逐步采用，而不需要对你的安全基础设施和业务流程全面推倒重建。网格对应用程序、部署和安全问题的解耦意味着你可以开始在现有的基础设施上建立一个零信任的架构，而不扰乱你的业务流程和应用程序交付生命周期。&lt;/p&gt;
&lt;h2 id=&#34;案例研究美国国防部-platform-one&#34;&gt;案例研究——美国国防部 Platform One&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;老实说，我任务在没有服务网格的情况下无法获得任何有意义的成功；也许在 2018 年可以，但在 2020 年和这以后不可能。&amp;rdquo; ——美国空军首席软件官尼古拉斯·M·查兰（Nicolas M. Chaillan）。&lt;/p&gt;
&lt;p&gt;美国国防部在空军首席软件官 Nicolas M. Chaillan 的主持下，对其开发和运营软件的方式进行了革新。由 Chaillan 领导的在整个国防部发展 DevSecOps 实践的团队 Platform One，提供了多种企业服务，将 &amp;ldquo;自动化的软件工具、服务和标准带到国防部的项目中，使作战人员能够在安全、灵活的情况下创建、部署和操作软件应用。&lt;/p&gt;
&lt;p&gt;这些服务包括他们的 DevSecOps 平台（DSOP），这是一个经批准的、符合 CNCF 标准的 Kubernetes 发行版的集合，还有 Istio、基础设施即代码的手册和加固的容器。&lt;/p&gt;
&lt;p&gt;根据 Chaillan 的说法，&amp;ldquo;拥有一个集中的、由政府提供的、团队可以来使用的 DevSecOps 堆栈，这改变了游戏规则。&amp;ldquo;过去，软件更新周期长达数年，而现在国防部 &amp;ldquo;每天都在推送代码，一天推送多次&amp;hellip;&amp;hellip;每个项目的初始计划时间每 5 年平均节省 12 至 18 个月。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Istio 是他们架构的一个主要支柱，它提供了服务网格的能力，特别是它实现零信任模型的方式。当被问及为什么他们使用服务网格而不是仅使用入口控制器时，他不仅提到每个应用程序默认都有 mTLS 传输加密，而且 &amp;ldquo;一旦你转向微服务和容器，你必须管理东西向流量，这与南北向完全不同……你需要确保横向移动受到限制。你不希望一个坏人获得一个容器的访问权，并能够&amp;hellip;&amp;hellip;横向移动到其他容器。除了 SSO 和 mTLS，Platform One 的架构使用 Istio 来执行东西向白名单，并在容器之间提供策略执行点。&lt;/p&gt;
&lt;p&gt;该网格将策略执行从应用堆栈中剥离出来，并将其透明地转移到 sidecar 代理上。Platform One 能够将不同应用团队独立构建的多个 &amp;ldquo;雪花 &amp;ldquo;应用级 SSO 和加密实现整合为一个加固的单点登录和授权库，可供企业范围内所有应用使用。这就减轻了开发团队在每个应用中构建安全的负担。它还通过对单一的、经过严格审查的实施方案进行标准化，大大降低了漏洞风险。&lt;/p&gt;
&lt;p&gt;Chaillan 说，&amp;ldquo;如果你不使用服务网格，你最终不得不按语言、按微服务来做。而现在你是紧密耦合的。而且，比方说，在过去如果你想要更新加密位数，你就必须更新所有容器，而现在只需要更新服务网格中的 sidecar，现在你已经解耦了。仅此一点，就值得使用服务网格。”&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;周边安全模式及其渐进式的后继者过于脆弱和复杂，无法满足现代应用开发和部署的需要。现在应用程序的构建方式需要一个动态的、灵活的安全解决方案，一个既能集中管理又能普遍适用于所有应用程序开发团队的解决方案。零信任架构在网络和应用层面提供了急需的安全改进，而服务网格为实现零信任提供了最强大、动态和灵活的方式。&lt;/p&gt;
&lt;p&gt;在所有服务和所有应用之间部署全局管理的策略执行点，服务网格提供了插入零信任功能的模拟点，如 SSO、mTLS 和动态授权。通过在全局范围内将安全责任从单个应用程序抽离到服务网格，企业有可能逐步采用零信任原则，而无需重写应用程序或改变现有流程。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
