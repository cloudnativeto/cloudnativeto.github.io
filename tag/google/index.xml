<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>google | 云原生社区（中国）</title>
    <link>https://cloudnative.to/tag/google/</link>
      <atom:link href="https://cloudnative.to/tag/google/index.xml" rel="self" type="application/rss+xml" />
    <description>google</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Mon, 06 Mar 2023 12:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>google</title>
      <link>https://cloudnative.to/tag/google/</link>
    </image>
    
    <item>
      <title>Google 开源 Service Weaver——构建和部署分布式应用程序框架</title>
      <link>https://cloudnative.to/blog/introducing-service-weaver-framework-for-writing-distributed-applications/</link>
      <pubDate>Mon, 06 Mar 2023 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/introducing-service-weaver-framework-for-writing-distributed-applications/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;编者按：近日 Google 开源了一个名为 Service Weaver 的开源框架，它可以帮助开发者构建和部署分布式应用程序。Service Weaver 的特点是，它允许开发者以模块化单体的方式编写应用程序，然后使用自定义部署器将其部署为一组微服务。这样，开发者可以在不改变代码的情况下，灵活地调整应用程序的架构和性能。&lt;a href=&#34;https://opensource.googleblog.com/2023/03/introducing-service-weaver-framework-for-writing-distributed-applications.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google 开源博客&lt;/a&gt;介绍了该项目，并给出了开源地址：https://github.com/ServiceWeaver/weaver&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Service Weaver 是一个用于构建和部署分布式应用程序的开源框架&lt;/strong&gt;。Service Weaver 允许您将应用程序编写为&lt;strong&gt;模块化单体&lt;/strong&gt;，并将其部署为一组微服务。&lt;/p&gt;
&lt;p&gt;更具体地说，Service Weaver 由两个核心部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一组编程库，可让您将应用程序编写为单个&lt;strong&gt;模块化&lt;/strong&gt;二进制文件，仅使用本机数据结构和方法调用，以及&lt;/li&gt;
&lt;li&gt;一组部署器，可让您配置应用程序的运行时拓扑并将其部署为一组微服务，可以在本地或在您选择的云上部署。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-service-weaver-编程库从开发到执行的流程图将标记为-a-到-d-的四个模块从跨微服务级别的应用程序移动到标记为-desktopgoogle-cloud-和其他云的部署程序&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Service Weaver 编程库从开发到执行的流程图，将标记为 A 到 D 的四个模块从跨微服务级别的应用程序移动到标记为 Desktop、Google Cloud 和其他云的部署程序&#34; srcset=&#34;
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/1_huf4882d3c7ca30bb9e8058102f31d9c40_37319_0992182b7d182f578649ce9d3b3aeb23.webp 400w,
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/1_huf4882d3c7ca30bb9e8058102f31d9c40_37319_d804be9d4aa26207eadf33792d09c41f.webp 760w,
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/1_huf4882d3c7ca30bb9e8058102f31d9c40_37319_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/introducing-service-weaver-framework-for-writing-distributed-applications/1_huf4882d3c7ca30bb9e8058102f31d9c40_37319_0992182b7d182f578649ce9d3b3aeb23.webp&#34;
               width=&#34;760&#34;
               height=&#34;380&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Service Weaver 编程库从开发到执行的流程图，将标记为 A 到 D 的四个模块从跨微服务级别的应用程序移动到标记为 Desktop、Google Cloud 和其他云的部署程序
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过将应用程序编写过程与运行时考虑因素（例如应用程序如何拆分为微服务、使用何种数据序列化格式以及如何发现服务）分离，Service Weaver 旨在提高分布式应用程序开发速度和性能。&lt;/p&gt;
&lt;h3 id=&#34;构建-service-weaver-的动机&#34;&gt;构建 Service Weaver 的动机&lt;/h3&gt;
&lt;p&gt;在编写基于微服务的应用程序时，我们发现维护多个不同的微服务二进制文件（具有它们自己的配置文件、网络端点和可序列化数据格式）的开销大大降低了我们的开发速度。&lt;/p&gt;
&lt;p&gt;更重要的是，&lt;strong&gt;微服务严重影响我们进行跨二进制更改的能力&lt;/strong&gt;。使得我们不得不做一些事情，比如在每个二进制文件中标记新功能，仔细地改进我们的数据格式，并深入了解我们的上线过程。最后，拥有预定数量的特定微服务会有效地冻结我们的 API；它们变得如此难以更改，以至于将我们所有的更改都压缩到现有的 API 中而不是改进它们。&lt;/p&gt;
&lt;p&gt;因此，我们希望我们有一个单一的整体二进制文件来使用。单体二进制文件易于编写：它们仅使用语言原生类型和方法调用。它们也很容易更新：只需编辑源代码并重新部署。它们很容易在本地或虚拟机中运行：只需执行二进制文件即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service Weaver 是一个提供两全其美的框架：单体应用程序的开发速度，以及微服务的可扩展性、安全性和容错性。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;服务编织器概述&#34;&gt;服务编织器概述&lt;/h2&gt;
&lt;p&gt;Service Weaver 的核心思想是它的&lt;strong&gt;模块化单体&lt;/strong&gt;模型。您编写单个二进制文件，仅使用语言的原生数据结构和方法调用。您将二进制文件组织成一组称为组件的模块，它们是您的编程语言中的原生类型。例如，这是一个使用 Service Weaver 用 Go 语言编写的简单应用程序。它由一个 main() 函数和一个 Adder 组件组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Adder&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;adder&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;weaver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Implements&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Background&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;weaver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;weaver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;adder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行上述应用程序时，您可以进行简单的配置选择，即是将 Adder 组件放置在 main() 函数中还是单独放置。当 Adder 组件分离时，Service Weaver 框架自动将 Add 调用翻译成跨机 RPC；否则，Add 调用仍然是本地方法调用。&lt;/p&gt;
&lt;p&gt;要更改上述应用程序，例如向 Add 方法添加无限数量的参数，您所要做的就是更改 Add 的签名，更改其调用站点，然后重新部署您的应用程序。Service Weaver 确保新版本的 main() 只与新版本的 Adder 通信，无论它们是否位于同一位置。这种行为与使用语言原生数据结构和方法调用相结合，使您可以专注于编写应用程序逻辑，而不必担心部署拓扑和服务间通信（例如，代码中没有原型、存根或 RPC 通道）。&lt;/p&gt;
&lt;p&gt;当需要运行您的应用程序时，Service Weaver 允许您在任何地方运行它——在您的本地桌面环境或本地机器机架上，或在云中——而无需对您的应用程序代码进行任何更改。这种级别的可移植性是通过将关注点明确分离到 Service Weaver 框架中来实现的。一方面，我们有应用程序开发的编程框架。另一方面，我们有各种 &lt;strong&gt;deployer&lt;/strong&gt; 实现，每个部署环境一个。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-描述一次迭代中跨三个独立平台的-service-weaver-libraries-部署程序实施的流程图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;描述一次迭代中跨三个独立平台的 Service Weaver Libraries 部署程序实施的流程图&#34; srcset=&#34;
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/2_hu8d2fad478d5447f760431eccae81a4ae_35718_20533cbed71db134f0a916f475d3b8b0.webp 400w,
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/2_hu8d2fad478d5447f760431eccae81a4ae_35718_0622f3103db18aa88d3009d08290b4c5.webp 760w,
               /blog/introducing-service-weaver-framework-for-writing-distributed-applications/2_hu8d2fad478d5447f760431eccae81a4ae_35718_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/introducing-service-weaver-framework-for-writing-distributed-applications/2_hu8d2fad478d5447f760431eccae81a4ae_35718_20533cbed71db134f0a916f475d3b8b0.webp&#34;
               width=&#34;732&#34;
               height=&#34;265&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      描述一次迭代中跨三个独立平台的 Service Weaver Libraries 部署程序实施的流程图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种关注点分离允许您通过 go run 在单个进程中本地运行您的应用程序。或者通过 weaver gke deploy 在谷歌云上运行它；或者在其他平台上启用并运行它。在所有这些情况下，您无需修改或重新编译您的应用程序即可获得相同的应用程序行为。&lt;/p&gt;
&lt;h2 id=&#34;service-weaver-v01-中有什么&#34;&gt;Service Weaver v0.1 中有什么？&lt;/h2&gt;
&lt;p&gt;Service Weaver 的 v0.1 版本包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于编写应用程序的 核心&lt;a href=&#34;https://github.com/ServiceWeaver/weaver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go 库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;许多用于在&lt;a href=&#34;https://github.com/ServiceWeaver/weaver/tree/main/cmd/weaver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;本地&lt;/a&gt;或&lt;a href=&#34;https://github.com/ServiceWeaver/weaver-gke&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GKE 上&lt;/a&gt;运行您的应用程序的部署程序&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ServiceWeaver/weaver/tree/main/runtime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一组 API&lt;/a&gt;，允许您为任何其他平台编写自己的部署程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有库都是在 Apache 2.0 许可下发布的。请注意，在发布 v1.0 版之前， &lt;strong&gt;我们可能会引入重大更改&lt;/strong&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google Traffic Director 详细介绍</title>
      <link>https://cloudnative.to/blog/google-traffic-director-detail/</link>
      <pubDate>Thu, 09 May 2019 21:38:59 +0800</pubDate>
      <guid>https://cloudnative.to/blog/google-traffic-director-detail/</guid>
      <description>&lt;h2 id=&#34;traffic-director-介绍&#34;&gt;Traffic Director 介绍&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/google-traffic-director-logo.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Traffic Director 是 Google Cloud 推出的完全托管的服务网格流量控制平面。&lt;/p&gt;
&lt;p&gt;援引来自 Traffic Director 官方网站的介绍资料，Traffic Director 的定位是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Enterprise-ready traffic management for open service mesh.&lt;/p&gt;
&lt;p&gt;适用于开放式服务网格的企业级流量管理工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前 Traffic Director 还处于测试阶段，尚未 GA：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 2018 年 7 月的 Cloud Next‘18 大会上，Google Cloud 推出了 Traffic Director 的 alpha 版本&lt;/li&gt;
&lt;li&gt;在 2019 年 4 月的 Cloud Next‘19 大会上，Google Cloud 推出了 Traffic Director 的 beta 版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;traffic-director-推出的背景&#34;&gt;Traffic Director 推出的背景&lt;/h2&gt;
&lt;p&gt;在详细介绍 Traffic Director 的功能之前，我们先看一下 Traffic Director 推出的背景。由于 Traffic Director 刚推出不久，资料非常少，所以下面的内容有很多来自仅有的一点 Traffic Director 的演讲和官方文档。&lt;/p&gt;
&lt;p&gt;在 Cloud Next‘18 /19 介绍 Traffic Director 的演讲中，都谈到 Traffic Director 推出和下列两个趋势有关：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;微服务的普及和 Service Mesh 技术的兴起&lt;/li&gt;
&lt;li&gt;混合云和多云部署&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;从微服务到-service-mesh&#34;&gt;从微服务到 Service Mesh&lt;/h3&gt;
&lt;p&gt;近年来微服务架构大热，传统的单体应用按照微服务的理念进行拆分。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/microservices.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但是当应用从单个巨型单体拆分为数量大增的微服务之后，新的问题出现：如果高效的部署、连接、管理这些服务，并提供安全和监控能力？如果按照传统的侵入式微服务框架的思路，则开发人员就不得不在进行微服务改造时，承受微服务拆分带来的各种技术复杂度。&lt;/p&gt;
&lt;p&gt;但是，当将单体应用拆分到微服务时，客户关注的并不是微服务或者和微服务相关的各种技术，他们真正关注的是：微服务可以给他们带来什么。因此，必须要有一种解决方案，抽象并屏蔽掉微服务实现的技术细节。&lt;/p&gt;
&lt;p&gt;服务网格就是这样一种功能强大的抽象层，在微服务交付方面得到了越来越多的使用。其核心价值有两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Separates applications from app networking / 分离应用和网络&lt;/li&gt;
&lt;li&gt;Decouples operation from development / 解耦开发和运维&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;混合云和多云环境&#34;&gt;混合云和多云环境&lt;/h3&gt;
&lt;p&gt;考虑另一个趋势：在混合云和多云环境下部署和管理服务。客户可能使用公有云，如 GCP 或其他公有云，也可能混合使用私有云。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/multicloud.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这种场景下，该如何简化混合和多云服务的部署？Traffic Director 的思路是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引入 ServiceMesh 技术：通过 ServiceMesh 将通用的核心部分从服务中移除，典型如网络通信代码中的负载均衡，错误注入，失败恢复，流量管理，路由，安全等。&lt;/li&gt;
&lt;li&gt;托管：需要 ServiceMesh 来管理服务，但最好不要自己直接管理 ServiceMesh，而是使用提供托管的基础设施&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;控制平面与托管&#34;&gt;控制平面与托管&lt;/h3&gt;
&lt;p&gt;在服务网格中，服务网格数据平面与服务代理一起传输流量，而服务网格控制平面为这些服务代理提供政策、配置和智能建议：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/servicemesh.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Traffic Director 是 GCP 专为服务网格打造的完全托管式流量控制平面，其架构如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-global-lb/images/Traffic_Director_for_service_mesh.max-1200x1200.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;托管式服务的好处是有服务等级协议 (SLA) 的保障，下面是 Google Cloud 官方对此的声明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作为 Google 的一项托管式服务，Traffic Director 提供生产级 99.99% 可用性的 SLA：如果出现问题，收到通知并负责解决问题是我们的运营人员，而不是您的。您不必担心部署和管理控制平面，因而您的员工可以专注于发展业务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然目前 Traffic Director 还是 beta 测试阶段，上述 SLA 保障需要在 GA 之后才能提供。&lt;/p&gt;
&lt;p&gt;最后我们援引 Matt Klein（Envoy 作者）的这段致辞作为 Traffic Director 推出的背景总结，虽然这段话有做托的嫌疑：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Traffic Director 可以更加便捷地将 Envoy 和服务网格的优势运用到生产环境。由于 Envoy 提供通用型数据平面，Traffic Director 可提供具有开放接口的完全托管式流量控制平面，避免锁定于某一种产品。Traffic Director 的 SLA、全球负载平衡和丰富的流量控制措施可帮助企业和云原生最终用户减少流量管理工作。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里列出的功能我们后面会详细解析，重点看”开放接口”/“避免锁定”这两个关键词：这可以说是 Google 乃至整个 CNCF/Cloud Native 社区一直念念不忘反复提醒的关键字，极其强调标准接口和避免供应商绑定。&lt;/p&gt;
&lt;p&gt;与此对应的是，Traffic Director 采用了开放的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xDS v2 API&lt;/a&gt; 与数据平面中的服务代理进行通信。xDS v2 API 来自 Envoy，目前已经成为 Service Mesh 的事实 API 标准。Traffic Director 通过采用 xDS v2 API 这样的开发 API 实现了其倡导的避免绑定。&lt;/p&gt;
&lt;h2 id=&#34;traffic-director-的功能&#34;&gt;Traffic Director 的功能&lt;/h2&gt;
&lt;h3 id=&#34;全局负载均衡&#34;&gt;全局负载均衡&lt;/h3&gt;
&lt;p&gt;这个功能是 Traffic Director 在各种演讲和介绍中强调的最多的功能，其官方介绍为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Traffic Director 将服务作为虚拟机或容器部署在多个区域中来保证它正常运行，并使用 Traffic Director 通过自动化的跨区域溢出和故障转移来提供全局负载均衡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“作为虚拟机或容器”我们在下一节展开，先看看 Traffic Director 提供的全局负载均衡是什么。&lt;/p&gt;
&lt;p&gt;这是 Traffic Director 官方给出的示例，图中的三个服务分别部署在两个不同的区域。在 Traffic Director 的控制下，流量按照就近原则被发送到具有可用容量的最近的服务实例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-global_load_balancingmax-1400x1400&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-global-lb/images/Global_load_balancing.max-1400x1400.png&#34; alt=&#34;Global_load_balancing.max-1400x1400&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Global_load_balancing.max-1400x1400
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;故障转移是指，如果最接近客户端服务的实例已关闭或过载，则 Traffic Director 会控制流量无缝转移到下一个最近区域中的健康实例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-traffic_director_intelligencemax-1400x1400&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-global-lb/images/Traffic_Director_intelligence.max-1400x1400.png&#34; alt=&#34;Traffic_Director_intelligence.max-1400x1400&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Traffic_Director_intelligence.max-1400x1400
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;跨区域溢出则是指当流量超出当前区域部署的实例的承受能力之后，会突破就近路由的原则，将部分流量导流到其他区域。这背后的逻辑是：就近路由的收益的是本地访问的低网络延迟，在流量突发时，宁可牺牲延迟也要将流量引导到其他区域以保证可用性。&lt;/p&gt;
&lt;p&gt;下面这个动画可以更生动的展示上述描述的”全局负载均衡”/“故障转移”和”跨区域溢出”的功能：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/Traffic_Director_for_open_service_mesh.gif&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;适用于虚拟机和容器&#34;&gt;适用于虚拟机和容器&lt;/h3&gt;
&lt;p&gt;在上面的示例中，提到”Traffic Director 将服务作为虚拟机或容器部署在多个区域中”，这是 Traffic Director 重点强调的另外一个重要功能：支持虚拟机和容器，而且支持混合使用。&lt;/p&gt;
&lt;p&gt;下面这张图片强调了服务部署的多样性：三个服务分别是自己管理的 docker 服务 / 基于虚拟机的服务 / 部署在 GKE 的服务。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/mixed-service.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Traffic Director 官方文档给出的解释是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“按您的节奏进行现代化改造”&lt;/p&gt;
&lt;p&gt;Traffic Director 既适用于基于虚拟机 (Compute Engine) 的应用，也适用于容器化应用（Google Kubernetes Engine 或自行管理的 Kubernetes），并可以增量方式逐步应用于您的服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这背后的考虑是：service mesh 和 k8s 的普及，不会一蹴而就，基于虚拟机的服务会长期存在，因此提供对基于虚拟机服务的支持和打通与容器服务的交互访问就至关重要。这个思路同样出现在 AWS 的 app mesh 产品中，app mesh 也是强调同时支持 VM 服务和容器服务。&lt;/p&gt;
&lt;p&gt;Service Mesh 技术的典型使用场景是运行和管理已经拆解为微服务并按照云原生理念开发的服务，但是考虑到大量遗留应用存在的现实，Traffic Director 通过支持 VM 服务，可以为这些非云原生服务引入高级功能。这个做法在我们之前的介绍中，被戏称为”先上车再买票”，即在不做应用大规模改造的前提下先体现享受 Service Mesh 带来的部分红利，再慢慢逐步和分批做应用改造。&lt;/p&gt;
&lt;p&gt;注意：在 Traffic Director 的支持中，基于虚拟机的服务和基于容器的服务采用一致的流量管理功能，两者并没有功能上的差别。&lt;/p&gt;
&lt;h3 id=&#34;混合云和多云支持&#34;&gt;混合云和多云支持&lt;/h3&gt;
&lt;p&gt;最近看到 Google Cloud 提出要”All in Hybird Cloud”，在这个大背景下，Traffic Director 提供对混合云和多云环境的支持：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/hybird-multicloud.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是完整的应用改造示意，从原有在私有环境下运行的单体应用，转换到在公有云和私有云上的 service mesh 中运行的多个微服务：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/hybird-support.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;集中式健康检查&#34;&gt;集中式健康检查&lt;/h3&gt;
&lt;p&gt;Traffic Director 官方文档对集中式健康检查给出的介绍是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大规模执行运行状况检查&lt;/p&gt;
&lt;p&gt;Traffic Director 通过 GCP 进行大规模运行状况检查。因此，运行状况检查从 Envoy/服务代理分流到 Google 的弹性系统，这样您就可以对各种规模的部署进行大规模运行状况检查。另外，您的实例本身不会因网格规模的运行状况检查而不堪重负。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解释一下这里所说的”因网格规模的运行状况检查而不堪重负”：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大型服务网格会生成大量的健康检查流量，因为每个 sidecar 代理都必须对服务网格中的所有服务实例进行健康检查。随着网格的增长，让每个客户端代理健康检查每个服务器实例，这种做法会产生一个 n^2 健康检查问题，这将成为增长和扩展部署的障碍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Traffic Director 对此给出的解决方案是提供集中式健康检查，Traffic Director 会提供一个全局分布的弹性系统监控所有服务实例。然后，Traffic Director 使用 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/eds.proto#envoy-api-file-envoy-api-v2-eds-proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EDS API&lt;/a&gt; 将聚合的健康检查结果分发到全局网格中的所有代理。如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/health-check.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这样 Proxy 就不需要自行实现健康检测，只要接受 EDS 更新即可（当然客户端被动健康检测还是需要的，当发生无法连接等错误时还是需要处理的）。&lt;/p&gt;
&lt;p&gt;这里 Traffic Director 的做法和 Istio 的标准做法是很类似的，Istio 在 k8s 上部署时，是依赖 k8s 的探测机制来做服务的探活的。Traffic Director 的 health check 机制没有找到详细的介绍资料，暂时不清楚具体的机制，Traffic Director 的介绍中只是提到这个功能是由 GCP 统一提供。&lt;/p&gt;
&lt;p&gt;集中式健康检查这个功能也算是一个卖点，毕竟，虽然 Envoy 自带健康检测机制，但是如果由客户端来实现健康检测，的确是需要每个客户端都检查所有其他服务，连接太多，请求太多，而且随着服务数量和实例数量的增加，健康检测的开销会直线上涨。由平台/基础设施/云等来统一提供集中式健康检查，再通过 xDS/EDS API 下发结果应该会是一个通用的做法。&lt;/p&gt;
&lt;h3 id=&#34;流量控制&#34;&gt;流量控制&lt;/h3&gt;
&lt;p&gt;Traffic Director 目前提供流量控制功能，包括流量路由和策略执行。官方文档的介绍描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过请求路由和丰富的流量政策进行流量控制（Alpha 版）&lt;/p&gt;
&lt;p&gt;Traffic Director 支持高级请求路由功能，如流量拆分、启用 Canary 更新等用例、网址重写/重定向、故障注入、流量镜像，以及基于各种标头值的高级路由功能，包括 Cookie。此外，Traffic Director 还支持许多高级流量政策，包括多种负载平衡方案、熔断和后端异常检测。&lt;/p&gt;
&lt;p&gt;您可以使用 Traffic Director 轻松部署一切功能：从简单的负载平衡，到请求路由和基于百分比的流量拆分等高级功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从最新的 Traffic Director 的介绍 PPT 上看到，Traffic Director 的流量控制功能包含两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Routing Rules&lt;/strong&gt;：定义请求如何路由到网格中的服务
&lt;ul&gt;
&lt;li&gt;Traffic splitting&lt;/li&gt;
&lt;li&gt;Traffic steering&lt;/li&gt;
&lt;li&gt;Timeouts and retries&lt;/li&gt;
&lt;li&gt;Fault Injection&lt;/li&gt;
&lt;li&gt;Mirroring&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Traffic Policies&lt;/strong&gt;：用于服务的路由相关策略
&lt;ul&gt;
&lt;li&gt;Load balancing schemes.&lt;/li&gt;
&lt;li&gt;Outlier detection.&lt;/li&gt;
&lt;li&gt;Circuit breakers&lt;/li&gt;
&lt;li&gt;Timeouts&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;熟悉 Istio API 和 Envoy xDS API 的同学就会发现这些功能非常眼熟，基本上和 Istio / Envoy 提供的功能相同。&lt;/p&gt;
&lt;p&gt;和包括 Istio 在内的所有 Service Mesh 产品一致，Traffic Director 也在强调说这些功能都是可以在不修改应用代码的前提下获得，这是理所当然的重要卖点。&lt;/p&gt;
&lt;p&gt;但是注意：目前这些功能都还是 alpha 阶段，因此支持度应该不会像 Istio 那么齐全。&lt;/p&gt;
&lt;p&gt;我们快速过一下目前提供的功能（图片来自 Google Traffic Director 的演讲 PPT）：&lt;/p&gt;
&lt;p&gt;Traffic Splitting/流量拆分，支持百分比拆分，这是 version based routing，用于实现金丝雀发布/蓝绿部署/AB 测试等：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/traffic-splitting.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Traffic Steering，这是 content based routing，支持 Host / Path / Header 匹配：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/traffic-steering.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在匹配完成之后，除了做流量拆分之外，还可以由其他的功能，如错误注入。Traffic Director 支持的错误注入同样有 Delay 和 Abort 两种：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/fault-injection.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;熔断和异常检测，支持每服务配置，具体的配置方式也和 Istio / Envoy 差不多。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/circuit-breakers.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;流量镜像功能，也称为影子流量。流量会复制一份发送给接受镜像流量的服务，Traffic Director 的实现会在发送给镜像服务的请求的 Host/Authority header 中增加一个“-shadow”后缀。镜像请求是发出去就不管的，无视应答，和 Istio 的处理方式一致。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/traffic-mirror.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;总结：在流量控制这块功能上，Traffic Director 除了因为是 alpha 版本，可能功能支持不够齐全之外，基本和 Istio / Envoy 是一致的。考虑到 Traffic Director 支持 xDS V2 API，和目前只支持 Envoy（理论上兼容任何支持 xDS v2 的代理，但是实际只测试过 Envoy）的现状，Traffic Director 在流量控制上和 Istio / Envoy 高度一致也就非常容易理解。&lt;/p&gt;
&lt;p&gt;需要特别指出的是：目前 beta 版本的 Traffic Director 只支持用 GCP 的 API 来设置流量控制的规则，目前还不支持直接使用 Istio 的 API（CRD）。但是，预计未来将提供支持，从 Roadmap 上也看到有和 Istio 集成的规划。&lt;/p&gt;
&lt;h3 id=&#34;基于流量的自动伸缩&#34;&gt;基于流量的自动伸缩&lt;/h3&gt;
&lt;p&gt;Traffic Director 前面支持的功能，基本都有不出意外的感觉，毕竟熟悉 Istio/Envoy 体系的同学对这些功能都了如指掌。而 自动伸缩这个功能是一个特例。&lt;/p&gt;
&lt;p&gt;援引 Traffic Director 官方文档对此功能的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据您的服务规模智能快速进行地自动扩缩&lt;/p&gt;
&lt;p&gt;Traffic Director 可根据您的需求自动扩缩，您只需按实际用量付费，并且快速智能地进行扩容，无需联系云服务提供商也不必进行任何预热。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到这段描述，第一反应是：这不是 serverless 吗？按需伸缩，按使用付费。&lt;/p&gt;
&lt;p&gt;Traffic Director 在提供标准的 service mesh 功能的同时，也引入了 serverless 的特性。下面是 Traffic Director 中自动伸缩功能的实现方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Traffic Director 根据代理向其报告的负载信号启用自动伸缩。Traffic Director 通知 Compute Engine autoscaler 流量变化，并让 autoscaler 一次性增长到所需的大小（而不是像其他 autoscaler 那样重复步骤），从而减少 autoscaler 对流量峰值做出反应所需的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自动伸缩的功能不仅仅可以用于常规的按照请求流量进行扩容和缩容，也支持某些特殊场景，如前面在介绍全局负载均衡时提到的：如果最接近客户端服务的实例已关闭或过载，则 Traffic Director 会控制流量无缝转移到下一个最近区域中的健康实例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-traffic_director_intelligencemax-1400x1400&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-global-lb/images/Traffic_Director_intelligence.max-1400x1400.png&#34; alt=&#34;Traffic_Director_intelligence.max-1400x1400&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Traffic_Director_intelligence.max-1400x1400
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此时由于原来两个区域的流量都进入了一个区域的 Shopping Car 服务，可能出现流量超出当前承受能力的情况，此时 Traffic Director 会指示 Compute Engine autoscaler 增加 Shopping Car 服务的容量。同理，Payments 服务的容量也会随之增加。&lt;/p&gt;
&lt;p&gt;按照 Google Cloud 官方博客文章的介绍，Traffic Director 在这块的处理非常的复杂而智能：在新增加的容量生效之前，Traffic Director 会暂时将流量重定向到其他可用实例 - 即使在其他区域也是如此。（也就是前面所说的跨区域溢出，其指导原则是可用性目标高于低延迟目标）一旦 autoscaler 增加了足够的工作负载容量以维持峰值，Traffic Director 就会将流量移回最近的 zone 和 region，再次优化流量分配以最小化每个请求的 RTT。&lt;/p&gt;
&lt;p&gt;从这里可以看到，Traffic Director 结合使用了 Service Mesh 的路由控制能力和 Serverless 的按需自动伸缩的资源调度能力，在故障处理和自动运维上表现非常突出。&lt;/p&gt;
&lt;p&gt;可以说，Traffic Director 在 servicemesh 和 serverless 整合的道路上迈出了重要的一步。这是一个非常有创新的想法，值得借鉴和学习。&lt;/p&gt;
&lt;h3 id=&#34;功能限制&#34;&gt;功能限制&lt;/h3&gt;
&lt;p&gt;Traffic Director 官方文档中列出了一些目前的功能限制，这里摘录其中比较重要的部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Beta 版本的 Traffic Director 仅支持 GCP API。Beta 版本的 Traffic Director 不支持 Istio API。&lt;/li&gt;
&lt;li&gt;Traffic Director 仅支持 HTTP 流量。&lt;/li&gt;
&lt;li&gt;Traffic Director 流量控制功能是 Alpha 状态。&lt;/li&gt;
&lt;li&gt;本文档讨论了 Envoy 代理，但您可以将任何 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开放标准 API（xDS v2）代理&lt;/a&gt; 与 Traffic Director 一起使用。但请注意，Google 仅使用 Envoy 代理测试了 Traffic Director。在此测试期间，Traffic Director 仅支持 Envoy 版本 1.9.1 或更高版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;和-istio-的关系&#34;&gt;和 Istio 的关系&lt;/h2&gt;
&lt;p&gt;在了解 Traffic Director 之后，相信很多人会和我一样有同样的问题：Traffic Director 和 Istio 到底有什么关系？&lt;/p&gt;
&lt;p&gt;简单介绍 Istio：Istio 提供控制平面来保护，连接和监控微服务。它有三个组成部分：Pilot 负责流量管理，Mixer 负责可观察性，Istio Security（Citadel）负责服务到服务的安全性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/istio.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Traffic Director 和 Istio 的基本区别在于，Istio 是一个开源产品，而 Traffic Director 是一个完全托管的服务。&lt;/p&gt;
&lt;p&gt;在具体的功能模块上，Traffic Director 将取代 Pilot 的位置：所有 Pilot 能提供的功能，Traffic Director 都将提供。这也是采用 open xDS v2 API 的原因，以便在开源的 Pilot 和 Traffic Director 之间切换。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/pilot-replace.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;总结说：Traffic Director 提供了 GCP 托管的 Pilot，以及全局负载均衡和集中式健康检查等其他功能。&lt;/p&gt;
&lt;p&gt;但请注意，当前 Traffic Director Beta 版本还无法使用 Istio API 配置 Traffic Director，暂时只能使用 GCP API 进行配置。&lt;/p&gt;
&lt;p&gt;在 Sidecar 的注入上，Istio 支持自动注入，而 Traffic Director 目前需要手工注入 Sidecar，不过未来 Traffic Director 应该会支持自动注入，毕竟这个功能实现上并不复杂。&lt;/p&gt;
&lt;p&gt;Traffic Director 的 Roadmap 中，有和 Istio 进一步集成的计划，从下图上看是准备引入 Istio Security（Citadel），以提供安全特性如 mTLS，RBAC 等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/istio-integration.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;暂时未看到有引入 Mixer 的信息。&lt;/p&gt;
&lt;h2 id=&#34;traffic-director-roadmap&#34;&gt;Traffic Director Roadmap&lt;/h2&gt;
&lt;p&gt;援引最新 Traffic Director 介绍的 PPT，Traffic Director 的 Roadmap 中未来准备加入以下内容：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/roadmap.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安全方面的集成，要支持 mTLS/RBAC，看前面的图片是打算引入Istio Security（Citadel）模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可观测性集成：按说是 Istio Mixer 模块，但是没见到介绍，怀疑是不是因为 Mixer 在性能上的拙劣表现，导致 Traffic Director 可能采用其他方案，后续关注。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hybird/Multi-cloud支持&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 Istio API 来进行控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和其他控制平面组建联邦&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://skyao.io/post/201905-google-traffic-director-detail/images/federation.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;traffic-director-分析&#34;&gt;Traffic Director 分析&lt;/h2&gt;
&lt;p&gt;从前面的功能介绍中可以看到，Traffic Director 的重要卖点和特色在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对混合云/多云的支持&lt;/li&gt;
&lt;li&gt;对 VM 服务（或者说非云原生服务）的支持&lt;/li&gt;
&lt;li&gt;整合了 serverless 的部分特性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他功能不是说不重要，而是相对来说比较常规化，即托管的服务网格理论上说应该都会提供这些功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全托管，无需运维，GA 后提供 SLA 保证&lt;/li&gt;
&lt;li&gt;流量管理（包括路由和策略）/安全/可观测性&lt;/li&gt;
&lt;li&gt;全局负载均衡&lt;/li&gt;
&lt;li&gt;集中式健康检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从产品定位上说，Traffic Director 只提供控制平面，对于数据平面理论上只要兼容 xDS v2 API 即可，也就是说 Traffic Director 完全关注在控制平面，前面列出来的几个重要的卖点也都属于控制平面的创新和深耕，和数据平面关系不大，或者说数据平面只需简单的提供底层支持。从这点上看，和 Istio 专注在控制平面，而将数据平面完全委托给 Envoy 的做法可谓一脉相承。&lt;/p&gt;
&lt;p&gt;在 API 的选择上，Traffic Director 的做法是支持开放的 xDS v2 API，以及计划中的通过 Istio API 来进行配置。一方面在产品层面上和开源的 Envoy/Istio 保持一致，另一方面也通过这种方式实现了其一直宣传的不锁定的目标，对于市场宣传和争取客户应该是有利的，也有助于实现混合云和多云战略。&lt;/p&gt;
&lt;p&gt;目前 Traffic Director 还处于 beta 测试阶段，尤其流量配置更是还在 alpha 阶段，产品的成熟度还不够高，roadmap 中也还有很多非常重要甚至急迫（如可观测性）的内容有待完成。因此不适合对 Traffic Director 过早的做判断和评论，我的观点是 Traffic Director 代表的产品方向应该是非常有前途，可以给客户带来实际价值。这是 Google 在 ServiceMesh 领域（甚至是 Serverless 领域）新的探索和尝试，期望有好的结果。&lt;/p&gt;
&lt;p&gt;对 Traffic Director 的理解，我的观点是不能单独的只看 Traffic Director 这一个产品，而是要结合近期 Google 陆续推出的几个相关产品：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google Cloud Service Mesh：ServiceMesh 产品，简单理解为 Istio 的 GCP 托管版本（猜测可能是兼容 Istio API的内部实现/扩展版本），探索方向为在公有云上提供 Service Mesh 托管服务&lt;/li&gt;
&lt;li&gt;Google Cloud Run：Serverless 产品，简单理解为 knative 的 GCP 托管版本（猜测依然可能是兼容 Knative API的内部实现/扩展版本），探索方向为在公有云上提供 Serverless 托管服务&lt;/li&gt;
&lt;li&gt;Anthos：Hybird/Multi-Cloud 产品，号称业界”第一个真正的混合和多云平台”，探索方向为 Google 宣称要“All in”的混合云市场&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后再来看，作为托管版 Service Mesh 控制平台而推出 Traffic Director 产品，我们前面列出的三个卖点和特色：对混合云/多云的支持；对 VM 服务（或者说非云原生服务）的支持；整合 serverless 的部分特性。和这三个新产品可谓交相呼应。&lt;/p&gt;
&lt;p&gt;摘录两句从最近的 Google Cloud Next 大会信息中看到的话，是不是更有体会？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Write once, Run Anywhere/一次写好，哪都能跑&lt;/li&gt;
&lt;li&gt;Use open-source technology easily and in a cloud-native way / 以云原生的方式，轻松使用开源技术&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Google / Google Cloud 在下一盘很大的棋，一盘围绕云和云原生的大棋：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以云为战场，以 kubernetes 为根据地，以开源开放不锁定为口号，以云原生为旗帜，以 ServiceMesh 和 Serviceless 为桥梁连接起应用和基础设施，以混合云为突破口……剑指当前云计算市场排名第一/第二的 AWS/Azure。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;Traffic Director 目前能找到的资料不多，基本都是 Google Cloud放出来的新闻稿/博客和官方文档，还有两次cloud next 大会上的介绍演讲及 PPT。第三方的介绍文章非常的少，因此在调研和整理资料时不得不大量引用来自 Traffic Director 官方渠道的资料和图片。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/traffic-director/docs/traffic-director-concepts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traffic Director concepts&lt;/a&gt;: Google Cloud 上的 Traffic Director 官方文档&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/blog/products/networking/traffic-director-global-traffic-management-for-open-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud networking in depth: How Traffic Director provides global load balancing for open service mesh&lt;/a&gt;：来自 Google Cloud 网站的官方博客文章，发表时间为 2019-04-18&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/cloudzone/google-clouds-traffic-director-what-is-it-and-how-is-it-related-to-the-istio-service-mesh-c199acc64a6d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud’s Traffic Director — What is it and how is it related to the Istio service-mesh?&lt;/a&gt;：来自 Medium 网站的博客文章，原作者为 &lt;a href=&#34;https://medium.com/@iftachsc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Iftach Schonbaum&lt;/a&gt;，发表时间 2019-04-16&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.com/news/2019/04/google-traffic-director&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introducing Traffic Director: Google’s Service Mesh Control Plane&lt;/a&gt;：来自 InfoQ 网站的文章，发布时间 2019-04-25&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=FUITCYMCEhU&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traffic Director &amp;amp; Envoy-Based L7 ILB for Production-Grade Service Mesh &amp;amp; Istio&lt;/a&gt;: Google 在 Cloud Next‘19 大会上的主题演讲，发表时间 2019-04-10（本文的很多图片摘录自这个演讲的 ppt）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?time_continue=2759&amp;amp;v=4U4X_OzJaNY&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hybrid and Open Services with GCP, Envoy and Istio: A Talk with Google and Lyft &lt;/a&gt;: Google 在 Cloud Next‘18 大会上的主题演讲，发表时间 2018-07-26&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
