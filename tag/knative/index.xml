<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Knative | 云原生社区（中国）</title>
    <link>https://cloudnative.to/tag/knative/</link>
      <atom:link href="https://cloudnative.to/tag/knative/index.xml" rel="self" type="application/rss+xml" />
    <description>Knative</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Mon, 08 Nov 2021 06:37:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>Knative</title>
      <link>https://cloudnative.to/tag/knative/</link>
    </image>
    
    <item>
      <title>Knative 1.0 发布了！</title>
      <link>https://cloudnative.to/blog/knative-1-0-ga/</link>
      <pubDate>Mon, 08 Nov 2021 06:37:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/knative-1-0-ga/</guid>
      <description>&lt;p&gt;作者：&lt;a href=&#34;https://twitter.com/csantanapr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Carlos Santana &lt;/a&gt;(IBM)、&lt;a href=&#34;https://twitter.com/omer_bensaadon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Omer Bensaadon &lt;/a&gt;(VMware)、&lt;a href=&#34;https://twitter.com/marianarra_&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maria Cruz &lt;/a&gt;(Google)，原文发布于 &lt;a href=&#34;https://knative.dev/blog/articles/knative-1.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative 官方博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;今天我们发布了 Knative 1.0，达到了一个重要的里程碑，这要归功于 600 多名开发者的贡献和合作。Knative 项目是由谷歌在 2018 年 7 月发布的，并与 VMWare、IBM、Red Hat 和 SAP 紧密合作开发的。在过去 3 年中，Knative 已经成为 &lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2020/11/CNCF_Survey_Report_2020.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 上最广泛安装的无服务器层&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;最新动态&#34;&gt;最新动态&lt;/h2&gt;
&lt;p&gt;如果你没有密切关注 Knative 的发展，自从我们在 2018 年 7 月首次发布以来，已经有很多变化。&lt;/p&gt;
&lt;p&gt;除了无数的错误修复、稳定性和性能增强之外，我们的社区还按时间顺序进行了以下改进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持多个 HTTP 路由层（包括 Istio、Contour、Kourier 和 Ambassador）&lt;/li&gt;
&lt;li&gt;支持多个存储层的事件概念与常见的订阅方法（包括 Kafka、GCP PubSub 和 RabbitMQ）&lt;/li&gt;
&lt;li&gt;“鸭子类型 &amp;quot; 的抽象，允许处理具有共同字段（如 status.conditions 和 status.address）的任意 Kubernetes 资源&lt;/li&gt;
&lt;li&gt;支持额外功能插件的&lt;a href=&#34;https://knative.dev/docs/client/install-kn/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;命令行客户端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;6 周一次的定期发布流程&lt;/li&gt;
&lt;li&gt;支持 HTTP/2、gRPC 和 WebSockets&lt;/li&gt;
&lt;li&gt;Broker 和触发器，以简化事件的发布和订阅，同时将生产者和消费者解耦&lt;/li&gt;
&lt;li&gt;支持事件组件向非 Knative 组件传递，包括集群外组件或主机上的特定 URL&lt;/li&gt;
&lt;li&gt;支持自动提供 TLS 证书（通过 DNS 或 HTTP01 挑战）&lt;/li&gt;
&lt;li&gt;为活动目的地定制交付选项，包括对无法交付的信息进行重试和 dead-letter 排队&lt;/li&gt;
&lt;li&gt;对 Broker 和 Channel 的事件追踪支持，以改善调试工作&lt;/li&gt;
&lt;li&gt;由 Knative Build 催生的 &lt;a href=&#34;https://tekton.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tekton 项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;并行和序列组件，用于编纂某些复合事件的工作流程&lt;/li&gt;
&lt;li&gt;事件源的文档以及如何贡献说明，目前涵盖了大约 40 个不同的事件源&lt;/li&gt;
&lt;li&gt;“Hitless&amp;quot; 的升级，在小版本发布之间没有放弃的请求&lt;/li&gt;
&lt;li&gt;重新设计服务的 API，以匹配部署、CronJob 等使用的 PodTemplateSpec，以简化 Kubernetes 用户的使用&lt;/li&gt;
&lt;li&gt;支持将事件目的地地址注入 PodTemplateSpec 的对象中&lt;/li&gt;
&lt;li&gt;支持基于并发量或 RPS 的水平 Pod 自动扩展&lt;/li&gt;
&lt;li&gt;使用领导者选举片的控制平面组件的高可用性&lt;/li&gt;
&lt;li&gt;一个帮助管理员安装 Knative 的 Operator&lt;/li&gt;
&lt;li&gt;快速入门，供开发者在本地试用 Knative&lt;/li&gt;
&lt;li&gt;使用 DomainMapping 简化服务的管理和发布&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10-意味着什么&#34;&gt;1.0 意味着什么？&lt;/h2&gt;
&lt;p&gt;Knative 是由许多组件组成的，这些组件的版本是一起分布的。这些组件有不同的成熟度，从“实验性 &amp;quot; 到“已经 GA”(Generally Available)。我们仍然希望保持版本的同步，因此决定将所有的组件转移到 1.0 版本。GA 级别会单独标记组件。&lt;/p&gt;
&lt;h3 id=&#34;为什么要一次把所有的组件移到-10&#34;&gt;为什么要一次把所有的组件移到 1.0？&lt;/h3&gt;
&lt;p&gt;两个原因：一个是面向用户的，一个是面向贡献者的。主要是面向用户的原因是，它给用户提供了一个单一的数字，让他们在了解他们所安装的东西和哪些东西可以一起使用时，可以挂在上面。次要的面向贡献者的原因是，我们所有的基础设施都是为了管理一个单一的版本号而设计的，更新它以支持多个版本号似乎不是很好地利用时间。&lt;/p&gt;
&lt;h3 id=&#34;一个组件既是10-又是beta岂不是很混乱吗&#34;&gt;一个组件既是“1.0&amp;quot; 又是“Beta”岂不是很混乱吗？&lt;/h3&gt;
&lt;p&gt;除非我们等待与 Knative 有关的所有事情都完成，否则我们总会有一些组件或功能处于 alpha 或 beta 状态。虽然这种情况有时会沿着组件的边界发生，但它也可能发生在一个组件内部，所以版本号不能作为“GA 与否 &amp;quot; 的唯一指标。(这种情况也发生在其他项目上，如 Kubernetes，以及 Serving 或 Eventing 中的特定功能）。&lt;/p&gt;
&lt;p&gt;展望未来，该项目将清楚地了解各种组件或功能的成熟度，并将功能沿着 GA 或退役的路线移动。&lt;/p&gt;
&lt;h2 id=&#34;了解更多&#34;&gt;了解更多&lt;/h2&gt;
&lt;p&gt;Knative 指导委员会成员 Ville Aikas 是&lt;a href=&#34;https://kubernetespodcast.com/episode/166-knative-1.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;本周谷歌 Kubernetes 播客的嘉宾&lt;/a&gt;，他讲述了该项目创建的故事以及它的 1.0 之旅。你也可以参加 &lt;a href=&#34;https://calendar.google.com/calendar/u/0/r/eventedit/NnAycjJyZmdlMTF1b2FuOGJzZjZ1dXA0aTZfMjAyMTExMjRUMTczMDAwWiBrbmF0aXZlLnRlYW1fOXE4M2JnMDdxczViOXJyc2xwNWpvcjRsNnNAZw?tab=mc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;11 月 17 日的 Knative 社区聚会&lt;/a&gt;，届时 Ville 将谈论项目的最新变化。&lt;/p&gt;
&lt;h2 id=&#34;参与其中&#34;&gt;参与其中&lt;/h2&gt;
&lt;p&gt;Knative 社区随时欢迎新成员的加入。&lt;a href=&#34;https://slack.knative.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;加入 Knative Slack 空间&lt;/a&gt;，在熟悉项目的过程中提出问题并排除故障。最后，在 Knative 网站上找到所有的&lt;a href=&#34;https://knative.dev/docs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;项目文档&lt;/a&gt;，并&lt;a href=&#34;https://github.com/knative&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 GitHub 上为该项目做出贡献&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;感谢我们的贡献者&#34;&gt;感谢我们的贡献者&lt;/h2&gt;
&lt;p&gt;实现这一里程碑确实是一个社区的努力–我们不能不感谢一些帮助我们走到今天的人。感谢…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持 Knative 的公司，包括：
&lt;ul&gt;
&lt;li&gt;谷歌（他们还赞助了我们的网站和测试基础设施，并每月举办社区聚会）&lt;/li&gt;
&lt;li&gt;IBM&lt;/li&gt;
&lt;li&gt;红帽&lt;/li&gt;
&lt;li&gt;SAP&lt;/li&gt;
&lt;li&gt;TriggerMesh&lt;/li&gt;
&lt;li&gt;VMWare&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://knative.teststats.cncf.io/d/5/companies-table?orgId=1&amp;amp;var-period_name=Last_decade&amp;amp;var-metric=contributions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以及更多&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;我们的&lt;a href=&#34;https://github.com/knative/community/blob/main/TECH-OVERSIGHT-COMMITTEE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;技术监督委员会&lt;/a&gt;、&lt;a href=&#34;https://github.com/knative/community/blob/main/STEERING-COMMITTEE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;指导委员会&lt;/a&gt;和&lt;a href=&#34;https://github.com/knative/community/blob/main/TRADEMARK-COMMITTEE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;商标委员会&lt;/a&gt;的成员&lt;/li&gt;
&lt;li&gt;所有 Knative 的贡献者，过去和现在的&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>使用 Knative 作为 API 聚合层的实践</title>
      <link>https://cloudnative.to/blog/using-knative-as-api-aggregator-layer/</link>
      <pubDate>Fri, 23 Aug 2019 16:43:58 +0800</pubDate>
      <guid>https://cloudnative.to/blog/using-knative-as-api-aggregator-layer/</guid>
      <description>&lt;img src=&#34;./img/knative-logo-cmyk.png&#34; width=&#34;250&#34; height=&#34;200&#34; &gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 2019 年的今天，微服务这个词相信对于绝大多数的开发者都已经不再陌生。时至今日，非常多的项目都逐渐开始实践起微服务这一设计思想，将原本的磐石应用逐渐按照领域模型切分成一个个小的服务，对于微服务的实践也日渐趋向于成熟。在笔者目前工作的业务实践中，同样也使用着微服务作为后端服务的架构设立思想，微服务为我们的代码管理与项目管理带来了非常大的简便性。然而随着需求的迭代与代码的日益积累，曾经泾渭分明、代码精简的各个微服务也逐渐开始变得逻辑复杂、代码冗余，同时每个微服务之间有似乎存在着剪不断理还乱的关系。2019 年是 Serverless 蓬勃发展的一年，作为 Serverless 领域的中的明星产品，Knative 在今年 8 月份发布了 0.8 版本，其中 Serving 组件的 0.8 版本在笔者看来才真正达到了可用的程度。本篇文章将介绍笔者是如何使用 Knative 来作为 API 聚合层，来解决我们在实践微服务中所遇到的问题的。&lt;/p&gt;
&lt;h2 id=&#34;微服务迭代之痛&#34;&gt;微服务迭代之痛&lt;/h2&gt;
&lt;p&gt;在笔者目前的工作实践中，我们在架构设计中严格遵循着微服务的设计理念。每块业务上独立的领域作为一个微服务，每个微服务有自己单独的数据库。任何一个微服务只能读写自己的数据库，而绝对不能干涉其他微服务的数据库，所有微服务之间获取信息都是通过 http 协议进行通信。在业务初期时，由于产品处于雏形中，所有服务的接口在逻辑上都比较简单，大部分接口都可以看做各自领域模型上的增删改查形态，服务与服务之间的调用也并不密集频繁。随着业务的持续发展与产品的迭代，大大小小、许许多多的功能需求交织重叠在一起，相应的各个服务直接服务于需求的接口也逐渐变多，每个接口越来越“需求相关”。并且我们逐渐发现随着需求的逐渐复杂，每个接口涉及的服务也越来越多，很难有一个强有力的理由去确定这个接口就必须放在某个服务里。这个时候将这个接口放在哪个服务里面，往往取决于做这个需求的开发对哪个服务的掌控力更强，或者说这个接口看上去更倾向于哪块业务领域。同时由于大大小小的“需求相关”的接口越来越多的堆积在各个微服务内以后，整个服务仓库的代码量逐渐增大，代码质量也逐渐下降、微服务仿佛变得不再那么“微”。&lt;/p&gt;
&lt;h2 id=&#34;serverless&#34;&gt;Serverless&lt;/h2&gt;
&lt;p&gt;Serverless，又或者说无服务器、Faas，几乎是 2019 年内整个云原生领域甚至是整个互联网技术圈领域内呼声最旺的关键字。当然 Serverless 并非只是在 2019 年才开始出现相关的技术，早在 2014、2015 年的时候，AWS 就已经在各个文章、博客渠道上就已经开始宣传与推广自家的 AWS Lambda 服务了。当然，在如今 2019 年，国内的各个云服务厂商也都已经开始提供了成熟的 Serverless 产品，整个云原生开源社区内各个 Serverless 产品技术也逐渐走向成熟，同时 Serverless 这一技术落地的场景比起过去几年也越来越清晰、边界也越来越广。如同今年 Kubecon 上越来越多关于 Serverless 的议题一样。以及针对 Serverless 落地的技术分享也越来越多，这块笔者听到的最多的就是关于前端领域和 Serverless 结合的落地分享了。而在许多开源的 Serverless 产品中，最饱受关注的莫过于&lt;a href=&#34;https://knative.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative&lt;/a&gt;了。而在今年 8 月份，Knative 也终于发布了 0.8 版本，虽然这依然还不是一个生产就绪版本，但是 0.8 版本在 API、稳定性上已经“几乎”可以认为是一个生产就绪版本了。这其中最关键的就是 Knative Serving 组件的更新了，可以说在 Knative Serving 0.7 及其之前的版本，这个组件都一直处于一个“几乎”可用的状态，有着不少令人困扰的小 bug。好在这些许多影响正常使用的 bug 都最终在&lt;a href=&#34;https://github.com/knative/serving/releases/tag/v0.8.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Serving 0.8 版本&lt;/a&gt;中被修复了。&lt;/p&gt;
&lt;h2 id=&#34;serverless-在-api-聚合层的尝试&#34;&gt;Serverless 在 API 聚合层的尝试&lt;/h2&gt;
&lt;p&gt;Api 聚合层，第一次听到这个名词依旧也是在今年前端领域的技术分享中。相应的、API 聚合层在前端领域中也有个专门的名词叫做 BFF，即 Backend For Frontend。在这一块，国内已经有过不少 BFF 与 Serverless 结合的的&lt;a href=&#34;https://zhuanlan.zhihu.com/p/65914436&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;分享&lt;/a&gt;。可以说 BFF 与 Serverless 的结合即解决了在前端领域中，多端适配、又或者是 UI 模型与后端 API 数据的转化这一系列问题，同时也没有引入多余的维护服务稳定性以及服务治理等一系列额外的运维负担。&lt;/p&gt;
&lt;p&gt;那么，既然在前端场景中可以有 API 聚合层，在后端服务的场景中是否也可以引入 API 聚合层这一个概念？既然在目前的微服务中，许多直接服务于需求、业务，并且在整个请求链路周期内会跨越许多微服务的 API 难以定位应该放在哪个微服务里，那么倒不如将思维逆转过来，对于这些“无处安放”的 API，我们就干脆不把他们放在任何一个服务上，我们用 Serverless 去支持这些 API，使得这些 API 一直以独立的函数单元存在。这样就让每个后端微服务的定位更加“靠后”，每个微服务提供的 API，用如今一个比较流行的词来形容就是更加“中台化”，更加领域相关，更加的可复用化，而不再是直接面向需求，难以复用的接口。让 Serverless 去承载那些直接面向需求的接口，直接接受来自客户端的请求，然后通过调用更加“靠后”的微服务接口，来将各个 API 聚合在一起进行处理，最终返回给客户端。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-topo&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./img/tuopu.png&#34; alt=&#34;topo&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      topo
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这种设计下的架构就很可能是以上这种形态，每个微服务都会提供自己业务领域内的、高度可复用的接口，然后再由 Serverless 层将这些 API 都聚合在一起直接服务与客户端请求。但不得不说这种设计其实非常“严格”，抑或是“苛刻”。事实上，我们完全可以让微服务与 Serverless 共同服务客户端的请求，而每个微服务之间也可以依旧有着相互的请求调用，只要每个微服务所暴露的接口不要再是那么的“需求相关”即可。毕竟推动我们这么去做的一个最大的痛点就在于一点：微服务如今已经不再那么“微”，希望把那些乱七八糟的接口通通移出去。&lt;/p&gt;
&lt;h2 id=&#34;使用-knative-来搭建-api-聚合层&#34;&gt;使用 Knative 来搭建 API 聚合层&lt;/h2&gt;
&lt;p&gt;这里我们单独使用 Knative Serving 组件来搭建这么一个 API 聚合层的基础设施，相关安装文档可以参考&lt;a href=&#34;https://knative.dev/docs/install/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;。这里我选择的是 Knative+Istio 的方案，版本则为目前最新的 0.8 版本。在搭建完 Knative Serving 组件以后，我们随便部署一个官方 Demo 来看看 Serving 组件究竟给我们做了哪些操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;autoscale-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-test&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# Target 10 in-flight-requests per pod.&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;autoscaling.knative.dev/target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;10&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gcr.azk8s.cn/knative-samples/autoscale-go:0.1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里我们创建完 KSVC 以后，可以看到 Knative Serving 还为我们在 K8S 里创建了对应的 Kubernetes 中的 Service，Deployment 以及 Istio 中的 VirtualService。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get ksvc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME           URL                                          LATESTCREATED        LATESTREADY          READY   REASON
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;autoscale-go   http://autoscale-go.istio-test.example.com   autoscale-go-cl5ng   autoscale-go-cl5ng   True    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get service &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s1&#34;&gt;&amp;#39;autoscale-go&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;autoscale-go               ExternalName   &amp;lt;none&amp;gt;          istio-ingressgateway.istio-system.svc.cluster.local   &amp;lt;none&amp;gt;              2m16s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;autoscale-go-cl5ng         ClusterIP      10.212.41.137   &amp;lt;none&amp;gt;                                                80/TCP              2m41s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;autoscale-go-cl5ng-hpl9z   ClusterIP      10.212.65.244   &amp;lt;none&amp;gt;                                                80/TCP              2m41s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;autoscale-go-cl5ng-zklz4   ClusterIP      10.212.32.0     &amp;lt;none&amp;gt;                                                9090/TCP,9091/TCP   2m41s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get deployment &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s1&#34;&gt;&amp;#39;autoscale-go&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;autoscale-go-cl5ng-deployment   1/1     &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;            &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;           3m15s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get virtualService &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s1&#34;&gt;&amp;#39;autoscale-go&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;autoscale-go        &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;knative-serving/cluster-local-gateway knative-serving/knative-ingress-gateway&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;autoscale-go.istio-test autoscale-go.istio-test.example.com autoscale-go.istio-test.svc autoscale-go.istio-test.svc.cluster.local e6171b7a9294b95cd736d9111a66f2da.probe.invalid&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;   3m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;autoscale-go-mesh   &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;mesh&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;                                                                            &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;autoscale-go.istio-test.svc.cluster.local 675805e7307e82364d1ccb70387c018e.probe.invalid&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里我们先直接看一下 Service 内 autoscale-go 的定义，在这里我们可以看到 autoscale-go 这个 Service 其实是一个 Headless Service，他会将请求直接转发给 Istio Ingressgateway，然后我们再查看一下 autoscale-go VirtualService 的定义。虽然 autoscale-go 的 VirtualService 很长，但其实内核非常简单，就是将 host 满足相关条件的 HTTP 请求转发到 autoscale-go 这个 KSVC 最后对应的服务实例中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2019-08-23T06:26:40Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serving.knative.dev/route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;autoscale-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;autoscale-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-test&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ownerReferences&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;blockOwnerDeletion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;controller&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Route&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;autoscale-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e577a131-c56e-11e9-b3f2-5254000238c1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resourceVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;303862837&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selfLink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/api/v1/namespaces/istio-test/services/autoscale-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;f78f8742-c56e-11e9-b3f2-5254000238c1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;externalName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-ingressgateway.istio-system.svc.cluster.local&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sessionAffinity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ExternalName&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;loadBalancer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;VirtualService&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kubectl.kubernetes.io/last-applied-configuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      {&amp;#34;apiVersion&amp;#34;:&amp;#34;serving.knative.dev/v1alpha1&amp;#34;,&amp;#34;kind&amp;#34;:&amp;#34;Service&amp;#34;,&amp;#34;metadata&amp;#34;:{&amp;#34;annotations&amp;#34;:{},&amp;#34;name&amp;#34;:&amp;#34;autoscale-go&amp;#34;,&amp;#34;namespace&amp;#34;:&amp;#34;istio-test&amp;#34;},&amp;#34;spec&amp;#34;:{&amp;#34;template&amp;#34;:{&amp;#34;metadata&amp;#34;:{&amp;#34;annotations&amp;#34;:{&amp;#34;autoscaling.knative.dev/target&amp;#34;:&amp;#34;10&amp;#34;}},&amp;#34;spec&amp;#34;:{&amp;#34;containers&amp;#34;:[{&amp;#34;image&amp;#34;:&amp;#34;gcr.azk8s.cn/knative-samples/autoscale-go:0.1&amp;#34;}]}}}}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;networking.knative.dev/ingress.class&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio.ingress.networking.knative.dev&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serving.knative.dev/creator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;i18n&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serving.knative.dev/lastModifier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;i18n&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2019-08-23T06:26:40Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;generation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serving.knative.dev/route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;autoscale-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serving.knative.dev/routeNamespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-test&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;autoscale-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-test&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ownerReferences&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.internal.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;blockOwnerDeletion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;controller&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Ingress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;autoscale-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;f791860d-c56e-11e9-b3f2-5254000238c1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resourceVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;303863300&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selfLink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/apis/networking.istio.io/v1alpha3/namespaces/istio-test/virtualservices/autoscale-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;f794b8c8-c56e-11e9-9d0d-5254008ecd85&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;gateways&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;knative-serving/cluster-local-gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;knative-serving/knative-ingress-gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;autoscale-go.istio-test&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;autoscale-go.istio-test.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;autoscale-go.istio-test.svc&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;autoscale-go.istio-test.svc.cluster.local&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;e6171b7a9294b95cd736d9111a66f2da.probe.invalid&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;authority&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;regex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;^autoscale-go\.istio-test\.example\.com(?::\d{1,5})?$&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;gateways&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;knative-serving/knative-ingress-gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;authority&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;regex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;^autoscale-go\.istio-test(\.svc(\.cluster\.local)?)?(?::\d{1,5})?$&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;gateways&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;knative-serving/knative-ingress-gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;retries&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;attempts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;perTryTimeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;10m0s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;autoscale-go-cl5ng.istio-test.svc.cluster.local&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;headers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Knative-Serving-Namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-test&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Knative-Serving-Revision&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;autoscale-go-cl5ng&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;10m0s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;websocketUpgrade&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;fault&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;abort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;httpStatus&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;percent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;authority&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exact&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;e6171b7a9294b95cd736d9111a66f2da.probe.invalid&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;.invalid&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;weight&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从以上层层分析中我们可以看到，其实 Knative Serving 背后的拓扑关系并不复杂，依旧是一个依托于 Kubernetes 与 Istio 固有的 API 所结合起来的一个 Serverless 方案，但这同时也给我们带来一个非常显而易见的矛盾。从以上 Knative Serving API 定义中，我们不难发现在 Knative 中，区分一个个函数、即 KSVC，依靠的是 Hostname。即对于 Knative 而言，他并不关心这个函数的 Http Method 与 Http Path 是什么，只要这个 Http 请求的 host 符合{ksvc-name}.{namespace}的判断条件，他就会将这个请求转发到对应的实例中去。而作为 Faas 使用者的我们，区分一个个函数，尤其是作为 API 聚合层的场景下，最直观的区分变量其实就是 Http Method 与 Http Path。同时另外一点是，和之前常驻型的微服务不同的是，对于常驻型的微服务，通常匹配 Http 请求与 Http Handler 往往只需要 Http Method 与 Http Path 即可，并不需要关心这个 Http 请求的 Host 是什么。而在现在的 Knative Serving 的场景下，即使我们在 Knative 接受到请求之前 Handle 了 Http Method 与 Http Path 与各个 KSVC 的对应关系，我们同时还需要将这个来自外部客户端的 HTTP 请求中的 Hostname 改写为 KSVC 能接受的 Hostname。这个需求其实听上去非常像是一个反代服务器，事实上用 Nginx 也可以同样 handle 住这个需求，当然这里为了快速验证这个想法，我就简单用 golang 快速写了一个 proxy server，同时增加了在反代过程中通过 Http Method 与 Http Path 快速检索对应的 KSVC HostName 的逻辑。(当然这块一一对应的关系最好在应用启动时事先加载在内存中)&lt;/p&gt;
&lt;p&gt;Golang 起一个 HTTP 反代服务器非常简单，其核心代码就短短几行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s&#34;&gt;&amp;#34;net/http&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s&#34;&gt;&amp;#34;net/http/httputil&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s&#34;&gt;&amp;#34;log&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HandleFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;director&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;URL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Scheme&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;http&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;URL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Host&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Host&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;httputil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ReverseProxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Director&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;director&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;:8888&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;经过上面这一番操作，我们整个调用 Serverless 函数的网络链路也就最终确定下来，并且在我们的实践中，我们所有使用 Serverless 的函数在 Http Path 上都约定以“/faas/”作为 Http Path 前缀，这样一个来自外部客户端的请求从网关层进入到最终被 autoscale-go 访问这个网络链路可以分为五步。
假设 autoscale-go 这个程序本身监听了 Get 请求，“/faas/demo”作为 Http Path 的请求，然后网关层接收到了&lt;a href=&#34;https://www.example.com/faas/golang%22&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.example.com/faas/golang&lt;/a&gt;的请求。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网关层 Nginx Ingress 会将 https 解包成 http 协议，并且根据 Ingress 规则将请求转发给 proxy-server&lt;/li&gt;
&lt;li&gt;proxy-server 收到请求后，会根据请求的 Http Method 与 Http Path 检索其对应的 KSVC，如果检索到，则改写 HostName，并转发到对应的 Headless Service 上。&lt;/li&gt;
&lt;li&gt;Headless Service 收到请求后将请求转发给 Istio IngressGateway&lt;/li&gt;
&lt;li&gt;Istio IngressGateway 收到请求后，根据 VirtualService 规则转发到对应的服务实例中去&lt;/li&gt;
&lt;li&gt;autoscale-go 实例收到请求后开始处理，处理完以后回复 Response。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./img/netline.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;为何要这么设计链路&#34;&gt;为何要这么设计链路？&lt;/h2&gt;
&lt;p&gt;纵观上面整个五步，一定会有人问这么设计会不会整个网络链路转发的步骤太多了，影响性能之类的问题。事实上，在我们做任何一个架构上的设计时，一定会牵扯到&lt;strong&gt;可维护性&lt;/strong&gt;，&lt;strong&gt;复杂度&lt;/strong&gt;，&lt;strong&gt;性能&lt;/strong&gt;，&lt;strong&gt;风险&lt;/strong&gt;等多个因素的平衡与取舍。事实上上面的第一步和第二步，完全可以合并为一步，在网关层就直接将 KSVC 检索、HostName 替换给一起做了，可是试想下，在互联网场景下，一个高速迭代的业务平时会上线、下线大量的接口。和常驻的微服务不同，微服务增加新的接口是不需要刷新网关层配置的，而在 Faas 的场景下我们每新增一个接口新相当于上线一个新服务，更别提也许我们未来希望在每个函数接受到请求时都已经经过鉴权以及设置了一些约定的 Http Header 等更多需求。而上面的第三到第五步则完全就是 Knative Serving 原生的处理流程，这里不去干涉 Knative Serving 的原生处理流程，就是为了能直接使用到 Knative Serving 原生封装好的各种功能，包括函数迭代、灰度发布、冷启动等功能。&lt;/p&gt;
&lt;h2 id=&#34;最后的一点经验总结&#34;&gt;最后的一点经验总结&lt;/h2&gt;
&lt;p&gt;在 Serverless 领域中，一个被所有开发者最关心的一个问题就是冷启动的耗时问题。在笔者的场景下，即使是在所有使用到的镜像都彻底预先拉取到宿主机的情况下，并且函数本身所使用的镜像大小都尽可能小时，对于冷启动的耗时依旧处于一个不令人满意的结果。但是这也问题不大，因为 Knative Serving 本身也提供了杜绝冷启动的选项，当然在这一情况下每个函数都会保留一个实例，也就没了节约资源这一说法。然而，站在一个向业务开发方推荐 Serverless 这一新技术的角度下，在保证性能的前提下，节约资源这一优点对于业务方而言并不属于非常通用，非常有说服力的痛点。正如在我看来前端领域中 BFF+Serverless 是一个非常好的双方各取所需的共赢案例，Serverless 希望推广，希望扩展场景，而前端开发者们则希望解决 UI 模型与后端数据转换的痛点，于是双方一拍即合。你能说在这一例子中，Serverless 所强调的节约资源，弹性伸缩等特性完全契合了 BFF 的需求吗？非也，无需运维才是。在这 API 聚合的场景中，针对微服务不再“微”，通过将直接面向需求的接口从各个微服务中剥离转交到 Serverless 层，达到了将各个复杂的接口独立治理、分而治之的思想降低了整体的复杂度，让每个微服务都能直接提供“中台化”的，“可复用”的接口，这往往会大大提高每个微服务的代码可维护性。实践证明，往往那些一次性的、无法复用的、极度“需求相关”的逻辑往往是摧毁项目可维护性的元凶之一，而在一个多人合作的业务项目中，我们往往无法杜绝这样的代码，也无法拒绝这样的需求，那么这篇文章所讲的落地场景就是将这些代码剥离出来，作为一个个函数。就算某个函数写的极其混乱，那又如何，把整个函数清空了重写的成本也并不高，毕竟重构一个函数比重构一个服务简单多了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Solo.io 打造的 Gloo——Knative 中 Istio 的替代方案</title>
      <link>https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/</link>
      <pubDate>Thu, 16 May 2019 12:20:44 +0800</pubDate>
      <guid>https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/solo-io/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-324753586f3a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;[编者按]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;之前有社区成员询问是不是想尝试 Knative 时，必须要安装 Istio 才行，今天就告诉大家一种 Istio 的替代方案，使用 Solo.io 公司研发的 Gloo 来替代 Istio 来使用 Knative。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;在 Knative 中，Istio 的主要作用是作为一个 Ingress 技术。Gloo 现在加入 Istio 作为 Knative 的集成和支持 Ingress。有关快速演示 demo，请参阅文章末尾。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，&lt;a href=&#34;https://github.com/knative/docs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative 的存在&lt;/a&gt;是为了定义在&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;上构建和服务化工作负载的一套标准方法。Knative 的一个显著特性是它的 serverless 特性：它将工作负载的执行与事件关联起来，而只在此类事件发生时消耗计算能力（事件驱动）。&lt;/p&gt;
&lt;p&gt;Knative 是最初在谷歌创建，现在已与 Pivotal、Red Hat、SAP、IBM 等许多公司联合开发的开源协作技术。&lt;/p&gt;
&lt;h2 id=&#34;使用-knative-服务处理请求&#34;&gt;使用 Knative 服务处理请求&lt;/h2&gt;
&lt;p&gt;让我们简要了解一下 Knative 如何处理请求，以及它与“纯”Kubernetes 的比较。&lt;/p&gt;
&lt;p&gt;Kubernetes 上的&lt;em&gt;传统&lt;/em&gt;工作负载，比如 web 应用程序，需要一个运行的 Pod 和一个 Ingress，以允许流量从其他集群流入到当前集群。&lt;/p&gt;
&lt;p&gt;现在，通过 Knative 的视角，让我们考虑下面的示例：有如下一个场景，客户端希望从一个在 Knative 平台上注册但不一定立即运行的应用程序中检索天气预报信息。使用 Knative 术语，有一个服务可以创建必要的配置和路由，以便在调用天气预报应用程序时运行它。在 Knative 上下文中，应用程序包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/spec/spec.md#service&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Service&lt;/a&gt;（不要与 Kubernetes Service 对象混淆）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/spec/spec.md#route&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Route&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/spec/spec.md#configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Configuration&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个或多个&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/spec/spec.md#revision&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Revision&lt;/a&gt;，运行时，Revision 会变成 Kubernetes Pod。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-1_hu18430415403217440895.webp 400w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-1_hu13576380678038512255.webp 760w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-1_hu14813630817470749605.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-1_hu18430415403217440895.webp&#34;
               width=&#34;624&#34;
               height=&#34;176&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;深入到流量管理部分，Knative service 有一个名为&lt;a href=&#34;https://github.com/knative/serving/tree/master/pkg/activator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Activator&lt;/a&gt;的组件，它负责报告某个工作负载需要运行相应数量的 pod 来处理请求。&lt;/p&gt;
&lt;p&gt;这种架构的美妙之处在于，如果负责运行应用程序的 Pod 没有运行，那么请求将被搁置，直到流量可以路由到一个或多个 pod 为止。这优化了资源利用率。&lt;/p&gt;
&lt;p&gt;如果您想知道，还有一些特性允许您预热应用程序，这样就不会阻塞任何请求。这使您能够对是否始终保持 Pod 运行做出明智的决策。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-2_hu7592915862189423071.webp 400w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-2_hu15671538393972779163.webp 760w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-2_hu612503228005542232.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-2_hu7592915862189423071.webp&#34;
               width=&#34;624&#34;
               height=&#34;378&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如前所述，一旦有一个修订（一个或多个 Pod）来处理请求，流量就可以从 Ingress 网关流到您的修订。Knative Serving 将继续收到请求的通知，以便确定是否需要对服务于修订的 Pod 进行伸缩。这真的太棒了！&lt;/p&gt;
&lt;h2 id=&#34;istio-的必要性&#34;&gt;Istio 的必要性&lt;/h2&gt;
&lt;p&gt;请求可能需要路由到相同配置的不同版本 (请阅读工作负载规范)，特别是在同时运行同一应用程序的不同版本的情况下。为了做到这一点，Knative 需要一个可以执行以下功能的 Ingress 控制器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;流量分流&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TLS 终止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于 Header 路由&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;追加 Header&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Solo.io 拥抱&lt;a href=&#34;https://istio.io/zh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;。我们已经投资构建了一个名为&lt;a href=&#34;https://github.com/solo-io/supergloo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SuperGloo&lt;/a&gt;的服务网格编排器和管理平台，这可能是开始使用 Istio 的最简单方法。就我个人而言，我也很喜欢 Istio。在红帽的时候，我参与了这个项目的&lt;a href=&#34;https://blog.openshift.com/red-hat-istio-launch/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;正式启动&lt;/a&gt;，并&lt;a href=&#34;https://www.infoworld.com/article/3273547/the-rise-of-the-istio-service-mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;写下&lt;/a&gt;了为什么 Istio 如此受欢迎。&lt;/p&gt;
&lt;p&gt;但如果我诚实地评价 Istio 在 Knative 上的角色，我的感觉是：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-3_hu6398569505473181893.webp 400w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-3_hu9688276613693843709.webp 760w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-3_hu9320918603308994774.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-3_hu6398569505473181893.webp&#34;
               width=&#34;624&#34;
               height=&#34;177&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Istio 提供了一组令人惊讶的特性，但是 Knative 只使用了其中的一些。作为参考，Istio 目前有 48 个 CRD（CustomResourceDefinition 对象），其中只有一个主要由 Knative（VirtualService）使用。&lt;/p&gt;
&lt;p&gt;现在，如果您的组织也愿意采用服务网格技术，并且 Istio 是您的选择，那么这种痛苦肯定会减少。为此，您必须熟悉或已经熟悉 Istio 的工作原理。现在对于许多用户来说，增加的复杂性可能不值得。&lt;/p&gt;
&lt;h2 id=&#34;gloo下一代通用-api-网关作为网关服务&#34;&gt;Gloo——下一代通用 API 网关，作为网关服务。&lt;/h2&gt;
&lt;p&gt;Gloo 是下一代 API 网关，它既满足 Knative 的需求，又不会带来成熟服务网格技术 (Istio 就是这种情况) 的不必要包袱。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-4_hu8426130359135009551.webp 400w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-4_hu11368614000809522496.webp 760w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-4_hu2493543545681977301.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-4_hu8426130359135009551.webp&#34;
               width=&#34;317&#34;
               height=&#34;135&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;建立在 Envoy 之上，&lt;a href=&#34;https://knative.dev/docs/install/knative-with-gloo/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;是 Knative 第一个官方的 Istio 替代品&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但这在现实中意味着什么呢？当我们决定对这个解决方案投入精力时，我们的主要目标之一就是解决方案的可持续性。当一个新版本出现时，一起工作的项目突然停止工作，这肯定会令人沮丧，我们的集成工作主要集中在三个方面：易用性、实现和持续集成。&lt;/p&gt;
&lt;h2 id=&#34;易用性&#34;&gt;易用性&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;作为一家公司的一个关键任务是为了弥合先进的开源技术与使用这种技术的企业和用户之间的差距。在这种程度上，我们在&lt;a href=&#34;https://knative.dev/docs/install/knative-with-gloo/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 Gloo 时改进了 Knative 本身的安装&lt;/a&gt;。整个社区可以立即受益于一种更简单的实验和生产方式。&lt;/p&gt;
&lt;p&gt;流行的&lt;code&gt;glooctl&lt;/code&gt;命令现在包含一个 Knative 选项，该选项&lt;a href=&#34;https://gloo.solo.io/installation/#2c-install-the-gloo-knative-cluster-ingress-to-your-kubernetes-cluster-using-glooctl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不仅安装 Gloo 网关本身而且还将安装 Knative&lt;/a&gt;（！！！）。在安装过程中，Knative 配置了&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;作为集群 Ingress 网关，它使用一个命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ glooctl install knative
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;虽然这是一个显而易见的问题，但我们创建了必要的控制和监视，以便&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;能够在 Istio Ingress 运行时在相同或更好的容量水平上运行和报告。大部分工作都是在 Gloo 上完成的。在技术层面，Gloo 得到了扩展，包括基于 Knative ClusterIngress CRD 读取和应用配置的能力。&lt;/p&gt;
&lt;h2 id=&#34;持续集成&#34;&gt;持续集成&lt;/h2&gt;
&lt;p&gt;我们在&lt;a href=&#34;https://github.com/knative/serving/pull/3087&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative&lt;/a&gt;的 CI 测试流水线中实现并引入了特定的 Gloo 测试，这意味着如果 Knative 中的一个更改破坏了与 Gloo 的集成，反之亦然，那么社区将得到通知并根据情况采取相应的行动。这为任何正在寻找 Knative 上的 Istio 的替代方案的人提供了可能，在撰写本文时，Knative 是唯一的替代方案。&lt;/p&gt;
&lt;h2 id=&#34;立刻行动吧&#34;&gt;立刻行动吧！&lt;/h2&gt;
&lt;p&gt;如果您能够访问 Kubernetes 集群，只需&lt;a href=&#34;https://github.com/solo-io/gloo/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;下载&lt;/a&gt;最适合您的操作系统的&lt;code&gt;glooctl&lt;/code&gt;版本，然后立即开始您的 Knative（和&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;）之旅。我们最近也增加了对 Windows 的支持。要获得更多帮助，请查看我们的 Knative 特定&lt;a href=&#34;https://gloo.solo.io/installation/#2c-install-the-gloo-knative-cluster-ingress-to-your-kubernetes-cluster-using-glooctl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;并加入我们的&lt;a href=&#34;http://slack.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slack&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Gloo 可以做的不仅仅是基本的 Ingress 路由。Gloo 被设计为下一代 API 网关，能够理解功能级别的调用 (HTTP1、HTTP2、gRPC、REST/OpenAPISpec、SOAP、WebSockets、Lambda/Cloud 函数)，并能够帮助您从单一功能到微服务和 serverless 的演进。参加我们的&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络研讨会&lt;/a&gt;，我们将讨论如何渐进地、安全地发展您的应用程序架构，以利用新功能来满足您的业务需求，而不必对您的单体应用进行危险的更改。&lt;/p&gt;
&lt;h2 id=&#34;观看介绍视频&#34;&gt;观看介绍视频&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=_e61MB2Afvs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.youtube.com/watch?v=_e61MB2Afvs&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google Cloud Run 详细介绍</title>
      <link>https://cloudnative.to/blog/google-cloud-run-intro/</link>
      <pubDate>Mon, 13 May 2019 12:20:46 +0800</pubDate>
      <guid>https://cloudnative.to/blog/google-cloud-run-intro/</guid>
      <description>&lt;p&gt;在 Cloud Next 2019 大会上，Google 宣布了 Cloud Run，这是一个新的基于容器运行 Serverless 应用的解决方案。Cloud Run 基于开源的 knative 项目，宣称要将 serverless 带入容器世界。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cloud-run-介绍&#34;&gt;Cloud Run 介绍&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/28a4d1a9808e275623bbbc81ee19b298.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在旧金山举办的 Google Cloud Next 2019 大会上，Google 宣布了 Cloud Run，这是一个新的基于容器运行 Serverless 应用的解决方案。Cloud Run 基于开源的 knative 项目，是 knative 的 Google Cloud 托管版本，也是业界第一个基于 Knative + Kubernetes 的 Serverless 托管服务。&lt;/p&gt;
&lt;p&gt;援引来自 Google Cloud 官方网站的介绍资料，对 Cloud Run 的定位是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Run stateless HTTP containers on a fully managed environment or in your own GKE cluster.&lt;/p&gt;
&lt;p&gt;在完全托管的环境或者自己的 GKE 集群中运行 serverless HTTP 容器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前 Google Cloud 还处于测试阶段，尚未 GA，而且暂时只在美国地区提供。&lt;/p&gt;
&lt;h2 id=&#34;cloud-run-推出的背景&#34;&gt;Cloud Run 推出的背景&lt;/h2&gt;
&lt;p&gt;这里有一个大的背景：在 knative 出来之前，serverless 市场虽然火热，但是有一个根本性的问题，就是市场碎片化极其严重，有大大小小几十个产品和开源项目，而且存在严重的供应商绑定风险。因此，Google 牵头推出了 knative 开源项目，希望实现 serverless 的标准化和规范化。&lt;/p&gt;
&lt;p&gt;关于 knative 的详细情况，这里不继续展开，有兴趣的同学可以阅读我之前的演讲分享 &lt;a href=&#34;https://www.atatech.org/articles/128783&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative: 重新定义 Serverless&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;google-cloud-上的-serverless&#34;&gt;Google Cloud 上的 Serverless&lt;/h3&gt;
&lt;p&gt;在 Cloud Run 出现之后，目前 Google Cloud 上就有三种 Serverless 产品了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cloud Functions: 事件驱动的 serverless 计算平台&lt;/li&gt;
&lt;li&gt;App Engine: 高可扩展的 serverless web 应用&lt;/li&gt;
&lt;li&gt;Cloud Run: 无状态的 serverless HTTP 容器，口号是 &lt;strong&gt;Bringing Serverless to Containers&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/a254a5969d0da9b36796483cf73c3dbb.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-serverless-computer-on-google-cloudpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/a254a5969d0da9b36796483cf73c3dbb.png&#34; alt=&#34;serverless-computer-on-google-cloud.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      serverless-computer-on-google-cloud.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;bring-serverless-to-containers&#34;&gt;Bring Serverless to Containers&lt;/h3&gt;
&lt;p&gt;这是 Cloud Run/knative 区别于之前的各种 serverless 产品的本质不同之处：支持的工作负载不再局限于 Function，而是任意容器！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：当然基本的容器运行时契约还是要遵守的，具体要求见下面的介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和 Function 相比，以 container 方式呈现的工作负载，给使用者更大的自由度，Google Cloud 对此给出的口号是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Any langurage / 不限语言&lt;/li&gt;
&lt;li&gt;Any library / 不限类库&lt;/li&gt;
&lt;li&gt;Any binary 不限二进制文件（备注：格式还是要限制的，要求 Linux x86_64 ABI 格式）&lt;/li&gt;
&lt;li&gt;Ecosystem of base images / 基础镜像的生态系统&lt;/li&gt;
&lt;li&gt;Industry standard/工业标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/f5e1d702207d1b633cb7482408ef7661.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-bring-serverless-to-containerpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/f5e1d702207d1b633cb7482408ef7661.png&#34; alt=&#34;bring-serverless-to-container.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      bring-serverless-to-container.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google Cloud Run / Knative 对容器的要求，和通用容器相比，强调 &lt;strong&gt;无状态（Stateless）&lt;/strong&gt; / &lt;strong&gt;请求驱动（request-triggered）&lt;/strong&gt; / &lt;strong&gt;可自动伸缩（autoscaled）&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/f95df42e15c178258391a2a74cb51b0b.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-workload-containerpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/f95df42e15c178258391a2a74cb51b0b.png&#34; alt=&#34;workload-container.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      workload-container.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，请求流量通常并非均匀分布，有突发高峰，有长期低谷，甚至有时没有流量。因此，从资源使用率的角度考虑，处理这些请求流量的服务容器的实例也应该随请求流量变化，做到自动伸缩，按需使用，以节约成本。&lt;/p&gt;
&lt;h2 id=&#34;cloud-run-的特性和要求&#34;&gt;Cloud Run 的特性和要求&lt;/h2&gt;
&lt;h3 id=&#34;cloud-run-的特性概述&#34;&gt;Cloud Run 的特性概述&lt;/h3&gt;
&lt;p&gt;下图是整理的 Cloud Run 的几个主要特性，其核心还是那句口号 &amp;ldquo;Bring Serverless to Container&amp;rdquo;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/d3f10b6a5886a874747e4c7515498fcc.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-cloud-run-featurespng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/d3f10b6a5886a874747e4c7515498fcc.png&#34; alt=&#34;cloud-run-features.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      cloud-run-features.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以容器形式出现的工作负载：不只是 Function，极大的丰富了 serverless 的玩法&lt;/li&gt;
&lt;li&gt;兼容 knative API：这也是近年来 Google 的一贯打法，开源项目先行，对社区开放，拉拢盟友建立标准，以无厂商锁定的风险来吸引客户，我将其简称为&amp;quot;开源开放不锁定&amp;quot;。&lt;/li&gt;
&lt;li&gt;GCP 托管：托管的好处自然是客户无需运维，这也是 serverless 的由来和最基本的特性&lt;/li&gt;
&lt;li&gt;流量驱动模式：请求驱动，实例数量可自动伸缩，甚至伸缩到 0，因此无需在业务高峰时预先配置资源和事后手工释放资料，极大的减少运维需要。在此基础上，执行按使用付费，因此可以在不同的应用之间（在公有云上则可以在不同的客户之间）共享成本，以低成本的方式应付短期突发高并发请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cloud Run 的其他特性还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速从容器到生产部署&lt;/li&gt;
&lt;li&gt;开发体验简单&lt;/li&gt;
&lt;li&gt;高可用：自动跨区域的冗余&lt;/li&gt;
&lt;li&gt;和 Stackdrive 的集成，监控/日志/错误报告都是开箱即用&lt;/li&gt;
&lt;li&gt;可自定义域名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些特性容易理解，就不一一展开。&lt;/p&gt;
&lt;h3 id=&#34;适用于更多的场景&#34;&gt;适用于更多的场景&lt;/h3&gt;
&lt;p&gt;传统的基于 Function 负载的 serverless，受限于 Function，适用范围相对有限，尤其不适合非 Function 方式编写的旧有应用，而将应用改造为 Function 一来工作量巨大，二来也不是所有的应用都适合用 Function 形式开发。&lt;/p&gt;
&lt;p&gt;在以 Function 为负载的 serverless 系统中，调用往往发生在外部对 Function 的访问，类似 API gateway 下的南北向通信。Function 之间通常不直接相互调用（某些情况下需要调用时，往往也是走外部调用的通道），因此调用关系相对简单。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/408d2919990b81568734083f0242421b.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-serverless-north-southpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/408d2919990b81568734083f0242421b.png&#34; alt=&#34;serverless-north-south.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      serverless-north-south.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当工作负载从 Function 转变为 Container 之后，不仅仅有 serverless 原有的南北向通信，而且以容器形态出现的工作负载之间相互调用的场景大为增加，这些负载之间的相互调用类似于传统 SOA/微服务框架的东西向服务间通信。Cloud Run 通过支持容器作为工作负载，极大的扩大了 serverless 的适用范围。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/b789978c94647204f33a5a1e202a9a35.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-serverless-east-westpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/b789978c94647204f33a5a1e202a9a35.png&#34; alt=&#34;serverless-east-west.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      serverless-east-west.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了前面列出来的两种场景之外，Cloud Run 还可以适用于其他场景，如事件驱动/异步任务/调度服务等：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/3756b025f89e554e198cc8159060cbd3.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-workload-more-stylepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/3756b025f89e554e198cc8159060cbd3.png&#34; alt=&#34;workload-more-style.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      workload-more-style.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这也迎合了目前 serverless 的发展趋势：未来 serverless 将渗透到各种场景，任何需要按照请求自动实现资源动态调度的工作负载都应该 serverless 化。我称之为：&lt;strong&gt;万物皆可 serverless&lt;/strong&gt;！从 Function 到 Container，serverless 朝这个目标迈出了一大步。&lt;/p&gt;
&lt;h3 id=&#34;cloud-run-的并发模型&#34;&gt;Cloud Run 的并发模型&lt;/h3&gt;
&lt;p&gt;重点看一下 Cloud Run 对请求并发的处理，因为这涉及到如何动态调配服务容器实例的个数。&lt;/p&gt;
&lt;p&gt;在 Cloud Run 中，每个服务都要自动伸缩容器的实例数量来应对请求流量。在 Cloud Run 中对并发（Concurrency）的定义是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Concurrency&lt;/strong&gt; = &amp;ldquo;maximum number of requests that can be sent at the same time to a given container instance&amp;rdquo;&lt;/p&gt;
&lt;p&gt;并发 = &amp;ldquo;可以同时对给定容器实例发送请求的最大数量&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是我们平时理解的&amp;quot;最大并发请求数&amp;quot;，或者&amp;quot;最大工作线程数&amp;quot;。在这一点上，Cloud Run 的做法和 AWS Lambda 还有 Google 自己的 Cloud Function 不同，后两者的做法是每个实例只能同时接受一个请求，相当于“Concurrency=1”。如图，当有多个并发请求时就需要启动多个实例。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/2f69c0f3528dd313836cbdb5725762a3.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-concurrency-1png&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/2f69c0f3528dd313836cbdb5725762a3.png&#34; alt=&#34;concurrency-1.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      concurrency-1.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而在 Cloud Run 中，并发度是可以设置的，容许的值范围是从 1 到 80，默认值是 80，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/311fd84e418f4c362545afa179b4daaa.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-concurrency-settingpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/311fd84e418f4c362545afa179b4daaa.png&#34; alt=&#34;concurrency-setting.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      concurrency-setting.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果并发度设置为 1 则 Cloud Run 的行为也就和 AWS Lambda/Google Cloud Function 一致了，不过对于容器形式的工作负载而言，容器启动和销毁的资源消耗和成本就有过高了，因此 Cloud Run 下通常建议根据实际业务场景设置合适的并发度/请求数上限。这样在处理请求时，可以用一个实例对应多个请求，从而不必启动太多的实例。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/e2bf7c12793ba2969f16fd6625ada7ef.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-concurrency-20png&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/e2bf7c12793ba2969f16fd6625ada7ef.png&#34; alt=&#34;concurrency-20.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      concurrency-20.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;cloud-run-对容器的要求&#34;&gt;Cloud Run 对容器的要求&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/6f73d8eefad9af361963852948b010b1.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-container-runtime-contractpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/6f73d8eefad9af361963852948b010b1.png&#34; alt=&#34;container-runtime-contract.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      container-runtime-contract.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 Google Cloud Run 的文档中， &lt;a href=&#34;https://cloud.google.com/run/docs/reference/container-contract&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Container 运行时契约&lt;/a&gt; 中列出了 Cloud Run 对容器的要求，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语言支持&lt;/p&gt;
&lt;p&gt;可以使用任意语言编写代码，可以使用任意基础镜像，但是容器镜像必须是为 64 位 Linux 编译的; Cloud Run 支持 Linux x86_64 ABI 格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求监听&lt;/p&gt;
&lt;p&gt;容器必须在 &lt;code&gt;0.0.0.0&lt;/code&gt; 上监听，端口由环境变量 &lt;code&gt;PORT&lt;/code&gt; 定义。目前在 Cloud Run 中，PORT 环境变量总是设置为 8080，但是为了可移植性，不能 hardcode。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动时间和响应时间&lt;/p&gt;
&lt;p&gt;容器实例必须在收到请求后的四分钟内启动 HTTP 服务器; 容器实例必须收到 HTTP 请求后的规定时间内发送响应，该时间由 &lt;a href=&#34;https://cloud.google.com/run/docs/configuring/request-timeout&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;request timeout setting&lt;/code&gt;&lt;/a&gt; 配置，包含容器实例的启动时间。否则请求会被终止并返回 504 错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件访问&lt;/p&gt;
&lt;p&gt;容器的文件系统是可写的并受以下影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件系统是基于内存的，写入文件系统会使用容器实例的内存&lt;/li&gt;
&lt;li&gt;写入到文件系统中的数据不会持久化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器实例生命周期考虑&lt;/p&gt;
&lt;p&gt;服务的每个版本都将自动伸缩，如果某个版本没有流量，则会缩减到 0。&lt;/p&gt;
&lt;p&gt;服务应该是无状态的，计算应该限定于请求的范围，如果没有请求则不能使用 CPU。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器实例资源&lt;/p&gt;
&lt;p&gt;每个容器实例分配 1 vCPU 而且不能修改。每个容器实例默认 256M 内存，可以修改，最多为 2G。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，Cloud Run 目前处于测试阶段，因此这些要求可能会随时间而发生变化。&lt;/p&gt;
&lt;p&gt;Container Runtime Contract 更详细的信息，请参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/run/docs/reference/container-contract&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Container Runtime Contract&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/runtime-contract.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Container Runtime Contract&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/opencontainers/runtime-spec/blob/master/spec.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Container Initiative Runtime Specification&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cloud-run-的限制&#34;&gt;Cloud Run 的限制&lt;/h3&gt;
&lt;p&gt;目前 Cloud Run 的限制有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最多 1 个 vCPU 和 2 G 内存&lt;/li&gt;
&lt;li&gt;不能访问 GPU&lt;/li&gt;
&lt;li&gt;没有 Cloud SQL（即将提供）&lt;/li&gt;
&lt;li&gt;没有 VPS 访问（即将提供）&lt;/li&gt;
&lt;li&gt;不支持全局负载均衡&lt;/li&gt;
&lt;li&gt;只支持 HTTP（未来会支持 gRPC）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这些限制，都可以通过选择使用 Cloud Run on GKE 来解决。&lt;/p&gt;
&lt;h3 id=&#34;安全容器-gvisor-的使用&#34;&gt;安全容器 gVisor 的使用&lt;/h3&gt;
&lt;p&gt;gVisor 是由 Google 开源的容器沙箱运行时 (Container sandbox runtime)。用于在宿主机操作系统与容器中的应用之间创建一个安全的隔离边界，便于安全的对外提供大规模部署的容器服务——关于安全容器和 gVisor 的介绍就不在这里展开。&lt;/p&gt;
&lt;p&gt;在 Cloud Run 中，容器是运行在 gVisor 之上的，而不是默认的 Kubernetes runc runtime。gVisor 为 Cloud Run 带来了安全容器的隔离，但是也带来了一些限制。如下图所示，gVisor 支持的 System Call 是有限的，不支持所有的 Linux System Call。但是考虑到 Cloud Run 的主要使用场景是无状态的 HTTP 容器，正常情况下应该不会触发这个限制。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/0720320c9e5ec4be828cc4286a2241ac.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-gvisorpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/0720320c9e5ec4be828cc4286a2241ac.png&#34; alt=&#34;gvisor.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      gvisor.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;和-knative-的关系&#34;&gt;和 knative 的关系&lt;/h2&gt;
&lt;p&gt;Google Cloud 给出的一些 PPT 中宣称 Cloud Run 就是托管版本的 knative，当然这一点我个人有些质疑：当前开源版本的 knative 实在有些不够成熟，应该还达不到生产级强度，Google Cloud 托管的有可能是 knative 的内部版本。但可以肯定的是，Cloud Run 一定是兼容 knative API 的。&lt;/p&gt;
&lt;p&gt;目前 Knative 发展趋势非常不错，尤其社区快速成长，聚拢了一批大小盟友。这里有一份 google 给出的长长列表，列出了当前参与 knative 开发的贡献者来自的公司：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;VMware, Huawei, Cisco, TriggerMesh, Dropbox, SAP, Microsoft, Schibsted, Apache, Independent, China Mobile NTT, CloudBees, Caicloud, Inovex, Docker, Heureka, CNCF, Liz Rice, Zalando, Douyu.com, Nebula. OpsGenie. Terracotta, Eldarion, Giant Swarm, Heroku, Revolgy, SORINT.lab, Switch, Ticketmaster, Virtustream,, Alipay, Blue Box, Cruise Automation, EPAM Systems, EVRY, Foreningen Kollegienet Odense, Giddyinc, IPB, Manifold.co, Orange, Puppet, Stark &amp;amp; Wayne, Weaveworks, Disney Interactive, Ivx, Mediative, Ministère de l&amp;rsquo;Agriculture et de l&amp;rsquo;Alimentation, NatureServe, Samsung SDS. Typeform, Wise2c&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，其中最重要的力量还是来自 google 自己，以及 Redhat、Pivotal、IBM 这三位社区巨头。下图是以公司为单位的贡献度比例：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/b3c67cb6523f850996aa04d71b14bc86.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-knative-companypng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/b3c67cb6523f850996aa04d71b14bc86.png&#34; alt=&#34;knative-company.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      knative-company.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下图是基于 Knative 的几个主要 serverless 产品，除了 Google 的 Cloud Run 之后，还有 Redhat / Pivotal / IBM 等大厂：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/9acb6154b0842a93e2bbd9349231ba2a.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-knative-based-productspng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/9acb6154b0842a93e2bbd9349231ba2a.png&#34; alt=&#34;knative-based-products.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      knative-based-products.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;serverless-计算平台选择&#34;&gt;Serverless 计算平台选择&lt;/h2&gt;
&lt;p&gt;Cloud Run 是一个 serverless 计算平台，用于运行无状态 HTTP 应用程序。它有两种风格：完全托管的环境或 Google Kubernetes Engine 集群。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cloud Run：完全托管，完整的 serverless 体验，客户不需要管理集群，按使用付费。&lt;/li&gt;
&lt;li&gt;Cloud Run on GKE：只具有 serverless 的开发体验，客户需要在自己的 GKE 集群中运行，价格包含在 GKE 集群中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/be5f759c8e6d22b7e7cfab20fb8a58d4.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-cloud-run-on-gkepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/be5f759c8e6d22b7e7cfab20fb8a58d4.png&#34; alt=&#34;cloud-run-on-gke.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      cloud-run-on-gke.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cloud Run on GKE 具有和 Cloud Run 相同的开发体验，但是 Cloud Run on GKE 运行在 k8s 上，有更多的灵活性和控制力，不过需要自己运维。Cloud Run on GKE 可以集成基于 k8s 的策略、控制和管理。允许访问自定义计算机类型，额外的网络和 GPU 支持，以扩展 Cloud Run 服务的运行方式。&lt;/p&gt;
&lt;p&gt;可以在 Cloud Run 和 Cloud Run on GKE 之间按需要选择，另外 Google Cloud 容许在 Cloud Run 和 Cloud Run on GKE 之间切换，无需改动应用。&lt;/p&gt;
&lt;p&gt;Cloud Run 和 Cloud Run on GKE 的详细对比：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;Cloud Run&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;GKE 上的 Cloud Run&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;价钱&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;按使用付费（见下文）。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;作为 Kubernetes Engine 的一部分提供。定价将在 GA 之前确定。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;机器类型&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;每个实例一个 vCPU，可以更改内存&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;GKE 上的标准或自定义机器类型，包括 GPU。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;身份和政策&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;管理允许调用服务的身份（或允许未经身份验证的调用）。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将服务发布到 Internet 或仅将其提供给群集或 VPC 网络。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;联网&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;无法访问 VPC /计算引擎网络。服务不是 Istio 服务网格的一部分。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;访问 VPC /计算引擎网络。服务参与 Istio 服务网格。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;网址&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;自动提供 URL 和 SSL 证书&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;自定义域仅包含手动 SSL 证书。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;考虑到 Cloud Run 是 knative 的 google cloud 托管版本，对于客户，则理论上在 Cloud Run 和 Cloud Run on GKE 之外还存在另外一种选择：直接使用开源版本的 knative。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/12c9e1173c8c479185aa9aadc5954302.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-serverless-whereverpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/12c9e1173c8c479185aa9aadc5954302.png&#34; alt=&#34;serverless-wherever.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      serverless-wherever.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者 google 之外的其他基于 knative 的产品，如 Redhat / IBM / Pivotal 等，从而避免了供应商锁定的风险。&lt;/p&gt;
&lt;p&gt;这也是 google 在宣传 Cloud Run 产品是一直反复强调的：开源、开放、不绑定。&lt;/p&gt;
&lt;p&gt;回到在 google cloud 上进行 serverless 平台选择这个话题，现在 google cloud 上的 serverless 有 function/app/container三种模式，而其中的 container 模式又可以细分为 Cloud Run 和 Cloud Run on GKE 两种形态，还有一个自由度极高可以自由发挥的 GKE。下图摘录自 google 的演讲 PPT，做了很好的分类和总结：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/575484dad6e1988bcb23bfe9b9208a7e.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-serverless-hosting-on-gcppng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/575484dad6e1988bcb23bfe9b9208a7e.png&#34; alt=&#34;serverless-hosting-on-gcp.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      serverless-hosting-on-gcp.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;cloud-run-的计费&#34;&gt;Cloud Run 的计费&lt;/h2&gt;
&lt;p&gt;最后关注一下 Cloud Run 的计费，Cloud Run 的官方文档 &lt;a href=&#34;https://cloud.google.com/run/pricing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pricing&lt;/a&gt; 对此有详细的描述，这里摘录部分内容。&lt;/p&gt;
&lt;p&gt;首先，完全托管式的 Cloud Run 仅为使用的资源收取费用，计费到最近的 100 毫秒。而 Cloud Run on GKE 则不同，GKE 上的 Cloud Run 是 Google Kubernetes Engine 集群的附加组件。而 Cloud Run on GKE 部署的工作量包含在 GKE 定价中。而 GKE 上 Cloud Run 的最终定价要到 GA 才确定。&lt;/p&gt;
&lt;p&gt;Cloud Run 的计费模型也颇具创新性，不是完全按请求数量计费，而是同时考量三个指标：CPU/内存/请求数量。搬运一下官方文档作为示意：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;CPU&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;Memory&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;Requests&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;Networking&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;First 180,000 vCPU-seconds free&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;First 360,000 GB-seconds free&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2 million requests free&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;Free during beta.&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;0.00002400/vCPU−secondsbeyondfreequota|0.00002400/vCPU−secondsbeyondfreequota|0.00000250 / GB-second beyond free quota&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;$0.40 / million requests beyond free quota&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;测试期间免费&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;按照这个计费模型，将 concurrency 设置为合适的数值（起码不是 1），让一个容器实例可以同时服务多个请求，分享 CPU 和内存，在费用上会更合适。另外上面的计费信息中可以看到，CPU/内存/请求数量都有免费配额，只有超过免费配额的使用才需要付费。免费配额会每月重置。&lt;/p&gt;
&lt;p&gt;Cloud Run 对可计费时间的计算比较良心，只有在容器实例有请求在处理时才计算，从第一个请求开始到最后一个请求结束。而容器实例启动的时间和空闲的时间不计算在内，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/e4ff1e6e6272e8ead0ef539c275559a3.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  id=&#34;figure-屏幕快照-2019-05-13-上午-95621png&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://ata2-img.cn-hangzhou.oss-pub.aliyun-inc.com/e4ff1e6e6272e8ead0ef539c275559a3.png&#34; alt=&#34;屏幕快照 2019-05-13 上午 9.56.21.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      屏幕快照 2019-05-13 上午 9.56.21.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;cloud-run-分析&#34;&gt;Cloud Run 分析&lt;/h2&gt;
&lt;p&gt;总结前面的功能介绍，我们可以看到，在 serverless 的常规特性和托管带来的运维便利之外，Cloud Run 的主要特性和卖点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拥抱容器生态&lt;/p&gt;
&lt;p&gt;将 serverless 与容器结合，极大的扩展了 serverless 的适用范围，对于 serverless 市场是一个巨大的创新。对于习惯使用容器/微服务技术的客户，可以更好的迁移过来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥抱社区&lt;/p&gt;
&lt;p&gt;基于开源的 knative，拉拢社区和盟友，通过 knative 实现 serverless 的标准化和平台化，解决了 serverless 市场碎片化的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;极佳的可迁移性&lt;/p&gt;
&lt;p&gt;为客户提供了没有供应商锁定风险的解决方案。理论上 客户可以根据实际需要选择完全托管的 Cloud Run 或 Cloud Run on GKE，或者开源版本的 knative，以及其他基于 knative 的托管平台，。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥抱云原生技术栈&lt;/p&gt;
&lt;p&gt;结合使用 servicemesh 技术和安全容器技术，配合容器/kubernetes，用 Cloud Native 技术栈打通了从底层到上层应用的通道。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结说，Cloud Run 是 Google Cloud 在 serverless 领域的全新尝试，具有创新的产品思路，未来的发展值得关注和借鉴。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;Cloud Run 刚刚发布才一个多月，目前能找到的资料不多，基本都是 Google Cloud放出来的新闻稿/博客和官方文档，还有Cloud Next 大会上的介绍演讲及 PPT。第三方的介绍文章非常的少，因此在调研和整理资料时不得不大量引用来自 Cloud Run 官方渠道的资料和图片。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/run/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Run 官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=gx8VTa1c8DA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Run Overview&lt;/a&gt;: 不到 2 分钟的介绍视频，官方宣传片&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=RVdhyprptTQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Differences between Cloud Run and Cloud Run on GKE&lt;/a&gt;: 官方视频，5 分钟长度，展示 cloud run 和 Cloud Run on GKE 之间的相同点和不同点。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.withgoogle.com/next/sf/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Next&amp;rsquo; 19 大会上和 serverless 相关的演讲&lt;/a&gt;：主要信息还是来自 Next&amp;rsquo; 19 的演讲，在这个页面中选择 &amp;ldquo;serverless&amp;rdquo; 会列出本次大会和 serverless 相关的演讲，大概十余个，视频可以回放，也提供 PPT 下载。（本文的大部分的信息和图片来自这些演讲内容），数量比较多就不一一列举了。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Knative 入门系列 2：serving 介绍</title>
      <link>https://cloudnative.to/blog/knative-serving/</link>
      <pubDate>Tue, 12 Mar 2019 11:17:13 +0800</pubDate>
      <guid>https://cloudnative.to/blog/knative-serving/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;译者：杨铁党、孙海洲、邱世达、宋净超、徐鹏&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative&lt;/a&gt; 是一个基于 Kubernetes 的，用于构建、部署和管理现代 serverless 应用的平台。Getting Started with Knative 是一本由 Pivotal 公司赞助 O’Reilly 出品的电子书，本书中文版由 ServiceMesher 社区自发翻译，这是该系列的第二篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即便使用无服务器架构，处理和响应 HTTP 请求的能力依然重要。在开始写代码使用事件触发一个函数之前，您需要有地方来运行代码。&lt;/p&gt;
&lt;p&gt;本章探讨 Knative Serving 组件，您将了解 Knative Serving 如何管理部署以及为应用和函数提供服务。通过 Serving，您可以轻松地将一个预先构建好的镜像部署到底层 Kubernetes 集群中。（在&lt;a href=&#34;https://cloudnative.to/getting-started-with-knative/serving.html&#34;&gt;第三章：Build&lt;/a&gt;，您将看到 Knative Build 可以帮助构建镜像以在 Serving 组件中运行）Knative Serving 维护某一时刻的快照，提供自动化伸缩功能 (既支持扩容，也支持缩容直至为零)，以及处理必要的路由和网络编排。&lt;/p&gt;
&lt;p&gt;Serving 模块定义一组特定的对象以控制所有功能：Revision（修订版本）、Configuration（配置）、Route（路由）和 Service（服务）。Knative 使用 Kubernetes CRD（自定义资源）的方式实现这些 Kubernetes 对象。下图 2-1 展示所有 Serving 组件对象模型间的关系。在接下去的章节将具体介绍每个部分。&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
&lt;img src=&#34;006tKfTcly1g0yrpiumcqj31230u0jxo.jpg&#34; alt=&#34;Serving Object Model&#34;/&gt;
&lt;/div&gt;
&lt;h2 id=&#34;configuration配置和-revision修订版本&#34;&gt;Configuration（配置）和 Revision（修订版本）&lt;/h2&gt;
&lt;p&gt;Knative Serving 始于 Configuration。您可以在 Configuration 中为部署定义所需的状态。最小化 Configuration 至少包括一个配置名称和一个要部署容器镜像的引用。在 Knative 中，定义的引用为 Revision。Revision 代表一个不变的，某一时刻的代码和 Configuration 的快照。每个 Revision 引用一个特定的容器镜像和运行它所需要的任何特定对象（例如环境变量和卷）。然而，您不必显式创建 Revision。由于 Revision 是不变的，它们从不会被改变和删除，相反，当您修改 Configuration 的时候，Knative 会创建一个 Revision。这允许一个 Configuration 既反映工作负载的当前状态，同时也维护一个它自己的历史 Revision 列表。&lt;/p&gt;
&lt;p&gt;以下&lt;a href=&#34;#example-2-1&#34;&gt;示例 2-1&lt;/a&gt; 展示了一个完整的 Configuration 定义。它指定一个 Revision，该 Revision 使用一个容器镜像仓库 URI 引用一个特定的镜像并且指定其版本标签。&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;example-2-1&#34;&gt;&lt;em&gt;示例 2-1. knative-helloworld/configuration.yml&lt;/em&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Configuration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revisionTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;container&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker.io/gswk/knative-helloworld:latest&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;MESSAGE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Knative!&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，您可以用一个简单的命令启用该 YAML 文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f configuration.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;自定义端口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，Knative 将假定您的应用程序监听 8080 端口。但是，如果不是这样的话，您可以通过 &lt;code&gt;containerPort&lt;/code&gt; 参数自定义一个端口：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revisionTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;container&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker.io/gswk/knative-helloworld:latest&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;MESSAGE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Knative!&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8081&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就像任意 Kubernetes 对象一样，您可以在系统中使用命令行工具（CLI）查阅 Revision 和 Configuration。您可以使用 &lt;code&gt;kubectl get revisions&lt;/code&gt; 和 &lt;code&gt;kubectl get configurations&lt;/code&gt; 得到它们的列表。获取我们刚刚创建&lt;a href=&#34;#example-2-1&#34;&gt;示例 2-1&lt;/a&gt; 的 Configuration，可以使用命令 &lt;code&gt;kubectl get configuration knative-helloworld -oyaml&lt;/code&gt;。这将以 YAML 形式显示该 Configuration 完整详情（如下&lt;a href=&#34;#example-2-2&#34;&gt;示例 2-2&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;example-2-2&#34;&gt;&lt;em&gt;示例 2-2. 命令 &lt;code&gt;kubectl get configuration knative-hellworld -oyaml&lt;/code&gt; 的输出&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Configuration&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;YYYY-MM-DDTHH:MM:SSZ&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;generation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serving.knative.dev/route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serving.knative.dev/service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ownerReferences&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;blockOwnerDeletion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;controller&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;9835040f-f29c-11e8-a238-42010a8e0068&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resourceVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;374548&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selfLink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/apis/serving.knative.dev/v1alpha1/namespaces\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    /default/configurations/knative-helloworld&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;987101a0-f29c-11e8-a238-42010a8e0068&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;generation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revisionTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;container&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker.io/gswk/knative-helloworld:latest&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;conditions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;lastTransitionTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;YYYY-MM-DDTHH:MM:SSZ&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;True&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Ready&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;latestCreatedRevisionName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld-00001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;latestReadyRevisionName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld-00001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;observedGeneration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意&lt;a href=&#34;#example-2-2&#34;&gt;示例 2-2&lt;/a&gt; 中 &lt;code&gt;status&lt;/code&gt; 小节，Configuration 控制器保持对最近创建和就绪 Revison 的追踪。它也包含了 Revision 的适用条件，表明它是否就绪以接收流量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Configuration 可以指定一个已有的容器镜像，如&lt;a href=&#34;#example-2-1&#34;&gt;示例 2-1&lt;/a&gt; 中所示。或者，它也可以选择指向一个 Build 资源以从源代码创建一个容器镜像。&lt;a href=&#34;./build.md&#34;&gt;第三章：Build&lt;/a&gt; 将介绍 Knative Build 组件的详情并提供一些示例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么在 Kubernetes 集群内部发生了什么？我们在 Configuration 中指定的容器镜像是什么样子？Knative 转换 Configuration 定义为一些 Kubernetes 对象并在集群中创建它们。在启用 Configuration 后，可以看到相应的 Deployment、ReplicaSet 和 Pod。&lt;a href=&#34;#example-2-3&#34;&gt;示例 2-3&lt;/a&gt; 展示了所有来自&lt;a href=&#34;#example-2-1&#34;&gt;示例 2-1&lt;/a&gt; 所创建的对象。&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;example-2-3&#34;&gt;&lt;em&gt;示例 2-3. Knative 创建的 Kubernetes 对象&lt;/em&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get deployments -oname
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deployment.extensions/knative-helloworld-00001-deployment
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get replicasets -oname
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;replicaset.extensions/knative-helloworld-00001-deployment-5f7b54c768
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods -oname
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pod/knative-helloworld-00001-deployment-5f7b54c768-lrqt5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们有了用于运行我们应用的 Pod，但是我们怎么知道该向哪里发送请求？这正是 Route 用武之地。&lt;/p&gt;
&lt;h2 id=&#34;route路由&#34;&gt;Route（路由）&lt;/h2&gt;
&lt;p&gt;Knative 中的 Route 提供了一种将流量路由到正在运行的代码的机制。它将一个命名的，HTTP 可寻址端点映射到一个或者多个 Revision。Configuration 本身并不定义 Route。&lt;a href=&#34;#example-2-4&#34;&gt;示例 2-4&lt;/a&gt; 展示了一个将流量发送到指定 Configuration 最新 Revision 的最基本路由定义。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span id=&#34;example-2-4&#34;&gt;示例 2-4. knative-helloworld/route.yml&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Route&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;traffic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;configurationName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;percent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就像我们对 Configuration 所做的那样，我们可以运行一个简单的命令应用该 YAML 文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f route.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个定义中，Route 发送 100% 流量到由 &lt;code&gt;configurationName&lt;/code&gt; 属性指定 Configuration 的最新就绪 Revision，该 Revision 由 Configuration YAML 中 &lt;code&gt;latestReadyRevisionName&lt;/code&gt; 属性定义。您可以通过发送如下 &lt;code&gt;curl&lt;/code&gt; 命令来测试这些 Route 和 Configuration：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Host: knative-routing-demo.default.example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;http://&lt;span class=&#34;nv&#34;&gt;$KNATIVE_INGRESS&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过使用 &lt;code&gt;revisionName&lt;/code&gt; 替代 &lt;code&gt;latestReadyRevisionName&lt;/code&gt; ，您可以锁定一个 Route 以发送流量到一个指定的 Revision。使用 &lt;code&gt;name&lt;/code&gt; 属性，您也可以通过可寻址子域名访问 Revision。&lt;a href=&#34;#example-2-5&#34;&gt;示例 2-5&lt;/a&gt; 同时展示两种场景。&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;example-2-5&#34;&gt;&lt;em&gt;示例 2-5. knative-routing-demo/route.yml&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Route&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-routing-demo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;traffic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;revisionName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-routing-demo-00001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;percent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以再一次使用简单命令应用该 YAML 文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f route.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;指定的 Revision 可以使用 &lt;code&gt;v1&lt;/code&gt; 子域名访问，如下 &lt;code&gt;curl&lt;/code&gt; 命令所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Host: v1.knative-routing-demo.default.example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;http://&lt;span class=&#34;nv&#34;&gt;$KNATIVE_INGRESS&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Knative 默认使用 &lt;code&gt;example.com&lt;/code&gt; 域名，但不适合生产使用。您会注意到在 &lt;code&gt;curl&lt;/code&gt; 命令 (v1.knative-routing-demo.default.example.com) 中作为一个主机头传递的 URL 包含该默认值作为域名后缀。URL 格式遵循模式 &lt;code&gt;{REVISION_NAME}.{SERVICE_NAME}.{NAMESPACE}.{DOMAIN}&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在这个案例中，子域名中 &lt;code&gt;default&lt;/code&gt; 部分指的是命名空间。您将在&lt;a href=&#34;./using-knative.md/#6.2&#34;&gt;第六章：部署注意事项&lt;/a&gt;一节中学习到如何改变这些值以及如何使用自定义域名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Knative 也允许以百分比的方式跨 Revision 进行流量分配。支持诸如增量发布、蓝绿部署或者其他复杂的路由场景。您将在&lt;a href=&#34;./using-knative.md&#34;&gt;第六章&lt;/a&gt;看到这些以及其他案例。&lt;/p&gt;
&lt;h3 id=&#34;autoscaler自动伸缩器和-activator激活器&#34;&gt;Autoscaler（自动伸缩器）和 Activator（激活器）&lt;/h3&gt;
&lt;p&gt;Serverless 的一个关键原则是可以按需扩容以满足需要和缩容以节省资源。Serverless 负载应当可以一直缩容至零。这意味着如果没有请求进入，则不会运行容器实例。Knative 使用两个关键组件以实现该功能。它将 Autoscaler 和 Activator 实现为集群中的 Pod。您可以看到它们伴随其他 Serving 组件一起运行在 &lt;code&gt;knative-serving&lt;/code&gt; 命名空间中（参见&lt;a href=&#34;#example-2-6&#34;&gt;示例 2-6&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;example-2-6&#34;&gt;&lt;em&gt;示例 2-6. &lt;code&gt;kubectl get pods -n knative-serving&lt;/code&gt; 输出&lt;/em&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                          READY     STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;activator-69dc4755b5-p2m5h    2/2       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          7h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;autoscaler-7645479876-4h2ds   2/2       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          7h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;controller-545d44d6b5-2s2vt   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          7h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;webhook-68fdc88598-qrt52      1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          7h
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Autoscaler 收集打到 Revision 并发请求数量的有关信息。为了做到这一点，它在 Revision Pod 内运行一个称之为 &lt;code&gt;queue-proxy&lt;/code&gt; 的容器，该 Pod 中也运行用户提供的 (user-provided) 镜像。可以在相应 Revision Pod 上，通过运行 &lt;code&gt;kubectl describe&lt;/code&gt; 命令可以看到这些容器 (参见&lt;a href=&#34;#example-2-7&#34;&gt;示例 2-7&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;example-2-7&#34;&gt;&lt;em&gt;示例 2-7. &lt;code&gt;kubectl describe pod knative-helloworld-00001-deployment-id&lt;/code&gt; 输出片段&lt;/em&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;user-container&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Container ID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker://f02dc...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;index.docker.io/gswk/knative-helloworld...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;queue-proxy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Container ID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker://1afcb...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gcr.io/knative-releases/github.com/knative...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;queue-proxy&lt;/code&gt; 检测该 Revision 上观察到的并发量，然后它每隔一秒将此数据发送到 Autoscaler。Autoscaler 每两秒对这些指标进行评估。基于评估的结果，它增加或者减少 Revision 部署的规模。&lt;/p&gt;
&lt;p&gt;默认情况下，Autoscaler 尝试维持每 Pod 每秒平均 100 个并发请求。这些并发目标和平均并发窗口均可以变化。Autoscaler 也能够被配置为利用 Kubernets HPA (Horizontal Pod Autoscaler) 来替代该默认配置。这将基于 CPU 使用率来自动伸缩但不支持缩容至零。这些设定都能够通过 Revision 元数据注解 (annotations) 定制。有关这些注解的详情，请参阅 &lt;a href=&#34;https://github.com/knative/docs/blob/master/serving/samples/autoscale-go/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative 文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;例如，一个 Revision 每秒收到 350 个请求并且每次请求大约需要处理 0.5 秒。使用默认设置 (每 Pod 100 个并发请求)，这个 Revision 将扩展至两个 Pod：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;350 * .5 = 175
175 / 100 = 1.75
ceil(1.75) = 2 pods
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Autoscaler 也负责缩容至零。Revision 处于 Active (激活) 状态才接受请求。当一个 Revision 停止接受请求时，Autoscaler 将其置为 Reserve (待命) 状态，条件是每 Pod 平均并发必须持续 30 秒保持为 0 (这是默认设置，但可以配置)。&lt;/p&gt;
&lt;p&gt;处于 Reserve 状态下，一个 Revision 底层部署缩容至零并且所有到它的流量均路由至 Activator。Activator 是一个共享组件，其捕获所有到待命 Revisios 的流量。当它收到一个到某一待命 Revision 的请求后，它转变 Revision 状态至 Active。然后代理请求至合适的 Pods。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Autoscaler 如何伸缩&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Autoscaler 采用的伸缩算法针对两个独立的时间间隔计算所有数据点的平均值。它维护两个时间窗，分别是 60 秒和 6 秒。Autoscaler 使用这些数据以两种模式运作：Stable Mode (稳定模式) 和 Panic Mode (忙乱模式)。在 Stable 模式下，它使用 60 秒时间窗平均值决定如何伸缩部署以满足期望的并发量。&lt;/p&gt;
&lt;p&gt;如果 6 秒窗口的平均并发量两次到达期望目标，Autoscaler 转换为 Panic Mode 并使用 6 秒时间窗。这让它更加快捷的响应瞬间流量的增长。它也仅仅在 Panic Mode 期间扩容以防止 Pod 数量快速波动。如果超过 60 秒没有扩容发生，Autoscaler 会转换回 Stable Mode。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span id=&#34;fingure-2-2&#34;&gt;&lt;em&gt;图 2-2 显示 Autoscaler 和 Activator 如何和 Routes 及 Revisions 协同工作。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;
&lt;img src=&#34;006tKfTcly1g0yrmo1t2cj31z70u0afi.jpg&#34; alt=&#34;Autoscaler and Activator with Route and Revision&#34; /&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;WARN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Autoscaler 和 Activator 均是 Knative 中快速演化的部分。参阅&lt;a href=&#34;https://github.com/knative/docs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最新 Knative 文档&lt;/a&gt;获取最近改进。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;服务&#34;&gt;服务&lt;/h2&gt;
&lt;p&gt;在 Knative 中，Service 管理负责的整个生命周期。包括部署、路由和回滚。（不要将 Knative Service 和 Kubernetes &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service&lt;/a&gt; 混淆。它们是不同的资源。）Knative Service 控制一系列组成软件的 Route 和 Configuration。Knative Service 可以被看作是一段代码 —— 您正在部署的应用或者函数。&lt;/p&gt;
&lt;p&gt;一个 Service 注意确保一个应用有一个 Route、一个 Configuation，以及为每次 Service 更新产生的一个新 Revision。当创建一个 Service 时，您没有特别定义一个 Route，Knative 创建一个发送流量到最新 Revision 的路由。您可以选择一个特定的 Revision 以路由流量到该 Revision。&lt;/p&gt;
&lt;p&gt;不要求您明确创建一个 Service。Route 和 Configuration 可以被分开在不同的 YAML 文件（如&lt;a href=&#34;#example-2-1&#34;&gt;示例 2-1&lt;/a&gt; 和 &lt;a href=&#34;#example-2-4&#34;&gt;示例 2-4&lt;/a&gt;）。在这种情形下，您可以应用每个单独的对象到集群。然而，推荐的方式使用一个 Service 来编排 Route 和 Configuration。&lt;a href=&#34;#example-2-8&#34;&gt;示例 2-8&lt;/a&gt; 所示文件用于替换来自&lt;a href=&#34;#example-2-1&#34;&gt;示例 2-1&lt;/a&gt; 和&lt;a href=&#34;#example-2-4&#34;&gt;示例 2-4&lt;/a&gt; 定义的 &lt;code&gt;configuation.yml&lt;/code&gt; 和 &lt;code&gt;route.yml&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;example-2-8&#34;&gt;&lt;em&gt;示例 2-8. knative-helloworld/service.yml&lt;/em&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runLatest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;configuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revisionTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;container&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker.io/gswk/knative-helloworld:latest&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意这个 &lt;code&gt;service.yml&lt;/code&gt; 文件和 &lt;code&gt;configuration.yml&lt;/code&gt; 非常相似。这个文件定义 Configuration 并且是最小化 Service 定义。由于这里没有 Route 定义，一个默认 Route 指向最新 Revision。Service 控制器整体追踪它所有的 configuration 和 Route 的状态。然后反映这些状态在它的 &lt;code&gt;ConfigurationsReady&lt;/code&gt; 和 &lt;code&gt;RoutesReady&lt;/code&gt; conditions 属性里。当通过 CLI 使用 &lt;code&gt;kubectl get ksvc&lt;/code&gt; 命令请求 Knative Service 信息的时候，这些状态可以被看到。&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;example-2-9&#34;&gt;&lt;em&gt;示例 2-9. &lt;code&gt;kubectl get ksvc knative-helloworld -oyaml&lt;/code&gt; 命令输出片段&lt;/em&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;conditions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;lastTransitionTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;YYYY-MM-DDTHH:MM:SSZ&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;True&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ConfigurationsReady&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;lastTransitionTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;YYYY-MM-DDTHH:MM:SSZ&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;True&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Ready&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;lastTransitionTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;YYYY-MM-DDTHH:MM:SSZ&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;True&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RoutesReady&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;domain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld.default.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;domainInternal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld.default.svc.cluster.local&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;latestCreatedRevisionName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld-00001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;latestReadyRevisionName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld-00001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;observedGeneration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;domainInternal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld.default.svc.cluster.local&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;traffic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;percent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revisionName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-helloworld-00001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;#example-2-9&#34;&gt;示例 2-9&lt;/a&gt; 显示这个命令的输出。&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;至此已经向您介绍了 Service、Route、Configuration 和 Revision。Revision 是不变的并且只能经由 Configuration 改变而被创建。您可以分别单独创建 Configuration 和 Route，或者把它们组合在一起并定义为一个 Service。理解 Serving 组件的这些构建块是使用 Knative 的基础。您部署的应用均需要一个 Service 或者 Configuration 以在 Knative 中作为容器运行。&lt;/p&gt;
&lt;p&gt;但是，如何打包您的源代码进入一个容器镜像以使用本章介绍的方式进行部署？&lt;a href=&#34;./build.md&#34;&gt;第三章&lt;/a&gt;将回答这些问题并且向您介绍 Knative Build 组件。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Knative 入门系列 1：knative 概述</title>
      <link>https://cloudnative.to/blog/knative-overview/</link>
      <pubDate>Mon, 11 Mar 2019 12:23:31 +0800</pubDate>
      <guid>https://cloudnative.to/blog/knative-overview/</guid>
      <description>&lt;p&gt;译者：陈佳栋、宋净超、孙海洲、徐鹏、邱世达&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative&lt;/a&gt; 是一个基于 Kubernetes 的，用于构建、部署和管理现代 serverless 应用的平台。&lt;em&gt;Getting Started with Knative&lt;/em&gt; 是一本由 Pivotal 公司赞助 O’Reilly 出品的电子书，本书中文版由 ServiceMesher 社区自发翻译，从今天起 ServiceMesher 社区将陆续为大家推出本书的中文译文。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-overview/006tKfTcly1g0yocivk0jj30p011iat3_hu15758598087756310532.webp 400w,
               /blog/knative-overview/006tKfTcly1g0yocivk0jj30p011iat3_hu18171000690409304684.webp 760w,
               /blog/knative-overview/006tKfTcly1g0yocivk0jj30p011iat3_hu14205888938796914056.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-overview/006tKfTcly1g0yocivk0jj30p011iat3_hu15758598087756310532.webp&#34;
               width=&#34;507&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Kubernetes 赢了。这不是夸大其词，事实就是如此。越来越多的人开始基于容器部署，而 Kubernetes 已经成为容器编排的事实标准。但是，Kubernetes 自己也承认，它是一个&lt;em&gt;容器&lt;/em&gt;而不是&lt;em&gt;代码&lt;/em&gt;平台。它可以作为一个运行和管理容器的很好的平台，但是这些容器是如何构建、运行、扩展和路由很大程度上是由用户自己决定的。这些是 Knative 想要补充的缺失部分。&lt;/p&gt;
&lt;p&gt;也许你已经在生产上使用 Kubernetes，或者你是一个前沿技术爱好者，梦想着将你基于 OS/2 运行的组织现代化。不管怎样，本报告都没有假定太多东西，只是要求您知道容器是什么，具有 Kubernetes 的一些基本知识，可以访问 Kubernetes 集群。如果这些您都不具备的话，那么 Minikube 是一个很好的选择。&lt;/p&gt;
&lt;p&gt;我们将使用大量代码示例和预先构建的容器镜像，这些镜像我们都为读者开源，您可以从 &lt;a href=&#34;http://github.com/gswk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://github.com/gswk&lt;/a&gt; 找到所有代码示例，并在 &lt;a href=&#34;http://hub.docker.com/u/gswk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://hub.docker.com/u/gswk&lt;/a&gt; 找到所有容器镜像。您还可以在 &lt;a href=&#34;http://gswkbook.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://gswkbook.com&lt;/a&gt; 找到这两个存储库以及其他重要参考资料的链接。&lt;/p&gt;
&lt;h2 id=&#34;目标读者&#34;&gt;目标读者&lt;/h2&gt;
&lt;p&gt;我们本质上是开发人员，所以这份报告主要是针对开发人员编写的。在整个报告中，我们将探索 serverless 架构模式，并向开发人员展示自服务用例示例（例如构建和部署代码）。然而，Knative 吸引了不同角色的技术人员。特别是，将 Knative 组件作为更大平台的一部分或与他们的系统集成的想法会引起运维和平台构建者们的极大兴趣。当这些受众探索如何使用 Knative 来实现其特定目的时，本报告将对他们非常有用。&lt;/p&gt;
&lt;h2 id=&#34;你将学到什么&#34;&gt;你将学到什么&lt;/h2&gt;
&lt;p&gt;尽管本报告并不旨在详解 Knative 的全部功能，但已足够深入，可以带您入门 Knative，了解它的工作原理和使用方式。初步了解了 Knative 后，我们将花一些时间研究如何使用它的每个主要组件。然后转到一些高级用例，最后通过构建一个真实的示例应用来结束，该应用将充分利用您在本报告中学到的所有知识。&lt;/p&gt;
&lt;h1 id=&#34;knative-概述&#34;&gt;Knative 概述&lt;/h1&gt;
&lt;p&gt;我们有一个信念：以平台的方式提供软件是一个最佳选择。事实证明，标准化的开发和部署流程能让开发人员更专注于新功能的研发，从而减少时间和金钱上的消耗。不仅如此，确保应用程序之间的一致性也意味着其更容易打补丁，更新和监控，从而让运维工作也更加高效。Knative 的目标就是成为这样的现代化平台。&lt;/p&gt;
&lt;h2 id=&#34;什么是-knative&#34;&gt;什么是 Knative&lt;/h2&gt;
&lt;p&gt;我们先来看看 Knative 的目标。Knative 的目标是在基于 Kubernetes 之上为整个开发生命周期提供帮助。它的具体实现方式是：首先使你作为开发人员能够以你想要的语言和以你想要的方式来编写代码，其次帮助你构建和打包应用程序，最后帮助你运行和伸缩应用程序。&lt;/p&gt;
&lt;p&gt;为此，Knative 将重点放在三个关键组件上：&lt;em&gt;build（构建）&lt;em&gt;你的应用程序，为其提供流量&lt;/em&gt;serving（服务）&lt;/em&gt;，以及确保应用程序能够轻松地生产和消费&lt;em&gt;event（事件）&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Build（构建）&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过灵活的插件化的构建系统将用户源代码构建成容器。目前已经支持多个构建系统，比如 Google 的 Kaniko，它无需运行 Docker daemon 就可以在 Kubernetes 集群上构建容器镜像。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Serving（服务）&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基于负载自动伸缩，包括在没有负载时缩减到零。允许你为多个修订版本（revision）应用创建流量策略，从而能够通过 URL 轻松路由到目标应用程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Event（事件）&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使得生产和消费事件变得容易。抽象出事件源，并允许操作人员使用自己选择的消息传递层。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Knative 是以 Kubernetes 的一组自定义资源类型（CRD）的方式来安装的，因此只需使用几个 YAML 文件就可以轻松地开始使用 Knative 了。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;Kubernetes 知识&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;由于 Knative 是基于 Kubernetes 的一系列扩展，因此建议你先了解下 Kubernetes 和 Docker 的架构和术语。今后我们会提及以下术语，比如 namespace、Deployment、ReplicaSet 和 Pod。熟悉这些 Kubernetes 术语将帮助你在阅读时更好地理解 Knative 的基本工作。如果你对这些都不熟悉，那么这两个链接：&lt;a href=&#34;https://kubernetes.io/docs/tutorials/kubernetes-basics/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 和 &lt;a href=&#34;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#objectreference-v1-core&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker&lt;/a&gt; 上都有很棒的培训材料，可以直接在浏览器上阅读。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;无服务器架构serverless&#34;&gt;无服务器架构（serverless）？&lt;/h2&gt;
&lt;p&gt;到目前为止，我们已经讨论了应用程序的容器化。但都 2019 年了，我们读了半章却还没有提到“无服务器架构（serverless）”这个词。也许作为当今技术中被提到最多的一个词，无服务器架构（serverless）仍然在寻找一个整个行业都能认同的定义。许多人都同意这个理念的影响最大的是代码量，比如以前需要编写大型、单一的应用程序，现在你只需编写通过&lt;em&gt;事件&lt;/em&gt;来调用的小型、单一用途的&lt;em&gt;函数&lt;/em&gt;即可。这些&lt;em&gt;事件&lt;/em&gt;可以简单到是一个 HTTP 请求或一个来自消息通道（如 Apache Kafka）的消息。同时&lt;em&gt;事件&lt;/em&gt;也可能是间接的，比如这些操作：将图像上传到 Google Cloud Storage 或更新了 Amazon 的 DynamoDB 中的一张表。&lt;/p&gt;
&lt;p&gt;许多人也都同意这表示着你的代码只在处理请求时才用到计算资源。对于很多托管服务来说，如 Amazon 的 Lambda 或 Google Cloud Functions，这意味着你只需要为活跃期间的计算服务付费，而不是一台 7x24 小时运行并可能在大部分时间内无所事事的虚拟机。在本地或非托管的无服务器架构（serverless）平台上，则表示代码可以只在需要时运行，在不需要时就停止，从而让你的基础设施能在其他方面自由使用计算资源。&lt;/p&gt;
&lt;p&gt;在这些基础原理之上的是一场圣战。有些人坚持无服务器架构（serverless）只适合在托管的云环境中运行，在本地运行这样的平台完全是不对的。其他人则认为它更像是一种哲学理论上的设计。也许这些定义最后会合并，也许不会。就目前来说，随着无服务器架构（serverless）普及率的持续增长，Knative 最有可能成为其标准。&lt;/p&gt;
&lt;h2 id=&#34;为什么是-knative&#34;&gt;为什么是 Knative？&lt;/h2&gt;
&lt;p&gt;除了关于无服务器架构（serverless）定义的争论之外，下一个逻辑问题是“为什么创造的是 Knative？”随着基于容器的架构的流行和 Kubernetes 的普及，我们又开始见到一些相同的问题，这些问题之前也出现在平台即服务（PaaS）方案上并推动了其发展。如在构建容器时，我们该如何保证其一致性？谁负责给所有东西打补丁？如何根据需求来伸缩？如何实现零停机部署？&lt;/p&gt;
&lt;p&gt;虽然 Kubernetes 确实已经演进并开始解决其中一些问题，但是之前提到的关于不断发展的无服务器架构（serverless）的概念方面产生了更多的问题。如何管理多个事件类型的一致性？如何定义事件源和目标？&lt;/p&gt;
&lt;p&gt;许多无服务器架构（serverless）或函数即服务（FaaS）框架都尝试回答这些问题，但它们都在用不同的方式来解决问题，且不是所有的解决方案都用到了 Kubernetes。而 Knative 构建在 Kubernetes 的基础上，并为构建和部署无服务器架构（serverless）和基于事件驱动的应用程序提供了一致的标准模式。Knative 减少了这种新的软件开发方法所产生的开销，同时还把路由（routing）和事件（eventing）的复杂性抽象出来。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;现在我们已经很好地理解了什么是 Knative 以及它被创造出来的原因，接下来我们将进一步深入了解它。下一章将介绍 Knative 的三个关键组件。我们将详细研究它们，并解释它们是如何协同工作的，以及如何充分发挥它们的潜力。之后，我们将了解如何在 Kubernetes 集群上安装 Knative 和一些更高级的用例。最后，我们将通过演示一个 demo 来展示你能在这个报告中学习到的大部分内容。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Knative：精简代码之道</title>
      <link>https://cloudnative.to/blog/knative-whittling-down-the-code/</link>
      <pubDate>Fri, 01 Mar 2019 10:40:18 +0800</pubDate>
      <guid>https://cloudnative.to/blog/knative-whittling-down-the-code/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://content.pivotal.io/blog/knative-whittling-down-the-code&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;[&lt;strong&gt;编者案&lt;/strong&gt;]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Knative 作为 Google 发起开源的 serverless 项目，给我们提供了一套简单易用的 serverless 开源解决方案。本文作者直观地向我们展示了如何使用 Knative 来一步一步逐渐精简我们的代码，来更加简单容易的开发云原生应用。作者使用实例来逐步向我们讲述如何使用 Knative 提供的 Build、Serving 和 Eventing 三大组件来发挥威力，逐渐精简代码。如果您对 Knative 有兴趣，本文对于你通过 Knative 实践 serverless 一定会有所启发，希望您能喜欢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对我来说，2018 年最好的开源项目是&lt;strong&gt;Knative&lt;/strong&gt;，这是一个建立在 Kubernetes 之上的 serverless 平台。不仅是为了 serverless 平台本身，也是为了它所倡导的整个开发范式。事件驱动开发并不新鲜，但 Knative 为围绕事件构建生态系统奠定了基础。&lt;/p&gt;
&lt;p&gt;如果您不熟悉 Knative，那么您读到的任何文档都将它分为三大组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建 (Build) —— 我如何构建代码和打包代码？&lt;/li&gt;
&lt;li&gt;服务 (Serving) —— 我的代码如何为请求提供服务？它是如何伸缩的？&lt;/li&gt;
&lt;li&gt;事件 (Eventing) —— 我的代码如何被各种事件触发？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事实上这并不是一篇“Knative 入门”的文章 (在不久的将来会有更多关于这方面的&lt;a href=&#34;https://twitter.com/BrianMMcClain/status/1086006073503481864?s=20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;内容&lt;/a&gt;)，但是我最近一直在思考的是，随着开发人员越来越多地利用 Knative 提供的功能，他们如何减少自己需要编写的代码。这是最近 Twitter 上一个特别热门的话题，尤其是在 KubeCon 时代。我注意到的一个常见问题是，“如果您正在编写 Dockerfile，它真的是一个 serverless 的平台吗？”但是，其他人认为将代码打包为容器可能是最合理的解决方案，因为它是可移植的、全面的，并且具有所有依赖项。不乏强烈持有这种观点的人们，他们非常渴望争辩。&lt;/p&gt;
&lt;p&gt;与其火上浇油，不如让我们看看 Knative 给开发人员提供了哪些选项来逐渐减少我们编写的代码量。我们将从最冗长的示例开始—我们自己构建的预构建容器（prebuilt container）。从这里开始，我们将逐渐减少基准代码量，减少构建自己的容器的需要，减少编写自己的 Dockerfile 的需要，最后减少编写自己的配置的需要。最重要的是，我们将看到 Pivotal Function Service (PFS) 的强大功能，以及它如何允许开发人员关注代码而不是配置。&lt;/p&gt;
&lt;p&gt;我们将看到的所有代码都包含在两个 git repos 中：&lt;a href=&#34;https://github.com/BrianMMcClain/knative-hello-world&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;knative-hello-world&lt;/a&gt;和&lt;a href=&#34;https://github.com/BrianMMcClain/pfs-hello-world&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pfs-hello-world&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;预构建prebuilt的-docker-容器&#34;&gt;预构建（Prebuilt）的 Docker 容器&lt;/h2&gt;
&lt;p&gt;我们将看到的第一个场景是为 Knative 提供一个预构建的容器镜像，该镜像已经上传到我们选择的容器镜像库。您将在 Knative 中看到的大多数&lt;a href=&#34;https://github.com/knative/docs/tree/master/serving/samples/helloworld-nodejs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hello World&lt;/a&gt;示例都采用直接构建和管理容器的方式。这是有意义的，因为它很容易理解，而且没有引入很多新概念，这是一个很好的起点。这个概念非常简单直接：传给 Knative 一个暴露端口的容器，它将处理剩余的所有事情。它不关心你的代码是用&lt;a href=&#34;https://github.com/knative/docs/tree/master/serving/samples/helloworld-go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go&lt;/a&gt;、&lt;a href=&#34;https://github.com/knative/docs/tree/master/serving/samples/helloworld-ruby&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ruby&lt;/a&gt;还是&lt;a href=&#34;https://github.com/knative/docs/tree/master/serving/samples/helloworld-java&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Java&lt;/a&gt;写的;它会接收传入的请求并将它们发送到你的应用程序。&lt;/p&gt;
&lt;p&gt;让我们从一个使用&lt;a href=&#34;https://expressjs.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Express web&lt;/a&gt;框架基于 node.js 实现的 hello world 应用程序开始。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;express&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bodyParser&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;require&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;body-parser&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;express&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bodyParser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;*/*&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;post&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nx&#34;&gt;res&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Hello, &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;port&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nx&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Server started on port&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;是不是漂亮且简洁。这段代码将启动一个 web 服务器，监听端口 8080(除非端口已被占用)，并通过返回 Hello 来响应 HTTP POST 请求。当然，还需要 package.json 文件，它定义了一些东西 (如何启动应用程序，依赖关系等)，但这有点超出了我们所看到的范围。另一部分是 Dockerfile，它描述如何将所有内容打包到一个容器中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; node:10.15.1-stretch-slim&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WORKDIR&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; /usr/src/app&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; . .&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;RUN&lt;/span&gt; npm install&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENV&lt;/span&gt; PORT &lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;EXPOSE&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; $PORT&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENTRYPOINT&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;npm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里也没什么好惊讶的。我们将我们的镜像建立在官方 node.js 镜像的基础之上，将我们的代码复制到容器中并安装依赖项，然后告诉它如何运行我们的应用程序。剩下的就是将其上传到 Docker Hub。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker build . -t brianmmcclain/knative-hello-world:prebuilt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker push brianmmcclain/knative-hello-world:prebuilt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果您曾经在类似于 Kubernetes 的应用程序上运行过，那么所有这些看起来应该非常熟悉。将代码放入容器中，让调度器处理以确保它处于正常状态。我们可以告诉 Knative 关于这个容器的信息，再加上一点 metadata，它会处理所有的东西。随着请求数量的增长，它将扩展实例的数量，缩减到 0，路由请求，连接事件——竭尽所能。我们真正需要告诉 Knative 的是调用我们的应用程序，运行它的名称空间，以及容器镜像的位置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-hello-world-prebuilt&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runLatest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;configuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revisionTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;container&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker.io/brianmmcclain/knative-hello-world:prebuilt&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;$ kubectl apply -f 01-prebuilt.yaml&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;几分钟后，我们将看到一个新的 pod 运行起来，准备为请求服务，如果在一段时间内没有收到任何流量，Pod 数量将会缩减为 0。我们可以 POST 一些数据，看看我们收到的响应。首先，让我们获取 Kubernetes 集群的 Ingress IP，并将其分配给$SERVICE_IP 变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;SERVICE_IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;kubectl get svc istio-ingressgateway -n istio-system -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.status.loadBalancer.ingress[*].ip}&amp;#34;&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后使用 IP 向我们的服务发送请求，在我们的请求中设置 HOST header:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl -XPOST http://&lt;span class=&#34;nv&#34;&gt;$SERVICE_IP&lt;/span&gt; -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Host: knative-hello-world-prebuilt.default.example.com&amp;#34;&lt;/span&gt; -d &lt;span class=&#34;s2&#34;&gt;&amp;#34;Prebuilt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Hello, Prebuilt!&lt;/p&gt;
&lt;h2 id=&#34;kaniko-容器构建器&#34;&gt;Kaniko 容器构建器&lt;/h2&gt;
&lt;p&gt;上面介绍的一切可以很好的工作，但是我们甚至还没有开始接触 Knative 的“Build”部分。实际上，我们没有碰它，我们自己构建了这个容器。您可以在 Knative 文档中&lt;a href=&#34;https://github.com/knative/docs/tree/master/build&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;阅读所有关于构建&lt;/a&gt;以及它们如何工作的信息。总的来说，knative 有一个名为&lt;a href=&#34;https://github.com/knative/docs/blob/master/build/build-templates.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;“Build Templates”&lt;/a&gt;的概念，我喜欢这样描述他们：他们是关于如何从代码到容器的可共享逻辑。这些构建模板中的大多数模板都能够完成我们构建容器和上传镜像的需要。这些模板中最基本的可能是&lt;a href=&#34;https://github.com/knative/build-templates/tree/master/kaniko&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kaniko Build Templates&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;顾名思义，它基于谷歌的&lt;a href=&#34;https://github.com/GoogleContainerTools/kaniko&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kaniko&lt;/a&gt;, Kaniko 是在容器中构建容器镜像的工具，不依赖于正在运行的 Docker 守护进程。向 Kaniko 容器镜像提供 Dockerfile 和一个上传结果的位置，它就可以据此构建镜像。我们无需拉取代码、在本地构建镜像、上传到 Docker Hub，然后从 Knative 拉取镜像，我们可以让 Knative 为我们做这些，只需要多做一点配置。&lt;/p&gt;
&lt;p&gt;但是，在执行此操作之前，我们需要告诉 Knative 如何根据容器注册中心进行身份验证。为此，我们首先需要在 Kubernetes 中创建一个 Secret，这样我们就可以对 Docker Hub 进行身份验证，然后创建一个服务帐户来使用该 Secret 并运行构建。让我们从创造 Secret 开始：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Secret&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;dockerhub-account&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;build.knative.dev/docker-0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;https://index.docker.io/v1/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubernetes.io/basic-auth&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# &amp;#39;echo -n &amp;#34;username&amp;#34; | base64&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;username&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;dXNlcm5hbWUK&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# &amp;#39;echo -n &amp;#34;password&amp;#34; | base64&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;cGFzc3dvcmQK&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;uesrname 和 password 作为 base64 编码的字符串发送给 Kubernetes。（对于有安全意识的读者来说，这是一种传输机制，而不是安全机制。有关 Kubernetes 如何存储 Secret 的更多信息，请在有空时查看关于&lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;on encrypting secret data at rest&lt;/a&gt;）。提交之后，我们将创建一个名为 build-bot 的服务帐户，并告诉它在推送到 Docker Hub 时使用这个 Secret：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ServiceAccount&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;build-bot&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;secrets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;dockerhub-account&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有关身份验证的更多信息，请确保查看 knative 文档中的&lt;a href=&#34;https://github.com/knative/docs/blob/master/build/auth.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;how-authentication-work -in- knative&lt;/a&gt;文档。&lt;/p&gt;
&lt;p&gt;构建模板 (Build Templates) 的好处是任何人都可以创建并与社区共享它们。我们可以告诉 Knative 通过传递一些 YAML 来安装这个构建模板：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f https://raw.githubusercontent.com/knative/build-templates/master/kaniko/kaniko.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后我们需要在我们的应用 YAML 中添加更多：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-hello-world-kaniko&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runLatest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;configuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceAccountName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;build-bot&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;source&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;git&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;https://github.com/BrianMMcClain/knative-hello-world.git&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revision&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;master&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kaniko&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;arguments&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;IMAGE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker.io/brianmmcclain/knative-hello-world:kaniko&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revisionTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;container&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker.io/brianmmcclain/knative-hello-world:kaniko&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然直接比较有点困难，但是我们实际上只向 YAML 中添加了一个部分—“Build”部分。我们添加的内容可能看起来很多，但如果你花时间逐条查看的话，它实际上并不坏：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;serviceAccountName：在 Knative auth 文档中，它遍历了设置服务帐户的过程。所有这些都是通过设置一个 Kubernetes Secret 来验证我们的容器镜像库，然后将其封装到一个服务帐户中。&lt;/li&gt;
&lt;li&gt;source：代码所在的位置。例如，git repository。&lt;/li&gt;
&lt;li&gt;template：要使用哪个 Build Template。在本例中，我们将使用 Kaniko Build Template。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们向应用程序的新版本发送一个请求，以确保一切正常：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl -XPOST http://&lt;span class=&#34;nv&#34;&gt;$SERVICE_IP&lt;/span&gt; -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Host: knative-hello-world-kaniko.default.example.com&amp;#34;&lt;/span&gt; -d &lt;span class=&#34;s2&#34;&gt;&amp;#34;Kaniko&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Hello, Kaniko!&lt;/p&gt;
&lt;p&gt;尽管这可能是一种更预先的配置，但权衡的结果是，现在我们不必每次更新代码时都构建或推送我们自己的容器镜像。相反，Knative 将为我们处理这些步骤！&lt;/p&gt;
&lt;h2 id=&#34;buildpack-build-template&#34;&gt;Buildpack Build Template&lt;/h2&gt;
&lt;p&gt;所以，这个博客的重点是我们如何编写更少的代码。虽然我们已经使用 Kaniko Build Template 删除了部署的一个操作组件，但是我们仍然在代码之上维护一个 Dockerfile 和一个配置文件。但是如果我们可以抛弃 Dockerfile 呢？&lt;/p&gt;
&lt;p&gt;如果您具有使用 PaaS 的习惯，那么您可能已经习惯了简单地向上推代码，然后发生了一些神奇的事情，然后您就有了一个正常工作的应用程序。你不在乎这是怎么做到的。我们所知道的是，您不必编写 Dockerfile 来将其放入容器中，而且它可以正常工作。在&lt;a href=&#34;https://www.cloudfoundry.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Foundry&lt;/a&gt;，这是通过名为&lt;a href=&#34;https://docs.cloudfoundry.org/buildpacks/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;buildpacks&lt;/a&gt;的框架实现的，该框架为应用程序提供运行时和依赖项。&lt;/p&gt;
&lt;p&gt;实际上给我们带来两大好处。不仅有一个使用 buildpacks 的 Build Template，还有一个用于 Node.js 的 buildpacks。就像 Kaniko Build Template 一样，我们将在 Knative 中安装 buildpack Build Template：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f https://raw.githubusercontent.com/knative/build-templates/master/buildpack/buildpack.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，让我们看看使用 Buildpack Build Template 的 YAML 是什么样子的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;knative-hello-world-buildpack&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runLatest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;configuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceAccountName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;build-bot&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;source&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;git&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;https://github.com/BrianMMcClain/knative-hello-world.git&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revision&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;master&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;buildpack&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;arguments&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;IMAGE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker.io/brianmmcclain/knative-hello-world:buildpack&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revisionTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;container&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker.io/brianmmcclain/knative-hello-world:buildpack&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这与我们使用 Kaniko Build Template 时非常相似。实际上，我们来做个比较：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;&amp;lt;   name: knative-hello-world-kaniko
&amp;gt;   name: knative-hello-world-buildpack
---
&amp;lt;           name: kaniko
&amp;gt;           name: buildpack
---
&amp;lt;             value: docker.io/brianmmcclain/knative-hello-world:kaniko
&amp;gt;             value: docker.io/brianmmcclain/knative-hello-world:buildpack
---
&amp;lt;             image: docker.io/brianmmcclain/knative-hello-world:kaniko
&amp;gt;             image: docker.io/brianmmcclain/knative-hello-world:buildpack
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么区别是什么呢？首先，我们可以完全抛弃 Dockerfile。Buildpack  Build Template 将分析我们的代码，确定它是一个 Node.js 应用程序，并通过下载 Node.js 运行时和依赖项为我们构建一个容器。虽然 Kaniko Build Template 将我们从 Docker 容器生命周期的管理工作中解放出来，但 Buildpack Build Template 更进一步，完全不需要管理 Dockerfile 了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f 03-buildpack.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;service.serving.knative.dev &lt;span class=&#34;s2&#34;&gt;&amp;#34;knative-hello-world-buildpack&amp;#34;&lt;/span&gt; configured
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl -XPOST http://&lt;span class=&#34;nv&#34;&gt;$SERVICE_IP&lt;/span&gt; -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Host: knative-hello-world-buildpack.default.example.com&amp;#34;&lt;/span&gt; -d &lt;span class=&#34;s2&#34;&gt;&amp;#34;Buildpacks&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Hello, Buildpacks!
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;pivotal-function-service&#34;&gt;Pivotal Function Service&lt;/h3&gt;
&lt;p&gt;让我们检查一下代码库的剩余部分。我们有响应 POST 请求的 Node.js 代码，使用 Express 框架设置 web 服务器。package.json 文件定义了我们的依赖项。虽然这不是真正的代码，但我们也在维护定义 Knative 服务的 YAML。不过，我们可以继续削减。&lt;/p&gt;
&lt;p&gt;进入&lt;a href=&#34;https://pivotal.io/platform/pivotal-function-service&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pivotal Function Service&lt;/a&gt; (PFS)，这是构建在 Knative 之上的 Pivotal 的商业 serverless 产品。PFS 旨在消除管理代码以外的任何东西的需要。这包括我们在代码库中管理自己的 web 服务器。使用 PFS，我们的代码如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-code&#34; data-lang=&#34;code&#34;&gt;module.exports = x =&amp;gt; &amp;#34;Hello, &amp;#34; + x + &amp;#34;!&amp;#34;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就是这样，没有 Dockerfile，没有 YAML。只要一行代码。当然，像所有优秀的节点开发人员一样，我们仍然需要有自己的 package.json 文件，尽管它不依赖于 Express。一旦部署完毕，riff 将使用这一行代码并将其封装在自己的托管容器镜像中。它将把它与调用&lt;a href=&#34;https://github.com/projectriff/riff-buildpack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;代码所需的逻辑&lt;/a&gt;打包在一起，并像运行在 Knative 上的任何其他函数一样提供服务。&lt;/p&gt;
&lt;p&gt;PFS CLI 使得部署我们的函数变得非常容易。我们将给函数命名为 pfs-hello-world，为它提供到代码所在的 GitHub 存储库的链接，并告诉它将生成的容器映像上传到我们的私有容器镜像库中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;pfs &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; create pfs-hello-world --git-repo https://github.com/BrianMMcClain/pfs-hello-world.git --image &lt;span class=&#34;nv&#34;&gt;$REGISTRY&lt;/span&gt;/&lt;span class=&#34;nv&#34;&gt;$REGISTRY_USER&lt;/span&gt;/pfs-hello-world --verbose
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;几分钟后，我们将看到我们的函数进入运行状态，我们可以像任何其他 Knative 函数一样，向其发送请求：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl -XPOST http://&lt;span class=&#34;nv&#34;&gt;$SERVICE_IP&lt;/span&gt; -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Host: pfs-hello-world.default.example.com&amp;#34;&lt;/span&gt; -H &lt;span class=&#34;s2&#34;&gt;&amp;#34;Content-Type: text/plain&amp;#34;&lt;/span&gt; -d &lt;span class=&#34;s2&#34;&gt;&amp;#34;PFS&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Hello, PFS!&lt;/p&gt;
&lt;p&gt;或者，更简单的是，使用 riff CLI 来调用我们的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ pfs service invoke pfs-hello-world --text -- -d &lt;span class=&#34;s2&#34;&gt;&amp;#34;PFS CLI&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Hello, PFS CLI!&lt;/p&gt;
&lt;p&gt;我们终于实现了目标！由 23 行 YAML、14 行代码和一个 10 行 Dockerfile 组成的简化代码行。&lt;/p&gt;
&lt;p&gt;是不是一下子对 PFS 感兴趣了呢？要申请提前访问，只需填写这张&lt;a href=&#34;https://pivotal.io/platform/pivotal-function-service&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;快速表格&lt;/a&gt;!&lt;/p&gt;
&lt;h2 id=&#34;接下来工作&#34;&gt;接下来工作？&lt;/h2&gt;
&lt;p&gt;越来越多的构建模板。这是 Knative 最令人兴奋的特性之一，因为它有很大的潜力为各种场景打开一个自定义构建模板的社区。现在，您可以为&lt;a href=&#34;https://github.com/knative/build-templates/tree/master/jib&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jib&lt;/a&gt;和&lt;a href=&#34;https://github.com/knative/build-templates/tree/master/buildkit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BuildKit&lt;/a&gt;等工具使用模板。已经有一个&lt;a href=&#34;https://github.com/knative/build-templates/pull/67&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pull request&lt;/a&gt;来更新 Buildpack 构建模板，以支持&lt;a href=&#34;https://buildpacks.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Native Buildpacks&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2018 年是一个激动人心的开始，但是更让我兴奋的是看到 Knative 社区在 2019 年的增长。我们当然可以期望从社区获得更多的构建模板和更多的事件源。不仅如此，我们还可以期望与现有技术更好地集成，例如 Spring，&lt;a href=&#34;https://www.youtube.com/watch?v=zCObFAhrhJM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;它已经对此功能提供了强大的支持&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果您希望开始使用 Knative 进行开发，那么 Bryan Friedman 和我将在 2 月 21 日主持一个很棒的网络研讨会，讨论&lt;a href=&#34;https://content.pivotal.io/webinars/feb-21-developing-serverless-applications-on-kubernetes-with-knative-webinar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;developing serverless applications on Kubernetes with Knative&lt;/a&gt;。我们将深入研究 Knative 的三个组件，它们是如何工作的，以及作为开发人员如何利用它们来编写更好的代码。&lt;/p&gt;
&lt;p&gt;如果你 4 月 2-4 日在费城，请加入我们的&lt;a href=&#34;https://www.cloudfoundry.org/event/nasummit2019/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CF Summit&lt;/a&gt;! Bryan 和我将讨论&lt;a href=&#34;https://cfna19.sched.com/event/KJD9&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;the way to build serverless on Knative&lt;/a&gt;，或者如果您看到我们，就说声 hi!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Knative Eventing in-memory-channel 实现原理解析</title>
      <link>https://cloudnative.to/blog/knative-eventing-in-memory-channel-deep-dive/</link>
      <pubDate>Fri, 22 Feb 2019 14:08:59 +0800</pubDate>
      <guid>https://cloudnative.to/blog/knative-eventing-in-memory-channel-deep-dive/</guid>
      <description>&lt;p&gt;关于 Knative eventing 的基本概念可以参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/docs/blob/master/eventing/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/knative/docs/blob/master/eventing/README.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://thenewstack.io/knative-enables-portable-serverless-platforms-on-kubernetes-for-any-cloud/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://thenewstack.io/knative-enables-portable-serverless-platforms-on-kubernetes-for-any-cloud/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文不对基本概念做介绍，本文主要是基于 &lt;a href=&#34;https://github.com/knative/docs/blob/master/eventing/samples/kubernetes-event-source/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Event Source example&lt;/a&gt; 为例分析 &lt;a href=&#34;https://github.com/knative/eventing/tree/master/config/provisioners/in-memory-channel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;in-memory-channel&lt;/a&gt; 的实现原理。&lt;/p&gt;
&lt;p&gt;在运行 &lt;a href=&#34;https://github.com/knative/docs/blob/master/eventing/samples/kubernetes-event-source/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Event Source example&lt;/a&gt; 之前要保证已经安装了 &lt;a href=&#34;https://github.com/knative/eventing/tree/master/config/provisioners/in-memory-channel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;in-memory-channel&lt;/a&gt; , 下面先从 in-memory-channel controller 开始介绍 channel 的工作机制。&lt;/p&gt;
&lt;h2 id=&#34;in-memory-channel-controller&#34;&gt;in-memory-channel controller&lt;/h2&gt;
&lt;p&gt;in-memory-channel 安装好以后就会自动创建一个 controller 和 in-memory-channel-dispatcher。dispatcher 启动 http 服务接受 event，并根据 event 所属 channel 自动寻找相关的 subscription 然后把事件发送出去。因为这是一个基于内存实现的 channel 所以仅仅是转发一下事件不能用于生产环境，在生产环境可以使用 gcppubsub、kafka 以及 natss 等存储介质。&lt;/p&gt;
&lt;p&gt;in-memory-channel controller 监听 channel 资源如果发现有 channel 的 provisioner 是自己就开始做 EventResource 到 channel 的 feed(目前是基于 istio 的 virtualService 实现的)&lt;/p&gt;
&lt;p&gt;通过上面的介绍我们发现 channel 其实是一个虚拟的概念作用仅仅是提供一个分组功能，有点儿像是 kubernetes 中的 service 的概念，channel 的作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供一种事件从事件源路由到 consumer 的介质&lt;/li&gt;
&lt;li&gt;绑定事件源和 channel (sink)&lt;/li&gt;
&lt;li&gt;把 consumer 绑定到 channel(subscription)&lt;/li&gt;
&lt;li&gt;把接收到的消息 dispatch 到相应的 subscription&lt;/li&gt;
&lt;li&gt;channel 是可以有自己的后端存储的，自己的后端存储可以是任何消息中间件，in-memory 只保存在内存中&lt;/li&gt;
&lt;li&gt;目前 channel 接收和 dispatch eventing 都是基于 http 协议的 (&lt;a href=&#34;https://github.com/cloudevents/spec/blob/v0.1/spec.md#protocol&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CloudEvent 在设计上是支持很多协议的&lt;/a&gt;， &lt;a href=&#34;https://github.com/knative/eventing/blob/master/docs/spec/interfaces.md#addressable&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;但是目前 knative 只实现了 http 协议&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;in-memory channel controller 发现如果有 channel 的 provisioner 是 ClusterChannelProvisioner 会做如下三件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建一个 service，这个 service 就是 event Resource 向自己发送事件时使用的 service，并且 service 会写入到 channel 的 Status.Address.Hostname 字段。channel 这是一个&lt;a href=&#34;https://github.com/knative/eventing/blob/master/docs/spec/interfaces.md#addressable&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;地址可达&lt;/a&gt;的资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个 Istio 的 VirtualService，作用是把 Channel 的 service 转换到 in-memory channel dispatcher service 从而达到 channel 和 provisioner &lt;em&gt;绑定&lt;/em&gt; 的效果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 Channel 的 subscriptions&lt;/p&gt;
&lt;p&gt;不过配置 subscriptions 的动作不是在接收到 channel cr 的时候触发的。in-memory-channel controller 会 watch subscriptions 资源，当有 subscriptions 创建或者修改的时候就把相关的 subscription 绑定到 channel 上 ( &lt;a href=&#34;https://github.com/knative/eventing/blob/master/docs/spec/spec.md#group-eventingknativedevv1alpha1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;subscribable.subscribers&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;创建一个-testchannel&#34;&gt;创建一个 testchannel&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;创建 channel&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;eventing.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Channel&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;testchannel&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;provisioner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;eventing.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterChannelProvisioner&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;in-memory-channel&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;channel 定义中的 provisioner 是 channel 的实现实体 (如果把 channel 比喻成 service/endpoint 的话那么 provisioner 就相当于是 service 对应的 Pod)。channel 本身其实只是一个概念、一个定义。具体的实现都是 provisioner 来做的。channel 使用哪个 provisioner 就相当于是使用哪一种实现（是不是有一种 StorageClass 的感觉？）。目前 knative 支持的实现有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;in-memory 一般只在测试时使用&lt;/li&gt;
&lt;li&gt;gcppubsub&lt;/li&gt;
&lt;li&gt;kafka&lt;/li&gt;
&lt;li&gt;natss&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;channel 创建提交以后会创建出现下面这样的一个 channel 资源，和一个 kubernetes serivce 资源&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                                       AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;channel.eventing.knative.dev/testchannel   7d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                                    TYPE           CLUSTER-IP       EXTERNAL-IP                                           PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;           AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;service/testchannel-channel-9j22r       ClusterIP      10.102.124.54    &amp;lt;none&amp;gt;                                                80/TCP            7d3h
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个 service/testchannel-channel-9j22r service 并没有对应到真实的 pod, 因为 channel 只是一个概念具体的实现是需要对应的 provisioner 来实现的，并且 channel 的 status 里面会记录到当前 channel 的 hostname&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;testchannel-channel-9j22r.default.svc.cluster.local&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们以 in-memory-channel provisioner controller 为例说明，在 in-memory-channel 的实现中是通过 istio 的一个 VirtualService 实现的，把到这个 service 的访问直接跳转到 in-memory-channel-dispatcher.knative-eventing.svc.cluster.local 这个 service。而 in-memory-channel-dispatcher.knative-eventing.svc.cluster.local 这个 service 就是 in-memory-channel controller 实现创建的。in-memory-channel controller &lt;em&gt;通过 istio 的 VirtualService 实现了事件源和 channel 的绑定&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建-k8s-事件源&#34;&gt;创建 k8s 事件源&lt;/h2&gt;
&lt;p&gt;k8s 事件源的定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;sources.eventing.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;KubernetesEventSource&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;testevents&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;eventing.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Channel&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;testchannel&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;事件源通过 spec.sink 定义事件需要发送到哪个 channel 上去。&lt;/p&gt;
&lt;p&gt;K8S 事件源会生成相应的 Deployment 用于收集 kubernetes 事件并发送到相应的 channel，pod 的 &amp;ndash;sink= 启动参数就是到目标 channel 的 url。&amp;ndash;sink 这个参数的 url 就是根据 KubernetesEventSource crd 的 spec.sink 信息获取到目标 channel 然后取的其 status.address.hostname 字段&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;extensions/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;testevents-n5t2w-qzhbv&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;... ...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- --&lt;span class=&#34;l&#34;&gt;namespace=default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- --&lt;span class=&#34;l&#34;&gt;sink=http://testchannel-channel-9j22r.default.svc.cluster.local/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;SINK&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http://testchannel-channel-9j22r.default.svc.cluster.local/&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当 testevents-n5t2w-qzhbv pod 发送事件到 &lt;code&gt;http://testchannel-channel-9j22r.default.svc.cluster.local/&lt;/code&gt; 时请求会被 sidecar 中的 istio-proxy 转发到 &lt;code&gt;http://in-memory-channel-dispatcher.knative-eventing.svc.cluster.local/&lt;/code&gt; (Knative 就是通过 istio 的 virtualService 实现的 eventSource 到 channel 的绑定) 从而达到事件转发到 in-memory-channel 的能力。接下来 in-memory-channel 的 dispatcher 把接收到的时候转发给响应的 subscription 就完成了实践的整个生命周期的流转。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们来汇总一下 Knative eventing 涉及到的几个关键概念及其之间的关系。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;event producers&lt;/li&gt;
&lt;li&gt;eventSource&lt;/li&gt;
&lt;li&gt;channel&lt;/li&gt;
&lt;li&gt;provisioners&lt;/li&gt;
&lt;li&gt;subscription&lt;/li&gt;
&lt;li&gt;consumers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们以 &lt;a href=&#34;https://github.com/knative/docs/blob/master/eventing/samples/kubernetes-event-source/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Event Source example&lt;/a&gt; 来说明每一个概念对应的角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;event producers:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/docs/blob/master/eventing/samples/kubernetes-event-source/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Event Source example&lt;/a&gt; 是演示如何把 kubernetes 中的事件发送到 channel 并通过 subscription 最终触发 message-dumper 函数执行的例子。这其中 kubernetes 集群就是事件的最初生产者，所以 kubernetes 集群就是 event producers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;eventSource&lt;/p&gt;
&lt;p&gt;eventSource 不是 event producers，eventSource 是把 event producers 生成的事件 &lt;em&gt;接入&lt;/em&gt; 到 Knative 体系中，其实是一个和外部系统的适配层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;channel&lt;/p&gt;
&lt;p&gt;是一个逻辑概念，主要是对事件本身、事件的存储以及事件的 subscription 向下传递路径做一个分组归类，每一个 channel 都有一个 status.address.hostname 字段，这个字段确定了如何把事件发送到这个 channel&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;provisioners&lt;/p&gt;
&lt;p&gt;provisioners 是 channel 的存储介质，可以使用 gcpsubsub、kafka 以及 natss 等产品支持。provisioners 是 channel crd 在创建的时候指定的。这个设计和 kubernetes 的 StorageClass 是一脉相承的。因为 eventSource 是通过 channel 的 status.address.hostname 向 channel post 事件的，所以 in-memory-channel 这个 provisioners 通过 istio virtualService 的方式 &lt;em&gt;在 eventSource 的 sidecar 中劫持了&lt;/em&gt; 发向 channel 的事件，直接转发给了 provisioners，从而实现了 provisioners 和 channel 的动态绑定的功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;subscription&lt;/p&gt;
&lt;p&gt;subscription 是一个独立的 crd，一个 channel 可以对应多个 subscription，当 provisioners watch 到一个新的 subscription 是就建立自己管理的 channel 和 subscription 的绑定关系 (在 channel 的 spec 中增加到 subscription 的引用列表)。当有事件发送到 channel 时 provisioners 就自动把事件转发给相关的 subscription&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;consumers&lt;/p&gt;
&lt;p&gt;消费事件的角色，和 channel 一样，consumers 也必须是一个地址可达的资源，并通过 status.address.hostname 字段指明如何访问到此 consumer。consumers 是通过 subscription 建立和 channel 的关联，从而达到消费事件的目的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参考文档&#34;&gt;参考文档&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/docs/blob/master/install/Knative-with-any-k8s.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Install on a Kubernetes Cluster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/eventing/blob/master/docs/spec/overview.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/knative/eventing/blob/master/docs/spec/overview.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/eventing/blob/master/docs/spec/spec.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/knative/eventing/blob/master/docs/spec/spec.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/eventing/blob/master/docs/spec/interfaces.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/knative/eventing/blob/master/docs/spec/interfaces.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Knative：重新定义 serverless</title>
      <link>https://cloudnative.to/blog/knative-redefine-serverless/</link>
      <pubDate>Wed, 02 Jan 2019 11:35:38 +0800</pubDate>
      <guid>https://cloudnative.to/blog/knative-redefine-serverless/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ypjjbxj30k00f0q6r_hu5701777729892149433.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ypjjbxj30k00f0q6r_hu9290623985293857830.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ypjjbxj30k00f0q6r_hu12121637701129615556.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ypjjbxj30k00f0q6r_hu5701777729892149433.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，今天给大家来的演讲专题是“Knative：重新定义 Serverless”, 我是来自蚂蚁金服中间件的敖小剑。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yi4z9yj30k00f040w_hu15317459654391868904.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yi4z9yj30k00f040w_hu6922032953478057975.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yi4z9yj30k00f040w_hu16500140560035031634.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yi4z9yj30k00f040w_hu15317459654391868904.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是我的个人资料，有兴趣的同学可以关注的我的个人技术博客网站 &lt;a href=&#34;https://skyao.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://skyao.io&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yeu4gcj30k00f0my3_hu18213542256211711025.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yeu4gcj30k00f0my3_hu15697377278990312651.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yeu4gcj30k00f0my3_hu7824692371278740261.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yeu4gcj30k00f0my3_hu18213542256211711025.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这次演讲的内容将会有这些，首先给大家介绍一下 knative 是什么，然后是 knative 的主要组件，让大家对 knative 有一个基本的了解。之后我会简单的对 knative 做一些分析和探讨，以及介绍一下 knative 后续的发展。希望本次的内容让大家能够对 knative 有一个基本的认知。&lt;/p&gt;
&lt;h2 id=&#34;什么是-knative&#34;&gt;什么是 knative？&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ymud2uj30k00f00tn_hu6912369311471791812.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ymud2uj30k00f00tn_hu3817388118122609450.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ymud2uj30k00f00tn_hu5445354578548297632.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ymud2uj30k00f00tn_hu6912369311471791812.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative 是 Google 牵头发起的 serverless 项目。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yanrbxj30k00f075o_hu14084717900628449383.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yanrbxj30k00f075o_hu5575380802924668538.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yanrbxj30k00f075o_hu8548530068051393298.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yanrbxj30k00f075o_hu14084717900628449383.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是 Knative 的项目定义，注意这句话里面几个关键字：kubernetes，serverless，workload。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yczkalj30k00f03zo_hu389233561471493892.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yczkalj30k00f03zo_hu12949371645698361988.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yczkalj30k00f03zo_hu3865218302187935506.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yczkalj30k00f03zo_hu389233561471493892.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是最近几年 Google 做大型项目的常态：产品刚出来，阵营就已经很强大了，所谓先声夺人。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2y8v7unj30k00f0gmk_hu8060481964062622552.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y8v7unj30k00f0gmk_hu17005868690107606049.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y8v7unj30k00f0gmk_hu15351237451356555325.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2y8v7unj30k00f0gmk_hu8060481964062622552.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是目前 Knative 项目的进展，可以看到这是一个非常新的项目，刚刚起步。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：这是截至 2018-11-24 演讲当天的情况，到 2018 年 12 月底，knative 已经发布了 v0.2.2 和 v0.2.3 两个 bugfix 版本。但也还只是 0.2 &amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yot2wbj30k00f0dh0_hu17323398005482940007.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yot2wbj30k00f0dh0_hu12176128645696234803.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yot2wbj30k00f0dh0_hu11754591860285618082.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yot2wbj30k00f0dh0_hu17323398005482940007.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们来看一下，在 knative 出来前，serverless 领域已有的实现，包括云端提供的产品和各种开源项目。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yo906aj30k00f0di1_hu691266762830715051.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yo906aj30k00f0di1_hu2555565540906510281.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yo906aj30k00f0di1_hu5585073118507041235.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yo906aj30k00f0di1_hu691266762830715051.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这幅图片摘自 The New Stack 的一个 serverless 调查，我们忽略调查内容，仅仅看看这里列出来的 serverless 产品的数量——感受是什么？好多 serverless 项目，好多选择！&lt;/p&gt;
&lt;p&gt;那问题来了：到底该怎么选？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ya58f5j30k00f00up_hu17321585622651719758.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ya58f5j30k00f00up_hu15520136001774703180.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ya58f5j30k00f00up_hu13113485193170662473.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ya58f5j30k00f00up_hu17321585622651719758.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这就是目前 serverless 的问题：由于缺乏标准，市场呈现碎片化。不同厂商，不同项目，各不相同，因此无论怎么选择，都面临一个风险：供应商绑定！&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ylfrl8j30k00f03zx_hu16928023015793262611.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ylfrl8j30k00f03zx_hu2696154433594515512.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ylfrl8j30k00f03zx_hu1448231092084868016.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ylfrl8j30k00f03zx_hu16928023015793262611.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这段话来自 knative 的官方介绍，google 推出 knative 的理由和动机。其中第一条和第二条针对的是当前 serverless 市场碎片的现状。而第四条多云战略，则是针对供应商绑定的风险。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yjj4hrj30k00f0q4o_hu8857517994360029925.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yjj4hrj30k00f0q4o_hu1575565575866362102.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yjj4hrj30k00f0q4o_hu10834350429531453152.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yjj4hrj30k00f0q4o_hu8857517994360029925.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;google 描述 knative 的动机之一，是将云原生中三个领域的最佳实践结合起来。&lt;/p&gt;
&lt;p&gt;小结：&lt;/p&gt;
&lt;p&gt;当前 serverless 市场产品众多导致碎片化严重，存在厂商绑定风险，而 google 推出 knative，希望能提供一套简单易用的 serverless 方案，实现 serverless 的标准化和规范化。&lt;/p&gt;
&lt;h2 id=&#34;knative-的主要组件&#34;&gt;Knative 的主要组件&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2y9rm2nj30k00f0gmk_hu8060481964062622552.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y9rm2nj30k00f0gmk_hu17005868690107606049.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y9rm2nj30k00f0gmk_hu15351237451356555325.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2y9rm2nj30k00f0gmk_hu8060481964062622552.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第二部分，来介绍一下 knative 的主要组件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ylvenwj30k00f0409_hu11929168689089623470.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ylvenwj30k00f0409_hu12541043719282637881.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ylvenwj30k00f0409_hu12602353568634537441.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ylvenwj30k00f0409_hu11929168689089623470.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;前面提到，google 推出 knative，试图将云原生中三个领域的最佳实践结合起来。反应到 knative 产品中，就是这三大主要组件：Build，Serving，Eventing。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yqp82zj30k00f0taa_hu14180969790364801839.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yqp82zj30k00f0taa_hu10031019848644175951.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yqp82zj30k00f0taa_hu302948752905398445.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yqp82zj30k00f0taa_hu14180969790364801839.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative Build 组件，实现从代码到容器的目标。为什么不直接使用 dockfile 来完成这个事情？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ykxse9j30k00f0q51_hu7666525698910967650.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ykxse9j30k00f0q51_hu103261756818806581.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ykxse9j30k00f0q51_hu14996923921464674425.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ykxse9j30k00f0q51_hu7666525698910967650.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative Build 在实现时，是表现为 kubernetes 的 CRD，通过 yaml 文件来定义构建过程。这里引入了很多概念如：build，builder，step，template，source 等。另外支持用 service account 做身份验证。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ydy8wvj30k00f00uh_hu14063687653637506162.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ydy8wvj30k00f00uh_hu1533638600830010390.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ydy8wvj30k00f00uh_hu598876173218737338.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ydy8wvj30k00f00uh_hu14063687653637506162.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative Serving 组件的职责是运行应用以对外提供服务，即提供服务、函数的运行时支撑。&lt;/p&gt;
&lt;p&gt;注意定义中的三个关键：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;kubernetes-based：基于 k8s，也仅支持 k8s，好处是可以充分利用 k8s 平台的能力&lt;/li&gt;
&lt;li&gt;scale-to-zero：serverless 最重要的卖点之一，当然要强调&lt;/li&gt;
&lt;li&gt;request-driven compute：请求驱动的计算&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;值得注意的是，除了 k8s 之外，还有另外一个重要基础：istio！后面会详细聊这个。&lt;/p&gt;
&lt;p&gt;Knative Serving 项目同样也提供了自己的中间件原语，以支持如图所示的几个重要特性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ybms2rj30k00f00um_hu4399327869184303213.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ybms2rj30k00f00um_hu8480025971127141050.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ybms2rj30k00f00um_hu10905306756308324572.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ybms2rj30k00f00um_hu4399327869184303213.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;knative 中有大量的概念抽象，而在这之后的背景，说起来有些意思：knative 觉得 kubernetes 和 istio 本身的概念非常多，多到难于理解和管理，因此 knative 决定要自己提供更高一层的抽象。至于这个做法，会是釜底抽薪解决问题，还是雪上加霜让问题更麻烦&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;knative 的这些抽象都是基于 kubernetes 的 CRD 来实现，具体抽象概念有：Service、Route、Configuration 和 Revision。特别提醒的是，右边图中的 Service 是 knative 中的 service 概念，&lt;code&gt;service.serving.knative.dev&lt;/code&gt;，而不是大家通常最熟悉的 k8s 的 service。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ynrcmoj30k00f0wgc_hu16274786134296607861.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ynrcmoj30k00f0wgc_hu4582060978296364845.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ynrcmoj30k00f0wgc_hu4684590142528837189.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ynrcmoj30k00f0wgc_hu16274786134296607861.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于 Knative Serving 组件，最重要的特性就是自动伸缩的能力。目前伸缩边界支持从 0 到无限，容许通过配置设置。&lt;/p&gt;
&lt;p&gt;Knative 目前是自己实现的 autoscaler，原来比较简单：Revision 对应的 pod 由 k8s deployment 管理，pod 上的工作负载上报 metrics，汇总到 autoscaler 分析判断做决策，在需要时修改 replicas 数量来实现自动伸缩（后面会再讲这块存在的问题）。&lt;/p&gt;
&lt;p&gt;当收缩到 0，或者从 0 扩展到 1 时，情况会特别一些。knative 在这里提供了名为 Activator 的设计，如图所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Istio Route 控制流量走向，正常情况下规则设置为将流量切到工作负载所在的 pod&lt;/li&gt;
&lt;li&gt;当没有流量，需要收缩到 0 时，规则修改为将流量切到 Activator，如果一直没有流量，则什么都不发生。此时 autoscaler 通过 deployment 将 replicas 设置为 0。&lt;/li&gt;
&lt;li&gt;当新的流量到来时，流量被 Activator 接收，Activator 随即拉起 pod，在 pod 和工作负载准备好之后，再将流量转发过去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yj0vbkj30k00f0wfe_hu17721909027809710119.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yj0vbkj30k00f0wfe_hu15611838837853404728.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yj0vbkj30k00f0wfe_hu3908443028830714140.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yj0vbkj30k00f0wfe_hu17721909027809710119.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative Eventing 组件负责事件绑定和发送，同样提供多个抽象概念：Flow，Source，Bus，以帮助开发人员摆脱概念太多的负担（关于这一点，我保留意见）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ynaza9j30k00f075w_hu7904115580059379449.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ynaza9j30k00f075w_hu8941552780118751910.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ynaza9j30k00f075w_hu18143230547081810391.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ynaza9j30k00f075w_hu7904115580059379449.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Bus 是对消息总线的抽象。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yr4beaj30k00f0wg3_hu930531001096330862.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yr4beaj30k00f0wg3_hu12548548512523606684.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yr4beaj30k00f0wg3_hu14073810165644628219.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yr4beaj30k00f0wg3_hu930531001096330862.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Source 是事件数据源的抽象。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yk1kkij30k00f0q4j_hu13138941175357778196.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yk1kkij30k00f0q4j_hu16526234028224012132.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yk1kkij30k00f0q4j_hu15027063504181686425.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yk1kkij30k00f0q4j_hu13138941175357778196.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative 在事件定义方面遵循了 cloudevents 规范。&lt;/p&gt;
&lt;p&gt;小结：&lt;/p&gt;
&lt;p&gt;简单介绍了一下 knative 中的三大组件，让大家对 knative 的大体架构和功能有个基本的认知。这次就不再继续深入 knative 的实现细节，以后有机会再展开。&lt;/p&gt;
&lt;h2 id=&#34;knative-分析和探讨&#34;&gt;Knative 分析和探讨&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yfiktvj30k00f0q3w_hu6421773110828779322.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yfiktvj30k00f0q3w_hu7283542420931335202.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yfiktvj30k00f0q3w_hu4432602057027364867.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yfiktvj30k00f0q3w_hu6421773110828779322.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在第三部分，我们来分析探讨一下 knative 的产品定位，顺便也聊一下为什么我们会看好 knative。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ygta4hj30k00f0758_hu6660768309871444077.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ygta4hj30k00f0758_hu8198479608113750470.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ygta4hj30k00f0758_hu8836102719221249517.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ygta4hj30k00f0758_hu6660768309871444077.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先，最重要的一点是：knative &lt;strong&gt;不是&lt;/strong&gt;一个 Serverless 实现，而是一个 Serviceless 平台。&lt;/p&gt;
&lt;p&gt;也就是说，knative 不是在现有市场上的 20 多个 serverless 产品和开源项目的基础上简单再增加一个新的竞争者，而是通过建立一个标准而规范的 serverless 平台，容许其他 serverless 产品在 knative 上运行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yq94l2j30k00f00ug_hu5814550519632008201.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yq94l2j30k00f00ug_hu16213068341940544725.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yq94l2j30k00f00ug_hu3450354773843043851.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yq94l2j30k00f00ug_hu5814550519632008201.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative 在产品规划和设计理念上也带来了新的东西，和传统 serverless 不同。工作负载和平台支撑是 knative 最吸引我们的地方。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yfrimxj30k00f00tv_hu8658061672409146793.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yfrimxj30k00f00tv_hu15672080990105378135.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yfrimxj30k00f00tv_hu17860514666859171335.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yfrimxj30k00f00tv_hu8658061672409146793.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;要不要 Istio？这是 knative 一出来就被人诟病和挑战的点：因为 Istio 的确是复杂度有点高。而 k8s 的复杂度，还有 knative 自身的复杂度都不低，再加上 Istio&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;关于这一点，个人的建议是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果原有系统中没有规划 Istio/Service mesh 的位置，那么为了 knative 而引入 Istio 的确是代价偏高。可以考虑用其他方式替代，最新版本的 knative 已经实现了对 Istio 的解耦，容许替换。&lt;/li&gt;
&lt;li&gt;如果本来就有规划使用 Istio/Service mesh，比如像我们蚂蚁这种，那么 knative 对 Istio 的依赖就不是问题了，反而可以组合使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而 kubernetes + servicemesh + serverless 的组合，我们非常看好。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ydgkfej30k00f0abb_hu1319010130213408538.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ydgkfej30k00f0abb_hu16600932245571046301.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ydgkfej30k00f0abb_hu6427253049905650415.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ydgkfej30k00f0abb_hu1319010130213408538.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当然，knative 体系的复杂度问题是无法回避的：kubernetes，istio，knative 三者都是复杂度很高的产品，加在一起整体复杂度就非常可观了，挑战非常大。&lt;/p&gt;
&lt;h2 id=&#34;knative-后续发展&#34;&gt;Knative 后续发展&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ykhnnvj30k00f0gmk_hu17162727764921405164.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ykhnnvj30k00f0gmk_hu17773942899000050135.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ykhnnvj30k00f0gmk_hu11998435324906289452.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ykhnnvj30k00f0gmk_hu17162727764921405164.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第四个部分，我们来展望一下 knative 的后续发展，包括如何解决一些现有问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yb5n5nj30k00f03zp_hu15779701123198071897.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yb5n5nj30k00f03zp_hu10445338731408644847.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yb5n5nj30k00f03zp_hu16941009869688290290.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yb5n5nj30k00f03zp_hu15779701123198071897.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第一个问题就是性能问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yefneyj30k00f075m_hu5090244148595487349.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yefneyj30k00f075m_hu16607552395938986358.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yefneyj30k00f075m_hu6007208762605565739.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yefneyj30k00f075m_hu5090244148595487349.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Queue Proxy 也是一个现存的需要替换的模块。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yimwxxj30k00f00tt_hu8418605974326059977.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yimwxxj30k00f00tt_hu1878777737321566552.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yimwxxj30k00f00tt_hu9772898106270923190.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yimwxxj30k00f00tt_hu8418605974326059977.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;前面讲过 knative 的 Autoscaler 是自行实现的，而 k8s 目前已经有比较健全原生能力：HPA 和 Custom Metrics。目前 knative 已经有计划要转而使用 k8s 的原生能力。这也符合 Cloud Native 的玩法：将基础能力下沉到 k8s 这样的基础设施，上层减负。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ycjvmtj30k00f0q41_hu17113927520270460286.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ycjvmtj30k00f0q41_hu12205774908549618671.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ycjvmtj30k00f0q41_hu1228396865544985888.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ycjvmtj30k00f0q41_hu17113927520270460286.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了下沉到 k8s 之外，autoscaler 还有很多细节需要在后续版本中完善。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2y8qjlcj30k00f075c_hu7022603702557377015.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y8qjlcj30k00f075c_hu2955679894775347124.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y8qjlcj30k00f075c_hu3501079101141133405.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2y8qjlcj30k00f075c_hu7022603702557377015.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对事件源和消息系统的支持也远不够完善，当然考虑到目前才 0.2.0 版本，可以理解。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2y989gtj30k00f0gn0_hu13063810958544620300.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y989gtj30k00f0gn0_hu4754349645553003788.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2y989gtj30k00f0gn0_hu4208583147075496379.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2y989gtj30k00f0gn0_hu13063810958544620300.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;目前 knative 还没有规划 workflow 类的产品。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2ymbqcvj30k00f0wgf_hu6198131007270606504.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ymbqcvj30k00f0wgf_hu11006616270887587208.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2ymbqcvj30k00f0wgf_hu951371071227425039.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2ymbqcvj30k00f0wgf_hu6198131007270606504.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在网络路由能力方面也有很多欠缺，上面是 knative 在文档中列出来的需求列表。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yc0iq9j30k00f0gn5_hu1306980046628835369.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yc0iq9j30k00f0gn5_hu9399965448696277279.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yc0iq9j30k00f0gn5_hu18124261795578427697.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yc0iq9j30k00f0gn5_hu1306980046628835369.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后聊聊 knative 的可拔插设计，这是 knative 在架构设计上的一个基本原则：顶层松耦合，底层可拔插。&lt;/p&gt;
&lt;p&gt;最顶层是 Build / Serving / Eventing 三大组件，中间是各种能力，通过 k8s 的 CRD 方式来进行声明，然后底层是各种实现，按照 CRD 的要求进行具体的实现。&lt;/p&gt;
&lt;p&gt;在这个体系中，用户接触的是 Build / Serving / Eventing 通用组件，通过通过标准的 CRD 进行行为控制，而和底层具体的实现解耦。理论上，之后在实现层做适配，knative 就可以运行在不同的底层 serverless 实现上。从而实现 knative 的战略目标：提供 serverless 的通用平台，实现 serverless 的标准化和规范化。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yhmny2j30k00f03zg_hu5106540269748244405.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yhmny2j30k00f03zg_hu6290612757843415835.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yhmny2j30k00f03zg_hu8680493005633276724.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yhmny2j30k00f03zg_hu5106540269748244405.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，我们对 knative 做一个简单总结。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yg9jwdj30k00f0q49_hu4946920223737897048.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yg9jwdj30k00f0q49_hu4258869705654910329.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yg9jwdj30k00f0q49_hu11001783563723224426.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yg9jwdj30k00f0q49_hu4946920223737897048.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;先谈一下 knative 的优势，首先是 knative 自身的几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产品定位准确：针对市场现状，不做竞争者而是做平台&lt;/li&gt;
&lt;li&gt;技术方向明确：基于 k8s，走 cloud native 方向&lt;/li&gt;
&lt;li&gt;推出时机精准：k8s 大势已成，istio 接近成熟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，再次强调：kubernetes + service mesh + serverless 的组合，在用好的前提下，应该威力不凡。&lt;/p&gt;
&lt;p&gt;此外，knative 在负载的支撑上，不拘泥于传统的 FaaS，可以支持 BaaS 和传统应用，在落地时适用性会更好，使用场景会更广泛。（备注：在这里我个人有个猜测，knative 名字中 native 可能指的是 native workload，即在 k8s 和 cloud native 语义下的原生工作负载，如果是这样，那么 google 和 knative 的这盘棋就下的有点大了。）&lt;/p&gt;
&lt;p&gt;最后，考虑到目前 serverless 的市场现状，对 serverless 做标准化和规范化，出现一个 serverless 平台，似乎也是一个不错的选择。再考虑到 google 拉拢大佬和社区一起干的一贯风格，携 k8s 和 cloud native 的大势很有可能实现这个目标。&lt;/p&gt;
&lt;p&gt;当然，knative 目前存在的问题也很明显，细节不说，整体上个人感觉有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成熟度：目前才 0.2 版本，实在太早期，太多东西还在开发甚至规划中。希望随着时间的推移和版本演进，knative 能尽快走向成熟。&lt;/li&gt;
&lt;li&gt;复杂度：成熟度的问题还好说，总能一步一步改善的，无非是时间问题。但是 knative 的系统复杂度过高的问题，目前看来几乎是不可避免的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，对 knative 的总结，就一句话：&lt;strong&gt;前途不可限量，但是成长需要时间&lt;/strong&gt;。让我们拭目以待。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-redefine-serverless/006tNbRwly1fys2yh7tksj30k00f03zu_hu2600050413615285982.webp 400w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yh7tksj30k00f03zu_hu2110103497654398393.webp 760w,
               /blog/knative-redefine-serverless/006tNbRwly1fys2yh7tksj30k00f03zu_hu10417105422124712308.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-redefine-serverless/006tNbRwly1fys2yh7tksj30k00f03zu_hu2600050413615285982.webp&#34;
               width=&#34;720&#34;
               height=&#34;540&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;广告时间，欢迎大家加入 servicemesher 社区，也可以通过关注 servicemesher 微信公众号来及时了解 service mesh 技术的最新动态。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Serverless 平台 knative 简介</title>
      <link>https://cloudnative.to/blog/knative-serverless-platform/</link>
      <pubDate>Tue, 18 Dec 2018 19:43:14 +0800</pubDate>
      <guid>https://cloudnative.to/blog/knative-serverless-platform/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文作者：吴伟，蚂蚁金服系统部技术专家，本文转载自其&lt;a href=&#34;http://cizixs.com/2018/08/25/knative-serverless-platform/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;knative&lt;/a&gt; 是谷歌开源的 serverless 架构方案，旨在提供一套简单易用的 serverless 方案，把 serverless 标准化。目前参与的公司主要是 Google、Pivotal、IBM、Red Hat，2018 年 7 月 24 日才刚刚对外发布，当前还处于快速发展的阶段。&lt;/p&gt;
&lt;p&gt;这是 Google Cloud Platform 宣布 knative 时给出的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Developed in close partnership with Pivotal, IBM, Red Hat, and SAP, Knative pushes Kubernetes-based computing forward by providing the building blocks you need to build and deploy modern, container-based serverless applications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出，knative 是为了解决容器为核心的 serverless 应用的构建、部署和运行的问题。&lt;/p&gt;
&lt;p&gt;serverless 的概念已经出现蛮久了，为了理解 serverless, 可以从应用开发者的角度来看，使用 serverless 框架之后，应用开发者的整个操作流程就变成了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;~ &lt;span class=&#34;c1&#34;&gt;# 编写 code 和 configuration 文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;~ &lt;span class=&#34;c1&#34;&gt;# faascli build&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;~ &lt;span class=&#34;c1&#34;&gt;# faascli deploy&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;~ &lt;span class=&#34;c1&#34;&gt;# curl http://myapp.com/hello&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hello, world from Awesome FaaS App!
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到用户只需要编写代码（或者函数），以及配置文件（如何 build、运行以及访问等声明式信息），然后运行 build 和 deploy 就能把应用自动部署到集群（可以是公有云，也可以是私有的集群）。&lt;/p&gt;
&lt;p&gt;其他事情都是 serverless 平台（比如这里的 knative）自动处理的，这些事情包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动完成代码到容器的构建&lt;/li&gt;
&lt;li&gt;把应用（或者函数）和特定的事件进行绑定：当事件发生时，自动触发应用（或者函数）&lt;/li&gt;
&lt;li&gt;网络的路由和流量控制&lt;/li&gt;
&lt;li&gt;应用的自动伸缩&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和标准化的 FaaS 不同（只运行特定标准的 Function 代码），knative 期望能够运行所有的 workload : traditional application、function、container。&lt;/p&gt;
&lt;p&gt;knative 建立在 kubernetes 和 istio 平台之上，使用 kubernetes 提供的容器管理能力（deployment、replicaset、和 pods 等），以及 istio 提供的网络管理功能（ingress、LB、dynamic route 等）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-knative-with-istio-and-kubernetes&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2018/08/25/5b811d40e22bb.png&#34; alt=&#34;knative with istio and kubernetes&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      knative with istio and kubernetes
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;knative-核心概念和原理&#34;&gt;knative 核心概念和原理&lt;/h2&gt;
&lt;p&gt;为了实现 serverless 应用的管理，knative 把整个系统分成了三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build：构建系统，把用户定义的函数和应用 build 成容器镜像&lt;/li&gt;
&lt;li&gt;Serving：服务系统，用来配置应用的路由、升级策略、自动扩缩容等功能&lt;/li&gt;
&lt;li&gt;Eventing：事件系统，用来自动完成事件的绑定和触发&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;build-构建系统&#34;&gt;Build 构建系统&lt;/h3&gt;
&lt;p&gt;build 的功能是把用户的代码自动化构建成容器镜像，初次听起来很奇怪，有了 docker 之后有一个 Dockerfile 不就能构建容器了吗？为什么还需要一个新的 Build 系统？&lt;/p&gt;
&lt;p&gt;Knative 的特别之处在于两点：一是它的构建完全是在 kubernetes 中进行的，和整个 kubernetes 生态结合更紧密；另外，它旨在提供一个通用的标准化的构建组件，可以作为其他更大系统中的一部分。&lt;/p&gt;
&lt;p&gt;正如官方文档中的说的那样，是为了定义标准化、可移植、可重用、性能高效的构建方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The goal of a Knative build is to provide a standard, portable, reusable, and performance optimized method for defining and running on-cluster container image builds.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Knative 提供了 &lt;code&gt;Build&lt;/code&gt; CRD 对象，让用户可以通过 yaml 文件定义构建过程。一个典型的 &lt;code&gt;Build&lt;/code&gt; 配置文件如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;build.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Build&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-build&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceAccountName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;build-auth-example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;source&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;git&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;https://github.com/example/build-example.git&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revision&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;master&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;steps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ubuntu-example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ubuntu&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;ubuntu-build-example&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;SECRETS-example.md&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;steps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gcr.io/example-builders/build-example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;echo&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;hello-example&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;build&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中，&lt;code&gt;serviceAccountName&lt;/code&gt; 是构建过程中需要用到的密码和认证信息（比如连接到 git repo 的 SSH keys、push 镜像到 registry 的用户名和密码等）；
&lt;code&gt;source&lt;/code&gt; 是代码信息，比如这里的 git 地址和分支；&lt;code&gt;steps&lt;/code&gt; 是真正运行过程中的各个步骤。
这个示例中的步骤只是作为 demo，真正的构建过程一般是 pull 代码、build 镜像和 push 镜像到 registry 等逻辑。&lt;/p&gt;
&lt;p&gt;因为大部分的构建过程都是一致的，因此 knative 还提供了 &lt;code&gt;Build template&lt;/code&gt; 的概念，
Build template 封装了预先定义好的构建过程（就是封装了上面的 &lt;code&gt;steps&lt;/code&gt; 过程），并提供了非常简单的配置参数来使用。&lt;/p&gt;
&lt;p&gt;使用 build template 构建容器镜像就更简单了，只需要提供代码的地址和镜像名字即可，比如下面是使用 Google kaniko 模板构建 github 源码的 yaml 文件（需要在代码根目录存在 Dockerfile 文件）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;build.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Build&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kaniko-build&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceAccountName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;build-bot&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;source&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;git&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;https://github.com/my-user/my-repo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revision&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;master&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kaniko&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;arguments&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;IMAGE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;us.gcr.io/my-project/my-app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;serving服务系统&#34;&gt;Serving：服务系统&lt;/h3&gt;
&lt;p&gt;serving 的核心功能是让应用运行起来提供服务。&lt;/p&gt;
&lt;p&gt;虽然听起来很简单，但这里包括了很多的事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动化启动和销毁容器&lt;/li&gt;
&lt;li&gt;根据名字生成网络访问相关的 service、ingress 等对象&lt;/li&gt;
&lt;li&gt;监控应用的请求，并自动扩缩容&lt;/li&gt;
&lt;li&gt;支持蓝绿发布、回滚功能，方便应用发布流程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;knative serving 功能是基于 kubernetes 和 istio 开发的，它使用 kubernetes 来管理容器（deployment、pod），istio 来管理网络路由（VirtualService、DestinationRule）。&lt;/p&gt;
&lt;p&gt;因为 kubernetes 和 istio 本身的概念非常多，理解和管理起来比较困难，knative 在此之上提供了更高一层的抽象（这些对应是基于 kubernetes 的 CRD 实现的）。这些抽象出来的概念对应的关系如下图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-knative-serving-terminology&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://i.loli.net/2018/08/25/5b81211da0309.png&#34; alt=&#34;knative serving terminology&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      knative serving terminology
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Configuration：应用的最新配置，也就是应用目前期望的状态，对应了 kubernetes 的容器管理（deployment）。每次应用升级都会更新 configuration，而 knative 也会保留历史版本的记录（图中的 revision），结合流量管理，knative 可以让多个不同的版本共同提供服务，方便蓝绿发布和滚动升级&lt;/li&gt;
&lt;li&gt;Route：应用的路由规则，也就是进来的流量如何访问应用，对应了 istio 的流量管理（VirtualService）&lt;/li&gt;
&lt;li&gt;Service：注意这里不是 kubernetes 中提供服务发现的那个 service，而是 knative 自定义的 CRD，它的全称目前是 &lt;code&gt;services.serving.knative.dev&lt;/code&gt; 。单独控制 route 和 configuration 就能实现 serving 的所有功能，但 knative 更推荐使用 Service 来管理，因为它会自动帮你管理 route 和 configuration&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个 hello world 的 serving 配置如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;serving.knative.dev/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;helloworld-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;runLatest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;configuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;revisionTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;container&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker.io/{username}/helloworld-go&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TARGET&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Go Sample v1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看起来和 kubernetes 的 pod 定义非常类似，但是它会帮你管理 deployment、ingress、service discovery、auto scaling……从这个角度来看，可以认为 knative 提供了更高的抽象，自动帮你封装掉了 kubernetes 和 istio 的实现细节。&lt;/p&gt;
&lt;p&gt;下面这张图介绍了 knative serving 各组件之间的关系：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-knative-serving-architecture&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;knative serving architecture&#34; srcset=&#34;
               /blog/knative-serverless-platform/006tNbRwgy1fum2swzqebj31j00to41f_hu7252209627635120875.webp 400w,
               /blog/knative-serverless-platform/006tNbRwgy1fum2swzqebj31j00to41f_hu17736197252218929294.webp 760w,
               /blog/knative-serverless-platform/006tNbRwgy1fum2swzqebj31j00to41f_hu2653398200666737142.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-serverless-platform/006tNbRwgy1fum2swzqebj31j00to41f_hu7252209627635120875.webp&#34;
               width=&#34;760&#34;
               height=&#34;410&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      knative serving architecture
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以看到，每个 revision 对应了一组 deployment 管理的 pod&lt;/li&gt;
&lt;li&gt;pod 会自动汇报 metrics 数据到 autoscaler，autoscaler 会根据请求量和资源使用情况修改 deployment 的 replicas 数量，从而实现自动扩缩容。serverless 一个重要的特定是它会 scale to 0 的，也就是当应用没有流量访问时，它会自动销毁所有的 pod&lt;/li&gt;
&lt;li&gt;activator 比较有趣，它是为了处理 scale to 0 而出现的。当某个 revision 后面的 pod 缩容到 0 时，route 的流量会指向 activator，activator 接收到请求之后会自动拉起 pod，然后把流量转发过去&lt;/li&gt;
&lt;li&gt;route 对象对应了 istio 的 DestinationRoute 和 VirtualService，决定了访问应用的流量如何路由&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;eventing事件系统&#34;&gt;Eventing：事件系统&lt;/h3&gt;
&lt;p&gt;serving 系统实现的功能是让应用/函数能够运行起来，并且自动伸缩，那什么时候才会调用应用呢？除了我们熟悉的正常应用调用之外，serverless 最重要的是基于事件的触发机制，也就是说当某件事发生时，就触发某个特定的函数。&lt;/p&gt;
&lt;p&gt;事件概念的出现，让函数和具体的调用方能够解耦。函数部署出来不用关心谁会调用它，而事件源触发也不用关心谁会处理它。&lt;/p&gt;
&lt;p&gt;Note：目前 serverless 的产品和平台很多，每个地方支持的事件来源以及对事件的定义都是不同的（比如 AWS Lambda 支持很多自己产品的事件源）。Knative 自然也会定义自己的事件类型，除此之外，knative 还联合 CNCF 在做事件标准化的工作，目前的产出是 CloudEvents 这个项目。&lt;/p&gt;
&lt;p&gt;为了让整个事件系统更有扩展性和通用性，knative 定义了很多事件相关的概念。我们先来介绍一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EventSource：事件源，能够产生事件的外部系统&lt;/li&gt;
&lt;li&gt;Feed：把某种类型的 EventType 和 EventSource 和对应的 Channel 绑定到一起&lt;/li&gt;
&lt;li&gt;Channel：对消息实现的一层抽象，后端可以使用 kafka、RabbitMQ、Google PubSub 作为具体的实现。channel name 类似于消息集群中的 topic，可以用来解耦事件源和函数。事件发生后 sink 到某个 channel 中，然后 channel 中的数据会被后端的函数消费&lt;/li&gt;
&lt;li&gt;Subscription：把 channel 和后端的函数绑定的一起，一个 channel 可以绑定到多个 knative service&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们之间的关系流程图如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-knative-eventing-architecture&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;knative eventing architecture&#34; srcset=&#34;
               /blog/knative-serverless-platform/006tNbRwgy1fum30a10ynj31jm0v2dkq_hu3829967790219646833.webp 400w,
               /blog/knative-serverless-platform/006tNbRwgy1fum30a10ynj31jm0v2dkq_hu8787028561937312171.webp 760w,
               /blog/knative-serverless-platform/006tNbRwgy1fum30a10ynj31jm0v2dkq_hu18015210808358663386.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-serverless-platform/006tNbRwgy1fum30a10ynj31jm0v2dkq_hu3829967790219646833.webp&#34;
               width=&#34;760&#34;
               height=&#34;424&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      knative eventing architecture
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Bus 是 knative 内部的事件存储层，用户可以选择自己感兴趣的实现，目前支持的方式有：Stub（在内存中实现的简单消息系统）、Kafka、Google PubSub。如果想要事件能够正常运行，必须在 knative 集群中安装其中一个 bus 实现方式。&lt;/p&gt;
&lt;p&gt;有了 bus 之后，我们就可以监听外部的事件了。目前支持的事件源有三个：github（比如 merge 事件，push 事件等），kubernetes（events），Google PubSub（消息系统），后面还会不断接入更多的事件源。&lt;/p&gt;
&lt;p&gt;如果要想监听对应的事件源，需要在 knative 中部署一个 source adaptor 的 pod，它负责从外部的系统中读取事件。&lt;/p&gt;
&lt;p&gt;读取后的事件，会根据用户配置的 Feed 对象（里面包括了事件源和 channel 的对应关系），找到对应的 channel，然后把消息发送到这个 channel 中（channel 的消息最终是存储在后端的 bus 系统里的）。&lt;/p&gt;
&lt;p&gt;然后，knative 会根据 subscription 的配置，不断从 channel 中读取事件，然后把事件作为参数调用对应的函数，从而完成了整个事件的流程。&lt;/p&gt;
&lt;h2 id=&#34;knative-目前的状态&#34;&gt;Knative 目前的状态&lt;/h2&gt;
&lt;p&gt;knative 是 2018 年 7 月才刚刚对外开放，虽然内部已经开发一段时间，但是目前还处于非常早前的阶段（从支持的事件源和 bus 就能看出来）。目前代码还不稳定，很多实现都是 hard-coded。&lt;/p&gt;
&lt;p&gt;knative 也是脱产于 google 和 CNCF，因此整个社区运行方式和目标与之前的 kubernetes 以及 istio 非常相似。社区根据组件分成多个 Working Group，每个 Group 独立负责自己的功能，所有的开源活动（文档、视频、代码）都是开放的。另外，CloudEvents 作为 knative 依赖的标准，目标也是成为 CRI、CNI、CSI 这种类似的标准。&lt;/p&gt;
&lt;p&gt;knative 社区目前非常活跃，以 &lt;code&gt;github.com/knative/serving&lt;/code&gt; 项目为例，一个月已经有 600+ star，目前有 60+ contributor，900+ commits，而且入门的文档和教程都已经非常全面。&lt;/p&gt;
&lt;h2 id=&#34;knative-应用场景和思考&#34;&gt;Knative 应用场景和思考&lt;/h2&gt;
&lt;p&gt;knative 基于 kubernetes 和 istio 的 serverless 开源实现，目标是提供更高层次的抽象，让开发者无需关注基础设施（虚拟机或者容器，网络配置，容量规划），而专注于业务代码即可。更多关于 knative 的使用场景可以参考 AWS Lambda 或者其他相关的文档，这里不再赘述，主要讲讲 knative 目前的局限性或者问题：&lt;/p&gt;
&lt;h3 id=&#34;1-性能问题&#34;&gt;1. 性能问题&lt;/h3&gt;
&lt;p&gt;性能问题一直是 serverless 被人诟病的一点，也是目前它不能广泛用于应用服务上的决定性原因。互联网的应用大多数有高并发、高性能的要求，serverless 整个网络链路很长，容器启停需要额外的时间，还无法满足互联网应用的要求。&lt;/p&gt;
&lt;p&gt;针对这一点，很多 serverless 框架也在不断地做改进，比如不断精简容器的启动时间、容器启动之后会做缓存等，比如 nuclio 就宣称自己的平台比 AWS Lambda 要快 10 倍以上。&lt;/p&gt;
&lt;p&gt;相信随着 serverless 的不断演进，性能问题会不断优化，至于能不能达到互联网应用的要求，还要时间给我们答案。&lt;/p&gt;
&lt;h3 id=&#34;2-是否需要-istio-这一层&#34;&gt;2. 是否需要 istio 这一层？&lt;/h3&gt;
&lt;p&gt;基于 kubernetes 的 serverless 组件非常多，比如 kubeless。但是基于 kubernetes 同时又基于 istio，目前 knative 还是第一个这么做的。&lt;/p&gt;
&lt;p&gt;有些人的疑问在于，knative 真的有必要基于 istio 来做吗？对于这个问题，我个人的看法是必要的。&lt;/p&gt;
&lt;p&gt;虽然 istio 才刚刚 release 1.0 版本，但是它作为集群基础设施通用网络层的地位已经开始显露，相信在未来的发展中接受度会越来越大，并逐渐巩固自己的地位。虽然现阶段来说，很多人并不非常熟悉 istio 的情况，但是从长远角度来看，这一点将是 knative 的一个优势所在。&lt;/p&gt;
&lt;p&gt;另外，基于 istio 构建自己的 serverless 服务，也符合目前软件行业不要重复造轮子的思路。istio 在集群的网络管理方面非常优秀（智能路由、负载均衡、蓝绿发布等），基于 istio 来做可以让 knative 不用重复工作就能直接使用 istio 提供的网络通用功能。&lt;/p&gt;
&lt;h3 id=&#34;3-系统复杂度&#34;&gt;3. 系统复杂度&lt;/h3&gt;
&lt;p&gt;这一点和上面类似，knative 下面已经有两个非常复杂的平台：kubernetes 和 istio。这两个平台的理解、构建、运维本身就很复杂，如今又加上 knative 整个平台，需要了解的概念都要几十个，更不要提落地过程中会遇到的各种问题。&lt;/p&gt;
&lt;p&gt;对于公有云来说，kubernetes 和 istio 这些底层平台可以交给云供应商来维护（比如 google Function），但是对于内部构建来说，这无疑提高了整个技术门槛，对系统管理人员的要求更高。&lt;/p&gt;
&lt;p&gt;如何安装部署整个集群？如何对集群做升级？出现问题怎么调试和追踪？怎么更好地和内部的系统对接？这些系统的最佳实践是什么？怎么做性能优化？所有这些问题都需要集群管理人员思考并落实。&lt;/p&gt;
&lt;h3 id=&#34;4-函数的可运维性&#34;&gt;4. 函数的可运维性？&lt;/h3&gt;
&lt;p&gt;相对于编写微服务来说，单个函数的复杂度已经非常低，但是当非常多的函数需要共同工作的时候，如何管理这些函数就成了一个必须解决的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何快速找到某个函数？&lt;/li&gt;
&lt;li&gt;如何知道一个函数的功能是什么？接受的参数是什么？&lt;/li&gt;
&lt;li&gt;怎么保证函数的升级不会破坏原有的功能？升级之后如何回滚？怎么记录函数的历史版本方面追溯？&lt;/li&gt;
&lt;li&gt;当有多个函数需要同时工作的时候，怎么定义它们之间的关系？&lt;/li&gt;
&lt;li&gt;函数出现问题的时候如何调试？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于函数的运维，一般的 serverless 平台（包括 knative）都提供了 logging、metrics、tracing 三个方面的功能。默认情况下，knative 使用 EFK（Elasticsearch、Fluent、Kibana）来收集、查找和分析日志；使用 prometheus + grafana 来收集和索引、展示 metrics 数据；使用 jaeger 来进行调用关系的 tracing。&lt;/p&gt;
&lt;p&gt;针对 serverless 衍生出来的运维工具和平台还不够多，如何调试线上问题还没有看到非常好的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;5-knative-成熟度&#34;&gt;5. knative 成熟度&lt;/h3&gt;
&lt;p&gt;最后一点是关于 knative 成熟度的，前面已经提到，knative 目前刚出现不久。虽然整个框架和设计都已经搭好了，但是很多实现都比较初级。这里提几点来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了实现 autoscaling，knative 在每个 pod 中添加一个叫做 queue proxy 的代理，它会自动把请求的 metrics 发送给 autoscaler 组件作为参考。这样一来，整个网络链路上又多了一层，对整个性能势必会有影响，未来的打算是直接使用 envoy sidecar 来替换掉 queue proxy&lt;/li&gt;
&lt;li&gt;支持的事件源和消息系统还很有限，外部事件只支持 github、kubernetes 和 Google PubSub。这个问题可以慢慢扩展，knative 本身会实现很常用的事件类型，自定义的事件源用户可以自己实现&lt;/li&gt;
&lt;li&gt;目前还没有函数的 pipeline 管理（类似 AWS Lambda Step Functions），多个函数如何协作并没有自己处理。虽然没有在官方文档中看到这方面的 roadmap，但是以后一定会有这方面的功能（不管是 knative 本身来做，还是社区作为工具补充来实现）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这方面的问题都不是大事情，随着 knative 版本的迭代，在很快的时间都能够解决。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Google Cloud Platform 宣布 Knative 发布的博客文章： &lt;a href=&#34;https://cloudplatform.googleblog.com/2018/07/bringing-the-best-of-serverless-to-you.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Platform Blog: Bringing the best of serverless to you&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;the Newstack 上非常好的科普文章： &lt;a href=&#34;https://thenewstack.io/knative-enables-portable-serverless-platforms-on-kubernetes-for-any-cloud/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Enables Portable Serverless Platforms on Kubernetes, for Any Cloud - The New Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Serving 的设计理念：&lt;a href=&#34;https://docs.google.com/presentation/d/1CbwVC7W2JaSxRyltU8CS1bIsrIXu1RrZqvnlMlDaaJE/edit#slide=id.g32c674a9d1_0_5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://docs.google.com/presentation/d/1CbwVC7W2JaSxRyltU8CS1bIsrIXu1RrZqvnlMlDaaJE/edit#slide=id.g32c674a9d1_0_5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;knative 官方文档：&lt;a href=&#34;https://github.com/knative/docs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub - knative/docs: Documentation for users of Knative components&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Google Cloud Next 2018 大会上宣布 knative 的视频 presentation： &lt;a href=&#34;https://www.youtube.com/watch?v=LtELzpw1l1M&amp;amp;t=1s&amp;amp;list=PLBgogxgQVM9v0xG0QTFQ5PTbNrj8uGSS-&amp;amp;index=105&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes, Serverless, and You (Cloud Next ’18) - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/knative/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Knative 产品页面，目前只有最简单的介绍和文档链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Serverless Jenkins 和 Jenkins X</title>
      <link>https://cloudnative.to/blog/serverless-jenkins-with-jenkins-x/</link>
      <pubDate>Tue, 04 Dec 2018 14:47:13 +0800</pubDate>
      <guid>https://cloudnative.to/blog/serverless-jenkins-with-jenkins-x/</guid>
      <description>&lt;p&gt;















&lt;figure  id=&#34;figure-jenkins-x&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Jenkins x&#34; srcset=&#34;
               /blog/serverless-jenkins-with-jenkins-x/006tNbRwly1fxupra5gsfj30bx0epgn0_hu10618078412741882716.webp 400w,
               /blog/serverless-jenkins-with-jenkins-x/006tNbRwly1fxupra5gsfj30bx0epgn0_hu1708527284179556735.webp 760w,
               /blog/serverless-jenkins-with-jenkins-x/006tNbRwly1fxupra5gsfj30bx0epgn0_hu9110473000119644296.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/serverless-jenkins-with-jenkins-x/006tNbRwly1fxupra5gsfj30bx0epgn0_hu10618078412741882716.webp&#34;
               width=&#34;429&#34;
               height=&#34;529&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Jenkins x
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/@jdrawlings/serverless-jenkins-with-jenkins-x-9134cbfe6870&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Jenkins 服务来源于创建自 2004 年的 Hudson。在软件行业中，Jenkins 已经是家喻户晓的明星产品，并且已经是 CI 和 CD 的领头羊。到目前为止有超过 2050 万的 Jenkins 任务，以及将近 20 万的 Jenkins 服务在运行中。这真的是非常惊人的增长速度。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-jenkins-的增长变化图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;jenkins 的增长变化图&#34; srcset=&#34;
               /blog/serverless-jenkins-with-jenkins-x/5f3e3349gy1fxsw5vx2ooj20jk0c6gmj_hu16045134357453091685.webp 400w,
               /blog/serverless-jenkins-with-jenkins-x/5f3e3349gy1fxsw5vx2ooj20jk0c6gmj_hu1141001929273088922.webp 760w,
               /blog/serverless-jenkins-with-jenkins-x/5f3e3349gy1fxsw5vx2ooj20jk0c6gmj_hu13419906667055806187.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/serverless-jenkins-with-jenkins-x/5f3e3349gy1fxsw5vx2ooj20jk0c6gmj_hu16045134357453091685.webp&#34;
               width=&#34;704&#34;
               height=&#34;438&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      jenkins 的增长变化图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上面的增长图说明在技术领域已经有很大的进步，列如云计算和容器，这些变化说明 Jenkins 在很多方面已经起到了很好的作用，我们应该很好的利用这些影响力。如今，很多公司都开始进行容器化改造，我们希望 jenkins 能跟上时代的步伐，开始自己的云原生之路。Jenkins 应当继续成长，提供更多大家需要的自动化，可靠性，以及更好的开发体验。&lt;/p&gt;
&lt;p&gt;Jenkins 在取得巨大成功的同时，也产生了一些问题。&lt;/p&gt;
&lt;p&gt;下面让我们来简要描述一些我们了解到的比较重要的问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Jenkins 服务的单点问题。特别是在服务维护期间，git webhook 的操作都会被丢失。&lt;/li&gt;
&lt;li&gt;Jenkins 服务经常将磁盘跑满，需要脚本或者人工清理之后，才能继续运行。&lt;/li&gt;
&lt;li&gt;在服务升级之后，plugin 的版本会匹配不上。&lt;/li&gt;
&lt;li&gt;多分支扫描，经常导致 GitHub 的速率被限制。&lt;/li&gt;
&lt;li&gt;在没有任何任务执行时，也需要占用巨大的内存，从基于使用情况来看，这是一种巨大的浪费。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;未来的改进：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低云计算开销，只在有任务需要被构建时才执行 jenkins 服务。&lt;/li&gt;
&lt;li&gt;尽量使用上一次的临时构建通道，避免磁盘被耗尽。&lt;/li&gt;
&lt;li&gt;通过持续集成进行插件的安装和插件的升级更新。&lt;/li&gt;
&lt;li&gt;提供高可用性和可伸缩性的 webhook 操作，来解决 spof 问题。&lt;/li&gt;
&lt;li&gt;避免由于 GitHub 的 API 扫描导致的速度风险。&lt;/li&gt;
&lt;li&gt;提供灾难恢复策略，用来恢复存储在 git 上的所有配置信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Jenkins x 项目在今年早些时候对外宣布为基于 kubernetes 的 pull 请求和 gitops 自动升级提供了 CI 和 CD（Testing&amp;ndash;&amp;gt;Staging&amp;ndash;&amp;gt;Production）。Jenkins X 同样继承了 kubernetes 的 CRD 特性 (&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; title=&#34;custom resource definitions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;custom resource definitions&lt;/a&gt;)，并为你的 Jenkins 服务和作业提供了编排功能。&lt;/p&gt;
&lt;p&gt;Jenkins x 和 Jenkins 激动的宣布无服务的 Jenkins。Jenkins x 既能编排无服务的 jenkins，一个静态的 jenkins master，也能为每一个 team 提供 Knative 构建；因此现在开源的 Jenkins 云拥有完整的 Knative 构建支持。&lt;/p&gt;
&lt;p&gt;无服务 Jenkins 使用成功的并且创新开源项目来解决和上述静态 Jenkins master 的问题。Kubernetes 现在是事实的云实现，因此现在让我们专注在那些不太有名的，却能使得无服务的 Jenkins 成为可能的项目：Prow and Knative build。&lt;/p&gt;
&lt;p&gt;在这篇博客的底部，有一个链接到未经编辑的 Youtube，它演示了这系列的操作。&lt;/p&gt;
&lt;h2 id=&#34;prow-是什么&#34;&gt;Prow 是什么？&lt;/h2&gt;
&lt;p&gt;Prow 来源于 google 的电子商务系统。被一帮纠结于是否需要使用 Jenkins 来构建那些基于 kubernetes 的 GitHub repos 的优秀群体所创建。Kubernetes 是 GitHub 上最成功的项目之一。Prow 被用于&lt;a href=&#34;https://github.com/istio&#34; title=&#34;Istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;和&lt;a href=&#34;https://github.com/jetstack/&#34; title=&#34;Jetstack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jetstack&lt;/a&gt;的同时，还被 140 个项目使用。有许多不同的职责的微服务组成的基于事件的解决方案——为云原生提供了理想的松散耦合架构。对于 merge 到 master 上请求，有了更加有力的方式（不管是在构建请求之前，还是之后），可以使用 ChatOps 和构建系统进行交互。&lt;/p&gt;
&lt;p&gt;Prow 提供了可伸缩的，高可用的 webhook 事件处理器，可以将 ProwJobs 的 CRDs 请求写入到 kubernetes，以至于像正在运行中的持续集成或者发布服务等其它微服务收到响应，并执行操作（kubernetes controller 对于 ProwJob 事件进行了监听）。Git 事件可以是新的 PR、issue、评论、merge、push 等操作都会触发 git event，因此我们能对更多的事件请求响应。&lt;/p&gt;
&lt;p&gt;对于一些已经提供了一组配置规则的目录，我们提供了自动 merge pull request 功能。对于 Prow 组件和描述参考如下链接&lt;a href=&#34;https://github.com/kubernetes/test-infra/tree/master/prow&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/kubernetes/test-infra/tree/master/prow&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Prow 同样也将它的配置信息存储在 git 上，这样在出现问题时可以进行恢复。Jenkins X 项目在向用户发布前已经进行了广泛的测试和验证。你能在如下地址上看到 Jenkins X项目对于CI/CD提供了很多基于yaml的Prow配置&lt;a href=&#34;https://github.com/jenkins-x/prow-config&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/jenkins-x/prow-config&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;knative-build&#34;&gt;Knative Build&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/build&#34; title=&#34;Knative Build&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Build&lt;/a&gt;是一个继承自 Kubernetes 项目的云原生解决方案。让用户可以直接从源码进行构建。Knative Build 最大的特色就是可以将一些简单的操作在同一个 pod 中的串联起来的执行，还可以在容器间进行状态的共享。这个特性通过&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/init-containers/&#34; title=&#34;Kubernetes init containers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes init containers&lt;/a&gt;进行初始化。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/build-templates&#34; title=&#34;Build Templates&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Build Templates&lt;/a&gt;是可以通过 Kubernetes pod 来直接运行你构建的项目。这个允许你在构建项目时，事先指定要需要运行的 docker image，构建时需要用到的环境变量、service accounts、secret 以及需要 mount 的存储卷。build template 是 kubernetes CRD 的集合。可以使用 Jenkins x 进行自动升级。通过 build template 创建或者引入一个应用时，可以使用 jenkins x 产生 Prow 配置。在 Jenkins x 项目中有一个列子是在&lt;a href=&#34;https://github.com/jenkins-x-charts/jx-build-templates/blob/81fd333/jx-build-templates/templates/jenkins-go-buildtemplate.yaml#L4&#34; title=&#34;BuildTemplate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BuildTemplate&lt;/a&gt;中配置&lt;a href=&#34;https://github.com/jenkins-x/prow-config/blob/7dcda43/prow/config.yaml#L138-L139&#34; title=&#34;prow config pointing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;prow config pointing&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;什么是无服务-jenkins&#34;&gt;什么是无服务 Jenkins&lt;/h2&gt;
&lt;p&gt;现在您已经了解了我们正在做的事情的背景，我们可以看看无服务 Jenkins。云原生 Jenkins 正在努力帮助开发人员、团队和组织迁移到云，并确保 Jenkins 不仅与云相关，还允许我们利用云和 Jenkins 最擅长的东西。&lt;/p&gt;
&lt;p&gt;详情：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-credit-thanks-to-gareth-evans-for-the-diagram&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Credit: thanks to Gareth Evans for the diagram&#34; srcset=&#34;
               /blog/serverless-jenkins-with-jenkins-x/5f3e3349gy1fxsw5gepi2j20id0jrt9z_hu8131205625787832423.webp 400w,
               /blog/serverless-jenkins-with-jenkins-x/5f3e3349gy1fxsw5gepi2j20id0jrt9z_hu4115874897965790967.webp 760w,
               /blog/serverless-jenkins-with-jenkins-x/5f3e3349gy1fxsw5gepi2j20id0jrt9z_hu6596188164006437687.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/serverless-jenkins-with-jenkins-x/5f3e3349gy1fxsw5gepi2j20id0jrt9z_hu8131205625787832423.webp&#34;
               width=&#34;661&#34;
               height=&#34;711&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Credit: thanks to Gareth Evans for the diagram
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用基于 Kubernetes 的 Jenkins X 将会帮你自动安装和配置 Prow 和 Knative，下面我们开始准备进行安装。当创建项目或者引入项目时，jx cli 生成了所有需要的配置，并且更新 git repo webhook endpoint。&lt;/p&gt;
&lt;p&gt;现在，每个 pull 请求或合并到 master 的请求都会触发使用 Knative 在 Kubernetes 中产生一个临时的 Jenkins 操作，checkout git revision，配置所需的凭证，并使用 Jenkinsfile 运行应用程序构建管道。一旦构建完成，它将丢弃 Jenkinsfile 运行程序 pod。&lt;/p&gt;
&lt;p&gt;多亏了&lt;a href=&#34;https://github.com/jenkinsci/custom-war-packager&#34; title=&#34;War Packager&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;War Packager&lt;/a&gt;（CWP），Jenkins X 发布过程构建了不同风格的 Jenkins 服务器，其中包含必要的构建工具。语言检测确保使用正确的风格。我们还使用&lt;a href=&#34;https://github.com/jenkinsci/configuration-as-code-plugin&#34; title=&#34;Configuration as Code plugin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Configuration as Code plugin&lt;/a&gt;（CasC）在构建时添加必要的 Jenkins 配置。CWP 很棒的特性之一是它提取 Jenkins 插件再构建 serverless Jenkins（而不是当 serverless Jenkins），所以在基于 Jenkins image 的容器和 JVM 中启动 Jenkins X 耗时 5 秒——相比之下，要花几分钟启动基于 Kubernetes 的 Jenkins server。&lt;/p&gt;
&lt;p&gt;每当我们发布 Jenkins X 时，我们有一个&lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-serverless&#34; title=&#34;monorepo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;monorepo&lt;/a&gt;，它用于自动构建和发布这些程序指定的 Jenkins image。&lt;/p&gt;
&lt;p&gt;这也意味着，因为插件是在&lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-serverless/blob/master/packager-config.yml#L29-L170&#34; title=&#34;yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;yaml&lt;/a&gt;中定义的，并存储在 git 中，所以我们可以为 CI 和 CD 工具提供 CI 和 CD。当我们想要升级一个插件时，我们发出一个 pull 请求，它会触发 CI 并构建一个预览 Jenkins image，确保没有插件冲突，我们甚至可以运行模拟作业作为自动化测试（尽管我们还没有完成这一部分）。每个人都可以采用完全相同的方法，构建定制的 Serverless Jenkins images，以相同的方式在管道中使用。&lt;/p&gt;
&lt;p&gt;突出的一件事是，当你切换到 Serverless Jenkins，进行构建是没有状态存储（这意味着为每个 Job 构建的编号总是 1）。在 Jenkins X 中，我们为了 PipelineActivity 创建的 CRD，所以这就允许我们在单个 Jenkins 构建完成之后想象先前的构建管道可以生成下一个构建编号和存储信息。&lt;/p&gt;
&lt;p&gt;当 Prow 收到 webhook 事件时，它将在 Kubernetes 中创建一个 Knative 构建资源。接下来，监视构建的 Knative 构建控制器将创建一个 Kubernetes pod，并自动添加一个克隆 PR 或发布分支源代码的 init 容器。接下来，利用&lt;a href=&#34;https://github.com/jenkinsci/jenkinsfile-runner&#34; title=&#34;Jenkinsfile runner&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jenkinsfile runner&lt;/a&gt;，在一个单独的步骤中启动 Jenkins 可以访问 Knative 克隆的源代码并处理应用程序 Jenkinsfile。&lt;/p&gt;
&lt;h2 id=&#34;如何开始尝试&#34;&gt;如何开始尝试？&lt;/h2&gt;
&lt;p&gt;今天，含有 Prow 的 Jenkins X 在使用 terraform via 在 GKE 上创建集群时开箱即用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;jx create terraform
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者在其他创建集群或安装命令上使用功能标志时，即：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;jx create cluster gke --prow 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;jx install — prow
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;faq&#34;&gt;FAQ&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果没有运行中的 Jenkins 服务，如何访问 UI？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一个非常重要的问题是 Serveless Jenkins 没有开源的 Jenkins UI。下面我们来解释一下，Jenkins X 具有可以使 Jenkins X 开发人员感到友好的 IDE 和 CLI 工具，但 UI 已经消失了。Prow 有一个名为 Deck 的开源 UI，Jenkins X 安装了 OOTB。CloudBees 可能很快也将提供免费增值 UI，但有关详细信息，请自行查找。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从哪里可以看到构建的日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前 Jenkinsfile runner 将构建日志发送到标准输出，但是一个允许我们利用 Kubernetes 集群集中日志记录的更好的解决方案将被开发，如 Stackdriver，CloudWatch。我们还提供&lt;code&gt;jx logs -k&lt;/code&gt;（在构建运行时可用）和&lt;code&gt;jx get build log&lt;/code&gt;（可用几个小时）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我是否需要更改依赖于特定 Jenkins multibranch 插件环境变量（如&lt;code&gt;$ JOB_NAME&lt;/code&gt;）的 Jenkinsfile？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不，我们已经尝试确保所有与 MBP 相关的环境变量仍然以相同的格式添加。如果还有什么没有被添加的。请让我们知道。&lt;/p&gt;
&lt;h2 id=&#34;如何将-jenkinsfiles-迁移到-serveless-jenkins&#34;&gt;如何将 Jenkinsfiles 迁移到 Serveless Jenkins？&lt;/h2&gt;
&lt;p&gt;Jenkins X 项目本身已经从使用静态（永远在线）Jenkins 服务器迁移到 Serveless Jenkins。是的，我们将 Jenkins 服务器缩小到 0 并将我们所有的 Git 存储转移到 Prow 和 Serverless Jenkins。您可以在&lt;a href=&#34;https://github.com/jenkins-x/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/jenkins-x/&lt;/a&gt;组织上查看任何拉取请求，以查看它的实际运行情况。我们使用的是&lt;a href=&#34;https://github.com/jenkins-x/draft-packs/blob/prow/packs/javascript/Jenkinsfile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;declarative style Jenkinsfile&lt;/a&gt;（这是我们在将新项目导入 Jenkins X 时添加的），这意味着迁移到 Serverless Jenkins 只需要对 Jenkins 文件进行一些调整：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将代理类型更改为“any”，以便在一个临时的单独的 Jenkins 上执行管道&lt;/li&gt;
&lt;li&gt;现在删除所有 Jenkinsfile 容器块，假设所有步骤都在一个单独的 Jenkins 管道引擎中执行。&lt;/li&gt;
&lt;li&gt;对于任何发布分支管道都应该有一个标记（它们都应该创建一个 git 标签！），然后我们必须进行从 checkout scm 到 git&amp;rsquo;github / foo.git&amp;rsquo;的切换，因为重新使用来自 Knative 和 Jenkinsfile runner 的克隆 repo 有问题，好像是因为将 repo 添加到 Jenkins 工作区时使用的是符号链接。我们希望解决这个问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/jenkins-x/jenkins-x-platform/commit/ca9e0a58a76519193a2c7a0d8cf277dfc11babe4&#34; title=&#34;这里&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;可以看到上述变化的一个例子。要启用 prow 的 ChatOps &lt;code&gt;/approve&lt;/code&gt;注释，您还需要一个类似的 OWNERS 文件到该链接，该文件使用批准者 GitHub ID。&lt;/p&gt;
&lt;h2 id=&#34;当前的限制&#34;&gt;当前的限制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;目前只有 GitHub，我们将为多个 git 提供者提供支持&lt;/li&gt;
&lt;li&gt;Jenkins X 使用了另一个分支，但是在接下来的几周内它将被切换回使用上游的 prow repo&lt;/li&gt;
&lt;li&gt;默认情况下，Jenkins X 会创建一个声明性管道 Jenkinsfiles，这尚未在脚本和共享库 Jenkinsfile 管道上进行测试，但如果按预期工作，我们很想收到反馈。&lt;/li&gt;
&lt;li&gt;Kubernetes Plugin PodTemplates 尚不支持。我们不确定这是否是一个好主意。这意味着如果要迁移具有多个不同容器{&amp;hellip;}块的现有 Jenkinsfiles，则需要将每个容器的构建工具添加到上面由 CWP 创建的单个一次性 Jenkins 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有工作要做，所以如果你想参与其中，请在&lt;a href=&#34;https://jenkins-x.io/community/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jenkins X Kubernetes slack rooms&lt;/a&gt;打个招呼来帮助解决问题，或先试试，让我们知道你是怎么做到的。&lt;/p&gt;
&lt;p&gt;现在和我们一起参加&lt;a href=&#34;https://www.cloudbees.com/devops-world/nice&#34; title=&#34; Jenkins World Nice&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Jenkins World Nice&lt;/a&gt;并不会太晚，我们将在现场演示中展示这个以及其他精彩的演讲！&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Jenkins X 是可供团队使用的一站式服务，可用来进行 Prow ChatOps 编排静态、无服务器或 Knative 构建作业，其中包括用于 Kubernetes 工作负载的自动化 CI/CD 以及更多自动化。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基于 Kubernetes 和 Istio 的 Serverless 框架 Knative 解析之 Autoscaler</title>
      <link>https://cloudnative.to/blog/knative-serving-autoscaler-single-tenancy-deep-dive/</link>
      <pubDate>Tue, 07 Aug 2018 22:20:49 +0800</pubDate>
      <guid>https://cloudnative.to/blog/knative-serving-autoscaler-single-tenancy-deep-dive/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;我们都是知道 Kubernetes 中个资源对象叫 autoscaler，该对象在 serverless 架构中更是不可或缺，有了它可以负责应用的自动水平伸缩，用户再也不用关心示例的个数和资源消耗，本文是来自阿里巴巴 UC 事业群基础研发部的陈有坤同学对 Knative 的解析之 autoscaler 部分，还有大量的解析等待放出，起关注本站的后续内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative&lt;/a&gt;是一款基于 Kubernetes 的平台，用来构建、部署和管理现代 serverless 应用的框架。该框架试图将云原生应用开发的以下三个领域的最佳实践结合起来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建容器（和函数）&lt;/li&gt;
&lt;li&gt;为工作负载提供服务（和动态扩展）&lt;/li&gt;
&lt;li&gt;事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Knative 是由谷歌与&lt;a href=&#34;https://content.pivotal.io/blog/knative-powerful-building-blocks-for-a-portable-function-platform&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pivotal&lt;/a&gt;、&lt;a href=&#34;https://www.ibm.com/blogs/cloud-computing/2018/07/24/ibm-cloud-google-knative-serverless/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM&lt;/a&gt;、&lt;a href=&#34;https://blog.openshift.com/state-of-serverless-in-kubernetes-knative-and-openshift-cloud-functions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat&lt;/a&gt; 和&lt;a href=&#34;https://blogs.sap.com/?p=696354&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SAP&lt;/a&gt;紧密协作开发的。 &lt;/p&gt;
&lt;p&gt;Knative 构建在 Kubernetes 和&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;之上，它的设计考虑到了多种角色通过该框架进行交互，包括开发人员、运维人员和平台提供者。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-serving-autoscaler-single-tenancy-deep-dive/0069RVTdgy1fu1er29srhj30ws0mpgo9_hu9527562046558606358.webp 400w,
               /blog/knative-serving-autoscaler-single-tenancy-deep-dive/0069RVTdgy1fu1er29srhj30ws0mpgo9_hu8082051280090971795.webp 760w,
               /blog/knative-serving-autoscaler-single-tenancy-deep-dive/0069RVTdgy1fu1er29srhj30ws0mpgo9_hu7625566482949973097.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-serving-autoscaler-single-tenancy-deep-dive/0069RVTdgy1fu1er29srhj30ws0mpgo9_hu9527562046558606358.webp&#34;
               width=&#34;760&#34;
               height=&#34;526&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Knative 所涉及的角色（图片来源于&lt;a href=&#34;https://github.com/knative/docs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative GitHub 仓库&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;Knative 致力于提供可重用的“通用模式和最佳实践组合”实现，目前可用的组件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/build&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Build&lt;/a&gt;：从源到容器的构建编排；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/eventing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Eventing&lt;/a&gt;：管理和交付事件；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/serving&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Serving&lt;/a&gt;：请求驱动的计算，可以缩放到零。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;以上内容引用自： &lt;a href=&#34;http://www.infoq.com/cn/news/2018/07/knative-kubernetes-serverless&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfoQ | 谷歌发布 Knative：用于构建、部署和管理 Serverless 工作负载的 Kubernetes 框架&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是对 Knative 的基本介绍，关于 Knative 的更多信息大家可以关注其 GitHub：&lt;a href=&#34;https://github.com/knative&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/knative&lt;/a&gt;，我们都是知道 Kubernetes 中个资源对象叫&lt;code&gt;autoscaler&lt;/code&gt;，该对象在 serverless 架构中是不可或缺的，有了它可以负责应用的自动水平伸缩，用户再也不用关心示例的个数和资源消耗，下文是来自阿里巴巴 UC 事业群的陈有坤同学对 Knative 的解析。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面首先解析的是 Serving 中的 Autoscaling 组件，该组件的功能是根据网络流量来自动伸缩应用实例的个数。&lt;/p&gt;
&lt;h2 id=&#34;knative-是如何做伸缩容的&#34;&gt;Knative 是如何做伸缩容的？&lt;/h2&gt;
&lt;p&gt;处理伸缩容问题，首先要解决的问题是根据什么指标判断伸缩容？cpu、内存、请求数？这里 knative 使用的是请求数。&lt;/p&gt;
&lt;p&gt;其次是伸缩多少的问题。&lt;/p&gt;
&lt;p&gt;Knative 的伸缩是依赖修改 deployment 的 replica 数实现的。&lt;/p&gt;
&lt;h2 id=&#34;如何采集请求数&#34;&gt;如何采集请求数？&lt;/h2&gt;
&lt;p&gt;启动 revision 的 pod 时，也会启动一个 autoscaler（一个 knative revision 只启动一个 autoscaler），autoscaler 自己本身也会 scale 到 0，用于接收请求数统计和处理伸缩容。&lt;/p&gt;
&lt;p&gt;业务 pod 中，会注入 queue-proxy sidecar，用于接收请求，在这里会统计并发数，每秒向 autoscaler 汇报，接收到的请求会转发给业务 container。&lt;/p&gt;
&lt;p&gt;注：单租户模式下一个 revision 启动一个 autoscaler，多租户共用一个 autoscaler&lt;/p&gt;
&lt;h2 id=&#34;计算需要-pod-的个数&#34;&gt;计算需要 pod 的个数？&lt;/h2&gt;
&lt;p&gt;autoscaler 接收到并发统计的时候，会根据算法计算需要的 pod 个数。&lt;/p&gt;
&lt;p&gt;算法中有两种模式，分别是 panic 和 stable 模式，一个是短时间，一个是长时间，为了解决短时间内请求突增的场景，需要快速扩容。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/docs/blob/master/serving/samples/autoscale-go/README.md#algorithm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档中描述&lt;/a&gt;的算法是，默认的 target concurrency 是 1，如果一个 revision 35QPS，每个请求花费 0.25 秒，Knative Serving 觉得需要 9 个 pod。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ceil&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;35&lt;/span&gt; * .25&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; ceil&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;8.75&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;9&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;stable-mode稳定模式&#34;&gt;Stable Mode（稳定模式）&lt;/h4&gt;
&lt;p&gt;在稳定模式下，Autoscaler 根据每个 pod 期望的并发来调整 Deployment 的副本个数。根据每个 pod 在 60 秒窗口内的平均并发来计算，而不是根据现有副本个数计算，因为 pod 的数量增加和 pod 变为可服务和提供指标数据有一定时间间隔。&lt;/p&gt;
&lt;h4 id=&#34;panic-mode恐慌模式&#34;&gt;Panic Mode（恐慌模式）&lt;/h4&gt;
&lt;p&gt;Panic 时间窗口默认是 6 秒，如果在 6 秒内达到 2 倍期望的并发，则转换到恐慌模式下。在恐慌模式下，Autoscaler 根据这 6 秒的时间窗口计算，这样更能及时的响应突发的流量请求。每 2 秒调整 Deployment 的副本数达到想要的 pod 个数（或者最大 10 倍当前 pod 的数量），为了避免 pod 数量频繁变动，在恐慌模式下只能增加，不会减少。60 秒后会恢复回稳定模式。&lt;/p&gt;
&lt;h1 id=&#34;autoscaler-单租户图&#34;&gt;autoscaler 单租户图&lt;/h1&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/knative-serving-autoscaler-single-tenancy-deep-dive/0069RVTdgy1fu1g19gvitj31kw13agrp_hu11475525043676078418.webp 400w,
               /blog/knative-serving-autoscaler-single-tenancy-deep-dive/0069RVTdgy1fu1g19gvitj31kw13agrp_hu3565741337247230807.webp 760w,
               /blog/knative-serving-autoscaler-single-tenancy-deep-dive/0069RVTdgy1fu1g19gvitj31kw13agrp_hu17849706816313740141.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/knative-serving-autoscaler-single-tenancy-deep-dive/0069RVTdgy1fu1g19gvitj31kw13agrp_hu11475525043676078418.webp&#34;
               width=&#34;760&#34;
               height=&#34;524&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上图基于 &lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/scaling/DEVELOPMENT.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/knative/serving/blob/master/docs/scaling/DEVELOPMENT.md&lt;/a&gt; 绘制。&lt;/p&gt;
&lt;h1 id=&#34;模式&#34;&gt;模式&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;c1&#34;&gt;// 每个 pod 实例同时只处理一个请求
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;nx&#34;&gt;RevisionRequestConcurrencyModelSingle&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;RevisionRequestConcurrencyModelType&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Single&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;c1&#34;&gt;// 每个 pod 实例同时处理多个请求
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;nx&#34;&gt;RevisionRequestConcurrencyModelMulti&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;RevisionRequestConcurrencyModelType&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Multi&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;配置&#34;&gt;配置&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apiVersion: v1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kind: ConfigMap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  name: config-autoscaler
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  namespace: knative-serving
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;data:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# Static parameters:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 期望每个pod并发请求数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  multi-concurrency-target: &lt;span class=&#34;s2&#34;&gt;&amp;#34;1.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 如果是单个并发，值要接近1.0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  single-concurrency-target: &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.9&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# stable窗口时间，计算平均并发会用到。如果进入panic模式后，经过stable窗口时间也会恢复stable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  stable-window: &lt;span class=&#34;s2&#34;&gt;&amp;#34;60s&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 如果平均并发在panic窗口时间内达到2倍目标并发，autoscaler进入panic模式。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 在panic模式下，自动伸缩按在panic窗口时间的平均并发来操作。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  panic-window: &lt;span class=&#34;s2&#34;&gt;&amp;#34;6s&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 最大增长比例，每次调整会根据并发计算增长比例，最大增长不超过这个值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  max-scale-up-rate: &lt;span class=&#34;s2&#34;&gt;&amp;#34;10&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 计算并发值的参数，每一段时间得到最大并发，作为一个bucket，最后汇报的时候，&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 平均并发 = 各个bucket最大并发之和 / 总bucket数，汇报间隔是1秒（hard coded）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  concurrency-quantum-of-time: &lt;span class=&#34;s2&#34;&gt;&amp;#34;100ms&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 是否开启缩容到0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  enable-scale-to-zero: &lt;span class=&#34;s2&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 实验性：开启垂直扩容&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# Requires a VPA installation (e.g. ./third_party/vpa/install-vpa.sh)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  enable-vertical-pod-autoscaling: &lt;span class=&#34;s2&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 如果开启了enable-vertical-pod-autoscaling，这个值就会替代multi-concurrency-target，&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 如果成熟了后期会变成默认值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  vpa-multi-concurrency-target: &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 多长时间调整一次&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  tick-interval: &lt;span class=&#34;s2&#34;&gt;&amp;#34;2s&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# Dynamic parameters (take effect when config map is updated):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 空闲多长时间缩容到0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  scale-to-zero-threshold: &lt;span class=&#34;s2&#34;&gt;&amp;#34;5m&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>
