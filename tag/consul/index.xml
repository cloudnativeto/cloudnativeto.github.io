<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>consul | 云原生社区</title>
    <link>https://cloudnative.to/tag/consul/</link>
      <atom:link href="https://cloudnative.to/tag/consul/index.xml" rel="self" type="application/rss+xml" />
    <description>consul</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 04 Jun 2020 00:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>consul</title>
      <link>https://cloudnative.to/tag/consul/</link>
    </image>
    
    <item>
      <title>如何将第三方服务中心注册集成到 Istio ？</title>
      <link>https://cloudnative.to/blog/istio-service-registy-integration/</link>
      <pubDate>Thu, 04 Jun 2020 00:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-service-registy-integration/</guid>
      <description>&lt;p&gt;作为云原生服务网格领域的热门开源项目，Istio 可以为微服务提供无侵入的流量管理、安全通信、服务可见性等服务治理能力。目前越来越多的微服务项目开始考虑将自己的微服务基础设施向 Istio 进行迁移。&lt;/p&gt;
&lt;p&gt;Istio 对 Kubernetes 具有较强的依赖性，其服务发现就是基于 Kubernetes 实现的。如果要使用 Istio，首先需要迁移到 Kubernetes 上，并使用 Kubernetes 的服务注册发现机制。但是对于大量现存的微服务项目来说，这个前提条件并不成立。很多微服务项目要么还没有迁移到 Kubernetes 上；要么虽然采用了 Kubernetes 来进行部署和管理，但还是使用了 Consul，Eureka 等其他服务注册解决方案或者自建的服务注册中心。&lt;/p&gt;
&lt;p&gt;在这种情况下，我们如何能够以最小的代价快速地将现有微服务项目和 Istio 进行集成，以享受 Istio 提供的各种服务治理能力呢？本文将分析 Istio 服务注册机制的原理，并提出几种 Istio 与第三方服务注册中心集成的可行方案，以供读者参考。&lt;/p&gt;
&lt;h2 id=&#34;istio-服务模型&#34;&gt;Istio 服务模型&lt;/h2&gt;
&lt;p&gt;我们先来看一下 Istio 内部的服务模型。在 Istio 控制面中，Pilot 组件负责管理服务网格内部的服务和流量策略。Pilot 将服务信息和路由策略转换为 xDS 接口的标准数据结构，下发到数据面的 Envoy。但 Pilot 自身并不负责网格中的服务注册，而是通过集成其他服务注册表来获取网格中管理的服务。除此以外，Istio 还支持通过 API 向网格中添加注册表之外的独立服务。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34;
           src=&#34;https://cloudnative.to/blog/istio-service-registy-integration/pilot-services-source.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

图1 Istio 服务模型数据来源&lt;/p&gt;
&lt;p&gt;从上图中可以得知， Pilot 中管理的服务数据有两处数据来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Registry：来源于各个服务注册表，例如 Kubernetes 中的 Service 和 Consul Catalog 中注册的服务。Istio 通过特定的适配器连接这些服务注册表，由适配器将服务注册表中的私有服务模型转换为 Istio 内部支持的标准服务模型。&lt;/li&gt;
&lt;li&gt;Config Storage：来源于各种配置数据源中的独立服务，通过 Istio 定义的 &lt;a href=&#34;https://istio.io/docs/reference/config/networking/service-entry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ServiceEntry&lt;/a&gt; 和 &lt;a href=&#34;https://istio.io/docs/reference/config/networking/workload-entry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WorkloadEntry&lt;/a&gt; 资源类型加入到 Pilot 的内部服务模型中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pilot-服务模型源码分析&#34;&gt;Pilot 服务模型源码分析&lt;/h2&gt;
&lt;p&gt;Pilot 中涉及到服务模型的代码模块如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34;
           src=&#34;https://cloudnative.to/blog/istio-service-registy-integration/pilot-service-model.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

图2 Pilot 服务模型相关的代码结构&lt;/p&gt;
&lt;p&gt;Pilot 的入口函数是 pilot/cmd/pilot-discovery/main.go 中的 main 方法。main方法中创建了 Discovery Server，Discovery Server 中和服务模型相关的主要包含三部分内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Config Controller&lt;/strong&gt;：用于管理各种配置数据，包括用户创建的流量管理规则和策略。配置数据中有两个 API 对象和服务模型相关，ServiceEntry 和 WorkloadEntry。Istio 目前支持三种类型的 Config Controller：
&lt;ul&gt;
&lt;li&gt;Kubernetes：使用 Kubernetes 来作为配置数据的存储，该方式的直接依附于 Kubernetes 强大的 CRD 机制来存储配置数据，简单方便，是 Istio 缺省使用的配置存储方案。&lt;/li&gt;
&lt;li&gt;Memory：一个在内存中的 Config Controller 实现，可以监控一个文件目录，加载该目录中的 yaml 文件中定义的 Istio API 配置对象，该方式主要用于测试。&lt;/li&gt;
&lt;li&gt;MCP：通过 &lt;a href=&#34;https://github.com/istio/api/tree/master/mcp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MCP(Mesh Configuration Protocol)&lt;/a&gt; 协议，可以接入一个到多个 MCP Server。Pilot 从 MCP server 中获取网格的配置数据，包括 ServiceEntry 和 WorkloadEntry 定义的服务数据，以及 VirtualService，DestinationRule 等路由规则等其他配置。Istio 中有一个 Galley 组件，该组件实现为一个 MCP Server，从 Kubernetes API Server 中获取配置数据，然后通过 MCP 协议提供给 Pilot。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service Controller&lt;/strong&gt;：负责接入各种 Service Registry，从 Service Registry 同步需要在网格中进行管理的服务，目前Istio支持的Service Registry包括：
&lt;ul&gt;
&lt;li&gt;Kubernetes：对接 Kubernetes Registry，可以将 Kubernetes 的 Service 和 Endpoint 采集到 Istio 中。&lt;/li&gt;
&lt;li&gt;Consul： 对接Consul Catalog，将注册到 Consul 中的服务数据采集到 Istio 中。&lt;/li&gt;
&lt;li&gt;External Service Discovery：该 Service Registry 比较特殊，后端并未对接到一个服务注册表，而是会监听 Config Controller 的配置变化消息，从 Config Controller 中获取 ServiceEntry 和 WorkloadEntry 资源，然后以 Service Registry 的形式提供给 Service Controller。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Discovery Service&lt;/strong&gt;：将服务模型和控制面配置转换为数据面标准数据格式，通过 xDS 接口下发给数据面的代理。主要包含下述逻辑：
&lt;ul&gt;
&lt;li&gt;启动GRPC Server并接收来自Envoy端的连接请求。&lt;/li&gt;
&lt;li&gt;接收Envoy端的xDS请求，从Config Controller和Service Controller中获取配置和服务信息，生成响应消息发送给Envoy。&lt;/li&gt;
&lt;li&gt;监听来自Config Controller的配置变化消息和来自Service Controller的服务变化消息，并将配置和服务变化内容通过xDS接口推送到Envoy。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第三方服务注册表集成&#34;&gt;第三方服务注册表集成&lt;/h2&gt;
&lt;h3 id=&#34;consul-集成&#34;&gt;Consul 集成&lt;/h3&gt;
&lt;p&gt;鉴于和 Kubernetes 的紧密关系，Istio 在最初只重点关注了 Kubernetes 服务注册的集成。虽然在 Istio 最初的版本中也有 Consul 和 Eureka 的适配代码，但这些代码基本只是处于原型验证的节点，存在较多的故障和性能问题。&lt;/p&gt;
&lt;p&gt;由于在项目中采用了 Consul 作为自研服务注册的后端存储，我们在和 Istio 进行集成时对 Consul 的适配进行了大量测试和研究，并解决了一些功能和性能效率方面的问题。这些 Consul 适配的问题解决后已经合入了 Istio 版本中，参见这些 PR：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/istio/istio/pull/17881&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Use watching instead of polling to get update from Consul catalog #17881&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/istio/istio/pull/15510&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fix: Consul high CPU usage (#15509) #15510&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/istio/istio/pull/12148&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Avoid unnecessary service change events(#11971) #12148&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/istio/istio/pull/9713&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Use ServiceMeta to convey the protocol and other service properties #9713&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些问题处理后，Consul 注册表的集成已经基本可用。要将 Consul 接入到 Pilot 中， 只需要在 pilot-discovery 的启动命令中通过这两个参数指定 registry 类型和 consul 的连接地址即可： &lt;code&gt;--registries Consul&lt;/code&gt;   &lt;code&gt;--consulserverURL http://$consul-ip:$port&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;其他服务注册表的集成&#34;&gt;其他服务注册表的集成&lt;/h3&gt;
&lt;p&gt;虽然在 1.0 中还有 Eureka 的适配代码框架，但在 Istio 后面的版本完全删除了 Eureka 适配的相关代码。除了 Kubernetes 和 Consul 之外，原生 Istio 代码不支持其他服务注册表。但通过前面对 Pilot 服务模型源码的分析，我们可以得出以下三种将其他服务注册表集成到 Istio 的方式。
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34;
           src=&#34;https://cloudnative.to/blog/istio-service-registy-integration/service-registry-integration.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

图3 集成第三方服务注册表的三种方式&lt;/p&gt;
&lt;p&gt;上图中分别用红、绿、蓝三种颜色标识了这三种不同的集成方式。&lt;/p&gt;
&lt;h4 id=&#34;自定义-service-registry-适配器&#34;&gt;自定义 Service Registry 适配器&lt;/h4&gt;
&lt;p&gt;如图3中红色箭头所示，我们可以编写一个自定义的适配器来集成第三方服务注册表。该自定义适配器从第三方服务注册表中获取服务和服务实例，转换为 Pilot 内部的标准模型，集成到 Service Controller 中。自定义适配器需要实现 &lt;code&gt;serviceregistry.Instance&lt;/code&gt; 接口。该方式的原理和 Consul Service Registry 的适配是类似的，可以参照 Consul Service Registry 的适配代码进行编写。&lt;/p&gt;
&lt;p&gt;实施该方案需要熟悉 Pilot 内部服务模型和 Service Registry 适配相关 Istio 源码，并且需要将自定义适配器代码和 Pilot 代码一起编译生成定制的 Pilotd 二进制执行文件。该方案的问题是和 Istio 代码耦合较强，后续 Istio 版本升级时可能需要修改适配器代码并重新编译。&lt;/p&gt;
&lt;h4 id=&#34;自定义-mcp-server&#34;&gt;自定义 MCP Server&lt;/h4&gt;
&lt;p&gt;这种集成方式的业务流程参见图3中的蓝色箭头。该方案需要编写自定义的 MCP Server 从第三方注册表中获取服务和服务实例，然后转换为 ServiceEntry 和 WorkloadEntry 资源，通过 MCP 协议提供给 Pilot 中的 MCP config Controller。&lt;/p&gt;
&lt;p&gt;采用这种方式，需要在 Global Mesh Options 中通过 &lt;a href=&#34;https://istio.io/docs/reference/config/istio.mesh.v1alpha1/#ConfigSource&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;configSources&lt;/a&gt; 参数设置自定义 MCP Server 的地址。需要注意的是，目前1.6的 Config Controller 实现不允许同时使用不同类型的Config controller。这意味着如果采用自定义 MCP Server 来获取第三方注册表中的服务数据，也必须同时采用 Galley 来获取其他控制面的配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;configSources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;address:istio-galley.istio-system.svc:9901&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;address:${your-coustom-mcp-server}:9901&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而从1.5版本开始，&lt;a href=&#34;https://istio.io/news/releases/1.6.x/announcing-1.6/change-notes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Galley 的功能已经被合并到 Istiod 中，并且缺省被禁用&lt;/a&gt;。从 Istio 控制面简化的趋势来看，Galley 后续很可能会被逐渐放弃，其自身功能的稳定性也值得怀疑。因此我不建议在产品中启用 Galley。&lt;/p&gt;
&lt;p&gt;除此以外，根据 Istio 社区中的这个 &lt;a href=&#34;https://docs.google.com/document/d/1lHjUzDY-4hxElWN7g6pz-_Ws7yIPt62tmX3iGs_uLyI/edit#heading=h.xw1gqgyqs5b&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MCP over XDS&lt;/a&gt; proposal，社区正在讨论使用 XDSv3/UDPA 代替目前的 MCP 协议来传输配置数据，因此 MCP server 和 Pilot 的通信机制在 1.7 版本中很可能变化。&lt;/p&gt;
&lt;h4 id=&#34;向-api-server-写入-serviceentry-和-workloadentry&#34;&gt;向 API Server 写入 ServiceEntry 和 WorkloadEntry&lt;/h4&gt;
&lt;p&gt;该集成方式的业务流程如图3中绿色箭头所示。我们只需要编写一个独立的服务，该服务从第三方法服务注册表中获取服务和服务实例数据，然后转换为 Istio 的 ServiceEntry 和 WorkloadEntry 资源，通过 Kubernetes API Server 的接口写入到 API Server 中。 Pilot 中自带的 Kube Config Controller 会监听 Kubernetes API Server 中和 Istio 相关的资源对象的变化，并将 ServiceEntry 和 WorkloadEntry 转换为 Piolt 的内部服务模型。&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文分析了 Istio 和第三方服务注册表集成的几种可能的方式。如果你使用的是 Consul，可以通过配置参数设置 Consul 的连接地址，将 Consul 集成到 Istio 中。 对于其他的服务注册表，有以下三种可选的集成方案： 自定义的 Service Registry 适配代码，自定义 MCP Server，或者采用一个独立服务向 API Server 写入 ServiceEntry 和 WorkloadEntry。 有需要的读者可以根据项目的实际情况选择采用哪一种方法。由于第一种和第二种方法目前都存在一些问题，建议先采用第三种方式，待 Istio 对 Galley 和 MCP 的改造彻底完成后再考虑向第二种方式迁移。&lt;/p&gt;
&lt;p&gt;备注：本文的分析和建议都是基于使用 Istio 1.6 的前提下。随着 Istio 版本的不断发展，其服务模型和注册相关机制可能发生变化，和第三方服务注册表的集成方式也可能变化。&lt;/p&gt;
&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhaohuabing.com/post/2019-02-18-pilot-service-registry-code-analysis&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 服务注册插件机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhaohuabing.com/post/2019-10-21-pilot-discovery-code-analysis&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Pilot代码深度解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/cloud/blog/seamless-integration-istio-and-external-services&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio and managing microservices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/news/releases/1.6.x/announcing-1.6/change-notes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 1.6 Change Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://discuss.istio.io/t/the-recommended-way-to-integrate-a-third-party-service-registry-with-istio/6863&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The recommended way to integrate a third-party service registry with Istio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Consul Service Mesh的7层网络可观察性</title>
      <link>https://cloudnative.to/blog/layer-7-observability-with-consul-service-mesh/</link>
      <pubDate>Fri, 12 Jul 2019 00:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/layer-7-observability-with-consul-service-mesh/</guid>
      <description>&lt;p&gt;&lt;em&gt;编者按：Consul团队写了一篇易懂、又有实操的如何在Service Mesh中，实现服务的可观察性的文章。即使没有太多基础，也能比较容易的看懂并了解service mesh中，如何实现服务的度量。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这是系列博客的第二篇文章，重点介绍Consul服务网格中的新功能。&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;您之前可能已经听过“可观察性”一词，但它实际上意味着什么？ 它只是监控重新品牌，还是更多的可观察性？ 我们正在发布一系列博客文章，讨论服务网格的核心用例。 在本博客中，我们将详细介绍可观察性以及如何启用最近&lt;a href=&#34;https://www.hashicorp.com/blog/hashicorp-consul-1-5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Consul 1.5发布&lt;/a&gt;中包含的Consul Connect的新L7可观察性功能。&lt;/p&gt;
&lt;p&gt;首先，让我们重新审视一个熟悉的概念：监控。&lt;/p&gt;
&lt;h3 id=&#34;监控&#34;&gt;监控&lt;/h3&gt;
&lt;p&gt;监控意味着使用内部或外部工具检测应用程序和系统，以确定其状态。&lt;/p&gt;
&lt;p&gt;例如，您可能有一个外部运行状况检查，用于探测应用程序的状态或确定其当前的资源消耗。 您可能还有内部统计信息，用于报告特定代码块的性能，或执行某个数据库事务所需的时间。&lt;/p&gt;
&lt;h3 id=&#34;可观察性&#34;&gt;可观察性&lt;/h3&gt;
&lt;p&gt;可观察性来自工程和控制理论的世界。控制理论&lt;a href=&#34;https://en.wikipedia.org/wiki/Observability&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;指出&lt;/a&gt;可观察性本身就是一种描述“从外部产出的知识中推断出系统内部状态的程度”的措施。与监视哪些是你所做的相比，可观察性是系统的属性。如果外部输出，日志记录，度量，跟踪，健康检查等允许您了解其内部状态，则可以观察系统。&lt;/p&gt;
&lt;p&gt;可观察性对于频繁发布的现代分布式应用程序尤其重要。与通过进程内调用进行通信的单片体系结构相比，微服务体系结构在服务交互期间会出现更多故障，因为这些调用发生在可能不可靠的网络上。随着为测试创建逼真的类似生产的环境变得越来越困难，在客户开始之前检测生产中的问题变得更加重要。这些服务调用的视图可帮助团队及早发现故障，跟踪故障并设计弹性。&lt;/p&gt;
&lt;p&gt;借助模块化和可独立部署的（微）服务，很难实现对这些服务的可视性。单个用户请求可以流经多个服务，每个服务由不同的团队独立开发和部署。由于无法预测系统中可能发生的每个潜在故障或问题，因此您需要构建一旦部署后易于调试的系统。对网络的了解对于了解这些高度分布式系统的流量和性能至关重要。&lt;/p&gt;
&lt;h2 id=&#34;服务网格&#34;&gt;服务网格&lt;/h2&gt;
&lt;p&gt;服务网格是一种网络基础设施，它利用“边车”代理进行微服务部署。 由于边车代理存在于每个网络跃点，因此它捕获上游和下游通信。 因此，服务网格提供了对所有服务的外部性能的完全可见性。&lt;/p&gt;
&lt;p&gt;采用服务网格的一个主要好处是，边车代理队伍可以完全了解所有服务流量，并且可以以一致的方式公开指标，而不管不同的编程语言和框架。 应用程序仍需要进行检测，以便深入了解内部应用程序性能。&lt;/p&gt;
&lt;h3 id=&#34;控制平面&#34;&gt;控制平面&lt;/h3&gt;
&lt;p&gt;服务网格传统上由两个主要组件构成：控制平面和数据平面。 控制平面为网格中的所有正在运行的数据平面提供策略和配置。 数据平面通常是本地代理，作为应用程序的边车运行。 数据平面根据控制平面中的策略和服务图终止所有TLS连接和托管授权。 Consul构成服务网格的控制平面，简化了边车代理的配置，以实现安全的流量通信和度量收集。 Consul旨在支持各种代理作为sidecars，并且目前已经为Envoy提供了一流的支持，因为它具有轻量级的占用空间和可观察性支持。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-envoy-sidecar-proxy-with-its-upstream-services&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Envoy sidecar proxy with its upstream services&#34; srcset=&#34;
               /blog/layer-7-observability-with-consul-service-mesh/1558253731-consul_hu2eb839ff43ce99e0d9c67ed38ca02111_50640_eb4a1efee28706017177c2f06f0e1be0.webp 400w,
               /blog/layer-7-observability-with-consul-service-mesh/1558253731-consul_hu2eb839ff43ce99e0d9c67ed38ca02111_50640_b4e5a8eaa49e77f9e0769f7741a46123.webp 760w,
               /blog/layer-7-observability-with-consul-service-mesh/1558253731-consul_hu2eb839ff43ce99e0d9c67ed38ca02111_50640_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/layer-7-observability-with-consul-service-mesh/1558253731-consul_hu2eb839ff43ce99e0d9c67ed38ca02111_50640_eb4a1efee28706017177c2f06f0e1be0.webp&#34;
               width=&#34;760&#34;
               height=&#34;360&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Envoy sidecar proxy with its upstream services
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Consul UI showing the Envoy sidecar proxy and its upstream services&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Consul 1.5引入了使用&lt;code&gt;consul connect envoy&lt;/code&gt;命令立即为Consul Connect中的所有Envoy代理配置度量集合的功能。 在新的发现阶段，此命令从本地Consul代理获取集中存储的代理配置，并使用其值来引导Envoy代理。&lt;/p&gt;
&lt;p&gt;通过Consul Connect配置Envoy引导程序时，可以支持几种不同级别的自定义。 更高级别的配置是最简单的配置，涵盖了从Envoy获取指标所需的一切。&lt;/p&gt;
&lt;p&gt;可以通过创建配置文件来创建集中配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;kind&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;proxy-defaults&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;global&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;config &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# (dog)statsd listener on either UDP or Unix socket. &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# envoy_statsd_url = &amp;#34;udp://127.0.0.1:9125&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;envoy_dogstatsd_url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;udp://127.0.0.1:9125&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# IP:port to expose the /metrics endpoint on for scraping.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# prometheus_bind_addr = &amp;#34;0.0.0.0:9102&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# The flush interval in seconds.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;envoy_stats_flush_interval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以使用&lt;code&gt;consul config write &amp;lt;filename&amp;gt;&lt;/code&gt;命令将此配置写入Consul。&lt;/p&gt;
&lt;p&gt;上述文件中的配置部分通过告知Envoy将指标发送到何处来启用指标收集。目前，Consul Connect通过集中配置支持以下度量标准输出格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;StatsD&lt;/strong&gt;：允许客户报告指标的网络协议，如计数器和计时器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DogStatsD&lt;/strong&gt;：StatsD协议的扩展，支持直方图和指标标记&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Prometheus&lt;/strong&gt;：暴露出Prometheus可以抓取指标的终点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DogStatsD接收器优于statsd，因为它允许标记指标，这对于能够在Grafana中正确过滤它们至关重要。一旦支持Envoy 1.10并发出直方图，prometheus端点对大多数用户来说都是一个不错的选择。&lt;/p&gt;
&lt;p&gt;Consul将使用该配置生成Envoy设置代理并配置相应统计信息接收器所需的引导配置。一旦Envoy代理被引导，它将开始发出指标。您可以在Prometheus等时间序列存储中捕获这些指标，并在Grafana等工具中查询它们，或将它们发送到托管监控解决方案。下面是一个Prometheus查询示例，您可以根据生成的指标编写，该查询将所有请求时间记录到上游“emojify-api”集群，然后按分位数对它们进行分组&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# The response times of the emojify-api upstream, &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# categorized by quantile &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sum&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;envoy_cluster_upstream_rq_time&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;envoy_cluster_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;emojify-api&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &amp;gt; 0&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; by &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;quantile&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;















&lt;figure  id=&#34;figure-resulting-graph-showing-the-request-time-quantiles&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Resulting graph showing the request time quantiles&#34; srcset=&#34;
               /blog/layer-7-observability-with-consul-service-mesh/1558253416-requesttime_hu09423e67206d13b684a713ec628a7a9a_12411_98c29524fbb8370c64c779c2f11b564e.webp 400w,
               /blog/layer-7-observability-with-consul-service-mesh/1558253416-requesttime_hu09423e67206d13b684a713ec628a7a9a_12411_e753ebe1eb9f1c354ccbcd26cb0347ff.webp 760w,
               /blog/layer-7-observability-with-consul-service-mesh/1558253416-requesttime_hu09423e67206d13b684a713ec628a7a9a_12411_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/layer-7-observability-with-consul-service-mesh/1558253416-requesttime_hu09423e67206d13b684a713ec628a7a9a_12411_98c29524fbb8370c64c779c2f11b564e.webp&#34;
               width=&#34;760&#34;
               height=&#34;336&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Resulting graph showing the request time quantiles
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;em&gt;Resulting graph showing the request time quantiles&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Envoy根据其配置方式发出&lt;a href=&#34;https://docs.datadoghq.com/integrations/envoy/#data-collected&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大量&lt;/a&gt;统计信息。 一般来说，有三类统计数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Downstream&lt;/strong&gt; 与传入连接/请求相关的&lt;strong&gt;下游&lt;/strong&gt;统计信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Upstream&lt;/strong&gt; 与传出连接/请求相关的&lt;strong&gt;上游&lt;/strong&gt;统计信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Server&lt;/strong&gt; 描述Envoy服务器实例如何执行的&lt;strong&gt;服务器&lt;/strong&gt;统计信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;统计信息的格式类似于``envoy.&lt;category&gt;(.&lt;subcategory&gt;).metric`，我们感兴趣的一些类别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cluster&lt;/strong&gt;：Envoy连接的一组逻辑上相似的上游主机。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Listener&lt;/strong&gt;：一个命名的网络位置，如端口或unix套接字，可由下游客户端连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCP&lt;/strong&gt;：连接，吞吐量等指标&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP&lt;/strong&gt;：有关HTTP和HTTP/2连接和请求的指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-grafana-dashboard-containing-envoy-metrics&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Grafana dashboard containing Envoy metrics&#34; srcset=&#34;
               /blog/layer-7-observability-with-consul-service-mesh/1558253406-dashboard_hu13d99dff9587967e180fc0b26e47c2be_253836_7d7169c4a0be2147c470985c7caf7cca.webp 400w,
               /blog/layer-7-observability-with-consul-service-mesh/1558253406-dashboard_hu13d99dff9587967e180fc0b26e47c2be_253836_d6731d0cf4b453d272010c729b700e36.webp 760w,
               /blog/layer-7-observability-with-consul-service-mesh/1558253406-dashboard_hu13d99dff9587967e180fc0b26e47c2be_253836_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/layer-7-observability-with-consul-service-mesh/1558253406-dashboard_hu13d99dff9587967e180fc0b26e47c2be_253836_7d7169c4a0be2147c470985c7caf7cca.webp&#34;
               width=&#34;757&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Grafana dashboard containing Envoy metrics
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Grafana dashboard containing Envoy metrics&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;l7可观察性&#34;&gt;L7可观察性&lt;/h2&gt;
&lt;p&gt;默认情况下，Envoy代理L4或TCP层的连接。虽然这可能有用，但它不包括重要的协议特定信息，如请求率和指示错误所需的响应代码。&lt;/p&gt;
&lt;p&gt;例如，使用L4，您将看到发送和接收的连接数和字节数，但只有在连接意外终止时才会报告故障。当您的API或网站报告失败时，它们通常会响应特定于协议的错误消息，同时保持TCP连接处于活动状态或正常关闭它。例如，HTTP服务的响应带有状态代码，该状态代码指示响应的性质。当请求成功时，您将返回状态200，如果找不到，则返回404，当服务出现意外错误时，返回5xx。特使可以配置为记录每个响应的状态属于哪个类，以允许监视错误率。&lt;/p&gt;
&lt;p&gt;用于服务之间通信的另一个新兴协议是gRPC，它使用HTTP/2进行传输，使用Protocol Buffers作为接口定义和序列化格式，以执行远程过程调用。在为GRPC配置Envoy时，发出的指标将为您提供所调用的函数以及这些调用的结果状态。&lt;/p&gt;
&lt;p&gt;监控这些代码对于理解您的应用程序至关重要，但是，您需要在Envoy中启用一些其他配置，以便它了解您的应用正在使用L7。&lt;/p&gt;
&lt;p&gt;您可以通过在配置文件中设置服务默认值来指定服务的协议（请参阅下面的示例）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;service-defaults&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;emojify-api&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;protocol = &amp;#34;http&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后使用&lt;code&gt;consul write &amp;lt;filename&amp;gt;&lt;/code&gt;命令将其写入集中式配置。&lt;/p&gt;
&lt;p&gt;如果协议是“http”，“http2”或“grpc”，它将使侦听器发出L7指标。 在引导Envoy代理时，Consul将尝试从其引用的服务中解析上游协议。 如果已定义，则无需在上游指定协议。&lt;/p&gt;
&lt;p&gt;一旦通过Consul指定或发现代理和上游的协议字段，Envoy将配置集群以发出额外的L7指标，HTTP类别和指标的HTTP/GRPC子类别。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-the-emojify-cache-and-emojify-facebox-clusters-are-emitting-response-codes-with-their-metrics&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;The emojify-cache and emojify-facebox clusters are emitting response codes with their metrics&#34; srcset=&#34;
               /blog/layer-7-observability-with-consul-service-mesh/1558253409-l7metrics_hu5e0506212c5db93e52eb254cd626e237_32544_57231520c38ed274311be63b652f5a61.webp 400w,
               /blog/layer-7-observability-with-consul-service-mesh/1558253409-l7metrics_hu5e0506212c5db93e52eb254cd626e237_32544_98669d3580a29b38e755fecfc694b07f.webp 760w,
               /blog/layer-7-observability-with-consul-service-mesh/1558253409-l7metrics_hu5e0506212c5db93e52eb254cd626e237_32544_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/layer-7-observability-with-consul-service-mesh/1558253409-l7metrics_hu5e0506212c5db93e52eb254cd626e237_32544_57231520c38ed274311be63b652f5a61.webp&#34;
               width=&#34;760&#34;
               height=&#34;651&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      The emojify-cache and emojify-facebox clusters are emitting response codes with their metrics
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The emojify-cache and emojify-facebox clusters are emitting response codes with their metrics&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一旦您在Grafana中获得L7指标，您就可以开始更精确地关联事件，并了解系统中的故障是如何冒泡的。&lt;/p&gt;
&lt;p&gt;例如，如果emojify-api上游开始返回5xx响应代码，您可以查看对emojify-cache服务的调用，并查看Get调用是否也失败。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Number of requests to the emojify-upstream, &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# categorized by resulting response code&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sum&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;increase&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;envoy_cluster_upstream_rq_xx&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;envoy_cluster_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;emojify-api&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}[&lt;/span&gt;30s&lt;span class=&#34;o&#34;&gt;]))&lt;/span&gt; by &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;envoy_response_code_class&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Number of retry attempts to the emojify-api upstream&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sum&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;increase&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;envoy_cluster_upstream_rq_retry&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;envoy_cluster_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;emojify-api&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}[&lt;/span&gt;30s&lt;span class=&#34;o&#34;&gt;]))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;















&lt;figure  id=&#34;figure-resulting-graph-showing-the-number-of-requests-and-retries&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Resulting graph showing the number of requests and retries&#34; srcset=&#34;
               /blog/layer-7-observability-with-consul-service-mesh/1558253412-requestcount_hu1de564e25b0b4012763f1448151426de_9782_4abdce4301fb161cd3e964a820228e76.webp 400w,
               /blog/layer-7-observability-with-consul-service-mesh/1558253412-requestcount_hu1de564e25b0b4012763f1448151426de_9782_a378ab79021d7c081098309dadd2fb8a.webp 760w,
               /blog/layer-7-observability-with-consul-service-mesh/1558253412-requestcount_hu1de564e25b0b4012763f1448151426de_9782_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/layer-7-observability-with-consul-service-mesh/1558253412-requestcount_hu1de564e25b0b4012763f1448151426de_9782_4abdce4301fb161cd3e964a820228e76.webp&#34;
               width=&#34;760&#34;
               height=&#34;336&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Resulting graph showing the number of requests and retries
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Resulting graph showing the number of requests and retries&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Number of GRPC calls to the emojify-cache upstream, &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# categorized by function called&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sum&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;increase&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;envoy_cluster_grpc_0&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;envoy_cluster_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;emojify-cache&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}[&lt;/span&gt;30s&lt;span class=&#34;o&#34;&gt;]))&lt;/span&gt; by &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;envoy_grpc_bridge_method&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;















&lt;figure  id=&#34;figure-resulting-graph-showing-the-grpc-functions-and-their-call-count&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Resulting graph showing the GRPC functions and their call count&#34; srcset=&#34;
               /blog/layer-7-observability-with-consul-service-mesh/1558253414-requestgrpc_hu917c4645894c18d6f0b26b3251967b70_10673_ed5ed7a77a90d410e119d61c294f883f.webp 400w,
               /blog/layer-7-observability-with-consul-service-mesh/1558253414-requestgrpc_hu917c4645894c18d6f0b26b3251967b70_10673_b11b1f0c17470354911f9ac5bd4529d3.webp 760w,
               /blog/layer-7-observability-with-consul-service-mesh/1558253414-requestgrpc_hu917c4645894c18d6f0b26b3251967b70_10673_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/layer-7-observability-with-consul-service-mesh/1558253414-requestgrpc_hu917c4645894c18d6f0b26b3251967b70_10673_ed5ed7a77a90d410e119d61c294f883f.webp&#34;
               width=&#34;760&#34;
               height=&#34;336&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Resulting graph showing the GRPC functions and their call count
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Resulting graph showing the GRPC functions and their call count&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;通过使用分布式跟踪，您可以在系统上获得更好的可观察性。 这需要应用程序的一些合作来通过服务调用来发起跟踪和传播跟踪上下文。 可以将服务网格配置为集成并向跟踪添加跨度，以深入了解在代理中花费的时间。 这可以通过&lt;code&gt;envoy_tracing_json&lt;/code&gt;字段提供，该字段接受JSON格式的Envoy跟踪配置。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过使用集中式配置，您可以同时在中央位置为所有服务配置度量标准收集。 L7指标可让您更深入地了解服务的行为和性能。&lt;/p&gt;
&lt;p&gt;此处描述的L7可观察性功能已在&lt;a href=&#34;https://hashicorp.com/blog/hashicorp-consul-1-5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Consul 1.5&lt;/a&gt;中发布。 如果您想亲自试用新功能，这个&lt;a href=&#34;https://instruqt.com/hashicorp/tracks/consul-l7-%e5%8f%af%e8%a7%82%e5%af%9f%e6%80%a7&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演示&lt;/a&gt;提供了一个无需安装的实践操场。 如果您想了解更多关于Kulnetes上Consul Connect的L7可观察性的信息，请查看HashiCorp关于此主题的学习&lt;a href=&#34;https://learn.hashicorp.com/consul/getting-started-k8s/l7-observability-k8s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;指南&lt;/a&gt; 。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh新成员：Consul 1.2</title>
      <link>https://cloudnative.to/blog/consul-1-2-service-mesh/</link>
      <pubDate>Wed, 04 Jul 2018 12:48:07 +0800</pubDate>
      <guid>https://cloudnative.to/blog/consul-1-2-service-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://www.hashicorp.com/blog/consul-1-2-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文译自 HashiCorp 官网关于 Consul 1.2 支持 Service Mesh 发布的博客文章。&lt;/p&gt;
&lt;p&gt;本文是 HashiCorp 创始人 Mitchell Hashimoto 在 2018 年 6 月 26 日发布的关于 Consul 1.2 新功能 Service Mesh 的官方介绍。译者接触过的 Hashicorp 的产品有过不少，每款都给人感觉功能强大，设计简洁，可以说是都是非常优秀的开源产品（当然这与背后的 Hashicorp 公司商业级支撑有关）。译者有幸见过作者 Mitchell 一面，是个日裔混血，佩服他们取得的成就，期待他们推出的新功能能够取得市场上的成功。&lt;/p&gt;
&lt;p&gt;Service Mesh 是最近很火的微服务新范式，以 Istio 为首的开源项目引领着潮流，其他各大公司也在迅速跟上，包括 Hashicorp 也在 Consul 中加入类似的功能。我们后续也将提供 Service Mesh 这方面更多的技术文章，敬请期待。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-harshicorp-consul&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;HarshiCorp Consul&#34; srcset=&#34;
               /blog/consul-1-2-service-mesh/00704eQkgy1fsxqoqdg7mj312e0dw0tr_huc7bba6a7679a0e5e64c6f7f3b1cba0f7_99587_61894b92683eae9a3b98f84721c5d973.webp 400w,
               /blog/consul-1-2-service-mesh/00704eQkgy1fsxqoqdg7mj312e0dw0tr_huc7bba6a7679a0e5e64c6f7f3b1cba0f7_99587_6b40cdf0aa464193de9f5a23d4b17788.webp 760w,
               /blog/consul-1-2-service-mesh/00704eQkgy1fsxqoqdg7mj312e0dw0tr_huc7bba6a7679a0e5e64c6f7f3b1cba0f7_99587_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/consul-1-2-service-mesh/00704eQkgy1fsxqoqdg7mj312e0dw0tr_huc7bba6a7679a0e5e64c6f7f3b1cba0f7_99587_61894b92683eae9a3b98f84721c5d973.webp&#34;
               width=&#34;760&#34;
               height=&#34;275&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      HarshiCorp Consul
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们很激动宣布 HashiCorp Consul 1.2 正式发布了。这个版本主要新增了一个新的功能叫做 &lt;a href=&#34;https://www.consul.io/segmentation.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Connect&lt;/a&gt;, 它能够将现有的 Consul 集群自动转变为 service mesh （服务网格）的解决方案。Connect 通过自动 TLS 加密和基于鉴权的授权机制支持服务和服务之间的安全通信。&lt;/p&gt;
&lt;p&gt;当前全球有数以百万计的机器上正部署着 Consul。当升级到 Consul 1.2 并打开 Connect 功能后，任何现有的集群将立刻变身为支持任何包括物理机、云、容器和调度器等各种平台的 service mesh 方案。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/consul-1-2-service-mesh/00704eQkgy1fswof0iyxxj31rc0py1kx_hu56740b49a7a2c4333384902d8faa172e_693931_8c34b13a157baee26ce458c7de1deed3.webp 400w,
               /blog/consul-1-2-service-mesh/00704eQkgy1fswof0iyxxj31rc0py1kx_hu56740b49a7a2c4333384902d8faa172e_693931_cf99c5e8b98d47707ad37839296b5248.webp 760w,
               /blog/consul-1-2-service-mesh/00704eQkgy1fswof0iyxxj31rc0py1kx_hu56740b49a7a2c4333384902d8faa172e_693931_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/consul-1-2-service-mesh/00704eQkgy1fswof0iyxxj31rc0py1kx_hu56740b49a7a2c4333384902d8faa172e_693931_8c34b13a157baee26ce458c7de1deed3.webp&#34;
               width=&#34;760&#34;
               height=&#34;312&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;现代服务网络-service-mesh&#34;&gt;现代服务网络 Service Mesh&lt;/h2&gt;
&lt;p&gt;Service mesh 是企业和组织采用微服务以及动态云计算基础设施方案的必选方案。传统的基于主机的网络安全机制必须被替代为现代的基于服务的安全机制，以适应现代运行时环境的高度动态特性。&lt;/p&gt;
&lt;p&gt;Service mesh 提供了以下三个关键问题的一种高可用分布式解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务发现：服务之间必须能够互相发现找到彼此。&lt;/li&gt;
&lt;li&gt;配置：服务必须能够从一个中心的配置源接收运行时的配置信息。&lt;/li&gt;
&lt;li&gt;隔离：服务之间的通信必须是被授权和加密的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直到这个版本发布之前，Consul 分别用 DNS 解决了服务发现的使用场景，以及 K/V 存储解决了配置的使用场景。Connect 则将解决隔离的使用场景。这三项功能联合在一起提供了一种可运行在任何平台的 service mesh 完整解决方案。&lt;/p&gt;
&lt;h2 id=&#34;consul-connect&#34;&gt;Consul Connect&lt;/h2&gt;
&lt;p&gt;Connect 是 Consul 的一个主要新功能，旨在通过自动 TLS 加密和基于鉴权的授权机制提供服务之间的安全通信。今天宣布的 Connect 的功能是完全免费并且开源的。Consul 1.2 提供 Connect 功能面向公众的发布。&lt;/p&gt;
&lt;p&gt;Connect 在设计开发时就贯注了易于使用的想法。它可以仅仅通过一个配置参数就打开，在服务注册时额外添加一行就可以使得任何现存的应用接受基于 Connect 的连接。证书更新是自动的，因此不会导致服务停机。对于所有必须的子系统，Connect 仅仅需要一个二进制文件就可以支持。后面我们会涵盖很多其他的功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-1529562862-segmentationafter&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.idevfun.io/content/images/2018/07/1529562862-segmentationafter.gif&#34; alt=&#34;1529562862-segmentationafter&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      1529562862-segmentationafter
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在易于使用的基础上，Connect 暴露了 Consul 的很多新功能。这篇文章接下来会介绍其中一些功能的细节，不过让我们来先列举一下具有 Connect 的 Consul 所有主要的新功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流量加密：&lt;/strong&gt; 使用 Connect 创建的所有流量都是使用双向 TLS 的，这确保了所有流量在传输中都是经过加密的。这使得服务可以安全地部署在低信任度的环境中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接授权：&lt;/strong&gt; 使用 &lt;a href=&#34;https://www.consul.io/docs/connect/intentions.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;intentions&lt;/a&gt; 创建服务连接图，允许或拦截服务之间的通信。与防火墙使用 IP 地址不同，Connect 使用服务的逻辑命名。这意味着规则可以独立地进行扩展，无论有一个 web 服务还是 100 个。Intentions 可以通过界面、命令行、API 或者 HashiCorp Terraform 来进行配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sidecar 代理：&lt;/strong&gt; 应用可以使用轻量的 sidecar 代理进程来自动创建进出流量的 TLS 连接。这使得现有的应用可以不进行任何修改就可以使用 Connect。Consul 不仅提供了一个不需要任何外部依赖的内置代理，还提供了对例如 Envoy 等第三方代理的支持。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原生集成：&lt;/strong&gt; 对于性能非常敏感的应用，可以不使用代理，而通过集成原生 Consul Connect API 来创建和接受连接，从而获得更优的性能和安全。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4 层 vs. 7 层：&lt;/strong&gt; 鉴权是在 4 层实施的。Consul 将 7 层的功能和配置代理给可插拔式的数据层。你可以集成第三方代理，例如 Envoy，来提供诸如基于请求路径的路由，链路追踪和其他的功能，将 Consul 留作服务发现、鉴权和授权的功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;证书管理：&lt;/strong&gt; Consul 使用 CA 生成并分发证书。Consul 提供了一个不依赖外部系统的内置 CA 系统，与 HashiCorp Vault 集成后，还可以扩展支持其他 PKI 系统。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;证书更新：&lt;/strong&gt; Connect 可以自动更新根证书和子证书。根证书更新使用证书交叉签名来保证新老证书在更新期间可以共存，从而不影响服务。此系统还支持无缝配置新的 CA 提供商。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于 SPIFFE 的身份认证：&lt;/strong&gt; Consul 使用 &lt;a href=&#34;https://spiffe.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE&lt;/a&gt; 规范进行身份识别和认证。这使得使用 Connect 的服务可以创建和接受来自其他遵守 SPIFFE 系统的连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络和云平台无关：&lt;/strong&gt; Connect 使用基于 TCP/IP 的标准 TLS。这使得 Connect 可以支持任何网络配置，只要目标服务广播的 IP 地址在操作系统中可以访问。而且，服务之间可以进行跨云通信，而不借助于复杂的 overlay 层级。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;自动-sidecar-代理&#34;&gt;自动 Sidecar 代理&lt;/h2&gt;
&lt;p&gt;应用可以无须进行任何修改，使用代理 sidecar 创建出入连接。在使用 Connect 后，仅仅添加如下一行服务注册配置就可以使得这个服务能够接受基于 Connect 的连接：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;service&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;web&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;port&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;connect&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;proxy&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;唯一的区别就是由 &lt;code&gt;connect&lt;/code&gt; 开头的那行。这一行的存在使得 Consul 可以自动为这个服务启动和管理一个代理进程。这个代理进程代表了这个特定的服务。它在一个动态分配的端口上接受连接，验证并授权这个 TLS 连接，然后代理回一个标准的 TCP 连接到服务进程。&lt;/p&gt;
&lt;p&gt;对于上游的依赖，可以多添加几行配置通过 Connect 监听连接并代理到服务。例如，假设我们的 “web” 服务需要和 “db” 服务通过 Connect 进行通信：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;service&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;web&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;port&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;connect&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nt&#34;&gt;&amp;#34;proxy&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;config&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;nt&#34;&gt;&amp;#34;upstreams&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             &lt;span class=&#34;nt&#34;&gt;&amp;#34;destination_name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;db&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             &lt;span class=&#34;nt&#34;&gt;&amp;#34;local_bind_port&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9191&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面配置了一个受管代理并设置了监听本地 9191 端口将请求代理到任何远程 “db” 服务。通过配置 “web” 服务使用这个本地端口，所有 “web” 和 “db” 之间的通信都将成为加密的和已授权的。&lt;/p&gt;
&lt;p&gt;需要注意的是这些例子中，原来的应用 “web” 保持 &lt;em&gt;没有修改且感知不到 Connect 的存在&lt;/em&gt;。仅仅通过一行到几行的配置代码，任何应用都可以使用自动管理的代理 sidecar 来接受和创建 Connect 连接。&lt;/p&gt;
&lt;p&gt;可以参阅 &lt;a href=&#34;https://www.consul.io/docs/connect/proxies.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;代理的使用手册文档&lt;/a&gt; 了解更多内容。如果某个应用有极高的性能需求，那么它可以 &lt;a href=&#34;https://www.consul.io/docs/connect/native.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;原生地集成&lt;/a&gt;Connect。这使得服务可以完全不需要代理。&lt;/p&gt;
&lt;h2 id=&#34;开发友好的连接&#34;&gt;开发友好的连接&lt;/h2&gt;
&lt;p&gt;为了最佳的安全性，服务应该尽量做到仅仅接受基于 Connect 的连接。然而，这给连接到服务进行开发或测试带来了挑战。Consul 提供了一种简单的方式通过使用 &lt;code&gt;consul connect proxy&lt;/code&gt; 命令运行本地代理，从而使用 Connect 创建连接到服务。&lt;/p&gt;
&lt;p&gt;考虑一个场景示例，一个 PostgreSQL 数据库服务仅接受来自 Connect 的连接，某运维工程师因为维护需要，想使用 &lt;code&gt;psql&lt;/code&gt; 连接这个数据库。他可以在本地机器上通过 &lt;code&gt;consul connect proxy&lt;/code&gt; 命令来使用 &lt;code&gt;psql&lt;/code&gt; 进行连接：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ consul connect proxy -service mitchellh -upstream postgresql:9191
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&amp;gt; Consul Connect proxy starting...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    Configuration mode: Flags
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               Service: mitchellh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              Upstream: &lt;span class=&#34;nv&#34;&gt;postgresql&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;gt; :9191
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       Public listener: Disabled
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在另外一个 shell 终端中，可以使用标准 &lt;code&gt;psql&lt;/code&gt; 客户端连接：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ psql -h 127.0.0.1 -p &lt;span class=&#34;m&#34;&gt;9191&lt;/span&gt; -U mitchellh mydb
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 &lt;code&gt;-service&lt;/code&gt; 命令参数代表了源服务的认证信息。服务并不需要存在，但是调用者必须拥有合法的 ACL token 来注册这个服务，Consul 必须配置为允许源和目标服务之间的连接。&lt;/p&gt;
&lt;p&gt;对远程服务进行本地开发和测试是 service mesh 的一个常见工作流挑战，然而对于 Consul 和 Connect 来说却极为容易。&lt;/p&gt;
&lt;h2 id=&#34;使用-intentions-进行访问控制&#34;&gt;使用 Intentions 进行访问控制&lt;/h2&gt;
&lt;p&gt;服务之间的访问控制通过 “intentions” 进行配置。一个意向（intention）是一条从源到目的服务的允许或拦截规则。Intentions 可以通过 UI 界面、命令行、API 或 Terraform 进行创建。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/consul-1-2-service-mesh/00704eQkgy1fswofx2nh4j30u90k7dhv_hu162b9ff029c43772098e48518c295252_163584_36471a1792550b60545f252d4bb2594a.webp 400w,
               /blog/consul-1-2-service-mesh/00704eQkgy1fswofx2nh4j30u90k7dhv_hu162b9ff029c43772098e48518c295252_163584_b5316aef0887e758965d877e37cc3518.webp 760w,
               /blog/consul-1-2-service-mesh/00704eQkgy1fswofx2nh4j30u90k7dhv_hu162b9ff029c43772098e48518c295252_163584_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/consul-1-2-service-mesh/00704eQkgy1fswofx2nh4j30u90k7dhv_hu162b9ff029c43772098e48518c295252_163584_36471a1792550b60545f252d4bb2594a.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;按照上述示例，允许从 &lt;code&gt;db&lt;/code&gt; 服务到 &lt;code&gt;web&lt;/code&gt; 的访问，可以执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ consul intention create -allow web db
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Created: &lt;span class=&#34;nv&#34;&gt;web&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;gt; db &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;allow&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述命令允许 “web” 服务同 “db” 服务进行通信。然后这个 intention 可以通过 &lt;code&gt;-deny&lt;/code&gt; 立刻禁用两个服务之间的连接。&lt;/p&gt;
&lt;p&gt;Intentions 也可以通过服务的部署进行单独管理，可以配置 ACL 规则，使得仅有特定的服务可以修改 intentions 。这使得安全和隔离可以动态并几乎实时地进行配置和管控。&lt;/p&gt;
&lt;h2 id=&#34;更多内容--未来&#34;&gt;更多内容 &amp;amp; 未来&lt;/h2&gt;
&lt;p&gt;我们对于 Consul 1.2 和它所支持的新功能很是激动。由于这个功能和它的影响较大，Consul 1.2 中提供的 Connect 应该被认为是 beta 阶段。这个夏天我们将在 Connect 上努力，希望在年底前能去掉 beta 的标签。&lt;/p&gt;
&lt;p&gt;在将来，我们也会围绕 Connect 构建更多功能，包括新的 UI 增强、对 Envoy 代理的支持，以及同 Nomad 和 Kubernetes 的集成等等。Consul 1.2 中的 Connect 仅仅是个开始。&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&#34;https://www.consul.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.consul.io/&lt;/a&gt; 下载 Consul 1.2。&lt;/p&gt;
&lt;p&gt;下面的页面能很好地进一步了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.consul.io/segmentation.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;功能主页&lt;/a&gt; - 这是 Consul Connect 的专门主页，包含对所提供功能的总览和文档链接。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.consul.io/intro/getting-started/connect.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Connect 使用步骤&lt;/a&gt; - Consul 使用步骤新增了一步 Connect 并包含快速入门的一个浏览介绍。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://play.instruqt.com/hashicorp/tracks/connect&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Connect 交互式教程&lt;/a&gt; - 带你过一遍运行 Connect 关键步骤的交互式教程。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.consul.io/docs/connect/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Connect 参考手册&lt;/a&gt; - Connect 的文档手册中包含关于 Connect 如何工作、代理、原生集成和证书管理等等的所有细节。在部署 Connect 之前，推荐先阅读这个文档手册。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.consul.io/docs/connect/security.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Connect 安全清单&lt;/a&gt; - Connect 和 Consul 其余的部分相比有不同的安全需求。为了运维的安全性，我们推荐查看此清单，阅读并理解 Consul 的安全模型。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.consul.io/docs/guides/connect-production.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Connect 生产指引&lt;/a&gt; - 这是生产环境配置 Consul 集群 Connect 功能的一个完整配置指引，包括配置最大限度安全的必要步骤。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hashicorp.com/resources/introduction-consul-connect&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Connect 白板介绍&lt;/a&gt; - 这个视频是创始人兼联合 CTO Armon Dadgar 介绍 Connect 关于网络管理、安全和性能等方面的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;本文译自 HashiCorp 官网关于 Consul 1.2 支持 Service Mesh 发布的博客文章。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&#34;https://www.hashicorp.com/blog/consul-1-2-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.hashicorp.com/blog/consul-1-2-service-mesh&lt;/a&gt;
作者：Mitchell Hashimoto
翻译：董干&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>
