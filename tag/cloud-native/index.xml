<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cloud Native | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/tag/cloud-native/</link>
      <atom:link href="https://cloudnativecn.com/tag/cloud-native/index.xml" rel="self" type="application/rss+xml" />
    <description>Cloud Native</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 28 Jan 2021 11:03:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/media/sharing.png</url>
      <title>Cloud Native</title>
      <link>https://cloudnativecn.com/tag/cloud-native/</link>
    </image>
    
    <item>
      <title>“寒武纪大爆发”之后的云原生，2021 年走向何处？</title>
      <link>https://cloudnativecn.com/blog/cloud-native-2021/</link>
      <pubDate>Thu, 28 Jan 2021 11:03:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/cloud-native-2021/</guid>
      <description>&lt;p&gt;很荣幸收到 CSDN 的邀请，接受”云原生人物志“专栏采访，其实我从 2017 年起就已经在撰写 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/appendix/kubernetes-and-cloud-native-summary-in-2017-and-outlook-for-2018.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 和云原生年度总结和新年展望&lt;/a&gt;，今天在此聊抒己见，欢迎大家讨论和指正。&lt;/p&gt;
&lt;h2 id=&#34;云原生在演进&#34;&gt;云原生在演进&lt;/h2&gt;
&lt;p&gt;云原生是一种行为方式和设计理念，究其本质，凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的。云计算的发展史就是一部云原生化的历史。Kubernetes 开启了云原生 1.0 的序幕，服务网格 Istio 的出现，引领了后 Kubernetes 时代的微服务，serverless 的再次兴起，使得&lt;strong&gt;云原生从基础设施层不断向应用架构层挺进&lt;/strong&gt;，我们正处于一个云原生 2.0 的新时代。&lt;/p&gt;
&lt;h2 id=&#34;业界动向&#34;&gt;业界动向&lt;/h2&gt;
&lt;p&gt;最近国内的一些云厂商，如阿里云、腾讯云、华为云陆续发布了各自的云原生相关的架构和实践白皮书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2020 年 7，中国信通院发布了《云原生产业白皮书（2020）》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 20 日，在腾讯 2020 Techo Park 开发者大会上，腾讯云正式发布了《云原生最佳实践路线图》，同时发布的还有一份 3 万多字的《腾讯云原生路线图手册》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 23 日，阿里云原生实战峰会上发布了《云原生架构白皮书》。&lt;/li&gt;
&lt;li&gt;2020 年 12 月 30 日，华为云在深圳的 TechWave 云原生 2.0 技术峰会上联合 Forrester 发布了《云原生白皮书：拥抱云原生优先战略》。&lt;/li&gt;
&lt;li&gt;2021 年初，阿里巴巴达摩院发布 2021 十大科技趋势，其中将“云原生重塑 IT 技术体系”作为 2021 年技术预测之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;云原生项目的寒武纪大爆发&#34;&gt;云原生项目的“寒武纪大爆发”&lt;/h2&gt;
&lt;p&gt;云原生已历经”寒武纪大爆发“，标志是从 2018 年 Kubernetes 毕业 后走向深耕路线。云原生领域的开源项目层出不穷，令人眼花缭乱，见我收集的 Awesome Cloud Native。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk_hu_89cb44472138c874.webp 400w,
               /blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk_hu_337721b2c5d6de70.webp 760w,
               /blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk_hu_3e98e35177a1a0e5.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-2021/008eGmZEly1gn37vq5g81j30q906dmyk_hu_89cb44472138c874.webp&#34;
               width=&#34;760&#34;
               height=&#34;184&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;2020 年 CNCF 共接纳了 35 个项目加入基金会，并且有多个项目毕业或晋级，CNCF 托管的项目总数达到了 80 多个。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh_hu_5588df8d0ab22ed3.webp 400w,
               /blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh_hu_5c8b0eb63d1300aa.webp 760w,
               /blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh_hu_456b0995a2c90d4b.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-2021/008eGmZEly1gn37weeu5lj30q90ivalh_hu_5588df8d0ab22ed3.webp&#34;
               width=&#34;760&#34;
               height=&#34;546&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图片来自 CNCF 年度报告 2020&lt;/p&gt;
&lt;h2 id=&#34;云原生之争实际上是标准之争&#34;&gt;云原生之争实际上是标准之争&lt;/h2&gt;
&lt;p&gt;PC 端操作系统 Windows 占据上风，移动端是 iOS 和 Android，服务器端是 Linux，而云计算商用分布式操作系统呢？答案是 Kubernetes。&lt;/p&gt;
&lt;p&gt;2020 年 Kubernete 宣布将&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/110520682&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 v1.20 版本之后弃用 Docker&lt;/a&gt;，实际上 Docker 本来就不是 Kubernetes 中默认和唯一的的容器运行时了，实际上只要是支持 CRI（Container Runtime Interface）或 OCI（Open Container Initiative）标准的容器运行时都可以在 Kubernetes 中运行。如下图所示，容器，英文是 container，也是集装箱的意思，其实集装箱不止一种型号，根据运送的货物的不同特性可以制定了多种集装箱类型。而这个容器类型是标准只能是由 Kubernetes 来定，否则只能是削足适履。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-2021/008eGmZEly1gn38p94t5sj30q90enq52_hu_aa8ffa3e33b710f3.webp 400w,
               /blog/cloud-native-2021/008eGmZEly1gn38p94t5sj30q90enq52_hu_11e53f82d2713dbf.webp 760w,
               /blog/cloud-native-2021/008eGmZEly1gn38p94t5sj30q90enq52_hu_c0a22b5d8e36aa4.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-2021/008eGmZEly1gn38p94t5sj30q90enq52_hu_aa8ffa3e33b710f3.webp&#34;
               width=&#34;760&#34;
               height=&#34;424&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes 统一了云上的资源对象制定和调度的标准，只要在其标准之上开发 CRD 和 Operator 即可。但是这也仅限于单个应用的管理，如何管理复杂的多集群和混合云环境，如何管理应用间流量，如何如何保证调用链的安全？以 Istio 为代表的服务网格就是为了解决这个问题。&lt;/p&gt;
&lt;h2 id=&#34;云原生趋势云上应用管理&#34;&gt;云原生趋势：云上应用管理&lt;/h2&gt;
&lt;p&gt;Kubernetes 奠定了云原生基础设施的基础，随着而来的监控、存储、AI、大数据等技术的迁移，从单个应用层面来说已经日趋成熟，而在&lt;strong&gt;使用云原生架构尤其是对云上应用的管理&lt;/strong&gt;，而在异构环境、多集群、混合云等已成为常态的情况下，&lt;strong&gt;如何对云上的应用进行管理，成为棘手的事情&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Kubernetes 以其开创新的声明式 API 和调节器模式，奠定了云原生的基础。我们看到 Google 的项目 Anthos，Azure 的 Arc，AWS 最近开源的 EKS-D，它们都是着重在混合云管理，让云无处不在。另外，服务网格（Service Mesh）经过两年的推广和发酵，将会看到越来越多的应用。&lt;/p&gt;
&lt;h2 id=&#34;云原生与开源社区&#34;&gt;云原生与开源社区&lt;/h2&gt;
&lt;p&gt;目前&lt;strong&gt;企业云原生化转型最缺乏的东西 —— 套路和组合拳&lt;/strong&gt;。对于基础软件，企业往往会选择开源项目并根据自身需求进行改造，而云原生的开源项目又有很多，企业不是没有选择，而是选择太多，以致于无从下手。就像下面教你如何画猫头鹰的示例。我们可以将企业的云原生化的愿景想象成是这只猫头鹰，这些开源项目就像步骤一中圆，你可能想当然的认为只要用了 Kubernetes 就是云原生了，这就像画了两个圆，而剩余部分没有人教你如何完成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y_hu_1c0dcc6535bd3281.webp 400w,
               /blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y_hu_6bfb93a30431f505.webp 760w,
               /blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y_hu_f4ed9a400e6dbd31.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-2021/008eGmZEly1gn37vqshfnj30q90hh44y_hu_1c0dcc6535bd3281.webp&#34;
               width=&#34;760&#34;
               height=&#34;506&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;开源社区的核心是面向开发者，就是向开发者灌输如何来画好这只“猫头鹰”的。开源不意味着免费和做慈善，使用开源也是有代价的。&lt;strong&gt;开源社区存在的意义是平衡开发者、终端用户及供应商之间的共同利益&lt;/strong&gt;，而一个中立的开源社区有利于发挥开源的生态优势。&lt;/p&gt;
&lt;p&gt;近年来随着云原生大热，在美国诞生了大量该领域的初创公司，他们基于 AWS、谷歌云、Azure 等提供各种云原生的解决方案，从每次 KubeCon 的赞助商规模上就可以窥知一二。国内该领域的公司目前还不多，而云原生终端用户社区的公司规模上依然跟国外的公司数量有不小的差距。&lt;/p&gt;
&lt;p&gt;云原生社区就是在这样的背景下于 2020 年初由我发起，开始筹备并在 5 月 12 号正式成立，致力于推广云原生技术，构建开发者生态。云原生社区采取 SIG（特别兴趣小组）和 WG（工作组）的组织形式，基于开源项目和不同的专业领域构建研讨组，与厂商合作定期举办线下 meetup，并邀请社区的专家们定期在 B 站的云原生学院进行直播。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;开源应该关注的是终端用户和开发者生态，用 Apache Way 来说就是“社区大于代码”，没有社区的项目是难以长久的。因此我们可以看到国内一些云厂商开源项目之后也会积极投入运营，举行各种各样的活动。我们看到在云原生的推广过程中，CNCF 起到的相当大的作用，2020 年国内也有类似的基金会成立，我们希望看到更多中立的基金会和社区的成立，更多的厂商参与其中，为终端用户提供更佳的解决方案。&lt;/p&gt;
&lt;p&gt;最后感谢 CSDN 宋慧编辑和「CSDN 云计算」的邀请。&lt;/p&gt;
&lt;p&gt;往期报道见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/112293560&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;梁胜：做开源项目的贡献者没有意义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/FL63Zv9Zou86950w/article/details/110433443&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;华为云 CTO 张宇昕：云原生已经进入深水区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/csdnnews/article/details/110508201&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;APISIX 温铭：开源的本质是要拿开发者的杠杆&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;个人介绍&#34;&gt;个人介绍&lt;/h2&gt;
&lt;p&gt;在我的职业生涯里先后从事过 Java 开发、大数据运维、DevOps、开源管理等工作，个人爱好是研究并推广开源技术及理念，摄影和旅行。目前在企业级服务网格初创公司 Tetrate 担任 Developer Advocate，同时作为中立的云原生终端用户社区 —— 云原生社区（Cloud Native Community）的负责人。&lt;/p&gt;
&lt;p&gt;我的整个职业生涯都是与开源息息相关的，渊源可以追溯到大学时期。大学时我就开始使用 Linux 系统（Ubuntu）学习，刚进入职场的时候面向的也是 Hadoop 的开源生态及各种开源中间件，2015 起开始接触 Docker，2016 年开始进入云原生领域，2017 年开始写 Kubernetes 领域的第一本开源中文电子书《&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生应用架构实践手册&lt;/a&gt;》，本书直到如今仍在更新，2018 年在蚂蚁集团做开源管理及服务网格社区 ServiceMesher，2020 年加入基于 Istio、Envoy 和 Apache SkyWalking 等开源项目而构建企业级服务网格的初创公司 Tetrate。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生初学者入门必读</title>
      <link>https://cloudnativecn.com/blog/must-read-for-cloud-native-beginner/</link>
      <pubDate>Fri, 23 Oct 2020 14:18:40 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/must-read-for-cloud-native-beginner/</guid>
      <description>&lt;h2 id=&#34;为什么写这篇文章&#34;&gt;为什么写这篇文章&lt;/h2&gt;
&lt;p&gt;看到这个标题后，大家可能会问“都已经 2020 年了，Kubernetes 开源有 6 年时间了，为什么还要写一篇 Kubernetes 入门的文章？”我想说的是，Kubernetes 还远远没有达到我们想象的那么普及。众多的开发者，平时忙于各自的业务开发，学习新技术的时间有限；还有大量的学生群体，可能还仅仅停留在“知道有这门技术”的阶段，远远没有入门。这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。&lt;/p&gt;
&lt;p&gt;因为云原生的知识体系过于庞杂，本文主要讲解容器、Kubernetes 及服务网格的入门概念，关于云原生的更多细节将在后续文章中推出。另外大家也可以关注云原生社区推出的 &lt;a href=&#34;https://github.com/cloudnativeto/cloudnative-knowledge-map&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生知识图谱&lt;/a&gt; 项目，进一步了解云原生。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 一词来自希腊语，意思是“飞行员”或“舵手”。这个名字很贴切，Kubernetes 可以帮助你在波涛汹涌的容器海洋中航行。&lt;/p&gt;
&lt;p&gt;Kubernetes 是做什么的？什么是 Docker？什么是容器编排？Kubernetes 是如何工作和扩展的？你可能还有很多其他的问题，本文将一一为你解答。&lt;/p&gt;
&lt;p&gt;这篇文章适合初学者，尤其是那些工作忙碌，没有办法抽出太多时间来了解 Kubernetes 和云原生的开发者们，希望本文可以帮助你进入 Kubernetes 的世界。&lt;/p&gt;
&lt;p&gt;简而言之，Kubernetes 提供了一个平台或工具来帮助你快速协调或扩展容器化应用，特别是在 &lt;a href=&#34;https://docker.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker&lt;/a&gt; 容器。让我们深入了解一下这些概念。&lt;/p&gt;
&lt;h2 id=&#34;容器和容器化&#34;&gt;容器和容器化&lt;/h2&gt;
&lt;p&gt;那么什么是容器呢？&lt;/p&gt;
&lt;p&gt;要讨论容器化首先要谈到虚拟机 (VM)，顾名思义，虚拟机就是可以远程连接的虚拟服务器，比如 AWS 的 EC2 或阿里云的 ECS。&lt;/p&gt;
&lt;p&gt;接下来，假如你要在虚拟机上运行一个网络应用——包括一个 MySQL 数据库、一个 Vue 前端和一些 Java 库，在 Ubuntu 操作系统 (OS) 上运行。你不用熟悉其中的每一个技术——你只要记住，一个应用程序由各种组件、服务和库组成，它们运行在操作系统上。&lt;/p&gt;
&lt;p&gt;现在，将应用程序打包成一个虚拟机镜像，这个镜像中包括了 Ubuntu 操作系统。这使得虚拟机变得非常笨重——通常有几个 G 的大小。&lt;/p&gt;
&lt;p&gt;虚拟机镜像包含了整个操作系统及所有的库，对应用程序来说，这个镜像过于臃肿，其中大部分组件并没有被应用程序直接调用。如果你需要重新创建、备份或扩展这个应用程序，就需要复制整个环境（虚拟机镜像），在新环境中启动应用通常需要几十秒甚至几分钟时间。如果你想单独升级应用中的某个组件，比如说 Vue 应用，就需要重建整个虚拟机镜像。另外，如果你的两个应用依赖同一个底层镜像，升级底层镜像会同时影响这两个应用，而有时候，你只需要升级其中一个应用的依赖而已。这就是所谓的“依赖陷阱”。&lt;/p&gt;
&lt;p&gt;解决这个问题的办法就是容器。容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）。所以在上面的例子中，Ubuntu 操作系统就是一个单元（容器）。MySQL 数据库是另一个容器，Vue 环境和随之而来的库也是一个容器。&lt;/p&gt;
&lt;p&gt;但是，MySQL 数据库是如何自己“运行”的？数据库本身肯定也要在操作系统上运行吧？没错！&lt;/p&gt;
&lt;p&gt;更高层次的容器，比如 MySQL 容器，实际上会包含必要的库来与底层的操作系统容器通信和集成。所以你可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。&lt;/p&gt;
&lt;p&gt;与容器相关的一个重要概念是&lt;strong&gt;微服务&lt;/strong&gt;。将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。上面的例子中，我们会为 Vue 前端创建一个微服务，为 MySQL 数据库创建另一个微服务，为 Java 中间件部分创建另一个微服务，以此类推。很明显，微服务与容器化是相辅相成的。&lt;/p&gt;
&lt;h2 id=&#34;从-docker-开始&#34;&gt;从 Docker 开始&lt;/h2&gt;
&lt;p&gt;现在你已经对容器有一定了解了吧？Docker 是最常用的容器化工具，也是最流行的容器运行时。&lt;/p&gt;
&lt;p&gt;Docker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macOS 都支持 Docker。&lt;/p&gt;
&lt;p&gt;还有其他的容器化工具，如 &lt;a href=&#34;https://coreos.com/rkt/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CoreOS rkt&lt;/a&gt;、&lt;a href=&#34;http://mesos.apache.org/documentation/latest/mesos-containerizer/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mesos Containerizer&lt;/a&gt; 和 &lt;a href=&#34;https://linuxcontainers.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LXC&lt;/a&gt;。但是目前，绝大多数的容器化应用都是在 Docker 上运行的。&lt;/p&gt;
&lt;h2 id=&#34;再到-kubernetes&#34;&gt;再到 Kubernetes&lt;/h2&gt;
&lt;p&gt;首先，简单介绍一下历史。Kubernetes 是 Google 基于其内部容器调度平台 Borg 的经验开发的。2014 年开源，并作为 CNCF（云原生计算基金会）的核心发起项目。&lt;/p&gt;
&lt;p&gt;那么 Kubernetes 又跟容器是什么关系呢？让我们再回到上面的例子。假设我们的应用爆火，每天的注册用户越来越多。&lt;/p&gt;
&lt;p&gt;现在，我们需要增加后端资源，使浏览我们网站的用户在浏览页面时加载时间不会过长或者超时。最简单的方式就是增加容器的数量，然后使用负载均衡器将传入的负载（以用户请求的形式）分配给容器。&lt;/p&gt;
&lt;p&gt;这样做虽然行之有效，但也只能在用户规模有限的情况下使用。当用户请求达到几十万或几百万时，这种方法也是不可扩展的。你需要管理几十个也许是几百个负载均衡器，这本身就是另一个令人头疼的问题。如果我们想对网站或应用进行任何升级，也会遇到问题，因为负载均衡不会考虑到应用升级的问题。我们需要单独配置每个负载均衡器，然后升级该均衡器所服务的容器。想象一下，当你有 20 个负载均衡器和每周 5 或 6 个小的更新时，你将不得不进行大量的手工劳动。&lt;/p&gt;
&lt;p&gt;我们需要的是一种可以一次性将变更传递给所有受控容器的方法，同时也需要一种可以轻松地调度可用容器的方法，这个过程还必须要是自动化的，这正是 Kubernetes 所做的事情。&lt;/p&gt;
&lt;p&gt;接下来，我们将探讨 Kubernetes 究竟是如何工作的，它的各种组件和服务，以及更多关于如何使用 Kubernetes 来编排、管理和监控容器化环境。为了简单起见，假设我们使用的是 Docker 容器，尽管如前所述，Kubernetes 除了支持 Docker 之外，还支持其他几种容器平台。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-架构和组件&#34;&gt;Kubernetes 架构和组件&lt;/h2&gt;
&lt;p&gt;首先，最重要的是你需要认识到 Kubernetes 利用了“期望状态”原则。就是说，你定义了组件的期望状态，而 Kubernetes 要将它们始终调整到这个状态。&lt;/p&gt;
&lt;p&gt;例如，你想让你的 Web 服务器始终运行在 4 个容器中，以达到负载均衡的目的，你的数据库复制到 3 个不同的容器中，以达到冗余的目的。这就是你想要的状态。如果这 7 个容器中的任何一个出现故障，Kubernetes 引擎会检测到这一点，并自动创建出一个新的容器，以确保维持所需的状态。&lt;/p&gt;
&lt;p&gt;现在我们来定义一些 Kubernetes 的重要组件。&lt;/p&gt;
&lt;p&gt;当你第一次设置 Kubernetes 时，你会创建一个集群。所有其他组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间 (namespace)，它们是同一个物理集群的一部分。这与你可以在同一物理服务器上创建多个虚拟机的方式非常相似。如果你不需要，也没有明确定义的命名空间，那么你的集群将在始终存在的默认命名空间中创建。&lt;/p&gt;
&lt;p&gt;Kubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。&lt;/p&gt;
&lt;p&gt;主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。&lt;/p&gt;
&lt;p&gt;Master 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。&lt;/p&gt;
&lt;p&gt;Woker 节点是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的逻辑而非物理的工作单位称为 pod。一个 pod 类似于 Docker 中的容器。记得我们在前面讲到，容器可以让你创建独立、隔离的工作单元，可以独立运行。但是要创建复杂的应用程序，比如 Web 服务器，你经常需要结合多个容器，然后在一个 pod 中一起运行和管理。这就是 pod 的设计目的——一个 pod 允许你把多个容器，并指定它们如何组合在一起来创建应用程序。而这也进一步明确了 Docker 和 Kubernetes 之间的关系——一个 Kubernetes pod 通常包含一个或多个 Docker 容器，所有的容器都作为一个单元来管理。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的 service 是一组逻辑上的 pod。把一个 service 看成是一个 pod 的逻辑分组，它提供了一个单一的 IP 地址和 DNS 名称，你可以通过它访问服务内的所有 pod。有了服务，就可以非常容易地设置和管理负载均衡，当你需要扩展 Kubernetes pod 时，这对你有很大的帮助，我们很快就会看到。&lt;/p&gt;
&lt;p&gt;ReplicationController 或 ReplicaSet 是 Kubernetes 的另一个关键功能。它是负责实际管理 pod 生命周期的组件——当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubectl&#34;&gt;什么是 Kubectl？&lt;/h2&gt;
&lt;p&gt;kubectl 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-中的自动扩展&#34;&gt;Kubernetes 中的自动扩展&lt;/h2&gt;
&lt;p&gt;请记住，我们使用 Kubernetes 而不是直接使用 Docker 的原因之一，是因为 Kubernetes 能够自动扩展应用实例的数量以满足工作负载的需求。&lt;/p&gt;
&lt;p&gt;自动缩放是通过集群设置来实现的，当服务需求增加时，增加节点数量，当需求减少时，则减少节点数量。但也要记住，节点是“物理”结构——我们把“物理”放在引号里，因为要记住，很多时候，它们实际上是虚拟机。&lt;/p&gt;
&lt;p&gt;无论如何，节点是物理机器的事实意味着我们的云平台必须允许 Kubernetes 引擎创建新机器。各种云提供商对 Kubernetes 支持基本都满足这一点。&lt;/p&gt;
&lt;p&gt;我们再继续说一些概念，这次是和网络有关的。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubernetes-ingress-和-egress&#34;&gt;什么是 kubernetes Ingress 和 Egress？&lt;/h2&gt;
&lt;p&gt;外部用户或应用程序与 Kubernetes pod 交互，就像 pod 是一个真正的服务器一样。我们需要设置安全规则允许哪些流量可以进入和离开“服务器”，就像我们为托管应用程序的服务器定义安全规则一样。&lt;/p&gt;
&lt;p&gt;进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 egress。我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 / 流量的地方。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ingress-controller&#34;&gt;什么是 Ingress Controller？&lt;/h2&gt;
&lt;p&gt;但是在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。&lt;/p&gt;
&lt;h2 id=&#34;什么是-replica-和-replicaset&#34;&gt;什么是 Replica 和 ReplicaSet？&lt;/h2&gt;
&lt;p&gt;为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是“让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。&lt;/p&gt;
&lt;p&gt;所需状态是在 deployment 中定义的。Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。&lt;/p&gt;
&lt;p&gt;因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。&lt;/p&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://jimmysong.io/blog/what-is-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格 (Service Mesh)&lt;/a&gt; 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 &lt;a href=&#34;https://jimmysong.io/blog/post-kubernetes-era/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 次世代的云原生应用&lt;/a&gt; 的重要组成部分。&lt;/p&gt;
&lt;p&gt;服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）——就是 MySQL 数据库、Node.js 前端、负载均衡器等。&lt;/p&gt;
&lt;p&gt;所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更——这些变更对其他容器是完全透明的。&lt;/p&gt;
&lt;p&gt;如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。&lt;/p&gt;
&lt;p&gt;在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。关于服务网格的更多内容请参考 &lt;a href=&#34;https://www.servicemesher.com/istio-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Handbook——Istio 服务网格进阶实战&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在下一部分中，我们将展开更多关于 Kubernetes 的话题：如何开始学习 Kubernetes，如何在本地安装和测试 Kubernetes，以及 Kubernetes 的一些优秀的监控工具。&lt;/p&gt;
&lt;h2 id=&#34;如何学习-kubernetes&#34;&gt;如何学习 Kubernetes？&lt;/h2&gt;
&lt;p&gt;自学 Kubernetes 知识基本上有三种不同的途径，我们在这里只提供了一个指导大纲。&lt;/p&gt;
&lt;h3 id=&#34;一从零开始学习和安装-kubernetes&#34;&gt;一、从零开始学习和安装 Kubernetes&lt;/h3&gt;
&lt;p&gt;要想真正掌握 Kubernetes，最好的办法莫过于自己从头开始安装 Kubernetes。不过要注意的是，从零开始安装 Kubernetes 并不是一件容易的事情。安装 Kubernetes 并不是简单的“下载文件 -&amp;gt; 点击安装”式的操作，Kubernetes 由多个组件组成，这些组件必须单独安装和配置。而在此之前，你也需要相当的技术储备来做安装前的准备，比如熟悉 Linux 操作系统。如果你决定使用这种方式学习的话，推荐你阅读 &lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。此外，请记住，尽管 Kubernetes 作为一个开源解决方案在技术上是免费的，但它确实有一些隐藏的成本，只不过对初学者来说可能并不明显。&lt;/p&gt;
&lt;h3 id=&#34;二kubernetes-自托管解决方案&#34;&gt;二、Kubernetes 自托管解决方案&lt;/h3&gt;
&lt;p&gt;这些解决方案样是一些工具和实用程序，大大简化了在本地计算机上安装和配置小型 Kubernetes 集群的任务。它们是学习 Kubernetes 的好方法，同时对于新手来说也不会太难，又足够小巧可以到安装在个人电脑上。最流行的自托管 Kubernetes 工具和环境是 &lt;a href=&#34;https://github.com/kubernetes/minikube&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Minikube&lt;/a&gt;、&lt;a href=&#34;https://github.com/ubuntu/microk8s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MicroK8s&lt;/a&gt;、&lt;a href=&#34;https://docs.docker.com/docker-for-windows/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Desktop&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/kubernetes-sigs/kind&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kind&lt;/a&gt;。这些解决方案往往有一些限制，例如，Minikube 只允许创建一个节点。尽管有这些缺点，但这些工具还是非常值得推荐，因为它们将易学性和成本效益结合起来，对于刚开始使用 Kubernetes 的初学者来说，是一个很好的选择。&lt;/p&gt;
&lt;h3 id=&#34;三云托管的解决方案&#34;&gt;三、云托管的解决方案&lt;/h3&gt;
&lt;p&gt;如今各大云供应商都提供了定制化的 Kubernetes 解决方案来。你也可以通过线上教学平台如 &lt;a href=&#34;https://katacoda.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Katacoda&lt;/a&gt; 上的免费课程来学习 Kubernetes，它们都是云托管的，你不需要自己安装，只不过你需要云供应商的集群需要付费。&lt;/p&gt;
&lt;h2 id=&#34;本地测试和调试-kubernetes&#34;&gt;本地测试和调试 Kubernetes&lt;/h2&gt;
&lt;p&gt;作为本地安装 Kubernetes 的一部分，你很可能还需要一些测试和调试能力，以确保一切都在顺利运行，特别是定义入口和出口策略等棘手的任务。此外，还有 Kubernetes 附加组件的生态系统，你可能想使用这些组件来扩展 Kubernetes 集群的功能。添加所有这些都需要进行更多的测试，以确保它们能与你的 Kubernetes 集群完美的集成。&lt;/p&gt;
&lt;p&gt;用于在本地开发和调试 Kubernetes 服务的工具有：&lt;a href=&#34;https://github.com/microsoft/mindaro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microsoft Bridge to Kubernetes&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/telepresenceio/telepresence&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;telepresence&lt;/a&gt;。这些工具可以让你在本地运行单个服务，同时将该服务连接到远程 Kubernetes 集群。这样你就可以让自己的本地机器作为 Kubernetes 集群中的一部分来运行——这对于在本地而不是在生产集群上开发服务非常有用。&lt;/p&gt;
&lt;p&gt;Kubernetes 项目也了解到了 Kubernetes 安装对端到端 (E2E) 测试的需求。为此，项目核心团队一直在确保在最近的版本中更恰当地支持 E2E 测试。这包括诸如允许测试重用和纳入更多附加组件和驱动程序的测试等。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-监控工具&#34;&gt;Kubernetes 监控工具&lt;/h2&gt;
&lt;p&gt;Kubernetes 提供了应用程序在集群的每个层次上的资源使用情况的详细信息——容器、pod、服务。这些详细信息使你能够评估应用程序的性能，确定哪些瓶颈可以解决以提高整体性能。&lt;/p&gt;
&lt;p&gt;毕竟，监控可以帮助你了解应用和集群运行情况的详细信息，这对于学习 Kubernetes 是十分有帮助的。&lt;/p&gt;
&lt;p&gt;Kubernetes 包含两个内置度量收集工具用于监控：&lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;资源管道和全度量管道&lt;/a&gt;。资源管道是一个较低级和较有限的工具，主要集中在与各种控制器相关的指标上。全指标管道，顾名思义，从几乎所有集群组件中获取并显示更丰富的指标。&lt;/p&gt;
&lt;p&gt;还有一些第三方工具可以安装并集成到 Kubernetes 集群中。对于 Kubernetes 来说，最普遍使用的两个工具是 Prometheus 和 Grafana。&lt;/p&gt;
&lt;h3 id=&#34;prometheus-监控&#34;&gt;Prometheus 监控&lt;/h3&gt;
&lt;p&gt;Prometheus 是一个功能丰富的开源监控和警报工具。Prometheus 包含一个内部数据存储用来收集指标，如生成的时间序列数据。Prometheus 还拥有众多插件，允许它将数据暴露给各种外部解决方案，并从其他数据源导入数据，包括所有主要公有云监控解决方案。&lt;/p&gt;
&lt;h3 id=&#34;grafana-仪表盘&#34;&gt;Grafana 仪表盘&lt;/h3&gt;
&lt;p&gt;Grafana 是一个优秀的仪表盘、分析和数据可视化工具。它没有 Prometheus 的全功能数据收集能力，但 Prometheus 又没有 Grafana 的数据呈现界面。事实上，他们最好是结合在一起使用——Prometheus 负责数据收集和汇总，Grafana 负责数据展示。它们共同创造了一个强大的组合，涵盖了数据收集、基本警报和可视化。&lt;/p&gt;
&lt;h3 id=&#34;高级警报&#34;&gt;高级警报&lt;/h3&gt;
&lt;p&gt;对于高级警报，你可以添加 &lt;a href=&#34;https://www.nagios.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nagios&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/prometheus/alertmanager&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus Alertmanager&lt;/a&gt; 等工具。这些警报工具通常有大量的集成。你可以为自定义值班团队，然后定义你想要监控的参数，例如“当任何 pod 不可用时”或“当任何节点无法访问时”、“当容量达到 90%”等，然后通过电子邮件、短信、手机应用提醒、电话呼叫等方式向值班人员发送自定义通知。你还可以创建升级策略，比如，如果一个被定义为“危急”的警报在 10 分钟内没有值班人员确认，那么就将警报升级（发送警报）到该人员的经理。&lt;/p&gt;
&lt;p&gt;现在，你应该已经对 Docker 和 Kubernetes 有了大体的认识。了解了 Kubernetes 的作用，知道它是如何进行容器化应用部署和管理的。&lt;/p&gt;
&lt;p&gt;调试和监控技术不仅仅是运维需要，你也可以把它当作学习方式。有什么比边做边学更好呢？&lt;/p&gt;
&lt;p&gt;请记住，如果你的应用规模太小，而且预计用户需求不会有太大变化或重大波动（比如一个只在公司内部使用的应用），那么 Kubernetes 对你来说可能没有必要，这种情况下，直接使用 Docker 就足够了。&lt;/p&gt;
&lt;h2 id=&#34;更多&#34;&gt;更多&lt;/h2&gt;
&lt;p&gt;云原生领域的开源项目众多（见 &lt;a href=&#34;https://jimmysong.io/awesome-cloud-native&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Awesome Cloud Native/云原生开源项目大全&lt;/a&gt;），其中有大量的优秀项目可供我们学习。此外，Kubernetes 开源已经多年时间，网上有大量的学习资料，业界出版过很多 &lt;a href=&#34;https://jimmysong.io/cloud-native/note/books/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;书籍&lt;/a&gt;，建议大家通过阅读 &lt;a href=&#34;https://kubernetes.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt; 和实践来学习，也可以参考我编写的 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;推荐大家加入我发起创办的 &lt;a href=&#34;https://cloudnative.to&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区&lt;/a&gt;，这是一个立足中国，放眼世界的云原生终端用户社区，致力于云原生技术的传播和应用。云原生社区主办的 &lt;a href=&#34;https://github.com/cloudnativeto/academy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生学院&lt;/a&gt; 定期邀请云原生和开源领域的大咖在 B 站上进行直播分享，成员自发组织了多个 SIG（特别兴趣小组）进行讨论学习。欢迎加入我们，共同学习和交流云原生技术。如果你想从事服务网格领域，加入一家由开源技术而构建的全球化公司，欢迎大家关注我所在的服务网格公司 &lt;a href=&#34;https://mp.weixin.qq.com/s/_da1ZgA9-wnT5t_bFuw6AQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CNCF 年度报告解读（2018 年）</title>
      <link>https://cloudnativecn.com/blog/cncf-annual-report-2018-review/</link>
      <pubDate>Fri, 15 Feb 2019 10:41:22 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/cncf-annual-report-2018-review/</guid>
      <description>&lt;p&gt;2019 年 2 月初，CNCF 发布了 2018 年的年度报告，这是 CNCF 继 2017 年度报告之后，第二次发布年度报告，2017 年度的报告只有区区 14 页，今年的报告长度增长了一倍达 31 页。下面我将带大家一起来深度解读下这份 2018 年的年度报告，一窥 CNCF 过去一年里在推广云原生的道路上取得的进展。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文最后附上了 2017 年和 2018 年度的报告下载地址。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;cncf-年度报告涵盖的范围&#34;&gt;CNCF 年度报告涵盖的范围&lt;/h2&gt;
&lt;p&gt;在解读 CNCF 的 2018 年度报告之前，我们先简单回顾下&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2018/03/CNCF-Annual-Report-2017.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2017 年度的报告&lt;/a&gt;，因为 2017 年度报告是 CNCF 的首份年度报告，这样我们也能更好的了解 CNCF 的来龙去脉。&lt;/p&gt;
&lt;p&gt;2017 年度报告已经基本确定了 CNCF 每个年度报告所包含的主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自我定位&lt;/li&gt;
&lt;li&gt;会员参与情况&lt;/li&gt;
&lt;li&gt;终端用户社区&lt;/li&gt;
&lt;li&gt;项目更新&lt;/li&gt;
&lt;li&gt;会议和活动&lt;/li&gt;
&lt;li&gt;社区&lt;/li&gt;
&lt;li&gt;培训和认证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上为 CNCF 主要的市场活动，2017 年时其成立的第二年，经过一年时间的筹备，这一年里各种市场活动都已经开始确立并有声有色的开展了起来，包括 KubeCon、成员单位、终端用户都已经发展起来了，以后历年里只是对其不断的发展和完善。&lt;/p&gt;
&lt;p&gt;2018 年度报告中又新增了一些主题，这些主题是从 2018 年开始开展的，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;项目更新与满意度调查&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;给 CNCF 项目的维护者发调查问卷询问满意度&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/about/charter/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF charter&lt;/a&gt; 的修订（2018 年 11 月）&lt;/li&gt;
&lt;li&gt;项目更新与发布&lt;/li&gt;
&lt;li&gt;项目服务与支援&lt;/li&gt;
&lt;li&gt;专项活动、文档、网站与博客支持&lt;/li&gt;
&lt;li&gt;本地化、IT 支持和培训&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;社区拓展&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;社区奖项&lt;/li&gt;
&lt;li&gt;CNCF Meetup&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Ambassador 计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;卡通吉祥物 Phippy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生态系统工具&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://devstats.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;devstats&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Landscape&lt;/a&gt; 和路线图&lt;/li&gt;
&lt;li&gt;项目 logo 物料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试一致性项目&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国际化&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;进入中国&lt;/li&gt;
&lt;li&gt;本地化网站&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详情请大家从本文最后的链接下载报告原文以查看详情。&lt;/p&gt;
&lt;h2 id=&#34;cncf-的定位&#34;&gt;CNCF 的定位&lt;/h2&gt;
&lt;p&gt;CNCF（云原生计算基金会）成立于 2015 年 12 月 11 日，每届年度报告的开篇都会阐明 CNCF 的定位，CNCF 的自我定位在 2018 年发生了一次变动，这也说明基金会是跟随市场形势而动，其定位不是一成不变的，其中的变化暗含着 CNCF 战略的转变。&lt;/p&gt;
&lt;h3 id=&#34;cncf-的-2017-年度定位&#34;&gt;CNCF 的 2017 年度定位&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2018/03/CNCF-Annual-Report-2017.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2017 年度报告&lt;/a&gt;中是这样正式介绍自己的：&lt;/p&gt;
&lt;p&gt;The Cloud Native Computing Foundation (CNCF) is an open source software foundation dedicated to making cloud-native computing universal and sustainable. Cloud-native computing uses an &lt;strong&gt;open source&lt;/strong&gt; software stack to deploy applications as &lt;strong&gt;microservices&lt;/strong&gt;, packaging each part into its own &lt;strong&gt;container&lt;/strong&gt;, and &lt;strong&gt;dynamically orchestrating&lt;/strong&gt; those containers to optimize resource utilization. Cloud-native technologies enable software developers to build great products faster.&lt;/p&gt;
&lt;p&gt;We are a community of open source projects, including Kubernetes, Envoy and Prometheus. Kubernetes and other CNCF projects are some of the highest velocity projects in the history of open source.&lt;/p&gt;
&lt;p&gt;可以看到介绍中的重点技术是：微服务、容器、动态编排。而在 2018 年 CNCF 对自己进行了重新的定位和包装，增加了新的内容。&lt;/p&gt;
&lt;h3 id=&#34;cncf-的-2018-年度定位&#34;&gt;CNCF 的 2018 年度定位&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2019/02/CNCF_Annual_Report_2018_FInal.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2018 年度报告&lt;/a&gt;中 CNCF 对自己的定位是：&lt;/p&gt;
&lt;p&gt;The Cloud Native Computing Foundation (CNCF) is an open source software foundation dedicated to making cloud native computing universal and sustainable. Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. &lt;strong&gt;Containers&lt;/strong&gt;, &lt;strong&gt;service meshes&lt;/strong&gt;, &lt;strong&gt;microservices&lt;/strong&gt;, &lt;strong&gt;immutable infrastructure&lt;/strong&gt;, and &lt;strong&gt;declarative APIs&lt;/strong&gt; exemplify this approach.&lt;/p&gt;
&lt;p&gt;We are a community of open source projects, including Kubernetes, Prometheus, Envoy, and many others. Kubernetes and other CNCF projects are some of the highest velocity projects in the history of open source.&lt;/p&gt;
&lt;p&gt;我们可以看到其表述中更加注重多云环境，主要涉及的技术比 2017 年多了 Service Mesh（服务网格）、不可变基础设施和声明式 API。&lt;/p&gt;
&lt;h2 id=&#34;数读报告&#34;&gt;数读报告&lt;/h2&gt;
&lt;p&gt;CNCF 年度报告的原文主要是汇报了 CNCF 一年来的所展开的活动和进展，下表示根据 CNCF 2017 和 2018 年度报告整理了关键数据。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;Year&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;2016&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;2017&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;2018&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Members&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;63&lt;/td&gt;
          &lt;td&gt;170&lt;/td&gt;
          &lt;td&gt;365&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Contributors&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;18687&lt;/td&gt;
          &lt;td&gt;47358&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;CNCF Meetup Members&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;53925&lt;/td&gt;
          &lt;td&gt;89112&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Projects&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;14&lt;/td&gt;
          &lt;td&gt;32&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;End User Community Members&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;32&lt;/td&gt;
          &lt;td&gt;69&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Conference and Events Participants&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;4085&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Certified Kubernetes Partners&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;44&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Certified Kubernetes Service Providers&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;28&lt;/td&gt;
          &lt;td&gt;74&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;CNCF Ambassador&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;65&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Kubernetes Training Partners&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;18&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：其中 2016 年是 CNCF 正式开始工作的第一年，大部分数据因为活动尚未开展而缺失。&lt;/p&gt;
&lt;p&gt;从上表中我们可以看到 CNCF 诞生三年来基金会成员规模、托管项目的贡献者、参加 CNCF 名义的 Meetup 的人数取得较大范围的增长，尤其是 2018 年，因为基金会成员的爆发式增长（+130%），CNCF 开始给成员分级，会员级别、费用和权益也在 &lt;a href=&#34;https://www.cncf.io/about/join/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 官网&lt;/a&gt;上明码标价。&lt;/p&gt;
&lt;p&gt;2018 年 CNCF 组织的 KubeCon&amp;amp;CloudNativeCon 开始固定每年在西欧、北美和中国举行，且 2018 年是首次进入中国；原来的 Certified Kubernetes Partners 也取消了变成了 Certified Kubernetes Service Providers；CNCF 的 &lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambassador&lt;/a&gt; 计划拥有了来自 15 个国家的 65 位 Ambassador，在世界各地为云原生布道；CNCF 还首次引入了 Kubernetes Training Partner。&lt;/p&gt;
&lt;p&gt;2018 年 CNCF 又推出了一系列新的认证（CKA 为 2017 年推出），包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/cka/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CKA&lt;/a&gt;（Kubernetes 管理员认证）：这是 CNCF 最早制定的一个证书，顾名思义，通过该认证证明用户具有管理 Kubernetes 集群的技能、知识和能力。虽然该证书在 2017 年即推出，但 2018 年对考试做了更细致的指导。KCSP 要求企业必须有至少三人通过 CKA。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/ckad/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CKAD&lt;/a&gt;（Kubernetes 应用开发者认证）：该认证证明用户可以为 Kubernetes 设计、构建、配置和发布云原生应用程序。经过认证的 Kubernetes Application Developer 可以定义应用程序资源并使用核心原语来构建、监控 Kubernetes 中可伸缩应用程序和排除故障。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KCSP&lt;/a&gt;（Kubernetes 服务提供商认证）：截止本文发稿时共有 74 家企业通过该认证。该认证的主体是企业或组织，通过 KCSP 的企业意味着可以为其他组织提供 Kubernetes 支持、咨询、专业服务和培训。通过该认证的中国企业有：灵雀云、阿里云、博云、才云、DaoCloud、EasyStack、易建科技、精灵云、谐云科技、华为、时速云、星号科技、睿云智合、沃趣、元鼎科技、ZTE。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/software-conformance/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Certified Kubernetes Conformance&lt;/a&gt;（Kubernetes 一致性认证）：通过该认证的 Kubernetes 提供商所提供的服务，意味着其可以保证 Kubernetes API 的可移植性及跨云的互操作性；及时更新到最新的 Kubernetes 版本；是否一致是可以通过&lt;a href=&#34;https://github.com/cncf/k8s-conformance/blob/master/instructions.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;运行开源脚本&lt;/a&gt;验证的。截止本文发稿通过该认证的中国企业的发行版有：灵雀云（ACE、ACP、AKS）、才云 Compass、华为 FusionStage、酷栈科技 CStack MiaoYun、Daocloud Enterprise、新智认知新氦云、浪潮云、京东 TIG、网易云、七牛云、同方有云、睿云智合 WiseCloud；通过认证的中国企业托管平台有：阿里云、百度云、博云、EasyStack、易建科技、谐云科技、华为云 CCE、腾讯云 TKE、时速云、ZTE TECS。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上是 CNCF 提供的主要证书，一般通过 KCSP 的企业都要先通过 Kubernetes 一致性认证，而通过 Kubernetes 一致性认证不一定要同时通过 KCSP，所以我们看到很多通过 Kubernetes 一致性认证的企业就不一定会通过 KCSP，因为 KCSP 的要求更多，至少要成为 CNCF 会员才可以。&lt;/p&gt;
&lt;p&gt;下面将就 CNCF 会员、托管项目的成熟度等级划分、Kubernetes 服务提供商认证和 Kubernetes 提供商认证做详细说明。&lt;/p&gt;
&lt;h2 id=&#34;cncf-会员&#34;&gt;CNCF 会员&lt;/h2&gt;
&lt;p&gt;2018 年 CNCF 的会员单位经历了爆发式增长，从 170 家增长到 365 家。CNCF 制定了如下的会员等级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Silver Member&lt;/li&gt;
&lt;li&gt;Gold Member&lt;/li&gt;
&lt;li&gt;Platinum Member&lt;/li&gt;
&lt;li&gt;Academic/Nonprofit Member&lt;/li&gt;
&lt;li&gt;End User Member&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同等级的会员需要交纳的年费与权益不同，详情请见 &lt;a href=&#34;https://www.cncf.io/about/join/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/about/join/&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;成为-cncf-会员的好处&#34;&gt;成为 CNCF 会员的好处&lt;/h3&gt;
&lt;p&gt;成为 CNCF 会员包括但不限于如下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将可以参与 CNCF 市场委员会、CNCF Webinar、在 CNCF 和 Kubernetes 官网发表博客、博客被 KubeWeekly 收录、&lt;/li&gt;
&lt;li&gt;获得 KubeCon + CloudNativeCon 的门票折扣和参与大会的市场活动&lt;/li&gt;
&lt;li&gt;对于 Kubernetes 系列认证如 KCSP、入选 TOC 也要求必须成为 CNCF 会员才可以获得&lt;/li&gt;
&lt;li&gt;End User Case Study&lt;/li&gt;
&lt;li&gt;有机会加入 Ambassador 计划&lt;/li&gt;
&lt;li&gt;在社区里具有更多的话语权，例如 CNCF 在全球范围内组织的活动&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;项目成熟度等级&#34;&gt;项目成熟度等级&lt;/h2&gt;
&lt;p&gt;自 2015 年底 CNCF 创立之初 Kubernetes 成为其首个托管项目以来，截止到 2018 年底，CNCF 已经托管了&lt;a href=&#34;https://www.cncf.io/projects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;32 个开源项目&lt;/a&gt;，随着越来越多的项目加入到 CNCF，为了更好的管理这些项目，为这些项目划分不同的成熟度等级就成了迫在眉睫的事情。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-cncf-项目成熟度级别&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;CNCF 项目成熟度级别&#34; srcset=&#34;
               /blog/cncf-annual-report-2018-review/006tNc79ly1g04s0oznytj31tg0ok7ca_hu_68b4e94ccb7b211b.webp 400w,
               /blog/cncf-annual-report-2018-review/006tNc79ly1g04s0oznytj31tg0ok7ca_hu_dede17bb21ea6f61.webp 760w,
               /blog/cncf-annual-report-2018-review/006tNc79ly1g04s0oznytj31tg0ok7ca_hu_e960064ff6a203c3.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cncf-annual-report-2018-review/006tNc79ly1g04s0oznytj31tg0ok7ca_hu_68b4e94ccb7b211b.webp&#34;
               width=&#34;760&#34;
               height=&#34;285&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      CNCF 项目成熟度级别
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;根据《Crossing the Chasm》一书中的技术采用生命周期理论，CNCF 将其托管的项目划分为三个等级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Graduated：对应于早期成熟项目。截止到本文发稿时只有 &lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;、&lt;a href=&#34;https://prometheus.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus&lt;/a&gt;、&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 和 &lt;a href=&#34;https://coredns.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://coredns.io/&lt;/a&gt; 毕业。&lt;/li&gt;
&lt;li&gt;Incubating：对应于早期采用者阶段。截止到本文发稿时有 16 个项目。&lt;/li&gt;
&lt;li&gt;Sandbox：对应于创新者阶段。截止到本文发稿时有 12 个项目。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看 CNCF 托管的项目列表请访问：https://www.cncf.io/projects/&lt;/p&gt;
&lt;p&gt;CNCF 通过为项目设置成熟度水平是来建议企业应该采用哪些项目。CNCF 中托管的项目通过向 CNCF 的技术监督委员会（TOC）展示其可持续发展性来提高其成熟度：项目的采用率，健康的变化率，有来自多个组织的提交者，采用了 &lt;a href=&#34;https://github.com/cncf/foundation/blob/master/code-of-conduct-languages/zh.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 行为准则&lt;/a&gt;，实现并维护了核心基础设施倡议（Core Infrastructure Initiative）&lt;a href=&#34;https://bestpractices.coreinfrastructure.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最佳实践证书&lt;/a&gt;。详细信息在 &lt;a href=&#34;https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;毕业标准 v1.1&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;certified-kubernetes-service-provider&#34;&gt;Certified Kubernetes Service Provider&lt;/h2&gt;
&lt;p&gt;通过 &lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KCSP&lt;/a&gt; 意味着企业具有为其他企业或组织提供 Kubernetes 支持、咨询、专业服务和培训的资质。2018 年又有 46 家企业通过了&lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KCSP&lt;/a&gt;，通过该认证的企业累计达到 76 家。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kcsp&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;KCSP&#34; srcset=&#34;
               /blog/cncf-annual-report-2018-review/006tNc79ly1g04tl97vm4j318v0h7dpt_hu_ca5d23c0ac0d0b1f.webp 400w,
               /blog/cncf-annual-report-2018-review/006tNc79ly1g04tl97vm4j318v0h7dpt_hu_f3020189aca2e470.webp 760w,
               /blog/cncf-annual-report-2018-review/006tNc79ly1g04tl97vm4j318v0h7dpt_hu_8cbe34fe6d43f725.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cncf-annual-report-2018-review/006tNc79ly1g04tl97vm4j318v0h7dpt_hu_ca5d23c0ac0d0b1f.webp&#34;
               width=&#34;760&#34;
               height=&#34;291&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      KCSP
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何通过 KCSP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要想通过 KCSP 必须满足以下三个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三名或更多工程师通过认证 Kubernetes 管理员（CKA）考试。&lt;em&gt;（CKAD 考试不计入此要求）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;支持企业最终用户的商业模式，包括为客户提供驻场工程师&lt;/li&gt;
&lt;li&gt;成为 CNCF 会员&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 KCSP 有如下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;企业的 logo 会出现在 &lt;a href=&#34;https://kubernetes.io/partners/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Partners&lt;/a&gt; 页面&lt;/li&gt;
&lt;li&gt;参加与云原生项目 leader、TOC 成员、CNCF Governing Board 的月度会议&lt;/li&gt;
&lt;li&gt;向终端用户的 leader 寻求帮助&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为有如上这些好处，为了获得 Kubernetes 项目实施的资质，同时保持与基金会至今的交流，Kubernetes 厂商对该认证都趋之若鹜。&lt;/p&gt;
&lt;h2 id=&#34;certified-kubernetes-offering&#34;&gt;Certified Kubernetes offering&lt;/h2&gt;
&lt;p&gt;通过 KCSP 认证只代表企业有为他人实施 Kubernetes 项目的资质，而企业自身可能并不对外提供 Kubernetes 平台或服务，这些企业可能只是系统集成商或 ISV，这时候 CNCF 又推出了 Kubernetes 提供商认证。&lt;/p&gt;
&lt;p&gt;Kubernetes 认证的提供商包括 Kubernetes 发行版、托管平台和安装器，通过认证的工具或平台将允许使用 Kubernetes 认证的 Logo，并保证 Kubernetes 一致性认证。&lt;/p&gt;
&lt;h2 id=&#34;展望-2019&#34;&gt;展望 2019&lt;/h2&gt;
&lt;p&gt;2018 年 Kubernetes 成为 CNCF 孵化的首个毕业项目，根据 CNCF 打造的项目成熟度模型，Prometheus、Envoy、CoreDNS 相继毕业，CNCF 的眼光早已不再仅盯着 Kubernetes 了，&lt;a href=&#34;https://landscape.cncf.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Landscape&lt;/a&gt; 几乎包揽了所有云计算相关开源项目。可以说 CNCF 早已超出了 Kubernetes 的范畴，而是旨在一个建立在 Kubernetes 为底层资源调度和应用生命周期管理之上的生态系统，CNCF 中还演进出了如 Service Mesh 和 Serverless 之类的分支。&lt;/p&gt;
&lt;p&gt;从 CNCF 2017 和 2018 年度的变化来看，其中已经去掉了”dynamically orchestrating“的字眼，也就意味着 Kubernetes 在容器编排领域已经胜出，进而强调多云环境，同时 CNCF 推动的 Kubernetes 一致性认证也受到众多云厂商的支持，这也意味着 Kubernetes 将成为多云环境 API 一致性的保证。&lt;/p&gt;
&lt;p&gt;CNCF 在 2019 年的战略将更聚焦于开发者社区，协助尤其是来自终端用户的开发者成为项目的 contributor 和 maintainer，保证终端用户的意见能够在社区里被正确地传达和并最终成功地采纳云原生。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2018/03/CNCF-Annual-Report-2017.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Annual Report 2017 pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2019/02/CNCF_Annual_Report_2018_FInal.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Annual Report 2018 pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/projects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF  Projects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://landscape.cncf.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Landscape&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Ambassadors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/certification/kcsp/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Certified Service Providers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何将云原生工作负载映射到 Kubernetes 中的控制器</title>
      <link>https://cloudnativecn.com/blog/how-to-map-cloud-native-workloads-to-kubernetes-controllers/</link>
      <pubDate>Wed, 31 Oct 2018 20:01:03 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/how-to-map-cloud-native-workloads-to-kubernetes-controllers/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://thenewstack.io/how-to-map-cloud-native-workloads-to-kubernetes-controllers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Kubernetes &lt;a href=&#34;https://thenewstack.io/how-kubernetes-is-transforming-into-a-universal-scheduler/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不仅仅是一个容器管理工具&lt;/a&gt;。它是一个平台，旨在处理包装在任意数量的容器和组合中的各种工作负载。Kubernetes 内置了多个控制器，可映射到云原生架构的各个层。&lt;/p&gt;
&lt;p&gt;DevOps 工程师可以将 Kubernetes 控制器视为指示团队运行的各种工作负载的基础架构需求的手段。他们可以通过声明方法定义所需的配置状态。例如，容器/pod 作为 ReplicationController 的一部分部署保证始终可用。打包为 DaemonSet 的容器​保证在集群的每个节点上运行。声明式的方法使 DevOps 团队能够利用代码控制基础架构。下面讨论的一些部署模式遵循不可变基础结构的原则，其中每个新的部署都会导致原子部署。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/how-to-map-cloud-native-workloads-to-kubernetes-controllers/61411417ly1fwrcxotk3xj20r30i2n30_hu_43649730e5e039be.webp 400w,
               /blog/how-to-map-cloud-native-workloads-to-kubernetes-controllers/61411417ly1fwrcxotk3xj20r30i2n30_hu_cd4116c1cc9dc5ab.webp 760w,
               /blog/how-to-map-cloud-native-workloads-to-kubernetes-controllers/61411417ly1fwrcxotk3xj20r30i2n30_hu_4a05a3367ba672f5.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-map-cloud-native-workloads-to-kubernetes-controllers/61411417ly1fwrcxotk3xj20r30i2n30_hu_43649730e5e039be.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;DevOps 工程师可以通过声明方法定义所需的配置状态——每个工作负载映射到控制器。&lt;/p&gt;
&lt;h2 id=&#34;了解云原生用例&#34;&gt;了解云原生用例&lt;/h2&gt;
&lt;p&gt;Kubernetes 的控制平面不断跟踪部署，以确保它们符合 DevOps 定义的所需配置状态。&lt;/p&gt;
&lt;p&gt;Kubernetes 的基本部署单位是一个 pod。它是 Kubernetes 的基本构建块，是 Kubernetes 对象模型中最小和最简单的单元。pod 表示集群上正在运行的进程。无论服务是有状态的还是无状态的，它总是打包并部署为 pod。&lt;/p&gt;
&lt;p&gt;控制器可以在集群中创建和管理多个 pod，处理在集群范围内提供自我修复功能的副本。例如，如果节点发生故障，控制器可能会通过在不同节点上安排相同的 pod 用来自动替换该故障 pod。&lt;/p&gt;
&lt;p&gt;Kubernetes 配有多个控制器，可以处理所需的 pod 状态。如 ReplicationController、Deployment、DaemonSet 和 StatefulSet 控制器。Kubernetes 控制器使用提供的 pod 模板，来创建其负责 pod 的所需状态。与其他 Kubernetes 对象一样，Pod 在 YAML 文件中定义并提交给控制平面。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中运行云原生应用程序时，运维人员需要了解控制器解决的用例，以充分利用平台的特性。这有助于他们定义和维护应用程序的所需配置状态。&lt;/p&gt;
&lt;p&gt;上一节中介绍的每种模式都映射到特定的 Kubernetes 控制器，这些控制器允许对 Kubernetes 的工作负载进行更精确，细粒度的控制，但是采用自动化方式。&lt;/p&gt;
&lt;p&gt;Kubernetes 的声明式配置鼓励不可变的基础架构。控制平面跟踪和管理部署，以确保在整个应用程序生命周期中维护所需的配置状态。与基于虚拟机的传统部署相比，DevOps 工程师将花费更少的时间来维护工作负载。利用 Kubernetes 原语和部署模式的有效 CI/CD 策略使运营商无需执行繁琐的任务。&lt;/p&gt;
&lt;h3 id=&#34;可扩展层无状态工作负载&#34;&gt;可扩展层：无状态工作负载&lt;/h3&gt;
&lt;p&gt;无状态工作负载在 Kubernetes 中打包并部署为 ReplicaSet。ReplicationController 构成 ReplicaSet 的基础，可确保在任何给定时间始终运行指定数量的 pod 副本。换句话说，ReplicationController 确保一个 pod 或一组同类 pod 总是可用。&lt;/p&gt;
&lt;p&gt;如果有太多 pod，ReplicationController 可能会终止额外的 pod。如果太少，ReplicationController 将继续启动其他 pod。与手动创建的 pod 不同，ReplicationController 维护的 pod 在失败，删除或终止时会自动替换。在诸如内核升级之类的破坏性维护之后，在节点上重新创建 pod。因此，即使应用程序只需要一个 pod，也建议使用 ReplicationController。&lt;/p&gt;
&lt;p&gt;一个简单的用例是创建一个 ReplicationController 对象，以无限期地可靠地运行 pod 的一个实例。更复杂的用例是运行横向扩展服务的几个相同副本，例如 Web 服务器。在 Kubernetes 中部署时，DevOps 团队和运营商将无状态工作负载打包为 ReplicationControllers。&lt;/p&gt;
&lt;p&gt;在最近的 Kubernetes 版本中，ReplicaSets 取代了 ReplicationControllers。它们都针对相同的场景，但 ReplicaSet 使用基于 &lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#set-based-requirement&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;集合的标签选择器&lt;/a&gt; ，这使得可以使用基于注释的复杂查询。此外，Kubernetes 中的部署依赖于 ReplicaSet。&lt;/p&gt;
&lt;p&gt;Deployment 是 ReplicaSet 的抽象。在 Deployment 对象中声明所需状态时，Deployment 控制器会以受控速率将实际状态更改为所需状态。&lt;/p&gt;
&lt;p&gt;强烈建议部署管理云原生应用程序的无状态服务。虽然服务可以部署为 pod 和 ReplicaSet，但部署可以更轻松地升级和修补应用程序。DevOps 团队可以使用部署来升级 pod，而无法使用 ReplicaSet 完成。这样就可以在最短的停机时间内推出新版本的应用程序。部署为应用程序管理带来了类似于服务（PaaS）的功能。&lt;/p&gt;
&lt;h3 id=&#34;持久层有状态的工作量&#34;&gt;持久层：有状态的工作量&lt;/h3&gt;
&lt;p&gt;状态工作负载可以分为两类：需要持久存储的服务（单实例）和需要以高可靠性和可用模式运行的服务（复制的多实例）。需要访问持久存储后端的 pod 与为关系数据库运行集群的一组 pod 非常不同。虽然前者需要长期持久的持久性，但后者需要高可用性的工作量。Kubernetes 解决了这两种情况。&lt;/p&gt;
&lt;p&gt;可以通过将底层存储暴露给服务的卷来支持单个 pod。可以将卷映射到调度 pod 的任意节点。如果在集群的不同节点上调度多个 pod 并需要共享后端，则在部署应用程序之前手动配置分布式文件系统（如网络文件系统（NFS）或 Gluster）。云原生态系统中提供的现代存储驱动程序提供容器本机存储，其中文件系统本身通过容器公开。当 pod 只需要持久性和持久性时，请使用此配置。&lt;/p&gt;
&lt;p&gt;对于预计具有高可用性的场景，Kubernetes 提供 StatefulSets - 一组专门的 pod，可确保 pod 的排序和唯一性。这在运行主要/辅助（以前称为主/从）数据库集群配置时尤其有用。&lt;/p&gt;
&lt;p&gt;与部署类似，StatefulSet 管理基于相同容器规范的 pod。与 Deployment 不同，StatefulSet 为其每个 pod 保留唯一标识。这些 pod 是根据相同的规范创建的，但不可互换：每个 pod 都有一个持久标识符，它可以在任何重新安排时保留。&lt;/p&gt;
&lt;p&gt;StatefulSet 对需要以下一项或多项的工作负载非常有用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;稳定，独特的网络标识符。&lt;/li&gt;
&lt;li&gt;稳定，持久的存储。&lt;/li&gt;
&lt;li&gt;有序，优雅的部署和扩展。&lt;/li&gt;
&lt;li&gt;有序，优雅的删除和终止。&lt;/li&gt;
&lt;li&gt;有序的自动滚动更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes 对 StatefulSets 的处理方式与其他控制器不同。当正在使用 N 个副本调度 StatefulSet 的 pod 时，将按顺序创建它们，顺序从 0 到 N-1。当删除 StatefulSet 的 pod 时，它们以相反的顺序终止，从 N-1 到 0。在将一个扩展操作应用于 pod 之前，它的所有前驱必须正在运行并准备就绪。Kubernetes 确保在终止 pod 之前，其所有后继者都完全关闭。&lt;/p&gt;
&lt;p&gt;当服务需要运行 Cassandra、MongoDB、MySQL、PostgreSQL 集群或任何具有高可用性要求的数据库工作负载时，建议使用 StatefulSet。&lt;/p&gt;
&lt;p&gt;并非每个持久性工作负载都必须是 StatefulSet。某些容器依赖于持久存储后端来存储数据。为了向这些类型的应用程序添加持久性，pod 可能依赖于由基于主机的存储或容器本机存储后端支持的卷。&lt;/p&gt;
&lt;h3 id=&#34;可并行化层批处理&#34;&gt;可并行化层：批处理&lt;/h3&gt;
&lt;p&gt;Kubernetes 具有用于批处理的内置原语，这对于执行运行到完成作业或预定作业很有用。&lt;/p&gt;
&lt;p&gt;运行到完成作业通常用于运行需要执行操作和退出的进程。在处理数据之前运行的大数据工作负载就是这种工作的一个例子。另一个示例是一个处理队列中每条消息的作业，直到队列变空。&lt;/p&gt;
&lt;p&gt;作业是一个控制器，可以创建一个或多个 pod 并确保指定数量的 pod 成功终止。当 pod 成功完成后，Job 会跟踪成功的完成情况。达到指定数量的成功完成后，作业本身就完成了。删除作业将清理它创建的 pod。&lt;/p&gt;
&lt;p&gt;Job 还可以用于并行运行多个 pod，这使其成为机器学习培训工作的理想选择。Job 还支持并行处理一组独立但相关的工作项。&lt;/p&gt;
&lt;p&gt;当 Kubernetes 在具有 GPU 的硬件上运行时，机器学习培训可以利用 Job。诸如 Kubeflow 之类的新兴项目 - 一个致力于在 Kubernetes 上部署机器学习的简单，可移植和可扩展的项目 - 将把原始资料作为 job 包装到机器学习培训中。&lt;/p&gt;
&lt;p&gt;除了运行并行化作业外，可能还需要运行预定作业。Kubernetes 公开了 CronJobs，它可以在指定的时间点运行一次，也可以在指定的时间点定期运行。Kubernetes 中的 CronJob 对象类似于 Unix 中 crontab（cron 表）文件的一行。它以给定的时间表定期运行，以 cron 格式编写。&lt;/p&gt;
&lt;p&gt;Cron 作业对于安排定期作业（如数据库备份或发送电子邮件）特别有用。&lt;/p&gt;
&lt;h3 id=&#34;事件驱动层无服务器serverless&#34;&gt;事件驱动层：无服务器（Serverless）&lt;/h3&gt;
&lt;p&gt;无服务器计算（Serverless）是指构建和运行不需要服务器管理的应用程序的概念。它描述了一种更细粒度的部署模型，其中捆绑为一个或多个功能的应用程序上传到平台，然后执行，缩容和计费以响应当前所需的确切需求。&lt;/p&gt;
&lt;p&gt;函数即服务（FaaS）在无服务器计算的环境中运行，以提供事件驱动的计算。开发人员使用由事件或 HTTP 请求触发的功能来运行和管理应用程序代码。开发人员将小型代码单元部署到 FaaS，这些代码根据实际需要作为独立组件执行，无需管理服务器或任何其他底层基础架构即可进行扩展。&lt;/p&gt;
&lt;p&gt;虽然 Kubernetes 没有集成的事件驱动原语来响应其他服务引发的警报和事件，但仍有努力引入事件驱动的功能。该&lt;a href=&#34;http://bit.ly/2GBO5Dd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生计算基金会&lt;/a&gt; ，Kubernetes 的托管者，一直专注于这些致力于无服务器的工作组。&lt;a href=&#34;https://openwhisk.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache OpenWhisk&lt;/a&gt; 、&lt;a href=&#34;https://github.com/fission/fission&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fission&lt;/a&gt; 、&lt;a href=&#34;https://github.com/kubeless/kubeless&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubeless&lt;/a&gt; 、&lt;a href=&#34;https://github.com/openfaas/faas&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenFaaS&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/fnproject/fn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Oracle 的 Fn&lt;/a&gt; 等开源项目可以在 Kubernetes 集群中作为事件驱动的无服务器层运行。&lt;/p&gt;
&lt;p&gt;在无服务器环境中部署的代码与打包为 pod 的代码根本不同。它由自治函数组成，可以连接到可能触发代码的一个或多个事件。&lt;/p&gt;
&lt;p&gt;当事件驱动计算——无服务器计算成为 Kubernetes 不可或缺的一部分时，开发人员将能够部署响应 Kubernetes 控制平面生成的内部事件以及应用程序服务引发的自定义事件的函数。&lt;/p&gt;
&lt;h3 id=&#34;遗留层headless-service&#34;&gt;遗留层：Headless Service&lt;/h3&gt;
&lt;p&gt;即使您的组织经常使用微服务架构构建和部署应用程序到云上的容器中，也可能有一些应用程序继续存在于 Kubernetes 之外。云原生应用程序和服务必须与那些传统的单一应用程序进行交互。&lt;/p&gt;
&lt;p&gt;遗留层的存在是为了实现互操作性，以暴露一组指向单体应用程序的 Headless Service。Headless Service 允许开发人员通自由地以自己的方式进行服务发现来减少与 Kubernetes 系统的耦合。Kubernetes 中的 Headless Services 与 ClusterIP、NodePort 和 LoadBalancer 类型的服务不同。它们没有分配给它们的 Internet 协议（IP）地址，但具有指向外部端点（如 API Server、Web 服务器和数据库）的域名系统（DNS）条目。遗留层是一个逻辑互操作性层，它将 DNS 记录维护到众所周知的外部端点。&lt;/p&gt;
&lt;p&gt;微服务应用程序的每一层都可以映射到 Kubernetes 的一个控制器。根据希望部署的模式，DevOps 团队可以进行相应的选择。在下一篇文章中，我们将讨论将云原生应用程序部署到 Kubernetes 的一些最佳实践。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;Janakiram MSV 是 Janakiram＆Associates 的首席分析师，也是国际信息技术学院的兼职教员。他还是 Google 认证云开发人员，亚马逊认证解决方案架构师，亚马逊认证开发人员，亚马逊认证 SysOps 管理员和 Microsoft 认证 Azure 专业人员。Janakiram 是云原生计算基金会的大使，也是最早的认证 Kubernetes 管理员和认证 Kubernetes 应用程序开发人员之一。他之前的经历包括 Microsoft、AWS、Gigaom Research 和 Alcatel-Lucent。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生可移植性的神话</title>
      <link>https://cloudnativecn.com/blog/myth-cloud-native-portability/</link>
      <pubDate>Tue, 30 Oct 2018 17:15:17 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/myth-cloud-native-portability/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://thenewstack.io/myth-cloud-native-portability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文最初发表于 2017 年 5 月 24 日。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;随着大量新平台和支持工具的出现，云原生势头正在增长。这些新平台为开发人员提供了越来越多的功能，可以以自动化的方式快速开发，部署和管理大量&lt;a href=&#34;https://thenewstack.io/category/microservices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但这种云原生的势头的增长同样会伴随着成本的增加，最好做好为此付出代价的准备。&lt;/p&gt;
&lt;p&gt;最近我写了一篇由 Kubernetes 等云原生平台提供的“&lt;a href=&#34;http://www.ofbizian.com/2017/04/new-distributed-primitives-for.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为开发者准备的新的分布式原语&lt;/a&gt;”，以及这些原语如何与开发应用程序的编程原语相结合。例如，下面看看开发人员必须了解和使用多少 &lt;a href=&#34;https://thenewstack.io/category/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 概念才能有效地运行单个容器化应用程序：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-kubernetes-的微服务&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 Kubernetes 的微服务&#34; srcset=&#34;
               /blog/myth-cloud-native-portability/61411417ly1fwp5js00wxj20sg0m8wnm_hu_b1b9dc3afb57ed19.webp 400w,
               /blog/myth-cloud-native-portability/61411417ly1fwp5js00wxj20sg0m8wnm_hu_d1175519f025f60d.webp 760w,
               /blog/myth-cloud-native-portability/61411417ly1fwp5js00wxj20sg0m8wnm_hu_78faa66ba852a9ca.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/myth-cloud-native-portability/61411417ly1fwp5js00wxj20sg0m8wnm_hu_b1b9dc3afb57ed19.webp&#34;
               width=&#34;760&#34;
               height=&#34;594&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 Kubernetes 的微服务
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;请记住，此图表不包含 DevOps 团队的 Ops 部门必须管理的支持 Kubernetes 的对象。在操作之前也不需要额外的应用程序支持工具（用于日志管理、监控、跟踪、服务网格等）。&lt;/p&gt;
&lt;p&gt;更有可能的是，开发人员必须编写与容器中的应用程序代码相同数量的 YAML 代码。更重要的是，应用程序本身将依赖于比以往更多的平台。云原生应用程序期望平台执行运行状况检查、部署、放置、服务发现、运行定时任务（ &lt;strong&gt;cron&lt;/strong&gt; 作业）或调度原子工作单元（作业）、自动扩展、配置管理等。&lt;/p&gt;
&lt;p&gt;因此，您的应用程序已放弃并将所有这些职责委托给平台，并期望以可靠的方式处理它们。事实上，现在您的应用程序和相关团队在很多不同的级别上依赖于平台：代码、设计、体系结构、开发实践、部署和交付管道、支持过程、恢复方案，你能想到的一切。&lt;/p&gt;
&lt;h2 id=&#34;在生态系统上下注而不是在平台上&#34;&gt;在生态系统上下注而不是在平台上&lt;/h2&gt;
&lt;p&gt;上图显示了代码在 Kubernetes 微服务环境中的小巧程度。但是，当我们谈论基于生产就绪的微服务系统时，这种情况远未完成。任何规模庞大的系统都需要集中监控、度量收集、跟踪、服务网格、集成构建和部署工具、管道等工具。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-微服务需求层次&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;微服务需求层次&#34; srcset=&#34;
               /blog/myth-cloud-native-portability/61411417ly1fwp5jsbrzrj20sg0ltk30_hu_9021027051ed664e.webp 400w,
               /blog/myth-cloud-native-portability/61411417ly1fwp5jsbrzrj20sg0ltk30_hu_3a553deb45bb6f7d.webp 760w,
               /blog/myth-cloud-native-portability/61411417ly1fwp5jsbrzrj20sg0ltk30_hu_28419db994c2f2c7.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/myth-cloud-native-portability/61411417ly1fwp5jsbrzrj20sg0ltk30_hu_9021027051ed664e.webp&#34;
               width=&#34;760&#34;
               height=&#34;583&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      微服务需求层次
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://thenewstack.io/introducing-microservices-hierarchy-needs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务需求层次&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该平台只是冰山一角，为了在云原生世界取得成功，您需要成为完全集成的工具和公司生态系统的一部分。因此，赌注绝不是单一平台、项目、很酷的库或一家公司。它涉及整个协同工作的整个项目生态系统，以及在未来十年左右合作并致力于该事业的公司（供应商和客户）的整个生态系统。我认为这两个方面同样重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;技术&lt;/strong&gt; ：考虑到向云原生过渡是一个多年的旅程，只有长期成功才能带来好处，重要的是打赌有可能在未来 5 到 10 年内发展的技术，而不是从过去 5 到 10 年的历史。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文化&lt;/strong&gt; ：cloud-native 是通过微服务、容器、持续交付和 DevOps 的组合实现的。而成为云原生需要的不仅仅是为您的应用程序添加少量依赖项/库（也不是在某些会议中如何推广它）。您可能不得不改变团队结构和固定流程、工作习惯和编码实践，并习惯于消耗仍然非常活跃的技术空间。如果您的公司文化在某种程度上更接近于开发或仅使用云原生平台和相关工具的公司的文化，那就更容易了。诸如提出拉取请求与提交错误报告，检查上游源代码以及为即将推出的新功能打开讨论之类的小事情。文化一致性和人文因素与技术优势同等重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下内容并不代表完整的格局，但我将尝试将我想到的主要云原生生态系统分组：&lt;/p&gt;
&lt;h3 id=&#34;mesosphere-和-apache-mesos&#34;&gt;Mesosphere 和 Apache Mesos&lt;/h3&gt;
&lt;p&gt;作为 Apache Software Foundations 的一部分，&lt;a href=&#34;http://mesos.apache.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache Mesos&lt;/a&gt; 有优势（成熟的社区）也有缺点（进度缓慢）。它诞生于 2009 年左右，是一个成熟的框架，它最近增加了对容器（我的意思是 docker 格式）和类似概念（如 Pod/Task 组）的支持。&lt;/p&gt;
&lt;h3 id=&#34;cloud-foundry-和-spring-cloud&#34;&gt;Cloud Foundry 和 Spring Cloud&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://bit.ly/2quBaL4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Foundry&lt;/a&gt;诞生于 2009 年左右，是云原生世界的先驱之一。当 &lt;a href=&#34;http://cloud.spring.io/spring-cloud-cloudfoundry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud 与 Cloud Foundry 一起使用时，&lt;/a&gt; 该平台与应用程序本身融为一体。服务发现、负载平衡、配置管理、重试、超时等一系列功能在服务中执行（在本例中为 JVM）。这是 Kubernetes 等平台所采取的相反方法，其中所有这些职责都委托给平台或其他支持容器（例如 [envoy](&lt;a href=&#34;https://lyft.github.io/envoy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://lyft.github.io/envoy/&lt;/a&gt;、&lt;a href=&#34;https://linkerd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;linkerd&lt;/a&gt; 、&lt;a href=&#34;https://traefik.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;traefik&lt;/a&gt; ）。我在过去比较过&lt;a href=&#34;http://www.ofbizian.com/2016/12/spring-cloud-compared-kubernetes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 和 Spring Cloud&lt;/a&gt;（请注意，不是的 Cloud Foundry） 。&lt;/p&gt;
&lt;h3 id=&#34;aws-ecs-和-docker-swarm&#34;&gt;AWS ECS 和 Docker Swarm&lt;/h3&gt;
&lt;p&gt;在 Docker 公司仍然需要&lt;a href=&#34;https://thenewstack.io/focused-enterprise-docker-doesnt-fear-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;搞清楚&lt;/a&gt;它是要开发什么，卖什么，亚马逊创造了使用 Docker 技术作为一部分一个非常坚实的产品 &lt;a href=&#34;https://aws.amazon.com/ecs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ECS&lt;/a&gt; 。带有&lt;a href=&#34;https://blox.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Blox 的&lt;/a&gt; ECS（AWS 的开源容器编排软件）本身可能不是什么大事，但当与所有其他 AWS 产品结合使用时，它是一个功能非常强大的集成平台。&lt;/p&gt;
&lt;p&gt;更不用说从虚拟机时代起成为 AWS 支持者的&lt;a href=&#34;https://medium.com/netflix-techblog/the-evolution-of-container-usage-at-netflix-3abfc096781b&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix 正在向容器领域过渡&lt;/a&gt; ，并正在推动 Amazon ECS 的创新。&lt;/p&gt;
&lt;h3 id=&#34;cncf-和-kubernetes&#34;&gt;CNCF 和 Kubernetes&lt;/h3&gt;
&lt;p&gt;Kubernetes 是此类别中最新的平台之一，但同时也是有史以来最活跃，发展最快的开源项目之一。与整合的 &lt;a href=&#34;https://www.cncf.io/projects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生计算基金会项目&lt;/a&gt; 和支持&lt;a href=&#34;https://www.cncf.io/about/members/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公司相结合&lt;/a&gt; ，使整个生态系统成为这一类别中非常有力的竞争者。&lt;/p&gt;
&lt;p&gt;作为一个后来者（2014 年），Kuebernetes 的优势在于从一开始就以容器为中心的架构发展。而且它基于一个已有十年历史的 Google Borg，这意味着原则（不是实施）是成熟的，并在最高级别测试。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-container-orchestrator-调查结果&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Container Orchestrator 调查结果&#34; srcset=&#34;
               /blog/myth-cloud-native-portability/61411417ly1fwp5jrxbatj20sg0gejry_hu_87fb76d8e33b61dc.webp 400w,
               /blog/myth-cloud-native-portability/61411417ly1fwp5jrxbatj20sg0gejry_hu_a8848b9585130bac.webp 760w,
               /blog/myth-cloud-native-portability/61411417ly1fwp5jrxbatj20sg0gejry_hu_a89dbb2cfc6cbf5a.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/myth-cloud-native-portability/61411417ly1fwp5jrxbatj20sg0gejry_hu_87fb76d8e33b61dc.webp&#34;
               width=&#34;760&#34;
               height=&#34;438&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Container Orchestrator 调查结果
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Sysdig 2017 年 Docker 使用报告中的容器编排&lt;/p&gt;
&lt;p&gt;正如您可以 从 Sysdig 最近的 &lt;a href=&#34;https://sysdig.com/blog/sysdig-docker-usage-report-2017/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;报告中&lt;/a&gt; 看到的结果，云原生用户似乎很欣赏这一切。&lt;/p&gt;
&lt;h3 id=&#34;选择哪一个&#34;&gt;选择哪一个？&lt;/h3&gt;
&lt;p&gt;也许您在想，只要您将应用程序打包到容器中，就可以轻松地跨不同的云原生平台移植。你错了。无论您是从 Mesos、Cloud Foundry、Kubernetes、Docker Swarm 还是 ECS 开始，您都必须投入大量资金来学习平台和支持工具，了解文化和工作方式，并与这个仍然快速变化的生态系统的技术和公司进行互动。&lt;/p&gt;
&lt;p&gt;本文的目的不是要比较这些生态系统，而是要显示它们之间的差异，并证明如果需要，它将需要大量的时间和金钱来输入，或转移到另一个生态系统。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-作为应用程序可移植层&#34;&gt;Kubernetes 作为应用程序可移植层&lt;/h2&gt;
&lt;p&gt;云原生态系统在技术、流程和文化方面非常独特。但它们之间也有一些整合。许多由一个平台推广的概念也在向其他平台传播。例如，部署单元（Pod in Kubernetes）的概念现在出现在 Mesos 中，它也作为任务组存在于 Amazon ECS 中。服务器端负载平衡（Kubernetes 中的服务）和带有策略的调度/放置（Kubernetes Scheduler）的概念也存在于 Docker Swarm、AWS ECS 等中。但这是它走多远，从一个生态系统过渡到另外，需要付出很多努力。&lt;/p&gt;
&lt;p&gt;那么如何避免与单一供应商锁定？一种方法是坚持使用 Kubernetes 并接受它作为云和服务提供商之间的可移植性层。Kubernetes 如此受欢迎的原因之一是它不是单一的公司玩具，而是由多家大型科技公司支持，如谷歌、红帽（现被 IBM 收购【译者注】）、Docker，Mesosphere、IBM、戴尔、思科等等。&lt;/p&gt;
&lt;p&gt;另一个原因是有许多云公司提供 Kubernetes 作为服务。如果您使用 Kubernetes，那么您可以通过第三方服务提供商以最小的努力在 Google 容器引擎，Microsoft Azure、IBM Bluemix 容器服务等云提供商之间移动您的应用程序，甚至可以在 AWS 上移动您的应用程序。这意味着 Kubernetes API 是云平台之间应用程序的可移植性层，而不仅仅是容器。一个容器本身就是云原生海洋中的一滴。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/myth-cloud-native-portability/006tSBxtly1fuwq6p5tm2j302d02sq2y_hu_b3c5fefec0a79a17.webp 400w,
               /blog/myth-cloud-native-portability/006tSBxtly1fuwq6p5tm2j302d02sq2y_hu_93005e34324f9bbc.webp 760w,
               /blog/myth-cloud-native-portability/006tSBxtly1fuwq6p5tm2j302d02sq2y_hu_4a30dfe67c49ae47.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/myth-cloud-native-portability/006tSBxtly1fuwq6p5tm2j302d02sq2y_hu_b3c5fefec0a79a17.webp&#34;
               width=&#34;85&#34;
               height=&#34;100&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bilgin Ibryam&lt;/strong&gt;  （@bibryam）是 Red Hat 的首席架构师、提交者和 ASF 成员。他是一名开源布道师，博客作者，《Camel Design Patterns》和《Kubernetes Patterns》书籍的作者。在他的日常工作中，Bilgin 喜欢指导编码和领导开发人员成功构建云原生解决方案。他目前的工作重点是应用程序集成、分布式系统、消息传递、微服务、devops 和一般的云原生挑战。你可以在  &lt;a href=&#34;https://twitter.com/bibryam&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Twitter&lt;/a&gt;、&lt;a href=&#34;https://uk.linkedin.com/in/bibryam&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkedin&lt;/a&gt;  或他的  &lt;a href=&#34;http://www.ofbizian.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt; 上找到他。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
