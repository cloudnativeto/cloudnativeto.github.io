<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>容器 | 云原生社区（中国）</title>
    <link>https://cloudnative.to/tag/%E5%AE%B9%E5%99%A8/</link>
      <atom:link href="https://cloudnative.to/tag/%E5%AE%B9%E5%99%A8/index.xml" rel="self" type="application/rss+xml" />
    <description>容器</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 19 Sep 2023 12:03:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>容器</title>
      <link>https://cloudnative.to/tag/%E5%AE%B9%E5%99%A8/</link>
    </image>
    
    <item>
      <title>如何在 Docker 容器中运行 GUI 应用程序</title>
      <link>https://cloudnative.to/blog/run-gui-applications-as-containers-with-x11docker/</link>
      <pubDate>Tue, 19 Sep 2023 12:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/run-gui-applications-as-containers-with-x11docker/</guid>
      <description>&lt;p&gt;摘要：本文介绍了如何在 Docker 容器中运行 GUI 应用程序。通过使用 x11docker 应用程序，可以轻松启动带有桌面环境的 GUI 容器，并提供了许多功能，如 GPU 硬件加速、声音、剪贴板共享等。文章还提供了安装 Docker 运行时引擎和 x11docker 的详细步骤，并演示了使用 VLC 媒体播放器在容器中运行 GUI 应用程序的示例。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文译自：&lt;a href=&#34;https://thenewstack.io/run-gui-applications-as-containers-with-x11docker/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://thenewstack.io/run-gui-applications-as-containers-with-x11docker/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为开发人员，您可能需要使用 GUI 容器进行工作。如果是这种情况，您会很快发现，传统的 Docker 运行时引擎并不支持运行 GUI 应用程序（除非它们是基于 Web 的类型）。当您想要开发容器化的 GUI 应用程序时，您该怎么办呢？&lt;/p&gt;
&lt;p&gt;幸运的是，有许多第三方应用程序可以在桌面上轻松启动 GUI 容器。正如您可能预期的那样，这需要一个桌面环境（否则，您将在更传统的基于服务器的设置上进行开发）。其中一个应用程序叫做 &lt;a href=&#34;https://github.com/mviereck/x11docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;x11docker&lt;/a&gt;。顾名思义，此应用程序与 Linux X 显示服务器配合使用（这意味着您需要一个 Linux 发行版才能使其正常工作）。&lt;/p&gt;
&lt;p&gt;x11docker 应用程序包括以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPU 硬件加速&lt;/li&gt;
&lt;li&gt;PulseAudio 或 ALSA 声音&lt;/li&gt;
&lt;li&gt;剪贴板共享&lt;/li&gt;
&lt;li&gt;打印机和摄像头访问&lt;/li&gt;
&lt;li&gt;持久的主目录&lt;/li&gt;
&lt;li&gt;Wayland 支持&lt;/li&gt;
&lt;li&gt;语言区域设置创建&lt;/li&gt;
&lt;li&gt;容器内的多个 init 系统和 DBus&lt;/li&gt;
&lt;li&gt;支持多个容器运行时和后端（包括 Podman）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;您可能会问：“X11 不安全吗？”是的，确实。幸运的是，x11docker 通过使用多个 X 服务器来避免 X 服务器泄漏。因此，您可以放心使用该工具，而不必担心会暴露自己、系统或容器给典型的 X11 服务器弱点。&lt;/p&gt;
&lt;p&gt;需要记住的一件事是，x11docker 创建了一个非特权容器用户。该用户的密码为 x11docker，并限制了容器的功能。因此，某些应用程序可能无法按预期方式运行。例如，当尝试从容器内运行 Tor 浏览器时，它无法访问 /dev/stdout，这意味着容器将无法运行。但并不是所有容器都是如此。我将用 VLC 媒体播放器进行演示，该播放器可以按预期运行。&lt;/p&gt;
&lt;p&gt;接下来，我将向您展示如何在运行中的基于 Ubuntu 的桌面操作系统实例上安装 x11docker。当然，首先您必须安装 Docker 运行时引擎。为此，我将向您展示两种不同的方法。&lt;/p&gt;
&lt;p&gt;准备好了吗？我们开始吧。&lt;/p&gt;
&lt;h2 id=&#34;所需的工具&#34;&gt;所需的工具&lt;/h2&gt;
&lt;p&gt;正如我已经提到的，您需要运行中的基于 Ubuntu 的 Linux 桌面发行版实例。您还需要一个具有 sudo 权限的用户。就这些。&lt;/p&gt;
&lt;h2 id=&#34;安装-docker&#34;&gt;安装 Docker&lt;/h2&gt;
&lt;p&gt;首先，我们将使用传统的方法安装 Docker 运行时引擎。首先要做的是使用以下命令将官方 Docker GPG 添加到系统中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -fsSL &amp;lt;https://download.docker.com/linux/ubuntu/gpg&amp;gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，我们必须添加 Docker 仓库，以便安装软件。使用以下命令完成此操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] &amp;lt;https://download.docker.com/linux/ubuntu&amp;gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;lsb_release -cs&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; stable&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo tee /etc/apt/sources.list.d/docker.list &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;gt&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; /dev/null
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;添加仓库后，我们将使用以下命令安装一些依赖项：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release -y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用以下命令更新 apt：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get update
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，我们可以使用以下命令安装 Docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install docker-ce docker-ce-cli containerd.io -y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了能够在不使用 &lt;em&gt;sudo&lt;/em&gt; 的情况下运行 Docker 命令（这可能存在安全风险），请使用以下命令将您的用户添加到 docker 用户组中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo usermod -aG docker &lt;span class=&#34;nv&#34;&gt;$USER&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注销并重新登录以使更改生效。&lt;/p&gt;
&lt;p&gt;如果您希望采用快速方式，可以使用以下命令安装 Docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install curl wget uidmap -y
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget -qO- https://get.docker.com/ &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要能够以无特权方式运行 Docker，请执行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;dockerd-rootless-setuptool.sh install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;如何安装-x11docker&#34;&gt;如何安装 x11docker&lt;/h2&gt;
&lt;p&gt;在安装 x11docker 之前，我们必须安装一些依赖项。可以使用以下命令完成此操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install xpra xserver-xephyr xinit xauth xclip x11-xserver-utils x11-utils -y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，使用以下命令安装 x11docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -fsSL https://raw.githubusercontent.com/mviereck/x11docker/master/x11docker &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo bash -s -- --update
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，您可以使用以下命令更新 x11docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo x11docker --update
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;如何使用-x11docker&#34;&gt;如何使用 x11docker&lt;/h2&gt;
&lt;p&gt;安装了 x11docker 之后，就可以开始测试了。让我们使用 VLC 应用程序容器进行测试。首先，使用以下命令拉取镜像：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker pull jess/vlc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;拉取镜像后，使用以下命令（借助 x11docker）运行 VLC：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x11docker --pulseaudio --share&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/Videos jess/vlc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您应该会看到 VLC 窗口打开，准备好供使用（图 1）。它的速度比直接安装在您的桌面上要慢一些，但除此之外，它应该按预期工作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/run-gui-applications-as-containers-with-x11docker/docker_hu5167449153449712213.webp 400w,
               /blog/run-gui-applications-as-containers-with-x11docker/docker_hu9169833344889354399.webp 760w,
               /blog/run-gui-applications-as-containers-with-x11docker/docker_hu4592457042509244309.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/run-gui-applications-as-containers-with-x11docker/docker_hu5167449153449712213.webp&#34;
               width=&#34;621&#34;
               height=&#34;486&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当然，如果您是开发人员，这对您帮助不大，因为您想要开发自己的容器。您可以始终创建要使用的映像，对其进行标记，将其推送到您选择的存储库，使用 docker pull 命令将其拉到开发系统上，然后使用 x11docker 部署容器。&lt;/p&gt;
&lt;p&gt;就是这样。现在，您可以通过 x11docker 在 Docker 容器中运行 GUI 应用程序了。借助自己的图像部署自己的定制容器，看看它的工作原理。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生社区 meetup 第 12 期成都站</title>
      <link>https://cloudnative.to/event/cloud-native-meetup-chengdu-12/</link>
      <pubDate>Sat, 19 Aug 2023 13:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/event/cloud-native-meetup-chengdu-12/</guid>
      <description>&lt;p&gt;&lt;strong&gt;嘉宾及讲师介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;张晓辉：&lt;/p&gt;
&lt;p&gt;CNCF ambassador，云原生社区管委会成员&lt;/p&gt;
&lt;p&gt;王青：&lt;/p&gt;
&lt;p&gt;JFrog 中国技术总监 十五年敏捷研发管理与软件工程实践经验，目前任 JFrog 中国技术团队负责人 阿里云 MVP&lt;/p&gt;
&lt;p&gt;叶天星：&lt;/p&gt;
&lt;p&gt;一个 Rust 初学者和 Rust 开源爱好者&lt;/p&gt;
&lt;p&gt;王璞：&lt;/p&gt;
&lt;p&gt;达坦科技（DatenLord）联合创始人。王璞博士拥有多年云计算领域的经验，擅长分布式计算、海量数据处理、大规模机器学习。&lt;/p&gt;
&lt;p&gt;王祖熙：&lt;/p&gt;
&lt;p&gt;铜锁项目核心成员之一，蚂蚁集团技术专家，专注于密码学、云原生、高性能和网络安全等领域的研发。&lt;/p&gt;
&lt;p&gt;彭柳：&lt;/p&gt;
&lt;p&gt;Flomesh 技术专家，资深网关研发。有多年的微服务和网关实践经验，主要工作涉及微服务、网关、容器、Kubernetes 等。&lt;/p&gt;
&lt;p&gt;详情见&lt;a href=&#34;https://mp.weixin.qq.com/s/hL290d2om3kDGajKMJQPFQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;活动回顾&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes 将推出新 sidecar container 特性</title>
      <link>https://cloudnative.to/blog/understanding-kubernetes-new-sidecar-container-feature/</link>
      <pubDate>Wed, 02 Aug 2023 11:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/understanding-kubernetes-new-sidecar-container-feature/</guid>
      <description>&lt;p&gt;上周，Kubernetes 项目&lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/116429&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;合并&lt;/a&gt;了一个新的 alpha 特性，使用户能够在规范中定义“sidecar containers”。这个新功能旨在帮助定义多容器 pod 中辅助容器的行为，这些容器可能有助于配置、网络、日志和度量收集等方面。&lt;/p&gt;
&lt;h2 id=&#34;什么是-sidecar-container&#34;&gt;什么是 sidecar container？&lt;/h2&gt;
&lt;p&gt;理论上，Kubernetes 期望您在每个 pod 中运行一个容器。实际上，&lt;a href=&#34;https://www.mirantis.com/blog/kubernetes-pod-vs-container-multi-container-pods-and-container-communication/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;许多用例需要多容器 pod&lt;/a&gt;——例如，当您使用某些服务网格时，几乎所有的 pod 中都可能有 sidecar。&lt;/p&gt;
&lt;p&gt;有时，辅助容器仅用于初始化：例如为主容器配置和管理 secret。Kubernetes 已经为用户提供了定义 initContainer 的方式一段时间了。这个新功能最终为 initContainer 提供了更精细的粒度，以反映 sidecar 的特定要求，简化常见用法模式并为未来开辟了一些有趣的设计空间。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-container-特性如何工作&#34;&gt;sidecar container 特性如何工作？&lt;/h2&gt;
&lt;p&gt;在这个新的功能门控中，sidecar containers 被定义为&amp;hellip;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 pod 中比其他容器更早地启动，因为它们可能需要先初始化。这对于像服务网格这样的事情很重要，其中您希望 sidecar 准备好为主容器进程建立网络连接，以及在日志记录方面，您希望收集器 sidecar 能够抓取主容器的启动日志。&lt;/li&gt;
&lt;li&gt;在 pod 的整个生命周期内保持运行，因为它们可能需要长期运行。例如，在网络和指标/日志记录的情况下，您需要 sidecar 运行的时间与主进程一样长。&lt;/li&gt;
&lt;li&gt;永远不会阻止 pod 被终止，因为它们仅支持 pod 的核心功能——如果没有新功能，运行的 sidecar 容器可以阻止作业完成，即使 pod 的核心任务已完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在较丑的一面上，在这个 alpha 实现中，您可以通过在您的 &lt;code&gt;initContainer&lt;/code&gt; 规范中添加值为 &lt;code&gt;Always&lt;/code&gt; 的 &lt;code&gt;restartPolicy&lt;/code&gt; 字段来定义 sidecar container。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myapp-pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;initContainers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;init-myservice&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;busybox:1.28&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;init-mydb&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;busybox:1.28&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-proxy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio/proxyv2:1.16.0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;proxy&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;sidecar&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;restartPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Always&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myapp-container&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;busybox:1.28&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上面的规范中，&lt;strong&gt;init-myservice&lt;/strong&gt; 和 &lt;strong&gt;init-mydb&lt;/strong&gt; 是标准 initContainers，而设置为 &lt;code&gt;Always&lt;/code&gt; 的 &lt;code&gt;restartPolicy&lt;/code&gt; 字段使 &lt;strong&gt;istio-proxy&lt;/strong&gt; 成为 sidecar container。&lt;/p&gt;
&lt;p&gt;这个新特性的 Kubernetes Enhancement Proposal (KEP) 承认了这种表面上的不优雅，指出 initContainer“不适合作为 sidecar containers，因为它们通常做的不仅是初始化”，并建议“基础设施容器”是一个更好的名称，未来可能会采用。KEP 解释了选择的结构背后的思考方式：&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;将 sidecar containers 定义在其他 init 容器之间是很重要的，以便能够表达容器的初始化顺序。&lt;/p&gt;
&lt;p&gt;一位高级贡献者在 Hacker News 上补充了一些细节，指出：&lt;/p&gt;
&lt;p&gt;分离属性的挑战在于它与我们可能添加到 pod 周围的有关排序和生命周期的新功能不兼容。如果我们使用一个简单的布尔值，最终我们将不得不让它与其他字段交互，并处理“sidecar”的含义和更灵活性之间的冲突行为。[&amp;hellip;]我们为 init containers 可以失败 pod、并且可以并行化、以及常规容器具有唯一的 restartPolicies 留出了空间。这两个都将允许更多的工作流/作业引擎控制，以分解单体容器并获得更好的隔离。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&#34;https://news.ycombinator.com/item?id=36666359&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;另一个评论&lt;/a&gt;中，他们补充说，团队想要&amp;hellip;&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;留下更复杂的 init containers 和 sidecars 的排序（常规容器没有 restart 顺序）。例如，您可能需要一个服务网格来需要一个 vault secret——这两个可能都是 sidecars，并且如果两者都关闭，您可能需要确保 vault sidecar 首先启动。最终，我们可能希望在启动顺序中添加并行性，而单独的字段将阻止简单的排序现在起作用。&lt;/p&gt;
&lt;p&gt;KEP 提供了有关引发该功能的问题案例以及一些组织正在运行 Kubernetes 分叉以实现类似功能的有趣更广泛的背景的详细见解。&lt;/p&gt;
&lt;p&gt;如果您迫不及待地想在新的测试集群上尝试这个新功能，您需要为 kubelet、kube-apiserver、kube-controller-manager 和 kube-scheduler 启用 SidecarContainers feature gate。KEP 提供了有关默认策略和实现的有用细节，您可以期待在 8 月份发布 Kubernetes 1.28 时看到更多关于此功能的讨论。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 OCI 容器运行 WebAssembly 工作负载</title>
      <link>https://cloudnative.to/blog/wasm-containers/</link>
      <pubDate>Mon, 03 Apr 2023 20:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/wasm-containers/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;译者注：本文介绍了如何使用 OCI 容器来运行 WebAssembly 工作负载。WebAssembly（也称为 Wasm）是一种可移植的二进制指令格式，具有可嵌入和隔离的执行环境，适用于客户端和服务器应用。WebAssembly 可以看作是一种小巧、快速、高效、安全的基于栈的虚拟机，设计用于执行不关心 CPU 或操作系统的可移植字节码。WebAssembly 最初是为 web 浏览器设计的，用来作为函数的轻量级、快速、安全、多语言的容器，但它不再局限于 web。在 web 上，WebAssembly 使用浏览器提供的现有 API。WebAssembly System Interface（WASI）是为了填补 WebAssembly 和浏览器外系统之间的空白而创建的。这使得非浏览器系统可以利用 WebAssembly 的可移植性，使 WASI 成为分发和隔离工作负载时的一个很好的选择。文章中介绍了如何配置容器运行时来从轻量级容器镜像中运行 Wasm 工作负载，并给出了一些使用示例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;WebAssembly（也称为 Wasm）以其可嵌入和隔离的执行环境而成为一种流行的便携式二进制指令格式，用于客户端和服务器应用程序。将 WebAssembly 视为一种小型、快速、高效且非常安全的基于堆栈的虚拟机，专门用于执行可移植的字节码，不在乎它运行在哪个 CPU 或操作系统上。WebAssembly 最初是为 Web 浏览器设计的，用于成为函数的轻量级、快速、安全和多语言容器，但它不再仅限于 Web。&lt;/p&gt;
&lt;p&gt;在 Web 上，WebAssembly 使用浏览器提供的现有 API。WebAssembly 系统接口（WASI）的创建填补了 WebAssembly 和运行在浏览器外部的系统之间的空白。这使非浏览器系统能够利用 WebAssembly 的可移植性，使 WASI 成为在分发时具有可移植性和在运行负载时具有隔离性的良好选择。&lt;/p&gt;
&lt;p&gt;WebAssembly 提供了几个优点。因为它是平台中立的，所以可以在多个操作系统和架构上同时编译和执行一个单一的二进制文件，具有非常低的磁盘占用和启动时间。有用的安全功能包括模块签名和可以在运行时级别上控制的安全调节器，而不是依赖于主机操作系统的用户权限。封闭式内存仍然可以由现有的容器工具基础架构进行管理。&lt;/p&gt;
&lt;p&gt;在本文中，我将通过一个配置容器运行时来运行轻量级容器镜像中的 Wasm 工作负载的方案来讲解。&lt;/p&gt;
&lt;h2 id=&#34;webassembly-在云基础设施上的采用和阻碍&#34;&gt;WebAssembly 在云基础设施上的采用和阻碍&lt;/h2&gt;
&lt;p&gt;WebAssembly 和 WASI 相当新，因此尚未设置在容器生态系统中本地运行 Wasm 工作负载的标准。本文仅介绍一种解决方案，但还有其他可行的方法。&lt;/p&gt;
&lt;p&gt;其中一些解决方案包括使用兼容 Wasm 的组件替换本机 Linux 容器运行时。例如，Krustlet v1.0.0-alpha1 允许用户引入 Kubernetes 节点，其中 Krustlet 用作标准 kubelet 的替代品。这种方法的局限性在于用户必须在 Linux 容器运行时和 Wasm 运行时之间进行选择。&lt;/p&gt;
&lt;p&gt;另一种解决方案是使用带有 Wasm 运行时的基本镜像，并手动调用编译后的二进制文件。但是，如果我们在低于容器运行时的一级别调用 Wasm 运行时，这种方法会使容器镜像膨胀，这不一定是必需的。&lt;/p&gt;
&lt;p&gt;我将描述如何通过创建一个混合设置来避免这种情况，其中现有的 Open Containers Initiative（OCI）运行时可以运行本地 Linux 容器和与 WASI 兼容的工作负载。&lt;/p&gt;
&lt;h2 id=&#34;在混合设置中使用-crun-运行-wasm-和-linux-容器&#34;&gt;在混合设置中使用 crun 运行 Wasm 和 Linux 容器&lt;/h2&gt;
&lt;p&gt;一些上述问题可以通过允许现有的 OCI 运行时在较低级别上调用 Linux 容器和 Wasm 容器来轻松解决。这避免了依赖容器镜像携带 Wasm 运行时或引入仅支持 Wasm 容器的基础架构新层的问题。&lt;/p&gt;
&lt;p&gt;可以处理此任务的一个容器运行时是 crun。&lt;/p&gt;
&lt;p&gt;Crun 快速，占用内存低，是一个完全符合 OCI 的容器运行时，可以用作现有容器运行时的替代品。Crun 最初是编写用于运行 Linux 容器的，但它还提供了能够在本地方式下在容器沙盒中运行任意扩展的处理程序。&lt;/p&gt;
&lt;p&gt;这是用 crun 替换现有运行时的一种非正式方式，仅用于展示 crun 是您现有 OCI 运行时的完整替代品。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ mv /path/to/exisiting-runtime /path/to/existing-runtime.backup
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cp /path/to/crun /path/to/existing-runtime
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中之一处理程序是 &lt;code&gt;crun-wasm-handler&lt;/code&gt;，它将特别配置的容器镜像（&lt;em&gt;Wasm 兼容镜像&lt;/em&gt;）委派给现有 Wasm 运行时的部分，以本地方式在 crun 沙盒内运行。这样，终端用户无需自己维护 Wasm 运行时。&lt;/p&gt;
&lt;p&gt;Crun 与 &lt;a href=&#34;https://wasmedge.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wasmedge&lt;/a&gt;、&lt;a href=&#34;https://wasmtime.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wasmtime&lt;/a&gt; 和 &lt;a href=&#34;https://wasmer.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wasmer&lt;/a&gt; 具有本地集成，以支持此功能。它在 crun 检测到配置的镜像是否包含任何 Wasm/WASI 工作负载时动态地调用这些运行时的部分，同时仍支持本地 Linux 容器。&lt;/p&gt;
&lt;p&gt;有关使用 Wasm/WASI 支持构建 crun 的详细信息，请参见 &lt;a href=&#34;https://github.com/containers/crun/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub 上的 crun 存储库&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;在-podman-和-kubernetes-上使用-buildah-构建和运行-wasm-镜像&#34;&gt;在 Podman 和 Kubernetes 上使用 Buildah 构建和运行 Wasm 镜像&lt;/h2&gt;
&lt;p&gt;用户可以在 Podman 和 Kubernetes 上使用 crun 作为 OCI 运行时来创建和运行平台无关的 Wasm 镜像。以下是教程：&lt;/p&gt;
&lt;h3 id=&#34;使用-buildah-创建-wasm-兼容镜像&#34;&gt;使用 Buildah 创建 Wasm 兼容镜像&lt;/h3&gt;
&lt;p&gt;Wasm/WASI 兼容镜像很特别。它们包含一个魔术注释，可帮助像 crun 这样的 OCI 运行时分类别它是 Linux 本机镜像还是带有 Wasm/WASI 工作负载的镜像。然后，如果需要，它可以调用处理程序。&lt;/p&gt;
&lt;p&gt;使用任何容器镜像构建工具都可以非常轻松地创建这些 Wasm 兼容镜像，但是对于本文，我将演示如何使用 &lt;a href=&#34;https://opensource.com/article/22/2/build-your-own-container-linux-buildah&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Buildah&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译您的 &lt;code&gt;.wasm&lt;/code&gt; 模块。&lt;/li&gt;
&lt;li&gt;使用您的 &lt;code&gt;.wasm&lt;/code&gt; 模块准备一个 Containerfile。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; scratch&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; hello.wasm /&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;CMD&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/hello.wasm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;使用 Buildah 使用注释 &lt;code&gt;module.wasm.image/variant=compat&lt;/code&gt; 构建 Wasm 镜像。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ buildah build --annotation &lt;span class=&#34;s2&#34;&gt;&amp;#34;module.wasm.image/variant=compat&amp;#34;&lt;/span&gt; -t mywasm-image
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;构建完镜像并且容器引擎已配置为使用 crun，crun 将自动完成工作并通过配置的 Wasm 处理程序运行提供的工作负载。&lt;/p&gt;
&lt;h3 id=&#34;在-podman-中运行-wasm-工作负载&#34;&gt;在 Podman 中运行 WASM 工作负载&lt;/h3&gt;
&lt;p&gt;Crun 是 Podman 的默认 OCI 运行时。Podman 包含旋钮和处理程序，可利用大多数 crun 功能，包括 crun Wasm 处理程序。构建 Wasm 兼容镜像后，它可以像任何其他容器镜像一样由 Podman 使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ podman run mywasm-image:latest
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Podman 使用 crun 的 Wasm 处理程序运行请求的 Wasm 兼容镜像 &lt;code&gt;mywasm-image:latest&lt;/code&gt;，并返回确认我们的工作负载已执行的输出。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ hello world from the webassembly module !!!!
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;kubernetes-支持和测试的容器运行时接口cri实现&#34;&gt;Kubernetes 支持和测试的容器运行时接口（CRI）实现&lt;/h3&gt;
&lt;p&gt;以下是配置两个流行的容器运行时的方法：&lt;/p&gt;
&lt;h3 id=&#34;cri-o&#34;&gt;CRI-O&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通过编辑 &lt;code&gt;/etc/crio/crio.conf&lt;/code&gt; 上的配置将 CRI-O 配置为使用 crun 而不是 runc。Red Hat OpenShift 文档包含有关 &lt;a href=&#34;https://docs.openshift.com/container-platform/3.11/crio/crio_runtime.html#configure-crio-use-crio-engine&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;配置 CRI-O&lt;/a&gt; 的更多详细信息。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;sudo systemctl restart crio&lt;/code&gt; 重新启动 CRI-O。&lt;/li&gt;
&lt;li&gt;CRI-O 自动将 pod 注释传播到容器规范。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;containerd&#34;&gt;Containerd&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Containerd 支持通过自定义配置定义在 &lt;code&gt;/etc/containerd/config.toml&lt;/code&gt; 中切换容器运行时。&lt;/li&gt;
&lt;li&gt;通过确保运行时二进制文件指向 crun，将 containerd 配置为使用 crun。有关详细信息，请参见 &lt;a href=&#34;https://github.com/containerd/containerd/blob/main/docs/cri/config.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;containerd 文档&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;通过设置 &lt;code&gt;pod_annotations = [&amp;quot;module.wasm.image/variant.*&amp;quot;]&lt;/code&gt; 在配置中允许列出 Wasm 注释，以便将它们传播到 OCI 规范。然后使用 &lt;code&gt;sudo systemctl start containerd&lt;/code&gt; 重新启动 containerd。&lt;/li&gt;
&lt;li&gt;现在，containerd 应该将 Wasm pod 注释传播到容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是与 CRI-O 和 containerd 兼容的 Kubernetes pod 规范示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;pod-with-wasm-workload&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;mynamespace&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;module.wasm.image/variant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;compat&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;wasm-container&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myrepo/mywasmimage:latest&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;已知问题和解决方法&#34;&gt;已知问题和解决方法&lt;/h2&gt;
&lt;p&gt;复杂的 Kubernetes 基础架构包含 pod，而且在许多情况下，这些 pod 还包括 sidecar。这意味着当部署包含 sidecar 并且 sidecar 容器不包含 Wasm 入口点（例如像 Linkerd、Gloo 和 Istio 这样的服务网格或 Envoy 这样的代理的基础架构设置）时，crun 的 Wasm 集成将无用。&lt;/p&gt;
&lt;p&gt;您可以通过添加两个智能注释来解决此问题，用于 Wasm 处理程序：&lt;code&gt;compat-smart&lt;/code&gt; 和 &lt;code&gt;wasm-smart&lt;/code&gt;。这些注释充当智能开关，仅在容器需要时切换 Wasm 运行时。因此，在运行带有 sidecar 的部署时，只有包含有效 Wasm 工作负载的容器才由 Wasm 处理程序执行。常规容器像往常一样被委派给本机 Linux 容器运行时。&lt;/p&gt;
&lt;p&gt;因此，在为这种用例构建镜像时，请使用注释 &lt;code&gt;module.wasm.image/variant=compat-smart&lt;/code&gt;，而不是 &lt;code&gt;module.wasm.image/variant=compat&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;您可以在 &lt;a href=&#34;https://github.com/containers/crun/blob/main/docs/wasm-wasi-on-kubernetes.md#known-issues&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub 上的 crun 文档&lt;/a&gt; 中找到其他已知问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2022 年容器生态系统的 9 大趋势洞察</title>
      <link>https://cloudnative.to/blog/container-insights-2022/</link>
      <pubDate>Mon, 07 Nov 2022 10:16:27 +0800</pubDate>
      <guid>https://cloudnative.to/blog/container-insights-2022/</guid>
      <description>&lt;p&gt;这项研究建立在 Datadog 以前版本的&lt;a href=&#34;https://www.datadoghq.com/container-report-2021/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;容器使用报告&lt;/a&gt;、&lt;a href=&#34;https://www.datadoghq.com/container-orchestration-2018/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;容器编排报告&lt;/a&gt;和&lt;a href=&#34;https://www.datadoghq.com/docker-adoption/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker 研究报告&lt;/a&gt;的基础上。最新更新于 2022 年 11 月。译自：&lt;a href=&#34;https://www.datadoghq.com/container-report/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.datadoghq.com/container-report/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现代工程团队继续扩展他们对容器的使用，如今基于容器的微服务应用程序无处不在。不断增长的容器使用正在推动组织采用互补技术来简化他们操作集群的方式，而这种不断扩展的容器环境给组织带来了安全挑战。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在本报告中，我们检查了数万 Datadog 客户&lt;/strong&gt;运行的超过&lt;strong&gt;15 亿个容器&lt;/strong&gt;，以了解容器生态系统的状态。继续阅读，了解从最新的实际使用数据中收集的更多见解和趋势。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“这项调查表明，容器和 Kubernetes 革命正在不断发展壮大。结果揭示了使用容器和 Kubernetes 的云原生组织不仅发展得更快，而且获得了更大的信心——在比以往任何时候都更关键的生产环境中构建和部署更大型的应用程序和工作负载。&lt;/p&gt;
&lt;p&gt;得益于云原生生态系统中超过 175,000 名贡献者所推动的创新，云原生组织已为前进的道路做好了准备。他们正在创造可以让各种规模的工程团队都可以构建和运行应用程序的技术，以满足当今应用程序的需求。”&lt;/p&gt;
&lt;p&gt;— Priyanka Sharma，云原生计算基金会执行董事&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;趋势-1kubernetes-继续成为最受欢迎的容器管理系统&#34;&gt;趋势 1：Kubernetes 继续成为最受欢迎的容器管理系统&lt;/h2&gt;
&lt;p&gt;Kubernetes 比以往任何时候都更受欢迎。如今，近一半的容器组织运行 Kubernetes 来在不断发展的生态系统中部署和管理容器。Amazon Elastic Kubernetes Services (Amazon EKS) Blueprints 和 Amazon EKS Anywhere 等工具以及其他托管 Kubernetes 服务使团队可以轻松地在云中和本地运行 Kubernetes 集群。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/container-insights-2022/008vxvgGgy1h7wbyje5nkj30ku0ce757_hu4078896352302961886.webp 400w,
               /blog/container-insights-2022/008vxvgGgy1h7wbyje5nkj30ku0ce757_hu10283414410459016190.webp 760w,
               /blog/container-insights-2022/008vxvgGgy1h7wbyje5nkj30ku0ce757_hu14418854862505600162.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/container-insights-2022/008vxvgGgy1h7wbyje5nkj30ku0ce757_hu4078896352302961886.webp&#34;
               width=&#34;750&#34;
               height=&#34;446&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“在 AWS，我们致力于为客户提供简化的 Kubernetes 体验，以便他们可以轻松管理和扩展集群，同时受益于完全托管的 AWS 服务的安全性和弹性。Amazon EKS Blueprints 和 Amazon EKS Anywhere 等新功能使客户能够更快、更轻松地跨 AWS 和本地环境配置和部署 Kubernetes 集群，因此他们可以在任何需要的地方获得相同、一致的 Amazon EKS 体验，以最好地支持他们的应用程序和最终用户。”&lt;/p&gt;
&lt;p&gt;— Barry Cooks，Amazon Web Services Kubernetes 副总裁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;趋势-2无服务器容器技术在所有主要公共云中继续流行&#34;&gt;趋势 2：无服务器容器技术在所有主要公共云中继续流行&lt;/h2&gt;
&lt;p&gt;所有主要云提供商（包括 AWS App Runner、AWS Fargate、Azure Container Apps、Azure Container Instances (ACI) 和 Google Cloud Run）对无服务器容器技术的使用率从 2020 年的 21% 增加到 2022 年的 36%（年初至今）。这与我们在之前的研究中看到的增长相呼应，其中包括 Amazon ECS 用户转向 AWS Fargate。&lt;/p&gt;
&lt;p&gt;客户将减少配置和管理底层基础设施的需求列为容器采用无服务器技术的主要原因之一。那些不使用无服务器技术的客户更喜欢从管理自己的基础架构中获得的控制力和灵活性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/container-insights-2022/008vxvgGgy1h7wc0jp6mjj30ku0cewff_hu820837707082465627.webp 400w,
               /blog/container-insights-2022/008vxvgGgy1h7wc0jp6mjj30ku0cewff_hu221623317289408729.webp 760w,
               /blog/container-insights-2022/008vxvgGgy1h7wc0jp6mjj30ku0cewff_hu15726130732652852007.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/container-insights-2022/008vxvgGgy1h7wc0jp6mjj30ku0cewff_hu820837707082465627.webp&#34;
               width=&#34;750&#34;
               height=&#34;446&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;趋势-3多个云提供商的使用随着组织规模的增加而增加&#34;&gt;趋势 3：多个云提供商的使用随着组织规模的增加而增加&lt;/h2&gt;
&lt;p&gt;我们的数据显示，超过 30% 的使用 1,000 台或更多主机的容器组织在多个云中工作，并且组织运行的容器越少，多云使用率最低。此外，我们发现多云组织平均拥有比单云组织更多的容器。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/container-insights-2022/008vxvgGgy1h7wc690cy0j30ku0ce750_hu2002788632623474832.webp 400w,
               /blog/container-insights-2022/008vxvgGgy1h7wc690cy0j30ku0ce750_hu10540423688120754754.webp 760w,
               /blog/container-insights-2022/008vxvgGgy1h7wc690cy0j30ku0ce750_hu10547135402856979507.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/container-insights-2022/008vxvgGgy1h7wc690cy0j30ku0ce750_hu2002788632623474832.webp&#34;
               width=&#34;750&#34;
               height=&#34;446&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;趋势-4kubernetes-ingress-使用率正在上升&#34;&gt;趋势 4：Kubernetes Ingress 使用率正在上升&lt;/h2&gt;
&lt;p&gt;为了大规模管理来自集群外部的请求，管理员经常使用 Ingress 来配置到集群中多个服务的路由。如今，超过 35% 的组织使用 Ingress，自 2020 年 8 月 Kubernetes 1.19 版本发布以来，Ingress 已经普遍可用。&lt;/p&gt;
&lt;p&gt;随着我们的客户操作更多的集群和 Pod，他们在路由和网络管理方面面临着越来越复杂的问题。许多 Kubernetes 的早期采用者使用云提供的负载均衡器将流量路由到他们的服务。但 Ingress 通常更具成本效益，并且自发布以来其采用率稳步提高。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gateway-api.sigs.k8s.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Gateway API&lt;/a&gt;（于 2022 年 7 月完成测试版）是容器网络管理发展的下一步。Gateway API 提供高级网络功能，包括使用自定义资源和使用 API 资源对组织角色建模的面向角色的设计。我们期待看到 Gateway API 是否会取代 Ingress，或者这两种技术是否并排使用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/container-insights-2022/008vxvgGgy1h7wc8i70cdj30ku0cemxs_hu13945575724311191908.webp 400w,
               /blog/container-insights-2022/008vxvgGgy1h7wc8i70cdj30ku0cemxs_hu5542078478041936092.webp 760w,
               /blog/container-insights-2022/008vxvgGgy1h7wc8i70cdj30ku0cemxs_hu16630714657264543880.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/container-insights-2022/008vxvgGgy1h7wc8i70cdj30ku0cemxs_hu13945575724311191908.webp&#34;
               width=&#34;750&#34;
               height=&#34;446&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;趋势-5服务网格仍处于早期阶段istio-主导使用&#34;&gt;趋势 5：服务网格仍处于早期阶段，Istio 主导使用&lt;/h2&gt;
&lt;p&gt;服务网格提供服务发现、负载均衡、超时和重试，并允许管理员管理集群的安全性并监控其性能。我们之前的研究说明了服务网格的早期采用，我们看到的初始模式基本上没有变化。在我们的客户中，我们主要看到 Istio 和 Linkerd，其中 Istio 的受欢迎程度是 Linkerd 的三倍多。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/container-insights-2022/008vxvgGgy1h7wc9fn7llj30ku0cewf3_hu18271699145528997490.webp 400w,
               /blog/container-insights-2022/008vxvgGgy1h7wc9fn7llj30ku0cewf3_hu11020369557059959021.webp 760w,
               /blog/container-insights-2022/008vxvgGgy1h7wc9fn7llj30ku0cewf3_hu11703549338582979776.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/container-insights-2022/008vxvgGgy1h7wc9fn7llj30ku0cewf3_hu18271699145528997490.webp&#34;
               width=&#34;750&#34;
               height=&#34;446&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“服务网格已经证明了为企业中的流量提供一致的安全性、可观测性和控制的价值。Istio 已明确将自己确立为领先的网格解决方案，我为社区为实现这一目标所做的工作感到自豪。最近完成的对 CNCF 的 Istio 捐赠将在这一成功的基础上发展壮大我们的社区。”&lt;/p&gt;
&lt;p&gt;——Louis Ryan，Istio 的联合创始人兼谷歌首席工程师&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;趋势-6大多数主机使用超过-18-个月的-kubernetes-版本&#34;&gt;趋势 6：大多数主机使用超过 18 个月的 Kubernetes 版本&lt;/h2&gt;
&lt;p&gt;Kubernetes 每年发布三个新版本，为用户提供新功能、安全改进和错误修复。我们在之前的研究中看到，用户通常更愿意等待一年多才能采用这些新版本。我们从轶事中了解到，一些客户延迟的原因是为了确保他们的集群的稳定性和与 API 版本的兼容性。如今，使用最多的版本是 v1.21，它于 2021 年 4 月发布，并于今年早些时候正式过了生命周期终结日。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/container-insights-2022/008vxvgGgy1h7wcb5u0w5j30ku0cemy5_hu7884426757635580643.webp 400w,
               /blog/container-insights-2022/008vxvgGgy1h7wcb5u0w5j30ku0cemy5_hu2554215774634145209.webp 760w,
               /blog/container-insights-2022/008vxvgGgy1h7wcb5u0w5j30ku0cemy5_hu5904689561653064235.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/container-insights-2022/008vxvgGgy1h7wcb5u0w5j30ku0cemy5_hu7884426757635580643.webp&#34;
               width=&#34;750&#34;
               height=&#34;446&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;趋势-7超过-30-的运行-containerd-的主机使用不受支持的版本&#34;&gt;趋势 7：超过 30% 的运行 containerd 的主机使用不受支持的版本&lt;/h2&gt;
&lt;p&gt;先前的研究表明 containerd 的使用有所增加，这是组织可以采用的符合 CRI 的运行时之一，因为 Dockershim 正在被弃用。我们发现只有大约 69% 的 containerd 主机使用的是 1.5 或 1.6 版本，这是积极支持的版本。值得注意的是，大约 31% 的 containerd 主机正在使用 1.4 或更早的版本，这些版本已经过了生命周期的终结日。&lt;/p&gt;
&lt;p&gt;运行较旧的软件版本会带来有关安全性和合规性的问题，并且在容器运行时的情况下，会带来容器逃逸等漏洞的风险。许多主机使用不受支持的容器运行时版本这一事实凸显了组织在运行适当的工具以维护容器安全性和合规性方面面临的挑战。无服务器容器技术降低了过时运行时的风险和手动更新的负担，这可能是我们看到所有云都转向无服务器容器的原因之一。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/container-insights-2022/008vxvgGgy1h7wcc9pjexj30ku0ce74y_hu5116801282910452367.webp 400w,
               /blog/container-insights-2022/008vxvgGgy1h7wcc9pjexj30ku0ce74y_hu15811047954641942892.webp 760w,
               /blog/container-insights-2022/008vxvgGgy1h7wcc9pjexj30ku0ce74y_hu16562159669739141616.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/container-insights-2022/008vxvgGgy1h7wcc9pjexj30ku0ce74y_hu5116801282910452367.webp&#34;
               width=&#34;750&#34;
               height=&#34;446&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;趋势-8访问管理正在改进但仍然是一个挑战&#34;&gt;趋势 8：访问管理正在改进，但仍然是一个挑战&lt;/h2&gt;
&lt;p&gt;Kubernetes 管理员使用基于角色的访问控制 (RBAC) 来允许主体（用户、组或服务账户）访问或修改集群中的资源。根据安全最佳实践，主体应该只有必要的权限，并且管理员在授予与升级风险相关的 RBAC 权限时必须谨慎。其中包括允许主体列出所有机密或创建工作负载、证书或令牌请求的权限，这些请求可以允许他们修改自己的权限。&lt;/p&gt;
&lt;p&gt;好消息是，随着组织部署更多集群，这些集群中使用过度宽松特权的百分比正在下降。我们怀疑随着组织采用权限审计等安全实践和自动化 RBAC 扫描仪等工具，这一数字正在下降。但是，我们发现大约 40% 的集群仍然使用宽松的权限，这会带来安全风险。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/container-insights-2022/008vxvgGgy1h7wcdev59yj30ku0cet9l_hu10514464501877942294.webp 400w,
               /blog/container-insights-2022/008vxvgGgy1h7wcdev59yj30ku0cet9l_hu4965472205818328633.webp 760w,
               /blog/container-insights-2022/008vxvgGgy1h7wcdev59yj30ku0cet9l_hu10220171299495715387.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/container-insights-2022/008vxvgGgy1h7wcdev59yj30ku0cet9l_hu10514464501877942294.webp&#34;
               width=&#34;750&#34;
               height=&#34;446&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;趋势-9nginxredis-和-postgres-再次成为最受欢迎的容器镜像&#34;&gt;趋势 9：NGINX、Redis 和 Postgres 再次成为最受欢迎的容器镜像&lt;/h2&gt;
&lt;p&gt;截至 2022 年 9 月，最流行的现成容器镜像是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NGINX：这又是最流行的容器镜像。NGINX 为近 50% 的使用容器的组织提供缓存、负载平衡和代理功能。&lt;/li&gt;
&lt;li&gt;Redis：组织可以在容器中部署 Redis，用作键值数据存储、缓存或消息代理。&lt;/li&gt;
&lt;li&gt;Postgres：这个关系数据库的使用比去年略有增长。&lt;/li&gt;
&lt;li&gt;Elasticsearch：这个高性能的文档存储和搜索引擎仍然是最流行的镜像之一。&lt;/li&gt;
&lt;li&gt;Kafka：组织可以通过在容器中部署 Kafka 轻松地将事件流功能添加到应用程序中。&lt;/li&gt;
&lt;li&gt;RabbitMQ：RabbitMQ 在基于微服务的应用程序中支持解耦架构。&lt;/li&gt;
&lt;li&gt;MongoDB：MongoDB 仍然是最流行的 NoSQL 数据库之一。&lt;/li&gt;
&lt;li&gt;MySQL：这个开源数据库的排名比以前低。但是 MySQL 的性能和可扩展性使其在最流行的容器镜像列表中持续占有一席之地。&lt;/li&gt;
&lt;li&gt;Calico：Calico 是一个网络提供商，让管理员可以管理其 Kubernetes 集群内网络的安全性。&lt;/li&gt;
&lt;li&gt;GitLab：为了帮助团队采用和维护 DevOps 实践，GitLab 提供了存储库管理、问题跟踪和 CI/CD 管道。&lt;/li&gt;
&lt;li&gt;Vault：团队可以使用 Vault 来简化机密管理并帮助维护安全的应用程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/container-insights-2022/008vxvgGgy1h7wcim7nrxj30ku0cedgh_hu7778555536475499852.webp 400w,
               /blog/container-insights-2022/008vxvgGgy1h7wcim7nrxj30ku0cedgh_hu5508975403228929622.webp 760w,
               /blog/container-insights-2022/008vxvgGgy1h7wcim7nrxj30ku0cedgh_hu1603001076238228144.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/container-insights-2022/008vxvgGgy1h7wcim7nrxj30ku0cedgh_hu7778555536475499852.webp&#34;
               width=&#34;750&#34;
               height=&#34;446&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 Kubernetes StatefulSets 中，我们发现 Redis、Postgres、Elasticsearch、RabbitMQ 和 Kafka 是最常部署的镜像。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/container-insights-2022/008vxvgGgy1h7wciyjri3j30ku0cet9d_hu12309459542534645837.webp 400w,
               /blog/container-insights-2022/008vxvgGgy1h7wciyjri3j30ku0cet9d_hu12086625783955694832.webp 760w,
               /blog/container-insights-2022/008vxvgGgy1h7wciyjri3j30ku0cet9d_hu6510006890745605242.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/container-insights-2022/008vxvgGgy1h7wciyjri3j30ku0cet9d_hu12309459542534645837.webp&#34;
               width=&#34;750&#34;
               height=&#34;446&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生社区 meetup 第九期广州站</title>
      <link>https://cloudnative.to/event/cloud-native-meetup-guangzhou-09/</link>
      <pubDate>Sun, 25 Sep 2022 13:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/event/cloud-native-meetup-guangzhou-09/</guid>
      <description>&lt;h3 id=&#34;云原生应用安全应该从哪几个方向切入&#34;&gt;云原生应用安全应该从哪几个方向切入？&lt;/h3&gt;
&lt;p&gt;讲师：马景贺&lt;/p&gt;
&lt;p&gt;个人介绍：&lt;/p&gt;
&lt;p&gt;极狐 (GitLab)DevOps 技术布道师，LFAPAC 开源布道师，CDF ambassador。关注在云原生和 DevSecOps 领域。&lt;/p&gt;
&lt;p&gt;议题大纲：&lt;/p&gt;
&lt;p&gt;云原生发展的过程中，安全不应该是成为被忽视的一环。云原生应用程序的安全防护体系建立应该是多方位的，要满足从静态到动态，从源码到上线，同时还要注意镜像以及部署文件的安全。需要将这些手段结合起来，与研发流程打通，构建安全研发闭环，从而保证云原生应用程序的安全。&lt;/p&gt;
&lt;p&gt;听众收益：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;镜像 &amp;amp; IaC 安全扫描&lt;/li&gt;
&lt;li&gt;源代码安全审计（防止泄漏）&lt;/li&gt;
&lt;li&gt;常规的安全检测手段（SAST、DAST、Fuzzing Testing 等）&lt;/li&gt;
&lt;li&gt;漏洞管理 &amp;amp; 安全的研发闭环构建&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;基于硬件卸载的云原生网关连接平衡实现&#34;&gt;基于硬件卸载的云原生网关连接平衡实现&lt;/h3&gt;
&lt;p&gt;讲师：戴翔&lt;/p&gt;
&lt;p&gt;个人介绍：&lt;/p&gt;
&lt;p&gt;Intel 云原生工程师，从事云原生行业多年，深耕开源，Dapr/Thanos/Golangci-lint Maintainer，目前专注于服务网格领域。GH: daixiang0&lt;/p&gt;
&lt;p&gt;议题大纲：&lt;/p&gt;
&lt;p&gt;Envoy 是为单一服务和应用程序设计的高性能 C++ 分布式代理，也是为大型微服务“服务网格”架构设计的通信总线和“通用数据平面”。基于对 NGINX、HAProxy、硬件负载均衡器和云负载均衡器等解决方案的学习，Envoy 与每个应用程序一起运行，并通过以与平台无关的方式提供通用功能来抽象网络。当基础设施中的所有服务流量都通过 Envoy 网格流动时，通过一致的可观察性来可视化问题区域、调整整体性能并在一个地方添加底层特性变得很容易。在本次演讲中，我们将介绍 Envoy 中的线程模型和连接平衡状态，展示使用 PCI 硬件来平衡每个线程的连接，以及它获得的出色性能。&lt;/p&gt;
&lt;p&gt;听众收益：&lt;/p&gt;
&lt;p&gt;了解当多个客户端连接产生大流量时，Envoy 会因为连接平衡性差而获得较大的尾部延迟。借助核心级别的负载均衡，Envoy 将减少尾部延迟，占用更少的资源来处理更多的请求，从而为用户提供降本增效的双重保障。这可以卸载到硬件负载平衡器，显示结合软件效率和硬件的方向。&lt;/p&gt;
&lt;h3 id=&#34;dapr-助力开发云原生应用&#34;&gt;Dapr 助力开发云原生应用&lt;/h3&gt;
&lt;p&gt;讲师：张善友&lt;/p&gt;
&lt;p&gt;个人介绍：&lt;/p&gt;
&lt;p&gt;从事.NET 技术开发二十余年，认证 CKAD 专家，曾在腾讯工作 12 年，2018 年创立深圳友浩达科技，专注于云原生方面的解决方案咨询。目前在深圳市友浩达科技担任首席架构师，被评为微软最有价值专家 MVP，华为云 MVP，腾讯云 TVP&lt;/p&gt;
&lt;p&gt;议题大纲：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;.NET 云原生案例&lt;/li&gt;
&lt;li&gt;Dapr 介绍&lt;/li&gt;
&lt;li&gt;Dapr 助力云原生应用开发
&lt;ol&gt;
&lt;li&gt;服务治理：服务调用、弹性、API 网关 和 服务网格&lt;/li&gt;
&lt;li&gt;发布订阅 改造实时服务&lt;/li&gt;
&lt;li&gt;可观测性 日志、分布式追踪、指标采集&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;听众收益：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;了解一种新型的多运行时架构以及开源项目 Dapr&lt;/li&gt;
&lt;li&gt;了解如何一套代码如何同时适配虚拟机和容器，适配不同的云环境&lt;/li&gt;
&lt;li&gt;深入 Dapr 在实际项目中的工程实践&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;容器云调度优化及实践&#34;&gt;容器云调度优化及实践&lt;/h3&gt;
&lt;p&gt;讲师：王琼&lt;/p&gt;
&lt;p&gt;个人介绍：&lt;/p&gt;
&lt;p&gt;目前就职于 YY 直播，担任高级 SRE 运维工程师，负责 YY 直播容器云。10 年的工作经验，6 年以上的容器相关平台经验，在云原生领域持续深耕，曾在多家公司主导并落地云原生技术和企业容器化改造，致力于打造稳定高效的容器云平台，目前负责 YY 直播容器云的迭代更新以及新技术落地&lt;/p&gt;
&lt;p&gt;议题大纲：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;YY 直播容器云介绍&lt;/li&gt;
&lt;li&gt;业务资源使用画像实现&lt;/li&gt;
&lt;li&gt;基于节点实际负载调度&lt;/li&gt;
&lt;li&gt;基于节点实际负载二次调度&lt;/li&gt;
&lt;li&gt;通过 virtual kubelet 实现集群峰值弹性能力&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;听众收益：&lt;/p&gt;
&lt;p&gt;大规模容器化落地遇到的问题及挑战如何应对突发流量，实现集群的峰值弹性能力如何引进云原生技术，并在生产环境中落地及整合&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
