<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>微服务 | 云原生社区</title>
    <link>https://cloudnative.to/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
      <atom:link href="https://cloudnative.to/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1/index.xml" rel="self" type="application/rss+xml" />
    <description>微服务</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Fri, 18 Feb 2022 16:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>微服务</title>
      <link>https://cloudnative.to/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
    </image>
    
    <item>
      <title>避免在微服务上失败的 7 个关注点</title>
      <link>https://cloudnative.to/blog/7-ways-to-fail-at-microservices/</link>
      <pubDate>Fri, 18 Feb 2022 16:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/7-ways-to-fail-at-microservices/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://www.infoq.com/articles/microservices-seven-fail/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;7 Ways to Fail at Microservices&lt;/a&gt;，作者总结了她见过的导致微服务落地失败的一些情况，并提出了 7 个重要的关注点以引导大家来尽量避免。译者是在工作闲暇时间完成的翻译，其中难免有不当之处，请读者指正。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文主要观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务是一种手段，而不是目标&lt;/li&gt;
&lt;li&gt;分布式并不能保证解耦性&lt;/li&gt;
&lt;li&gt;合约测试（Contract Testing）是任何微服务架构的重要组成部分&lt;/li&gt;
&lt;li&gt;分解（Decomposition）需要发生在前端、后端和集成层，以及业务逻辑中&lt;/li&gt;
&lt;li&gt;如果企业没有能力快速、独立地发布微服务，那么微服务的许多好处就会丧失&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我（Holly Cummins）是 IBM 的一名 &lt;a href=&#34;https://www.linkedin.com/in/holly-k-cummins&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;技术顾问&lt;/a&gt;，我的一部分工作是帮助企业实现云原生。在去年 11 月的 QCon Plus 上，我介绍了 &lt;a href=&#34;https://plus.qconferences.com/plus2021/presentation/7-ways-fail-microservices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一些不正确的微服务使用方式&lt;/a&gt;。这些问题是基于我的经验来整理的，它们是我在客户现场反复看到的一些问题。&lt;/p&gt;
&lt;p&gt;我看到的第一个问题是，我们有时甚至不知道问题出在哪里。人们觉得我们应该做 &lt;a href=&#34;https://microservices.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务&lt;/a&gt;，但我们并没有真正花足够的时间来定义我们为什么要做微服务。&lt;/p&gt;
&lt;p&gt;我们要解决的是什么问题？现在是什么问题在困扰我们？我们做了微服务之后，什么会更好？这是一个很自然的本能问题，尤其是对于我们这些技术人员来说。我们想直接开始用微服务去解决问题，同时想玩一些这样新的酷炫的技术。尽管这些也非常重要，但更应该清楚我们要通过微服务去解决什么问题。&lt;/p&gt;
&lt;p&gt;容器技术使这种 “直接开始用微服务去解决问题” 的情况变得更糟：因为容器是一种近乎神奇的技术，这使得它本身就是一个伟大的解决方案 —— 它是如此轻巧，它是如此的便携，它使许多事情变得更好。于是我们最终决定：“因为我已经有了这些容器，如果只在一个容器中运行我的应用程序，那将是对容器能力的严重浪费。我应该在尽可能多的容器中运行它！” 不幸的是，“没有足够的容器（来发挥伟大的容器技术的能力）” 并不是一个合理（分辨为什么我们需要微服务）的问题陈述。&lt;/p&gt;
&lt;h2 id=&#34;简历驱动的开发&#34;&gt;简历驱动的开发&lt;/h2&gt;
&lt;p&gt;我看到的另一个问题是 &lt;a href=&#34;http://radar.oreilly.com/2014/10/resume-driven-development.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;简历驱动的开发&lt;/a&gt;。我们在看自己的简历时，有时会觉得在应该在 “微服务” 这部分写点什么。既然什么都不写肯定是不好的，所以我们会想：“我可以通过重新架构我公司的技术架构来让我的个人简历变得更漂亮啊”。 读到这里时你可能在想，“不会吧，这也太功利了吧。应该没有人真的会为了完善他们的个人简历来做公司的架构决策吧？” 然而事实证明 &amp;hellip;&amp;hellip; 确实是有人会这么做的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/cv-driven-development_hu04ec9156bbbc361046da74193f0f9a79_231757_944f809988c5ca933d12396273bdc08a.webp 400w,
               /blog/7-ways-to-fail-at-microservices/cv-driven-development_hu04ec9156bbbc361046da74193f0f9a79_231757_95768934380e869211301ec04acc20df.webp 760w,
               /blog/7-ways-to-fail-at-microservices/cv-driven-development_hu04ec9156bbbc361046da74193f0f9a79_231757_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/cv-driven-development_hu04ec9156bbbc361046da74193f0f9a79_231757_944f809988c5ca933d12396273bdc08a.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.redhat.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat&lt;/a&gt; 公司最近做了一项调查，调查了 &lt;a href=&#34;https://www.redhat.com/en/blog/red-hat-survey-reveals-career-progression-driving-developer-hunger-containers-and-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于容器的开发的主要驱动因素&lt;/a&gt;。职业发展是头号驱动力。职业发展是简历驱动发展的一种更好的说法。&lt;/p&gt;
&lt;p&gt;避免在简历上出现微服务部分的缺口是一件重要的事，因为目前微服务几乎是一种新的主流技术理念。即使我们此刻没有寻找新的工作，我们也不希望成为异类 —— 当我们环顾四周，似乎其 TA 人都在做微服务。于是一种很自然的想法是，如果 TA 们都在做微服务，那我为什么不去做做微服务呢？我把这称为 “微服务嫉妒”（Microservice Envy）。&lt;/p&gt;
&lt;h2 id=&#34;微服务不是目标&#34;&gt;微服务不是目标&lt;/h2&gt;
&lt;p&gt;“微服务嫉妒” 是一个问题，因为微服务并不是我们应该羡慕的那种东西。我们的一位技术顾问同事有一个讲法，如果一个客户一直在谈论 Netflix 的技术并要求使用微服务，他就知道这个合作可能有问题了。几乎可以肯定的是，他们转向微服务的原因并不正确。如果对话更深入一些，涵盖了耦合和聚合等内容，那么他就知道客户他们转向微服务的原因确实存在问题。&lt;/p&gt;
&lt;p&gt;微服务转型的出发点不应该是微服务本身。微服务是实现业务敏捷性或弹性或同等的更高层次目标的手段。实际上，微服务甚至不是唯一的手段；它只是一种手段而已。&lt;/p&gt;
&lt;h3 id=&#34;分布式单体&#34;&gt;分布式单体&lt;/h3&gt;
&lt;p&gt;重要的是要问：“你是有微服务，还是有一个分布在数百个 Git 仓库的单体？” 不幸的是，这就是我们经常看到的情况。一个分布式的单体是一个可怕的东西 —— 很难说它到底怎样，它比纯粹单体更容易出错。在传统的单体中，所有的东西都包含在一个单一的开发环境中，你可以得到一些好处，如编译时检查和 IDE 重构支持。因为你总是在一个进程中执行，你可以得到有保障的函数执行。你不必担心记住分布式计算的谬误和服务发现，以及处理你试图调用的东西已经停止存在的情况，事情是比较安全的。另一方面，如果我们去掉了单体的安全性，但保留了耦合性，我们最终会得到 “云原生意大利面条”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;术语 “意大利面条架构”（Spaghetti Architecture）可以被定义为一个信息技术问题，它阻碍了企业快速解码和转换其应用程序和数据以满足不断变化的需求的能力。“意大利面条架构” 是一个源自一盘意大利面条外观的比喻。每根意大利面条代表每个业务工具，它们被纠结成无限的复杂线。—— 摘自《 &lt;a href=&#34;https://data-sleek.com/what-is-spaghetti-architecture-and-how-to-avoid-it/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;什么是 “意大利面架构” 和如何避免它&lt;/a&gt; 》。&lt;/p&gt;
&lt;p&gt;【编者按】“意大利面条” 这个比喻似乎可以理解为：各个服务虽然看似分离了，但却各种层面上耦合、混合在一起，同时还容易断裂、崩坏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;分布式不等同于解耦&#34;&gt;分布式不等同于解耦&lt;/h2&gt;
&lt;p&gt;几年前，我被邀请到一个陷入困境的项目中去提供援助。当我进入项目时，团队对我说的第一件事就是 “每当我们改变一个微服务时，另一个服务就会出现故障”。如果你一直在关注微服务的优势，你就会知道，这与应该发生的事情完全相反。微服务应该是相互独立的，解耦的。然而，如果你把你的系统做成分布式，&lt;a href=&#34;https://en.wikipedia.org/wiki/Decoupling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;解耦&lt;/a&gt; 就变得不那么容易了（它是有代价的）。虽然 “分布式”（Distributed）和 “解耦”（Decoupled）都以 D 开头，但它们本身不是一回事。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu60fffb5b6fce695f6538e318918e5618_111831_5d2f718880989eab11493394c8f044ef.webp 400w,
               /blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu60fffb5b6fce695f6538e318918e5618_111831_a466c0df1aa3d37c07cfdae055b6b026.webp 760w,
               /blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu60fffb5b6fce695f6538e318918e5618_111831_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu60fffb5b6fce695f6538e318918e5618_111831_5d2f718880989eab11493394c8f044ef.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;拥有一个高度分布式的系统是很有可能既具有分布式所带来的所有痛苦，同时又仍然是完全纠缠和耦合的。上面提到的困境就是在这种情况下发生的事情。当我开始探索代码库的时候，我不断地在每个代码仓库中看到相同的代码。这个应用程序的对象模型是相当复杂的，有大约 20 个类，其中一些类有 70 个字段。这是一个非常复杂的结构体。&lt;/p&gt;
&lt;p&gt;微服务开发的原则之一是充分的 DRY（Don&amp;rsquo;t Repeat Yourself），避开公共库，因为它们是耦合的来源。在这种情况下，为了避免中央对象库的耦合，每个微服务在其代码中都有一个剪切和粘贴的对象模型副本。但如果领域结构体（Domain Schema）仍然是共享的，就仍然存在耦合。复制对象代码并不能消除耦合，它只是消除了编译时检查的可能性。如果一个字段名改变了，它仍然会破坏所有人，但这种破坏直到运行时才会发生。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hu3867d02eef6a23a3ed282a750ba0281d_165164_5004c5f4600d8b4f2d75c25ae453300d.webp 400w,
               /blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hu3867d02eef6a23a3ed282a750ba0281d_165164_6a73f9cc9c26346bd8e65e44a0d31d50.webp 760w,
               /blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hu3867d02eef6a23a3ed282a750ba0281d_165164_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hu3867d02eef6a23a3ed282a750ba0281d_165164_5004c5f4600d8b4f2d75c25ae453300d.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个悲伤的故事表明了领域驱动设计（Domain-Driven Design）原则在微服务中的重要性。我们要实现的理想情况是，每个微服务都能整齐地映射到一个领域。这样做的一个副作用，也是你做得对的一个标志，就是你的微服务的接口粒度很小。如果我们沿着技术边界而不是领域边界划分，我们最终会出现像我看到的情况；每个微服务都有一个巨大的、脆弱的接口。 其结果是一个支离破碎的 “意大利面条” 式的混乱状态。&lt;/p&gt;
&lt;h3 id=&#34;火星气候轨道飞行器&#34;&gt;火星气候轨道飞行器&lt;/h3&gt;
&lt;p&gt;虽然从技术上讲它是一个航天器，而不是一个微服务平台，但 &lt;a href=&#34;https://en.wikipedia.org/wiki/Mars_Climate_Orbiter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;火星气候轨道器&lt;/a&gt; 很好地展示了分布式和解耦之间的区别。NASA 在 1998 年发射了火星气候轨道器，其任务是研究火星气候。遗憾的是，轨道器没有成功绕过火星；相反，探测器坠入火星。NASA 的事后调查发现，问题源于两个不同的控制系统之间的关系，这两个系统由不同的团队建造。大多数时候，转向是由探测器本身的一个系统完成的。每隔几天，当轨道飞行器进入地球的视野时，佛罗里达州的监督控制系统就会发出航线修正。这大约是一个系统可以做到的分布式；它的一部分在太空中。但这两个系统之间的领域实际上是相似的：都在处理发动机推力的计算。 这两个团队在沟通中对界面的样子还不够清楚，所以他们最终使用了不同的单位。太空中的部分使用公制单位，地球上的部分使用英制单位，所以灾难发生了。我们可以肯定地说，在这种情况下，系统是非常分布式的，然而这种分布式并没有帮助。&lt;/p&gt;
&lt;h2 id=&#34;以消费者为导向的合约测试&#34;&gt;以消费者为导向的合约测试&lt;/h2&gt;
&lt;p&gt;这种微妙的沟通问题在有多个团队参与的时候经常发生。令人高兴的是，有一个很好的缓解措施：&lt;a href=&#34;https://pactflow.io/what-is-consumer-driven-contract-testing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;消费者驱动的合约测试&lt;/a&gt;。在 IDE 没有帮助我们进行类型检查的系统中，我们需要测试我们的集成，但我们希望尽量减少全面的集成测试。集成测试很重，运行成本很高，而且本身就是耦合的。 如果我们已经投资开发了微服务，我们不想在测试时倒退并制造一个大的集成单体。那么，我们如何让自己得到信心，让我们确信我们正在建立一个真正有效的东西呢？&lt;/p&gt;
&lt;p&gt;数据模拟（Mock）是一种常见的解决方案，但数据模拟本身也有一个问题。为了建立数据模拟，生产团队和消费团队在开发之初就会就接口的情况进行对话。他们达成了一个协议，然后消费团队就去尝试写一个数据模拟，这个模拟看起来就像他们对生产团队所说的代码的理解。在理想的情况下，他们会做得很好。问题是，消费团队经常会把自己的假设也写进了模拟中，而他们也许不是知道其他代码是什么样子的，是否是合适这部分模拟的，毕竟不是消费团队编写的代码。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/problems-with-mocks_huf163ee0ef011541e6b6c3517dbf9c753_117220_bce9d904e2f51d87c846ee9c9ec58f74.webp 400w,
               /blog/7-ways-to-fail-at-microservices/problems-with-mocks_huf163ee0ef011541e6b6c3517dbf9c753_117220_a2ca2f713cb4564a4a1cebe692edfb88.webp 760w,
               /blog/7-ways-to-fail-at-microservices/problems-with-mocks_huf163ee0ef011541e6b6c3517dbf9c753_117220_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/problems-with-mocks_huf163ee0ef011541e6b6c3517dbf9c753_117220_bce9d904e2f51d87c846ee9c9ec58f74.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在顺利的情况下，他们得到了正确的结果。单元测试全部通过，而且在集成阶段也继续通过，一切都很好。不幸的是，这并不总是发生。有时，实际的实现与消费团队所理解的不同，要么是因为生产团队改变了他们的想法，要么是因为某个地方的人做了一个不正确的假设。在这种情况下，测试仍然会通过。然而，当我们真正整合真实的服务时，它就会失败。问题是，模拟的行为没有经过真实服务的验证。生产团队很可能甚至从未见过已经创建的模拟。&lt;/p&gt;
&lt;p&gt;一个更好的选择是有一个消费者驱动的合约测试。合约测试的美妙之处，以及为什么它与模拟不同，是双方都与合约测试互动。对于消费者来说，合约测试就像一个方便的模拟。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/contract-testing_huc707e39dd7bb0b5a38d6b0cea5e63af0_119166_025b710982eacdc2e5c81fb1d4d91af1.webp 400w,
               /blog/7-ways-to-fail-at-microservices/contract-testing_huc707e39dd7bb0b5a38d6b0cea5e63af0_119166_fefab6ed93950c3e7ecfd00ad27710df.webp 760w,
               /blog/7-ways-to-fail-at-microservices/contract-testing_huc707e39dd7bb0b5a38d6b0cea5e63af0_119166_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/contract-testing_huc707e39dd7bb0b5a38d6b0cea5e63af0_119166_025b710982eacdc2e5c81fb1d4d91af1.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在另一方面，合约测试对于生产团队也是一个方便的功能测试。它是一个更深刻的验证，而不仅仅是像 &lt;a href=&#34;https://swagger.io/specification/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenAPI&lt;/a&gt; 的语法检查。合约测试实际上也会检查语义和行为，这节省了生产团队编写功能测试的时间。&lt;/p&gt;
&lt;p&gt;如果所有的东西都是兼容的并且工作的，所有的合约测试都会通过。这是一个快速的信心提升，因为它们运行起来成本很低、也很轻便。如果生产团队破坏了什么，他们的测试将失败，并提供早期警报，在破坏性变化逃逸到集成环境之前。如果 API 发生变化，新版本的合约就会被双方（或连接的中间人）提出。&lt;/p&gt;
&lt;p&gt;现在有几个不同的合约测试系统。如果你在 Spring 的生态系统中，&lt;a href=&#34;https://spring.io/projects/spring-cloud-contract&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud Contract&lt;/a&gt; 工作得非常好。如果你是一个多面手，那么我非常喜欢 &lt;a href=&#34;https://pact.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pact&lt;/a&gt;。它有几乎所有你可能使用的语言的绑定。&lt;/p&gt;
&lt;h2 id=&#34;企业的毛球&#34;&gt;企业的毛球&lt;/h2&gt;
&lt;p&gt;当然，即使我们理清了所有的测试，即使我们在业务逻辑层有一套漂亮的解耦微服务，也不能保证成功。在我们的系统中还会有许多其他的元素，这些元素可能是我们在制定真正干净的微服务架构时没有考虑到的。我们对业务逻辑的开发非常投入，而忘记了前台和后台，以及所有的胶水层。在企业架构中，胶水层是非常可能存在的，而且是粘性的。我们的一位架构师把这称为 “企业毛球”（Enterprise Hairball）。&lt;/p&gt;
&lt;p&gt;如果我们把所有的功能分解工作都集中在业务层，我们最终往往会得到一堆整齐的解耦的微服务，夹在一个单体的前端和一个单体的数据库层之间。在这些类型的系统中，变革将是一个挑战。然而，作为一个行业，我们正在更好地分解数据库，以便将其映射到各个微服务上，并且我们正在开发微前端。&lt;/p&gt;
&lt;p&gt;但我们还没有完成分解。如果系统不是很复杂，我们将有一个集成层。这可能是消息传递系统，也可能是一些其他的集成解决方案，将复杂的系统拉到一起。即使在架构的其他部分实现现代化架构之后，集成层往往仍然是单体的，不灵活的。团队本身可能处于重大的负荷之下 —— 正如我的同事所称呼的 “恐慌的三明治”。因为集成层是单体的，他们必须小心翼翼地安排所有的变化，这就阻碍了其他所有人。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hubfb74a0d87ffee7f1a9c8cbbcf269a69_367367_2e26cf95a21c9f138a96a951d9a282ba.webp 400w,
               /blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hubfb74a0d87ffee7f1a9c8cbbcf269a69_367367_6315d081516b3c3db774b384188901a5.webp 760w,
               /blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hubfb74a0d87ffee7f1a9c8cbbcf269a69_367367_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hubfb74a0d87ffee7f1a9c8cbbcf269a69_367367_2e26cf95a21c9f138a96a951d9a282ba.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这可能会带来很多挫折感，特别是对集成团队来说。在外界看来，他们似乎反应迟钝，速度缓慢，尽管他们正在努力工作。为了理清这种耦合，我们需要采用模块化的集成模式。&lt;/p&gt;
&lt;p&gt;如果我们不把集成层、数据库和前端层分割开来，会发生什么？几乎可以肯定的是，我们的微服务不会达到我们想要的效果。“毛球” 各部分之间的依赖关系将使任何部分都无法快速移动。业务层的微服务将不能独立部署，部署的速度将明显地不连续。&lt;/p&gt;
&lt;h3 id=&#34;阻碍发布的拖累&#34;&gt;阻碍发布的拖累&lt;/h3&gt;
&lt;p&gt;你们有多少人经历过这种情况？你非常努力地工作，你创造了一些惊人的东西；你知道用户会喜欢它，但它还没有到他们手中。价值被摆在台面上了，但你那令人惊奇的东西却不能被发布。即使你有一个微服务架构，你也会有一个发布看板。所有其它的微服务都需要同时发布，因为它们需要一起测试，这样做的成本太高，除非正好是大批量服务同时发布。即使填写发布清单也很昂贵。大家时常会害怕发布，因为可能在过去曾被低劣的发布所深深地伤害。发布检查表、发布委员会、单线程测试和其它发布方法都是为了减少那些已知的风险。 因为整个组织的发布期限是共同的，所以我们最终不得不争分夺秒地在最后期限前把功能塞进去。当然，这也使得发布的风险更大。某个人正在跟踪一个电子表格，上面有所有微服务之间的依赖关系，这些微服务的耦合度比它们应该的要高。然而，发布还是得按期执行。当我们选择微服务时，这并不是我们所希望发生的！所有这些用心良苦设计的流程都成为了拖累，阻碍了价值到达用户手中，而且往往实际上又增加了风险。&lt;/p&gt;
&lt;h2 id=&#34;测试自动化&#34;&gt;测试自动化&lt;/h2&gt;
&lt;p&gt;通常情况下，我们如此害怕发布的原因是在发布中涉及到大量的手工工作。特别是，真正能给我们带来信心的测试并不是自动化的，所以我们需要做大量的工作来弄清楚我们的应用程序是否能工作。当我访问一个客户，听到 “我们的测试没有自动化” 时，我听到的是 “我们不知道我们的代码目前是否工作，它可能工作。上次我们做人工 QA 的时候它是有效的；我们希望它仍然有效”。这是一个可悲的情况。&lt;/p&gt;
&lt;p&gt;如果你关心你们的测试，就把它自动化 —— 质量是你应该关心的东西。特别是如果架构已经偏向于 “意大利面条”，并且耦合性已经悄然出现，那么就很可能出现断裂。去 “意大利面条化” 是很困难的，所以我们要在一个快速反馈的地方，尽可能早地发现断裂。如果你要成为 “意大利面条”，至少要成为经过测试的 “意大利面条”。&lt;/p&gt;
&lt;h2 id=&#34;发布周期&#34;&gt;发布周期&lt;/h2&gt;
&lt;p&gt;手动测试只是发布过程中涉及的手动流程的一部分。 在受监管或以合规性为重点的行业，几乎总是有一堆人工合规性工作。合规性是我们非常关心的事情 —— 所以我们应该把它自动化。&lt;/p&gt;
&lt;p&gt;有了所有这些手工流程和所有这些造成减速的流程，这意味着即使我们正在上云，但我们没有实际得到上云的红利。我们在使用云，但它好像又不是云。讽刺的是，在云中，我们曾经做过的事情、曾经是一个好主意的东西、曾经让我们更安全的事情，实际上正在伤害我们。旧式的治理在云中是行不通的，它不能实现我们所希望的商业结果，而且它失去了很多上云应得的商业利益。&lt;/p&gt;
&lt;p&gt;通过观察发布周期，很容易发现一个企业是否实现了上云的目标。几年前，我的一位同事与一家大型的传统银行进行了一次销售会谈。他们的市场被金融科技公司和新兴的挑战者银行吃掉了，这个企业明白他们为什么会输 —— 他们无法快速地跟上。他们来找我们，解释说他们有大量的 COBOL 资产，而这正是拖累他们的原因（很可能确实如此）。然后他们补充说，他们显然需要摆脱所有的 COBOL 并转向微服务，因为其他人都在做微服务。然后他们又说，他们的发布委员会一年只开两次会。讲到这里的时候，我的同事感觉不妙。如果你的发布委员会每六个月才开一次会，你就知道你的发布节奏将是每六个月一次。你有多少个可独立部署的微服务并不重要，你不可能在这种情况下获得敏捷性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hue8c151f9e5d4b918c1062fc684d75753_209176_7b31b22c2518a5d4ef6b57153b63f3b6.webp 400w,
               /blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hue8c151f9e5d4b918c1062fc684d75753_209176_c6ed93655c918a3b71199e648a811550.webp 760w,
               /blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hue8c151f9e5d4b918c1062fc684d75753_209176_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hue8c151f9e5d4b918c1062fc684d75753_209176_7b31b22c2518a5d4ef6b57153b63f3b6.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这家银行需要的帮助并不是真正的技术帮助；他们需要改变他们对风险的思考方式，以及他们的运营方式，他们的发布计划需要进行彻底的改革，他们需要一大堆的自动化。缺乏持续交付的纪律性是阻碍他们获取敏捷的原因，而不是 COBOL。&lt;/p&gt;
&lt;p&gt;“我想进行分解” 是一个常见的客户要求，但分解有不止一个意思。当我们希望有一个分解的应用服务时，这并不能保证模块化 —— 有时它只是意味着乱七八糟的东西被分散得更广。如果有一些外部约束，比如发布看板和陈旧的工作流程，让我们总是被限制住，那在我们解决这些问题之前，我们如何分解都可能是徒劳无功的。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Holly Cummins&lt;/strong&gt; 是 IBM 企业战略部的创新领导者，并在 IBM Garage 担任顾问多年。作为 Garage 的一员，她为各行各业的客户提供技术驱动的创新，从银行业到餐饮业，从零售业到非政府组织。Holly 是 Oracle Java 冠军、IBM Q 大使和 JavaOne Rock Star。她与人合著了 Manning 的《Enterprise OSGi in Action》。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>微服务的未来——更多层抽象</title>
      <link>https://cloudnative.to/blog/the-future-of-microservices/</link>
      <pubDate>Fri, 13 Aug 2021 17:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/the-future-of-microservices/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://thenewstack.io/the-future-of-microservices-more-abstractions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Future of Microservices? More Abstractions&lt;/a&gt;，作者是 Container Solutions 的主编 Charles Humble。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://thenewstack.io/category/microservices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务&lt;/a&gt;是在 10 年前出现的，是软件融合进化的例子之一。虽然这个词可以归功于软件咨询公司 &lt;a href=&#34;https://www.thoughtworks.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Thoughtworks&lt;/a&gt; 的 &lt;a href=&#34;https://twitter.com/boicy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;James Lewis&lt;/a&gt; 和 Martin Fowler，&lt;a href=&#34;https://www.linkedin.com/in/adriancockcroft/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Adrian Cockcroft&lt;/a&gt; 也曾提出类似的想法。但当时在 Netflix 和许多硅谷的其他公司，如亚马逊、Google 和 eBay 等公司大致在相同的时间内独立搭建了或多或少相同的架构模式。&lt;/p&gt;
&lt;p&gt;在这个词诞生后的十年里，我们看到了 Kubernetes、服务网格和无服务器的兴起，我们也开始看到微服务被应用到了前端。除了可以横向扩展，微服务还可以让开发人员更快地部署代码，有利于组件的可替换性而不是可维护性。&lt;/p&gt;
&lt;p&gt;无论好坏，对许多人来说，微服务已经成为默认的架构选择。对于拥有自主团队和松散耦合系统的组织来说，微服务可以很好地工作，但它们带来了所有分布式系统都无法逃避的复杂性。&lt;/p&gt;
&lt;p&gt;“我坚决认为公共云比私有云和数据中心更好，这些好处是一目了然的。在许多情况下，是恐惧让人们畏缩不前。“独立技术顾问 &lt;a href=&#34;https://www.linkedin.com/in/samnewman/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sam Newman&lt;/a&gt; 告诉 The New Stack，他的 &lt;a href=&#34;https://samnewman.io/books/building_microservices_2nd_edition/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Building Microservices&lt;/a&gt; 一书的第二版将在今年 8 月出版。“但是对于微服务，事情将比这复杂得多的多。”&lt;/p&gt;
&lt;p&gt;考虑到这一点，在进入微服务时代的十年里，思考一下我们已经走到了哪一步，以及我们还需要解决哪些问题是很有意思的。&lt;/p&gt;
&lt;h2 id=&#34;盘点部署和运行时间&#34;&gt;盘点：部署和运行时间&lt;/h2&gt;
&lt;p&gt;现在有各种各样成熟的、设计良好的微服务框架，涵盖了大多数语言的基础知识，在 JVM 上有大量的选择，包括 &lt;a href=&#34;https://spring.io/projects/spring-boot&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Boot&lt;/a&gt;、&lt;a href=&#34;https://www.dropwizard.io/en/latest/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dropwizard&lt;/a&gt;、&lt;a href=&#34;https://helidon.io/#/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Helidon&lt;/a&gt;、&lt;a href=&#34;https://www.lagomframework.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lagom&lt;/a&gt;、&lt;a href=&#34;https://micronaut.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Micronaut&lt;/a&gt; 和 &lt;a href=&#34;https://quarkus.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quarkus&lt;/a&gt;，同时还有 &lt;a href=&#34;https://github.com/go-kit/kit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go kit&lt;/a&gt;（Go）、&lt;a href=&#34;https://flask.palletsprojects.com/en/2.0.x/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Flask&lt;/a&gt; 和 &lt;a href=&#34;https://falconframework.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Falcon&lt;/a&gt;（Python）、&lt;a href=&#34;https://nodejs.org/en/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Node.js&lt;/a&gt;（JavaScript）等选择。&lt;/p&gt;
&lt;p&gt;同样地，好的监控工具也比比皆是。&lt;a href=&#34;https://thenewstack.io/getting-started-with-opentelemetry-for-java/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt; 的出现尤其重要。它由 OpenTracing 和 OpenCensus 合并而成，拥有广泛的供应商和语言支持，为分布式遥测数据提供标准化。这意味着开发人员只需要对他们的代码进行一次检测，然后就可以交换和改变监控工具，比较相互竞争的解决方案，甚至在生产中为不同的需求运行多个不同的监控解决方案。&lt;/p&gt;
&lt;p&gt;然而，当我们看向部署和运行时，情况就变得有点模糊了。Kubernetes 已经或多或少地成为微服务的代名词，它的复杂性不断增加，促使云原生咨询公司 &lt;a href=&#34;https://www.container-solutions.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Container Solutions&lt;/a&gt; 的首席科学家 &lt;a href=&#34;https://twitter.com/adrianmouat&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Adrian Mouat&lt;/a&gt; &lt;a href=&#34;https://blog.container-solutions.com/10-predictions-for-the-future-of-computing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;猜测&lt;/a&gt;我们将看到它的竞争对手出现。&lt;/p&gt;
&lt;p&gt;“值得注意的是，这种复杂性不仅仅是隐藏在引擎盖下。“Mouat 说：“它正在溢出到界面上，影响到用户。“黑进 kubectl 运行并得到一个演示并运行仍然相当容易。但是，运行生产应用程序并弄清楚如何安全地暴露它们需要了解大量不同的功能，这不可避免地导致 YAML 文件比大多数微服务源代码还要长。”&lt;/p&gt;
&lt;p&gt;Newman 总结了一个基本挑战：“Kubernetes 对开发者并不友好。我们仍然没有一个好的、可靠的、类似 &lt;a href=&#34;https://www.heroku.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heroku&lt;/a&gt; 的抽象，在 Kubernetes 之上被广泛使用，这让我感到震惊。”&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.spotify.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spotify&lt;/a&gt; 的工程总监 &lt;a href=&#34;https://www.linkedin.com/in/pia-nilsson-02b47b1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pia Nilsson&lt;/a&gt; 曾 &lt;a href=&#34;https://engineering.atspotify.com/2021/05/18/a-product-story-the-lessons-of-backstage-and-spotifys-autonomous-culture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;谈到&lt;/a&gt;，这家快速扩张的公司的新工程师平均需要 60 天才能合并他们的第 10 个 pull request。作为回应，该公司建立了一个&lt;a href=&#34;https://thenewstack.io/design-a-better-kubernetes-experience-for-developers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开发者门户网站&lt;/a&gt; &lt;a href=&#34;https://engineering.atspotify.com/2020/09/24/cloud-native-computing-foundation-accepts-backstage-as-a-sandbox-project/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Backstage&lt;/a&gt;，现在是 &lt;a href=&#34;https://cncf.io/?utm_content=inline-mention&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生计算基金会&lt;/a&gt;的一个&lt;a href=&#34;https://backstage.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;沙盒项目&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://about.netflix.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix&lt;/a&gt; 非常重视 DevEx—— 该公司为开发者铺设的 “道路”—— 利用它来帮助 &lt;a href=&#34;https://www.infoq.com/presentations/devex-netflix-graphql/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;加速&lt;/a&gt; &lt;a href=&#34;https://graphql.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GraphQL&lt;/a&gt; 等新技术的 &lt;a href=&#34;https://www.infoq.com/presentations/devex-netflix-graphql/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;采用&lt;/a&gt;。同样，我们已经看到了内部建设和通过 &lt;a href=&#34;https://humanitec.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Humanitec&lt;/a&gt; 等供应商建设的 &lt;a href=&#34;https://info.container-solutions.com/the-rise-of-the-internal-developer-platform&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开发者平台&lt;/a&gt;的崛起。 &lt;a href=&#34;https://www.getambassador.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambassador Labs&lt;/a&gt; 有一个相关的 &lt;a href=&#34;https://www.getambassador.io/developer-control-plane/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开发者控制平面&lt;/a&gt;的概念 —— 它的网站声称，“使开发者能够控制和配置整个云开发循环，以便更快地发布软件”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Kubernetes 对开发者并不友好。我们仍然没有一个好的、可靠的、类似 &lt;a href=&#34;https://www.heroku.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heroku&lt;/a&gt; 的抽象，在 Kubernetes 之上被广泛使用，这让我感到震惊。” ——Sam Newman， Building Microservices 作者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ambassador Labs 的开发者关系总监 &lt;a href=&#34;https://www.linkedin.com/in/danielbryantuk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Daniel Bryant&lt;/a&gt; 告诉 The New Stack：“如果你看看 &lt;a href=&#34;https://www.airbnb.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Airbnb&lt;/a&gt;、&lt;a href=&#34;https://www.shopify.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Shopify&lt;/a&gt; 和 &lt;a href=&#34;https://tech.lunar.app/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lunar&lt;/a&gt; 等公司正在做什么，它们之间有一个明显的共同点。他们正在为他们的开发者创建一个类似于 Heroku 的 CLI，这样，像’创建新的微服务’这样的命令就会产生一些支架，插入 CI，插入管道，插入可观察性。问题是，你向开发者展示的抽象是什么，以便他们获得所需的可见性，同时也使他们所需的要求变得清晰？”&lt;/p&gt;
&lt;p&gt;Bryant 特继续说：“开发者需要指定某些操作特性：这是一个内存大的服务；这个服务需要低延迟；这个服务需要非常接近那个服务。目前，你通过启动 Kubernetes 和编写大量的 YAML 来做到这一点。那里的抽象并不完全正确，特别是当你引入其他部署机制时，如&lt;a href=&#34;https://thenewstack.io/category/serverless/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;无服务器&lt;/a&gt;和&lt;a href=&#34;https://thenewstack.io/how-low-code-can-help-enterprise-software-development/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;低代码 / 无代码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;“我想知道谁能通过平台暴露出正确的抽象概念，然后让工程师决定如何打包他们的代码 —— 但他们打包的方式是一样的，而平台暴露出一些传统上属于运维的属性。”&lt;/p&gt;
&lt;h2 id=&#34;开放应用模型oam&#34;&gt;开放应用模型（OAM）&lt;/h2&gt;
&lt;p&gt;其他几个关于 Kubernetes 的倡议也值得跟踪。由&lt;a href=&#34;https://thenewstack.io/open-application-model-build-the-next-generation-of-cloud-native-applications/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微软和阿里云&lt;/a&gt;联合创建的&lt;a href=&#34;https://oam.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开放应用模型&lt;/a&gt;（OAM）是一个描述应用的规范，将应用定义与集群的操作细节分开。因此，它使应用程序开发人员能够专注于其应用程序的关键要素，而不是其部署地点的操作细节。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://crossplane.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Crossplane&lt;/a&gt; 是 &lt;a href=&#34;https://thenewstack.io/oam-the-kubernetes-application-model-bridging-development-and-deployment/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM&lt;/a&gt; 的 Kubernetes 特定实现。它可以被企业用来在各种基础设施和云供应商之间建立和运维一个内部平台即服务（PaaS），这使得它在多云环境中特别有用，比如在那些兼并和收购越来越常见的大型企业中。&lt;/p&gt;
&lt;p&gt;虽然 OAM 试图将部署细节的责任从编写服务代码中分离出来，但服务网格旨在通过一个专门的基础设施层将服务间通信的责任从个人开发者那里转移出来，该层侧重于使用代理管理服务间的通信。不幸的是，它们也有复杂性的问题，而且还可能引入相当大的性能开销。&lt;/p&gt;
&lt;p&gt;因此，到目前为止，许多在生产中成功实施服务网格的案例都是在那些非常精通技术的初创公司。在 &lt;a href=&#34;https://www.infoq.com/podcasts/monolith-microservices/?&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2020 年与 InfoQ 的 Wes Reisz 的播客中&lt;/a&gt;，Newman 建议在选择之前等待 6 个月，他告诉 The New Stack，他仍然给出同样的建议。&lt;/p&gt;
&lt;p&gt;“就该技术栈的权重、管理、影响以及性能带来的影响而言，它们的现实情况是非常可怕的，“Newman 说。“对有一些组织说，如果没有它们，有些事情是不可能完成的，&lt;a href=&#34;https://monzo.com/blog/2019/04/03/deploying-envoy-proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Monzo 就是一个很好的例子&lt;/a&gt; —— 在一个组织中，你有一个异构的技术栈，你需要做大规模的双向 TLS，我可以看到它的价值。但在我看来，它仍然是 “概念很好，执行不力”。我想，我们可能会在很长时间内仍这样说。”&lt;/p&gt;
&lt;h2 id=&#34;隐藏服务网格&#34;&gt;隐藏服务网格&lt;/h2&gt;
&lt;p&gt;有一件事可能会发生，至少对企业客户来说，性能问题往往不是那么尖锐，那就是服务网格被推到平台的更深处，并在很大程度上对开发者隐藏。例如，&lt;a href=&#34;https://www.openshift.com/try?utm_content=inline-mention&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;红帽 OpenShift&lt;/a&gt; &lt;a href=&#34;https://www.openshift.com/blog/istio-on-openshift-in-2020&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;将 Istio 整合到平台层&lt;/a&gt;，还有多个类似的计划，将服务网格与公有云平台更紧密地整合在一起，如 &lt;a href=&#34;https://aws.amazon.com/app-mesh/?aws-app-mesh-blogs.sort-by=item.additionalFields.createdDate&amp;amp;aws-app-mesh-blogs.sort-order=desc&amp;amp;whats-new-cards.sort-by=item.additionalFields.postDateTime&amp;amp;whats-new-cards.sort-order=desc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS App Mesh&lt;/a&gt; 和 &lt;a href=&#34;https://cloud.google.com/traffic-director&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Platform Traffic Director&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关于服务网格的工作还在继续，以减少其所带来的网络开销。&lt;a href=&#34;https://cilium.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium&lt;/a&gt; 团队的工作很有希望，它利用 Linux 内核中的 &lt;a href=&#34;https://ebpf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 功能来实现它所说的 “非常有效的网络、策略执行和负载均衡功能”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我认为现在我们需要为其他人提供领域驱动设计（DDD）。因为即使是普通的开发者而不是架构师，也需要对如何确定实体的范围和边界有一定的了解，这其中有很多是回到了良好的 API 设计上。——Daniel Bryant，开发者关系总监，Ambassador Labs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但另一种可能性是，我们可能完全转向不同的运行时。&lt;a href=&#34;https://leadingedgeforum.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Leading Edge Forum&lt;/a&gt; 的顾问 &lt;a href=&#34;https://www.linkedin.com/in/simonwardley/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Simon Wardley&lt;/a&gt; &lt;a href=&#34;https://acloudguru.com/blog/engineering/simon-wardley-is-a-big-fan-of-containers-despite-what-you-might-think&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;认为&lt;/a&gt;，函数即服务（Faas）/ 无服务器将最终取代 Kubernetes，成为分布式应用事实上的标准运行时，我们也看到了一些真实的生产实例，比如 &lt;a href=&#34;https://www.bbc.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BBC&lt;/a&gt;，它的大部分在线架构已经从之前的 LAMP 堆栈 &lt;a href=&#34;https://www.infoq.com/podcasts/bbc-aws-lambda-react-cicd/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;直接转向了 AWS 上的 Lambda&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;“我认为 FaaS 是一个管理部署的伟大抽象，“Newman 说。“作为一个对开发者友好的部署软件的抽象，它是自 Heroku 以来我们拥有的最好的东西。我确实认为目前的实现方式很差，但他们会改进。但他们只处理了在一次在一个地方执行一件任务。这并没有解决更大的网络系统的抽象问题”。&lt;/p&gt;
&lt;p&gt;作为一个例子，Newman 引用了&lt;a href=&#34;https://azure.microsoft.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微软 Azure&lt;/a&gt; 的 &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview?tabs=csharp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Durable Functions&lt;/a&gt;，它通过响应式扩展提供了类似于连续性的东西，允许开发者在无服务器环境中建立有状态的工作流和函数。但是，虽然部署抽象可能会有所改善，但如果想象你可以完全抽象出编写分布式系统的复杂性，那就太天真了。&lt;/p&gt;
&lt;p&gt;“你不能假设你说的东西就在那里，“Newman 说。“你不能假设数据会神奇地从一个时间点瞬时传送到另一个时间点。因为它不是这样的。而且，再多的抽象也无法解决这个基本问题。”&lt;/p&gt;
&lt;h2 id=&#34;自主团队的架构&#34;&gt;自主团队的架构&lt;/h2&gt;
&lt;p&gt;另一个仍然具有挑战性的领域与整个系统架构有关，以及围绕团队组织和结构的相关问题。正如 &lt;a href=&#34;https://www.ibm.com/cloud?utm_content=logo-sponsorpage&amp;amp;utm_source=thenewstack&amp;amp;utm_medium=website&amp;amp;utm_campaign=platform&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM&lt;/a&gt; 的全球开发者 leader &lt;a href=&#34;https://www.linkedin.com/in/holly-k-cummins&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Holly Cummins&lt;/a&gt; 在 &lt;a href=&#34;https://cloudnative.to/cloud-native-culture-not-container/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生是关于文化而不是容器&lt;/a&gt; 一文中指出的，“即使有适当的自主团队，系统级的考虑也不会消失”。&lt;/p&gt;
&lt;p&gt;Eric Evans 的《&lt;a href=&#34;https://www.amazon.com/gp/product/0321125215/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321125215&amp;amp;linkCode=as2&amp;amp;tag=martinfowlerc-20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;领域驱动设计》&lt;/a&gt;是微服务运动的基石，任何软件架构师都应该阅读，Bryant 说。但他更进一步说：&lt;/p&gt;
&lt;p&gt;“我认为现在我们需要为我们其他人提供 DDD，“他告诉 The New Stack。“因为即使是普通的开发者而不是架构师，也需要对如何确定实体和边界的范围有一定的了解，其中很多都要回到良好的 API 设计。一旦你理解了耦合和内聚的重要性，关注点和边界的分离，无论你处理的是什么抽象（模块、类、服务、应用），你都会自然而然地跳到这个齿轮上。”&lt;/p&gt;
&lt;p&gt;Newman 的 Building Microservices 一书的第二版即将推出，该书介绍了很多这些概念，并考虑到了下一代服务。&lt;/p&gt;
&lt;p&gt;在更新这本书时，Newman 告诉 The New Stack，“我想多谈一点耦合性。我想多谈一点内聚力。我想更多地谈论信息隐藏，这对我来说是现在最重要的事情。&lt;/p&gt;
&lt;p&gt;“我认为，即使人们掌握了分布式系统方面的知识，他们也没有掌握一个事实，即从根本上说，微服务只是模块化架构的一种形式。然而，很多创建微服务的人对什么是模块化架构或如何进行模块化毫无概念。”&lt;/p&gt;
&lt;p&gt;Newman 在新书中还引入了自 2014 年第一版出版以来出现的一些组织思维的变化。他特别引用了马修・斯凯尔顿（Matthew Skelton）和曼努埃尔・派斯（Manuel Pais）关于如何组织业务和技术团队以实现快速流动的极具影响力的作品&lt;a href=&#34;https://teamtopologies.com/book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《团队拓扑（Team Topologies）》&lt;/a&gt;，以及尼科尔・福斯格伦（Nicole Forsgren）、杰兹・汉伯（Jez Humble）和吉恩・金（Gene Kim）的&lt;a href=&#34;https://itrevolution.com/accelerate-book/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《加速（Accelerate）》&lt;/a&gt;一书，该书探讨了精益管理和 DevOps 原则背后的科学。&lt;/p&gt;
&lt;p&gt;修订过程不仅揭示了有多少关于微服务的新知识可以分享，而且这些知识是如何不断积累的。&lt;/p&gt;
&lt;p&gt;“这本书可以让你广泛了解什么是微服务以及它对软件开发的影响，“Newman 说。“我发现我在向人们推荐，哦，你应该读那本书的第四章。现在我会说这个，而不是那个。我不想在推荐自己的书上一直含糊其辞。这就是为什么我写了第二版：因为我希望它是好的、准确的。”&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>导致云原生微服务系统开发灾难性的8件事</title>
      <link>https://cloudnative.to/blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/</link>
      <pubDate>Mon, 22 Apr 2019 13:54:05 +0800</pubDate>
      <guid>https://cloudnative.to/blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/</guid>
      <description>&lt;p&gt;原文地址：&lt;a href=&#34;http://wei-meilin.blogspot.com/2019/03/my2cents-eight-things-leads-to.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://wei-meilin.blogspot.com/2019/03/my2cents-eight-things-leads-to.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编者按&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者以较为嘲讽的口吻列举了在开发云原生微服务系统时可能出现的8个错误，告诫开发人员要注意避免这些问题。其观点集中在业务划分、解耦合、重复代码和过度的API交互等方面。作者以自嘲的方式把这些想法用&amp;quot;我的两分钱&amp;quot;比喻，译者意译为&amp;quot;随笔&amp;quot;以方便理解。&lt;/p&gt;
&lt;p&gt;大部分标注“我的两分钱”的文章只是一些想法。你只需要快速愉快的阅读，不用太深入，但值得做笔记：）&lt;/p&gt;
&lt;h2 id=&#34;1-设置错误的领域边界&#34;&gt;1. 设置错误的领域边界&lt;/h2&gt;
&lt;p&gt;这是一种工作保障策略，它让参与项目的每个人在开发和测试中无休止地循环，而无法将服务投入生产环境！首先，一切都从简单开始，逐渐发现有越来越多的功能、业务逻辑被添加到微服务中，最后甚至不得不重新命名整个该死的东西。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;1&#34; srcset=&#34;
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g23ajtc2kej305k057glt_hu6a7aa96e4da0f461a9e3df293f19e869_6747_ee9b4b79bcdc3754a2564f17d9b668a3.webp 400w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g23ajtc2kej305k057glt_hu6a7aa96e4da0f461a9e3df293f19e869_6747_1715bd96355e20726ef8a1d2e1d66708.webp 760w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g23ajtc2kej305k057glt_hu6a7aa96e4da0f461a9e3df293f19e869_6747_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g23ajtc2kej305k057glt_hu6a7aa96e4da0f461a9e3df293f19e869_6747_ee9b4b79bcdc3754a2564f17d9b668a3.webp&#34;
               width=&#34;200&#34;
               height=&#34;187&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      1
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;u&gt;临床症状和副作用&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不断增长的微服务变得过于臃肿，或者域中的每个微服务都调用你的服务。（有时核心微服务具有相同的行为，但你不应该在单个域中看到如此多的这类服务）。这违反了简单、可维护和敏捷的微服务原则。&lt;/li&gt;
&lt;li&gt;到处都是重复的微服务/代码。你可以找到一些重复的代码或微服务，它们被复制和部署到其他域中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;2&#34; srcset=&#34;
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g23ajj6lw8j305k03swei_hua2b8121fbfe414c7c231ed6a5a5122fe_5237_6b000a4bbf92f01712feaa746df3a78b.webp 400w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g23ajj6lw8j305k03swei_hua2b8121fbfe414c7c231ed6a5a5122fe_5237_5f1564507e63fae1b1a1ee46d666d76e.webp 760w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g23ajj6lw8j305k03swei_hua2b8121fbfe414c7c231ed6a5a5122fe_5237_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g23ajj6lw8j305k03swei_hua2b8121fbfe414c7c231ed6a5a5122fe_5237_6b000a4bbf92f01712feaa746df3a78b.webp&#34;
               width=&#34;200&#34;
               height=&#34;136&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      2
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果你陷入了无休止的实现和测试地狱，就退一步看看如何分隔域。您是否接受（译注：此处原文有字母丢失）了一个来自其他领域的上下文，或者将不同的概念混合到一个领域中？也许回到设计阶段考虑边界是值得的。为了避免到处重复，请确保有适当的文档，比如在域之间使用OpenAPI标准的文档。&lt;/p&gt;
&lt;h2 id=&#34;2-混合微服务的职责&#34;&gt;2. 混合微服务的职责&lt;/h2&gt;
&lt;p&gt;想吃意面的话这是一个不错的选择。在意面上放些肉丸子让它更美味？在服务中混合一些有状态的进程将会给您带来更多!&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-3&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;3&#34; srcset=&#34;
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g24bk7332yj308w07kmy0_hu8d3ccc8914692f66753a9001a61dbab5_13060_2c8dc9af0f95e21b3d5e3e1e31cba269.webp 400w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g24bk7332yj308w07kmy0_hu8d3ccc8914692f66753a9001a61dbab5_13060_98f5bc05854cae287980afdfc7f0eb9c.webp 760w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g24bk7332yj308w07kmy0_hu8d3ccc8914692f66753a9001a61dbab5_13060_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g24bk7332yj308w07kmy0_hu8d3ccc8914692f66753a9001a61dbab5_13060_2c8dc9af0f95e21b3d5e3e1e31cba269.webp&#34;
               width=&#34;320&#34;
               height=&#34;272&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      3
    &lt;/figcaption&gt;&lt;/figure&gt;

混合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合微服务&lt;/li&gt;
&lt;li&gt;功能性的核心业务&lt;/li&gt;
&lt;li&gt;无状态整合&lt;/li&gt;
&lt;li&gt;有状态的进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;u&gt;临床症状和副作用&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端调用变得复杂，如果不提供特定服务的组合视图，客户端可能需要组合并在其中处理某种核心业务。&lt;/li&gt;
&lt;li&gt;服务之间的关系就好像意大利面条之间的关系，很容易无法追踪到数据流和业务逻辑在微服务中的调用关系。&lt;/li&gt;
&lt;li&gt;太多的耦合，无状态和有状态依赖于存储解决方案，向下扩展也可能有潜在问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我写了很多关于这一主题的博客，主要观点都是担心拆分。确保你的云原生微服务是干净、精练和敏捷的，这意味着你需要确保业务组合和实际业务功能需要单独分开到不同的实例并独立部署，以便获得更好的结构化和模块化。为了可伸缩性和灵活性，确保微服务的组合/编排是无状态的。用专门的存储解决方案在其他实例上保留长时间运行的进程来保持状态。&lt;/p&gt;
&lt;h2 id=&#34;3-和外界因素需求太多的耦合&#34;&gt;3. 和外界因素/需求太多的耦合&lt;/h2&gt;
&lt;p&gt;有耐心总是好的，如果你想练习在你平静的时候能更加的耐心，通过与遗留系统的深度耦合将训练你成为耐心大师，并且能够在敏捷和缓慢的遗留更新周期之间找到平衡，并且更擅长代码管理。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;临床症状和副作用&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;持续的从核心业务更新到更好控制的外部系统。外部系统决定和做出变更请求，更短的反应时间可能会导致问题。&lt;/li&gt;
&lt;li&gt;一旦双方建立了契约，就需要特别小心版本的更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-3&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;3&#34; srcset=&#34;
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g25q0lfgymj308w07dt9b_hu4f88d9899aac0105ad69e962ff65877b_11965_33536b3c37849e788ef5291a6a176762.webp 400w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g25q0lfgymj308w07dt9b_hu4f88d9899aac0105ad69e962ff65877b_11965_8d986f3f26d6c597d4279ed2efdb869b.webp 760w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g25q0lfgymj308w07dt9b_hu4f88d9899aac0105ad69e962ff65877b_11965_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g25q0lfgymj308w07dt9b_hu4f88d9899aac0105ad69e962ff65877b_11965_33536b3c37849e788ef5291a6a176762.webp&#34;
               width=&#34;320&#34;
               height=&#34;265&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      3
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;部署周期因系统而异，但是与更敏捷、更动态的云原生应用相比，棕色地带的应用（译注：作者本意应该是比喻新旧代码或功能耦合的有污染的应用）生命周期更长。为了更快，请始终考虑在你的棕色/绿色地带的应用程序之间设置一个屏蔽保护。因此，它适应更少的变化，并帮助绿色领域继续进行敏捷开发。在你的核心域微服务中，请避免添加任何依赖于外部消费者或特定于外部消费者的内容，因为这可能导致过多的自定义，从而破坏了确定的上下文边界。确保你有其他面向模块的公共库或外部系统来进行定制，并对内部业务模型隐藏复杂性。&lt;/p&gt;
&lt;h2 id=&#34;4-微服务中重复的业务无关的代码&#34;&gt;4. 微服务中重复的业务无关的代码&lt;/h2&gt;
&lt;p&gt;作为一个开发人员，如果有人依赖你会让你感到被需要的满足感。为什么每天有24小时是有原因的，你得工作20小时，因为你的重要性，系统部署上线的时候你需要在那儿。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;临床症状和副作用&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-4&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;4&#34; srcset=&#34;
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g26lj2v5nsj308w06edgx_hu048a4785d22717fe768fcfb25d027f4a_16552_595ae770c05023cb99cbc78590b2caf7.webp 400w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g26lj2v5nsj308w06edgx_hu048a4785d22717fe768fcfb25d027f4a_16552_040da9d11b4ce348a56d1e14b830837d.webp 760w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g26lj2v5nsj308w06edgx_hu048a4785d22717fe768fcfb25d027f4a_16552_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g26lj2v5nsj308w06edgx_hu048a4785d22717fe768fcfb25d027f4a_16552_595ae770c05023cb99cbc78590b2caf7.webp&#34;
               width=&#34;320&#34;
               height=&#34;230&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      4
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有集中控制，所有重试、重路由、版本控制和部署策略都存储在每个独立的实例中。&lt;/li&gt;
&lt;li&gt;开发和开发运维人员之间的职责不明确，同样的，对于能够访问环境运行情况的监控来说，网络策略更好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置重试和路由策略可以让应用更加健壮。用更集中化的视图来了解这些策略是如何处理的，而不是将它们分散到各个微服务上。减轻开发人员处理应用程序中所有事情的负担，以及更好的管理和监控。&lt;/p&gt;
&lt;h2 id=&#34;5-服务网格化所有的连接通过api&#34;&gt;5. 服务网格化，所有的连接通过API&lt;/h2&gt;
&lt;p&gt;进行API调用非常简单，服务网格是现在每个人都在做的事情。每种技术都有一个库来处理REST/JSON。让我们用API来连接系统中的所有组件!&lt;/p&gt;
&lt;p&gt;&lt;u&gt;临床症状和副作用&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反应慢，因为请求并响应是大多数人使用它的方式。等待时间可能会越来越长，长进程也会有更多的锁。这将成为性能瓶颈。&lt;/li&gt;
&lt;li&gt;没有工具化的云基础架构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当微服务首次出现时，人们希望远离ESB，因此许多人不再使用消息传递代理，并使用API作为服务之间唯一的连接方法，因为OpenAPI标准允许你在可用的内容之间构建一个良好的目录。但是事件驱动是有原因的，为了实现真正的可伸缩性，更好的解耦，你需要停止在调用之间进行粘性依赖。事件驱动允许你只向相关方发送事件，因为它是异步的，所以在等待响应时不会浪费任何资源。&lt;/p&gt;
&lt;h2 id=&#34;6-乱序的事件&#34;&gt;6. 乱序的事件&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-6&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;6&#34; srcset=&#34;
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g26n3fd6mvj308w07omxp_hu701ee0fae9a2c310a2b8ac236e71e7e7_10039_62c0bcc92b6cc608f0f4e0c8fc16aed7.webp 400w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g26n3fd6mvj308w07omxp_hu701ee0fae9a2c310a2b8ac236e71e7e7_10039_33344dbba28bfbfebc31f422d48761ad.webp 760w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g26n3fd6mvj308w07omxp_hu701ee0fae9a2c310a2b8ac236e71e7e7_10039_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g26n3fd6mvj308w07omxp_hu701ee0fae9a2c310a2b8ac236e71e7e7_10039_62c0bcc92b6cc608f0f4e0c8fc16aed7.webp&#34;
               width=&#34;320&#34;
               height=&#34;276&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      6
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;用事件来轰炸系统，把任何事件都通知到每个角落，这会让你的系统超级的反抗！顺便说一下，为什么不把所有的东西都序列化并存储所有的事件呢？为了更好的可追踪性！&lt;/p&gt;
&lt;p&gt;&lt;u&gt;临床症状和副作用&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件无处不在，你意识到必须监听大量的事件来做出反应。&lt;/li&gt;
&lt;li&gt;不需要的代码过滤掉事件。&lt;/li&gt;
&lt;li&gt;混淆状态变化和应该采取的行为。&lt;/li&gt;
&lt;li&gt;不知道保存或丢失事件消息哪个更好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有各种类型的事件，如果不谨慎的处理事件分发到哪儿以及如何分发，就很可能以不需要的事件结束并消耗不必要的资源。关注一些通用的，比如包含数据、状态和命令的事件。你希望尽量减少数据消息的数量，因为它需要更长的处理时间和更多的存储工作。分拆和过滤数据可能更有效。处理状态事件重试和回滚命令事件也应该是事件策略的一部分。&lt;/p&gt;
&lt;h2 id=&#34;7-数据孤岛&#34;&gt;7. 数据孤岛&lt;/h2&gt;
&lt;p&gt;一个微服务一个数据源，专家如是说。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;临床症状和副作用&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据源之间的数据不一致或同步较慢。&lt;/li&gt;
&lt;li&gt;创建了不需要的微服务只是为了确保数据的一致性。&lt;/li&gt;
&lt;li&gt;事件到处更新状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-7&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;7&#34; srcset=&#34;
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g26qyic03cj308w03saa7_hud559610bf024a59e0006d7c6bddb634e_5700_94cf6fce2d6b994b8a96c30ce791e797.webp 400w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g26qyic03cj308w03saa7_hud559610bf024a59e0006d7c6bddb634e_5700_5047a64123c0a96f5808aeffed436567.webp 760w,
               /blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g26qyic03cj308w03saa7_hud559610bf024a59e0006d7c6bddb634e_5700_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/eight-things-leads-to-developing-catastrophic-cloud-native-microservices-system/006tNc79ly1g26qyic03cj308w03saa7_hud559610bf024a59e0006d7c6bddb634e_5700_94cf6fce2d6b994b8a96c30ce791e797.webp&#34;
               width=&#34;320&#34;
               height=&#34;136&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      7
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当您拥有独立的数据源时，就有创建数据孤岛的风险，而且由于微服务的分布式特性和更复杂的数据存储场景，管理数据一致性变得更加困难。你可以开始研究如何使用许多现有的解决方案来捕获数据变更，比如在进程中发生的流事件变更，或者从主存储中监听更改。&lt;/p&gt;
&lt;h2 id=&#34;8-有限的自动化&#34;&gt;8. 有限的自动化&lt;/h2&gt;
&lt;p&gt;手动要灵活得多，以前在服务器上使用JavaEE应用时也是如此。自动化需要太多的时间来安装设置，有时间的时候再处理吗？&lt;/p&gt;
&lt;p&gt;&lt;u&gt;临床症状和副作用&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新缓慢&lt;/li&gt;
&lt;li&gt;到生成环境需要漫长而痛苦的步骤&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在计划中需要做的第一件事一定是自动化。如何应用自动化的CI/CD流程和部署策略，如何实现云原生微服务系统的敏捷性。我过去做过一些基于Jenkins的CI/CD自动化。&lt;a href=&#34;https://github.com/jbossdemocentral/fuse-financial-cicd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;See Github Link&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;好了，这就是我的两分钱。如果你认为还有其他可能导致糟糕的云原生微服务开发的事情，请和我分享！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>微服务通信的设计模式</title>
      <link>https://cloudnative.to/blog/design-patterns-for-microservice-communication/</link>
      <pubDate>Tue, 27 Nov 2018 19:29:05 +0800</pubDate>
      <guid>https://cloudnative.to/blog/design-patterns-for-microservice-communication/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://dzone.com/users/468979/rajesh.bhojwani.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在我的上一篇博客中，我谈到了&lt;a href=&#34;https://dzone.com/articles/design-patterns-for-microservices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务的设计模式&lt;/a&gt;。现在我想更深入地探讨微服务架构中最重要的模式：微服务之间的相互通信。我仍然记得我们过去开发单一应用时通讯是一项艰巨的任务。在那时我们必须小心的设计数据库表和对象模型映射之间的关系。而现在在微服务中，我们已经将它们分解为独立的服务，并创建网格来彼此通信。让我们来谈谈迄今为止为解决这个问题而发展起来的所有通信方式和模式。&lt;/p&gt;
&lt;p&gt;许多架构师已经将微服务之间的通信划分为同步和异步两种模式。让我们一个一个来介绍。&lt;/p&gt;
&lt;h2 id=&#34;同步模式&#34;&gt;同步模式&lt;/h2&gt;
&lt;p&gt;当我们说到同步时，意思是客户端向服务端发出请求并等待其响应。线程将被阻塞，直到它接收到返回。实现同步通信最主要的协议是HTTP。HTTP可以通过REST或SOAP实现。现在REST在微服务方面发展迅速并超越了SOAP。对我而言两者都很好用。&lt;/p&gt;
&lt;p&gt;现在让我们讨论同步模式中的不同的工作流、用例，我们面临的问题以及如何去解决。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先从一个简单的例子开始。你需要一个服务A来调用服务B并等待实时数据的响应。这是实现同步的一个很好的选择，因为不会涉及到下游服务。如果使用多个实例，除了负载均衡之外，你不需要为这个用例实现任何复杂的设计模式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sync-flow&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/design-patterns-for-microservice-communication/006tNbRwly1fxlg5e91x1j30fc04yt8l.jpg&#34; alt=&#34;sync flow&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      sync flow
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现在让我们把它变得更复杂一点。服务A为实时数据调用多个下游服务，如服务B、服务C和服务D。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;服务B、服务C和服务D都必须按顺序调用——当服务相互依赖以检索数据，或者是有一个事件序列的功能需要被执行，就会出现这种情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务B、服务C和服务D可以并行调用——这种场景被使用在服务彼此独立或服务A可能扮演协调者（Orchestrator）角色时。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sync-flow2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/design-patterns-for-microservice-communication/006tNbRwly1fxlgbk5vfbj30g609rwei.jpg&#34; alt=&#34;sync flow2&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      sync flow2
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这会为通信带来复杂性。让我们一个一个地讨论。&lt;/p&gt;
&lt;h3 id=&#34;紧密耦合&#34;&gt;紧密耦合&lt;/h3&gt;
&lt;p&gt;服务A将与服务B、C和D耦合。它必须知道每个服务的端点（endpoint）和凭据（credentials）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;： &lt;a href=&#34;https://www.rajeshbhojwani.co.in/2018/11/design-patterns-for-microservices.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务发现模式&lt;/a&gt; 就是用来解决这类问题的。它通过提供查询功能来帮助分离消费者和生产者应用。服务B、C和D可以将它们自己注册为服务。服务发现可以在服务端也可以在客户端实现。对于服务端，有AWS ALB和NGINX，它们接受来自客户端的请求，发现服务并将请求路由到指定位置。&lt;/p&gt;
&lt;p&gt;对于客户端，有Spring Eureka发现服务。使用Eureka的真正好处是它在客户端缓存了可用的服务信息，所以即使Eureka服务器宕机了一段时间，它也不会成为单点故障。除了Eureka，etcd和consul等其他服务发现工具也得到了广泛的应用。&lt;/p&gt;
&lt;h3 id=&#34;分布式系统&#34;&gt;分布式系统&lt;/h3&gt;
&lt;p&gt;如果服务B，C，D有多个实例，它们需要知道如何负载均衡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：负载均衡通常与服务发现携手出现。对于服务器负载平衡，可以使用AWS ALB，对于客户端可以使用Ribbon或Eureka。&lt;/p&gt;
&lt;h3 id=&#34;验证过滤处理协议&#34;&gt;验证/过滤/处理协议&lt;/h3&gt;
&lt;p&gt;如果服务B、C和D需要被保护并验证身份，我们只需要过滤这些服务的某些请求，如果服务A和其他服务使用不同的协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;a href=&#34;http://www.rajeshbhojwani.co.in/2018/11/design-patterns-for-microservices.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 网关模式（gateway）&lt;/a&gt; 有助于解决这些问题。它可以处理身份验证、过滤和将协议从AMQP转换为HTTP或其他协议。它还可以查看分布式日志、监控和分布式跟踪等可观测的指标（metrics）。Apigee、Zuul和Kong就是一些这样的工具。请注意，如果服务B、C和D是可管理的API的一部分，我建议使用这种模式，否则使用API网关就太重了。下面将要读到的服务网格是它的替代解决方案。&lt;/p&gt;
&lt;h3 id=&#34;处理失败&#34;&gt;处理失败&lt;/h3&gt;
&lt;p&gt;如果服务B、C或D宕机，服务A仍然有某些功能来响应客户端请求，就必须相应地对其进行设计。另一个问题是：假设服务B宕机，所有请求仍然在调用服务B，并且由于它没有响应而耗尽了资源，这会使整个系统宕机，服务A也无法向C和D发送请求了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;a href=&#34;http://www.rajeshbhojwani.co.in/2018/11/design-patterns-for-microservices.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;熔断器（Circuit Breaker）&lt;/a&gt; 和 &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/architecture/patterns/bulkhead&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;隔板（bulkhead） &lt;/a&gt;模式有助于解决这些问题。熔断器识别下游服务是否停机了一段时间，并断开开关以避免向其发送调用请求。它将在定义的时间段之后再次尝试检查，如果服务已经恢复则关闭开关以继续对其进行调用。这确实有助于避免网络阻塞和耗尽资源。隔板模式有助于隔离用于服务的资源，并避免级联故障。Spring Cloud Hystrix就是做这样的工作，它适用于断路器和隔板模式。&lt;/p&gt;
&lt;h3 id=&#34;微服务间网络通信&#34;&gt;微服务间网络通信&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://www.rajeshbhojwani.co.in/2018/11/design-patterns-for-microservices.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 网关&lt;/a&gt; 通常用于管理API，它处理来自ui或其他消费者的请求，并对多个微服务进行下游调用并作出响应。但是，当一个微服务想要调用同组中的另一个微服务时，API网关就没有必要了，它并不是为了这个目的而设计的。最终，独立的微服务将负责进行网络通信、安全验证、处理超时、处理故障、负载平衡、服务发现、监控和日志记录。对于微服务来说开销太大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：服务网格模式有助于处理此类NFRs。它可以卸载我们前面讨论的所有网络功能。这样，微服务就不会直接调用其他微服务，而是通过服务网格，它将处理所有的通信。这种模式的美妙之处在于，你可以专注于用任何语言（如Java、NodeJS或Python）编写业务逻辑，而不必担心这些语言是否支持所有的网络功能。Istio和Linkerd解决了这些需求。我唯一不喜欢Istio的地方是它目前仅限于Kubernetes。&lt;/p&gt;
&lt;h2 id=&#34;异步模式&#34;&gt;异步模式&lt;/h2&gt;
&lt;p&gt;当我们谈到异步通信时，它意味着客户端调用服务器，接收到请求的确认，然后忘记它。服务器将处理请求并完成。&lt;/p&gt;
&lt;p&gt;现在让我们讨论一下什么时候需要异步。如果你的应用读操作很多，那么同步可能非常适合，尤其是在需要实时数据时。但是，当你处理大量写操作而又不能丢失数据记录时，你可能希望选择异步操作，因为如果下游系统宕机，你继续向其发送同步的调用，你将丢失请求和业务交易。经验法则是永远不要对实时数据读取使用异步，也永远不要对关键的业务交易写操作使用同步，除非你在写后立即需要数据。你需要在数据可用性和数据的强一致性之间进行选择。&lt;/p&gt;
&lt;p&gt;有几种不同的方式可以实现异步：&lt;/p&gt;
&lt;h3 id=&#34;消息&#34;&gt;消息&lt;/h3&gt;
&lt;p&gt;在这种方式中，生产者将消息发送到消息代理，而消费者可以监听代理来接收消息并相应地处理它。在消息处理中有两种模式：一对一和一对多。我们讨论了同步带来的一些复杂性，但是在消息传递中，默认情况下就会消除一些复杂性。例如，服务发现变得无关紧要，因为消费者和生产者都只与消息代理对话。负载均衡是通过扩展消息系统来处理的。失败处理是内建的，主要由message broker负责。RabbitMQ、ActiveMQ和Kafka是云平台中最流行的消息传递解决方案。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-msg-flow&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/design-patterns-for-microservice-communication/006tNbRwly1fxlhh1zzvuj30kj0coaa7.jpg&#34; alt=&#34;msg flow&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      msg flow
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;事件驱动&#34;&gt;事件驱动&lt;/h3&gt;
&lt;p&gt;事件驱动方式看起来类似于消息传递，但它的用途不同。它不会发送消息，而是将事件细节连同负载（payload）一起发送到消息代理。消费者将确定事件是什么，以及如何对此作出响应。这会更加松散的耦合。有下面几种类型的负载可以被传递：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全负载 —— 这将包含与消费者采取进一步行动所需的事件相关的所有数据。然而，这使得它的耦合更加紧密。&lt;/li&gt;
&lt;li&gt;资源 URL —— 这是一个指向代表事件的资源的URL。&lt;/li&gt;
&lt;li&gt;仅事件 —— 不会发送负载，消费者将基于事件名称知道如何从其他源（如数据库或队列）检索相关数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-event-flow&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/design-patterns-for-microservice-communication/006tNbRwly1fxlhpapghaj30ll0a8mx7.jpg&#34; alt=&#34;event flow&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      event flow
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;还有其他一些方式，比如编排（choreography），但我个人并不喜欢。它太复杂几乎无法实现，只能通过同步方式来完成。&lt;/p&gt;
&lt;p&gt;以上就是本博客的全部内容。请让我知道你在微服务通信方面的经验。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>速率限制系列part4—为Ambassador API网关设计速率限制服务</title>
      <link>https://cloudnative.to/blog/designing-a-rate-limiting-service-for-ambassador-part-4/</link>
      <pubDate>Wed, 11 Jul 2018 15:32:40 +0800</pubDate>
      <guid>https://cloudnative.to/blog/designing-a-rate-limiting-service-for-ambassador-part-4/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.getambassador.io/designing-a-rate-limiting-service-for-ambassador-f460e9fabedb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.getambassador.io/rate-limiting-a-useful-tool-with-distributed-systems-6be2b1a4f5f4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;先前&lt;/a&gt;关于速率限制文章主要描述如何构建并部署基于Java的速率限制服务，该服务可以和开源的Ambassador API网关以及Kubernetes集成（文章的&lt;a href=&#34;https://cloudnative.to/blog/rate-limiting-a-useful-tool-with-distributed-systems-part1&#34;&gt;第1部分&lt;/a&gt;和&lt;a href=&#34;https://cloudnative.to/blog/rate-limiting-for-api-gateway-daniel-bryant-part2&#34;&gt;第2部分&lt;/a&gt;请见这里）。 大家或许会疑惑怎么样才能更好地设计速率限制服务，尤其是如何保证Ambassador以及其底层的Envoy代理的灵活性？这篇文章将给大家启发。&lt;/p&gt;
&lt;h2 id=&#34;设置场景&#34;&gt;设置场景&lt;/h2&gt;
&lt;p&gt;如果你还没有阅读这个系列的第3部分“&lt;a href=&#34;https://cloudnative.to/blog/implementing-a-java-rate-limiting-service-for-the-ambassador-api-gateway-part3&#34;&gt;基于Ambassador API网关实现Java速率限制服务&lt;/a&gt;”，我建议你先阅读（文章的&lt;a href=&#34;https://cloudnative.to/blog/rate-limiting-a-useful-tool-with-distributed-systems-part1&#34;&gt;第1部分&lt;/a&gt;和&lt;a href=&#34;https://cloudnative.to/blog/rate-limiting-for-api-gateway-daniel-bryant-part2&#34;&gt;第2部分&lt;/a&gt;请见这里 ）。其中最关键的是&lt;a href=&#34;https://www.getambassador.io/reference/services/rate-limit-service&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambassador API网关&lt;/a&gt;，其就像其底层使用的&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v1/route_config/rate_limits&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy代理&lt;/a&gt;一样，通过请求另一个服务来决定一个请求的速率是否需要被限制。这是关注点分离（和单一原则）设计的良好实现。同时由于Ambassador可作为Kubernetes原生API网关，因此你可以很方便将rate limiter部署为Kubernetes基础服务，用来管理平台的容错特性，同时其也很容易进行扩展。&lt;/p&gt;
&lt;p&gt;下文假设你已成功将Ambassador部署进Kubernetes集群，同时也根据我先前文章中所描述的那样完成速率限制服务部署。以下是基于Java开发的速率限制服务其所使用的Kubernetes配置文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apiVersion: v1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kind: Service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  name: ratelimiter
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  annotations:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    getambassador.io/config: &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      ---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      apiVersion: ambassador/v0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      kind: RateLimitService
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      name: ratelimiter_svc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      service: &lt;span class=&#34;s2&#34;&gt;&amp;#34;ratelimiter:50051&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  labels:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    app: ratelimiter
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  type: ClusterIP
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  selector:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    app: ratelimiter
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ports:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  - protocol: TCP
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    port: &lt;span class=&#34;m&#34;&gt;50051&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    name: http
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apiVersion: apps/v1beta2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kind: Deployment
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  name: ratelimiter
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  labels:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    app: ratelimiter
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  replicas: &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  selector:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    matchLabels:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      app: ratelimiter
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  template:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      labels:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        app: ratelimiter
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    spec:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      containers:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      - name: ratelimiter
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        image: danielbryantuk/ratelimiter:0.3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ports:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - containerPort: &lt;span class=&#34;m&#34;&gt;50051&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;描述符descriptor&#34;&gt;描述符（descriptor）&lt;/h2&gt;
&lt;p&gt;Ambassador中速率限制功能的灵活性主要通过在Kubernetes配置上指定描述符和请求头实现，这些参数会被传递到速率限制服务实例中。 以下文为例，首先看一下先前文章中探讨过的my shopfront应用程序的Ambassador配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apiVersion: v1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kind: Service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  labels:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    service: ambassador
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  name: ambassador
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  annotations:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    getambassador.io/config: &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      ---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      apiVersion: ambassador/v0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      kind:  Mapping
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      name:  shopfront_stable
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      prefix: /shopfront/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      service: shopfront:8010
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      rate_limits:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - descriptor: Example descriptor
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          headers:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            - &lt;span class=&#34;s2&#34;&gt;&amp;#34;X-MyHeader&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - descriptor: Y header descriptor
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          headers:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            - &lt;span class=&#34;s2&#34;&gt;&amp;#34;Y-MyHeader&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到在rate_limits配置中有两个YAML元素，每个元素都有不同的描述符和请求头。根据&lt;a href=&#34;https://www.getambassador.io/user-guide/rate-limiting-tutorial#2-configure-ambassador-mappings&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambassador速率限制&lt;/a&gt;文档中所述，当请求头在配置中定义，并出现在请求元数据中，其才能被速率限制。比如说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果访问shopfront的请求没有包含请求头，其就不符合速率限制条件（即不会对在Ambassador的其他配置中所定义的速率限制服务生效）&lt;/li&gt;
&lt;li&gt;通过请求头“X-MyHeader:123”向shopfront服务发出的请求可能受到速率限制。速率限制服务将接收与“X-MyHeader”请求头相匹配的rate_limits元素所关联的描述符信息，并以“generic_key”为名，这里值为“Example descriptor”。因此，速率限制服务将收到如下请求元数据：[{“generic_key”,“Example descriptor”},{“X-MyHeader”,”123”}]&lt;/li&gt;
&lt;li&gt;通过请求头“Y-MyHeader:ABC”向shopfront服务发出的请求可能受到速率限制。速率限制服务将接收与“Y-MyHeader”请求头相匹配的rate_limits元素所关联的描述符信息，并以“generic_key”为名，这里值为“Y header descriptor”。因此，速率限制服务将收到如下请求元数据：[{“generic_key”,“Y header descriptor”},{“Y-MyHeader”,”ABC”}]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是否进行速率限制是由速率限制服务决定的，该服务只需在Envoy的&lt;a href=&#34;https://github.com/envoyproxy/envoy/blob/master/source/common/ratelimit/ratelimit.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ratelimit.proto&lt;/a&gt; gRPC接口中返回的适当值：OK, OVER_LIMIT 或 UNKNOWN即可。根据上文描述，你可以在两个地方添加包含描述符和请求头的请求元数据，使其可在速率限制服务中使用：可以在部署时添加到Ambassador Kubernetes配置中；或在程序运行时添加。&lt;/p&gt;
&lt;h2 id=&#34;速率限制服务元数据样例&#34;&gt;速率限制服务元数据样例&lt;/h2&gt;
&lt;p&gt;举个例子。假设你的企业已经创建了一个移动应用程序，该程序通过Ambassador API网关与后端服务进行通信，并且你希望对普通用户和测试用户使用不同的规则进行速率限制，同时你也希望对未认证用户也这么进行。你可以在请求头中访问UserID和UserType数据：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apiVersion: v1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kind: Service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  labels:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    service: BackendService
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  name: BackendService
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  annotations:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    getambassador.io/config: &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      ---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      apiVersion: ambassador/v0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      kind:  Mapping
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      name:  backend_app
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      prefix: /app/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      service: backend_app:8010
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      rate_limits:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - descriptor: Mobile app ingress - authenticated
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          headers:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            -&lt;span class=&#34;s2&#34;&gt;&amp;#34;UserID&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            -&lt;span class=&#34;s2&#34;&gt;&amp;#34;UserType&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - descriptor: Mobile app ingress - unauthenticated
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;任何包含请求头“UserID”和“UserType”的请求都将被转发到速率限制服务，同时请求也包含（generic_key）描述符“Mobile app ingress - authenticated”。未包含请求头的请求会被第二个描述符捕获，并被转发到只包含（generic_key）描述符“Mobile app ingress - unauthenticated”的速率限制服务中。你可以通过任意语言的算法实现上述速率限制功能。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;如果你正在考虑&lt;a href=&#34;https://eng.lyft.com/announcing-ratelimit-c2e8f3182555&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;inspiration&lt;/a&gt;，或&lt;a href=&#34;https://github.com/lyft/ratelimit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;现成可用的Ambassador限速服务&lt;/a&gt;，请务必留心Envoy文档和Lyft GitHub库。尤其是Lyft参考Envoy所实现的&lt;a href=&#34;https://github.com/lyft/ratelimit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;速率限制&lt;/a&gt;方案非常实用，它既可作为可插拔的解决方案，也可以作为解决方案的指南用于在自定义速率限制服务中实现配置加载和运行时加载。&lt;/p&gt;
&lt;p&gt;你可以在先前文章“&lt;a href=&#34;https://blog.getambassador.io/implementing-a-java-rate-limiting-service-for-the-ambassador-api-gateway-e09d542455da&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于Ambassador API网关实现Java速率限制服务&lt;/a&gt;”中找到有关在Kubernetes中安装Ambassador API网关和配置速率限制的教程。同样，欢迎你在&lt;a href=&#34;https://gitter.im/datawire/ambassador&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambassador Gitter&lt;/a&gt;提问。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>速率限制part3—基于Ambassador API网关实现Java速率限制服务</title>
      <link>https://cloudnative.to/blog/implementing-a-java-rate-limiting-service-for-the-ambassador-api-gateway-part3/</link>
      <pubDate>Wed, 04 Jul 2018 12:26:02 +0800</pubDate>
      <guid>https://cloudnative.to/blog/implementing-a-java-rate-limiting-service-for-the-ambassador-api-gateway-part3/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.getambassador.io/implementing-a-java-rate-limiting-service-for-the-ambassador-api-gateway-e09d542455da&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;基于Kubernetes云原生的&lt;a href=&#34;https://www.getambassador.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ambassador API&lt;/a&gt;网关所提供的速率限制功能是完全可定制的，其允许任何实现gRPC服务端点的服务自行决定是否需要对请求进行限制。本文在先前&lt;a href=&#34;rate-limiting-a-useful-tool-with-distributed-systems-part1.md&#34;&gt;第1部分&lt;/a&gt;和&lt;a href=&#34;rate-limiting-for-api-gateway-daniel-bryant-part2.md&#34;&gt;第2部分&lt;/a&gt;的基础上，阐述如何为Ambassador API网关创建和部署简单的基于Java的速率限制服务。&lt;/p&gt;
&lt;h2 id=&#34;部署docker-java-shop&#34;&gt;部署Docker Java Shop&lt;/h2&gt;
&lt;p&gt;在我之前的教程“&lt;a href=&#34;https://blog.getambassador.io/deploying-java-apps-with-kubernetes-and-the-ambassador-api-gateway-c6e9d9618f1b&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用Kubernetes和Ambassador API网关部署Java应用&lt;/a&gt;”中，我将开源的Ambassador API网关添加到现有的一个部署于Kubernetes的Java（Spring Boot和Dropwizard）服务中。 如果你之前不了解这个，建议你先阅读下此教程及其他相关内容来熟悉基础知识。
本文假定你熟悉如何构建基于Java的微服务并将其部署到Kubernetes，同时已经完成安装所有的必备组件（我在本文中使用&lt;a href=&#34;https://docs.docker.com/docker-for-mac/edge-release-notes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker for Mac Edge&lt;/a&gt;，并启用其内置的Kubernetes支持。若使用minikube或远程群集应该也类似）。&lt;/p&gt;
&lt;h2 id=&#34;先决条件&#34;&gt;先决条件&lt;/h2&gt;
&lt;p&gt;需要在本地安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker for Desktop：我使用edge community edition (18.04.0-ce)，内置了对本地Kubernetes集群的支持。由于Java应用对内存有一定要求，我还将Docker可用内存增加到8G。&lt;/li&gt;
&lt;li&gt;编辑器选择：Atom 或者 VS code；当写Java代码时也可以使用IntelliJ。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以在这里获取最新版本的“Docker Java Shop”源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/danielbryantuk/oreilly-docker-java-shopping&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/danielbryantuk/oreilly-docker-java-shopping&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你可以通过如下命令使用SSH克隆仓库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ git clone git@github.com:danielbryantuk/oreilly-docker-java-shopping.git
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一阶段的服务和部署架构如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-第一阶段架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/implementing-a-java-rate-limiting-service-for-the-ambassador-api-gateway-part3/78a165e1gy1fsvwpjxbzuj20hi0gjdga.jpg&#34; alt=&#34;第一阶段架构&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      第一阶段架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从图中可以看到，Docker Java Shopping应用程序主要由三个服务组成。在先前的教程中，你已经添加Ambassador API网关作为系统的“front door”（大门）。需要注意的是，Ambassador API网关直接使用Web 80号端口，因此需要确保本地运行的其他应用没有占用该端口。&lt;/p&gt;
&lt;h2 id=&#34;ambassador-api网关速率限制入门&#34;&gt;Ambassador API网关速率限制入门&lt;/h2&gt;
&lt;p&gt;我在本教程的仓库中增加了一个新文件夹 “&lt;a href=&#34;https://github.com/danielbryantuk/oreilly-docker-java-shopping/tree/master/kubernetes-ambassador-ratelimit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubernetes-ambassador-ratelimit&lt;/a&gt;”，用于包含Kubernetes相关配置。请通过命令行导航到此目录。此目录应包含如下文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;master *&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; oreilly-docker-java-shopping $ &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; kubernetes-ambassador-ratelimit/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;master *&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; kubernetes-ambassador-ratelimit $ ll
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;total &lt;span class=&#34;m&#34;&gt;48&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; drwxr-xr-x &lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; danielbryant staff &lt;span class=&#34;m&#34;&gt;256&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;23&lt;/span&gt; Apr 09:27 .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; drwxr-xr-x &lt;span class=&#34;m&#34;&gt;19&lt;/span&gt; danielbryant staff &lt;span class=&#34;m&#34;&gt;608&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;23&lt;/span&gt; Apr 09:27 ..
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; -rw-r — r — &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; danielbryant staff &lt;span class=&#34;m&#34;&gt;2033&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;23&lt;/span&gt; Apr 09:27 ambassador-no-rbac.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; -rw-r — r — &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; danielbryant staff &lt;span class=&#34;m&#34;&gt;698&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;23&lt;/span&gt; Apr 10:30 ambassador-rate-limiter.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; -rw-r — r — &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; danielbryant staff &lt;span class=&#34;m&#34;&gt;476&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;23&lt;/span&gt; Apr 10:30 ambassador-service.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; -rw-r — r — &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; danielbryant staff &lt;span class=&#34;m&#34;&gt;711&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;23&lt;/span&gt; Apr 09:27 productcatalogue-service.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; -rw-r — r — &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; danielbryant staff &lt;span class=&#34;m&#34;&gt;659&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;23&lt;/span&gt; Apr 10:02 shopfront-service.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;8&lt;/span&gt; -rw-r — r — &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; danielbryant staff &lt;span class=&#34;m&#34;&gt;678&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;23&lt;/span&gt; Apr 09:27 stockmanager-service.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可以使用以下命令来提交Kubernetes配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过以上命令部署，这与之前架构的区别在于添加了&lt;code&gt;ratelimiter&lt;/code&gt;服务。 这个服务是用Java编写的，且没有使用微服务框架。它发布了一个gRPC端点，可供Ambassador来使用以实现速率限制。这种方案允许灵活定制速率限制算法（关于这点的好处请查看我&lt;a href=&#34;https://blog.getambassador.io/rate-limiting-for-api-gateways-892310a2da02&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以前的文章&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-限速架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/implementing-a-java-rate-limiting-service-for-the-ambassador-api-gateway-part3/78a165e1gy1fsvwvs0d8kj20hi0gj74v.jpg&#34; alt=&#34;限速架构&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      限速架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;探索部署于kubernetes的限速器服务&#34;&gt;探索部署于Kubernetes的限速器服务&lt;/h2&gt;
&lt;p&gt;与任何其他服务一样，部署到Kubernetes的限速服务也可以根据需要进行水平扩展。 以下是Kubernetes配置文件&lt;code&gt;ambassador-rate-limiter.yaml&lt;/code&gt;的内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ratelimiter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;getambassador.io/config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      ---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      apiVersion: ambassador/v0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      kind: RateLimitService
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      name: ratelimiter_svc
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      service: &amp;#34;ratelimiter:50051&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ratelimiter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterIP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ratelimiter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;50051&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ReplicationController&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ratelimiter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;replicas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ratelimiter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ratelimiter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;danielbryantuk/ratelimiter:0.3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;50051&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里不需要关注最后Docker Image处的&lt;code&gt;danielbryantuk/ratelimiter:0.3&lt;/code&gt; ，而需要注意的是：此服务在集群使用50051 TCP端口。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;ambassador-service.yaml&lt;/code&gt;配置文件中，还更新了Ambassador Kubernetes annotations配置，以确保能通过包含&lt;code&gt;rate_limits&lt;/code&gt;属性来限制对shopfront服务的请求。 我还添加了一些额外的元数据&lt;code&gt;- descriptor: Example descriptor&lt;/code&gt;，这将在下一篇文章中更详细地解释。这里我们需要注意的是，如果要将元数据传递到速率限制服务，这种方法不错。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ambassador&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ambassador&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;getambassador.io/config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      ---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      apiVersion: ambassador/v0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      kind:  Mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      name:  shopfront_stable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      prefix: /shopfront/
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      service: shopfront:8010
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      rate_limits:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        - descriptor: Example descriptor&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可以使用kubectl命令来检查部署是否成功：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;master *&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; kubernetes-ambassador-ratelimit $ kubectl get svc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME               TYPE           CLUSTER-IP       EXTERNAL-IP   PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;          AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ambassador         LoadBalancer   10.105.253.3     localhost     80:30051/TCP     1d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ambassador-admin   NodePort       10.107.15.225    &amp;lt;none&amp;gt;        8877:30637/TCP   1d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetes         ClusterIP      10.96.0.1        &amp;lt;none&amp;gt;        443/TCP          16d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;productcatalogue   ClusterIP      10.109.48.26     &amp;lt;none&amp;gt;        8020/TCP         1d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ratelimiter        ClusterIP      10.97.122.140    &amp;lt;none&amp;gt;        50051/TCP        1d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;shopfront          ClusterIP      10.98.207.100    &amp;lt;none&amp;gt;        8010/TCP         1d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;stockmanager       ClusterIP      10.107.208.180   &amp;lt;none&amp;gt;        8030/TCP         1d
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;6个业务服务看起来都不错（去除Kubernetes服务）：包含3个Java服务，2个Ambassador服务和1个ratelimiter服务。&lt;/p&gt;
&lt;p&gt;你可以通过curl命令对shopfront的服务端点进行测试，其应绑定在外部IP localhost的80端口上（如上文所示）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(master *) kubernetes-ambassador-ratelimit $ curl localhost/shopfront/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;lang=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;xmlns=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;http://www.w3.org/1999/xhtml&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;charset=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;utf-8&amp;#34;&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&amp;lt;!-- jQuery (necessary for Bootstrap&amp;#39;s JavaScript plugins) --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;script&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;src=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&amp;lt;!-- Include all compiled plugins (below), or include individual files as needed --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;script&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;src=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;js/bootstrap.min.js&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;(master *) kubernetes-ambassador-ratelimit $
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你会注意到这里显示了一些HTML，这只是Docker Java Shop的首页。虽然可以通过浏览器在&lt;a href=&#34;http://localhost/shopfront/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://localhost/shopfront/&lt;/a&gt;访问，对于我们的速率限制实验，最好还是使用curl命令。&lt;/p&gt;
&lt;h2 id=&#34;速率限制测试&#34;&gt;速率限制测试&lt;/h2&gt;
&lt;p&gt;对于这种演示性质的速率限制服务，这里仅对服务本身进行限制。比如当速率限制服务需要计算是否需要限制请求时，唯一需要考虑的指标是在一段时间内针对特定后端的请求数量。在代码实现中使用&lt;a href=&#34;https://en.wikipedia.org/wiki/Token_bucket&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;令牌桶算法&lt;/a&gt;。假设桶中令牌容量为20，并且每秒钟的补充10个令牌。由于速率限制与请求相关联，这意味着你可以每秒发出10次API请求，这没有任何问题，同时由于存储桶最初包含20个令牌，你可以暂时超过此并发数量。但是，一旦最初额外的令牌使用完，并且你仍在尝试每秒发出10个以上请求，那么你将收到HTTP 429 “Too Many Requests” 状态码。这时，Ambassador API网关不会再将请求转发到后端服务。&lt;/p&gt;
&lt;p&gt;让我看下如何通过curl发出大量请求来模拟这个操作。避免显示的HTML页面（通过&lt;code&gt;-output /dev/null&lt;/code&gt;参数）及curl请求（通过&lt;code&gt;--silent&lt;/code&gt;参数），但需要显示符合预期的HTTP响应状态（通过&lt;code&gt;-- show-error  --fail&lt;/code&gt;参数）。下文通过一个bash循环脚本，并记录时间输出（以显示发出请求的时间），以此来创建一个非常粗颗粒度的负载发生器（可以通过&lt;code&gt;CTRL-C&lt;/code&gt;来终止循环）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; true&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; curl --silent --output /dev/null --show-error --fail http://localhost/shopfront/&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; -e &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;date&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;master *&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; kubernetes-ambassador-ratelimit $ &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; true&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; curl --silent --output /dev/null --show-error --fail http://localhost/shopfront/&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; -e &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;date&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tue &lt;span class=&#34;m&#34;&gt;24&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;2018&lt;/span&gt; 14:16:31 BST
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tue &lt;span class=&#34;m&#34;&gt;24&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;2018&lt;/span&gt; 14:16:31 BST
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tue &lt;span class=&#34;m&#34;&gt;24&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;2018&lt;/span&gt; 14:16:31 BST
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tue &lt;span class=&#34;m&#34;&gt;24&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;2018&lt;/span&gt; 14:16:31 BST
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tue &lt;span class=&#34;m&#34;&gt;24&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;2018&lt;/span&gt; 14:16:35 BST
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl: &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;22&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; The requested URL returned error: &lt;span class=&#34;m&#34;&gt;429&lt;/span&gt; Too Many Requests
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tue &lt;span class=&#34;m&#34;&gt;24&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;2018&lt;/span&gt; 14:16:35 BST
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl: &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;22&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; The requested URL returned error: &lt;span class=&#34;m&#34;&gt;429&lt;/span&gt; Too Many Requests
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tue &lt;span class=&#34;m&#34;&gt;24&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;2018&lt;/span&gt; 14:16:35 BST
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tue &lt;span class=&#34;m&#34;&gt;24&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;2018&lt;/span&gt; 14:16:35 BST
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl: &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;22&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; The requested URL returned error: &lt;span class=&#34;m&#34;&gt;429&lt;/span&gt; Too Many Requests
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tue &lt;span class=&#34;m&#34;&gt;24&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;2018&lt;/span&gt; 14:16:35 BST
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl: &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;22&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; The requested URL returned error: &lt;span class=&#34;m&#34;&gt;429&lt;/span&gt; Too Many Requests
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Tue &lt;span class=&#34;m&#34;&gt;24&lt;/span&gt; Apr &lt;span class=&#34;m&#34;&gt;2018&lt;/span&gt; 14:16:35 BST
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;^C
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如你所见，从输出日志来看，前几个请求显示日期且没有错误，一切正常。过不了多久，当在我测试的Mac上的请求循环超过每秒10次，HTTP 429错误便开始出现。&lt;/p&gt;
&lt;p&gt;顺便说一下，我通常使用&lt;a href=&#34;https://httpd.apache.org/docs/2.4/programs/ab.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Apache Benchmarking “ab”&lt;/a&gt; 负载生成工具来进行这种简单实验，但这工具在调用本地localhost会有问题（同时Docker配置也给我带来了额外问题）。&lt;/p&gt;
&lt;h2 id=&#34;检验速率限制器服务&#34;&gt;检验速率限制器服务&lt;/h2&gt;
&lt;p&gt;Ambassador Java限速服务的源代码在我GitHub帐户的&lt;a href=&#34;https://github.com/danielbryantuk/ambassador-java-rate-limiter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ambassador-java-rate-limiter&lt;/a&gt;仓库中。其中也包含用于构建我推送到DockerHub中容器镜像的&lt;a href=&#34;https://github.com/danielbryantuk/ambassador-java-rate-limiter/blob/master/Dockerfile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dockerfile&lt;/a&gt;。你可以以此Dockerfile作为模板进行修改，然后构建和推送自己的镜像至DockerHub。你也可以修改在Docker Java Shopping仓库中的&lt;a href=&#34;https://github.com/danielbryantuk/oreilly-docker-java-shopping/blob/master/kubernetes-ambassador-ratelimit/ambassador-rate-limiter.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ambassador-rate-limiter.yaml&lt;/a&gt;文件来扩展使用你自己的速率限制服务。&lt;/p&gt;
&lt;h2 id=&#34;研究java代码&#34;&gt;研究Java代码&lt;/h2&gt;
&lt;p&gt;如果你深入研究Java代码，最需要关注的类应该是&lt;a href=&#34;https://github.com/danielbryantuk/ambassador-java-rate-limiter/blob/master/src/main/java/io/datawire/ambassador/ratelimiter/simpleimpl/RateLimitServer.java&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RateLimiterServer&lt;/a&gt;，它实现了在Ambassador API中使用的&lt;a href=&#34;https://www.datawire.io/envoyproxy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy代理&lt;/a&gt;所定义的速率限制gRPC接口。我创建了一个&lt;a href=&#34;https://github.com/danielbryantuk/ambassador-java-rate-limiter/blob/master/src/main/proto/ratelimit.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ratelimit.proto&lt;/a&gt;接口的副本，其通过Maven &lt;a href=&#34;https://github.com/danielbryantuk/ambassador-java-rate-limiter/blob/master/pom.xml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pom.xml&lt;/a&gt;中定义的gRPC Java构建工具来构建使用。代码主要涉及三点：实现gRPC接口，运行gRPC服务器，并实现速率限制。下面让我们来进一步分析。&lt;/p&gt;
&lt;h3 id=&#34;实现速率限制grpc接口&#34;&gt;实现速率限制gRPC接口&lt;/h3&gt;
&lt;p&gt;查看&lt;code&gt;RateLimitServer&lt;/code&gt;中的内部类&lt;code&gt;RateLimiterImpl&lt;/code&gt;，其对&lt;code&gt;RateLimitServiceGrpc.RateLimitServiceImplBase&lt;/code&gt;进行扩展，你可以看到此抽象类中的下列方法被重写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;shouldRateLimit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Ratelimit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;RateLimitRequest&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rateLimitRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StreamObserver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Ratelimit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;RateLimitResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;responseStreamObserver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里使用的很多命名规约来自于Java gRPC库，进一步信息请参阅&lt;a href=&#34;https://grpc.io/docs/tutorials/basic/java.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC Java文档&lt;/a&gt;。 尽管这样，如果查看&lt;a href=&#34;https://github.com/danielbryantuk/ambassador-java-rate-limiter/blob/master/src/main/proto/ratelimit.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ratelimit.proto&lt;/a&gt;文件，你可以清楚看到很多命名根，这些命名根定义了在Ambassador中使用的Envoy代理所需要的速率限制接口。例如，你可以看到此文件中定义的核心服务名为&lt;code&gt;RateLimitService&lt;/code&gt;（第9行），并且在服务&lt;code&gt;rpc ShouldRateLimit (RateLimitRequest) returns (RateLimitResponse) {}&lt;/code&gt;（第11行）中定义了一个RPC方法， 它在Java中实现通过上面所定义的&lt;code&gt;shouldRateLimit&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;如果有兴趣，可以看看那些由&lt;code&gt;protobuf-maven-plugin&lt;/code&gt;（&lt;a href=&#34;https://github.com/danielbryantuk/ambassador-java-rate-limiter/blob/master/pom.xml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pom.xml&lt;/a&gt;的第99行）生成的Java gRPC代码。&lt;/p&gt;
&lt;h3 id=&#34;运行grpc服务器&#34;&gt;运行gRPC服务器&lt;/h3&gt;
&lt;p&gt;一旦你实现了用&lt;code&gt;ratelimit.proto&lt;/code&gt;定义的gRPC接口，下一件事情就是创建一个gRPC服务器用来监听和回复请求。可以根据&lt;code&gt;main&lt;/code&gt;方法调用链来查看&lt;a href=&#34;https://github.com/danielbryantuk/ambassador-java-rate-limiter/blob/master/src/main/java/io/datawire/ambassador/ratelimiter/simpleimpl/RateLimitServer.java&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RateLimitServer&lt;/a&gt;的内容。简而言之，&lt;code&gt;main&lt;/code&gt;方法创建一个&lt;code&gt;RateLimitServer&lt;/code&gt;类的实例，调用&lt;code&gt;start()&lt;/code&gt;方法，再调用&lt;code&gt;blockUntilShutdown()&lt;/code&gt;方法。 这将启动一个应用实例，并在指定的服务端点上发布gRPC接口，同时侦听请求。&lt;/p&gt;
&lt;h3 id=&#34;实现java速率限制&#34;&gt;实现Java速率限制&lt;/h3&gt;
&lt;p&gt;负责速率限制过程的实际Java代码包含在&lt;code&gt;RateLimiterImpl&lt;/code&gt;内部类的&lt;code&gt;shouldRateLimit()&lt;/code&gt;方法（第75行）中。我没有自己实现算法，而是使用基于&lt;a href=&#34;https://en.wikipedia.org/wiki/Token_bucket&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;令牌桶算法&lt;/a&gt;的Java速度限制开源库&lt;a href=&#34;https://github.com/vladimir-bukhtoyarov/bucket4j&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bucket4j&lt;/a&gt;。由于我限制了对每个服务的请求，因此每个存储桶与服务名称所绑定。对每个服务的请求都会从其所关联的存储桶中删除一个令牌。在本案例中，桶没有存储在外部数据库，而是存储在内存中的&lt;code&gt;ConcurrentHashMap&lt;/code&gt;中。如果在生产环境中，通常会使用类似Redis的外部持久化存储方案来实现横向扩展。这里必须注意，如果在不更改每个服务桶限制的前提下水平扩展速率限制服务，那么将直接导致（非速率限制）请求数量的增加，但实际服务可支持的请求数量没有增加。&lt;/p&gt;
&lt;p&gt;创建bucket4j存储桶的&lt;code&gt;RateLimiterImpl&lt;/code&gt;大致代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bucket&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;createNewBucket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;overdraft&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Refill&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;refill&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Refill&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;smooth&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Duration&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ofSeconds&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Bandwidth&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;limit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bandwidth&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;classic&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;overdraft&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;refill&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bucket4j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addLimit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;limit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在下面可以看到&lt;code&gt;shouldRateLimit&lt;/code&gt;方法的代码，它只是简单地尝试执行&lt;code&gt;tryConsume(1)&lt;/code&gt;使用桶中一个令牌，并返回适当的HTTP响应。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;shouldRateLimit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Ratelimit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;RateLimitRequest&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rateLimitRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StreamObserver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Ratelimit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;RateLimitResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;responseStreamObserver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;logDebug&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rateLimitRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;destServiceName&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;extractDestServiceNameFrom&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rateLimitRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Bucket&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bucket&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getServiceBucketFor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;destServiceName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Ratelimit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;RateLimitResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Code&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;tryConsume&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Ratelimit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;RateLimitResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Code&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;OK&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Ratelimit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;RateLimitResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Code&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;OVER_LIMIT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Ratelimit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;RateLimitResponse&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rateLimitResponse&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;generateRateLimitResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;responseStreamObserver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;onNext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rateLimitResponse&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;responseStreamObserver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;onCompleted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码比较容易解释。如果当前请求不需要进行速率限制，则此方法返回&lt;code&gt;Ratelimit.RateLimitResponse.Code.OK; &lt;/code&gt;如果当前请求由于速度限制而被拒绝，则此方法返回&lt;code&gt;Ratelimit.RateLimitResponse.Code.OVER_LIMIT&lt;/code&gt;。根据此gRPC服务的响应，Ambassador API网关将请求传递给后端服务，或者中断请求并返回HTTP状态码429 “Too Many Requests” 而不再调用后端服务。&lt;/p&gt;
&lt;p&gt;这个简单案例只可以防止一个服务的访问过载，但也希望这能够阐明速率限制的核心概念，进而可以相对容易实现基于请求元数据（例如用户ID等）的速率限制。&lt;/p&gt;
&lt;h2 id=&#34;下一阶段&#34;&gt;下一阶段&lt;/h2&gt;
&lt;p&gt;本文演示了如何在Java中创建速率限制服务，并轻易与Ambassador网关所集成。如果需要，你也可以基于任何自定义的速率限制算法实现。 在本系列的最后一篇文章中，您将更深入地了解Envoy速率限制API，以便进一步学习如何设计速率限制服务。&lt;/p&gt;
&lt;p&gt;如果有任何疑问，欢迎在Ambassador Gitter或通过&lt;a href=&#34;https://twitter.com/danielbryantuk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@danielbryantuk&lt;/a&gt;及&lt;a href=&#34;https://twitter.com/datawireio?lang=en&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@datawireio&lt;/a&gt;联系。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
