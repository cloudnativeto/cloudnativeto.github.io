<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Helm | 云原生社区（中国）</title>
    <link>https://cloudnative.to/tag/helm/</link>
      <atom:link href="https://cloudnative.to/tag/helm/index.xml" rel="self" type="application/rss+xml" />
    <description>Helm</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Wed, 14 Dec 2022 15:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>Helm</title>
      <link>https://cloudnative.to/tag/helm/</link>
    </image>
    
    <item>
      <title>云原生架构师进阶指南</title>
      <link>https://cloudnative.to/blog/advanced-guide-for-cloudnative-architects/</link>
      <pubDate>Wed, 14 Dec 2022 15:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/advanced-guide-for-cloudnative-architects/</guid>
      <description>&lt;p&gt;伴随着云计算的浪潮，云原生的概念也应运而生，从 2015 年 CNCF 云原生基金会的成立，已经持续高速发展了 7 年时间。而 Kubernetes 作为云原生的代表就像是一个全新的云操作系统，围绕着它诞生了丰富的上层应用和生态。&lt;/p&gt;
&lt;p&gt;迄今为止，CNCF 在其公布的云原生全景图中，显示了目前近 30 个领域、数百个项目的繁荣发展，云原生技术的广度和深度得到了前所未有的发展。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-cncf-landscape&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/1.png&#34; alt=&#34;CNCF Landscape&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      CNCF Landscape
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;面对这庞杂的技术领域和技术工具，我们往往不知道要从哪儿下手开始学习。即便掌握了云原生核心技术 Docker 和 K8s，不过在工程实践中，这远远是不够的。&lt;/p&gt;
&lt;p&gt;那当我们有了云原生基础之后，&lt;strong&gt;想要进一步实现职业晋升，我建议你从下面的几个方面去学习：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-云原生架构师必须掌握的技能&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/2.jpeg&#34; alt=&#34;云原生架构师必须掌握的技能&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      云原生架构师必须掌握的技能
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;总结来说，你需要聚焦在下面几个领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器和镜像：Docker&lt;/li&gt;
&lt;li&gt;持续集成：GitHub Action、Jenkins、Tekton&lt;/li&gt;
&lt;li&gt;镜像仓库：Harbor&lt;/li&gt;
&lt;li&gt;应用定义：Helm、Kustomize&lt;/li&gt;
&lt;li&gt;持续部署：FluxCD、ArgoCD&lt;/li&gt;
&lt;li&gt;秘钥管理：Vault&lt;/li&gt;
&lt;li&gt;容器编排：K8s&lt;/li&gt;
&lt;li&gt;网关：Ingress-Nginx&lt;/li&gt;
&lt;li&gt;日志：Grafana Loki、Fluentd&lt;/li&gt;
&lt;li&gt;监控：Grafana&lt;/li&gt;
&lt;li&gt;告警：Prometheus&lt;/li&gt;
&lt;li&gt;应用开发：Nocalhost&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，这些领域的项目在云原生工程实践中并不是独立的，&lt;strong&gt;你需要掌握并把它们连接起来，才能将项目迁移到云原生架构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面对这么多的领域和技术，怎么学习它们才能更加高效呢？下面是根据我的学习经验总结的学习路径，你可以参考：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段：学习 Docker 和 K8s 的基础知识；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段：学习 CI/CD 领域的技术；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三阶段：学习日志、监控和告警领域的技术。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;三个学习阶段&#34;&gt;三个学习阶段&lt;/h2&gt;
&lt;h3 id=&#34;第一阶段&#34;&gt;第一阶段&lt;/h3&gt;
&lt;p&gt;在第一阶段，你需要学习 Docker 和 K8s 的基础知识。其中，Docker 相关的知识包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;镜像是什么，有什么作用？&lt;/li&gt;
&lt;li&gt;怎么将业务代码构建为镜像？&lt;/li&gt;
&lt;li&gt;如何选择合适的基础镜像？&lt;/li&gt;
&lt;li&gt;Docker 的其他基本操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在学习了 Docker 相关知识后，接下来就要开始学习 K8s 相关知识，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是 K8s 的工作负载？&lt;/li&gt;
&lt;li&gt;Service 的作用是什么？&lt;/li&gt;
&lt;li&gt;应用配置如何迁移？&lt;/li&gt;
&lt;li&gt;如何对外暴露服务？&lt;/li&gt;
&lt;li&gt;如何配置 HPA 扩缩容？&lt;/li&gt;
&lt;li&gt;Kubectl 的基本操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个阶段学习完成后，在工作中使用 Docker 和 K8s 基本上就没太大问题了。&lt;/p&gt;
&lt;h3 id=&#34;第二阶段&#34;&gt;第二阶段&lt;/h3&gt;
&lt;p&gt;当具备了 Docker 和 K8s 的基础知识后，接下来就需要学习 CI/CD 领域的技术了。其中，CI 领域包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何使用 Jenkins 自动构建镜像？&lt;/li&gt;
&lt;li&gt;如何使用 GitHub Action 自动构建镜像？&lt;/li&gt;
&lt;li&gt;如何自建 Tekton 构建镜像？&lt;/li&gt;
&lt;li&gt;如何使用 Tekton 搭建私有镜像仓库？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，再深入学习 CD 领域的技术，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何定义应用，Helm 还是 Kustomize？&lt;/li&gt;
&lt;li&gt;如何使用 ArgoCD 搭建 GitOps 工作流？&lt;/li&gt;
&lt;li&gt;如何管理 GitOps 中的秘钥&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到了这个阶段，也就具备在实际项目中搭建完整的 GitOps 工作流的能力了。&lt;/p&gt;
&lt;h3 id=&#34;第三阶段&#34;&gt;第三阶段&lt;/h3&gt;
&lt;p&gt;为了让分布式系统具有更好的可观测性，在第三阶段我们需要学习日志、监控和告警的知识，他们包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何使用 Loki 搭建轻量级的日志系统？&lt;/li&gt;
&lt;li&gt;如何使用 EFK 搭建日志系统？&lt;/li&gt;
&lt;li&gt;如何使用 Grafana 和 Prometheus 搭建监控系统？&lt;/li&gt;
&lt;li&gt;如何使用 Prometheus AlertManager 搭建告警系统？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到了第三个阶段，你已经基本上掌握完整的云原生知识体系了。&lt;/p&gt;
&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;p&gt;这种学习方式适合有一定基础并且动手能力强的同学，它们缺少体系化的学习过程，当需要将不同领域的工具进行连接时缺少可参考的最佳实践的案例。&lt;/p&gt;
&lt;h2 id=&#34;选择体系化的课程&#34;&gt;选择体系化的课程&lt;/h2&gt;
&lt;p&gt;还有一种可行的学习方法是选择一门体系化的课程，这里我推荐王炜的极客时间新专栏《云原生架构与 GitOps 实战》。你可以从零上手，一步一步入门云原生，一次学习云原生的所有知识点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-扫码报名&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/post.jpeg&#34; alt=&#34;扫码报名&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      扫码报名
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;也可以&lt;a href=&#34;https://time.geekbang.org/column/intro/100312001?code=PlMU9ITPlnun1QAjTGtDtNxkTtgSRZZzLJlQZHrEKtI%3D&amp;amp;utm_term=SPoster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击这里&lt;/a&gt;查看课程介绍&lt;/p&gt;
&lt;p&gt;这里也分享一张课程的学习路径，跟着这条路径，就可以高效地解决“怎么学”的问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-课程学习路径&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/3.jpg&#34; alt=&#34;课程学习路径&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      课程学习路径
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;课程目录&#34;&gt;课程目录&lt;/h3&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-课程目录&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/4.jpeg&#34; alt=&#34;课程目录&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      课程目录
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;关于王炜&#34;&gt;关于王炜&lt;/h3&gt;
&lt;p&gt;王炜，现在深圳氦三科技的联合创始人，他之前就职于腾讯云 CODING 担任架构师，也是&lt;strong&gt;中国云原生社区深圳站的负责人&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;出版了 &lt;strong&gt;《Spinnaker 实战：云原生多云环境的持续部署方案》&lt;/strong&gt;，参与编写了 &lt;strong&gt;《深入理解 Istio：云原生服务网格进阶实战》&lt;/strong&gt; 以及 &lt;strong&gt;《软件研发效能权威指南》&lt;/strong&gt; 的云原生开发部分。&lt;/p&gt;
&lt;p&gt;同时，他也是云原生开发工具 &lt;strong&gt;Nocalhost&lt;/strong&gt; 项目的核心作者。&lt;/p&gt;
&lt;h3 id=&#34;课程售价&#34;&gt;课程售价&lt;/h3&gt;
&lt;p&gt;课程原价 ¥129&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;今日早鸟 6 折秒杀，到手 ￥ 79！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你是新用户，只需要 ￥ 59！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;a href=&#34;https://time.geekbang.org/column/intro/100312001?code=PlMU9ITPlnun1QAjTGtDtNxkTtgSRZZzLJlQZHrEKtI%3D&amp;amp;utm_term=SPoster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;，立享 6 折，跟着王炜学习云原生架构与 GitOps。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Helm Chart 仓库弃用更新</title>
      <link>https://cloudnative.to/blog/helm-chart-repository-deprecation-update/</link>
      <pubDate>Thu, 12 Nov 2020 13:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/helm-chart-repository-deprecation-update/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://www.cncf.io/blog/2020/11/05/helm-chart-repository-deprecation-update/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Helm Chart Repository Deprecation Update&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 2019 年，当 Helm v2 的支持时间表和 &lt;a href=&#34;https://github.com/helm/charts#deprecation-timeline&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;终止计划&lt;/a&gt; 被宣布的时候，&lt;a href=&#34;https://github.com/helm/charts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;helm/charts GitHub 仓库&lt;/a&gt; 的弃用也同时被宣布。对于弃用的最主要原因是 &lt;a href=&#34;https://github.com/helm/charts/blob/master/OWNERS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;仓库维护人员&lt;/a&gt; 的维护成本显著增加。在过去的几年里，受维护的 charts 数量从约 100 增加到 300 个以上，这也导致了对于仓库的拉取请求和更新需求相应增加。很不幸的是，尽管采取了很多的措施来实现自动 review 和维护任务，但是维护人员能抽出的可用时间却没有增加。&lt;/p&gt;
&lt;p&gt;当我们开始宣布弃用的时候，我们已经开始着手分享我们曾经用来维护 helm/charts 仓库的工具和指导文档。对于那些想要自己保持和维护自己仓库的小伙伴们，你们现在已经有工具能完成以下流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/helm/chart-testing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chart 测试&lt;/a&gt; 为你的 charts PR 提供 lint 和测试&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/helm/chart-releaser&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chart 发布&lt;/a&gt; 提供工具来帮助你使用 GitHub Releases 和 pages 功能来管理你自己的 chart 仓库&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/helm?q=chart&amp;#43;action&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;测试和发布 GitHub Action&lt;/a&gt; 自动化调用上述工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上述工具的帮助下我们就能使很多 charts 迁移到 &lt;a href=&#34;https://github.com/helm/charts/issues/21103&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;他们自己的仓库&lt;/a&gt; 了，以便于进一步的维护。&lt;/p&gt;
&lt;h2 id=&#34;关键时间点和建议行动&#34;&gt;关键时间点和建议行动&lt;/h2&gt;
&lt;p&gt;我们对上述计划和接下来发生的事情可能会有的困惑/疑问进行了提炼，并提供了关键事件时间表和建议的后续行动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2020 年 11 月 2 号——所有非弃用 charts 的 README 中将会添加一个注释信息，以表明这些 charts 将不再更新&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;推荐行动&lt;/strong&gt; —— 如果你依赖于 Charts 仓库中的 chart，那么就需要寻找新的官方地址了。如果没有依赖，那就使用自己的 chart 即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020 年 11 月 6 号——稳定和孵化 charts 仓库将从 &lt;a href=&#34;https://artifacthub.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Artifact Hub&lt;/a&gt; 中删除&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;推荐行动&lt;/strong&gt;——无&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020 年 11 月 13 号——&lt;a href=&#34;https://github.com/helm/charts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;helm/charts 仓库&lt;/a&gt; 中的 CI 将被停用并且不再接受拉取请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;推荐行动&lt;/strong&gt;——关于正在进行的重新安置 charts 到新仓库的方案的更多信息，可以查看 &lt;a href=&#34;https://github.com/helm/charts/issues/21103&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这个 issue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020 年 11 月 13 号以后——使用旧地址下载 Charts 将会被重定向到在 GitHub pages 上可用的归档地址。在这个日期以后旧下载地址将不再可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;推荐行动&lt;/strong&gt;——查看 &lt;a href=&#34;https://helm.sh/docs/faq/#i-am-getting-a-warning-about-unable-to-get-an-update-from-the-stable-chart-repository&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;切换至归档的稳定和孵化仓库&lt;/a&gt; 的相关信息。切记那些 charts 将不再被更新，包括 bug 修复和安全补丁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/helm/charts/issues/23944&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Charts 仓库弃用时间表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/helm/charts/issues/23850&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;历史版本的归档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/helm/community/issues/114&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;请求让 CNCF 托管 Helm Charts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Istio 0.8 的 Helm Chart 解析</title>
      <link>https://cloudnative.to/blog/helm-chart-for-istio-0-8/</link>
      <pubDate>Mon, 04 Jun 2018 16:09:57 +0800</pubDate>
      <guid>https://cloudnative.to/blog/helm-chart-for-istio-0-8/</guid>
      <description>&lt;p&gt;儿童节期间，拖拉了一个多月的 Istio 0.8 正式发布了，这可能是 Istio 1.0 之前的最后一个 LTS 版本，意义重大。&lt;/p&gt;
&lt;p&gt;新版本中，原来的 Kubernetes 安装文件 &lt;code&gt;install/kubernetes/istio.yaml&lt;/code&gt;，变成了 &lt;code&gt;install/kubernetes/istio-demo.yaml&lt;/code&gt;，是的，你没看错，这个 LTS 的安装文件名字叫 demo。查看了一下文档，大概察觉到不靠谱的 Istio 发布组的意图了：这个项目的组件相对比较复杂，原有的一些选项是靠 ConfigMap 以及 istioctl 分别调整的，现在通过重新设计的 Helm Chart，安装选项用 values.yml 或者 helm 命令行的方式来进行集中管理了。下面就由看看 Istio 的 Helm Chart 的安装部署及其结构。&lt;/p&gt;
&lt;h2 id=&#34;使用-helm-安装-istio&#34;&gt;使用 Helm 安装 Istio&lt;/h2&gt;
&lt;p&gt;安装包内的 Helm 目录中包含了 Istio 的 Chart，官方提供了两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 Helm 生成 istio.yaml，然后自行安装。&lt;/li&gt;
&lt;li&gt;用 Tiller 直接安装。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很明显，两种方法并没有什么本质区别。例如第一个命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm template install/kubernetes/helm/istio &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --name istio --namespace  &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    istio-system &amp;gt; &lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/istio.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里说的是使用 &lt;code&gt;install/kubernetes/helm/istio&lt;/code&gt; 目录中的 Chart 进行渲染，生成的内容保存到 &lt;code&gt;$HOME/istio.yaml&lt;/code&gt; 文件之中。而第二个命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm template install/kubernetes/helm/istio &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --name istio --namespace istio-system &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;    --set sidecarInjectorWebhook.enabled&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt; &amp;gt; &lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/istio.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;只是设置了 Chart 中的一个变量 &lt;code&gt;sidecarInjectorWebhook.enabled&lt;/code&gt; 为 False。从而禁止自动注入属性生效。&lt;/p&gt;
&lt;p&gt;我们照猫画虎，看看命令二的结果提交到 Kubernetes 中会发生什么事情。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm template install/kubernetes/helm/istio --name istio &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--namespace istio-system --set sidecarInjectorWebhook.enabled&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt; &amp;gt; &lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/istio.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl create namespace istio-system
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl create -f &lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/istio.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据不同的网络情况，可能需要几分钟的等待，最后会看到这些 Pod 在运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;istio-citadel-ff5696f6f-h4rdz&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;istio-cleanup-old-ca-rp5p6&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;istio-egressgateway-58d98d898c-5jnpz&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;istio-ingress-6fb78f687f-wsl5q&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;istio-ingressgateway-6bc7c7c4bc-hhrh7&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;istio-mixer-post-install-d2kl5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;istio-pilot-6c5c6b586c-dqv2w&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;istio-policy-5c7fbb4b9f-xmv6f&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;istio-statsd-prom-bridge-6dbb7dcc7f-27tx7&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;istio-telemetry-54b5bf4847-9gpr7&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;na&#34;&gt;prometheus-586d95b8d9-gb846&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;过去的 istio-ca 现已更名 istio-citadel。&lt;/li&gt;
&lt;li&gt;istio-cleanup-old-ca 是一个 job，用于清理过去的 Istio 遗留下来的 CA 部署（包括 sa、deploy 以及 svc 三个对象）。&lt;/li&gt;
&lt;li&gt;istio-mixer-post-install 同样也是一个 job，和上面的 Job 一样，简单的调用 kubectl 创建第三方资源，从而避免了之前的 CDR 需要重复创建的尴尬状况。&lt;/li&gt;
&lt;li&gt;egressgateway、ingress 以及 ingressgateway，可以看出边缘部分的变动很大，以后会另行发文。&lt;/li&gt;
&lt;li&gt;和从前不同，缺省已经打开了监控界面。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;helm-chart-的安装配置&#34;&gt;Helm Chart 的安装配置&lt;/h3&gt;
&lt;p&gt;下面的配置项目，都可以使用 helm 的 &lt;code&gt;--set key=value&lt;/code&gt; 来设置，可以重复使用，用来设置多个值。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;选项&lt;/th&gt;
          &lt;th&gt;说明&lt;/th&gt;
          &lt;th&gt;缺省值&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;global.hub&lt;/td&gt;
          &lt;td&gt;绝大部分镜像所在的镜像库地址&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;docker.io/istionightly&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;global.tag&lt;/td&gt;
          &lt;td&gt;Istio 使用的绝大部分镜像的 Tag&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;circleci-nightly&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;global.proxy.image&lt;/td&gt;
          &lt;td&gt;指定 Proxy 的镜像名称&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;proxyv2&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;global.imagePullPolicy&lt;/td&gt;
          &lt;td&gt;镜像拉取策略&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;IfNotPresent&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;global.controlPlaneSecurityEnabled&lt;/td&gt;
          &lt;td&gt;控制面是否启动 mTLS&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;global.mtls.enabled&lt;/td&gt;
          &lt;td&gt;服务间是否缺省启用 mTLS&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;global.mtls.mtlsExcludedServices&lt;/td&gt;
          &lt;td&gt;禁用 mTLS 的 FQDN 列表&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;- kubernetes.default.svc.cluster.local&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;global.rbacEnabled&lt;/td&gt;
          &lt;td&gt;是否创建 RBAC 规则&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;global.refreshInterval&lt;/td&gt;
          &lt;td&gt;Mesh 发现间隔&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;10s&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;global.arch.amd64&lt;/td&gt;
          &lt;td&gt;amd64 架构中的调度策略，0：never；1: least preferred；2：no preference；3：most preferred&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;2&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;global.arch.s390x&lt;/td&gt;
          &lt;td&gt;amd64 架构中的调度策略，0：never；1: least preferred；2：no preference；3：most preferred&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;2&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;global.arch.ppc64le&lt;/td&gt;
          &lt;td&gt;amd64 架构中的调度策略，0：never；1: least preferred；2：no preference；3：most preferred&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;2&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;galley.enabled&lt;/td&gt;
          &lt;td&gt;是否安装 Galley 用于进行服务端的配置验证，需要 1.9 版本以上的 Kubernetes&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上面的内容来自&lt;a href=&#34;https://istio.io/docs/setup/kubernetes/helm-install/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;，其实这是不符合实际情况的（Istio 用户的日常）。在 &lt;code&gt;install/kubernetes/helm/istio/values.yaml&lt;/code&gt; 中，包含这一发行版本中的所有的缺省值。可以直接修改或者新建 values.yaml，并在 helm 命令行使用 &lt;code&gt;-f my-values.yaml&lt;/code&gt; 参数来生成自行定制的 &lt;code&gt;istio.yaml&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;解读-istio-helm-chart-中的模块&#34;&gt;解读 Istio Helm Chart 中的模块&lt;/h2&gt;
&lt;p&gt;打开 Istio 的 Chart 之后，发现其中并没有任何组件的内容，只有两个 Configmap 对象的模板。其安装主体再次很非主流的通过依赖 Chart 的方式实现了完全的模块化。因此这个 Chart 的主体，实际上是 &lt;code&gt;requirements.yaml&lt;/code&gt;，打开这个文件，会看到规规矩矩的列出很多模块，例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  - name: sidecarInjectorWebhook
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    version: 0.8.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    # repository: file://../sidecarInjectorWebhook
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    condition: sidecarInjectorWebhook.enabled
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这表明在 &lt;code&gt;sidecarInjectorWebhook&lt;/code&gt; 取值为 &lt;code&gt;enabled&lt;/code&gt; 的时候，就渲染这一模板。因此这里可以看做是模块的启用停用的控制点。这里列出的模块包括：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;模块&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;egressgateway&lt;/td&gt;
          &lt;td&gt;外发流量网关&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;galley&lt;/td&gt;
          &lt;td&gt;在 K8S 服务端验证 Istio 的 CRD 资源的合法性&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;grafana&lt;/td&gt;
          &lt;td&gt;Dashboard&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;ingress&lt;/td&gt;
          &lt;td&gt;Ingress Controller&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;ingressgateway&lt;/td&gt;
          &lt;td&gt;Ingress Gateway&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;mixer&lt;/td&gt;
          &lt;td&gt;Mixer&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;pilot&lt;/td&gt;
          &lt;td&gt;Pilot&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;prometheus&lt;/td&gt;
          &lt;td&gt;Prometheus&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;security&lt;/td&gt;
          &lt;td&gt;安全相关内容&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;servicegraph&lt;/td&gt;
          &lt;td&gt;调用关系图&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;sidecarInjectorWebhook&lt;/td&gt;
          &lt;td&gt;自动注入&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;tracing&lt;/td&gt;
          &lt;td&gt;Zipkin Jeager 的跟踪服务&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面逐一做一下简要说明&lt;/p&gt;
&lt;h3 id=&#34;egressgateway&#34;&gt;egressgateway&lt;/h3&gt;
&lt;p&gt;外发通信的网关。&lt;/p&gt;
&lt;p&gt;他的设置保存在 &lt;code&gt;values.yaml&lt;/code&gt; 的 &lt;code&gt;egressgateway&lt;/code&gt; 一节中（都是保存在同名分支下，后面不再重复）。部署内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Deployment 和 Service：一个 proxy。&lt;/li&gt;
&lt;li&gt;HPA&lt;/li&gt;
&lt;li&gt;RBAC 相关内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可定制项目包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端口和类型&lt;/li&gt;
&lt;li&gt;HPA 实例数量上下限&lt;/li&gt;
&lt;li&gt;资源限制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;galley&#34;&gt;galley&lt;/h3&gt;
&lt;p&gt;之前的 istio 版本中，只能通过 istioctl 验证 Istio 相关 CRD 的有效性，这个模块提供一个在服务端验证 CRD 的方法，他的部署内容包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Deployement 和 Service。&lt;/li&gt;
&lt;li&gt;RBAC 相关&lt;/li&gt;
&lt;li&gt;用于 CRD 校验的 ValidatingWebhookConfiguration 对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;校验目标包含 Pilot（例如 destinationpolicies 和 routerules）和 Mixer（例如 memquotas 和 prometheuses）两类 CRD。&lt;/p&gt;
&lt;h3 id=&#34;grafana&#34;&gt;grafana&lt;/h3&gt;
&lt;p&gt;一个带有 Istio 定制 Dashboard 的 Grafana 封装。&lt;/p&gt;
&lt;p&gt;实际上将其镜像中的 Dashboard 复制出来就可以在其他 Grafana 实例上运行了。&lt;/p&gt;
&lt;p&gt;定制内容的 &lt;code&gt;grafana.ingress.*&lt;/code&gt; 中包含 Ingress 的配置，用于外网访问。&lt;/p&gt;
&lt;h3 id=&#34;ingress&#34;&gt;ingress&lt;/h3&gt;
&lt;p&gt;Istio 的 Ingress Controller&lt;/p&gt;
&lt;p&gt;具体部署内容和 egresscontroller 基本一致。&lt;/p&gt;
&lt;h3 id=&#34;ingressgateway&#34;&gt;ingressgateway&lt;/h3&gt;
&lt;p&gt;0.8.0 新增功能，为 Ingress 通信提供 Istio rules/destination 等特性。&lt;/p&gt;
&lt;p&gt;部署内容和 ingress 类似。&lt;/p&gt;
&lt;h3 id=&#34;mixer&#34;&gt;mixer&lt;/h3&gt;
&lt;p&gt;Mixer 负责的是遥测和前置检查，他的 Chart 相对比较复杂，部署内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和前面的版本不同，Mixer 的部署分成了两个部分，分别是 Policy 和 Telemetry 两个 Deployment 对象。&lt;/li&gt;
&lt;li&gt;Service 也同样分成两个，其中 telemetry service 多了一个 prometheus 端口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;crds.yaml&lt;/code&gt; 中包含了 mixer 所支持的所有 crd 定义（例如 memquotas 和 prometheuses）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;create-custom-resources-job.yaml&lt;/code&gt; 中包含了用于创建 crd 的 Job 对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pilot&#34;&gt;pilot&lt;/h3&gt;
&lt;p&gt;Pilot 承上启下，负责服务发现和向 Proxy 下发配置。除了常规的 Deployment 和 Service 之外，还包含了 &lt;code&gt;crds.yaml&lt;/code&gt;，用于声明 CRD 资源类型（例如 destinationpolicies 和 routerules）。&lt;/p&gt;
&lt;h3 id=&#34;prometheus&#34;&gt;prometheus&lt;/h3&gt;
&lt;p&gt;这个组件跟前面的 Grafana 类似，也是一个预定义的镜像。这个模板中的 Configmap 就是 Prometheus 的抓取配置，可以直接用到其他的 Prometheus 实例之中。&lt;/p&gt;
&lt;h3 id=&#34;security&#34;&gt;security&lt;/h3&gt;
&lt;p&gt;旧版本中的 Istio-ca&lt;/p&gt;
&lt;p&gt;Security 部分的部署内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RBAC&lt;/li&gt;
&lt;li&gt;Job：使用 kubectl 清理旧版本 istio-ca 实例。&lt;/li&gt;
&lt;li&gt;Deployment，原 CA。&lt;/li&gt;
&lt;li&gt;Service：开放两个端口，分别服务于 http 和 gRPC。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;servicegraph&#34;&gt;servicegraph&lt;/h3&gt;
&lt;p&gt;Service Graph 支持，和 Grafana 基本一致。&lt;/p&gt;
&lt;h3 id=&#34;sidecarinjectorwebhook&#34;&gt;sidecarInjectorWebhook&lt;/h3&gt;
&lt;p&gt;这一部分的功能是自动为 K8S 对象注入 Envoy。主要包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Deployment 和 Service&lt;/li&gt;
&lt;li&gt;RBAC 相关&lt;/li&gt;
&lt;li&gt;一个 &lt;code&gt;MutatingWebhookConfiguration&lt;/code&gt; 对象，会监听 Pod 的创建事件，用于自动注入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tracing&#34;&gt;tracing&lt;/h3&gt;
&lt;p&gt;Jeager 的跟踪支持，总体情况跟 Prometheus 和 Grafana 等监控组件类似，配置项和暴露服务方面稍有区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置中包含 Jaeger 的环境变量的控制。&lt;/li&gt;
&lt;li&gt;开启 jaeger 开关，会启用 Jaeger 的几个服务端口。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
