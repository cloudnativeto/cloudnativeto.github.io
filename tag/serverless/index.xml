<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Serverless | 云原生社区</title>
    <link>https://cloudnative.to/tag/serverless/</link>
      <atom:link href="https://cloudnative.to/tag/serverless/index.xml" rel="self" type="application/rss+xml" />
    <description>Serverless</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Mon, 08 Nov 2021 06:37:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>Serverless</title>
      <link>https://cloudnative.to/tag/serverless/</link>
    </image>
    
    <item>
      <title>Knative 1.0 发布了！</title>
      <link>https://cloudnative.to/blog/knative-1-0-ga/</link>
      <pubDate>Mon, 08 Nov 2021 06:37:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/knative-1-0-ga/</guid>
      <description>&lt;p&gt;作者：&lt;a href=&#34;https://twitter.com/csantanapr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Carlos Santana &lt;/a&gt;(IBM)、&lt;a href=&#34;https://twitter.com/omer_bensaadon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Omer Bensaadon &lt;/a&gt;(VMware)、&lt;a href=&#34;https://twitter.com/marianarra_&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maria Cruz &lt;/a&gt;(Google)，原文发布于 &lt;a href=&#34;https://knative.dev/blog/articles/knative-1.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative 官方博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;今天我们发布了 Knative 1.0，达到了一个重要的里程碑，这要归功于 600 多名开发者的贡献和合作。Knative 项目是由谷歌在 2018 年 7 月发布的，并与 VMWare、IBM、Red Hat 和 SAP 紧密合作开发的。在过去 3 年中，Knative 已经成为 &lt;a href=&#34;https://www.cncf.io/wp-content/uploads/2020/11/CNCF_Survey_Report_2020.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 上最广泛安装的无服务器层&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;最新动态&#34;&gt;最新动态&lt;/h2&gt;
&lt;p&gt;如果你没有密切关注 Knative 的发展，自从我们在 2018 年 7 月首次发布以来，已经有很多变化。&lt;/p&gt;
&lt;p&gt;除了无数的错误修复、稳定性和性能增强之外，我们的社区还按时间顺序进行了以下改进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持多个 HTTP 路由层（包括 Istio、Contour、Kourier 和 Ambassador）&lt;/li&gt;
&lt;li&gt;支持多个存储层的事件概念与常见的订阅方法（包括 Kafka、GCP PubSub 和 RabbitMQ）&lt;/li&gt;
&lt;li&gt;“鸭子类型 &amp;quot; 的抽象，允许处理具有共同字段（如 status.conditions 和 status.address）的任意 Kubernetes 资源&lt;/li&gt;
&lt;li&gt;支持额外功能插件的&lt;a href=&#34;https://knative.dev/docs/client/install-kn/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;命令行客户端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;6 周一次的定期发布流程&lt;/li&gt;
&lt;li&gt;支持 HTTP/2、gRPC 和 WebSockets&lt;/li&gt;
&lt;li&gt;Broker 和触发器，以简化事件的发布和订阅，同时将生产者和消费者解耦&lt;/li&gt;
&lt;li&gt;支持事件组件向非 Knative 组件传递，包括集群外组件或主机上的特定 URL&lt;/li&gt;
&lt;li&gt;支持自动提供 TLS 证书（通过 DNS 或 HTTP01 挑战）&lt;/li&gt;
&lt;li&gt;为活动目的地定制交付选项，包括对无法交付的信息进行重试和 dead-letter 排队&lt;/li&gt;
&lt;li&gt;对 Broker 和 Channel 的事件追踪支持，以改善调试工作&lt;/li&gt;
&lt;li&gt;由 Knative Build 催生的 &lt;a href=&#34;https://tekton.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tekton 项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;并行和序列组件，用于编纂某些复合事件的工作流程&lt;/li&gt;
&lt;li&gt;事件源的文档以及如何贡献说明，目前涵盖了大约 40 个不同的事件源&lt;/li&gt;
&lt;li&gt;“Hitless&amp;quot; 的升级，在小版本发布之间没有放弃的请求&lt;/li&gt;
&lt;li&gt;重新设计服务的 API，以匹配部署、CronJob 等使用的 PodTemplateSpec，以简化 Kubernetes 用户的使用&lt;/li&gt;
&lt;li&gt;支持将事件目的地地址注入 PodTemplateSpec 的对象中&lt;/li&gt;
&lt;li&gt;支持基于并发量或 RPS 的水平 Pod 自动扩展&lt;/li&gt;
&lt;li&gt;使用领导者选举片的控制平面组件的高可用性&lt;/li&gt;
&lt;li&gt;一个帮助管理员安装 Knative 的 Operator&lt;/li&gt;
&lt;li&gt;快速入门，供开发者在本地试用 Knative&lt;/li&gt;
&lt;li&gt;使用 DomainMapping 简化服务的管理和发布&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10-意味着什么&#34;&gt;1.0 意味着什么？&lt;/h2&gt;
&lt;p&gt;Knative 是由许多组件组成的，这些组件的版本是一起分布的。这些组件有不同的成熟度，从 “实验性 &amp;quot; 到 “已经 GA”(Generally Available)。我们仍然希望保持版本的同步，因此决定将所有的组件转移到 1.0 版本。GA 级别会单独标记组件。&lt;/p&gt;
&lt;h3 id=&#34;为什么要一次把所有的组件移到-10&#34;&gt;为什么要一次把所有的组件移到 1.0？&lt;/h3&gt;
&lt;p&gt;两个原因：一个是面向用户的，一个是面向贡献者的。主要是面向用户的原因是，它给用户提供了一个单一的数字，让他们在了解他们所安装的东西和哪些东西可以一起使用时，可以挂在上面。次要的面向贡献者的原因是，我们所有的基础设施都是为了管理一个单一的版本号而设计的，更新它以支持多个版本号似乎不是很好地利用时间。&lt;/p&gt;
&lt;h3 id=&#34;一个组件既是-10-又是-beta-岂不是很混乱吗&#34;&gt;一个组件既是 “1.0&amp;quot; 又是 “Beta” 岂不是很混乱吗？&lt;/h3&gt;
&lt;p&gt;除非我们等待与 Knative 有关的所有事情都完成，否则我们总会有一些组件或功能处于 alpha 或 beta 状态。虽然这种情况有时会沿着组件的边界发生，但它也可能发生在一个组件内部，所以版本号不能作为 “GA 与否 &amp;quot; 的唯一指标。(这种情况也发生在其他项目上，如 Kubernetes，以及 Serving 或 Eventing 中的特定功能）。&lt;/p&gt;
&lt;p&gt;展望未来，该项目将清楚地了解各种组件或功能的成熟度，并将功能沿着 GA 或退役的路线移动。&lt;/p&gt;
&lt;h2 id=&#34;了解更多&#34;&gt;了解更多&lt;/h2&gt;
&lt;p&gt;Knative 指导委员会成员 Ville Aikas 是&lt;a href=&#34;https://kubernetespodcast.com/episode/166-knative-1.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;本周谷歌 Kubernetes 播客的嘉宾&lt;/a&gt;，他讲述了该项目创建的故事以及它的 1.0 之旅。你也可以参加 &lt;a href=&#34;https://calendar.google.com/calendar/u/0/r/eventedit/NnAycjJyZmdlMTF1b2FuOGJzZjZ1dXA0aTZfMjAyMTExMjRUMTczMDAwWiBrbmF0aXZlLnRlYW1fOXE4M2JnMDdxczViOXJyc2xwNWpvcjRsNnNAZw?tab=mc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;11 月 17 日的 Knative 社区聚会&lt;/a&gt;，届时 Ville 将谈论项目的最新变化。&lt;/p&gt;
&lt;h2 id=&#34;参与其中&#34;&gt;参与其中&lt;/h2&gt;
&lt;p&gt;Knative 社区随时欢迎新成员的加入。&lt;a href=&#34;https://slack.knative.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;加入 Knative Slack 空间&lt;/a&gt;，在熟悉项目的过程中提出问题并排除故障。最后，在 Knative 网站上找到所有的&lt;a href=&#34;https://knative.dev/docs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;项目文档&lt;/a&gt;，并&lt;a href=&#34;https://github.com/knative&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 GitHub 上为该项目做出贡献&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;感谢我们的贡献者&#34;&gt;感谢我们的贡献者&lt;/h2&gt;
&lt;p&gt;实现这一里程碑确实是一个社区的努力–我们不能不感谢一些帮助我们走到今天的人。感谢…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持 Knative 的公司，包括：
&lt;ul&gt;
&lt;li&gt;谷歌（他们还赞助了我们的网站和测试基础设施，并每月举办社区聚会）&lt;/li&gt;
&lt;li&gt;IBM&lt;/li&gt;
&lt;li&gt;红帽&lt;/li&gt;
&lt;li&gt;SAP&lt;/li&gt;
&lt;li&gt;TriggerMesh&lt;/li&gt;
&lt;li&gt;VMWare&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://knative.teststats.cncf.io/d/5/companies-table?orgId=1&amp;amp;var-period_name=Last_decade&amp;amp;var-metric=contributions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以及更多&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;我们的&lt;a href=&#34;https://github.com/knative/community/blob/main/TECH-OVERSIGHT-COMMITTEE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;技术监督委员会&lt;/a&gt;、&lt;a href=&#34;https://github.com/knative/community/blob/main/STEERING-COMMITTEE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;指导委员会&lt;/a&gt;和&lt;a href=&#34;https://github.com/knative/community/blob/main/TRADEMARK-COMMITTEE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;商标委员会&lt;/a&gt;的成员&lt;/li&gt;
&lt;li&gt;所有 Knative 的贡献者，过去和现在的&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Solo.io打造的Gloo——Knative中Istio的替代方案</title>
      <link>https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/</link>
      <pubDate>Thu, 16 May 2019 12:20:44 +0800</pubDate>
      <guid>https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/solo-io/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative-324753586f3a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;[编者按]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;之前有社区成员询问是不是想尝试Knative时，必须要安装Istio才行，今天就告诉大家一种Istio的替代方案，使用Solo.io公司研发的Gloo来替代Istio来使用Knative。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;在Knative中，Istio的主要作用是作为一个Ingress技术。Gloo现在加入Istio作为Knative的集成和支持Ingress。有关快速演示demo，请参阅文章末尾。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，&lt;a href=&#34;https://github.com/knative/docs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative的存在&lt;/a&gt;是为了定义在&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;上构建和服务化工作负载的一套标准方法。Knative的一个显著特性是它的serverless特性：它将工作负载的执行与事件关联起来，而只在此类事件发生时消耗计算能力（事件驱动）。&lt;/p&gt;
&lt;p&gt;Knative是最初在谷歌创建，现在已与Pivotal、Red Hat、SAP、IBM等许多公司联合开发的开源协作技术。&lt;/p&gt;
&lt;h2 id=&#34;使用knative服务处理请求&#34;&gt;使用Knative服务处理请求&lt;/h2&gt;
&lt;p&gt;让我们简要了解一下Knative如何处理请求，以及它与“纯”Kubernetes的比较。&lt;/p&gt;
&lt;p&gt;Kubernetes上的&lt;em&gt;传统&lt;/em&gt;工作负载，比如web应用程序，需要一个运行的Pod和一个Ingress，以允许流量从其他集群流入到当前集群。&lt;/p&gt;
&lt;p&gt;现在，通过Knative的视角，让我们考虑下面的示例：有如下一个场景，客户端希望从一个在Knative平台上注册但不一定立即运行的应用程序中检索天气预报信息。使用Knative术语，有一个服务可以创建必要的配置和路由，以便在调用天气预报应用程序时运行它。在Knative上下文中，应用程序包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/spec/spec.md#service&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Service&lt;/a&gt;（不要与Kubernetes Service对象混淆）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/spec/spec.md#route&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Route&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/spec/spec.md#configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Configuration&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个或多个&lt;a href=&#34;https://github.com/knative/serving/blob/master/docs/spec/spec.md#revision&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative Revision&lt;/a&gt;，运行时，Revision会变成Kubernetes Pod。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu8b8feffdb7437aba10b7738dce37ed90_17607_c739631f7042ad0cf5b0f88eeab2cca2.webp 400w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu8b8feffdb7437aba10b7738dce37ed90_17607_896e1a773019d5ab105a8445b502a76d.webp 760w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu8b8feffdb7437aba10b7738dce37ed90_17607_80a77e2587113afb0dbbf5f8c8c88439.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu8b8feffdb7437aba10b7738dce37ed90_17607_c739631f7042ad0cf5b0f88eeab2cca2.webp&#34;
               width=&#34;624&#34;
               height=&#34;176&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;深入到流量管理部分，Knative service有一个名为&lt;a href=&#34;https://github.com/knative/serving/tree/master/pkg/activator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Activator&lt;/a&gt;的组件，它负责报告某个工作负载需要运行相应数量的pod来处理请求。&lt;/p&gt;
&lt;p&gt;这种架构的美妙之处在于，如果负责运行应用程序的Pod没有运行，那么请求将被搁置，直到流量可以路由到一个或多个pod为止。这优化了资源利用率。&lt;/p&gt;
&lt;p&gt;如果您想知道，还有一些特性允许您预热应用程序，这样就不会阻塞任何请求。这使您能够对是否始终保持Pod运行做出明智的决策。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu84784781ccc78ef8c1fe3d2bdbf7c777_34231_6a9ff245ff18ce6ac15dd8af4772ec90.webp 400w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu84784781ccc78ef8c1fe3d2bdbf7c777_34231_4f0725462826a2684d7bc1bc1f8e54e2.webp 760w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu84784781ccc78ef8c1fe3d2bdbf7c777_34231_cef23d43ecf4f480c6eb77989c9c1367.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu84784781ccc78ef8c1fe3d2bdbf7c777_34231_6a9ff245ff18ce6ac15dd8af4772ec90.webp&#34;
               width=&#34;624&#34;
               height=&#34;378&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如前所述，一旦有一个修订（一个或多个Pod）来处理请求，流量就可以从Ingress网关流到您的修订。Knative Serving将继续收到请求的通知，以便确定是否需要对服务于修订的Pod进行伸缩。这真的太棒了!&lt;/p&gt;
&lt;h2 id=&#34;istio的必要性&#34;&gt;Istio的必要性&lt;/h2&gt;
&lt;p&gt;请求可能需要路由到相同配置的不同版本(请阅读工作负载规范)，特别是在同时运行同一应用程序的不同版本的情况下。为了做到这一点，Knative需要一个可以执行以下功能的Ingress控制器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;流量分流&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TLS终止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于Header路由&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;追加Header&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Solo.io拥抱&lt;a href=&#34;https://istio.io/zh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;。我们已经投资构建了一个名为&lt;a href=&#34;https://github.com/solo-io/supergloo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SuperGloo&lt;/a&gt;的服务网格编排器和管理平台，这可能是开始使用Istio的最简单方法。就我个人而言，我也很喜欢Istio。在红帽的时候，我参与了这个项目的&lt;a href=&#34;https://blog.openshift.com/red-hat-istio-launch/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;正式启动&lt;/a&gt;，并&lt;a href=&#34;https://www.infoworld.com/article/3273547/the-rise-of-the-istio-service-mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;写下&lt;/a&gt;了为什么Istio如此受欢迎。&lt;/p&gt;
&lt;p&gt;但如果我诚实地评价Istio在Knative上的角色，我的感觉是：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu0ff703ec26179ab22d1d2ecde3171989_18831_c257a68a676cf3e6c8052328bf512672.webp 400w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu0ff703ec26179ab22d1d2ecde3171989_18831_e5c60560fa0111d19a1d18c63eb9cb08.webp 760w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu0ff703ec26179ab22d1d2ecde3171989_18831_30a11665b3d36f7c0d624b785d5df908.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_hu0ff703ec26179ab22d1d2ecde3171989_18831_c257a68a676cf3e6c8052328bf512672.webp&#34;
               width=&#34;624&#34;
               height=&#34;177&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Istio提供了一组令人惊讶的特性，但是Knative只使用了其中的一些。作为参考，Istio目前有48个CRD （CustomResourceDefinition对象），其中只有一个主要由Knative（VirtualService）使用。&lt;/p&gt;
&lt;p&gt;现在，如果您的组织也愿意采用服务网格技术，并且Istio是您的选择，那么这种痛苦肯定会减少。为此，您必须熟悉或已经熟悉Istio的工作原理。现在对于许多用户来说，增加的复杂性可能不值得。&lt;/p&gt;
&lt;h2 id=&#34;gloo下一代通用api网关作为网关服务&#34;&gt;Gloo——下一代通用API网关，作为网关服务。&lt;/h2&gt;
&lt;p&gt;Gloo是下一代API网关，它既满足Knative的需求，又不会带来成熟服务网格技术(Istio就是这种情况)的不必要包袱。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_huc67c83c46f00a70d7b5e5e86be23706d_11173_f1e7a088829dcfa2a969361011e84c41.webp 400w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_huc67c83c46f00a70d7b5e5e86be23706d_11173_4032fcf9bf494e21112497fe31404d9f.webp 760w,
               /blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_huc67c83c46f00a70d7b5e5e86be23706d_11173_7645e8a942107931fd8961f1a9f434db.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/gloo-by-solo-io-is-the-first-alternative-to-istio-on-knative/_huc67c83c46f00a70d7b5e5e86be23706d_11173_f1e7a088829dcfa2a969361011e84c41.webp&#34;
               width=&#34;317&#34;
               height=&#34;135&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;建立在Envoy之上，&lt;a href=&#34;https://knative.dev/docs/install/knative-with-gloo/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;是Knative第一个官方的Istio替代品&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但这在现实中意味着什么呢?当我们决定对这个解决方案投入精力时，我们的主要目标之一就是解决方案的可持续性。当一个新版本出现时，一起工作的项目突然停止工作，这肯定会令人沮丧，我们的集成工作主要集中在三个方面：易用性、实现和持续集成。&lt;/p&gt;
&lt;h2 id=&#34;易用性&#34;&gt;易用性&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;作为一家公司的一个关键任务是为了弥合先进的开源技术与使用这种技术的企业和用户之间的差距。在这种程度上，我们在&lt;a href=&#34;https://knative.dev/docs/install/knative-with-gloo/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用Gloo时改进了Knative本身的安装&lt;/a&gt;。整个社区可以立即受益于一种更简单的实验和生产方式。&lt;/p&gt;
&lt;p&gt;流行的&lt;code&gt;glooctl&lt;/code&gt;命令现在包含一个Knative选项，该选项&lt;a href=&#34;https://gloo.solo.io/installation/#2c-install-the-gloo-knative-cluster-ingress-to-your-kubernetes-cluster-using-glooctl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不仅安装Gloo网关本身而且还将安装Knative&lt;/a&gt;（！！！）。在安装过程中，Knative配置了&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;作为集群Ingress网关，它使用一个命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ glooctl install knative
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;虽然这是一个显而易见的问题，但我们创建了必要的控制和监视，以便&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;能够在Istio Ingress运行时在相同或更好的容量水平上运行和报告。大部分工作都是在Gloo上完成的。在技术层面，Gloo得到了扩展，包括基于Knative ClusterIngress CRD读取和应用配置的能力。&lt;/p&gt;
&lt;h2 id=&#34;持续集成&#34;&gt;持续集成&lt;/h2&gt;
&lt;p&gt;我们在&lt;a href=&#34;https://github.com/knative/serving/pull/3087&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative&lt;/a&gt;的CI测试流水线中实现并引入了特定的Gloo测试，这意味着如果Knative中的一个更改破坏了与Gloo的集成，反之亦然，那么社区将得到通知并根据情况采取相应的行动。这为任何正在寻找Knative上的Istio的替代方案的人提供了可能，在撰写本文时，Knative是唯一的替代方案。&lt;/p&gt;
&lt;h2 id=&#34;立刻行动吧&#34;&gt;立刻行动吧！&lt;/h2&gt;
&lt;p&gt;如果您能够访问Kubernetes集群，只需&lt;a href=&#34;https://github.com/solo-io/gloo/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;下载&lt;/a&gt;最适合您的操作系统的&lt;code&gt;glooctl&lt;/code&gt;版本，然后立即开始您的Knative（和&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;）之旅。我们最近也增加了对Windows的支持。要获得更多帮助，请查看我们的Knative特定&lt;a href=&#34;https://gloo.solo.io/installation/#2c-install-the-gloo-knative-cluster-ingress-to-your-kubernetes-cluster-using-glooctl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;并加入我们的&lt;a href=&#34;http://slack.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slack&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Gloo可以做的不仅仅是基本的Ingress路由。Gloo被设计为下一代API网关，能够理解功能级别的调用(HTTP1、HTTP2、gRPC、REST/OpenAPISpec、SOAP、WebSockets、Lambda/Cloud函数)，并能够帮助您从单一功能到微服务和serverless的演进。参加我们的&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络研讨会&lt;/a&gt;，我们将讨论如何渐进地、安全地发展您的应用程序架构，以利用新功能来满足您的业务需求，而不必对您的单体应用进行危险的更改。&lt;/p&gt;
&lt;h2 id=&#34;观看介绍视频&#34;&gt;观看介绍视频&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=_e61MB2Afvs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.youtube.com/watch?v=_e61MB2Afvs&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>选择FaaS还是微服务？</title>
      <link>https://cloudnative.to/blog/faas-vs-microservices/</link>
      <pubDate>Tue, 09 Apr 2019 22:42:29 +0800</pubDate>
      <guid>https://cloudnative.to/blog/faas-vs-microservices/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://dzone.com/articles/faas-vs-microservices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在做项目的云原生改造时我们可以采用微服务架构。DevOps和自动化构建两方面的成功经验对微服务的实践很有帮助。经过一段时间的实践，你可能会有将微服务架构推广到其他部门的想法。而你担心微服务本身的复杂性和分布式系统的高维护成本会让其他部门难以接受它。可能在我们想方设法解决微服务带来的问题时，总会有些人觉得这样做毫无意义。因为现在技术发展如此之快，总会出现更好的技术方案，你能保证自己在微服务领域所做的工作最后没有白费吗？&lt;/p&gt;
&lt;p&gt;我认为不会白费！&lt;/p&gt;
&lt;p&gt;现在“serverless”和“functions-as-a-service”（FAAS）还处于早期的炒作阶段。有些人觉得serverless就是下一代的微服务，所以我们应该跳过当前的微服务模式而直接采用serverless。其实这种说法是有点夸大其词。作为架构师或开发者，我们通过学习新技术来提升自身能力让自己变得更&amp;quot;值钱&amp;quot;并没有错。但我们也要以务实态度来判断是否应该采用新技术。虽然持续跟进最新技术是我们作为架构师的职责所在，但掌握在之前的产品和IT部门引用新技术的时机也很重要。我们可以通过下面的模块来理解微服务架构和serverless，从而让它们可以更好的融入我们的技术栈。&lt;/p&gt;
&lt;p&gt;首先，我们需要知道为什么我们需要微服务。选用微服务架构的主要原因就是避免项目的体量阻碍产品的迭代，所有微服务其他的优势都是基于这点。更快的迭代速度意味着可以更快的为客户交付新功能/修改，从而更快的验证这些改动能够带来的效果。我们需要快速的知道自己所做的努力是否能够带来好的效果，如果不能就要马上调整方向。快速迭代就是微服务架构的核心优势。&lt;/p&gt;
&lt;p&gt;对于大多数的团队而言，至少有一部分应用能从微服务的迭代过程中获益。因此作为架构师或开发者，我们不要因为采用微服务有门槛就对其失去信心。实践微服务的重要步骤就是确定和测量改进指标。改进指标一般可以为每天迭代应用的次数、保证迭代应用稳定性的方法等。&lt;/p&gt;
&lt;p&gt;另一方面，不是所有的应用都需要用这种松散而复杂的方式来保证服务的迭代速度。如果只想简单做个应用来验证自己创意的商业价值，那你完全可以选择更加适合的架构。这时采用MVP测试（最小可行性测试）就是个很好的方案。如果你因为商业价值很低而打算放弃的话，那也只是放弃了一个MVP应用。你可以非常快的迭代它并从潜在的用户中获得反馈。在这种情况下，你可能需要根据反馈反复修改API、功能边界、组件等。所以过早就将组件功能做成分布式的服务也会拖慢产品的发布速度。你想修改分布式组件和它的api就必须在各个团队间进行协调。&lt;/p&gt;
&lt;p&gt;上述观点能够反映出微服务架构和单体架构适用不同的场景。而事实上并没有所谓&amp;quot;一招鲜吃遍天“的方案。当我们在微服务架构和单体架构之间纠结时，还需要考虑到所需服务是否已经存在以及它提供服务的方式（第三方服务/公司内部服务）。我们完全可以充分利用当前已有服务来构建我们的应用，不必重新购买硬件、安装和修补操作系统，以及优化服务从而达到最高吞吐量，而这也正是云及其服务存在的意义。云供应商和他们的合作伙伴能提供数据库、消息队列、缓存、CDN和其他更高级的功能： 例如语言翻译、地图/地理空间地图、天气等。我们可以组合各种按量付费的服务来构建自己的应用。如果在使用某个服务的时候无需关心安装、参数和容量等问题，其实我们就已经在采用serverless架构了。serverless架构的特点就是可以重用已经存在的service，而无需关心运行服务需要消耗些什么。&lt;/p&gt;
&lt;p&gt;函数即服务和serverless具有某种联系，因为它利用了缩小到单个应用程序函数的范围的计算模型，而这有助于将各种服务组合在一起构建应用。在这种模型下，功能按需分解，你只需为使用的功能付费。它特别适合对我们使用的服务进行按需计费和按量付费。这样一来我们能够构建弹性应用，而不需要考虑复杂的技术问题。将这些复杂的技术问题外包给别人可以让你更专注于为客户提供商业价值。&lt;/p&gt;
&lt;p&gt;但是将这部分能力外包不总是可行的。如果选择云服务，我们就丧失了对程序运行时、具体功能、bug修复和接受监管的控制力。这也是需要考虑的一部分。&lt;/p&gt;
&lt;p&gt;serverless不一定是完整的“公有云或无云”方案。如果以单个组织的角度来看，&amp;ldquo;serverless&amp;quot;可能只是代表整个体系的其他部分。例如：零售业务可以为组织内部其他服务或第三方提供“购买“服务以支持诸如分析、推荐以及其他使用“购买”服务的应用。利用定义良好的API和订阅并消费API的工作负载，你可以在自己的基础设施为微服务应用或单体应用提供serverless能力。在很多时候这其实就是服务向SOA架构进化的方向。但它们之间最大的不同就是在你将组织看作一个整体时，自己给自己的其他部分提供服务并不算serverless。因为此时还是需要自己手动的去安装、管理和更新应用。&lt;/p&gt;
&lt;p&gt;最终采用哪种方案其实取决于很多因素，例如：业务、商业目标、软件部门对该技术的熟练度和历史遗留问题等。如果你觉得应该采用微服务架构，那就不要因为其他新技术而分心。我们可以持续跟进最新技术，从而保证适时的采用它们。总的来讲，不管是微服务架构、单体架构还是serverless架构，它们都有自己的应用场景。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes 的无服务器框架的评估</title>
      <link>https://cloudnative.to/blog/evaluation-of-serverless-frameworks-for-kbe/</link>
      <pubDate>Thu, 08 Nov 2018 13:20:46 +0800</pubDate>
      <guid>https://cloudnative.to/blog/evaluation-of-serverless-frameworks-for-kbe/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtshzvvdnj20m808ct8v_hu22ad58426a2a97b3467e99d1a1802ff2_34114_dd721725b11a650eda096d09c71247e9.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtshzvvdnj20m808ct8v_hu22ad58426a2a97b3467e99d1a1802ff2_34114_7d730f5c10b1c6e1e28f9be1d301f03c.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtshzvvdnj20m808ct8v_hu22ad58426a2a97b3467e99d1a1802ff2_34114_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtshzvvdnj20m808ct8v_hu22ad58426a2a97b3467e99d1a1802ff2_34114_dd721725b11a650eda096d09c71247e9.webp&#34;
               width=&#34;760&#34;
               height=&#34;285&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://rancher.com/blog/2018/2018-04-23-evaluation-of-serverless-frameworks-for-kbe/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Rancher 1.6和Rancher 2.0底层容器编排引擎的术语和概念略微有所不同。想要了解这些差异就需要先了解Cattle和Kubernetes之间的根本区别。对于使用过Cattle或者Kubernetes的新手来说，这篇文章比较适合您。同时你也可以从这里获取到容器编排引擎 Cattle 到 Kubernetes 的对应关系词汇表cheatsheet。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://rancher.com/tags/serverless&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;无服务器&lt;/a&gt; &lt;a href=&#34;https://rancher.com/tags/kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubernetes&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在Pokemon Go的早期，我们都惊讶于Niantic如何在全球范围内扩展其用户群，现在看来他们应该是以无缝地向其容器集群添加额外的节点以容纳更多的玩家和环境，所有这一切都可以通过使用Kubernetes作为容器编排工具来实现。Kubernetes在扩展和管理容器基础架构中，能够从开发者角度抽象出部分过程和低级依赖关系。这使它成为一个非常有效的平台，用于开发和维护跨多个容器的应用程序服务。本文将探讨如何利用K8S的设计参数和服务编排功能，并将它们与无服务器框架和函数即服务（FaaS）结合起来。特别是，我们将深入研究其特性和功能，分析在K8s架构上构建的三个无服务器框架的运行性能和效率：（i）Fission; （ii）OpenFaaS; （iii）Kubeless。&lt;/p&gt;
&lt;h2 id=&#34;a-为什么kubernetes是无服务器的优秀编排系统&#34;&gt;A. 为什么Kubernetes是无服务器的优秀编排系统？&lt;/h2&gt;
&lt;p&gt;无服务器体系结构指的是从开发人员中抽象出服务器管理任务的应用程序体系结构，并通过动态分配和管理计算资源来提高开发速度和效率。函数即服务（FaaS）是一个运行时被构建的无服务架构，可以在其上构建无服务器体系结构。FaaS框架作为短暂的容器运行，它们已经安装了公共语言运行时，并允许在这些运行时内执行代码。&lt;/p&gt;
&lt;p&gt;FaaS框架应该能够在各种基础架构上运行，以实现真正有用，包括公共云，混合云和内部部署环境。在真实生产环境中基于FaaS运行时构建的无服务器框架应该能够依靠经过验证和测试的编排和管理功能来大规模部署容器和分布式工作负载。&lt;/p&gt;
&lt;p&gt;对于编排和管理，无服务器FaaS框架依赖Kubernetes，因为它能够：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨主机群集编排容器。&lt;/li&gt;
&lt;li&gt;最大化程度的利用企业应用程序所需的硬件资源。&lt;/li&gt;
&lt;li&gt;管理和自动化应用程序部署并提供声明式更新。&lt;/li&gt;
&lt;li&gt;通过挂载存储运行有状态应用程序。&lt;/li&gt;
&lt;li&gt;秒级扩容容器化应用程序并提供支持它们的资源。&lt;/li&gt;
&lt;li&gt;声明式地管理服务。&lt;/li&gt;
&lt;li&gt;提供一个大盘，来检查应用的健康情况，并通过自动重启，自动复制和自动缩放来进行应用程序的自我修复。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn1842j20ao07idgj_hue0bfad4f44901d513adfe8160b3cba5c_67236_c8b67ae09ca932d1f31b8c2bc23503de.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn1842j20ao07idgj_hue0bfad4f44901d513adfe8160b3cba5c_67236_45b5398385c5815c70430ec57acfc8c3.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn1842j20ao07idgj_hue0bfad4f44901d513adfe8160b3cba5c_67236_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn1842j20ao07idgj_hue0bfad4f44901d513adfe8160b3cba5c_67236_c8b67ae09ca932d1f31b8c2bc23503de.webp&#34;
               width=&#34;384&#34;
               height=&#34;270&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;无服务器系统可以包括通过客户端请求触发的功能或作为业务服务的一部分执行的功能这两个过程都可以使用容器集群管理器如kubernetes进行编排资料来源dzonecom&#34;&gt;无服务器系统可以包括通过客户端请求触发的功能或作为业务服务的一部分执行的功能。这两个过程都可以使用容器集群管理器（如Kubernetes）进行编排。资料来源：dzone.com&lt;/h4&gt;
&lt;p&gt;我们将在本文中介绍三个无服务器框架各自的优点和缺点。这些FaaS框架之间的共同点是，它们能够（1）将函数转化为服务; （2）利用Kubernetes平台管理这些服务的生命周期。这些框架背后的设计，会由于其用于实现的具体方式的不同而有差异，我们将在下一节中探讨。我们将在以下部分中重点介绍这些框架之间的一些差异：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;框架是在源码级别或Docker镜像级别还是在中间运行，例如buildpacks？&lt;/li&gt;
&lt;li&gt;由于使用公共语言运行库启动容器，冷启动性能的延迟或执行函数期间的延迟分别是多少？&lt;/li&gt;
&lt;li&gt;它们如何为服务分配内存或资源？&lt;/li&gt;
&lt;li&gt;它们如何访问和部署Kubernetes的编排和容器管理功能？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;b-openfaas和部署spring-boot模板&#34;&gt;B. OpenFaaS和部署Spring Boot模板&lt;/h2&gt;
&lt;p&gt;OpenFaaS是一个无服务器平台，允许使用Docker或Kubernetes管理函数，因为它是基于OCI格式的容器。OpenFaaS可以支持企业级扩展的功能，如Docker Universal Control Plane企业级集群管理解决方案与Docker Enterprise或Tectonic for Kubernetes。OpenFaaS继承了现有的容器安全功能，例如r/o文件系统，权限下降和内容信任。它能够使用Docker或K8s调度程序/容器编排的管理功能，并且可以使用其相关的丰富的商业和社区供应商生态系统。同样，由于其多语言特性，任何可执行文件都可以打包到OpenFaas中的函数中。&lt;/p&gt;
&lt;p&gt;SpringBoot和Vertx是开发微服务的非常流行的框架，它们的易用性已经通过OpenFaaS模板扩展到OpenFaaS。这些模板允许在OpenFaaS平台上无缝地开发和部署无服务器函数。模板在&lt;a href=&#34;https://github.com/tmobile/faas-java-templates&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;的github存储库中可用。让我们来看看如何在OpenFaaS平台上部署SpringBoot模板。&lt;/p&gt;
&lt;h3 id=&#34;在本地安装openfaas&#34;&gt;在本地安装OpenFaaS&lt;/h3&gt;
&lt;h4 id=&#34;在本地计算机上下载和安装模板&#34;&gt;在本地计算机上下载和安装模板&lt;/h4&gt;
&lt;p&gt;我们需要安装和配置FaaS CLI以与本地或远程K8S或Docker配合使用。在本练习中，我们将使用本地Docker客户端，并在后续工作中将其扩展到基于云的GKE集群。&lt;/p&gt;
&lt;p&gt;对于最新版本的CLI类型：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ curl -sL https://cli.openfaas.com | sudo sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;[或通过MacOS上的brew install faas-cli。]&lt;/p&gt;
&lt;p&gt;使用以下命令验证本地安装的模板：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;faas-cli new --list&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在我们创建无服务器函数之前，我们必须在本地计算机上安装这些模板。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; faas-cli template pull https://github.com/tmobile/faas-java-templates.git
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;查看帮助菜单&#34;&gt;查看帮助菜单&lt;/h4&gt;
&lt;p&gt;可以为所有命令调用-help标志。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ faas-cli --help&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从命令行管理您的OpenFaaS功能&lt;/p&gt;
&lt;p&gt;用法： &lt;code&gt;faas-cli&lt;/code&gt; [flags] &lt;code&gt;faas-cli&lt;/code&gt; [command]&lt;/p&gt;
&lt;p&gt;可用命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;build&lt;/code&gt; 构建OpenFaaS功能容器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deploy&lt;/code&gt; 部署OpenFaaS功能&lt;/p&gt;
&lt;p&gt;&lt;code&gt;help&lt;/code&gt; 有关任何命令的帮助&lt;/p&gt;
&lt;p&gt;&lt;code&gt;push&lt;/code&gt; 将OpenFaaS功能推送到远程仓库（Docker Hub）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;remove&lt;/code&gt; 删除已部署的OpenFaaS功能&lt;/p&gt;
&lt;p&gt;&lt;code&gt;version&lt;/code&gt; 显示客户端版本信息&lt;/p&gt;
&lt;p&gt;参数： &lt;code&gt;-h&lt;/code&gt;，&lt;code&gt;--help&lt;/code&gt; 帮助FAAS-CLI &lt;code&gt;-f&lt;/code&gt;，&lt;code&gt;--yaml string&lt;/code&gt; 描述函数的yaml文件的路径&lt;/p&gt;
&lt;p&gt;有关命令的更多信息，请使用 &lt;code&gt;faas-cli&lt;/code&gt; [command] &lt;code&gt;--help&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;用已安装的模板创建函数&#34;&gt;用已安装的模板创建函数&lt;/h4&gt;
&lt;p&gt;使用来自Vertx/SpringBoot模板的github存储库中我们感兴趣的函数，我们可以创建一个函数（用我们的函数替换大括号内的文本，我们使用springboot但你可以用vertx模板代替它）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;faas-cli new {function of function} --lang springboot&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用mvnw，命令是&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;faas-cli new mvnw --lang vertx | springboot 
Folder: mvnw created.
Function created in folder: mvnw 
Stack file written: mvnw.yml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;mvnw.yml的内容现在可以与CLI一起使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果您的群集是远程的或未在8080端口上运行 - 请在继续之前在YAML文件中对其进行编辑。为我们的函数生成了handler.java文件。您可以编辑pom.xml文件，并在“build”步骤中安装所有依赖项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;构建函数&#34;&gt;构建函数&lt;/h4&gt;
&lt;p&gt;现在我们已经创建了函数逻辑，我们可以使用faas cli build命令构建函数。我们将使用本地Docker客户端将该函数构建到docker镜像中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ faas-cli build -f mvnw.yml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Building: mvnw.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Clearing temporary build folder: ./build/mvnw/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Preparing ./mvnw/ ./build/mvnw/function
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Building: mvnw with node template. Please wait..
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker build -t mvnw .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Sending build context to Docker daemon  8.704kB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Step 1/19 : FROM node:6.11.2-alpine
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; 16566b7ed19e
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Step 19/19 : CMD fwatchdog
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; Running in 53d04c1631aa
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; ---&amp;gt; f5e1266b0d32
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Removing intermediate container 53d04c1631aa
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Successfully built f5e1266b0d32
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Successfully tagged mvnw:latest
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Image: mvnw built.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;推送您的函数可选因为我们正在进行本地安装&#34;&gt;推送您的函数（可选，因为我们正在进行本地安装）&lt;/h4&gt;
&lt;p&gt;为了部署我们的函数，我们将编辑mvnw.yml文件并将“image”行设置为Docker Hub上适用的用户名，例如：hishamhasan/mvnw。然后我们将再次构建该函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ faas-cli push -f mvnw.yml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Pushing: mvnw to remote repository.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;The push refers to a repository &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;docker.io/hishamhasan/mvnw&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完成此操作后，镜像将被推送到Docker Hub或远程Docker registry，我们可以部署并运行该函数。&lt;/p&gt;
&lt;h4 id=&#34;部署函数&#34;&gt;部署函数&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ faas-cli deploy -f mvnw.yml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Deploying: mvnw.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;No existing service to remove
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Deployed.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;URL: &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;http://localhost:8080/function/mvnw&lt;span class=&#34;o&#34;&gt;](&lt;/span&gt;http://localhost:8080/function/mvnw&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;调用函数&#34;&gt;调用函数&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
$ faas-cli invoke -f mvnw.yml callme
Reading from STDIN - hit (Control + D) to stop.
This is my message

{&amp;#34;status&amp;#34;:&amp;#34;done&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们还可以将命令传递给函数，例如:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ date | faas-cli invoke -f mvnw.yml mvnw
{&amp;#34;status&amp;#34;:&amp;#34;done&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;在google-cloud-platform上安装openfaas&#34;&gt;在Google Cloud Platform上安装OpenFaaS&lt;/h3&gt;
&lt;p&gt;在使用OpenFaaS时，我们不限于任何本地或云基础架构。现在我们已经在本地Docker集群中部署了模板，我们可以通过在GCP中的GKE上设置它来利用OpenFaaS的多功能性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个名为的GCP项目&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/sdk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在此处&lt;/a&gt; 下载并安装Google Cloud SDK。安装SDK后，运行gcloud init，然后将默认项目设置为openfaas。&lt;/li&gt;
&lt;li&gt;使用gcloud安装kubectl： &lt;code&gt;gcloud components install kubectl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;导航到API Manager&amp;gt;凭据&amp;gt;创建凭据&amp;gt;服务帐户密钥。&lt;/li&gt;
&lt;li&gt;选择JSON作为密钥类型。将文件重命名为json并将其放在项目中&lt;/li&gt;
&lt;li&gt;添加刚刚在ComputeEngine&amp;gt; Metadata&amp;gt; SSH Keys下创建的SSH密钥，并使用您的公共SSH密钥作为值创建名为sshKeys的元数据条目。&lt;/li&gt;
&lt;li&gt;创建一个三节点Kubernetes集群，每个节点位于不同的区域中。在&lt;a href=&#34;https://kubernetes.io/docs/concepts/cluster-administration/federation/#selecting-the-right-number-of-clusters&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此处&lt;/a&gt; 阅读 有关群集联合的信息，以了解如何选择每个群集中的群集数和节点数，这些群集可能会根据负载或增长频繁更改。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;k8s_version&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;gcloud container get-server-config --format&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;json &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; jq -r &lt;span class=&#34;s1&#34;&gt;&amp;#39;.validNodeVersions[0]&amp;#39;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gcloud container clusters create demo &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --cluster-version&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;k8s_version&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --zone&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;us-west1-a &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --additional-zones&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;us-west1-b,us-west1-c &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --num-nodes&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --machine-type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;n1-standard-2 &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --scopes&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;default,storage-rw
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将默认节点池的大小增加到所需的节点数（在此示例中，我们将按比例增加3到9个节点）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcloud container clusters resize --size=3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;您可以通过调用此 &lt;a href=&#34;https://cloud.google.com/sdk/gcloud/reference/container/clusters/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;页面中&lt;/a&gt; 所述的合适的SDK命令来执行集群管理功能，例如删除集群。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcloud container clusters delete demo -z=us-west1-a&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;完整的管理设置&#34;&gt;完整的管理设置&lt;/h3&gt;
&lt;p&gt;设置kubectl的凭据：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcloud container clusters get-credentials demo -z=us-west1-a&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;创建集群管理员用户：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl create clusterrolebinding &lt;span class=&#34;s2&#34;&gt;&amp;#34;cluster-admin-&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;whoami&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--clusterrole&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cluster-admin &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--user&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;gcloud config get-value core/account&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;授予kubernetes-dashboard管理员权限（确保在非生产环境中完成）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl create clusterrolebinding &lt;span class=&#34;s2&#34;&gt;&amp;#34;cluster-admin-&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;whoami&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--clusterrole&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;cluster-admin &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--user&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;gcloud config get-value core/account&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您可以通过使用kubectl反向代理在浏览器（或在 &lt;a href=&#34;http://localhost:9099/ui&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http//localhost:9099/ui&lt;/a&gt; ）上调用 &lt;code&gt;kubectl proxy --port=8080&lt;/code&gt; 和导航到 &lt;a href=&#34;http://localhost:8080/ui&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http//localhost:8080/ui&lt;/a&gt; 来访问port-8080上的kubernetes-dashboard ：&lt;a href=&#34;http://localhost:9099/ui&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://localhost:9099/ui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubectl proxy --port=9099 &amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes集群由主节点和节点资源组成 - 主节点协调集群，节点运行应用程序，并通过Kubernetes API进行通信。我们使用OpenFaaS CLI构建了容器化应用程序并编写了.yml文件来构建和部署该函数。通过在Kubernetes集群中的节点之间部署该函数，我们允许GKE分发和调度我们的节点资源。我们的节点已经配置了处理容器操作的工具，可以通过kubectl CLI。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn3annj20d80apmy6_hu6a3d1d10ac45ea6b02a8c0f25d9be1a1_74723_37938348eb977f2082f59ebf9f604084.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn3annj20d80apmy6_hu6a3d1d10ac45ea6b02a8c0f25d9be1a1_74723_88f1c4e5264533a4a5f0b0978c53fc44.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn3annj20d80apmy6_hu6a3d1d10ac45ea6b02a8c0f25d9be1a1_74723_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn3annj20d80apmy6_hu6a3d1d10ac45ea6b02a8c0f25d9be1a1_74723_37938348eb977f2082f59ebf9f604084.webp&#34;
               width=&#34;476&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;资料来源dzonecom&#34;&gt;资料来源：dzone.com&lt;/h4&gt;
&lt;h3 id=&#34;使用基本身份验证部署openfaas&#34;&gt;使用基本身份验证部署OpenFaaS。&lt;/h3&gt;
&lt;p&gt;克隆openfaas-gke存储库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/tmobile/faas-java-templates.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; openfaas-gke
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建openfaas和openfaas-fn名称空间以在多租户设置中部署OpenFaaS服务：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubectl apply -f ./namespaces.yaml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要在openfaas命名空间中部署OpenFaaS服务：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubectl apply -f ./openfaas&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这将为OpenFaaS网关，FaaS-netesd（K8S控制器），Prometheus，警报管理器，Nats和队列工作者提供K8s pods，部署和服务。&lt;/p&gt;
&lt;p&gt;我们需要在通过设置身份验证在Internet上公开OpenFaaS之前保护我们的网关。我们可以使用一组凭据创建一个通用的basic-auth秘密：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl -n openfaas create secret generic basic-auth &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--from-literal&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;admin &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;--from-literal&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;admin
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后我们可以为我们的OpenFaaS网关部署Caddy，它既可以作为反向代理，又可以作为强大的负载均衡器，并支持WebSocket连接：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubectl apply -f ./caddy&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后，我们将使用K8s服务对象公开的外部IP访问OpenFaaS网关UI，并使用我们的凭据访问http://&amp;lt;EXTERNAL-IP&amp;gt;。我们可以通过运行kubectl get svc来获取外部IP。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;get_gateway_ip&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; kubectl -n openfaas describe service caddy-lb &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep Ingress &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; awk&lt;span class=&#34;s1&#34;&gt;&amp;#39;{ print $NF }&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;until&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;get_gateway_ip&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; sleep1&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; -n &lt;span class=&#34;s2&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;gateway_ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;get_gateway_ip&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;OpenFaaS Gateway IP: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;gateway_ip&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注意：如果外部IP地址显示为&lt;pending&gt;，请等待一分钟再次输入相同的命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果您尚未执行上一个练习，请通过调用安装OpenFaaS CLI。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;curl-sL cli.openfaas.com | sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后使用CLI，凭据和K8s服务公开的外部IP登录：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;faas-cli login -u admin -p admin --gateway http://&amp;lt;EXTERNAL-IP&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：（a）您可以通过创建Ingress资源，使用Google Cloud L7 HTTPS负载均衡器公开OpenFaaS网关。您可以在 &lt;a href=&#34;https://cloud.google.com/kubernetes-engine/docs/tutorials/http-balancer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此处&lt;/a&gt; 找到有关创建负载均衡器的详细指南。（b）您可以使用密码创建文本文件，并将该文件与-password-stdin标志一起使用，以避免在bash历史记录中输入密码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;您可以使用先前在上一个练习中发布的镜像并部署无服务器功能&#34;&gt;您可以使用先前在上一个练习中发布的镜像并部署无服务器功能。&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ faas-cli deploy -f mvnw.yml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;deploy命令在当前目录中查找mvnw.yml文件，并部署openfaas-fn命名空间中的所有函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：（a）您可以使用com.openfaas.scale.min标签设置最小运行pod数，并为autoscaler com.openfaas.scale.max设置最小副本数。OpenFaaS的默认设置是每个功能运行一个pod，并且在负载下最多可扩展到20个pod&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;调用无服务器功能&#34;&gt;调用无服务器功能。&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;faas-cli invoke mvnw--gateway=http://&amp;lt;GATEWAY-IP&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;您可以随时注销&#34;&gt;您可以随时注销：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;faas-cli logout -gateway http://&amp;lt;EXTERNAL-IP&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;c-fission和部署简单的http请求&#34;&gt;C. Fission和部署简单的HTTP请求&lt;/h2&gt;
&lt;p&gt;Fission是一个无服务器框架，它进一步抽象出容器镜像，并允许仅通过函数在K8s上创建HTTP服务。Fission中的容器镜像包含语言运行时，一组常用的依赖项和一个用于函数的动态加载器。可以定制这些图像，例如打包二进制依赖项。Fission能够通过维护一个正在运行的容器池来优化冷启动开销。当新请求来自客户端应用程序或业务服务时，它会将该函数复制到容器中，动态加载它，并将请求路由到该实例。因此，对于NodeJS和Python函数，它能够最小化100毫秒的冷启动开销。&lt;/p&gt;
&lt;p&gt;通过在源码级别进行操作，Fission使用户不必处理容器的镜像构建，将镜像推送到注册表，管理注册表凭据，镜像版本控制和其他管理任务。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn7oehj20hs0dcglu_hua6f008d9db6d57312dde126ef6c5bae9_35625_8f2cef097060810cd4146f59b4e268e7.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn7oehj20hs0dcglu_hua6f008d9db6d57312dde126ef6c5bae9_35625_fd1c5c6a21d685fd60be5cb3cabb5396.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn7oehj20hs0dcglu_hua6f008d9db6d57312dde126ef6c5bae9_35625_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn7oehj20hs0dcglu_hua6f008d9db6d57312dde126ef6c5bae9_35625_8f2cef097060810cd4146f59b4e268e7.webp&#34;
               width=&#34;640&#34;
               height=&#34;480&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;httpskubernetesioblog201701fission-serverless-functions-as-service-for-kubernetes&#34;&gt;&lt;a href=&#34;https://kubernetes.io/blog/2017/01/fission&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubernetes.io/blog/2017/01/fission&lt;/a&gt;-serverless-functions-as-service-for-kubernetes&lt;/h4&gt;
&lt;p&gt;如上图所示，Fission被设计为一组微服务，主要组件如下所述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跟踪功能，HTTP路由，事件触发器和环境镜像的控制器;&lt;/li&gt;
&lt;li&gt;管理空闲环境容器池的池管理器，将函数加载到这些容器中，并定期杀死函数实例以管理容器开销;&lt;/li&gt;
&lt;li&gt;一种路由器，它接收HTTP请求并将它们路由到poolmgr或已在运行的实例中的新鲜函数实例。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以使用在上一个练习中GCP上创建的K8s群集在Fission上部署HTTP请求。让我们走过这个过程吧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装Helm CLI， Helm是一个Kubernetes包管理器。让我们初始化Helm：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ helm init
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在GKE命名空间中安装Fission&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ helm install --namespace fission https://github.com/fission/fission/releases/download/0.7.0/fission-all-0.7.0.tgz
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装Fission CLI&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSX&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl -Lo fission https://github.com/fission/fission/releases/download/0.7.0/fission-cli-osx&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; chmod +x fission &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo mv fission /usr/local/bin/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt; 在 &lt;a href=&#34;https://github.com/fission/fission/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此处&lt;/a&gt; 下载Windows可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建HTTP服务我们将创建一个简单的HTTP服务来打印Hello World。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat &amp;gt; hello.py
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;def main&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;context&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    print &lt;span class=&#34;s2&#34;&gt;&amp;#34;Hello, world!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Fission上部署HTTP服务&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ fission &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; create --name hello --env python --code hello.py --route /hello
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl http://&amp;lt;fission router&amp;gt;/hello
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Hello, world!
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;d-kubeless和部署spring-boot模板&#34;&gt;D. Kubeless和部署Spring Boot模板&lt;/h2&gt;
&lt;p&gt;Kubeless是一个Kubernetes原生无服务器框架，可以将功能部署在K8s集群上，同时允许用户利用Kubernetes资源提供自动扩展，API路由，监控和故障排除。Kubeless使用Kubernetes自定义资源定义来创建自定义kubernetes资源的功能。自定义资源是 &lt;a href=&#34;https://kubernetes.io/docs/reference/api-overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes API&lt;/a&gt; 中的端点，用于存储&lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API对象&lt;/a&gt;的集合某种类型的K8s pod对象，它代表了特定K8s安装的自定义。自定义资源非常有用，因为它们可以通过动态注册进行配置然后在正在运行的集群中删除，集群管理员可以独立于集群本身更新自定义资源。Kubeless利用这些功能并运行集群内控制器，可以跟踪这些自定义资源并按需启动运行时。&lt;/p&gt;
&lt;p&gt;我们可以使用在上一个练习中GCP上创建的K8s群集在Fission上部署HTTP请求。让我们走过这个过程吧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;访问Kubernetes仪表板&lt;/p&gt;
&lt;p&gt;在K8s集群正在运行的情况下，我们可以使用kubectl在8080端口上使用仪表板：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubectl proxy --port=8080&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsjw13nsj218g0jrq81_hu6f7184b545b2dff64b93bd45b69ae2fa_268195_17403ee6ee1f3af68e39a45feed4e19b.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsjw13nsj218g0jrq81_hu6f7184b545b2dff64b93bd45b69ae2fa_268195_fe65e261c07a5242f8c2f1da2219cbd2.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsjw13nsj218g0jrq81_hu6f7184b545b2dff64b93bd45b69ae2fa_268195_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsjw13nsj218g0jrq81_hu6f7184b545b2dff64b93bd45b69ae2fa_268195_17403ee6ee1f3af68e39a45feed4e19b.webp&#34;
               width=&#34;760&#34;
               height=&#34;338&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以通过浏览器导航到&lt;a href=&#34;http://localhost8080/ui&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://localhost8080/i&lt;/a&gt;来访问仪表板&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装Kubeless CLI&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSX&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl -L https://github.com/kubeless/kubeless/releases/download/0.0.20/kubeless_darwin-amd64.zip &amp;gt; kubeless.zip
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ unzip kubeless.zip
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo cp bundles/kubeless_darwin-amd64/kubeless /usr/local/bin/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&#34;https://github.com/kubeless/kubeless/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此处&lt;/a&gt; 下载Windows可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在K8s群集中部署Kubeless&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug1ieuj20jr0c3dgl_hud3bc2248484e2a81508a0667b4897714_177487_015fdd4a4edb76b643761419943dacb8.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug1ieuj20jr0c3dgl_hud3bc2248484e2a81508a0667b4897714_177487_8a1febb7de7d0a447dde406bb72f4d41.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug1ieuj20jr0c3dgl_hud3bc2248484e2a81508a0667b4897714_177487_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug1ieuj20jr0c3dgl_hud3bc2248484e2a81508a0667b4897714_177487_015fdd4a4edb76b643761419943dacb8.webp&#34;
               width=&#34;711&#34;
               height=&#34;435&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们将使用此&lt;a href=&#34;https://github.com/kubeless/kubeless/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;链接中&lt;/a&gt; 的清单在K8s群集中部署Kubless。根据清单创建一个kubeless命名空间，一个函数ThirdPartyResource，一个kubeless控制器，并在进程中设置一个kafka，zookeeper StatefulSet。Kubless的一个主要优点是它具有高度的Kubernetes原生特性，它可以设置非rbac和rbac特定环境。下面的屏幕截图显示了如何使用kubectl命令在非rbac环境中部署kubeless。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug4tx0j20hr05bwew_hu2ebcf8cc33814747f6044ee7214e8bbb_32838_27ea0fdaba04c0643ed7c5a57b0a8d67.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug4tx0j20hr05bwew_hu2ebcf8cc33814747f6044ee7214e8bbb_32838_0a4a0be7687d90a4c52ddd5d2d48f28e.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug4tx0j20hr05bwew_hu2ebcf8cc33814747f6044ee7214e8bbb_32838_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwx4ug4tx0j20hr05bwew_hu2ebcf8cc33814747f6044ee7214e8bbb_32838_27ea0fdaba04c0643ed7c5a57b0a8d67.webp&#34;
               width=&#34;639&#34;
               height=&#34;191&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建函数&lt;/p&gt;
&lt;p&gt;我们可以创建一个服务函数，并从请求中接受方法，URL，标题和请求体。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;const &lt;span class=&#34;nv&#34;&gt;http&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; require&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;http&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    http.createServer&lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;request, response&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      const &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; headers, method, url &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; request&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nb&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      request.on&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;error&amp;#39;&lt;/span&gt;, &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;err&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        console.error&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;err&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;.on&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;, &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;chunk&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        body.push&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;chunk&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;.on&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;, &lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&amp;gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nv&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; Buffer.concat&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;body&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;.toString&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // 此时，我们有标题，方法，网址和请求体，现在可以做任何我们需要的事情来回应这个要求。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;.listen&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;8080&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; // 激活此服务器，监听8080端口。
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Kubeless环境中运行函数&lt;/p&gt;
&lt;p&gt;我们可以通过提供以下信息向Kubeless注册该函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用于通过Web访问该函数的名称&lt;/li&gt;
&lt;li&gt;用于访问该函数的协议&lt;/li&gt;
&lt;li&gt;要执行以运行代码的语言运行时&lt;/li&gt;
&lt;li&gt;包含函数代码的文件的名称&lt;/li&gt;
&lt;li&gt;文件内部函数的名称&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过添加上面的变量1-5，我们调用以下命令在Kubeless中注册和部署函数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt; kubeless function deploy serverequest--trigger-http --runtime nodejs6 --handler serverequest.createServer --from-file /tmp/serverequest.js&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;e无服务器平台的评估&#34;&gt;E.无服务器平台的评估&lt;/h2&gt;
&lt;p&gt;我们评估的每个无服务器平台都有其独特的价值主张。使用OpenFaas，任何进程或容器都可以打包为Linux或Windows的无服务器功能。对于企业而言，OpenFaaS使用的体系结构提供了无缝插入计划群集和现有微服务的CI/CD工作流的能力，因为OpenFaaS是围绕Docker构建的，所有功能都打包到Docker镜像中。OpenFaaS还为企业提供了一种通过外部API，网关管理和执行函数的无缝方式，并管理函数的生命周期，包括通过提供商进行部署，扩展和secret管理。&lt;/p&gt;
&lt;p&gt;Fission具有事件驱动架构，使其成为短期无状态应用程序的理想选择，包括REST API或webhook实现以及DevOps自动化。使用Fission的一个很好的用例可能是开发聊天机器人的后端，因为Fission可以实现良好的冷启动性能，并在需要时通过保持运行时的容器池来提供快速响应时间。&lt;/p&gt;
&lt;p&gt;最后，Kubeless架构利用原生Kubernetes概念来部署和管理功能，例如自定义资源定义，用于定义功能和自定义控制器来管理函数，将其部署为Kubernetes部署并通过Kubernetes服务公开它。与Kubernetes原生功能的紧密结合将吸引现有的Kubernetes用户，降低所需的学习曲线并无缝插入现有的Kubernetes架构。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-hisham&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Hisham&#34; srcset=&#34;
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn5g0oj206y06y74m_hu956f9aff23327caefdd8deda708baff6_22757_7449669d19de2e84b1f0e351a4ab0eae.webp 400w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn5g0oj206y06y74m_hu956f9aff23327caefdd8deda708baff6_22757_3dd1775e3e900e8f13079a4377c1c237.webp 760w,
               /blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn5g0oj206y06y74m_hu956f9aff23327caefdd8deda708baff6_22757_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/evaluation-of-serverless-frameworks-for-kbe/61411417ly1fwtsgn5g0oj206y06y74m_hu956f9aff23327caefdd8deda708baff6_22757_7449669d19de2e84b1f0e351a4ab0eae.webp&#34;
               width=&#34;250&#34;
               height=&#34;250&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Hisham
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Hisham是一位咨询企业解决方案架构师，在利用容器技术解决基础架构问题和更快地部署应用程序以及更高级别的安全性，性能和可靠性方面拥有丰富的经验 最近，Hisham一直在为各种中间件应用程序利用容器和云原生架构，以在整个企业中部署复杂的关键任务服务。在进入咨询领域之前，Hisham曾在Aon Hewitt，Lexmark和ADP从事软件实施和技术支持工作。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google 加持 Istio：这可能比 Kubernetes 和 Serverless 产生更大影响力</title>
      <link>https://cloudnative.to/blog/google-istio-bigger-kubernetes-serverless/</link>
      <pubDate>Mon, 20 Aug 2018 16:14:16 +0800</pubDate>
      <guid>https://cloudnative.to/blog/google-istio-bigger-kubernetes-serverless/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/google-istio-bigger-kubernetes-serverless/00704eQkly1fug8z3tpgcj30lc0ao44a.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://diginomica.com/2018/08/03/google-istio-bigger-kubernetes-serverless/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Google Cloud采用了Istio服务网格技术来管理微服务，这可能比Kubernetes和无服务器产生更大的影响。&lt;/p&gt;
&lt;p&gt;随着现代数字计算基础设施的不断发展，新的自动化层加速了创新和提升了适应性。一旦实现容器化微服务几秒之内部署一个新功能成为可能。那么Kubernetes和类似工具的出现增加了一层业务流程，以便大规模协调容器部署。在基础设施中一个功能很容易抽象成为一个满足需求的serverless模型。现在，正在形成一个称为“service mesh”的新层，以便在所有这些功能中添加服务间治理、管理和通信功能。8月1号一个名为Istio的service mesh的新开源框架1.0版本发布生产版本，像之前的Kubernetes一样，由谷歌以及IBM支持。&lt;/p&gt;
&lt;h2 id=&#34;比kubernetes更有价值&#34;&gt;比Kubernetes更有价值&lt;/h2&gt;
&lt;p&gt;您可能没有听说过Istio，但如果您进行任何形式的敏捷数字开发或运维工作，您很快就会知道Istio。 Google云计算CTO（UrsHölzle）上周告诉我，他预计service mesh将会被普遍采用：“我希望看到的是，在两年后90％的Kubernetes用户将会使用Istio。Istio与Kubernetes提供的产品非常吻合，几乎感觉就像Kubernetes的下一次迭代。这是由同一个团队完成的，Istio和Kubernetes的功能能够很好的互补。”&lt;/p&gt;
&lt;p&gt;Hölzle没有明确地说Istio一定会比Kubernetes更大，但他非常确信Istio会和Kubernetes具有一样大的应用前景，甚至超过Kubernetes。&lt;/p&gt;
&lt;h2 id=&#34;istiokubernetes和serverless&#34;&gt;Istio、Kubernetes和Serverless&lt;/h2&gt;
&lt;p&gt;在某种程度上，Hölzle的信心源于谷歌决定将Istio标准化为其云服务平台（&lt;a href=&#34;https://cloudplatform.googleblog.com/2018/07/cloud-services-platform-bringing-the-best-of-the-cloud-to-you.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Services Platform &lt;/a&gt;）的管理层，该服务于上周在Cloud Next会议上宣布。这与上周推出的另外两个新项目同时启动。一个是&lt;a href=&#34;https://www.infoq.com/news/2018/07/knative-kubernetes-serverless&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative&lt;/a&gt;—一个基于Kubernetes的开源框架，用于构建、部署和管理serverless工作负载，正如Kurt Marko本周早些时候在他的&lt;a href=&#34;https://diginomica.com/2018/07/30/google-cloud-platform-removes-barriers-between-it-business/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Next文章&lt;/a&gt;中所解释的那样，“Knative不仅仅是一个serverless的容器包装器，而是一个容器化应用的开发框架“。另一个是谷歌GKE（Google Kubernetes Engine）私有云版本，是云供应商的容器管理工具。结合Istio的管理层，这实际上意味着组织可以从私有云到公有云使用CSP管理整个IT基础架构中的容器生态系统和serverless。&lt;/p&gt;
&lt;p&gt;Istio是Google、IBM和Lyft共同努力在一年多前推出的一项开放式技术框架，用于连接、保护、管理和监控云的服务网络。这三家公司都贡献了他们单独开发的现有技术。&lt;/p&gt;
&lt;h2 id=&#34;减轻企业上云难度&#34;&gt;减轻企业上云难度&lt;/h2&gt;
&lt;p&gt;Hölzle认为，Istio将加速企业采用公有云，因为它可以在私有化部署和云之间实现更高的同质化：“公司决定将所有内容（包括他们不想重写的旧代码）移至Istio，去包装旧代码而不去重写它这是非常合理的。我们相信GKE私有化部署将带领更多客户深入云技术。因为它与现代云思维非常融合，它保留了它们的地址以及何时何地去迁移的选择机会。你可以在任何你喜欢的云提供商之间自由迁移，且使你上云之路更加平稳。一旦人们熟悉了Kubernetes和Istio的管理和编排方式，上云就不会变得可怕了。”&lt;/p&gt;
&lt;p&gt;Hölzle认为BigQuery这样的云原生功能将继续为它们提供最终结果。与此同时，它依靠思科等合作伙伴提供GKE和Knative的私有化版本，而不是成为该技术本身的直销商。&lt;/p&gt;
&lt;h2 id=&#34;合作伙伴和开发者&#34;&gt;合作伙伴和开发者&lt;/h2&gt;
&lt;p&gt;合作伙伴还将发现Istio有助于他们从硬件产品转向安全等领域的软件和服务云转型。Hölzle认为：“许多合作伙伴正在转向销售软件和销售服务，这是进入该领域的理想切入点。如果您是正在使用Istio的服务安全提供商，将服务从本地迁移到云将不受影响，只有位置发生变化了。在当前模型中，如果您是本地提供商，所有API都不同，所有需要回答的问题都是新的，您可能会失去现任状态，因为您无法轻松移植到云端”。&lt;/p&gt;
&lt;p&gt;开发人员也需要得到说服。但谷歌开发者关系部副总裁亚当·塞利格曼认为，他对Istio为他们开放的东西感到很兴奋：“使用Istio不需要大量的重新编程。现有的应用程序、功能和服务可以使用Istio进行流量路由，并立即看到当前各维度的运行状态。你将没有使用Istio的应用程序加入Istio，你会获得以前无法获得的所有可见性。我认为这会刺激很多开发人员，加速Istio被采用的速度。我认为开发人员需要接受SLO（服务级别目标）监控、金丝雀部署、流量控制、A/B测试甚至多变量测试等技术培训。”&lt;/p&gt;
&lt;h2 id=&#34;我的见解&#34;&gt;我的见解&lt;/h2&gt;
&lt;p&gt;Istio不是唯一实现service mesh的技术框架，linkerd—由Buoyant支持的开源项目，早于Istio，已经投入生产。但谷歌、IBM和思科等重量级合作伙伴给Istio带来了比Bouyant对linkerd更大的支持。最后，重要的是服务网格的原则而不是具体的实现。一直存在着反对过度使用微服务的争论，因为你拥有的自主服务越多，管理它们就越复杂。在Istio的支持下，Google正在验证解决这个棘手问题的微服务架构，以便所有这些松散耦合的端点可以合理地协调以产生有用的业务成果。这似乎应该是云计算发展中非常重要的进展。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
