<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>eBPF | 云原生社区（中国）</title>
    <link>https://cloudnative.to/tag/ebpf/</link>
      <atom:link href="https://cloudnative.to/tag/ebpf/index.xml" rel="self" type="application/rss+xml" />
    <description>eBPF</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 10 Aug 2023 15:05:42 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>eBPF</title>
      <link>https://cloudnative.to/tag/ebpf/</link>
    </image>
    
    <item>
      <title>深入浅出运维可观测工具（一）：聊聊 eBPF 的前世今生</title>
      <link>https://cloudnative.to/blog/current-state-and-future-of-ebpf/</link>
      <pubDate>Thu, 10 Aug 2023 15:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/current-state-and-future-of-ebpf/</guid>
      <description>&lt;p&gt;今天跟大家分享的 eBPF（extended Berkeley Packet Filter），相信很多技术人员已经很熟悉了。作为 Linux 社区的新宠，它备受 Goole、Facebook、Twitter 等大公司的青睐。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-究竟有什么魔力让大家这么关注&#34;&gt;eBPF 究竟有什么魔力让大家这么关注&lt;/h2&gt;
&lt;p&gt;这是因为 eBPF 增加了内核的可扩展性，让内核变得更加灵活和强大。如果大家玩过乐高积木的话就会深有体会，乐高积木就是通过不断向主体添加积木来组合出更庞大的模型。而 eBPF 就像乐高积木一样，可以不断向内核添加 eBPF 模块来增强内核的功能。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ebpf&#34;&gt;什么是 eBPF&lt;/h2&gt;
&lt;p&gt;在介绍 eBPF (Extended Berkeley Packet Filter) 之前，我们先来了解一下它的前身－BPF (Berkeley Packet Filter) 伯克利数据包过滤器。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f1_hu0e565535cc1dea65db7cbcf02f2f7a34_73188_9f9b19d5d5ae8318cf8daf7a695ab46b.webp 400w,
               /blog/current-state-and-future-of-ebpf/f1_hu0e565535cc1dea65db7cbcf02f2f7a34_73188_dfc685aaaa361a0c7c4d62928b0d90c3.webp 760w,
               /blog/current-state-and-future-of-ebpf/f1_hu0e565535cc1dea65db7cbcf02f2f7a34_73188_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f1_hu0e565535cc1dea65db7cbcf02f2f7a34_73188_9f9b19d5d5ae8318cf8daf7a695ab46b.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;BPF 最早由 Van Jacobson 在 1992 年开发，用于在 Unix 操作系统中过滤和捕获网络数据包。它运行在内核中，通过提供一个简单而强大的虚拟机，可以在网络协议层上进行高效的数据包处理操作。BPF 通过把过程转换成指令序列来实现，这些指令直接在内核中执行，从而避免了用户空间和内核空间之间频繁的切换。&lt;/p&gt;
&lt;h2 id=&#34;基于-bpf-开发的工具库有-libpcaptcpdump-等工具&#34;&gt;基于 BPF 开发的工具库有 libpcap、tcpdump 等工具。&lt;/h2&gt;
&lt;p&gt;BPF 在网络性能监测和安全策略实施方面具有广泛的应用。然而，由于其指令集的限制和功能的局限性，它无法支持更加复杂和灵活的数据包处理需求。&lt;/p&gt;
&lt;p&gt;正是为了克服 BPF 的限制，eBPF 应运而生。eBPF 于 2014 年（3.18 版本）年首次引入 Linux 内核，并在此后的几年中经历了快速的发展和完善。&lt;/p&gt;
&lt;p&gt;eBPF 是一个高度可扩展的、运行在内核中的虚拟机，具备与传统 BPF 相似的指令集，但功能更加强大且更加灵活。eBPF 可以在运行时即时编译，从而能够处理更加复杂和动态的数据包处理任务，如网络流量分析、安全检测和性能优化等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f2_hufb4a26f066a127f289acfb867e36c42d_112644_b6bb59d2483fa6a3a5ff8f7463f7bb0f.webp 400w,
               /blog/current-state-and-future-of-ebpf/f2_hufb4a26f066a127f289acfb867e36c42d_112644_f0ec153bd2a451dd1148b5d1c6395779.webp 760w,
               /blog/current-state-and-future-of-ebpf/f2_hufb4a26f066a127f289acfb867e36c42d_112644_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f2_hufb4a26f066a127f289acfb867e36c42d_112644_b6bb59d2483fa6a3a5ff8f7463f7bb0f.webp&#34;
               width=&#34;760&#34;
               height=&#34;215&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;eBPF 的灵活性和可扩展性体现在它可以与各种用户空间程序（如 tcpdump、Wireshark、Suricata 等）和工具（如网络监控、调试器等) 无缝集成。&lt;/p&gt;
&lt;p&gt;eBPF 还可以与系统的其他组件（如网络协议栈、调度器等）交互，从而实现更加细粒度的性能优化和安全策略。&lt;/p&gt;
&lt;p&gt;此外，eBPF 的开发和使用也得到了广泛的支持和推动。社区中有许多致力于 eBPF 的开发者和贡献者，他们不断改进和扩展 eBPF 的功能。同时，一些知名的大型技术公司，如 Facebook、Netflix 和 Google 等，也在其产品和基础设施中广泛使用 eBPF。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-的发展史&#34;&gt;eBPF 的发展史&lt;/h2&gt;
&lt;p&gt;2014 年初，Alexei Starovoitov 实现了 eBPF。新的设计针对现代硬件进行了优化，所以 eBPF 生成的指令集比旧的 BPF 解释器生成的机器码执行得更快。扩展版本也增加了虚拟机中的寄存器数量，将原有的 2 个 32 位寄存器增加到 10 个 64 位寄存器。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f3_huf5d2b58880984684c4aaa67510b6b260_61554_414aa7d8142ac8a2a9c3c9341f856580.webp 400w,
               /blog/current-state-and-future-of-ebpf/f3_huf5d2b58880984684c4aaa67510b6b260_61554_f96739c368f990b35599ab32441995c7.webp 760w,
               /blog/current-state-and-future-of-ebpf/f3_huf5d2b58880984684c4aaa67510b6b260_61554_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f3_huf5d2b58880984684c4aaa67510b6b260_61554_414aa7d8142ac8a2a9c3c9341f856580.webp&#34;
               width=&#34;760&#34;
               height=&#34;560&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;由于寄存器数量和宽度的增加，开发人员可以使用函数参数自由交换更多的信息，编写更复杂的程序。总之，这些改进使 eBPF 版本的速度比原来的 BPF 提高了 4 倍。&lt;/p&gt;
&lt;p&gt;eBPF 是一项具有革命性的技术，源自于 Linux 内核，可以在特权环境中运行受沙盒保护的程序，例如操作系统内核。它被用于安全有效地扩展内核的功能，而无需更改内核源代码或加载内核模块。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f4_hu5c1e175de0db4c1e82620df259461b67_63539_53c39fc13a65773d09ddde491e6e97d8.webp 400w,
               /blog/current-state-and-future-of-ebpf/f4_hu5c1e175de0db4c1e82620df259461b67_63539_73a81fc517019b944f6782f2bd6b85f7.webp 760w,
               /blog/current-state-and-future-of-ebpf/f4_hu5c1e175de0db4c1e82620df259461b67_63539_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f4_hu5c1e175de0db4c1e82620df259461b67_63539_53c39fc13a65773d09ddde491e6e97d8.webp&#34;
               width=&#34;760&#34;
               height=&#34;506&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在历史上，操作系统一直是实现可观察性、安全性和网络功能的理想场所，这是因为内核具有特权能力，可以监督和控制整个系统。与此同时，由于内核在系统中的核心地位以及对稳定性和安全性的高要求，操作系统内核的演进往往很困难。因此，与操作系统外部实现的功能相比，操作系统层面的创新速度传统上较低。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f5_hue9bbd55d7224902cc0d40898abece082_151958_9c1ed77fe31e883e2c254245d492e7c8.webp 400w,
               /blog/current-state-and-future-of-ebpf/f5_hue9bbd55d7224902cc0d40898abece082_151958_1bab865bd77b8f61f27b2707481f8c44.webp 760w,
               /blog/current-state-and-future-of-ebpf/f5_hue9bbd55d7224902cc0d40898abece082_151958_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f5_hue9bbd55d7224902cc0d40898abece082_151958_9c1ed77fe31e883e2c254245d492e7c8.webp&#34;
               width=&#34;760&#34;
               height=&#34;391&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;eBPF 从根本上改变了这个现象。通过在操作系统内运行受沙盒保护的程序，应用开发人员可以在运行时运行 eBPF 程序，为操作系统添加额外的功能。操作系统会利用即时编译器和验证引擎的帮助来保证安全性和执行效率，就像本地编译一样。这导致了一系列基于 eBPF 的项目的涌现，涵盖了各种用例，包括下一代网络、可观测性和安全功能。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-应用场景&#34;&gt;eBPF 应用场景&lt;/h2&gt;
&lt;p&gt;如今，eBPF 被广泛应用于驱动各种用例：在现代数据中心和云原生环境中提供高性能的网络和负载均衡；&lt;/p&gt;
&lt;p&gt;以低开销提取细粒度的安全可观测性数据，帮助应用开发人员追踪应用程序、提供性能故障排除的见解，进行预防性应用程序和容器运行时安全执行等等。&lt;/p&gt;
&lt;p&gt;可能性是无限的，eBPF 正在释放出的创新力量才刚刚开始。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-特性&#34;&gt;eBPF 特性&lt;/h2&gt;
&lt;h3 id=&#34;hook-overview&#34;&gt;Hook Overview&lt;/h3&gt;
&lt;p&gt;eBPF 程序都是事件驱动的，它们会在内核或者应用程序经过某个确定的 Hook 点的时候运行，这些 Hook 点都是提前定义的，包括系统调用、函数进入/退出、内核 tracepoints、网络事件等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f6_hu6f14439a985313c8941b45c7c3ec5140_192922_58b478a303958d60f20eded523477712.webp 400w,
               /blog/current-state-and-future-of-ebpf/f6_hu6f14439a985313c8941b45c7c3ec5140_192922_8608deda371dbf615d709287fc9f1b1b.webp 760w,
               /blog/current-state-and-future-of-ebpf/f6_hu6f14439a985313c8941b45c7c3ec5140_192922_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f6_hu6f14439a985313c8941b45c7c3ec5140_192922_58b478a303958d60f20eded523477712.webp&#34;
               width=&#34;760&#34;
               height=&#34;578&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;verification&#34;&gt;Verification&lt;/h3&gt;
&lt;p&gt;With great power there must also come great responsibility.&lt;/p&gt;
&lt;p&gt;每一个 eBPF 程序加载到内核都要经过 Verification，用来保证 eBPF 程序的安全性，主要包括：&lt;/p&gt;
&lt;p&gt;要保证加载 eBPF 程序的进程有必要的特权级，除非节点开启了 unpriviledged 特性，只有特权级的程序才能够加载 eBPF 程序。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内核提供了一个配置项 /proc/sys/kernel/unprivileged_bpf_disabled 来禁止非特权用户使用 bpf(2) 系统调用，可以通过 sysctl 命令修改&lt;/li&gt;
&lt;li&gt;比较特殊的一点是，这个配置项特意设计为一次性开关（one-time kill switch），这意味着一旦将它设为 1，就没有办法再改为 0 了，除非重启内核&lt;/li&gt;
&lt;li&gt;一旦设置为 1 之后，只有初始命名空间中有 CAP_SYS_ADMIN 特权的进程才可以调用 bpf(2) 系统调用。Cilium 启动后也会将这个配置项设为 1：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;$ echo 1 &amp;gt; /proc/sys/kernel/unprivileged_bpf_disabled&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要保证 eBPF 程序不会崩溃或者使得系统出故障。&lt;/p&gt;
&lt;p&gt;要保证 eBPF 程序不能陷入死循环，能够 runs to completion。&lt;/p&gt;
&lt;p&gt;要保证 eBPF 程序必须满足系统要求的大小，过大的 eBPF 程序不允许被加载进内核。&lt;/p&gt;
&lt;p&gt;要保证 eBPF 程序的复杂度有限，Verifier 将会评估 eBPF 程序所有可能的执行路径，必须能够在有限时间内完成 eBPF 程序复杂度分析。&lt;/p&gt;
&lt;h3 id=&#34;jit-compilation&#34;&gt;JIT Compilation&lt;/h3&gt;
&lt;p&gt;Just-In-Time（JIT）编译用来将通用的 eBPF 字节码翻译成与机器相关的指令集，从而极大加速 BPF 程序的执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与解释器相比，它们可以降低每个指令的开销。通常指令可以 1:1 映射到底层架构的原生指令。&lt;/li&gt;
&lt;li&gt;这也会减少生成的可执行镜像的大小，因此对 CPU 的指令缓存更友好。&lt;/li&gt;
&lt;li&gt;特别地，对于 CISC 指令集（例如 x86），JIT 做了很多特殊优化，目的是为给定的指令产生可能的最短操作码，以降低程序翻译过程所需的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;64 位的 x86_64、arm64、ppc64、s390x、mips64、sparc64 和 32 位的 arm、x86_32 架构都内置了 in-kernel eBPF JIT 编译器，它们的功能都是一样的，可以用如下方式打开：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ echo 1 &amp;gt; /proc/sys/net/core/bpf_jit_enable&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;32 位的 mips、ppc 和 sparc 架构目前内置的是一个 cBPF JIT 编译器。这些只有 cBPF JIT 编译器的架构，以及那些甚至完全没有 BPF JIT 编译器的架构，需要通过内核中的解释器（in-kernel interpreter）执行 eBPF 程序。&lt;/p&gt;
&lt;p&gt;要判断哪些平台支持 eBPF JIT，可以在内核源文件中 grep HAVE_EBPF_JIT：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f8_hud76abf820beb08b928843600458d8b8c_44152_2a484759c6d4a61f4eac554606ddd237.webp 400w,
               /blog/current-state-and-future-of-ebpf/f8_hud76abf820beb08b928843600458d8b8c_44152_b4f113c46c86a52b5ac262c67f93e09f.webp 760w,
               /blog/current-state-and-future-of-ebpf/f8_hud76abf820beb08b928843600458d8b8c_44152_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f8_hud76abf820beb08b928843600458d8b8c_44152_2a484759c6d4a61f4eac554606ddd237.webp&#34;
               width=&#34;760&#34;
               height=&#34;215&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/current-state-and-future-of-ebpf/f7_hu74e6943e84e5c2e3fac5f6921d5dc7fc_71503_15583eae7ce68874c3785050044a012b.webp 400w,
               /blog/current-state-and-future-of-ebpf/f7_hu74e6943e84e5c2e3fac5f6921d5dc7fc_71503_4205e2ca601aada142d5027de67279d8.webp 760w,
               /blog/current-state-and-future-of-ebpf/f7_hu74e6943e84e5c2e3fac5f6921d5dc7fc_71503_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/current-state-and-future-of-ebpf/f7_hu74e6943e84e5c2e3fac5f6921d5dc7fc_71503_15583eae7ce68874c3785050044a012b.webp&#34;
               width=&#34;760&#34;
               height=&#34;364&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;好啦，本期关于运维可观测工具 eBPF 的分享到这里就告一段落了，下期我们再来讲讲 eBPF 在实际使用中遇到的问题。感兴趣的朋友可以关注一下~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何在产品中引入 eBPF 以增加可观察性</title>
      <link>https://cloudnative.to/blog/how-to-add-bpf-observability/</link>
      <pubDate>Thu, 27 Jan 2022 09:24:17 +0800</pubDate>
      <guid>https://cloudnative.to/blog/how-to-add-bpf-observability/</guid>
      <description>&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;本文译自 &lt;a href=&#34;https://www.brendangregg.com/blog/2021-07-03/how-to-add-bpf-observability.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How To Add eBPF Observability To Your Product&lt;/a&gt;，原文发布于 2021 年 7月 3 日。本文作者 Brendan Gregg 是 eBPF 领域的专家，出版过多本相关书籍，本文是他给想要在产品中引入 eBPF 增加可观察性人员的忠告。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;现在有一场军备竞赛，即增加 &lt;a href=&#34;https://www.brendangregg.com/blog/2021-07-03/BPF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 的军备竞赛，在这篇文章中，我将介绍如何快速做到这一点。这也适用于人们将其添加到自己的内部监测系统中。&lt;/p&gt;
&lt;p&gt;人们喜欢在他们建立了原型或构建了产品之后向我展示他们的 BPF 可观察性产品，但我常常在他们开始之前给出建议。作为 BPF 可观察性的领导者，这是我在最近的谈话中一直包含的建议，现在我把它纳入这篇文章中。&lt;/p&gt;
&lt;p&gt;首先，我知道你很忙。你甚至可能不喜欢 BPF。为了务实起见，我将描述如何花最少的精力来获得最大的价值。把这看成是 “第一版”。一个相当有用的出发点。无论你是否遵循这个建议，至少请你理解它，以避免以后的遗憾和痛苦。&lt;/p&gt;
&lt;p&gt;如果你正在使用开源监控平台，首先检查它是否已经有一个 BPF 代理。这篇文章假设它没有，而且你将首次添加一些东西。&lt;/p&gt;
&lt;h2 id=&#34;1-运行第一个工具&#34;&gt;1. 运行第一个工具&lt;/h2&gt;
&lt;p&gt;首先安装 &lt;a href=&#34;https://github.com/iovisor/bcc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/iovisor/bpftrace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt; 工具。例如，Ubuntu 上的 bcc。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# apt-get install bpfcc-tools&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后尝试运行一个工具。例如，使用 execsnoop (8) 查看带有时间戳的进程执行情况。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# execsnoop-bpfcc -T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;TIME     PCOMM            PID    PPID   RET ARGS
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 service          &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;6009&lt;/span&gt;     &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/sbin/service --status-all
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 basename         &lt;span class=&#34;m&#34;&gt;828568&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 basename         &lt;span class=&#34;m&#34;&gt;828569&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/basename /usr/sbin/service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 env              &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/env -i &lt;span class=&#34;nv&#34;&gt;LANG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;en_AU.UTF-8 &lt;span class=&#34;nv&#34;&gt;LANGUAGE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;en_AU:en &lt;span class=&#34;nv&#34;&gt;LC_CTYPE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_NUMERIC&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_TIME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_COLLATE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_MONETARY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_MESSAGES&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_PAPER&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_NAME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_ADDRESS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_TELEPHONE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_MEASUREMENT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_IDENTIFICATION&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LC_ALL&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/opt/local/bin:/opt/local/sbin:/usr/local/git/bin:/home/bgregg/.local/bin:/home/bgregg/bin:/opt/local/bin:/opt/local/sbin:/ &lt;span class=&#34;nv&#34;&gt;TERM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;xterm-256color /etc/init.d/acpid 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 acpid            &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828567&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /etc/init.d/acpid status
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 run-parts        &lt;span class=&#34;m&#34;&gt;828571&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/run-parts --lsbsysinit --list /lib/lsb/init-functions.d
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 systemctl        &lt;span class=&#34;m&#34;&gt;828572&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/systemctl -p LoadState --value show acpid.service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;19:36:15 readlink         &lt;span class=&#34;m&#34;&gt;828573&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;828570&lt;/span&gt;   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; /usr/bin/readlink -f /etc/init.d/acpid
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;...&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然很基本，但我仅用这个工具就解决了很多 perf 问题，包括针对配置错误的系统，其中一个 shell 脚本正在循环启动失败的进程，以及当一些小程序崩溃并每隔几分钟就重启但还没有被注意到时。&lt;/p&gt;
&lt;h2 id=&#34;2-为你的产品添加一个工具&#34;&gt;2. 为你的产品添加一个工具&lt;/h2&gt;
&lt;p&gt;现在想象一下将 execsnoop (8) 添加到你的产品中。你可能已经在你所有的客户系统上运行了代理。他们是否有办法运行一个命令并返回文本输出？或者运行一个命令并将输出发送到其他地方进行聚合（S3、Hive、Druid 等）？有很多选择，这实际上是你自己基于现有系统和客户环境的偏好。&lt;/p&gt;
&lt;p&gt;当你把第一个工具添加到你的产品中时，让它在短时间内运行，比如 10 到 60 秒。我刚刚注意到 execsnoop (8) 还没有持续时间选项，所以在这期间你可以用 &lt;code&gt;watch -s2 60 execsnoop-bpfcc&lt;/code&gt; 来包装它。 如果你想 24 小时运行这些工具，首先要研究开销以了解成本。低频率的事件，如进程的执行，捕捉起来应该是可以忽略不计的。&lt;/p&gt;
&lt;p&gt;不使用 bcc，你也可以使用 &lt;a href=&#34;https://github.com/iovisor/bpftrace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt; 版本。这些通常没有封装选项（-v、-l 等），但有一个 json 输出模式。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# bpftrace -f json execsnoop.bt &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;attached_probes&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;probes&amp;#34;&lt;/span&gt;: 2&lt;span class=&#34;o&#34;&gt;}}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;printf&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;TIME(ms)   PID   ARGS\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;printf&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;2737       849176 &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;join&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;ls -F&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;printf&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;5641       849178 &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;join&amp;#34;&lt;/span&gt;, &lt;span class=&#34;s2&#34;&gt;&amp;#34;data&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;date&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;添加这种模式是为了使 BPF 的可观测性产品可以建立在 bpftrace 之上。&lt;/p&gt;
&lt;h2 id=&#34;3-不要担心依赖性问题&#34;&gt;3. 不要担心依赖性问题&lt;/h2&gt;
&lt;p&gt;我建议你在客户系统上安装 bcc 或 bpftrace，它们目前有 llvm 依赖。这可能会增加到几十 MB，这对一些资源有限的环境（嵌入式）是个问题。我们一直在做大量的工作，以便在未来解决这个问题。 &lt;a href=&#34;https://www.brendangregg.com/blog/2020-11-04/bpf-co-re-btf-libbpf.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BTF and CO-RE&lt;/a&gt;（而不是 Python），最终将意味着你可以安装 100KB 的无依赖性的工具二进制版本。bpftrace 也有一个类似的计划，使用较新的内核特性生成一个小的无依赖性的二进制版本。&lt;/p&gt;
&lt;p&gt;这确实需要至少 Linux 5.8 才能很好地工作，而你的客户可能几年都不会运行这个系统。在这期间，我建议暂时不要担心 llvm 的依赖关系，因为它以后会被修复。&lt;/p&gt;
&lt;p&gt;请注意，并不是所有的 Linux 发行版都启用了 &lt;code&gt;CONFIG_DEBUG_INFO_BTF=y&lt;/code&gt;，这对于 BTF 和 CO-RE 的未来是必要的。主要的发行版已经设置了它，比如在 Ubuntu 20.10、Fedora 30 和 RHEL 8.2。但如果你知道你的一些客户正在运行一些不常见的东西，请检查并鼓励他们或发行商设置 &lt;code&gt;CONFIG_DEBUG_INFO_BTF=y&lt;/code&gt; 和 &lt;code&gt;CONFIG_DEBUG_INFO_BTF_MODULES=y&lt;/code&gt;，以避免未来的痛苦。&lt;/p&gt;
&lt;h2 id=&#34;4-第-1-版仪表板&#34;&gt;4. 第 1 版仪表板&lt;/h2&gt;
&lt;p&gt;现在你的产品中有了一个 BPF 可观察性工具，是时候增加更多的工具了。下面是你可以运行的十大工具，并作为一个通用的 BPF 可观察性仪表盘来展示，同时还有建议的可视化。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编号&lt;/th&gt;
&lt;th&gt;工具&lt;/th&gt;
&lt;th&gt;展示&lt;/th&gt;
&lt;th&gt;可视化&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;execsnoop&lt;/td&gt;
&lt;td&gt;新进程（通过 exec (2)）&lt;/td&gt;
&lt;td&gt;表格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;opensnoop&lt;/td&gt;
&lt;td&gt;打开的文件&lt;/td&gt;
&lt;td&gt;表格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;ext4slower&lt;/td&gt;
&lt;td&gt;慢速文件系统 I/O&lt;/td&gt;
&lt;td&gt;表格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;biolatency&lt;/td&gt;
&lt;td&gt;磁盘 I/O 延迟柱状图&lt;/td&gt;
&lt;td&gt;热力图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;biosnoop&lt;/td&gt;
&lt;td&gt;每个事件的磁盘 I/O 细节&lt;/td&gt;
&lt;td&gt;表格，偏移热图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;cachestat&lt;/td&gt;
&lt;td&gt;文件系统高速缓存统计&lt;/td&gt;
&lt;td&gt;线状图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7.&lt;/td&gt;
&lt;td&gt;tcplife&lt;/td&gt;
&lt;td&gt;TCP 连接&lt;/td&gt;
&lt;td&gt;表格，分布式图表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8.&lt;/td&gt;
&lt;td&gt;tcpretrans&lt;/td&gt;
&lt;td&gt;TCP 重传&lt;/td&gt;
&lt;td&gt;表格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9.&lt;/td&gt;
&lt;td&gt;runqlat&lt;/td&gt;
&lt;td&gt;CPU 调度器的延迟&lt;/td&gt;
&lt;td&gt;热力图&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10.&lt;/td&gt;
&lt;td&gt;profile&lt;/td&gt;
&lt;td&gt;CPU 堆栈跟踪样本&lt;/td&gt;
&lt;td&gt;火焰图&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这是在我的 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/docs/tutorial.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc Tutorial&lt;/a&gt; 的，而且很多也存在于 bpftrace 中。我选择这些是为了用最少的工具找到最大的性能优势。&lt;/p&gt;
&lt;p&gt;请注意，runqlat 和 profile 会有明显的开销，所以我只运行这些工具 10 到 60 秒，然后生成一份报告。有些工具的开销很低，如果需要的话可以 24 小时运行（例如 execsnoop、biolatency、tcplife、tcpretrans）。&lt;/p&gt;
&lt;p&gt;在 bcc 和 bpftrace 资源库中，已经有以手册和实例文件形式存在的文档，你可以链接到这些文档，以帮助你的客户了解工具的输出。例如，在 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/tools/execsnoop_example.txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/iovisor/bpftrace/blob/master/tools/execsnoop_example.txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt; 有 execsnoop (8) 的示例文件。&lt;/p&gt;
&lt;p&gt;完成这些后，你就有了第一版的仪表板。&lt;/p&gt;
&lt;h2 id=&#34;bcc-与-bpftrace&#34;&gt;bcc 与 bpftrace&lt;/h2&gt;
&lt;p&gt;bcc 工具是最容易使用的，因为它们通常有很多命令行选项。bpftrace 工具更容易编辑和定制，而且 bpftrace 有一个 json 输出模式。&lt;/p&gt;
&lt;p&gt;如果你是追踪的新手，就用 bcc 吧。如果你想做一些黑客和定制的工具，就用 bpftrace。最后，它们都是不错的选择。&lt;/p&gt;
&lt;h2 id=&#34;案例研究netflix&#34;&gt;案例研究：Netflix&lt;/h2&gt;
&lt;p&gt;Netflix 正在建立一个新的 GUI，在这些工具的 bpftrace 版本的基础上，做这个工具仪表盘和更多的工作。架构如图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/how-to-add-bpf-observability/008i3skNly1gys3a6aaa2j31310u0tcj_hu1281580f5509380cd815e555938ab274_151424_1e949c95cac35c688b74d4c44cbaa3b0.webp 400w,
               /blog/how-to-add-bpf-observability/008i3skNly1gys3a6aaa2j31310u0tcj_hu1281580f5509380cd815e555938ab274_151424_527c9635c03f4093f9256fe1c8dcb34b.webp 760w,
               /blog/how-to-add-bpf-observability/008i3skNly1gys3a6aaa2j31310u0tcj_hu1281580f5509380cd815e555938ab274_151424_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-add-bpf-observability/008i3skNly1gys3a6aaa2j31310u0tcj_hu1281580f5509380cd815e555938ab274_151424_1e949c95cac35c688b74d4c44cbaa3b0.webp&#34;
               width=&#34;760&#34;
               height=&#34;584&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;虽然 bpftrace 二进制文件安装在所有目标系统上，但 bpftrace 工具（文本文件）却在网络服务器上，并在需要时被推送出去。这意味着我们可以通过在一个地方更新工具来确保我们一直在运行最新版本的工具。&lt;/p&gt;
&lt;p&gt;这是目前我们 FlameCommander 用户界面的一部分，它也在云端运行火焰图。我们以前的 BPF GUI 是 &lt;a href=&#34;https://github.com/Netflix/vector&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vector&lt;/a&gt; 的一部分，并使用了 bcc，但我们后来废弃了它。我们可能会在某个时候开源新的 GUI，并在 Netflix 技术博客上发表相关文章。&lt;/p&gt;
&lt;h2 id=&#34;案例研究facebook&#34;&gt;案例研究：Facebook&lt;/h2&gt;
&lt;p&gt;Facebook 是 BPF 的高级用户，但他们如何在整个集群中运行工具的深层细节并没有完全公开。根据 bcc 的活动，以及他们对 BTF 和 CO-RE 技术的开发，我十分怀疑他们的解决方案是基于 bcc 的 libbpf-tool 版本。&lt;/p&gt;
&lt;h2 id=&#34;移植的陷阱&#34;&gt;移植的陷阱&lt;/h2&gt;
&lt;p&gt;BPF 追踪工具就像应用程序和内核的补丁。它们需要不断的更新以保持在不同的软件版本中工作。把它们移植到不同的语言，然后不维护它们，可能就像试图把 Linux 4.15 的补丁应用于 Linux 5.12。如果你运气好，它就会工作！如果你不走运，补丁就会应用，但会以一种微妙的方式破坏一些东西，直到后来你才注意到。这取决于工具。&lt;/p&gt;
&lt;p&gt;作为一个极端的例子，我在 2014 年休假时写了 cachestat (8)，用于 Netflix cloud，当时是 Linux 3.2 和 3.13 的混合版本。BPF 在这些版本上并不存在，所以我使用了 Linux 3.2 上的基本 Ftrace 功能。我把这种方法描述为 &lt;a href=&#34;https://www.brendangregg.com/blog/2014-12-31/linux-page-cache-hit-ratio.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;brittle&lt;/a&gt;， &lt;a href=&#34;https://github.com/brendangregg/perf-tools/blob/master/fs/cachestat&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sandcastle&lt;/a&gt; 需要随着内核的变化而进行维护。后来，它被移植到了带有 kprobes 的 BPF 上，现在已经被重写并包含在商业可观察性产品中。我听说它在较新的内核上有问题，打印的输出没有意义。它真的需要一次大修。当我（或某人）做了这个工作，任何从 bcc 上拉取更新的人都会自动得到固定的版本，不需要费力。那些重写的人将需要重写自己的版本。我担心他们不会这样做，而客户将在多年来一直运行一个错误的 cachestat (8) 版本。&lt;/p&gt;
&lt;p&gt;请注意，如果在我写 cachestat (8) 的时候，BPF 在我的目标环境中是可用的，我的编码方式就会完全不同。人们正在移植为 Linux 3.2 编写的东西，并在 Linux 5.x 上运行它。&lt;/p&gt;
&lt;p&gt;在以前的一篇博文 &lt;a href=&#34;https://www.brendangregg.com/blog/2021-06-04/an-unbelievable-demo.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;An Unbelievable Demo&lt;/a&gt; 中，谈到了很多年前发生的类似情况，即在没有更新的情况下使用旧的追踪工具版本。&lt;/p&gt;
&lt;p&gt;我所描述的问题是针对 BPF 软件和内核追踪的。作为一个不同的例子，我的火焰图软件已经被重写了十几次，由于它是一个简单而完备的算法，我不认为这有什么大问题。我更喜欢人们帮助更新 &lt;a href=&#34;https://github.com/spiermar/d3-flame-graph&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;d3 version&lt;/a&gt; 但如果人们自己做，那也没什么大不了的。你可以给它编码，它将永远工作。基于 uprobe 和 kprobe 的 BPF 工具就不是这样了，因为它们确实需要维护。&lt;/p&gt;
&lt;h2 id=&#34;像系统管理员一样思考而不是像程序员一样思考&#34;&gt;像系统管理员一样思考，而不是像程序员一样思考&lt;/h2&gt;
&lt;p&gt;总之，首先检查你的监控系统是否已经有一个 BPF 代理，如果没有，就在现有的基础上构建一个 &lt;a href=&#34;https://github.com/iovisor/bcc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/iovisor/bpftrace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bpftrace&lt;/a&gt; 工具，而不是从头开始重写一切。这是像一个安装和维护软件的系统管理员那样思考，而不是像一个编码所有东西的程序员那样思考。安装 bcc 或 bpftrace 工具，把它们添加到你的可观察性产品中，并根据需要拉取包的更新。这将是一个快速而有用的版本。BPF 启动和运行了！&lt;/p&gt;
&lt;p&gt;我看到人们反而像程序员一样思考，觉得他们必须从深入学习 bcc 和 BPF 编程。然后，在发现所有的东西都是 C 语言或 Python 写的之后，有些人就用不同的语言重写了。&lt;/p&gt;
&lt;p&gt;首先，学好 bcc 和 BPF 需要几周时间；学习系统跟踪的微妙之处和陷阱可能需要几个月或几年。为了让你了解你所面临的情况，请看我的 &lt;a href=&#34;https://www.brendangregg.com/blog/2021-06-15/bpf-internals.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BPF Internals&lt;/a&gt; 讲座。如果你真的想做这个，并且有时间，你当然可以（你可能会在 Tracing 会议上遇到我。在 Linux Plumber’s 或追 Tracing 会上见！）但是，如果你在某个期限内要增加 BPF 的可观察性，那就试着像一个系统管理员那样思考，并在现有的工具基础上进行构建。这是快速的方法。以后再像程序员那样思考，如果你有时间的话。&lt;/p&gt;
&lt;p&gt;第二，BPF 软件，特别是某些基于 kprobe 的工具，需要持续的维护。一个工具可能在 Linux 5.3 上工作，但在 5.4 上就会坏掉，因为一个被追踪的函数被重新命名或增加了一个新的代码路径。BPF 库和框架也在变化和发展，最近的一次是 BTF 和 CO-RE 支持。这是我希望人们在选择重写它们之前要考虑的问题。你是否也有计划重写所有的更新，或者你最终会被困在一个旧的库的端口上？拉取所有的更新比维护你自己的版本更容易。&lt;/p&gt;
&lt;p&gt;最后，如果你有一个比我们在 bcc 和 bpftrace 中使用的更好的 BPF 库或框架的好主意呢？和我们谈谈，试试，创新一下。我们正处于 BPF 时代的开端，还有很多东西需要探索。但请先了解现有的情况以及你所承担的维护负担。你的精力可能会被用来在现有的基础上创造新的东西，而不是移植旧的东西。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>eBPF 和 Wasm：探索服务网格数据平面的未来</title>
      <link>https://cloudnative.to/blog/ebpf-wasm-service-mesh/</link>
      <pubDate>Tue, 11 Jan 2022 10:55:44 +0800</pubDate>
      <guid>https://cloudnative.to/blog/ebpf-wasm-service-mesh/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://infoq.com/news/2022/01/ebpf-wasm-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF and Wasm: Exploring the Future of the Service Mesh Data Plane&lt;/a&gt;，作者 Vivian Hu，发布于 2022 年 1 月 10 日。&lt;/p&gt;
&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;前段时间，有人提出使用 eBPF 取代服务网格中的 sidecar 代理，该观点已经发出，就在服务网格和云原生社区中引起了“轩然大波”。后来也有不少人指出该方案实属武断，不切实际。本文就总结了 eBPF 在服务网格数据平面中的作用，以及使用 Wasm 这种新的方案。&lt;/p&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;2021 年 12 月 2 日，Cilium 项目宣布了 &lt;a href=&#34;https://cilium.io/blog/2021/12/01/cilium-service-mesh-beta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium Service Mesh&lt;/a&gt; 的 beta 测试计划。在谷歌云基于 eBPF 的 Google Cloud Kubernetes Service（GKS）Dataplane V2（于 2020 年 8 月发布）所开创的概念基础上，Cilium Service Mesh 提倡 “无 sidecar 服务网格 &amp;quot; 的理念。它扩展了 Cilium eBPF 产品，以处理服务网格中的大部分 sidecar 代理功能，包括 L7 路由和负载均衡、TLS 终止、访问策略、健康检查、日志和跟踪，以及内置的 Kubernetes Ingress。&lt;/p&gt;
&lt;p&gt;Cillium 的创建者 Isovalent 在一篇题为 “&lt;a href=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;告别 Sidecar—— 使用 eBPF 解锁内核级服务网格&lt;/a&gt; “的文章中解释了使用 eBPF 作为 sidecar 代理的理由。&lt;/p&gt;
&lt;p&gt;它将把我们从 sidecar 模型中解放出来，并允许我们将现有的代理技术整合到现有的内核命名空间概念中，使它们成为我们每天都在使用的容器抽象的一部分。&lt;/p&gt;
&lt;p&gt;简而言之，eBPF 有望解决服务网格中的一个主要痛点 —— 当有许多细粒度的微服务时，性能堪忧。然而，使用 eBPF 来取代 sidecar 代理这个想法也是存在争议的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-告别-sidecar&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;告别 sidecar&#34; srcset=&#34;
               /blog/ebpf-wasm-service-mesh/008i3skNly1gy9u3uba27j31x70u0dk7_hu6485f23e60e2e8e9568294bae27898e8_171400_3ec517e0bfbdc809387e973812172b6f.webp 400w,
               /blog/ebpf-wasm-service-mesh/008i3skNly1gy9u3uba27j31x70u0dk7_hu6485f23e60e2e8e9568294bae27898e8_171400_e9e66ec6f944a2d531d118d18b86143b.webp 760w,
               /blog/ebpf-wasm-service-mesh/008i3skNly1gy9u3uba27j31x70u0dk7_hu6485f23e60e2e8e9568294bae27898e8_171400_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-wasm-service-mesh/008i3skNly1gy9u3uba27j31x70u0dk7_hu6485f23e60e2e8e9568294bae27898e8_171400_3ec517e0bfbdc809387e973812172b6f.webp&#34;
               width=&#34;760&#34;
               height=&#34;329&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      告别 sidecar
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;（来源：&lt;a href=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;告别 Sidecar—— 使用 eBPF 解锁内核级服务网格&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;服务网格中的数据平面指的是管理数据流量如何被路由和交付给微服务应用的基础设施服务。目前，这是通过使用服务代理来实现的。这种设计模式通常也被称为 Sidecar 模式。Sidecar 允许其附属的微服务透明地与服务网格中的其他组件发出和接收请求。&lt;/p&gt;
&lt;p&gt;Sidecar 通常包含一个 L7 网络代理，如 &lt;a href=&#34;https://envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;、&lt;a href=&#34;https://linkerd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt; 或 &lt;a href=&#34;https://mosn.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MOSN&lt;/a&gt;。该代理处理流量路由、负载均衡、健康检查、认证、授权、加密、日志、跟踪和统计数据收集。Sidecar 还可以包含一个基于 SDK 的应用框架，如 &lt;a href=&#34;https://dapr.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dapr&lt;/a&gt;，以提供网络代理以外的应用服务。这种应用服务的例子包括服务注册、服务发现、资源绑定、基于名称的服务调用、状态管理、行为者框架和秘密存储。&lt;/p&gt;
&lt;p&gt;Sidecar 代理和服务通常在 Kubernetes pod 或容器内运行。微服务应用也在容器内运行，它们通过网络接口连接到 sidecar 上。然而，这些容器化应用程序的一个重要问题是资源消耗。Sidecar 服务随着微服务的数量呈几何级数增加。当一个应用程序有数百个相互联系和负载均衡的微服务时，开销可能变得不堪重负。服务网格代理供应商在性能上展开竞争。正如 &lt;a href=&#34;https://www.infoq.com/news/2021/08/linkerd-rust-cloud-native/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfoQ 之前报道的&lt;/a&gt;那样，Linkerd 将其代理从 Go 重写成了 Rust，并取得了明显的性能提升。&lt;/p&gt;
&lt;p&gt;不足为奇的是，现有的服务网格供应商并不相信 eBPF 是能解决我们所有问题的圣杯。来自 Solo 的 Idit Levine 等人写了一篇文章来回应 Cilium 的公告。这篇文章的标题是 “&lt;a href=&#34;https://www.zhaohuabing.com/post/2021-12-19-ebpf-for-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格将使用 eBPF ？是的，但 Envoy 代理将继续存在&lt;/a&gt; &amp;ldquo;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Solo.io，我们认为 eBPF 是优化服务网格的一种强大方式，我们认为 Envoy 代理是数据平面的基石。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Solo.io 作者提出的关键点是，现在的 sidecar 代理所做的事情远远超过了简单的网络流量管理。在今天的服务网格部署中，有一些复杂的要求，远远超过了 eBPF 所支持的有限的编程模型，eBPF 是图灵不完整的，对内核的安全性有许多限制。Cilium eBPF 产品可以处理许多，但不是全部，由 sidecar 代理执行的各种任务。此外，Solo.io 的作者指出，eBPF 的每个节点一个代理的设置提供了更少的灵活性，因此与传统代理的每个节点一个代理的设置相比，增加了整体开销。这些 eBPF 的缺点对于开发者必须编写并部署到服务网格代理中的流量路由、负载均衡和授权的特定应用逻辑来说尤其明显。&lt;/p&gt;
&lt;p&gt;Terate.io 的开发者在对 Cilium 公告的回应中提出了类似的论点，标题是 “&lt;a href=&#34;https://www.tetrate.io/blog/the-debate-in-the-community-about-istio-and-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;社区中关于 Istio 和服务网格的争论&lt;/a&gt; &amp;ldquo;。他们指出，今天的 sidecar 代理的性能是合理的，开源社区已经想出了进一步提高性能的方法。同时，对于开发者来说，在 eBPF 这种新颖的、图灵不完整的技术中构建特定应用的数据平面逻辑是非常困难的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Istio 架构是稳定的，可用于生产的，而且生态系统正在萌芽。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;eBPF 的许多问题与以下事实有关：它是一种内核技术，因此必须有安全限制。有没有一种方法可以将复杂的特定应用的代理逻辑纳入数据平面，而不使用使用空间技术降低性能？事实证明，WebAssembly（Wasm）可能正是这种选择。Wasm 运行时可以安全地隔离并以接近原生的性能执行用户空间代码。&lt;/p&gt;
&lt;p&gt;Envoy Proxy 开创了使用 Wasm 作为扩展机制对数据平面进行编程的方法。开发人员可以用 C、C++、Rust、AssemblyScript、Swift 和 TinyGo 等语言编写特定应用的代理逻辑，并将该模块编译到 Wasm 中。通过 proxy-Wasm 标准，代理可以在 &lt;a href=&#34;https://github.com/bytecodealliance/wasmtime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wasmtime&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/WasmEdge/WasmEdge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WasmEdge&lt;/a&gt; 等高性能运行机制中执行那些 Wasm 插件。目前，&lt;a href=&#34;https://envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Proxy&lt;/a&gt;、&lt;a href=&#34;https://github.com/istio/proxy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Proxy&lt;/a&gt;、MOSN 和 &lt;a href=&#34;http://openresty.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenResty&lt;/a&gt; 支持 &lt;a href=&#34;https://github.com/proxy-wasm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proxy-Wasm&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-容器生态&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;容器生态&#34; srcset=&#34;
               /blog/ebpf-wasm-service-mesh/008i3skNly1gy9u3wo1dnj30u015yq70_hu26b0dad46786521ed5b495b7eb2a0ed8_152531_c5510578fb10abbdd1e61d118af11825.webp 400w,
               /blog/ebpf-wasm-service-mesh/008i3skNly1gy9u3wo1dnj30u015yq70_hu26b0dad46786521ed5b495b7eb2a0ed8_152531_05e358f1c285b926d06f4e0344146a68.webp 760w,
               /blog/ebpf-wasm-service-mesh/008i3skNly1gy9u3wo1dnj30u015yq70_hu26b0dad46786521ed5b495b7eb2a0ed8_152531_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-wasm-service-mesh/008i3skNly1gy9u3wo1dnj30u015yq70_hu26b0dad46786521ed5b495b7eb2a0ed8_152531_c5510578fb10abbdd1e61d118af11825.webp&#34;
               width=&#34;543&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      容器生态
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;（容器生态系统中的 Wasm，来源：&lt;a href=&#34;https://wasmedge.org/book/en/kubernetes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WasmEdge Book&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;此外，Wasm 可以作为一个通用的应用容器。它在服务网格数据平面上的应用并不限于 sidecar 代理。附在 sidecar 上的微服务可以在它自己的轻量级 Wasm 运行时运行。WasmEdge WebAssembly 运行时是一个安全、轻量级、快速、可移植和多元化的运行时，可以直接由 &lt;a href=&#34;https://wasmedge.org/book/en/kubernetes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 作为容器&lt;/a&gt;管理。到 2021 年 12 月，WasmEdge 社区的贡献者证明了基于 WasmEdge 的微服务可以与 &lt;a href=&#34;https://github.com/second-state/dapr-wasm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dapr&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/Liquid-Reply/kind-crun-wasm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt; 一起工作，作为带有操作系统和完整软件堆栈的重量级全面的 Linux 容器的替代。WebAssembly 微服务消耗 1% 的资源，与 Linux 容器应用相比，冷启动的时间是 1%。&lt;/p&gt;
&lt;p&gt;eBPF 和 Wasm 是服务网格应用在数据平面上实现高性能的新生力量。它们仍然是新生的技术，但有可能成为今天微服务生态系统中 Linux 容器的替代品或补充。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>告别 Sidecar——使用 eBPF 解锁内核级服务网格</title>
      <link>https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/</link>
      <pubDate>Thu, 09 Dec 2021 21:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/</guid>
      <description>&lt;p&gt;译者注：本文作者是 Isovalent 联合创始人&amp;amp;CTO，原文标题 &lt;a href=&#34;https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How eBPF will solve Service Mesh - Goodbye Sidecars&lt;/a&gt;，作者回顾了Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;随着分布式应用的引入，额外的可见性、连接性和安全性要求也浮出水面。应用程序组件通过不受信任的网络跨越云和集群边界进行通信，负载均衡、弹性变得至关重要，安全必须发展到发送者和接收者都可以验证彼此的身份的模式。在分布式应用的早期，这些要求是通过直接将所需的逻辑嵌入到应用中来解决的。服务网格将这些功能从应用程序中提取出来，作为基础设施的一部分提供给所有应用程序使用，因此不再需要修改每个应用程序。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务网格示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;服务网格示意图&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hu6485f23e60e2e8e9568294bae27898e8_104054_8698f632d2f6bd2d13968093c75d0a57.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hu6485f23e60e2e8e9568294bae27898e8_104054_7ccad9cc60d4af9f3a79ee25730411ce.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hu6485f23e60e2e8e9568294bae27898e8_104054_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hu6485f23e60e2e8e9568294bae27898e8_104054_8698f632d2f6bd2d13968093c75d0a57.webp&#34;
               width=&#34;760&#34;
               height=&#34;253&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务网格示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;纵观今天服务网格的功能设置，可以总结为以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;弹性连接&lt;/strong&gt;：服务与服务之间的通信必须能够跨越边界，如云、集群和场所。通信必须是有弹性的和容错的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L7 流量管理&lt;/strong&gt;：负载均衡、速率限制和弹性必须是 L7 感知的（HTTP、REST、gRPC、WebSocket 等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于身份的安全&lt;/strong&gt;：依靠网络标识符来实现安全已经不够了，发送和接收服务都必须能够根据身份而不是网络标识符来验证对方。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可观察性和跟踪&lt;/strong&gt;：追踪和指标形式的可观察性对于理解、监控和排除应用程序的稳定性、性能和可用性至关重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;透明&lt;/strong&gt;：该功能必须以透明的方式提供给应用程序，即不需要改变应用程序代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在早期，服务网格的功能通常是以库的形式实现的，要求网格中的每个应用程序都要链接到以应用程序的语言框架编写的库。类似的事情也发生在互联网的早期：曾几何时，应用程序还需要运行自己的 TCP/IP 协议栈！正如我们将在这篇文章中讨论的那样，服务网格正在发展成为一种内核责任，就像网络堆栈一样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于库的服务网格模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于库的服务网格模型&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_hu50a747d0fe993bbedeb4bea6655ecd4b_95490_dc28956fcdaa8533c1e80646c297a1af.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_hu50a747d0fe993bbedeb4bea6655ecd4b_95490_95551f04e0dbe65f3378e151db58034e.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_hu50a747d0fe993bbedeb4bea6655ecd4b_95490_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_hu50a747d0fe993bbedeb4bea6655ecd4b_95490_dc28956fcdaa8533c1e80646c297a1af.webp&#34;
               width=&#34;760&#34;
               height=&#34;247&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于库的服务网格模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今天，服务网格通常使用一种叫做 sidecar 模型的架构来实现。这种架构将实现上述功能的代码封装到第四层代理中，服务间的流量被重定向到这个所谓的 sidecar 代理。它之所以被称为 “挎斗”，是因为每个应用程序都有一个代理，就像挎斗附着在摩托车上一样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-sidecar-的服务网格模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 Sidecar 的服务网格模型&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_hu4fd9e548e6d25e6c485bbd6b10898244_100939_0d600138e96a481444eae67391d42740.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_hu4fd9e548e6d25e6c485bbd6b10898244_100939_a407f59981107c732d11d0d70af1a165.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_hu4fd9e548e6d25e6c485bbd6b10898244_100939_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_hu4fd9e548e6d25e6c485bbd6b10898244_100939_0d600138e96a481444eae67391d42740.webp&#34;
               width=&#34;760&#34;
               height=&#34;281&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 Sidecar 的服务网格模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种架构的优点是，服务不再需要自己实现服务网格的功能。如果许多服务是用不同的语言编写部署的，或者如果你正在运行不可变的第三方应用程序，这就很有好处。&lt;/p&gt;
&lt;p&gt;这种模式的缺点是有大量的代理，许多额外的网络连接，以及复杂的重定向逻辑，将网络流量输入代理。除此之外，在什么类型的网络流量可以被重定向到第四层代理上也有限制。代理（Proxy）在其能支持的网络协议方面是有限的。&lt;/p&gt;
&lt;h2 id=&#34;连接性转移到内核中的历史&#34;&gt;连接性转移到内核中的历史&lt;/h2&gt;
&lt;p&gt;几十年来，在应用程序之间提供安全可靠的连接一直是操作系统的责任。有些人可能还记得早期 Unix 和 Linux 时代的 &lt;a href=&#34;https://en.wikipedia.org/wiki/TCP_Wrappers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TCP 包装器&lt;/a&gt;和 tcpd。tcpd 允许用户在不修改应用程序的情况下透明地添加日志、访问控制、主机名验证和欺骗保护。它使用了 libwrap，而且，在一个有趣的平行于服务网格的故事中，这个库也是以前应用程序提供这些功能的链接对象。tcpd 所带来的是能够在不修改现有应用程序的情况下将这些功能透明地添加到现有应用程序中。最终，所有这些功能都进入了 Linux 本身，并以一种更有效、更强大的方式提供给所有应用程序。今天，这已经发展到了我们所知道的 iptables。&lt;/p&gt;
&lt;p&gt;然而，iptables 显然不适合解决现代应用的连接性、安全性和可观察性要求，因为它只在网络层面上操作，对应用协议层缺乏任何了解。自然，阻力最小的路径是回到库模型，然后是 sidecar 模型。现在，我们正处于这样一个阶段：为了最佳的透明度、效率和安全性，在操作系统中原生地支持这种模式是有意义的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务网格的进化&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;服务网格的进化&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_9bd5af9f2b4e222bd3c4020df3f9c9da.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_8944ed8b5c9c12d06d4e019d777f3674.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_9bd5af9f2b4e222bd3c4020df3f9c9da.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务网格的进化
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 tcpd 时代，曾经的连接记录现在是追踪。IP 层面的访问控制已经演变成应用协议层面的授权，例如使用 JWT。主机名验证已被更强大的认证所取代，如 mTLS。网络负载均衡已经扩展到 L7 流量管理。HTTP 重试是新的 TCP 重传。过去用黑洞路由解决的问题今天被称为断路。这些都不是根本性的新问题，但所需的环境和控制已经发生了变化。&lt;/p&gt;
&lt;h2 id=&#34;扩展内核命名空间概念&#34;&gt;扩展内核命名空间概念&lt;/h2&gt;
&lt;p&gt;Linux 内核已经有一个概念，可以共享共同的功能，并使其对系统上运行的许多应用程序可用。这个概念被称为命名空间（Namespace），它构成了我们今天所知的容器技术的基础。命名空间（内核的那种，不是 Kubernetes 的命名空间）存在于各种抽象中，包括文件系统、用户管理、挂载设备、进程、网络等。这就是允许单个容器呈现不同的文件系统视图、不同的用户集，以及允许多个容器绑定到单个主机上的同一网络端口。在 cgroups 的帮助下，这个概念得到了扩展，可以对 CPU、内存和网络等资源进行管理和优先排序。从云原生应用开发者的角度来看，cgroups 和资源被紧密地整合到我们所知的 &amp;ldquo;容器&amp;rdquo; 概念中。&lt;/p&gt;
&lt;p&gt;符合逻辑的是，如果我们认为服务网格是操作系统的责任，那么它必须符合并整合命名空间和 cgroup 的概念。这看起来会是这样的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-service-mesh-namespace&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Service Mesh Namespace&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0135ea1d7ebbf6b8a4e6efa3962cc545_164573_16f30dbdeb4ebf1dd12714c687c97308.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0135ea1d7ebbf6b8a4e6efa3962cc545_164573_ca4f06178231f71ce281e8690fd8ece5.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0135ea1d7ebbf6b8a4e6efa3962cc545_164573_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0135ea1d7ebbf6b8a4e6efa3962cc545_164573_16f30dbdeb4ebf1dd12714c687c97308.webp&#34;
               width=&#34;760&#34;
               height=&#34;324&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Service Mesh Namespace
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;不出所料，这看起来非常自然，而且可能是大多数用户从简单的角度所期望的。应用程序保持不变，它们继续使用套接字进行通信，就像以前那样。理想的服务网格是作为 Linux 的一部分透明地提供的。它就在那里，就像今天的 TCP 一样。&lt;/p&gt;
&lt;h3 id=&#34;注入-sidecar-的成本&#34;&gt;注入 Sidecar 的成本&lt;/h3&gt;
&lt;p&gt;如果我们仔细研究一下 sidecar 模型，我们会发现它实际上是在试图模仿这种模型。应用程序继续使用套接字，一切都被塞进 Linux 内核的网络命名空间。然而，这比它看起来要复杂得多，需要许多额外的步骤来透明地注入 sidecar 代理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-注入-sidecar-的成本&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;注入 Sidecar 的成本&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_73d4c803cb891797200a45777fbad536.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_230fa8022744b20b7f78ac0299625e07.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_73d4c803cb891797200a45777fbad536.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      注入 Sidecar 的成本
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种额外的复杂性在延迟和额外资源消耗方面付出了巨大的代价。早期的基准测试表明，这对延迟的影响高达 3-4 倍，而且所有代理都需要大量的额外内存。在这篇文章的后面，我们将研究这两点，因为我们将其与基于 eBPF 的模型进行比较。&lt;/p&gt;
&lt;h2 id=&#34;用-ebpf-解锁内核服务网格&#34;&gt;用 eBPF 解锁内核服务网格&lt;/h2&gt;
&lt;p&gt;为什么我们以前没有在内核中创建一个服务网格？有些人半开玩笑地说，kube-proxy 是最初的服务网格（见&lt;a href=&#34;https://www.youtube.com/watch?v=lUF88T16YqY&amp;amp;ab_channel=CloudNativeRejekts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们已经构建了相当多的服务网格 - Tim Hockin, Google&lt;/a&gt;）。这句话是有一定道理的。Kube-proxy 是一个很好的例子，说明了 Linux 内核在依靠传统的基于网络的 iptables 功能实现服务网格时，可以达到多么接近。然而，这还不够，L7 上下文是缺失的。Kube-proxy 完全在网络数据包层面运作。现代应用需要 L7 流量管理、跟踪、认证和额外的可靠性保证。Kube-proxy 不能在网络层面上提供这些。&lt;/p&gt;
&lt;p&gt;eBPF 改变了这个模式。它允许动态地扩展 Linux 内核的功能。我们一直在使用 eBPF 为 Cilium 建立一个高效的网络、安全和可观察性数据通路，并将其直接嵌入到 Linux 内核。应用这个相同的概念，我们也可以在内核层面上解决服务网格的要求。事实上，Cilium 已经实现了各种所需的概念，如基于身份的安全、L3-L7 可观察性和授权、加密和负载均衡。缺少的部分现在正在向 Cilium 涌来。在本博客的末尾，你会发现如何加入由 Cilium 社区推动的 Cilium 服务网格测试项目的细节。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ebpf-服务网格架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;eBPF 服务网格架构&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_hu445db7688add13f894a9eb7f25ded5d7_145770_ec64207fe64f13ddab54f26766098829.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_hu445db7688add13f894a9eb7f25ded5d7_145770_0b120b1c08842e3408423ebcee010fc8.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_hu445db7688add13f894a9eb7f25ded5d7_145770_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_hu445db7688add13f894a9eb7f25ded5d7_145770_ec64207fe64f13ddab54f26766098829.webp&#34;
               width=&#34;760&#34;
               height=&#34;334&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      eBPF 服务网格架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有人可能想知道为什么 Linux 内核社区不直接解决这些需求&lt;/strong&gt;。eBPF 有一个巨大的优势，eBPF 代码可以在运行时插入到现有的 Linux 内核中，类似于 Linux 内核模块，但与内核模块不同，它可以以安全和可移植的方式进行。这使得 eBPF 的实现能够随着服务网格社区的发展而继续发展。&lt;strong&gt;新的内核版本需要几年时间才能进入用户手中&lt;/strong&gt;。eBPF 是一项关键技术，它使 Linux 内核能够跟上快速发展的云原生技术栈。&lt;/p&gt;
&lt;h2 id=&#34;无-sidecar-的基于-ebpf-的-l7-追踪和度量&#34;&gt;无 Sidecar 的基于 eBPF 的 L7 追踪和度量&lt;/h2&gt;
&lt;p&gt;让我们看看 L7 追踪和指标可观察性，作为一个具体的例子，说明基于 eBPF 的服务网格对保持低延迟和提高观察性有巨大的影响。应用程序团队依靠应用程序的可见性和监控作为基本要求这些，这包括请求跟踪、HTTP 响应率和服务延迟信息等能力。然而，这种可观察性应该没有明显的成本（延迟、复杂性、资源…）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-ebpf-的可视性&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 eBPF 的可视性&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hufd2b0ecfb4e71144719ce40203bf6eba_169325_3c5ffec4c37ab13904b7ad3f8850c40b.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hufd2b0ecfb4e71144719ce40203bf6eba_169325_9df96ff7ec97749415a91faf059c43e6.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hufd2b0ecfb4e71144719ce40203bf6eba_169325_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hufd2b0ecfb4e71144719ce40203bf6eba_169325_3c5ffec4c37ab13904b7ad3f8850c40b.webp&#34;
               width=&#34;760&#34;
               height=&#34;241&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 eBPF 的可视性
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在下面的基准测试中，我们可以看到早期的测量结果，即通过 eBPF 或 sidecar 方法实现 HTTP 可见性对延迟的影响。该设置是在两个不同节点上运行的两个 pod 之间通过固定数量的连接每秒稳定运行 10K 个 HTTP 请求，并测量请求的平均延时。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-ebpf-的延迟基准测试-vs-基于-sidecar-的-l7-可视性&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 eBPF 的延迟基准测试 vs 基于 Sidecar 的 L7 可视性&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu7a5bfe8bc9fa18fe7dc7457a21c91d33_61285_7cf7567252f38f870003e2bdc6cfef48.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu7a5bfe8bc9fa18fe7dc7457a21c91d33_61285_9a381eb32592d94bdcc1720e2bf4a21c.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu7a5bfe8bc9fa18fe7dc7457a21c91d33_61285_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu7a5bfe8bc9fa18fe7dc7457a21c91d33_61285_7cf7567252f38f870003e2bdc6cfef48.webp&#34;
               width=&#34;760&#34;
               height=&#34;347&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 eBPF 的延迟基准测试 vs 基于 Sidecar 的 L7 可视性
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们故意不提这些测量中使用的具体代理，因为它并不重要。对于我们测试过的所有代理，结果几乎都是一样的。要明确的是，这不是关于 Envoy、Linkerd、Nginx 或其他代理是否更快。所提到的代理有差异，但与首先注入代理的成本相比，它们是微不足道的。&lt;strong&gt;几乎没有开销是来自代理本身的逻辑。开销是通过注入代理，将网络流量重定向到它，终止连接和启动新的连接而增加的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些早期的测量结果表明，基于 eBPF 的内核方法是非常有前途的，可以实现完全透明的服务网格的愿望，而且没有明显的开销。&lt;/p&gt;
&lt;h2 id=&#34;使用-ebpf-加速的-per-node-代理&#34;&gt;使用 eBPF 加速的 per-node 代理&lt;/h2&gt;
&lt;p&gt;越来越多的用例可以用这种仅有 eBPF 的方法来覆盖，从而完全取消 L4 代理。有些用例，仍然需要代理。例如，当连接需要拼接时，当 TLS 终止被执行时，或对于某些形式的 HTTP 授权。&lt;/p&gt;
&lt;p&gt;我们的 eBPF 服务网格工作将继续关注那些从性能角度可以获得最大收益的领域。如果你必须执行 TLS 终止，你可能不介意在流量流入集群时用代理终止一次连接。然而，你会更关心在每个连接的路径中注入两个代理的影响，以提取 HTTP 指标和跟踪数据。&lt;/p&gt;
&lt;p&gt;当一个用例不能用纯 eBPF 的方法来实现时，网格可以回退到每个节点的代理模型，直接将代理与内核的套接字层结合起来。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ebpf-per-node-proxy&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;eBPF per-node Proxy&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu7eadff7af9f47974f13c9174791de55f_203134_cae09a072642115218e86546c57c2871.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu7eadff7af9f47974f13c9174791de55f_203134_bd76ad40fcfd5a162be8d7e6e709f964.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu7eadff7af9f47974f13c9174791de55f_203134_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu7eadff7af9f47974f13c9174791de55f_203134_cae09a072642115218e86546c57c2871.webp&#34;
               width=&#34;760&#34;
               height=&#34;337&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      eBPF per-node Proxy
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;eBPF 不依赖网络级的重定向，而是直接在套接字级别注入代理，保持路径短。在 Cilium 的案例中，正在使用 Envoy 代理，尽管从架构的角度来看，任何代理都可以被整合到这个模型。从概念上讲，这允许将 Linux 内核网络命名空间的概念直接扩展到 Envoy 监听器配置的概念，并将 Envoy 变成一个多用户代理。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-与-per-node-代理&#34;&gt;Sidecar 与 per-Node 代理&lt;/h2&gt;
&lt;p&gt;即使需要代理，代理的成本也会根据部署的架构而有所不同。让我们来看看每个节点的代理模式与 sidecar 模式的比较。&lt;/p&gt;
&lt;h3 id=&#34;每个连接的代理&#34;&gt;每个连接的代理&lt;/h3&gt;
&lt;p&gt;所需的网络连接数将因是否有代理而不同。最简单的情况是无 sidecar 模式，这意味着网络连接的数量没有变化。一个单一的连接将为请求提供服务，eBPF 将提供服务网格功能，如跟踪或现有连接上的负载均衡。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-ebpf-的模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 eBPF 的模型&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hua57ac0fec04afe9a17972f7f65b18710_75274_b1bb728478bd4a1d987e48d14e04251b.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hua57ac0fec04afe9a17972f7f65b18710_75274_a955581f54b7ac14d5395e3d87b55296.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hua57ac0fec04afe9a17972f7f65b18710_75274_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hua57ac0fec04afe9a17972f7f65b18710_75274_b1bb728478bd4a1d987e48d14e04251b.webp&#34;
               width=&#34;760&#34;
               height=&#34;191&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 eBPF 的模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;用 sidecar 模型提供同样的功能需要在连接中注入两次代理，这导致需要维护三个连接。这导致了开销的增加和所有额外的套接字缓冲区所需内存的倍增，表现为更高的服务间延迟。这就是我们之前在无 sidecar L7 可见性部分看到的 sidecar 开销。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-sidecar-代理的模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 Sidecar 代理的模型&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_hu773322c04982bb804c1017287914b0af_101275_47704abc0bc4ccd15f3e324e29995d3e.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_hu773322c04982bb804c1017287914b0af_101275_186ea6bca077e39bf5fb3791fc9b7d14.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_hu773322c04982bb804c1017287914b0af_101275_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_hu773322c04982bb804c1017287914b0af_101275_47704abc0bc4ccd15f3e324e29995d3e.webp&#34;
               width=&#34;760&#34;
               height=&#34;203&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 Sidecar 代理的模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;切换到 per-node 的代理模式使我们能够摆脱其中一个代理，因为我们不再依赖在每个工作负载中运行一个 sidecar。比起不需要额外的连接，这还是不够理想，但比起总是需要两个额外的连接要好。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-per-node-代理模式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Per-node 代理模式&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hu15d35ae3518e01d6235ec2f122222c42_89210_7bde5738f26376430d21264bb186b5f0.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hu15d35ae3518e01d6235ec2f122222c42_89210_7ce78a2664dc15bb076096454262f429.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hu15d35ae3518e01d6235ec2f122222c42_89210_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hu15d35ae3518e01d6235ec2f122222c42_89210_7bde5738f26376430d21264bb186b5f0.webp&#34;
               width=&#34;760&#34;
               height=&#34;225&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Per-node 代理模式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;所需的代理总数&#34;&gt;所需的代理总数&lt;/h3&gt;
&lt;p&gt;在每个工作负载中运行一个 sidecar 会导致大量的代理。即使每个单独的代理实例在其内存占用方面是相当优化的，但实例的数量之多将导致总的影响很大。此外，每个代理维护的数据结构，如路由和端点表，随着集群的增长而增长，所以集群越大，每个代理的内存消耗就越高。今天，一些服务网格试图通过将部分路由表推送给单个代理来解决这个问题，限制它们可以路由到哪里。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-代理数量&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;代理数量&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hu6485f23e60e2e8e9568294bae27898e8_147190_e5e6f2c7d1de4f5108e2f0c65c63633b.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hu6485f23e60e2e8e9568294bae27898e8_147190_2648ed10ae21eaef48205e7b5665caec.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hu6485f23e60e2e8e9568294bae27898e8_147190_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hu6485f23e60e2e8e9568294bae27898e8_147190_e5e6f2c7d1de4f5108e2f0c65c63633b.webp&#34;
               width=&#34;760&#34;
               height=&#34;262&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      代理数量
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;让我们假设在一个 500 个节点的集群中，每一个节点有 30 个 pod，一个基于 sidecar 的架构将需要运行 15K 个代理。在每个代理消耗 70MB 内存的情况下（假设已经经过极致优化过的路由表），这仍然导致集群中所有 sidecar 消耗 1.5TB 的内存。在 per-node 模型中，假设每个代理的内存足迹相同，500 个代理将消耗不超过 34GB 的内存。&lt;/p&gt;
&lt;h3 id=&#34;多租户&#34;&gt;多租户&lt;/h3&gt;
&lt;p&gt;当我们从 sidecar 模型转向 per-node 模型时，代理将为多个应用程序提供连接。代理必须具有多租户感知。这与我们从使用单个虚拟机转向使用容器时发生的过渡完全相同。由于我们不再使用在每个虚拟机中运行的完全独立的操作系统副本，而开始与多个应用程序共享操作系统，Linux 必须具有多租户感知。这就是命名空间和 cgroup 存在的原因。如果没有它们，一个容器可能会消耗一个系统的所有资源，容器可能会以不受控制的方式访问对方的文件系统。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-envoy-namespace&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Envoy Namespace&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu343c7ddad575180196b4717ceccff05e_154426_4c59051f9b916a64e84a2f5ffc02b30e.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu343c7ddad575180196b4717ceccff05e_154426_ea1a9152506ca77c4c47844ffafb9563.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu343c7ddad575180196b4717ceccff05e_154426_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu343c7ddad575180196b4717ceccff05e_154426_4c59051f9b916a64e84a2f5ffc02b30e.webp&#34;
               width=&#34;760&#34;
               height=&#34;423&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Envoy Namespace
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果这在服务网格级别的网络资源上表现得完全一样，那不是很好吗？Envoy 已经有了命名空间的初步概念，它们被称为监听器。监听器可以携带单独的配置并独立运行。这将开启全新的可能性：突然间，我们可以很容易地控制资源消耗，建立公平的排队规则，并将可用的资源平等地分配给所有的应用程序，或者按照指定的规则分配。这可以而且应该与我们今天在 Kubernetes 中定义应用程序的 CPU 和内存约束的方式完全一样。如果你想了解这个话题，我曾在 EnvoyCon 上讲过这个问题（&lt;a href=&#34;https://www.youtube.com/watch?v=08opgZkdYIw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Namespace - 以更小的代价运维基于 Envoy 的服务网格，Thomas Graf，EnvoyCon 2019&lt;/a&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;想参与其中吗--加入-cilium-服务网格测试版&#34;&gt;想参与其中吗？- 加入 Cilium 服务网格测试版&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-测试版&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;测试版&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_huba226543b9600e73651fc49ff93da841_178422_e129888b36894c5dfc6f5bdbaa5f88c3.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_huba226543b9600e73651fc49ff93da841_178422_5fa12c343403dc5a4a5172ebff80348b.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_huba226543b9600e73651fc49ff93da841_178422_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_huba226543b9600e73651fc49ff93da841_178422_e129888b36894c5dfc6f5bdbaa5f88c3.webp&#34;
               width=&#34;760&#34;
               height=&#34;286&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      测试版
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;伴随着即将发布的 Cilium 1.11 版本，Cilium 社区正在举办一个新的 Cilium Service Mesh 测试计划。它的特点是一个新的构建，将使以下功能可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L7 流量管理和负载均衡（HTTP，gRPC，…）&lt;/li&gt;
&lt;li&gt;跨集群、云和集群的拓扑感知路由&lt;/li&gt;
&lt;li&gt;TLS 终止&lt;/li&gt;
&lt;li&gt;通过 Envoy 配置的金丝雀发布、重试、速率限制、断路等&lt;/li&gt;
&lt;li&gt;用 OpenTelemetry 和 Jaeger 集成进行追踪&lt;/li&gt;
&lt;li&gt;内置 Kubernetes Ingress 支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述所有功能都可以在 &lt;a href=&#34;https://github.com/cilium/cilium&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;github.com/cilium/cilium&lt;/a&gt; 功能分支中找到。测试计划允许 Cilium 维护者直接与用户接触，了解他们的需求。要注册，你可以直接填写 &lt;a href=&#34;https://forms.gle/j9fwhAC6HnHRJQKeA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这个表格&lt;/a&gt;，或者你可以在 Cilium 社区的&lt;a href=&#34;https://cilium.io/blog/2021/12/01/cilium-service-mesh-beta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公告&lt;/a&gt;中阅读更多关于该计划的信息。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;eBPF 是提供本地和高效的服务网格实现的答案。它将把我们从 sidecar 模型中解放出来，并允许将现有的代理技术整合到现有的内核命名概念中，使它们成为我们每天都在使用的容器抽象的一部分。除此之外，eBPF 将能够卸载越来越多的目前由代理执行的功能，以进一步减少开销和复杂性。通过整合几乎任何现有的代理，该架构也允许与大多数现有的服务网格控制平面（Istio、SMI、Linkerd…）整合。这可以将 eBPF 的好处提供给广大的终端用户，同时将数据通路的效率和开销的讨论与控制平面方面相分离。&lt;/p&gt;
&lt;p&gt;如果你有兴趣探索这个话题，我们很想听到你的意见。请随时通过 &lt;a href=&#34;https://twitter.com/tgraf__&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Twitter&lt;/a&gt; 或 &lt;a href=&#34;http://ebpf.io/slack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF &amp;amp; Cilium Slack 联系我们&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;进一步阅读&#34;&gt;进一步阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/blog/how-ebpf-streamlines-the-service-mesh/&#34;&gt;eBPF 如何简化服务网格&lt;/a&gt;，Liz Rice，The New Stack&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cilium.io/blog/2021/12/01/cilium-service-mesh-beta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium 服务网格测试计划&lt;/a&gt;，Cilium 社区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cilium.io/learn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;了解更多关于 Cilium 的信息&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>eBPF 如何简化服务网格</title>
      <link>https://cloudnative.to/blog/how-ebpf-streamlines-the-service-mesh/</link>
      <pubDate>Wed, 27 Oct 2021 13:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/how-ebpf-streamlines-the-service-mesh/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://thenewstack.io/how-ebpf-streamlines-the-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How eBPF Streamlines the Service Mesh&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;今天有几个服务网格的产品和项目，承诺简化应用微服务之间的连接，同时提供额外的功能，如安全连接、可观察性和流量管理。但正如我们在过去几年中反复看到的那样，对服务网格的兴奋已经被对&lt;a href=&#34;https://nowei.github.io/projects/svc_mesh_measurement_final_report.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;额外的&lt;/a&gt;&lt;a href=&#34;https://engineering.hellofresh.com/everything-we-learned-running-istio-in-production-part-2-ff4c26844bfb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;复杂性&lt;/a&gt;和&lt;a href=&#34;https://pklinker.medium.com/performance-impacts-of-an-istio-service-mesh-63957a0000b&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开销的&lt;/a&gt;实际&lt;a href=&#34;https://medium.com/geekculture/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;担忧所抑制&lt;/a&gt;。让我们来探讨一下 &lt;a href=&#34;https://ebpf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 是如何让我们精简&lt;a href=&#34;https://thenewstack.io/category/service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格&lt;/a&gt;，使服务网格的数据平面更有效率，更容易部署。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-问题&#34;&gt;Sidecar 问题&lt;/h2&gt;
&lt;p&gt;今天的 Kubernetes 服务网格解决方案要求你在每一个应用 pod 上添加一个代理 sidecar 容器，如 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 或 &lt;a href=&#34;https://linkerd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd-proxy&lt;/a&gt;。这是正确的：即使在一个非常小的环境中，比如说有 20 个服务，每个服务运行五个 pod，分布在三个节点上，你也有 100 个代理容器。无论代理的实现多么小和有效，这种纯粹的重复都会耗费资源。&lt;/p&gt;
&lt;p&gt;每个代理使用的内存与它需要能够通信的服务数量有关。Pranay Singhal 写了他配置 Istio 的&lt;a href=&#34;https://medium.com/geekculture/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;经验&lt;/a&gt;，将每个代理的消耗从 1GB 左右减少到更合理的 60-70MB。但是，即使在我们的小环境中，在三个节点上有 100 个代理，这种优化配置仍然需要每个节点 2GB 左右。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-来自redhatcomarchitectwhy-when-service-mesh每个微服务都有自己的代理sidecar&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;来自&amp;lt;a href=&amp;#34;https://redhat.com/architect/why-when-service-mesh&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;redhat.com/architect/why-when-service-mesh&amp;lt;/a&amp;gt;——每个微服务都有自己的代理sidecar&#34; srcset=&#34;
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu75cdf8ad6ac0b3f98f9051bf67fd2e5c_260906_e82772dc16b0798bb43fb88f2ac134cc.webp 400w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu75cdf8ad6ac0b3f98f9051bf67fd2e5c_260906_fb23a1ea63de7ecc49e5bdb7fd35317a.webp 760w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu75cdf8ad6ac0b3f98f9051bf67fd2e5c_260906_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu75cdf8ad6ac0b3f98f9051bf67fd2e5c_260906_e82772dc16b0798bb43fb88f2ac134cc.webp&#34;
               width=&#34;760&#34;
               height=&#34;334&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      来自&amp;lt;a href=&amp;#34;https://redhat.com/architect/why-when-service-mesh&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;redhat.com/architect/why-when-service-mesh&amp;lt;/a&amp;gt;——每个微服务都有自己的代理sidecar
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为什么我们需要所有这些 sidecar？这种模式允许代理容器与 pod 中的应用容器共享一个网络命名空间。网络命名空间是 Linux 内核的结构，它允许容器和 pod 拥有自己独立的网络堆栈，将容器化的应用程序相互隔离。这使得应用之间互不相干，这就是为什么你可以让尽可能多的 pod 在 80 端口上运行一个 web 应用 —— 网络命名空间意味着它们各自拥有自己的 80 端口。代理必须共享相同的网络命名空间，这样它就可以拦截和处理进出应用容器的流量。&lt;/p&gt;
&lt;h2 id=&#34;引入-ebpf&#34;&gt;引入 eBPF&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://ebpf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 是一种内核技术，允许自定义程序在内核中运行。这些程序在响应事件时运行，有成千上万个可能的事件，eBPF 程序可以被附加到这些事件上。这些事件包括轨迹点、进入或退出任何功能（在内核或用户空间）或对服务网格来说很重要的 —— 抵达的网络数据包。&lt;/p&gt;
&lt;p&gt;重要的是，&lt;strong&gt;每个节点只有一个内核&lt;/strong&gt;；在一个节点上运行的所有容器（也就是所有的 pod）共享同一个内核。如果你在内核中添加一个 eBPF 程序到一个事件中，它将被触发，无论哪个进程引起该事件，无论它是在应用容器中运行还是直接运行在主机上。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-每台主机一个内核&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;每台主机一个内核&#34; srcset=&#34;
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_huccdd52df4dca33c37eced58c2e8ea8ae_143240_847d0bf365ee18cfcdd849278134a758.webp 400w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_huccdd52df4dca33c37eced58c2e8ea8ae_143240_db8f980112e5dfb449eac44c9bb97115.webp 760w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_huccdd52df4dca33c37eced58c2e8ea8ae_143240_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_huccdd52df4dca33c37eced58c2e8ea8ae_143240_847d0bf365ee18cfcdd849278134a758.webp&#34;
               width=&#34;760&#34;
               height=&#34;453&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      每台主机一个内核
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这就是为什么 eBPF 对于 Kubernetes 中的任何一种 instrumentation 来说都是如此令人兴奋的技术 —— 你只需要在每个节点上添加一次 instrumentation ，所有的应用程序 pod 都会被覆盖。无论你是在寻求可观察性、安全性还是网络，由 eBPF 驱动的解决方案都可以在不需要 sidecar 的情况下对应用进行检测。&lt;/p&gt;
&lt;p&gt;基于 eBPF 的 &lt;a href=&#34;http://cilium.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium&lt;/a&gt; 项目（最近 &lt;a href=&#34;https://www.cncf.io/blog/2021/10/13/cilium-joins-cncf-as-an-incubating-project/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以孵化级别加入云计算基金会&lt;/a&gt;）将这种 “无 sidecar&amp;quot; 模式带到了服务网格的世界。除了传统的 sidecar 模型，Cilium 还支持每个节点使用一个 Envoy 代理实例运行服务网格的数据平面。使用我们前面的例子，这就把代理实例的数量从 100 个减少到只有 3 个。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-用无sidecar代理模式减少代理实例&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;用无sidecar代理模式减少代理实例&#34; srcset=&#34;
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu3d32db78b48b2e257874198dc348cb5b_165479_b7de8ef9d83f49c194072ed86daeb771.webp 400w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu3d32db78b48b2e257874198dc348cb5b_165479_df1496e3029f185d02ebf3eb8de2416b.webp 760w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu3d32db78b48b2e257874198dc348cb5b_165479_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu3d32db78b48b2e257874198dc348cb5b_165479_b7de8ef9d83f49c194072ed86daeb771.webp&#34;
               width=&#34;760&#34;
               height=&#34;327&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      用无sidecar代理模式减少代理实例
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;减少-yaml&#34;&gt;减少 YAML&lt;/h2&gt;
&lt;p&gt;在 sidecar 模型中，指定每个应用 pod 的 YAML 需要被修改以添加 sidecar 容器。这通常是自动化的 —— 例如，使用一个 mutating webhook，在每个应用 pod 部署的时候注入 sidecar。&lt;/p&gt;
&lt;p&gt;以 Istio 为例，这需要&lt;a href=&#34;https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/#controlling-the-injection-policy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标记&lt;/a&gt; Kubernetes 命名空间和 / 或 pod，以定义是否应该注入 sidecar—— 当然也需要为集群启用 mutating webhook。&lt;/p&gt;
&lt;p&gt;但如果出了问题怎么办？如果命名空间或 pod 的标签不正确，那么 sidecar 将不会被注入，pod 将不会被连接到服务网格。更糟糕的是，如果攻击者破坏了集群，并能够运行一个恶意的工作负载 —— 例如，一个加密货币矿工，他们将不太可能标记它，以便它加入服务网格。它不会通过服务网格提供的流量观察能力而被发现。&lt;/p&gt;
&lt;p&gt;相比之下，在支持 eBPF 的无 sidecar 代理模型中，pod 不需要任何额外的 YAML 就可以被检测。相反，一个 CRD 被用来在集群范围内配置服务网格。即使是已经存在的 pod 也可以成为服务网格的一部分，而不需要重新启动。&lt;/p&gt;
&lt;p&gt;如果攻击者试图通过直接在主机上运行工作负载来绕过 Kubernetes 编排，eBPF 程序可以检测并控制这一活动，因为这一切都可以从内核看到。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-支持的网络效率&#34;&gt;eBPF 支持的网络效率&lt;/h2&gt;
&lt;p&gt;支持 eBPF 的网络允许数据包走捷径，绕过内核的部分网络堆栈，这可以使 Kubernetes 网络的&lt;a href=&#34;https://cilium.io/blog/2021/05/11/cni-benchmark&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;性能得到显著改善&lt;/a&gt;。让我们看看这在服务网格数据平面中是如何应用的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-在ebpf加速无sidecar的服务网格模型中网络数据包通过的路径要短得多&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;在eBPF加速、无sidecar的服务网格模型中，网络数据包通过的路径要短得多&#34; srcset=&#34;
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu2dc6a1f8e53eb927656788db4b31bc51_202323_7a9a484930ac06c27ab63979ee78513d.webp 400w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu2dc6a1f8e53eb927656788db4b31bc51_202323_f6be66e36d0a6d7b08ee504b51dfc6b7.webp 760w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu2dc6a1f8e53eb927656788db4b31bc51_202323_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu2dc6a1f8e53eb927656788db4b31bc51_202323_7a9a484930ac06c27ab63979ee78513d.webp&#34;
               width=&#34;760&#34;
               height=&#34;366&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      在eBPF加速、无sidecar的服务网格模型中，网络数据包通过的路径要短得多
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在服务网格的情况下，代理在传统网络中作为 sidecar 运行，数据包到达应用程序的路径相当曲折：入站数据包必须穿越主机 TCP/IP 栈，通过虚拟以太网连接到达 pod 的网络命名空间。从那里，数据包必须穿过 pod 的网络堆栈到达代理，代理将数据包通过回环接口转发到应用程序。考虑到流量必须在连接的两端流经代理，与非服务网格流量相比，这将导致延迟的&lt;a href=&#34;https://linkerd.io/2021/05/27/linkerd-vs-istio-benchmarks/#latency-at-20-rps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;显著增加&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;基于 eBPF 的 Kubernetes CNI 实现，如 Cilium，可以使用 eBPF 程序，明智地钩住内核中的特定点，沿着更直接的路线重定向数据包。这是可能的，因为 Cilium 知道所有的 Kubernetes 端点和服务的身份。当数据包到达主机时，Cilium 可以将其直接分配到它所要去的代理或 Pod 端点。&lt;/p&gt;
&lt;h2 id=&#34;网络中的加密&#34;&gt;网络中的加密&lt;/h2&gt;
&lt;p&gt;如果一个网络解决方案能够意识到 Kubernetes 服务，并在这些服务的端点之间提供网络连接，那么它能够提供服务网格数据平面的能力就不足为奇。但这些能力可以超越基本的连接。一个例子是透明加密。&lt;/p&gt;
&lt;p&gt;通常使用服务网格来确保所有的应用流量都是经过认证和加密的。这是通过双向 TLS（mTLS）实现的；服务网格代理组件作为网络连接的端点，并与其远程对等物协商一个安全的 TLS 连接。这种连接对代理之间的通信进行加密，而不需要对应用程序做任何改变。&lt;/p&gt;
&lt;p&gt;但在应用层管理的 TLS 并不是实现组件间认证和加密流量的唯一方法。另一个选择是在网络层加密流量，使用 &lt;a href=&#34;https://cilium.io/blog/2021/05/11/cni-benchmark#the-cost-of-encryption---wireguard-vs-ipsec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IPSec 或 WireGuard&lt;/a&gt;。因为它在网络层操作，这种加密不仅对应用程序完全透明，而且对代理也是透明的 —— 它可以在有或没有服务网格时启用。如果你使用服务网格的唯一原因是提供加密，你可能想考虑网络级加密。它不仅更简单，而且还可以用来验证和加密节点上的任何流量 —— 它不只限于那些启用了 sidecar 的工作负载。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-是服务网格的数据平面&#34;&gt;eBPF 是服务网格的数据平面&lt;/h2&gt;
&lt;p&gt;现在，eBPF 在 Linux 生产发行版使用的内核版本中得到广泛支持，企业可以利用它来获得更有效的网络解决方案，并作为服务网格的更有效的数据平面。&lt;/p&gt;
&lt;p&gt;去年，我代表 &lt;a href=&#34;https://cncf.io/?utm_content=inline-mention&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF&lt;/a&gt; 的技术监督委员会，对服务网格领域的整合和清晰化做了一些 &lt;a href=&#34;https://youtu.be/bESogtuHwX0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;预测&lt;/a&gt;。在同一主题演讲中，我谈到 eBPF 有可能成为更多项目和更广泛部署能力的基础。这两个想法现在正结合在一起，因为 eBPF 似乎是服务网格数据平面的自然路径。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编译运行Linux内核源码中的eBPF示例代码</title>
      <link>https://cloudnative.to/blog/compile-bpf-examples/</link>
      <pubDate>Thu, 06 Aug 2020 19:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/compile-bpf-examples/</guid>
      <description>&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;声明：下文提到的&lt;code&gt;bpf/BPF&lt;/code&gt;字样是泛指，包括&lt;code&gt;cBPF&lt;/code&gt;和&lt;code&gt;eBPF&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过文章，你能了解Linux内核代码中关于bpf程序的编译运行机制，并能学会如何基于Linux内核bpf示例环境编写你自己的bpf程序。文章涉及的实验环境和代码可以到这个git repo获取：
&lt;a href=&#34;https://github.com/nevermosby/linux-bpf-learning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/nevermosby/linux-bpf-learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近Kubecon 2020 China上已经有了3个关于bpf的中文分享（来自腾讯和PingCAP），也看到国内第一梯队公司越来越关心bpf这项新技术，欢迎大家都能加入bpf学习队伍。&lt;/p&gt;
&lt;h2 id=&#34;内核源码里的bpf示例代码概述&#34;&gt;内核源码里的BPF示例代码概述&lt;/h2&gt;
&lt;p&gt;示例代码里基本是&lt;strong&gt;kern&lt;/strong&gt;和&lt;strong&gt;user&lt;/strong&gt;成对出现，也就是对于一个示例来说，分别提供了在内核空间运行的和用户空间运行的程序，绝对是良心之作了。&lt;/p&gt;
&lt;h2 id=&#34;下载linux内核源代码&#34;&gt;下载Linux内核源代码&lt;/h2&gt;
&lt;p&gt;First thing first，第一步是下载内核代码。&lt;/p&gt;
&lt;h3 id=&#34;选择内核版本&#34;&gt;选择内核版本&lt;/h3&gt;
&lt;p&gt;目前社区维护的内核版本繁多，你需要确定下载哪个版本的代码。个人建议是下载与你的操作系统运行一致的内核版本，避免后续编译时出现不兼容问题。&lt;/p&gt;
&lt;h3 id=&#34;选择下载渠道&#34;&gt;选择下载渠道&lt;/h3&gt;
&lt;p&gt;代码下载渠道也很多：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过Linux社区官方仓库下载。以下几个网站都是官方维护的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/torvalds/linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&lt;/a&gt;
观察下来，只要有新的commit，基本是实时同步的，下载最新版本的内核代码肯定没问题。如果你跟我一样，需要相对较旧的版本，只要切换相关的目标tag即可。我的内核版本是&lt;strong&gt;v4.15.0&lt;/strong&gt;，下载地址参考如下：
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/tree/v4.15&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/torvalds/linux/tree/v4.15&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tag/?h=v4.15&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tag/?h=v4.15&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过Ubuntu apt仓库下载。Ubuntu官方自己维护了每个操作系统版本的背后的Linux内核代码，可以通过以下两种apt命令方式获取相关代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 第一种方式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 先搜索&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; apt-cache search linux-source
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-4.15.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 4.15.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-4.18.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 4.18.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-5.0.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 5.0.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux-source-5.3.0 - Linux kernel &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; version 5.3.0 with Ubuntu patches
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 再安装&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; apt install linux-source-4.15.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 第二种方式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; apt-get &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; linux
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Reading package lists... Done
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NOTICE: &lt;span class=&#34;s1&#34;&gt;&amp;#39;linux&amp;#39;&lt;/span&gt; packaging is maintained in the &lt;span class=&#34;s1&#34;&gt;&amp;#39;Git&amp;#39;&lt;/span&gt; version control system at:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/bionic
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Please use:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/bionic
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;to retrieve the latest &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;possibly unreleased&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; updates to the package.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Need to get &lt;span class=&#34;m&#34;&gt;167&lt;/span&gt; MB of &lt;span class=&#34;nb&#34;&gt;source&lt;/span&gt; archives.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Get:2 https://mirrors.ustc.edu.cn/ubuntu bionic-updates/main linux 4.15.0-99.100 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;tar&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;158&lt;/span&gt; MB&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;......
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 以上两种方式，内核源代码均下载至/usr/src/目录下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下载完成后，BPF示例就在&lt;strong&gt;源码根目录/samples/bpf&lt;/strong&gt;目录下，可以到&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;看个在线版的，建议大家通读一遍这个目录下的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf/README.rst&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;README.rst&lt;/a&gt;，了解整体步骤。&lt;/p&gt;
&lt;h2 id=&#34;编译bpf示例代码&#34;&gt;编译BPF示例代码&lt;/h2&gt;
&lt;h3 id=&#34;安装编译所依赖的工具&#34;&gt;安装编译所依赖的工具&lt;/h3&gt;
&lt;p&gt;在真正开始编译工作之前，请确保你的实验环境已经安装&lt;code&gt;clang&lt;/code&gt;和&lt;code&gt;llvm&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clang &amp;gt;= version 3.4.0&lt;/li&gt;
&lt;li&gt;llvm &amp;gt;= version 3.7.1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;正式编译示例代码&#34;&gt;正式编译示例代码&lt;/h3&gt;
&lt;p&gt;万事俱备了，可以正式开始编译工作。我们说的“编译”其本质就是利用内核目录下不同的&lt;code&gt;Makefile&lt;/code&gt;，通过特定的&lt;code&gt;make&lt;/code&gt;指令完成特定工作。来，先上命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 切换到内核源代码根目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; linux_sourcecode/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 生成内核编译时需要的头文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make headers_install
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 可视化选择你想为内核添加的内核模块，最终生成保存了相关模块信息的.config文件，为执行后面的命令做准备&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make menuconfig
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 使用make命令编译samples/bpf/目录下所有bpf示例代码，注意需要加上最后的/符号&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make samples/bpf/ &lt;span class=&#34;c1&#34;&gt;# or  make M=samples/bpf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如下截图看结果，生成了一大堆的文件，有&lt;code&gt;.o&lt;/code&gt;后缀的目标文件，还有绿色高亮的可执行文件，挑两个执行下，效果符合期待。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kernel-bpf-examples&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;kernel-bpf-examples&#34; srcset=&#34;
               /blog/compile-bpf-examples/bpf-kernel-examples_hud2d1bd975ff7a854c43bd69b6af7af9d_351870_7cc7208bdfbded5b98b6bb4bb1d19e63.webp 400w,
               /blog/compile-bpf-examples/bpf-kernel-examples_hud2d1bd975ff7a854c43bd69b6af7af9d_351870_54bbe94991366b3ad0e04247639fe9d6.webp 760w,
               /blog/compile-bpf-examples/bpf-kernel-examples_hud2d1bd975ff7a854c43bd69b6af7af9d_351870_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/compile-bpf-examples/bpf-kernel-examples_hud2d1bd975ff7a854c43bd69b6af7af9d_351870_7cc7208bdfbded5b98b6bb4bb1d19e63.webp&#34;
               width=&#34;760&#34;
               height=&#34;451&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      kernel-bpf-examples
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;分析samplesbpfmakefile文件&#34;&gt;分析&lt;strong&gt;samples/bpf/Makefile&lt;/strong&gt;文件&lt;/h2&gt;
&lt;p&gt;如果你是个喜欢打破砂锅问到底的同学，可以跟我一起看看最后的make命令到底用了什么魔法？当然你也可以跳过这个章节。本次分析的Makefile是基于内核版本&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;v4.15.0&lt;/a&gt;，不同内核版本的Makefile内容会有差异，但总体逻辑是一致的。&lt;/p&gt;
&lt;h3 id=&#34;前提条件&#34;&gt;前提条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果你对&lt;code&gt;make&lt;/code&gt;作为构建工具还不熟悉，可以看看这个&lt;a href=&#34;http://www.ruanyifeng.com/blog/2015/02/make.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;教程&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;Linux内核中大部分Makefile都是基于&lt;a href=&#34;https://www.kernel.org/doc/html/latest/kbuild/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kernel Build System&lt;/a&gt;，简称&lt;code&gt;kbuild&lt;/code&gt;，它是对Makefile的扩展，使其在编译内核文件时更加高效、简洁。因此你需要对其有所了解，可以到&lt;a href=&#34;https://www.kernel.org/doc/html/latest/kbuild/makefiles.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;看看官方介绍。&lt;/li&gt;
&lt;li&gt;上文使用的另外两个&lt;strong&gt;make&lt;/strong&gt;命令，利用的是根目录下的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/a&gt;，完成“生成头文件”和“生成.config文件”，这两步是内核开发的必要步骤，感兴趣的同学移步看&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/Documentation/admin-guide/README.rst&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;README.rst&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分段分析&#34;&gt;分段分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一段关于变量&lt;code&gt;hostprogs-y&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# List of programs to build&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; test_lru_dist
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sock_example
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; fds_example
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sockex1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sockex2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sockex3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Makefile的第一段是初始化变量&lt;code&gt;hostprogs-y&lt;/code&gt;，乍一看，好像是把所有示例程序名称都赋值给了&lt;code&gt;hostprogs-y&lt;/code&gt;。官方的注释是&lt;strong&gt;List of programs to build&lt;/strong&gt;，直译过来是，“准备构建的程序清单”、，大致能猜出这个变量的意义了，通过查询官方文档，发现一个概念叫&lt;a href=&#34;https://www.kernel.org/doc/html/latest/kbuild/makefiles.html#host-program-support&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Host Program support&lt;/strong&gt;&lt;/a&gt;，意思是在编译阶段就构建出可以在本机直接运行的可执行文件，为了实现这个目的，需要经过两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一步告诉 &lt;strong&gt;kbuild&lt;/strong&gt; 需要生成哪些可执行文件，这个就是通过变量&lt;code&gt;hostprogs-y&lt;/code&gt;来指定。来看源码中的这一行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; test_lru_dist
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;程序&lt;code&gt;test_lru_dist&lt;/code&gt;就是一个被指定的可执行程序名称，&lt;code&gt;kbuild&lt;/code&gt;默认会去同一个目录下查找名为&lt;code&gt;test_lru_dist.c&lt;/code&gt;作为构建这个可执行文件的源文件。类似代码也是同样的意义，总计有41个可执行文件赋值给了变量&lt;code&gt;hostprogs-y&lt;/code&gt;中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二步是将显式依赖关系添加到可执行文件中。这可以通过两种方式来完成，一种是为Makefile中某个&lt;strong&gt;target&lt;/strong&gt;添加这个可执行文件，作为&lt;strong&gt;prerequisites&lt;/strong&gt;，形成依赖关系，这样就可以触发这个可执行文件的构建任务，另一种是直接利用变量 &lt;code&gt;always&lt;/code&gt;，即无需指定第一种方式中的依赖关系，只要Makefile被执行，变量&lt;code&gt;always&lt;/code&gt;中包含的可执行文件都会被构建。来看源码中的相关片段：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Tell kbuild to always build the programs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;always :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;hostprogs-y&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到它使用上文提到的第二种方式，保证这些可执行文件一定会被执行构建任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二段关于变量&lt;code&gt;&amp;lt;executeable&amp;gt;-objs&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Libbpf dependencies&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;LIBBPF :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; ../../tools/lib/bpf/bpf.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CGROUP_HELPERS :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; ../../tools/testing/selftests/bpf/cgroup_helpers.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;test_lru_dist-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; test_lru_dist.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sock_example-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sock_example.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;fds_example-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; fds_example.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex1-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex1_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex2-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex2_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex3-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex3_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一、二行是声明并初始化了两个变量&lt;code&gt;LIBBPF&lt;/code&gt;和&lt;code&gt;CGROUP_HELPERS&lt;/code&gt;，以便后续复用。后面的几行是有共性的，&lt;code&gt;:=&lt;/code&gt;符号左边是个有规律的变量：&lt;code&gt;&amp;lt;executeable&amp;gt;-objs&lt;/code&gt;，右边是多个.o文件，看上去的意义像是右边的多个文件会合并成一个指定文件。通过查询文档可知，可执行文件可以由多个其他文件复合组成，通过&lt;code&gt;&amp;lt;executeable&amp;gt;-objs&lt;/code&gt;这样的语法，可以列出并指定所有用于生成最终可执行文件（命名为&lt;code&gt;executeable&lt;/code&gt;）的文件清单。以如下代码为例，可执行文件&lt;code&gt;sockex1&lt;/code&gt;是由&lt;code&gt;bpf_load.o&lt;/code&gt;、&lt;code&gt;bpf.o&lt;/code&gt;和&lt;code&gt;sockex1_usr.o&lt;/code&gt;链接生成的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sockex1-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; sockex1_user.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三段关于变量&lt;code&gt;HOSTCFLAGS&lt;/code&gt;和&lt;code&gt;HOSTLOADLIBES&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objtree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/usr/include
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/lib/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/testing/selftests/bpf/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/lib/ -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/include
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTCFLAGS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/perf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HOSTCFLAGS_bpf_load.o +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objtree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/usr/include -Wno-unused-variable
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_fds_example&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_sockex1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_sockex2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_sockex3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;HOSTLOADLIBES_tracex4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; -lelf -lrt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码中有两个关键变量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;变量&lt;code&gt;HOSTCFLAGS&lt;/code&gt;顾名思义，它是在编译host program（即可执行文件）时，为&lt;strong&gt;编译&lt;/strong&gt;操作指定的特殊选项，如上面代码中使用&lt;code&gt;-I&lt;/code&gt;参数指定依赖的头文件所在目录。默认情况下，这个变量的配置会作用到当前Makefile涉及的所有host program。如果你想为某个host program单独指定一个编译选项，可以像上文的这行代码：
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HOSTCFLAGS_bpf_load.o +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;objtree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/usr/include -Wno-unused-variable
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;只为&lt;code&gt;bpf_load.o&lt;/code&gt;这个object文件指定特殊选项。&lt;/li&gt;
&lt;li&gt;变量&lt;code&gt;HOSTLOADLIBES&lt;/code&gt;是用于&lt;strong&gt;链接&lt;/strong&gt;（link）操作时指定的特殊选项，如上面代码中使用两个library（因为代码中使用了相关的函数），通过选项&lt;code&gt;-l&lt;/code&gt;加到最终生成的可执行文件中：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libelf&lt;/code&gt;，这个库用来管理elf格式的文件，bpf程序一般都会使用elf作为最终格式，因此需要加载这个library。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;librt&lt;/code&gt;，这个库其实很常用，一般含有&lt;code&gt;#include&amp;lt;time.h&amp;gt;&lt;/code&gt;头文件的代码，都需要加载这个library，用来支持real time相关功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四段关于如何编译BPF程序源文件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Trick to allow make to be run from this directory&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;all:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;MAKE&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -C ../../ &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;CURDIR&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;obj&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.o: &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;src&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;CLANG&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;NOSTDINC_FLAGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LINUXINCLUDE&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;EXTRA_CFLAGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;obj&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-I&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/testing/selftests/bpf/ &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-D__KERNEL__ -Wno-unused-value -Wno-pointer-sign &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-D__TARGET_ARCH_&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;ARCH&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -Wno-compare-distinct-pointer-types &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-Wno-gnu-variable-sized-type-not-at-end &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-Wno-address-of-packed-member -Wno-tautological-compare &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-Wno-unknown-warning-option &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;CLANG_ARCH_ARGS&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;  			-O2 -emit-llvm -c $&amp;lt; -o -&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LLC&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -march&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;bpf -filetype&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;obj -o &lt;span class=&#34;nv&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中有两个系统变量：第一个&lt;code&gt;$@&lt;/code&gt;代表的是target所指的文件名；第二个&lt;code&gt;$&amp;lt;&lt;/code&gt;代表的是第一个prerequisite的文件名。看过本站关于BPF博文的同学可能已经看出如上代码的玄机了，我把它简化下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;clang -I &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;srctree&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/tools/testing/selftests/bpf/ &lt;span class=&#34;se&#34;&gt;\ &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  	      -O2 -emit-llvm -c $&amp;lt; -o -&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\ &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  	      llc -march&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;bpf -filetype&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;obj -o &lt;span class=&#34;nv&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上面的简化版命令，可以看出最后一行make命令的本质，就是把所有.c源代码文件，通过clang全部编译成.o目标文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;对&lt;strong&gt;samples/bpf/Makefile&lt;/strong&gt;这个文件执行make命令的本质就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为运行在内核空间的示例源代码（一般文件名称后缀为&lt;strong&gt;kern.c&lt;/strong&gt;），编译生成.o后缀的目标文件，以便加载到对应BPF提供的hook中去。&lt;/li&gt;
&lt;li&gt;为运行在用户空间的示例源代码(一般文件文件后缀为&lt;strong&gt;user.c&lt;/strong&gt;)，编译生成可以在本机直接运行的可执行文件，以便用户可以直接运行测试。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;我在执行make命令遇到的问题&#34;&gt;我在执行Make命令遇到的问题&lt;/h2&gt;
&lt;p&gt;我自己的实验环境是Ubuntu 18.04 with 4.15.0内核，在执行上面的make命令时，发生了以下的错误信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;In file included from ./tools/perf/perf-sys.h:9:0,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            	 from samples/bpf/bpf_load.c:28:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h: In &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; ‘sys_perf_event_open’:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h:68:15: error: ‘test_attr__enabled’ undeclared &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;first use in this &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;unlikely&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;test_attr__enabled&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/include/linux/compiler.h:74:43: note: in definition of macro ‘unlikely’
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;c1&#34;&gt;# define unlikely(x)  __builtin_expect(!!(x), 0)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                    	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h:68:15: note: each undeclared identifier is reported only once &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; each &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; it appears in
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;unlikely&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;test_attr__enabled&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/include/linux/compiler.h:74:43: note: in definition of macro ‘unlikely’
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;c1&#34;&gt;# define unlikely(x)  __builtin_expect(!!(x), 0)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                    	   ^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;In file included from samples/bpf/bpf_load.c:28:0:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./tools/perf/perf-sys.h:69:3: warning: implicit declaration of &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt; ‘test_attr__open’ &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;-Wimplicit-function-declaration&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   test_attr__open&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;attr, pid, cpu, fd, group_fd, flags&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   ^~~~~~~~~~~~~~~
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;scripts/Makefile.host:107: recipe &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; target &lt;span class=&#34;s1&#34;&gt;&amp;#39;samples/bpf/bpf_load.o&amp;#39;&lt;/span&gt; failed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;1&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;: *** &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;samples/bpf/bpf_load.o&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Error &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Makefile:1823: recipe &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; target &lt;span class=&#34;s1&#34;&gt;&amp;#39;samples/bpf/&amp;#39;&lt;/span&gt; failed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make: *** &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;samples/bpf/&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; Error &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据错误信息，查看发生错误的文件为**./tools/perf/perf-sys.h**，报错的那一行是test开头的。通过Google发现了内核大佬们的邮件来往：&lt;a href=&#34;https://www.spinics.net/lists/netdev/msg608676.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.spinics.net/lists/netdev/msg608676.html&lt;/a&gt;。大佬们建议由于是测试相关的代码，所以可以skip掉。修改完的文件在&lt;a href=&#34;https://github.com/nevermosby/linux-bpf-learning/blob/master/bpf/perf-sys.h&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;，请斟酌参考。重新运行make命令，错误不再发生了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make samples/bpf/ &lt;span class=&#34;c1&#34;&gt;# and it works&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;编译运行自己的bpf程序&#34;&gt;编译运行自己的BPF程序&lt;/h2&gt;
&lt;p&gt;如果你想利用Linux内核环境来编译自己的BPF程序，是非常方便的。只要对&lt;code&gt;samples/bpf/&lt;/code&gt;目录下的&lt;a href=&#34;https://elixir.bootlin.com/linux/v4.15/source/samples/bpf/Makefile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/a&gt;进行一点点自定义改造即可，如果你仔细阅读了上面的分析，那么改造的原理就显而易见了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 假设你自己BPF程序如下所示：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 内核空间代码：my_bpf_101_kern.c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 用户空间代码：my_bpf_101_user.c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 从上之下，添加新的代码行&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 1. 追加新的一行至hostprogs-y开头的代码块最后，保证自己的BPF程序能够生成可执行文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hostprogs-y +&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; my_bpf_101
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 2. 一般BPF程序使用以下命令即可，具体取决于你的程序是否依赖其他特殊头文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;my_bpf_101-objs :&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; bpf_load.o &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;LIBBPF&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; my_bpf_101_user.o
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 3. 追加新的一行至always开头的代码块最后，保证触发生成可执行文件的任务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;always&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; my_bpf_101_kern.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一般的BPF程序只需要通过如上3处更新加入到Makefile中，就可以使用&lt;code&gt;make samples/bpf/&lt;/code&gt;命令，生成你自己程序的可执行文件了。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
