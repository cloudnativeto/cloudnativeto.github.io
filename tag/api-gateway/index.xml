<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>api gateway | 云原生社区（中国）</title>
    <link>https://cloudnative.to/tag/api-gateway/</link>
      <atom:link href="https://cloudnative.to/tag/api-gateway/index.xml" rel="self" type="application/rss+xml" />
    <description>api gateway</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 18 May 2021 12:03:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>api gateway</title>
      <link>https://cloudnative.to/tag/api-gateway/</link>
    </image>
    
    <item>
      <title>KrakenD API 网关更名为 Lura 项目并宣布加入了 Linux 基金会</title>
      <link>https://cloudnative.to/blog/krakend-api-gateway-joins-the-linux-foundation-as-the-lura-project/</link>
      <pubDate>Tue, 18 May 2021 12:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/krakend-api-gateway-joins-the-linux-foundation-as-the-lura-project/</guid>
      <description>&lt;h2 id=&#34;关于-lura-项目&#34;&gt;关于 Lura 项目&lt;/h2&gt;
&lt;p&gt;近日，&lt;a href=&#34;https://www.luraproject.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lura 项目&lt;/a&gt;，原名为 KrakenD 的开源框架，加入了 &lt;a href=&#34;https://training.linuxfoundation.org/training/course-catalog/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linux 基金会&lt;/a&gt;，根据一份新闻声明，“它将是唯一一个在中立、开放论坛中托管的企业级 API 网关”。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.krakend.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KrakenD API 网关&lt;/a&gt;的联合创始人兼首席执行官 &lt;a href=&#34;https://www.linkedin.com/in/alombarte/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Albert Lombarte&lt;/a&gt; 说，该项目现在每月活跃在 100 多万台服务器上。转到 Linux 基金会后，将技术放在了第一位，而不是企业公司的需求。&lt;/p&gt;
&lt;p&gt;“我们是真正的开源信徒，我们相信开源是这个项目的归宿，“Lombarte 说。“我们已经看到，技术与 API 网关玩得不好，所采取的做法不是技术的最佳做法，“而是为了营销或销售产品的需要，为了锁定客户。“而我们希望能解放这一点，“他指出。&lt;/p&gt;
&lt;p&gt;KrakenD API 网关建立在现在被称为 Lura 项目的基础上，Lombarte 解释说，KrakenD 是一个有主见的实现，即它注重速度而不是其他功能。Lura 是一个构建 API 网关的框架，可以根据企业的需求进行定制。它是为速度和可扩展性而设计的。Lombarte 说，Lura 用 Go 语言构建，是一个无状态、高性能的 API 网关框架，为云原生和内部设置而设计，无状态是一个区别点。&lt;/p&gt;
&lt;p&gt;“如果你采取传统的 API 网关，你会发现配置是存储在数据库上的。我们没有任何形式的数据库，所以所有的配置都在一个静态的配置文件中，“Lombarte 说。&amp;quot; &lt;strong&gt;如果你想改变网关的状态，你必须重新部署另一个版本的网关。它就像今天任何公司的任何微服务一样工作。这就是我们和有状态网关的主要区别。&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;此外，有状态网关的问题是可扩展性，Lombarte 说。“因为它们通常连接到一个数据库，而这个数据库是唯一的真实数据来源，所有的节点都需要协调。因此，如果你去找大客户，他们无法正常扩展，因为他们有一个瓶颈，那就是数据库。我们节点甚至不互相通信，所以它们可以线性地扩展到无限大。”&lt;/p&gt;
&lt;p&gt;Lura 的另一个区别点是，其 API 网关超越了传统的 API 网关，&lt;strong&gt;作为多个微服务的聚合器发挥作用，而不是简单地作为一个扩展的代理&lt;/strong&gt;。Lombarte 说，市场上的所有 API 网关都只是 “中间有共享关注点的代理”，API 调用到达一个单一的后端服务。相反，Lura 允许聚集许多后端服务，可以通过调用它创建的单一 API 端点到达，而且这些后端服务中的每一个实际上也可以提供不同的 API 类型。&lt;/p&gt;
&lt;p&gt;“当你广泛地谈论 API 网关时，人们通常会想到 API 网关将授权请求，也许还有速率限制。这是每个人对 API 网关的理解，但这只是用其他东西进行代理，“Lombarte 说。“我们所做的是，我们创建一个新的 API，所以你不再消费你的后台，你在消费我们的 API 网关。这就像前端的一个后端。&lt;strong&gt;我们比市场上任何其他 API 网关更接近 GraphQL&lt;/strong&gt;&amp;quot;。&lt;/p&gt;
&lt;p&gt;Lombarte 说，如果你正在寻找这些强调速度的功能，那么 KrakenD 可能是正确的选择，但如果你需要专注于其他功能，那么 Lura 就可以帮助建立你需要的功能。他说，只需 20 到 30 行代码，你就可以使用 Lura 建立并运行一个 API 网关。eBay 和 Mail.ru 是目前使用 Lura 的两个大机构的例子。他说，这项技术提供了速度和无限的线性可扩展性，但也允许他们根据自己的需要定制 API 网关。&lt;/p&gt;
&lt;h2 id=&#34;未来计划&#34;&gt;未来计划&lt;/h2&gt;
&lt;p&gt;在 Lura 捐赠给 Linux 基金会之后，Lombarte 说，Lura 2.0 预计将在不久的将来发布，路线图中的新功能是支持 GraphQL 和能够用自定义插件进一步扩展该项目。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache APISIX 的全流量 API 网关统筹集群流量</title>
      <link>https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/</link>
      <pubDate>Wed, 30 Sep 2020 16:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/</guid>
      <description>&lt;p&gt;本文根据我在云原生学院的分享整理而成，视频见 &lt;a href=&#34;https://www.bilibili.com/video/BV1Gt4y1q7qC&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bilibli&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;bilibili.jpg&#34;&gt;云原生学院&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文将从云原生时代的机遇和挑战说起，介绍一个全新的开源高性能云原生 API 网关——Apache APISIX，探讨如何解决云原生时代 API 网关所面临的一些痛点，最后介绍该开源项目未来的规划。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;h3 id=&#34;云原生的机遇和挑战&#34;&gt;云原生的机遇和挑战&lt;/h3&gt;
&lt;p&gt;很多应用和服务都在向微服务、容器化迁移，形成新的云原生时代。云原生是下一个 5-10 年的技术颠覆，重写了传统企业的技术架构，例如云原生中的 Kubernetes 颠覆了传统操作系统，所有的“主机”（node 上的容器）由 Kubernetes 来控制和编排，非常适用于公有云、私有云、混合云等各种环境。云原生体系的特点之一就是由各种开源项目组成，不同于以往的商业闭源项目，缓解了收费贵等问题，加速了技术落地。现代公司的技术是非常重要的组成部分，在一个商业竞争激烈的时代，公司愈早的占据技术顶峰愈是能够占据商业顶峰。网关作为云原生入口，是掌握云原生的一个必经之地，是开启“财富”的关键钥匙。&lt;/p&gt;
&lt;h3 id=&#34;微服务的演进&#34;&gt;微服务的演进&lt;/h3&gt;
&lt;p&gt;从 2014-2015 年，谷歌搜索引擎上“微服务”关键字的搜索趋势呈直线上升。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps1_hud05ffbb97c9655a38d80df2007e5c7b4_494164_cda53a5f5f024db446901f3d8d546d0f.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps1_hud05ffbb97c9655a38d80df2007e5c7b4_494164_f47dd463b7b47aa1d7fb404f1a9c80de.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps1_hud05ffbb97c9655a38d80df2007e5c7b4_494164_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps1_hud05ffbb97c9655a38d80df2007e5c7b4_494164_cda53a5f5f024db446901f3d8d546d0f.webp&#34;
               width=&#34;760&#34;
               height=&#34;469&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在单体架构上，任一请求都会负载到整个的单体服务集群上。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps2_hub00e849b4190c28b456337b25e008a3c_235692_08e3a0619bd1cb0ca5623d919c4f7f9f.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps2_hub00e849b4190c28b456337b25e008a3c_235692_081c2294ac20561b55d187dfbdb49b53.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps2_hub00e849b4190c28b456337b25e008a3c_235692_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps2_hub00e849b4190c28b456337b25e008a3c_235692_08e3a0619bd1cb0ca5623d919c4f7f9f.webp&#34;
               width=&#34;760&#34;
               height=&#34;308&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在微服务架构上，对应请求会负载到微服务中对应的的子服务集群上。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps3_hu9d7fd3b8af1c798470ea19658e1029ba_508277_dda37ad97c2759be233ec43aa5462b26.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps3_hu9d7fd3b8af1c798470ea19658e1029ba_508277_b4d9209afe0cf7cf94d3192f603585d9.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps3_hu9d7fd3b8af1c798470ea19658e1029ba_508277_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps3_hu9d7fd3b8af1c798470ea19658e1029ba_508277_dda37ad97c2759be233ec43aa5462b26.webp&#34;
               width=&#34;760&#34;
               height=&#34;360&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用微服务进行精细管理后，服务的弹性伸缩、开发团队变得敏捷、服务之间隔离、降低故障率；在流量变动的时候，只需要对有可能变动流量的服务进行对应资源的扩缩容即可，这样可以很明显的节省服务器成本以及更高的承受度；在业务变动的时候，只需要对有可能变动业务的服务进行对应业务模块的变动即可，这样可以很明显的节省人力成本以及更高的控制力；在出现故障时不会导致整体服务不可用。&lt;/p&gt;
&lt;p&gt;但是落地微服务同样的带来了一些问题，比如接口之间通用的功能重复开发、膨胀的服务数量、难以管理。通常的解决方案便是使用 API 网关对其进行管理。&lt;/p&gt;
&lt;h3 id=&#34;微服务与-api-网关&#34;&gt;微服务与 API 网关&lt;/h3&gt;
&lt;p&gt;使用 API 网关进行管理，通常的做法是将微服务框架中功能型的功能统一放到网关上，例如可观测性 metrics、应用性能 apm tracing、限速、身份认证、日志等等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps4_hu84d506acad59869d38b3b43f13a67b2a_419390_5b905b922da2fa7948457a8510033262.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps4_hu84d506acad59869d38b3b43f13a67b2a_419390_281bf8710c53644c5807403497f71c6e.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps4_hu84d506acad59869d38b3b43f13a67b2a_419390_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps4_hu84d506acad59869d38b3b43f13a67b2a_419390_5b905b922da2fa7948457a8510033262.webp&#34;
               width=&#34;760&#34;
               height=&#34;286&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;灰度发布&#34;&gt;灰度发布&lt;/h4&gt;
&lt;p&gt;灰度发布也叫金丝雀发布，起源是，矿井工人发现，金丝雀对瓦斯气体很敏感，矿工会在下井之前，先放一只金丝雀到井中，如果金丝雀不叫了，就代表瓦斯浓度高。灰度发布会将流量按比例划分给已经上线的版本（比如1.0，占比90%）以及正在上线的版本（比如1.01，占比10%），若观测没有问题，逐步调整二者的流量占比直到流量完全切到1.01版本。Apache APISIX 内置的灰度发布支持读取到的 HTTP 请求参数中包含了 NGINX 的所有变量，可以依据变量进行灰度，甚至支持 LUA 代码去运算处理请求的请求体、请求参数。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps6_hu3a7e5756d50561a3c412aaf02916e4e4_472280_1506bef9ac3568cb2fa0c8981d539e28.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps6_hu3a7e5756d50561a3c412aaf02916e4e4_472280_3e2ea4f16d763454fa4c8fb5843bfd2d.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps6_hu3a7e5756d50561a3c412aaf02916e4e4_472280_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps6_hu3a7e5756d50561a3c412aaf02916e4e4_472280_1506bef9ac3568cb2fa0c8981d539e28.webp&#34;
               width=&#34;760&#34;
               height=&#34;319&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;服务熔断&#34;&gt;服务熔断&lt;/h4&gt;
&lt;p&gt;如图所示，当 Invoices 服务出现大量常见错误达到配置的熔断阈值就可以直接熔断不接收请求了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps7_hu54cd4cd03015653ae99a8f0fa47418fa_428019_b1d9b49ee40214788cf8a8edc41838ba.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps7_hu54cd4cd03015653ae99a8f0fa47418fa_428019_370b3238bc68117a5c145432333f76fa.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps7_hu54cd4cd03015653ae99a8f0fa47418fa_428019_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps7_hu54cd4cd03015653ae99a8f0fa47418fa_428019_b1d9b49ee40214788cf8a8edc41838ba.webp&#34;
               width=&#34;760&#34;
               height=&#34;353&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;apache-apisix-在传统和云原生领域的支持粒度&#34;&gt;Apache APISIX 在传统和云原生领域的支持粒度&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;作用在传统API网关领域的功能&lt;/th&gt;
&lt;th&gt;作用在云原生API网关领域的功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;让 API 请求更安全、更高效的得到处理；&lt;br /&gt;覆盖 Nginx 的所有功能：反向代理、负载均衡；&lt;br /&gt;动态上游、动态 SSL 证书、动态限流限速；主动/被动健康检查、服务熔断&lt;/td&gt;
&lt;td&gt;对接 Prometheus、Zipkin、Skywalking；&lt;br /&gt;gRPC 代理和协议转换 (REST &amp;lt;-&amp;gt; gRPC)；&lt;br /&gt;身份认证：OpenID Relying Party、OP（Auth0、okta……）&lt;br /&gt;高性能、无状态、随意扩容和缩容&lt;br /&gt;动态配置，不用 reload 服务&lt;br /&gt;支持多云、混合云&lt;br /&gt;容器优先，Kubernetes 友好&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;api-生命周期管理全景图&#34;&gt;API 生命周期管理全景图&lt;/h3&gt;
&lt;p&gt;API 生命周期指的是从 API 的设计到 API 的文档和他的 SDK 以及他的 API 的上线之类，甚至还包括 API 的市场等等一整套的解决方案，网关在其中是核心角色。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image-20200929155124157&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image-20200929155124157&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/image-20200929155124157_huecf471fe2c53bc25d53c1fd560f4daa3_234257_33c9f0c098e34ad036327d8416507d91.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/image-20200929155124157_huecf471fe2c53bc25d53c1fd560f4daa3_234257_7ee86511345bb854ec349fcd4c72678c.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/image-20200929155124157_huecf471fe2c53bc25d53c1fd560f4daa3_234257_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/image-20200929155124157_huecf471fe2c53bc25d53c1fd560f4daa3_234257_33c9f0c098e34ad036327d8416507d91.webp&#34;
               width=&#34;757&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image-20200929155124157
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在上半象限都是一些巨头公司，例如 Google、IBM 等等，都是公有云的闭源项目，具有领导地位，跟各自产品深度绑定在一起。在下半象限都是援建者，都是开源项目，例如: Kong，挑战着闭源项目, 随着时间的推移我们发现——软件在吞噬世界、开源软件在吞噬软件。以下是近几年发生的很多 API 网关厂商相关的收购案例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2015 年，IBM 收购 StrongLoop&lt;/li&gt;
&lt;li&gt;2015 年，谷歌 6.25 亿美元收购 apigee&lt;/li&gt;
&lt;li&gt;2018 年，Salesforce 65 亿美元收购 MuleSoft&lt;/li&gt;
&lt;li&gt;2018 年，Broadcom 189 亿美元收购 CA Technologies&lt;/li&gt;
&lt;li&gt;2019 年，F5 收购 6.7 亿美元收购 NGINX&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明 API 网关在云原生时代依然扮演者重要的角色&lt;/p&gt;
&lt;h2 id=&#34;深入浅出-apache-apisix&#34;&gt;深入浅出 Apache APISIX&lt;/h2&gt;
&lt;h3 id=&#34;设计思路&#34;&gt;设计思路&lt;/h3&gt;
&lt;p&gt;API 网关的数据面和控制面分离。控制面不仅能控制 Apache APISIX 还能控制其他组件；数据面不仅仅能被我的控制面控制，还能被其他组件所控制&lt;/p&gt;
&lt;p&gt;通过插件机制来方便二次开发和运维。拿 Envoy 来说，Envoy 的插件是使用 C++ 编写的，C++ 本身就具有很大的复杂性；再来对比下 Kong，Kong 开发一个 IP 黑白名单插件需要写 300+ 行代码，并且插件配置解析、插件逻辑等代码分布在 3-4 个文件中；而 Apache APISIX 开发同样功能的插件只需要一个文件并且只需要70行代码。&lt;/p&gt;
&lt;p&gt;默认高可用，没有单点故障。因为使用了 ETCD 来存储和分发路由数据&lt;/p&gt;
&lt;p&gt;安全和稳定第一。Apache APISIX 基于 Nginx 实现，支持mTLS 认证以及敏感信息加密加盐 (salt) 保存。为什么选择 Nginx 呢？它是基于 C 语言开发的程序，性能优化到极致，Nginx 的底层开发做的非常好，并且在大规模适用上得到充分有效的验证，从性能角度上是最佳选择&lt;/p&gt;
&lt;p&gt;高性能。Apache APISIX 基于 Nginx 的网络层，其单核心 QPS 1.5 万，延迟低于 0.7 毫秒。&lt;/p&gt;
&lt;p&gt;运维友好。它支持 Prometheus、SkyWalking 动态追踪、流量复制、故障注入等功能&lt;/p&gt;
&lt;h3 id=&#34;技术架构&#34;&gt;技术架构&lt;/h3&gt;
&lt;p&gt;Apache APISIX 架构如图，其主要分为数据面和控制面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据面：以 Nginx 的网络库为基础，（弃用 Nginx 的路由匹配、静态配置和 C 模块），使用 Lua 和 Nginx 动态控制请求流量，通过插件机制来实现各种流量处理和分发的功能：限流限速、日志记录、安全检测、故障注入等，同时支持用户编写自定义插件来对数据面进行扩充。&lt;/li&gt;
&lt;li&gt;控制面：使用 etcd 来存储和同步网关的配置数据，管理员通过 admin API 或者 dashboard 可以在毫秒级别内通知到所有的数据面节点，同时 etcd 集群也保证了系统的高可用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps15_huad3fed643d36b608f240e2099c8d1d94_465690_b20e902827d072bde1d0b1b5e01d2561.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps15_huad3fed643d36b608f240e2099c8d1d94_465690_9a0c7788e7b8de5d7079b7ef55d8f0f7.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps15_huad3fed643d36b608f240e2099c8d1d94_465690_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps15_huad3fed643d36b608f240e2099c8d1d94_465690_b20e902827d072bde1d0b1b5e01d2561.webp&#34;
               width=&#34;760&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;因为 Apache APISIX 使用了 ETCD 作为配置中心，在对应其他组件时会非常方便，可以把 ETCD 直接就当做服务注册发现中心来使用（服务注册、发现），当然同时也支持 Consul、Eureka、Nacos 等服务注册中心。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps16_hua4f27da2ae27158ee34830ca9d331531_958268_7ce118164c6cb22d9e0ebc793b98f50f.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps16_hua4f27da2ae27158ee34830ca9d331531_958268_eb54ef5676d9408214ec81267799e163.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps16_hua4f27da2ae27158ee34830ca9d331531_958268_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps16_hua4f27da2ae27158ee34830ca9d331531_958268_7ce118164c6cb22d9e0ebc793b98f50f.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;高性能&#34;&gt;高性能&lt;/h3&gt;
&lt;p&gt;Apache 只是使用了 Nginx 的网络库而并没有使用路由库，重写优化了路由算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apache APISIX 的路由复杂度是 O (k)，只和 URI 的长度有关，和路由数量无关；kong 的路由时间复杂度是 O (n) ，随着路由数量线性增长，K 指 URI 长度，和路由数量没有关系，例如有一百万条路由，ApiSix 路由的时间复杂度都是一样的，而 Kong 却不是这样的；&lt;/li&gt;
&lt;li&gt;Apache APISIX 的 IP 匹配时间复杂度是 O (1)，不会随着大量 IP 判断而导致 CPU 资源跑满；kong 的最新版本也换用了 Apache APISIX 的 IP 匹配库；不管有多少IP都是一次命中，而 Kong 却不是这样的；&lt;/li&gt;
&lt;li&gt;Apache APISIX 的路由匹配，接受 nginx 的所有变量作为条件，并且支持自定义函数；其他网关都是内置的几个条件；&lt;/li&gt;
&lt;li&gt;Apache APISIX 使用 etcd 作为配置中心，没有单点，任意宕掉一台机器，网关集群还能正常运行。其他基于 mysql，postgres 的网关都会有单点问题；&lt;/li&gt;
&lt;li&gt;Apache APISIX 的配置下发只要 1 毫秒就能达到所有网关节点，使用的是 etcd 的 watch；其他网关是定期轮询数据库，一般需要 5 秒才能获取到最新配置；&lt;/li&gt;
&lt;li&gt;只有 Apache APISIX 开放了自定义负载均衡的挂载点，其他网关都不支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;独创的插件编排&#34;&gt;独创的插件编排&lt;/h3&gt;
&lt;p&gt;基于已有插件的基础上，通过在界面上拖拖拽拽就可以生成一个全新的插件。&lt;/p&gt;
&lt;p&gt;通过插件编排的方式可以把 Apache APISIX 的四十多个插件的上下游关系全部串联起来形成一个新的插件。&lt;/p&gt;
&lt;p&gt;当前，Kong支持 Go 编写的插件，Envoy支持 Lua、WASM 编写的 filter。那么，Apache APISIX 的使用者为什么要“写”插件？我们认为运维、PM 也可以直接通过浏览器页面创造一个自己的插件。&lt;/p&gt;
&lt;p&gt;为了支持插件编排，Apache APISIX 一方面需要实现微插件、低代码，同时需要底层架构和插件足够灵活。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34;
           src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/low-code-api-gateway-example-en-US.gif&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;同类技术对比&#34;&gt;同类技术对比&lt;/h3&gt;
&lt;h4 id=&#34;apache-apisix-vs-kong&#34;&gt;Apache APISIX vs Kong&lt;/h4&gt;
&lt;p&gt;有对比才更有说服力，Apache APISIX 和 Kong 都是基于 Openresty/LuaJIT 实现的高性能 API 网关，让我们来对比下他们的异同。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;对⽐比项&lt;/th&gt;
&lt;th&gt;APISIX&lt;/th&gt;
&lt;th&gt;Kong&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;技术架构&lt;/td&gt;
&lt;td&gt;Nginx + etcd&lt;/td&gt;
&lt;td&gt;Nginx + postgres&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;高可用&lt;/td&gt;
&lt;td&gt;非常可靠，没有单点&lt;/td&gt;
&lt;td&gt;一般，有数据库的单点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;精细化路由&lt;/td&gt;
&lt;td&gt;支持 Nginx 变量和自定义函数&lt;/td&gt;
&lt;td&gt;固定的⼏个条件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;配置⽣效时间&lt;/td&gt;
&lt;td&gt;事件驱动，小于 1 毫秒&lt;/td&gt;
&lt;td&gt;轮询拉取，5 秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;处理延迟&lt;/td&gt;
&lt;td&gt;0.2 毫秒&lt;/td&gt;
&lt;td&gt;2 毫秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能（单核，开启两个限流和 prometheus 插件）&lt;/td&gt;
&lt;td&gt;18000&lt;/td&gt;
&lt;td&gt;1700&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持流量复制和故障&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;注⼊&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持 SkyWalking&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;插件热更新&lt;/td&gt;
&lt;td&gt;新增、删除、更新插件不用重载服务&lt;/td&gt;
&lt;td&gt;无，每次都需要重载服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;二次开发&lt;/td&gt;
&lt;td&gt;难度低&lt;/td&gt;
&lt;td&gt;难度中等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;本地技术支持&lt;/td&gt;
&lt;td&gt;有，1 小时响应&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;定期巡检和培训&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因此我们发现Apache APISIX的分布式可靠性强，路由支持丰富，配置变更生效时间快，网关处理速度快, 资源消耗率低，混沌测试支持度高，监控系统(如SkyWalking)支持度高，插件变动动态化程度高以及二次开发难度低。&lt;/p&gt;
&lt;h4 id=&#34;apache-apisix-vs-nginx&#34;&gt;Apache APISIX vs Nginx&lt;/h4&gt;
&lt;p&gt;Nginx 是一款轻量级 Web 服务器、反向代理服务器，由于它的内存占用少、启动极快、高并发能力强，故其在互联网项目中得到广泛应用，距今已经有十多年的历史。但 Nginx 在步入云原生时代后遇到了更多的挑战：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;社区不活跃：没有 github issue 和 PR&lt;/li&gt;
&lt;li&gt;没有跟进云原生：nginx-k8s-controller、nginx unit 的尝试都失败了&lt;/li&gt;
&lt;li&gt;配置不能热加载&lt;/li&gt;
&lt;li&gt;非 http、https 流量的兴起（微服务、物联网……）&lt;/li&gt;
&lt;li&gt;商业化不成功&lt;/li&gt;
&lt;li&gt;被 F5 收购&lt;/li&gt;
&lt;li&gt;后浪：API 网关比如 Kong 和 Apache APISIX，serviceMesh proxy 比如 Envoy 等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开源社区规划&#34;&gt;开源社区规划&lt;/h2&gt;
&lt;h3 id=&#34;运营-apache-孵化器项目的经验&#34;&gt;运营 Apache 孵化器项目的经验&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为了让社区和用户保持习惯和预期，每个月一个版本，雷打不动。&lt;/li&gt;
&lt;li&gt;当天回复邮件列表和 github issue、PR&lt;/li&gt;
&lt;li&gt;频繁的布道和走访用户：每个月一次 meetup，走访过美团、腾讯、华为、贝壳、平安、又拍云、中国移动、思必驰、空中云汇、中国航信等几十家企业，深入了解用户的需求&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;the-apache-way&#34;&gt;The Apache Way&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不看重 github star，更关注如何吸引新的贡献者以及如何让贡献者更加活跃&lt;/li&gt;
&lt;li&gt;贡献不止代码，文档、测试、文章都是贡献，都可以成为 committer 和 PMC&lt;/li&gt;
&lt;li&gt;社区多样性：近 30 位 committer，其中两位欧洲开发者；至少 4 位大学生，甚至有 00 后的后浪贡献者，是 Apache APISIX committer&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;社区大于代码&#34;&gt;社区大于代码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The Apache Way&lt;/li&gt;
&lt;li&gt;活跃的社区，会重构坏的代码；但再好的代码，也会死于独裁的社区&lt;/li&gt;
&lt;li&gt;案例：Apache APISIX dashboard 的重构，社区对于 MySQL 的方案不满，“怨声载道”，然后来自 5 家公司的贡献者一起重构掉它&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;规划&#34;&gt;规划&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2.0 版本（即将发布）：使用 etcd v3 替代 v2&lt;/li&gt;
&lt;li&gt;3.0 版本：废弃 admin API，分离 DP 和 CP&lt;/li&gt;
&lt;li&gt;2021 年的 ﬂag：Apache APISIX 的贡献者超过 200 位&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;
&lt;p&gt;如果你还在被 Nginx 或者 Nginx Ingress 的 reload 性能问题所折磨，又或者对 Kong 的转发能力并不满意，欢迎大家使用 Apache APISIX&lt;/p&gt;
&lt;p&gt;欢迎大家给 Apache APISIX 贡献！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目地址: &lt;a href=&#34;https://github.com/apache/apisix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/apache/apisix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;邮箱：&lt;a href=&#34;mailto:wenming@apache.org&#34;&gt;wenming@apache.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;QQ 群：578997126&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感谢&lt;a href=&#34;https://github.com/tristan-tsl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;谭世霖&lt;/a&gt;对本文内容的整理，&lt;a href=&#34;https://github.com/Miss-you&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;厉辉&lt;/a&gt;、&lt;a href=&#34;https://github.com/hyfj44255&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;杨冉宁&lt;/a&gt;、&lt;a href=&#34;https://github.com/rootsongjc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;宋净超&lt;/a&gt;参与审阅。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh和API Gateway关系深度探讨</title>
      <link>https://cloudnative.to/blog/service-mesh-and-api-gateway/</link>
      <pubDate>Tue, 28 Apr 2020 11:20:46 +0800</pubDate>
      <guid>https://cloudnative.to/blog/service-mesh-and-api-gateway/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;关于Service Mesh和API Gateway之间的关系，这个问题过去两年间经常被问起，社区也有不少文章和资料给出解答。其中不乏 Christian Posta 这样的网红给出过深度介绍。我在这里做一个资料的整理和汇总，结合个人的理解给出一些看法。另外在本文最后，介绍蚂蚁金服在Service Mesh和API Gateway融合的这个最新领域的一些开创性的实践和探索，希望给大家一个更有体感的认知。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注1：为了节约篇幅，我们将直奔主题，假定读者对Service Mesh和API Gateway已有基本的了解。&lt;/p&gt;
&lt;p&gt;备注2:  这边文章更关注于梳理整个脉络，内容不会展开的特别细，尤其是其他文章已经详细阐述的部分。如果您在浏览本文之后，还想更深入的了解细节，请继续阅读文章最后的参考资料和推荐阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;原本清晰的界限定位和职责&#34;&gt;原本清晰的界限：定位和职责&lt;/h2&gt;
&lt;p&gt;首先，Service Mesh和API Gateway在功能定位和承担的职责上有非常清晰的界限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Mesh：微服务的网络通信基础设施，负责（系统内部的）服务间的通讯&lt;/li&gt;
&lt;li&gt;API Gateway： 负责将服务以API的形式暴露（给系统外部），以实现业务功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_f7859c7321a401742114a8636976ce86.webp 400w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_c08d37f9ebed334e95e5091043dee125.webp 760w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_f7859c7321a401742114a8636976ce86.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从功能和职责上说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位于最底层的是拆分好的原子微服务，以服务的形式提供各种能力&lt;/li&gt;
&lt;li&gt;在原子微服务上是（可选的）组合服务，某些场景下需要将若干微服务的能力组合起来形成新的服务&lt;/li&gt;
&lt;li&gt;原子微服务和组合服务部署于 &lt;strong&gt;系统内部&lt;/strong&gt;，在采用Service Mesh的情况下，由Service Mesh提供服务间通讯的能力&lt;/li&gt;
&lt;li&gt;API Gateway用于将系统内部的这些服务暴露给 &lt;strong&gt;系统外部&lt;/strong&gt;，以API的形式接受外部请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从部署上说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Mesh部署在系统内部：因为原子微服务和组合服务通常不会直接暴露给外部系统&lt;/li&gt;
&lt;li&gt;API Gateway部署在系统的边缘：一方面暴露在系统之外，对外提供API供外部系统访问；一方面部署在系统内部，以访问内部的各种服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里引入两个使用非常广泛的术语：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_209feadfce8c585c7587bba795d19852.webp 400w,
               /blog/service-mesh-and-api-gateway/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_9f17930a636bbbb70cb99750fbba4279.webp 760w,
               /blog/service-mesh-and-api-gateway/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_209feadfce8c585c7587bba795d19852.webp&#34;
               width=&#34;760&#34;
               height=&#34;326&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;东西向&lt;/strong&gt;通讯：指服务间的相互访问，其通讯流量在服务间流转，流量都位于系统内部&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;南北向&lt;/strong&gt;通讯：指服务对外部提供访问，通常是通过API Gateway提供的API对外部暴露，其通讯流量是从系统外部进入系统内部。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;解释一下“东西南北”的由来：如上图所示，通常在地图上习惯性的遵循“上北下南，左东右西”的原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结：Service Mesh和API Gateway在功能和职责上分工明确，界限清晰。但如果事情就这么结束，也就不会出现Service Mesh和API Gateway关系的讨论了，自然也不会有本文。&lt;/p&gt;
&lt;p&gt;问题的根源在哪里？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈推荐阅读：附录中 Christian Posta 的文章 &amp;ldquo;Do I Need an API Gateway if I Use a Service Mesh?&amp;ldquo;对此有深度分析和讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;哲学问题网关访问内部服务算东西向还是南北向&#34;&gt;哲学问题：网关访问内部服务，算东西向还是南北向？&lt;/h2&gt;
&lt;p&gt;如下图所示，图中黄色的线条表示的是API Gateway访问内部服务：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_f7859c7321a401742114a8636976ce86.webp 400w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_c08d37f9ebed334e95e5091043dee125.webp 760w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_f7859c7321a401742114a8636976ce86.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;问题来了，从流量走向看：这是外部流量进入系统后，开始访问对外暴露的服务，应该属于“南北向”通讯，典型如上图的画法。但从另外一个角度，如果我们将 API Gateway 逻辑上拆分为两个部分，先忽略对外暴露的部分，单独只看  API Gateway  访问内部服务的部分，这时可以视 API Gateway 为一个普通的客户端服务，它和内部服务的通讯更像是“东西向”通讯：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_d8c9a7c4926c5d5d55309d338745e53c.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_d2fde4544697be18226fa1938b906d63.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_d8c9a7c4926c5d5d55309d338745e53c.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;所以，API Gateway 作为一个客户端访问内部服务时，到底算南北向还是东西向，就成为一个哲学问题：完全取决于我们如何看待 API Gateway ，是作为一个整体，还是逻辑上分拆为对内对外两个部分。&lt;/p&gt;
&lt;p&gt;这个哲学问题并非无厘头，在 API Gateway 的各种产品中，关于如何实现 “API Gateway 作为一个客户端访问内部服务” ，就通常分成两个流派：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;泾渭分明：视 API Gateway 和内部服务为两个独立事物，API Gateway访问内部服务的通讯机制自行实现，独立于服务间通讯的机制&lt;/li&gt;
&lt;li&gt;兼容并济：视 API Gateway 为一个普通的内部服务的客户端，重用其内部服务间通讯的机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而最终决策通常也和产品的定位有关：如果希望维持  API Gateway 的独立产品定位，希望可以在不同的服务间通讯方案下都可以使用，则通常选择前者，典型如kong；如果和服务间通讯方案有非常深的渊源，则通常选择后者，典型如springcloud生态下的zuul和springcloud gateway。&lt;/p&gt;
&lt;p&gt;但无论选择哪个流派，都改变不了一个事实，当 “API Gateway 作为一个客户端访问内部服务” 时，它的确和一个普通内部服务作为客户端去访问其他服务没有本质差异：服务发现，负载均衡，流量路由，熔断，限流，服务降级，故障注入，日志，监控，链路追踪，访问控制，加密，身份认证&amp;hellip;&amp;hellip; 当我们把网关访问内部服务的功能一一列出来时，发现几乎所有的这些功能都是和服务间调用重复。&lt;/p&gt;
&lt;p&gt;这也就造成了一个普遍现象：如果已有一个成熟的服务间通讯框架，再去考虑实现API Gateway，重用这些重复的能力就成为自然而然的选择。典型如前面提到的 springcloud 生态下的 zuul 以及后面开发的 springcloud gateway，就是以重用类库的方式实现了这些能力的重用。&lt;/p&gt;
&lt;p&gt;这里又是一个类似的哲学问题：当 “API Gateway 作为一个客户端访问内部服务” 时，它以重用类库的方式实现了代码级别的能力重用，相当于自行实现了一个和普通服务间通讯方案完全一样的客户端，那这个“客户端”发出来的流量算东西向还是南北向？&lt;/p&gt;
&lt;p&gt;答案不重要。&lt;/p&gt;
&lt;h2 id=&#34;sidecar真正的重合点&#34;&gt;Sidecar：真正的重合点&lt;/h2&gt;
&lt;p&gt;在进入Service Mesh时代之后，Service Mesh和API gateway 的关系开始是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;功能和职责清晰划分&lt;/li&gt;
&lt;li&gt;客户端访问服务的功能高度重叠&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时两者的关系很清晰，而且由于当时Service Mesh和API Gateway是不同的产品，两者的重合点只是在功能上。&lt;/p&gt;
&lt;p&gt;而随着时间的推移，当 Service Mesh 产品和 API Gateway 产品开始出现相互渗透时，两者的关系就开始变得暧昧。&lt;/p&gt;
&lt;p&gt;在Service Mesh出现之后，如何为基于Service Mesh的服务选择合适的API Gateway方案，就慢慢开始提上日程，而其中选择重用Service Mesh的能力也自然成为一个探索的方向，并逐步出现新式API Gateway产品，其想法很直接：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何融合东西向和南北向的通讯方案？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中的一个做法就是基于Service Mesh的Sidecar来实现API Gateway，从而在南北向通讯中引入Service Mesh这种东西向通讯的方案。这里我们不展开细节，我这里援引一个图片（鸣谢赵化冰同学）来解释这个方案的思路：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_54a5263908e4e52e9730a6748f4385f0.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_f2c217e21995849d90b4de49eb926a78.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_54a5263908e4e52e9730a6748f4385f0.webp&#34;
               width=&#34;760&#34;
               height=&#34;244&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个时候Service Mesh和API Gateway的关系就变得有意思了，因为Service Mesh中sidecar的引入，所以前面的“哲学问题”又有了一个新的解法：API Gateway这次真的可以分拆为两个独立部署的物理实体，而不是逻辑上的两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;API Gateway本体：实现API Gateway除了访问内部服务之外的功能&lt;/li&gt;
&lt;li&gt;Sidecar：按照Service Mesh的标准做法， 我们视API Gateway为一个部署于Service Mesh中的普通服务，为这个服务1:1的部署sidecar&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_3ed088127c7942f69ca2ad761a9a698a.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_b1b27cce2d81ade8f80fec6d35b9c9cd.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_3ed088127c7942f69ca2ad761a9a698a.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个方案中，原来用于Service Mesh的sidecar，被用在了API Gateway中，替代了API Gateway中原有的客户端访问的各种功能。这个方案让API Gateway的实现简化了很多，也实现了东西向和南北向通讯能力的重用和融合，而 API Gateway可以更专注于 “API Management” 的核心功能。&lt;/p&gt;
&lt;p&gt;此时 Service Mesh 和 API Gateway 的关系就从“泾渭分明”变成了“兼容并济”。&lt;/p&gt;
&lt;p&gt;而采用这个方案的公司，通常都是先有Service Mesh产品，再基于Service Mesh产品规划（或者重新规划）API Gateway方案，典型如蚂蚁金服的SOFA Gateway产品是基于MOSN，而社区开源产品Ambassador和Gloo都是基于Envoy。&lt;/p&gt;
&lt;p&gt;上述方案的优势在于API Gateway和Sidecar独立部署，职责明确，架构清晰。但是，和Service Mesh使用sidecar被质疑多一跳会造成性能开销影响效率一样，API Gateway使用Sidecar也被同样的质疑：多了一跳&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;解决“多一跳”问题的方法简单而粗暴，基于sidecar，将API Gateway的功能加进来。这样API Gateway本体和Sidecar再次合二为一：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_163f8837dff0c118a170820e063a577f.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_020610a9ce6d1f820c23632cfeb9a6c6.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_163f8837dff0c118a170820e063a577f.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;至于走到这一步之后，Service Mesh和API Gateway是什么关系：这到底算是Service Mesh/sidecar融合了API Gateway，还是API Gateway融合了Service Mesh/Sidecar？这个问题就像斑马到底是白底黑纹还是黑底白纹一样，见仁见智。&lt;/p&gt;
&lt;h2 id=&#34;bff把融合进行到底&#34;&gt;BFF：把融合进行到底&lt;/h2&gt;
&lt;p&gt;BFF（Backend For Frontend）的引入会让Service Mesh和API Gateway走到一个更加亲密的地步。&lt;/p&gt;
&lt;p&gt;先来看看常规的BFF的玩法：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_82b1c5385231645bca4414f8c7a003eb.webp 400w,
               /blog/service-mesh-and-api-gateway/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_217f47d97dac77b6bc6774e3d569d025.webp 760w,
               /blog/service-mesh-and-api-gateway/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_82b1c5385231645bca4414f8c7a003eb.webp&#34;
               width=&#34;760&#34;
               height=&#34;338&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这里，多增加了一个 BFF 层，介于API Gateway和内部服务（包括组合服务和原子微服务）之间。注意BFF的工作模式和组合服务很类似，都是组合多个服务。但差别在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组合服务还属于服务的范畴，只是实现机制上组合了多个服务，对外暴露的依然是一个完整和规范的服务&lt;/li&gt;
&lt;li&gt;BFF不同，BFF如名字所示，Backend For Frontend，完全是为了前端而存在，核心目标之一是简化前端的访问&lt;/li&gt;
&lt;li&gt;对我们今天的话题而言，最关键的一点：BFF完全收口了从外部进入的流量，而组合服务没有，API Gateway是可以直接访问原子微服务的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;“BFF完全收口外部流量”，这一点在API Gateway和Sidecar融合之后，会变得很有想象空间，我们先看按照前面的融合方式，在有BFF的情况下，API Gateway和Sidecar融合后的情景：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_96d4d14bd1670e31108c4e81cd7adebe.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_914a3273f0d0926c14625f45e18036f7.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_96d4d14bd1670e31108c4e81cd7adebe.webp&#34;
               width=&#34;760&#34;
               height=&#34;374&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;放大一点，单独看API Gateway和BFF：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_42493bb04cbd51ededf65744172d2fe8.webp 400w,
               /blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_be4073244f51e2b800b5fef26058168a.webp 760w,
               /blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_42493bb04cbd51ededf65744172d2fe8.webp&#34;
               width=&#34;552&#34;
               height=&#34;416&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;注意到，流量从被API Gateway接收，到进入BFF在这个流程中，这个请求路径中有两个sidecar：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;和BFF部署在一起的，是没有API Gateway功能的普通Sidecar&lt;/li&gt;
&lt;li&gt;API Gateway和Sidecar融合之后，这就是一个“有API Gateway功能的大Sidecar”（或者是“有Sidecar功能的特殊API Gateway”）：虽然扮演了API Gateway的角色，但本质上依然包含一个完整功能的sidecar，和BFF自带的Sidecar是等同的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，问题来了：为什么要放两个sidecar在流程中，缩减到一个会怎么样？我们尝试将两个Sidecar合二为一，去掉BFF自带的Sidecar，直接把扮演API Gateway的sidecar给BFF用：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_19bf30930b38a8ff63db84b4411dc7ab.webp 400w,
               /blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_fc053a06ecb1f70b192ebd292acb723b.webp 760w,
               /blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_19bf30930b38a8ff63db84b4411dc7ab.webp&#34;
               width=&#34;645&#34;
               height=&#34;287&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此时的场景是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流量直接打到BFF上（BFF前面可能会挂其他的网络组件提供负载均衡等功能）&lt;/li&gt;
&lt;li&gt;BFF的sidecar接收流量，完成API Gateway的功能，然后将流量转给BFF&lt;/li&gt;
&lt;li&gt;BFF通过sidecar调用内部服务（和没有合并时一致）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_6a0cf3f9991378844eb7e7cdad30c7fe.webp 400w,
               /blog/service-mesh-and-api-gateway/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_731b76370e8deced8226bd4660256307.webp 760w,
               /blog/service-mesh-and-api-gateway/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_6a0cf3f9991378844eb7e7cdad30c7fe.webp&#34;
               width=&#34;760&#34;
               height=&#34;389&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;注意这里有一个关键点，在前面时特意注明的：“&lt;strong&gt;BFF完全收口外部流量&lt;/strong&gt;”。这是前提条件，因为原有的API Gateway集群已经不再存在，如果BFF没能收口全部流量，则这些未能收口的流量会找不到API Gateway。当然，如果愿意稍微麻烦一点，在部署时清晰的划定需要暴露给外界的服务，直接在这些服务上部署带API Gateway功能的Sidecar，也是可行的，只是管理上会比BFF模式要复杂一些。&lt;/p&gt;
&lt;p&gt;另外，在部署上，按照上面的方案，我们会发现：API Gateway“消失”了 —— 不再有一个明确物理部署的API Gateway的集群，常规的中心化的网关在这个方案中被融合到每一个BFF的实例中，从而实现另外一个重要特性：去中心化。&lt;/p&gt;
&lt;p&gt;上述Service Mesh 和 API Gateway融合的方案，并未停留在纸面上。&lt;/p&gt;
&lt;p&gt;在蚂蚁金服内部，我们基于Service Mesh 和 API Gateway融合 + 去中心化的思路，进行过开创性的实践和探索。以支付宝移动网关为例，在过去十年间，网关经历了从单体到微服务，从中心化到去中心化，从共享的 gateway.jar 包到利用MOSN实现网关Mesh化/Sidecar化，最终演变成了这样一个方案：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_1ee19086dc89c08fdfb4b06d29218890.webp 400w,
               /blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_9605f0d2f2cc4fed5895eb9fbb8fd01d.webp 760w,
               /blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_1ee19086dc89c08fdfb4b06d29218890.webp&#34;
               width=&#34;760&#34;
               height=&#34;379&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈推荐阅读：附录中我的同事贾岛的文章 “蚂蚁金服 API Gateway Mesh 思考与实践” 对此有深入介绍和详细描述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文总结了 Service Mesh 和 API Gateway 的关系，整体上说两者的定位和职责“泾渭分明”，但在具体实现上，开始出现融合的趋势：早期传统方式是类库级别的代码复用，最新趋势是API Gateway和Sidecar 合二为一。&lt;/p&gt;
&lt;p&gt;后者的发展才刚刚起步，包括在蚂蚁金服我们也是才开始探索这个方向，但是相信在未来一两年间，社区可能会有更多的类似产品形态出现。&lt;/p&gt;
&lt;p&gt;补充介绍一下文中多次提到的“MOSN”：&lt;/p&gt;
&lt;p&gt;MOSN 是 MOSN 是 Modular Open Smart Network 的简称， 是一款使用 Go 语言开发的网络代理软件，由蚂蚁金服开源并经过几十万容器的生产级验证。 MOSN 作为云原生的网络数据平面，旨在为服务提供多协议、模块化、智能化、安全的代理能力。 MOSN 可以与任何支持 xDS API 的 Service Mesh 集成，亦可以作为独立的四、七层负载均衡，API Gateway、云原生 Ingress 等使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub：https://github.com/mosn/mosn&lt;/li&gt;
&lt;li&gt;官网：https://mosn.io&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;附录参考资料和推荐阅读&#34;&gt;附录：参考资料和推荐阅读&lt;/h2&gt;
&lt;p&gt;意犹未尽的同学，欢迎继续阅读以下内容。&lt;/p&gt;
&lt;p&gt;按文章发表的时间排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://konghq.com/blog/the-difference-between-api-gateways-and-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Difference Between API Gateways and Service Mesh&lt;/a&gt;： 2020-02，指导架构师确定何时使用API网关以及何时使用服务网格，作者Marco Palladino，来自kong。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/microservices/do-i-need-an-api-gateway-if-i-have-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Do I Need an API Gateway if I Use a Service Mesh?&lt;/a&gt;：2020-01，作者 Christian Posta，中文翻译版本请见马若飞同学的 &lt;a href=&#34;https://www.servicemesher.com/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用了 Service Mesh 后我还需要 API 网关吗&lt;/a&gt;，对 Service Mesh 技术和 API 网关的对比，着重分析了两者的功能重合点和分歧点，为技术选型和落地提供了指导思路。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/azCFGyTDGakZqaLEEDMN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;蚂蚁金服 API Gateway Mesh 思考与实践&lt;/a&gt;: 2019-12，作者贾岛，介绍蚂蚁金服支付宝网关的发展和API Gateway Mesh的由来，强烈推荐阅读，这个文章非常清晰的介绍了蚂蚁金服在Service Mesh和API Gateway融合方面的实践。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.servicemesher.com/blog/api-gateways-are-going-through-an-identity-crisis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Gateway的身份认同危机&lt;/a&gt;: 2019-05, 原文作者 Christian Posta，译者周雨青，讲述API Gateway的基本理念如API的定义，API Management的含义，API Gateway模式，以及服务网格和API Gateway的关系。&lt;/li&gt;
&lt;li&gt;长路漫漫踏歌而行：蚂蚁金服Service Mesh实践探索：2018-10，我在QCon的演讲，我分享了当时蚂蚁金服在服务间通讯范围的探索，提出将服务网格在东西向通讯中的能力重用到南北向通讯中，当时基于Sidecar的SOFA Gateway产品刚开始开发。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.getambassador.io/api-gateway-vs-service-mesh-104c01fa4784&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Gateway vs Service Mesh&lt;/a&gt;: 2018-09，作者Richard Li，Datawire的CEO ，在开发 Ambassador API Gateway。Ambassador 是基于 Envoy 的API Gateway开源产品，文章阐述了对服务网格和API Gateway的看法，差异，以及对两者集成的看法。&lt;/li&gt;
&lt;li&gt;DreamMesh抛砖引玉(9)-API Gateway：2018-03，这个文章也是我写的，2018年初我和Service Mesh社区的一些朋友深入探讨之后，在DreamMesh系列博客文章中记录下了当时构想的方案，尤其对 API gateway和sidecar是分是合有详细讨论。当时想法还不够成熟，但大体方向已经有雏形了。鸣谢当时参与讨论的同学！&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/microservices-in-practice/service-mesh-vs-api-gateway-a6d814b9bf56&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh vs API Gateway&lt;/a&gt;: 2017-10，原文作者 &lt;a href=&#34;https://medium.com/@kasunindrasiri&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kasun Indrasiri&lt;/a&gt;，以及 &lt;a href=&#34;https://zhaohuabing.com/2018/04/11/service-mesh-vs-api-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;赵化冰同学翻译的中文版本&lt;/a&gt;，文章不长，主要对比了服务网格和API Gateway的产品功能，提出了两者融合的方式——在API Gateway中通过服务网格来调用下游服务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Network Functions With ESBs, API Management, and Now.. Service Mesh?&lt;/a&gt;：2017-08，作者 Christian Posta，讲述服务网格与ESB，消息代理和API管理之类的事物的关系。内容非常好，强烈推荐阅读（我不得不吐糟一下：配图太辣眼睛）。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>构建云原生微服务网关-篇一：Ambassador</title>
      <link>https://cloudnative.to/blog/cloud-native-api-gateway-part-1/</link>
      <pubDate>Thu, 01 Aug 2019 20:15:43 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-api-gateway-part-1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在微服务架构中，API网关是一个十分重要的存在。一方面它为外部的流量访问提供了统一的入口，使得可以方便的进行防火墙的策略实施；另一方面，可以在网关处进行流量控制、认证、授权、灰度发布、日志收集、性能分析等各种高级功能，使得业务功能与非业务功能有效解耦，给予了系统架构更大的灵活性。本系列文章尝试分析目前主流的云原生微服务网关，并比较它们各自的优劣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;网关选型标准&#34;&gt;网关选型标准&lt;/h2&gt;
&lt;p&gt;其实kubernetes本身有一个ingress controller，基于Nginx或HAProxy等7层代理进行流量的转发。不过ingress只能进行简单的反向代理，不支持流控、灰度、认证、授权等网关必备的功能。所以一般意义认为，ingress是一个7层http代理，而非api网关。本系列主要分析Ambassador、Traefik、Kong等具备&lt;strong&gt;微服务&lt;/strong&gt;所需能力的网关产品。&lt;/p&gt;
&lt;h2 id=&#34;什么是ambassador&#34;&gt;什么是Ambassador？&lt;/h2&gt;
&lt;p&gt;这里引用官网的一段描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ambassador是一个基于Envoy proxy构建的，kubernetes原生的开源微服务网关。Ambassador在构建之初就致力于支持多个独立的团队，这些团队需要为最终用户快速发布、监控和更新服务。Ambassador还具有Kubernetes ingress和负载均衡的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意这里的几个关键词：&lt;strong&gt;Envoy&lt;/strong&gt;，&lt;strong&gt;kubernetes原生&lt;/strong&gt;，&lt;strong&gt;微服务&lt;/strong&gt;。现在市面上网关产品不少，不过Kubernetes原生的产品倒真的不多。传统的网关产品一般是基于rest api或者yaml文件来进行配置（谁让这些老大哥出来的早呢，他们火的时候k8还没出来呢），而Ambassador完全基于k8s标准的annotation或者CRD来进行各类配置，没错，非常的&lt;strong&gt;native&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;ambassador架构&#34;&gt;Ambassador架构&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-0dcae8cb18297b27_hu8bdf406e6696a0fec3f8bad4e0d74f39_140610_8b329baa11b79f1bd49b68ba4a5699af.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-0dcae8cb18297b27_hu8bdf406e6696a0fec3f8bad4e0d74f39_140610_94d293736e3b6fdd83c09d73500f1c7b.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-0dcae8cb18297b27_hu8bdf406e6696a0fec3f8bad4e0d74f39_140610_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-0dcae8cb18297b27_hu8bdf406e6696a0fec3f8bad4e0d74f39_140610_8b329baa11b79f1bd49b68ba4a5699af.webp&#34;
               width=&#34;760&#34;
               height=&#34;430&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;了解istio的同学，看到这张图会有十分熟悉的感觉，没错，Ambassador也是具有控制平面和数据平面的。数据平面自然是老伙计Envoy，Ambassador的控制平面负责监听k8s中的Service资源的变化，并将配置下发Envoy，实际的流量转发通过Envoy来完成。（感觉就是一个轻量级的istio）&lt;/p&gt;
&lt;p&gt;具体流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务所有者在kubernetes manifests中定义配置(通过annotation或者CRD)。&lt;/li&gt;
&lt;li&gt;当manifest应用到集群时，kubernetes api会将更改通知Ambassador。&lt;/li&gt;
&lt;li&gt;Ambassador解析更改并将配置转换为一种中间语义。Envoy的配置由该IR生成。&lt;/li&gt;
&lt;li&gt;新的配置通过基于gRPC的聚合发现服务（ADS）api传递给Envoy。&lt;/li&gt;
&lt;li&gt;流量通过重新配置的Envoy，而不会断开任何连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;扩展性和可用性&#34;&gt;扩展性和可用性&lt;/h2&gt;
&lt;p&gt;Ambassador依靠Kubernetes实现扩展性、高可用性和持久性。所有Ambassador配置都直接存储在Kubernetes中（etcd），没有数据库。Ambassador被打包成一个单独的容器，其中包含控制平面和一个Ambassador代理实例。默认情况下，Ambassador部署为kubernetes deployment，可以像其他kubernetes deployment一样进行扩展和管理。&lt;/p&gt;
&lt;h2 id=&#34;与其他网关产品比较&#34;&gt;与其他网关产品比较&lt;/h2&gt;
&lt;p&gt;目前主流的网关产品可以分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;托管的API网关，比如 &lt;a href=&#34;https://aws.amazon.com/api-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon api gateway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;传统的API网关，比如 &lt;a href=&#34;https://getkong.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;7层代理，比如 &lt;a href=&#34;https://traefik.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik&lt;/a&gt;, &lt;a href=&#34;http://nginx.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NGINX&lt;/a&gt;, &lt;a href=&#34;http://www.haproxy.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HAProxy&lt;/a&gt;, or &lt;a href=&#34;https://www.Envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;, 或者是基于这些代理的 Ingress controllers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有这些托管的和传统的API网关的问题是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不是自服务的。传统API网关上的管理接口不是为开发人员自服务而设计的，为开发人员提供的安全性和可用性有限。&lt;/li&gt;
&lt;li&gt;不是Kubernetes原生的。它们通常使用REST apis进行配置，这使得采用云原生模式（如GitOps和声明式配置）变得很困难。&lt;/li&gt;
&lt;li&gt;为API管理而设计，而非微服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说，7层代理可以用作API网关，但需要额外的定制开发来支持微服务用例。事实上，许多API网关都将API网关所需的附加功能打包在L7代理之上。Ambassador使用Envoy，而Kong使用Nginx。&lt;/p&gt;
&lt;h2 id=&#34;istio&#34;&gt;Istio&lt;/h2&gt;
&lt;p&gt;Istio是一个基于Envoy的开源服务网格。 服务网格用于管理东/西流量，而API网关用于管理南/北流量。 一般来说，我们发现南/北流量与东/西流量有很大不同（比如说，在南北流量中你无法控制客户端）。&lt;/p&gt;
&lt;h2 id=&#34;安装ambassador&#34;&gt;安装Ambassador&lt;/h2&gt;
&lt;p&gt;Ambassador安装非常的简单，直接使用helm安装。如果对于helm还不是很了解，可以参考我之前的文章 &lt;a href=&#34;https://www.jianshu.com/p/290f27841b8d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;helm介绍&lt;/a&gt;。
使用helm安装只需要执行如下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install --name my-release stable/ambassador
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 这边插播一下，推荐使用微软azure的charts镜像&lt;code&gt;http://mirror.azure.cn/kubernetes/charts/&lt;/code&gt;，基本和官方的同步，且可以正常访问，阿里云的charts不知道为什么更新很不及时。
安装完后可以看到有两个pods&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                          READY     STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ambassador-3655608000-43x86   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          2m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ambassador-3655608000-w63zf   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          2m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果都是都是running状态，这样Ambassador就安装完成了
接下来我们部署一下官网的应用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;getambassador.io/config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      ---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      apiVersion: ambassador/v1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      kind: Mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      name: tour-ui_mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      prefix: /
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      service: tour:5000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      ---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      apiVersion: ambassador/v1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      kind: Mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      name: tour-backend_mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      prefix: /backend/
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      service: tour:8080
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      labels:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        ambassador:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          - request_label:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;            - backend&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ui&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;backend&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apps/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;replicas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;strategy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RollingUpdate&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour-ui&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;quay.io/datawire/tour:ui-0.2.4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;quote&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;quay.io/datawire/tour:backend-0.2.4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;limits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;100Mi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个pod里面有两个容器，分别是前端的ui以及后端的backend。注意annotation里面的&lt;code&gt;getambassador.io/config&lt;/code&gt;部分，这就是ambassador的配置了，分别定义了两个注释，kind是&lt;code&gt;Mapping&lt;/code&gt;，定义了前后端的匹配路径，服务名称及端口。这个配置的意思是，凡是匹配上&lt;code&gt;/&lt;/code&gt;的，全部走tour的5000端口，凡是匹配上&lt;code&gt;/backend&lt;/code&gt;的，全部走tour的8080端口（对应的就是tour的service配置）。也可以使用CRD方式配置，ambassador已经默认创建了一组crd&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;root@MiWiFi-R1CM-srv zuul&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# kubectl get crds|grep ambassador&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;authservices.getambassador.io                  2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;consulresolvers.getambassador.io               2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetesendpointresolvers.getambassador.io   2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetesserviceresolvers.getambassador.io    2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mappings.getambassador.io                      2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;modules.getambassador.io                       2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ratelimitservices.getambassador.io             2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcpmappings.getambassador.io                   2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tlscontexts.getambassador.io                   2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tracingservices.getambassador.io               2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中mapping就是核心资源，用于路由的转发配置，下面是一个mapping资源配置示例&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;items&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;getambassador.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Mapping&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kubectl.kubernetes.io/last-applied-configuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;{&lt;span class=&#34;s2&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;getambassador.io/v1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;kind&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Mapping&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;{&lt;span class=&#34;s2&#34;&gt;&amp;#34;annotations&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;{}&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;nginx&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;namespace&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;default&amp;#34;&lt;/span&gt;}&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spec&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;{&lt;span class=&#34;s2&#34;&gt;&amp;#34;prefix&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/nginx&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;service&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;nginx:80&amp;#34;&lt;/span&gt;}}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2019-07-27T13:36:38Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;generation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resourceVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;420594&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selfLink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/apis/getambassador.io/v1/namespaces/default/mappings/nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;8f1f4d33-b073-11e9-be4c-0800279f163b&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx:80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resourceVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selfLink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一旦你修改了service里面的annotation设置，ambassador的控制面会自动将变更下发给Envoy，全程不需要中断服务。（也要感谢Envoy强大的xDS api）&lt;/p&gt;
&lt;p&gt;下面我们来看一下Ambassador的几个使用场景：&lt;/p&gt;
&lt;h2 id=&#34;用例&#34;&gt;用例&lt;/h2&gt;
&lt;h3 id=&#34;用例1边缘南北路由&#34;&gt;用例1：边缘（南/北）路由&lt;/h3&gt;
&lt;p&gt;这个是平时最常见的使用场景，网关位于整个集群的入口处，统一去做一些流控、鉴权等方面的工作：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-45238040cc6650c4_hu9a78ab1340ace24316364e507a63d684_654383_09787f1a4401c0f8bbad0bc56f6530ab.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-45238040cc6650c4_hu9a78ab1340ace24316364e507a63d684_654383_d91961dd019880166c342b67e4a660b2.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-45238040cc6650c4_hu9a78ab1340ace24316364e507a63d684_654383_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-45238040cc6650c4_hu9a78ab1340ace24316364e507a63d684_654383_09787f1a4401c0f8bbad0bc56f6530ab.webp&#34;
               width=&#34;760&#34;
               height=&#34;454&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;该场景的关注点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制/路由入口流量的能力&lt;/li&gt;
&lt;li&gt;卸载请求
&lt;ul&gt;
&lt;li&gt;认证（比如要求所有入口流量都必须要进过认证）&lt;/li&gt;
&lt;li&gt;加密（TLS终端及传输加密）&lt;/li&gt;
&lt;li&gt;重试及超时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;saas service中的真实用例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-7db0c08aafed66b9_hu20f7e83b2e9c7608cee16e9229828b84_213709_85ada0be71ca3bb3a0a3666e9a89bd58.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-7db0c08aafed66b9_hu20f7e83b2e9c7608cee16e9229828b84_213709_c3661edee9f05617ef196f6dc75be369.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-7db0c08aafed66b9_hu20f7e83b2e9c7608cee16e9229828b84_213709_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-7db0c08aafed66b9_hu20f7e83b2e9c7608cee16e9229828b84_213709_85ada0be71ca3bb3a0a3666e9a89bd58.webp&#34;
               width=&#34;760&#34;
               height=&#34;367&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;用例2内部南北路由&#34;&gt;用例2：内部（南/北）路由&lt;/h3&gt;
&lt;p&gt;通常来说，企业内部的系统架构会比较复杂，会有多集群或者多租户，比如一个kubernetes的集群和一个vm的集群（可能是openstack），那么在集群之间的流量就是内部的南/北流量，集群之间的流量交互可以通过ambassador完成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-90750413b7c7e9f5_huc1feabb3b3a414490d5dfa9c4dc40103_405846_5e02935b14f6ec5b5a30b3e32aa0eafb.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-90750413b7c7e9f5_huc1feabb3b3a414490d5dfa9c4dc40103_405846_9aac33649f7c5fe060e77916d7d91d53.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-90750413b7c7e9f5_huc1feabb3b3a414490d5dfa9c4dc40103_405846_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-90750413b7c7e9f5_huc1feabb3b3a414490d5dfa9c4dc40103_405846_5e02935b14f6ec5b5a30b3e32aa0eafb.webp&#34;
               width=&#34;760&#34;
               height=&#34;447&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此场景的关注点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制/路由多租户流量的能力&lt;/li&gt;
&lt;li&gt;卸载请求
&lt;ul&gt;
&lt;li&gt;匹配（基于headers）&lt;/li&gt;
&lt;li&gt;重试及超时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;saas service中的真实用例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-23acd24daab3455b_hu4aa6dec4760eb792f36bc4964dff083e_302570_9c7a2b3abed414693bfb1c34fdb836db.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-23acd24daab3455b_hu4aa6dec4760eb792f36bc4964dff083e_302570_1ca5013f8a5572ddde18f68a1d46ace9.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-23acd24daab3455b_hu4aa6dec4760eb792f36bc4964dff083e_302570_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-23acd24daab3455b_hu4aa6dec4760eb792f36bc4964dff083e_302570_9c7a2b3abed414693bfb1c34fdb836db.webp&#34;
               width=&#34;760&#34;
               height=&#34;371&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;用例3内部东西路由&#34;&gt;用例3：内部（东/西）路由&lt;/h3&gt;
&lt;p&gt;这个场景中Ambassador已经作为集群内部东西向流量的代理了，配合它自己的控制平面，有点service mesh的意思了。区别在于，Ambassador在这个集群里是处于一个中心节点的位置（一个或一组ambassador实例），属于server proxy的范畴，而不是service mesh里面的client proxy（sidecar）。这种架构其实和传统的esb更加的接近。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-8cec66e2dc3b82c1_hud2323e03413867f76b95fda25d4ce189_416807_ce6f2b85b020f743378a2b33b96e63b9.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-8cec66e2dc3b82c1_hud2323e03413867f76b95fda25d4ce189_416807_c7ff16de2510fa8d7c64009a62c9383b.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-8cec66e2dc3b82c1_hud2323e03413867f76b95fda25d4ce189_416807_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-8cec66e2dc3b82c1_hud2323e03413867f76b95fda25d4ce189_416807_ce6f2b85b020f743378a2b33b96e63b9.webp&#34;
               width=&#34;760&#34;
               height=&#34;459&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此场景关注点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制/路由任意流量的能力（南北向+东西向）&lt;/li&gt;
&lt;li&gt;卸载请求
&lt;ul&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;访问控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家可以看到，已经非常接近于service mesh的能力了（也许ambassador以后也会出一个service mesh产品？）&lt;/p&gt;
&lt;p&gt;saas service的真实用例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-605fcdf1a7987640_hu020f9ea833ad1b5261b564901f9470a8_235224_f48ef9a82d7b53bd7b5bdbaa1bde73f1.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-605fcdf1a7987640_hu020f9ea833ad1b5261b564901f9470a8_235224_cd7177c34ee038ce6164fb7956f9b9dd.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-605fcdf1a7987640_hu020f9ea833ad1b5261b564901f9470a8_235224_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-605fcdf1a7987640_hu020f9ea833ad1b5261b564901f9470a8_235224_f48ef9a82d7b53bd7b5bdbaa1bde73f1.webp&#34;
               width=&#34;760&#34;
               height=&#34;345&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;服务网格的真实用例（与istio集成）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-dbefbeb1c9fcf405_huf2e5170596e015ef27b04ec7522459b5_184471_046e52164cc571f0e1d6545f349e8fd7.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-dbefbeb1c9fcf405_huf2e5170596e015ef27b04ec7522459b5_184471_52e78c4fdfa62a02577d038776419c2f.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-dbefbeb1c9fcf405_huf2e5170596e015ef27b04ec7522459b5_184471_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-dbefbeb1c9fcf405_huf2e5170596e015ef27b04ec7522459b5_184471_046e52164cc571f0e1d6545f349e8fd7.webp&#34;
               width=&#34;760&#34;
               height=&#34;345&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;用例4流量镜像&#34;&gt;用例4：流量镜像&lt;/h3&gt;
&lt;p&gt;此场景中可以把流量复制一份到其他服务中（影子流量），通常用于监控、测试等场景&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-85a3899f164466c2_hue9ceca84ce874ed61d1e4e0e3ce76420_242144_a5c0e1daad16550b6cb54bc00b77a0f3.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-85a3899f164466c2_hue9ceca84ce874ed61d1e4e0e3ce76420_242144_3ceb7c521521d87ba120f90bd9884cdb.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-85a3899f164466c2_hue9ceca84ce874ed61d1e4e0e3ce76420_242144_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-85a3899f164466c2_hue9ceca84ce874ed61d1e4e0e3ce76420_242144_a5c0e1daad16550b6cb54bc00b77a0f3.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试代码、发布包的能力&lt;/li&gt;
&lt;li&gt;利用真实的流量/负载&lt;/li&gt;
&lt;li&gt;最小化重复资源&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：上面所描述的几个典型场景其实不光可以使用Ambassador，而是适用于各类使用api gateway或者proxy的场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;Ambassador不同版本之间配置方式的变更如下图所示,configmap方式是早期使用方式，目前已经被废弃了，现在更推荐使用CRD方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-d2aac8fb2c0cbeda_hu319b5bd47535d491d20c4cc26d77f27a_46410_62a411159854a3ebc5db1ef40660b4ac.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-d2aac8fb2c0cbeda_hu319b5bd47535d491d20c4cc26d77f27a_46410_9e9f0fcaf9f8b02d28f5efc608d25dfa.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-d2aac8fb2c0cbeda_hu319b5bd47535d491d20c4cc26d77f27a_46410_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-d2aac8fb2c0cbeda_hu319b5bd47535d491d20c4cc26d77f27a_46410_62a411159854a3ebc5db1ef40660b4ac.webp&#34;
               width=&#34;760&#34;
               height=&#34;201&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;加密的配置方式&#34;&gt;加密的配置方式&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-f9231001054176b2_hu0e18278873a9025e6f57b3a63492be1c_132866_013e305018bf0d428d6ab2e90b3a4a9d.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-f9231001054176b2_hu0e18278873a9025e6f57b3a63492be1c_132866_a53ebed36d1518c11ae7f2cd39b7ea37.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-f9231001054176b2_hu0e18278873a9025e6f57b3a63492be1c_132866_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-f9231001054176b2_hu0e18278873a9025e6f57b3a63492be1c_132866_013e305018bf0d428d6ab2e90b3a4a9d.webp&#34;
               width=&#34;760&#34;
               height=&#34;352&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;认证的配置方式&#34;&gt;认证的配置方式&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-38b74b7b5ed93f2e_huce83d985abfa41cbe73ea263abf7c813_200162_6ecf093e5ad77e38b593447e8afd4ecf.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-38b74b7b5ed93f2e_huce83d985abfa41cbe73ea263abf7c813_200162_fe81727bc94dd2e5c72293fd7a097625.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-38b74b7b5ed93f2e_huce83d985abfa41cbe73ea263abf7c813_200162_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-38b74b7b5ed93f2e_huce83d985abfa41cbe73ea263abf7c813_200162_6ecf093e5ad77e38b593447e8afd4ecf.webp&#34;
               width=&#34;760&#34;
               height=&#34;360&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;路由的配置方式&#34;&gt;路由的配置方式&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-64fc6ccdef6a0386_hu040b4cff851e7701e9464b017f5392f9_145494_42e2ca6220d71f029e81e3cebd9b78dc.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-64fc6ccdef6a0386_hu040b4cff851e7701e9464b017f5392f9_145494_751e240a25371632d2f10e57e66a928e.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-64fc6ccdef6a0386_hu040b4cff851e7701e9464b017f5392f9_145494_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-64fc6ccdef6a0386_hu040b4cff851e7701e9464b017f5392f9_145494_42e2ca6220d71f029e81e3cebd9b78dc.webp&#34;
               width=&#34;760&#34;
               height=&#34;338&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;跟踪的配置方式&#34;&gt;跟踪的配置方式&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-2ed98f1ea3c98531_hu40345bf7c2825f079a83019471fd9ae7_141631_5d7e6913a3f0dd516f5d7d008d978990.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-2ed98f1ea3c98531_hu40345bf7c2825f079a83019471fd9ae7_141631_7b99a3c5f037e57498c857c1c7778be3.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-2ed98f1ea3c98531_hu40345bf7c2825f079a83019471fd9ae7_141631_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-2ed98f1ea3c98531_hu40345bf7c2825f079a83019471fd9ae7_141631_5d7e6913a3f0dd516f5d7d008d978990.webp&#34;
               width=&#34;760&#34;
               height=&#34;322&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;ambassador的不足&#34;&gt;Ambassador的不足&lt;/h2&gt;
&lt;p&gt;Ambassador和同类的网关产品类似，分为社区版及商业版，社区版提供了最基础的路由、限速、TLS加密、跟踪、认证（需要自己实现external third party authentication service）等能力，但是微服务网关中十分重要的OAuth2集成认证、RBAC、custom filter等功能都是需要在pro版中才能实现，这是比较遗憾的一点。尤其是custom filter，根据我们目前的经验，一个能力完整、功能丰富的微服务网关，必然会引入custom filter。而custom filter也需要使用Golang进行编写，对于不熟悉Golang的开发人员来说也会比较痛苦。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Ambassador作为一个较新推出的开源微服务网关产品，与kubernetes结合的相当好，基于annotation或CRD的配置方式与k8s浑然一体，甚至让人感觉这就是k8s自身功能的一部分，真正做到了&lt;code&gt;kubernetes native&lt;/code&gt;。而底层基于Envoy进行流量代理，也让人不需要太担心性能问题。对于路由、加密、基础认证、链路跟踪等场景，可尝试使用。而对于像&lt;code&gt;custom filter&lt;/code&gt;、&lt;code&gt;rbac&lt;/code&gt;、&lt;code&gt;advanced rate limiting&lt;/code&gt;等场景有需求的用户，使用pro版本可满足要求。本人也与Ambassador开发团队进行了联系，遗憾的是Ambassador目前在国内尚未有reseller，若使用pro版，后期技术支持的便利性也是需要考虑的问题。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.getambassador.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.getambassador.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Using Ambassador to build Cloud-Native Applications - Steve Flanders, Omnition @ KubeCon 2019, Shanghai&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何为服务网格选择入口网关？</title>
      <link>https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/</link>
      <pubDate>Wed, 15 May 2019 12:23:01 +0800</pubDate>
      <guid>https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/</guid>
      <description>&lt;p&gt;在启用了Istio服务网格的Kubernetes集群中，缺省情况下只能在集群内部访问网格中的服务，要如何才能从外部网络访问这些服务呢？ Kubernetes和Istio提供了NodePort，LoadBalancer，Kubernetes Ingress，Istio Gateway等多种外部流量入口的方式，面对这么多种方式，我们在产品部署中应该如何选择？&lt;/p&gt;
&lt;p&gt;本文将对Kubernetes和Istio对外提供服务的各种方式进行详细介绍和对比分析，并根据分析结果提出一个可用于产品部署的解决方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;说明：阅读本文要求读者了解Kubernetes和Istio的基本概念，包括Pod、Service、NodePort、LoadBalancer、Ingress、Gateway、VirtualService等。如对这些概念不熟悉，可以在阅读过程中参考文后的相关链接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;内部服务间的通信&#34;&gt;内部服务间的通信&lt;/h2&gt;
&lt;p&gt;首先，我们来回顾一下Kubernetes集群内部各个服务之间相互访问的方法。&lt;/p&gt;
&lt;h2 id=&#34;cluster-ip&#34;&gt;Cluster IP&lt;/h2&gt;
&lt;p&gt;Kubernetes以Pod作为应用部署的最小单位。Kubernetes会根据Pod的声明对其进行调度，包括创建、销毁、迁移、水平伸缩等，因此Pod的IP地址不是固定的，不方便直接采用Pod IP对服务进行访问。&lt;/p&gt;
&lt;p&gt;为解决该问题，Kubernetes提供了Service资源，Service对提供同一个服务的多个Pod进行聚合。一个Service提供一个虚拟的Cluster IP，后端对应一个或者多个提供服务的Pod。在集群中访问该Service时，采用Cluster IP即可，Kube-proxy负责将发送到Cluster IP的请求转发到后端的Pod上。&lt;/p&gt;
&lt;p&gt;Kube-proxy是一个运行在每个节点上的go应用程序，支持三种工作模式：&lt;/p&gt;
&lt;h3 id=&#34;userspace-模式&#34;&gt;userspace 模式&lt;/h3&gt;
&lt;p&gt;该模式下Kube-proxy会为每一个Service创建一个监听端口。发向Cluster IP的请求被Iptables规则重定向到Kube-proxy监听的端口上，Kube-proxy根据LB算法选择一个提供服务的Pod并和其建立链接，以将请求转发到Pod上。&lt;br&gt;
该模式下，Kube-proxy充当了一个四层Load balancer的角色。由于Kube-proxy运行在userspace中，在进行转发处理时会增加两次内核和用户空间之间的数据拷贝，效率较另外两种模式低一些；好处是当后端的Pod不可用时，Kube-proxy可以重试其他Pod。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-userspace模式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kube-proxy userspace模式&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu004e566ffbb697606d214d97c7c998ef_173749_258d4c6b58c6c4521f1bbcd7367f27b7.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu004e566ffbb697606d214d97c7c998ef_173749_9cb85c216dcb7949a0277cb2a4e9c96c.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu004e566ffbb697606d214d97c7c998ef_173749_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu004e566ffbb697606d214d97c7c998ef_173749_258d4c6b58c6c4521f1bbcd7367f27b7.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kube-proxy userspace模式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图片来自：&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;iptables-模式&#34;&gt;iptables 模式&lt;/h3&gt;
&lt;p&gt;为了避免增加内核和用户空间的数据拷贝操作，提高转发效率，Kube-proxy提供了iptables模式。在该模式下，Kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。&lt;br&gt;
该模式下Kube-proxy不承担四层代理的角色，只负责创建iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略，当后端Pod不可用时也无法进行重试。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-iptables模式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kube-proxy iptables模式&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hua2531e630bdc8006015b2559d568efcc_213686_1be72a27081caba131a5f81c6608854b.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hua2531e630bdc8006015b2559d568efcc_213686_21265347f7e9647db3d7616e4074809c.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hua2531e630bdc8006015b2559d568efcc_213686_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hua2531e630bdc8006015b2559d568efcc_213686_1be72a27081caba131a5f81c6608854b.webp&#34;
               width=&#34;760&#34;
               height=&#34;526&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kube-proxy iptables模式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图片来自：&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;ipvs-模式&#34;&gt;ipvs 模式&lt;/h3&gt;
&lt;p&gt;该模式和iptables类似，Kube-proxy监控Pod的变化并创建相应的ipvs rules。ipvs也是在kernel模式下通过netfilter实现的，但采用了hash table来存储规则，因此在规则较多的情况下，Ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。如果要设置Kube-proxy为ipvs模式，必须在操作系统中安装IPVS内核模块。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-ipvs模式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kube-proxy ipvs模式&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hud3f3bc54abecdb13e6526c2355d0fa65_173996_c3e1d6f442f8f41b41265d563a1bf57a.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hud3f3bc54abecdb13e6526c2355d0fa65_173996_04f228eb72690b42be57168f95bd1ccb.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hud3f3bc54abecdb13e6526c2355d0fa65_173996_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hud3f3bc54abecdb13e6526c2355d0fa65_173996_c3e1d6f442f8f41b41265d563a1bf57a.webp&#34;
               width=&#34;760&#34;
               height=&#34;524&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kube-proxy ipvs模式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图片来自：&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;istio-sidecar-proxy&#34;&gt;Istio Sidecar Proxy&lt;/h2&gt;
&lt;p&gt;Cluster IP解决了服务之间相互访问的问题，但从上面Kube-proxy的三种模式可以看到，Cluster IP的方式只提供了服务发现和基本的LB功能。如果要为服务间的通信应用灵活的路由规则以及提供Metrics collection，distributed tracing等服务管控功能，就必须得依靠Istio提供的服务网格能力了。&lt;/p&gt;
&lt;p&gt;在Kubernetes中部署Istio后，Istio通过iptables和Sidecar Proxy接管服务之间的通信，服务间的相互通信不再通过Kube-proxy，而是通过Istio的Sidecar Proxy进行。请求流程是这样的：Client发起的请求被iptables重定向到Sidecar Proxy，Sidecar Proxy根据从控制面获取的服务发现信息和路由规则，选择一个后端的Server Pod创建连接，代理并转发Client的请求。&lt;/p&gt;
&lt;p&gt;Istio Sidecar Proxy和Kube-proxy的userspace模式的工作机制类似，都是通过在用户空间的一个代理来实现客户端请求的转发和后端多个Pod之间的负载均衡。两者的不同点是：Kube-Proxy工作在四层，而Sidecar Proxy则是一个七层代理，可以针对HTTP，gRPC等应用层的语义进行处理和转发，因此功能更为强大，可以配合控制面实现更为灵活的路由规则和服务管控功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-sidecar-proxy&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio Sidecar Proxy&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hucd3c3bc3c7bafc84039a0cee4ca4c566_55922_ce6ec5b399da16c115a57e739560ea4a.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hucd3c3bc3c7bafc84039a0cee4ca4c566_55922_dc5817ed09602b6c59e41cbed7493c02.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hucd3c3bc3c7bafc84039a0cee4ca4c566_55922_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hucd3c3bc3c7bafc84039a0cee4ca4c566_55922_ce6ec5b399da16c115a57e739560ea4a.webp&#34;
               width=&#34;636&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio Sidecar Proxy
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h1 id=&#34;如何从外部网络访问&#34;&gt;如何从外部网络访问&lt;/h1&gt;
&lt;p&gt;Kubernetes的Pod IP和Cluster IP都只能在集群内部访问，而我们通常需要从外部网络上访问集群中的某些服务，Kubernetes提供了下述几种方式来为集群提供外部流量入口。&lt;/p&gt;
&lt;h2 id=&#34;nodeport&#34;&gt;NodePort&lt;/h2&gt;
&lt;p&gt;NodePort在集群中的主机节点上为Service提供一个代理端口，以允许从主机网络上对Service进行访问。Kubernetes官网文档只介绍了NodePort的功能，并未对其实现原理进行解释。下面我们通过实验来分析NodePort的实现机制。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.katacoda.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;www.katacoda.com&lt;/a&gt; 这个网站提供了一个交互式的Kubernetes playground，注册即可免费实验Kubernetes的相关功能，下面我们就使用Katacoda来分析Nodeport的实现原理。&lt;/p&gt;
&lt;p&gt;在浏览器中输入这个网址：https://www.katacoda.com/courses/kubernetes/networking-introduction， 打开后会提供了一个实验用的Kubernetes集群，并可以通过网元模拟Terminal连接到集群的Master节点。&lt;/p&gt;
&lt;p&gt;执行下面的命令创建一个nodeport类型的service。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ cat nodeport.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apiVersion: v1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kind: Service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  name: webapp1-nodeport-svc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  labels:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    app: webapp1-nodeport
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  type: NodePort
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ports:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  - port: &lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    nodePort: &lt;span class=&#34;m&#34;&gt;30080&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  selector:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    app: webapp1-nodeport
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apiVersion: extensions/v1beta1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kind: Deployment
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  name: webapp1-nodeport-deployment
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  replicas: &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  template:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      labels:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        app: webapp1-nodeport
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    spec:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      containers:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      - name: webapp1-nodeport-pod
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        image: katacoda/docker-http-server:latest
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ports:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - containerPort: &lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ kubectl apply -f nodeport.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看创建的service，可以看到Kubernetes创建了一个名为webapp-nodeport-svc的service，并为该service在主机节点上创建了30080这个Nodeport。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ kubectl get svc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                   TYPE        CLUSTER-IP      EXTERNAL-IP   PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;        AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetes             ClusterIP   10.96.0.1       &amp;lt;none&amp;gt;        443/TCP        36m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;webapp1-nodeport-svc   NodePort    10.103.188.73   &amp;lt;none&amp;gt;        80:30080/TCP   3m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;webapp-nodeport-svc后端对应两个Pod，其Pod的IP分别为10.32.0.3和10.32.0.5。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ kubectl get pod -o wide
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                                           READY     STATUS    RESTARTS   AGE       IPNODE      NOMINATED NODE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;webapp1-nodeport-deployment-785989576b-cjc5b   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          2m        10.32.0.3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;webapp1-nodeport-deployment-785989576b-tpfqr   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          2m        10.32.0.5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过netstat命令可以看到Kube-proxy在主机网络上创建了30080监听端口，用于接收从主机网络进入的外部流量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ netstat -lnp&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;grep &lt;span class=&#34;m&#34;&gt;30080&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcp6       &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;      &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; :::30080                :::*                    LISTEN      7427/Kube-proxy
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面是Kube-proxy创建的相关iptables规则以及对应的说明。可以看到Kube-proxy为Nodeport创建了相应的IPtable规则，将发向30080这个主机端口上的流量重定向到了后端的两个Pod IP上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;iptables-save &amp;gt; iptables-dump
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Generated by iptables-save v1.6.0 on Thu Mar 28 07:33:57 2019&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*nat
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Nodeport规则链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-NODEPORTS - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Service规则链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-SERVICES - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Nodeport和Service共用的规则链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-SVC-J2DWGRZTH4C2LPA4 - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-SEP-4CGFRVESQ3AECDE7 - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-SEP-YLXG4RMKAICGY2B3 - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 将host上30080端口的外部tcp流量转到KUBE-SVC-J2DWGRZTH4C2LPA4链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-NODEPORTS -p tcp -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -m tcp --dport &lt;span class=&#34;m&#34;&gt;30080&lt;/span&gt; -j KUBE-SVC-J2DWGRZTH4C2LPA4
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将发送到Cluster IP 10.103.188.73的内部流量转到KUBE-SVC-J2DWGRZTH4C2LPA4链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;KUBE-SERVICES -d 10.103.188.73/32 -p tcp -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc: cluster IP&amp;#34;&lt;/span&gt; -m tcp --dport &lt;span class=&#34;m&#34;&gt;80&lt;/span&gt; -j KUBE-SVC-J2DWGRZTH4C2LPA4
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将发送到webapp1-nodeport-svc的流量转交到第一个Pod（10.32.0.3）相关的规则链上，比例为50%&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-SVC-J2DWGRZTH4C2LPA4 -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-YLXG4RMKAICGY2B3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将发送到webapp1-nodeport-svc的流量转交到第二个Pod（10.32.0.5）相关的规则链上&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-SVC-J2DWGRZTH4C2LPA4 -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -j KUBE-SEP-4CGFRVESQ3AECDE7
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将请求重定向到Pod 10.32.0.3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-SEP-YLXG4RMKAICGY2B3 -p tcp -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -m tcp -j DNAT --to-destination 10.32.0.3:80
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将请求重定向到Pod 10.32.0.5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-SEP-4CGFRVESQ3AECDE7 -p tcp -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -m tcp -j DNAT --to-destination 10.32.0.5:80
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上面的实验可以看到，通过将一个Service定义为NodePort类型，Kubernetes会通过集群中node上的Kube-proxy为该Service在主机网络上创建一个监听端口。Kube-proxy并不会直接接收该主机端口进入的流量，而是会创建相应的Iptables规则，并通过Iptables将从该端口收到的流量直接转发到后端的Pod中。&lt;/p&gt;
&lt;p&gt;NodePort的流量转发机制和Cluster IP的iptables模式类似，唯一不同之处是在主机网络上开了一个“NodePort”来接受外部流量。从上面的规则也可以看出，在创建Nodeport时，Kube-proxy也会同时为Service创建Cluster IP相关的iptables规则。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：除采用iptables进行流量转发，NodePort应该也可以提供userspace模式以及ipvs模式，这里未就这两种模式进行实验验证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从分析得知，在NodePort模式下，集群内外部的通讯如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-nodeport&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;NodePort&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu6e1f2811ddc8851efef39f1f43938ca9_64841_992e563a40bb3913a782ebd1cf5c5f67.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu6e1f2811ddc8851efef39f1f43938ca9_64841_7300066d32267b9dda170394d576eca2.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu6e1f2811ddc8851efef39f1f43938ca9_64841_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu6e1f2811ddc8851efef39f1f43938ca9_64841_992e563a40bb3913a782ebd1cf5c5f67.webp&#34;
               width=&#34;501&#34;
               height=&#34;408&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      NodePort
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;loadbalancer&#34;&gt;LoadBalancer&lt;/h2&gt;
&lt;p&gt;NodePort提供了一种从外部网络访问Kubernetes集群内部Service的方法，但该方法存在下面一些限制，导致这种方式主要适用于程序开发，不适合用于产品部署。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes cluster host的IP必须是一个well-known IP，即客户端必须知道该IP。但Cluster中的host是被作为资源池看待的，可以增加删除，每个host的IP一般也是动态分配的，因此并不能认为host IP对客户端而言是well-known IP。&lt;/li&gt;
&lt;li&gt;客户端访问某一个固定的host IP的方式存在单点故障。假如一台host宕机了，Kubernetes cluster会把应用 reload到另一节点上，但客户端就无法通过该host的nodeport访问应用了。&lt;/li&gt;
&lt;li&gt;通过一个主机节点作为网络入口，在网络流量较大时存在性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决这些问题，Kubernetes提供了LoadBalancer。通过将Service定义为LoadBalancer类型，Kubernetes在主机节点的NodePort前提供了一个四层的负载均衡器。该四层负载均衡器负责将外部网络流量分发到后面的多个节点的NodePort端口上。&lt;/p&gt;
&lt;p&gt;下图展示了Kubernetes如何通过LoadBalancer方式对外提供流量入口，图中LoadBalancer后面接入了两个主机节点上的NodePort，后端部署了三个Pod提供服务。根据集群的规模，可以在LoadBalancer后面可以接入更多的主机节点，以进行负荷分担。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-nodebalancer&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;NodeBalancer&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_hu53579f5e7ac717c1b782bc46f1cba810_149526_fa353de61b6e1fdebc5d96f2ef87da93.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_hu53579f5e7ac717c1b782bc46f1cba810_149526_7069003261a3c1f2bc2dce546576fa77.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_hu53579f5e7ac717c1b782bc46f1cba810_149526_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_hu53579f5e7ac717c1b782bc46f1cba810_149526_fa353de61b6e1fdebc5d96f2ef87da93.webp&#34;
               width=&#34;760&#34;
               height=&#34;497&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      NodeBalancer
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：LoadBalancer类型需要云服务提供商的支持，Service中的定义只是在Kubernetes配置文件中提出了一个要求，即为该Service创建Load Balancer，至于如何创建则是由Google Cloud或Amazon Cloud等云服务商提供的，创建的Load Balancer的过程不在Kubernetes Cluster的管理范围中。&lt;/p&gt;
&lt;p&gt;目前AWS、Azure、CloudStack、GCE和OpenStack等主流的公有云和私有云提供商都可以为Kubernetes提供Load Balancer。一般来说，公有云提供商还会为Load Balancer提供一个External IP，以提供Internet接入。如果你的产品没有使用云提供商，而是自建Kubernetes Cluster，则需要自己提供LoadBalancer。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ingress&#34;&gt;Ingress&lt;/h2&gt;
&lt;p&gt;LoadBalancer类型的Service提供的是四层负载均衡器，当只需要向外暴露一个服务的时候，采用这种方式是没有问题的。但当一个应用需要对外提供多个服务时，采用该方式则要求为每一个四层服务（IP+Port）都创建一个外部Load balancer。&lt;/p&gt;
&lt;p&gt;一般来说，同一个应用的多个服务/资源会放在同一个域名下，在这种情况下，创建多个Load balancer是完全没有必要的，反而带来了额外的开销和管理成本。另外直接将服务暴露给外部用户也会导致了前端和后端的耦合，影响了后端架构的灵活性，如果以后由于业务需求对服务进行调整会直接影响到客户端。&lt;/p&gt;
&lt;p&gt;在这种情况下，我们可以通过使用Kubernetes Ingress来统一网络入口。Kubernetes Ingress声明了一个应用层（OSI七层）的负载均衡器，可以根据HTTP请求的内容将来自同一个TCP端口的请求分发到不同的Kubernetes Service，其功能包括：&lt;/p&gt;
&lt;h3 id=&#34;按http请求的url进行路由&#34;&gt;按HTTP请求的URL进行路由&lt;/h3&gt;
&lt;p&gt;同一个TCP端口进来的流量可以根据URL路由到Cluster中的不同服务，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-按http请求的ulr进行路由&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;按HTTP请求的ULR进行路由&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu0bf1b1d2f986925642d684d489b02f8e_67735_f6cb08f427bd8f34c7bfc79238e93df0.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu0bf1b1d2f986925642d684d489b02f8e_67735_eeb9aede9844807d6d64017d98331d43.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu0bf1b1d2f986925642d684d489b02f8e_67735_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu0bf1b1d2f986925642d684d489b02f8e_67735_f6cb08f427bd8f34c7bfc79238e93df0.webp&#34;
               width=&#34;575&#34;
               height=&#34;421&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      按HTTP请求的ULR进行路由
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;按http请求的host进行路由&#34;&gt;按HTTP请求的Host进行路由&lt;/h3&gt;
&lt;p&gt;同一个IP进来的流量可以根据HTTP请求的Host路由到Cluster中的不同服务，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-按http请求的host进行路由&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;按HTTP请求的Host进行路由&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu5e105bf886f0eb1c393c0a2d9fac8ee7_67380_ed58a288ea2fa9499f1b0b1604e5436d.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu5e105bf886f0eb1c393c0a2d9fac8ee7_67380_261281a773fb889597c435ac2a64c6b9.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu5e105bf886f0eb1c393c0a2d9fac8ee7_67380_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu5e105bf886f0eb1c393c0a2d9fac8ee7_67380_ed58a288ea2fa9499f1b0b1604e5436d.webp&#34;
               width=&#34;572&#34;
               height=&#34;442&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      按HTTP请求的Host进行路由
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Ingress 规则定义了对七层网关的要求，包括URL分发规则，基于不同域名的虚拟主机，SSL证书等。Kubernetes使用Ingress Controller 来监控Ingress规则，并通过一个七层网关来实现这些要求，一般可以使用Nginx，HAProxy，Envoy等。&lt;/p&gt;
&lt;p&gt;虽然Ingress Controller通过七层网关为后端的多个Service提供了统一的入口，但由于其部署在集群中，因此并不能直接对外提供服务。实际上Ingress需要配合NodePort和LoadBalancer才能提供对外的流量入口，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用ingress-nodeportal和loadbalancer提供外部流量入口的拓扑结构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用Ingress, NodePortal和LoadBalancer提供外部流量入口的拓扑结构&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_huf359bd6ffc0630443f4803d51ab69f67_124888_727fd39cfd5efeda4d39ebf0a26df55a.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_huf359bd6ffc0630443f4803d51ab69f67_124888_c8fc00eb41acd10570c25f0ba86bb514.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_huf359bd6ffc0630443f4803d51ab69f67_124888_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_huf359bd6ffc0630443f4803d51ab69f67_124888_727fd39cfd5efeda4d39ebf0a26df55a.webp&#34;
               width=&#34;760&#34;
               height=&#34;580&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用Ingress, NodePortal和LoadBalancer提供外部流量入口的拓扑结构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上图描述了如何采用Ingress配合NodePort和Load Balancer为集群提供外部流量入口，从该拓扑图中可以看到该架构的伸缩性非常好，在NodePort，Ingress，Pod等不同的接入层面都可以对系统进行水平扩展，以应对不同的外部流量要求。&lt;/p&gt;
&lt;p&gt;上图只展示了逻辑架构，下面的图展示了具体的实现原理：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用ingress-nodeportal和loadbalancer提供外部流量入口的实现原理&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用Ingress, NodePortal和LoadBalancer提供外部流量入口的实现原理&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu4535170da61800f13d65ecbf23400376_133379_5a63790dab6a94e405ff4a1c1db8f668.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu4535170da61800f13d65ecbf23400376_133379_7e9bffcc8deb5a0e4ead361a750fcf38.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu4535170da61800f13d65ecbf23400376_133379_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu4535170da61800f13d65ecbf23400376_133379_5a63790dab6a94e405ff4a1c1db8f668.webp&#34;
               width=&#34;518&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用Ingress, NodePortal和LoadBalancer提供外部流量入口的实现原理
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;流量从外部网络到达Pod的完整路径如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;外部请求先通过四层Load Balancer进入内部网络&lt;/li&gt;
&lt;li&gt;Load Balancer将流量分发到后端多个主机节点上的NodePort (userspace转发)&lt;/li&gt;
&lt;li&gt;请求从NodePort进入到Ingress Controller (iptabes规则，Ingress Controller本身是一个NodePort类型的Service)&lt;/li&gt;
&lt;li&gt;Ingress Controller根据Ingress rule进行七层分发，根据HTTP的URL和Host将请求分发给不同的Service (userspace转发)&lt;/li&gt;
&lt;li&gt;Service将请求最终导入到后端提供服务的Pod中 (iptabes规则)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从前面的介绍可以看到，K8S Ingress提供了一个基础的七层网关功能的抽象定义，其作用是对外提供一个七层服务的统一入口，并根据URL/HOST将请求路由到集群内部不同的服务上。&lt;/p&gt;
&lt;h1 id=&#34;如何为服务网格选择入口网关&#34;&gt;如何为服务网格选择入口网关？&lt;/h1&gt;
&lt;p&gt;在Istio服务网格中，通过为每个Service部署一个sidecar代理，Istio接管了Service之间的请求流量。控制面可以对网格中的所有sidecar代理进行统一配置，实现了对网格内部流量的路由控制，从而可以实现灰度发布，流量镜像，故障注入等服务管控功能。但是，Istio并没有为入口网关提供一个较为完善的解决方案。&lt;/p&gt;
&lt;h2 id=&#34;k8s-ingress&#34;&gt;K8s Ingress&lt;/h2&gt;
&lt;p&gt;在0.8版本以前，Istio缺省采用K8s Ingress来作为Service Mesh的流量入口。K8s Ingress统一了应用的流量入口，但存在两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;K8s Ingress是独立在Istio体系之外的，需要单独采用Ingress rule进行配置，导致系统入口和内部存在两套互相独立的路由规则配置，运维和管理较为复杂。&lt;/li&gt;
&lt;li&gt;K8s Ingress rule的功能较弱，不能在入口处实现和网格内部类似的路由规则，也不具备网格sidecar的其它能力，导致难以从整体上为应用系统实现灰度发布、分布式跟踪等服务管控功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用kubernetes-ingress作为服务网格的流量入口&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用Kubernetes Ingress作为服务网格的流量入口&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_hubc2aba9431228d923fffdab87b3c9d23_72021_d5c3c8e21cf3b0e70f22460315c6ac1a.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_hubc2aba9431228d923fffdab87b3c9d23_72021_5d9189928ea684c48392160404ffeade.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_hubc2aba9431228d923fffdab87b3c9d23_72021_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_hubc2aba9431228d923fffdab87b3c9d23_72021_d5c3c8e21cf3b0e70f22460315c6ac1a.webp&#34;
               width=&#34;760&#34;
               height=&#34;346&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用Kubernetes Ingress作为服务网格的流量入口
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;istio-gateway&#34;&gt;Istio Gateway&lt;/h2&gt;
&lt;p&gt;Istio社区意识到了Ingress和Mesh内部配置割裂的问题，因此从0.8版本开始，社区采用了 Gateway 资源代替K8s Ingress来表示流量入口。&lt;/p&gt;
&lt;p&gt;Istio Gateway资源本身只能配置L4-L6的功能，例如暴露的端口，TLS设置等；但Gateway可以和绑定一个VirtualService，在VirtualService 中可以配置七层路由规则，这些七层路由规则包括根据按照服务版本对请求进行导流，故障注入，HTTP重定向，HTTP重写等所有Mesh内部支持的路由规则。&lt;/p&gt;
&lt;p&gt;Gateway和VirtualService用于表示Istio Ingress的配置模型，Istio Ingress的缺省实现则采用了和Sidecar相同的Envoy proxy。&lt;/p&gt;
&lt;p&gt;通过该方式，Istio控制面用一致的配置模型同时控制了入口网关和内部的sidecar代理。这些配置包括路由规则，策略检查、Telementry收集以及其他服务管控功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用-istio-ingress-gateway作为服务网格的流量入口&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用 Istio Ingress Gateway作为服务网格的流量入口&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu39d55e73a319f81f74377a388a98b6d1_95311_711aeb1be0ab812cf7a26533d9eee35d.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu39d55e73a319f81f74377a388a98b6d1_95311_d7a398ea58d5e260fae61ca30efcde12.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu39d55e73a319f81f74377a388a98b6d1_95311_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu39d55e73a319f81f74377a388a98b6d1_95311_711aeb1be0ab812cf7a26533d9eee35d.webp&#34;
               width=&#34;737&#34;
               height=&#34;443&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用 Istio Ingress Gateway作为服务网格的流量入口
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;应用对api-gateway的需求&#34;&gt;应用对API Gateway的需求&lt;/h2&gt;
&lt;p&gt;采用Gateway和VirtualService实现的Istio Ingress Gateway提供了网络入口处的基础通信功能，包括可靠的通信和灵活的路由规则。但对于一个服务化应用来说，网络入口除了基础的通讯功能之外，还有一些其他的应用层功能需求，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三方系统对API的访问控制&lt;/li&gt;
&lt;li&gt;用户对系统的访问控制&lt;/li&gt;
&lt;li&gt;修改请求/返回数据&lt;/li&gt;
&lt;li&gt;服务API的生命周期管理&lt;/li&gt;
&lt;li&gt;服务访问的SLA、限流及计费&lt;/li&gt;
&lt;li&gt;….&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kubernetes-ingress-istio-gateway-and-api-gateway的功能对比&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kubernetes ingress, Istio gateway and API gateway的功能对比&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu764b17e734bab8fed08e1cda54902d8f_204376_178de5a1eb415d849fdf76625ad5d50d.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu764b17e734bab8fed08e1cda54902d8f_204376_01aac67f9e108c35276843178888b59d.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu764b17e734bab8fed08e1cda54902d8f_204376_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu764b17e734bab8fed08e1cda54902d8f_204376_178de5a1eb415d849fdf76625ad5d50d.webp&#34;
               width=&#34;760&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kubernetes ingress, Istio gateway and API gateway的功能对比
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;API Gateway需求中很大一部分需要根据不同的应用系统进行定制，目前看来暂时不大可能被纳入K8s Ingress或者Istio Gateway的规范之中。为了满足这些需求，涌现出了各类不同的k8s Ingress Controller以及Istio Ingress Gateway实现，包括Ambassador、Kong、 Traefik、Solo等。&lt;/p&gt;
&lt;p&gt;这些网关产品在实现在提供基础的K8s Ingress能力的同时，提供了强大的API Gateway功能，但由于缺少统一的标准，这些扩展实现之间相互之间并不兼容。而且遗憾的是，目前这些Ingress controller都还没有正式提供和Istio 控制面集成的能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ambassador将对Istio路由规则的支持纳入了Roadmap &lt;a href=&#34;https://www.getambassador.io/user-guide/with-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.getambassador.io/user-guide/with-istio/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Istio声称支持Istio-Based Route Rule Discovery (尚处于实验阶段) &lt;a href=&#34;https://gloo.solo.io/introduction/architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://gloo.solo.io/introduction/architecture/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;采用api-gateway--sidecar-proxy作为服务网格的流量入口&#34;&gt;采用API Gateway + Sidecar Proxy作为服务网格的流量入口&lt;/h2&gt;
&lt;p&gt;在目前难以找到一个同时具备API Gateway和Istio Ingress能力的网关的情况下，一个可行的方案是使用API Gateway和Sidecar Proxy一起为服务网格提供外部流量入口。&lt;/p&gt;
&lt;p&gt;由于API Gateway已经具备七层网关的功能，Mesh Ingress中的Sidecar只需要提供VirtualService资源的路由能力，并不需要提供Gateway资源的网关能力，因此采用Sidecar Proxy即可。网络入口处的Sidecar Proxy和网格内部应用Pod中Sidecar Proxy的唯一一点区别是：该Sidecar只接管API Gateway向Mesh内部的流量，并不接管外部流向API Gateway的流量；而应用Pod中的Sidecar需要接管进入应用的所有流量。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用api-gateway--sidecar-proxy为服务网格提供流量入口&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用API Gateway &amp;#43; Sidecar Proxy为服务网格提供流量入口&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu46b796a40221c3a084a48e1733e26d44_109547_da9dbac348bc0a5a4838f5bd9c5e20d6.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu46b796a40221c3a084a48e1733e26d44_109547_e60e3959167108abc36feb709f2c4219.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu46b796a40221c3a084a48e1733e26d44_109547_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu46b796a40221c3a084a48e1733e26d44_109547_da9dbac348bc0a5a4838f5bd9c5e20d6.webp&#34;
               width=&#34;760&#34;
               height=&#34;383&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用API Gateway &amp;#43; Sidecar Proxy为服务网格提供流量入口
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：在实际部署时，API Gateway前端需要采用NodePort和LoadBalancer提供外部流量入口。为了突出主题，对上图进行了简化，没有画出NodePort和LoadBalancer。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;采用API Gateway和Sidecar Proxy一起作为服务网格的流量入口，既能够通过对网关进行定制开发满足产品对API网关的各种需求，又可以在网络入口处利用服务网格提供的灵活的路由能力和分布式跟踪，策略等管控功能，是服务网格产品入口网关的一个理想方案。&lt;/p&gt;
&lt;p&gt;性能方面的考虑：从上图可以看到，采用该方案后，外部请求的处理流程在入口处增加了Sidecar Proxy这一跳，因此该方式会带来少量的性能损失，但该损失是完全可以接受的。&lt;/p&gt;
&lt;p&gt;对于请求时延而言，在服务网格中，一个外部请求本来就要经过较多的代理和应用进程的处理，在Ingress处增加一个代理对整体的时延影响基本忽略不计，而且对于绝大多数应用来说，网络转发所占的时间比例本来就很小，99%的耗时都在业务逻辑。如果系统对于增加的该时延非常敏感，则建议重新考虑该系统是否需要采用微服务架构和服务网格。&lt;/p&gt;
&lt;p&gt;对于吞吐量而言，如果入口处的网络吞吐量存在瓶颈，则可以通过对API Gateway + Sidecar Proxy组成的Ingress整体进行水平扩展，来对入口流量进行负荷分担，以提高网格入口的网络吞吐量。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&#34;ref01&#34;&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Virtual IPs and Service Proxie - kubernetes.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhaohuabing.com/2017/11/28/access-application-from-outside/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如何从外部访问Kubernetes集群中的应用？ - zhaohuabing.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhaohuabing.com/post/2018-12-27-the-obstacles-to-put-istio-into-production/#service-mesh-and-api-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The obstacles to put Istio into production and how we solve them - kubernetes.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes NodePort vs LoadBalancer vs Ingress? When should I use what? - medium.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway的身份认同危机</title>
      <link>https://cloudnative.to/blog/api-gateways-are-going-through-an-identity-crisis/</link>
      <pubDate>Mon, 13 May 2019 20:08:37 +0800</pubDate>
      <guid>https://cloudnative.to/blog/api-gateways-are-going-through-an-identity-crisis/</guid>
      <description>&lt;p&gt;如今，API网关经历了一系列&lt;a href=&#34;https://en.wikipedia.org/wiki/Identity_crisis&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;身份认同危机&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们是集中式共享资源，有助于将API暴露和维护到外部实体吗？&lt;/li&gt;
&lt;li&gt;它们是否为集群的ingress哨兵，严格控制用户流量在集群的进出？&lt;/li&gt;
&lt;li&gt;或它们是否为某类API的集成，以便更简洁地表达API，具体取决于它所具有的客户端类型？&lt;/li&gt;
&lt;li&gt;当然还有不愿多谈但我经常听到的一个问题：&amp;ldquo;服务网格是否会使API网关过时？&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;有关背景&#34;&gt;有关背景&lt;/h2&gt;
&lt;p&gt;随着技术的快速发展，以及行业在技术和架构模式中的快速发展，你会想到&amp;quot;这一切都让我头晕目眩&amp;quot;。在这篇文章中，我希望简化&amp;quot;API网关&amp;quot;的不同身份，澄清组织中哪些组可能使用API网关（他们试图解决的问题），并重新关注第一原则。理想情况下，在本文结束时，您将更好地了解不同团队在不同层面的API架构的作用，以及如何从每个层面中获取最大价值。&lt;/p&gt;
&lt;p&gt;在我们深入研究之前，让我们对API这个术语非常清楚。&lt;/p&gt;
&lt;h2 id=&#34;我对api的定义&#34;&gt;我对API的定义：&lt;/h2&gt;
&lt;p&gt;一种明确且有目的地定义的接口，旨在通过网络调用，使软件开发人员能够以受控且舒适的方式对组织内的数据和功能进行编程访问。&lt;/p&gt;
&lt;p&gt;这些接口抽象了实现它们的技术基础结构的细节。对于这些设计好的端点，我们期望能有些一定程度的文档，例如使用指南，稳定性报告和向后兼容性。&lt;/p&gt;
&lt;p&gt;相反，仅仅因为我们可以通过网络与另一个软件通信并不一定意味着远程端点是这个定义好的API。许多系统彼此通信，往往这种通信更加随意地发生，并且通过耦合和其他因素进行实时交互。&lt;/p&gt;
&lt;p&gt;我们创建API以提供对业务部分的深思熟虑的抽象，并实现新的业务功能以及偶发创新。&lt;/p&gt;
&lt;p&gt;在讨论API网关时首先列出的是API管理。&lt;/p&gt;
&lt;h2 id=&#34;api管理&#34;&gt;API管理&lt;/h2&gt;
&lt;p&gt;很多人都在API管理方面考虑API网关。这是合理的。但是让我们快速了解一下API网关到底是做什么的。&lt;/p&gt;
&lt;p&gt;通过&lt;a href=&#34;https://en.wikipedia.org/wiki/API_management&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Management&lt;/a&gt;，我们希望解决：当我们希望公开现有API以供其他人使用时，如何跟踪谁使用这些API，实施允许谁使用这些API的策略，建立安全流以进行身份​​验证和授权允许，使用并构建可在设计时使用的服务目录，以促进API使用并为有效治理奠定基础。&lt;/p&gt;
&lt;p&gt;我们希望解决：现有的，规划好的API，我们希望按照我们的条款分享给他人的问题。&lt;/p&gt;
&lt;p&gt;API管理还可以很好地允许用户（潜在API消费者）自助服务，注册不同的API消费计划（想一想：指定价格点在给定时间范围内每个端点的每个用户的呼叫数）。我们能够实施这些管理功能的基础设施是我们的API流量通过的网关。在这一点上，我们可以执行诸如身份认证，流量限速，指标采集，以及其他策略执行操作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-management-sketch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;利用API网关的API管理软件示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://apigee.com/api-management/#/homepage&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Apigee&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.3scale.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat 3Scale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mulesoft.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mulesoft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://konghq.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个层面上，我们考虑API（如上所述）以及如何最好地管理和允许访问它们。我们没有考虑服务器，主机，端口，容器甚至服务（另一个定义不明确的词，但你理解我的！）。&lt;/p&gt;
&lt;p&gt;API管理（以及它们相应的网关）通常实现为由&amp;quot;平台团队&amp;quot;，&amp;ldquo;集成团队&amp;quot;或其他API基础架构团队拥有的严格控制的共享基础架构。通常这样做是为了强制执行一定程度的治理，变更管理和策略。在某些情况下，即使这些基础架构集中部署和管理，它们也可能支持更分散的物理部署。例如，Kong的首席技术官Marco Palladino在评论中指出，Kong可以选择部署的组件来支持集中式或分布式模型。&lt;/p&gt;
&lt;p&gt;有一点需要注意：我们要注意不要让任何业务逻辑进入这一层。如前一段所述，API管理是共享基础架构，但由于我们的API流量通过它，它倾向于重造&amp;quot;全知全能&amp;rdquo;（思考企业服务总线）治理门户，为通过它，我们必须全盘改造我们的服务。理论上这听起来很棒。实际上，这可能最终成为组织瓶颈。有关更多信息，请参阅此文章：&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Network Functions with ESBs, API Management, and Now… Service Mesh?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;集群入口&#34;&gt;集群入口&lt;/h2&gt;
&lt;p&gt;为了构建和实现API，我们专注于代码，数据，业务框架等方面。但是，要让这些的东西提供价值，必须对它们进行测试，部署到生产环境中并进行监控。当我们开始部署到云原生平台时，我们开始基于部署，容器，服务，主机，端口等考虑，以便构建我们的应用程序适应该环境。我们大概还需要制作工作流程（CI）和管道（CD），以利用云平台快速迭代，将其提供给客户等。&lt;/p&gt;
&lt;p&gt;在这种环境中，我们可以构建和维护多个集群来托管我们的应用程序，并需要某种方式来访问这些集群内的应用程序和服务。以Kubernetes为例。我们可以使用&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Ingress controller&lt;/a&gt;来允许访问Kubernetes集群（集群中的其他所有内容都无法从外部访问）。通过这种方式，我们可以非常严格地控制流量可能进入（甚至离开）我们的集群，具有明确定义的入口点，如域名/虚拟hosts，端口，协议等。&lt;/p&gt;
&lt;p&gt;在这个层面中，我们可能希望某种&amp;quot;&lt;a href=&#34;https://istio.io/docs/tasks/traffic-management/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ingress gateway&lt;/a&gt;&amp;ldquo;成为允许请求和消息进入集群的流量哨兵。在这个层面中，你需要更多考虑的是：&amp;ldquo;我在我的集​​群中有这项服务，我需要集群外部的人能够调用它&amp;rdquo;。这可能是一个服务（暴露API），一个系统整体，一个gRPC服务，一个缓存，一个消息队列，一个数据库等。有些人选择将其称为API网关，其中的一些可能实际上做得比流量入口/出口更多，但重点是问题存在于集群级操作上。由于我们倾向于部署更多集群（相对于单个高度多租户集群），我们最终会有更多网络入口点和彼此交互的需求。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/cluster-ingress-sketch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些类型的入口实现的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Envoy Proxy and projects that build upon it including：
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.getambassador.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Datawire Ambassador&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io Gloo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/heptio/contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heptio Contour&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HAProxy
&lt;ul&gt;
&lt;li&gt;Including &lt;a href=&#34;https://docs.openshift.com/container-platform/3.9/install_config/router/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenShift’s Router&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/ingress-nginx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NGINX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://traefik.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Kong/kubernetes-ingress-controller&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此层面的集群入口控制器由平台团队管理，但是这个基础架构通常与更分散的自助服务工作流程相关联（正如您期望从云原生平台那样）。请参阅&lt;a href=&#34;https://www.weave.works/blog/gitops-operations-by-pull-request&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;See the &amp;ldquo;GitOps&amp;rdquo; workflow as described by the good folks at Weaveworks&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;api-gateway模式&#34;&gt;API Gateway模式&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;API网关&amp;quot;这一术语的另一重意思才是我最开始理解的，即它是最接近API Gateway模式的那个。 &lt;a href=&#34;https://www.chrisrichardson.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chris Richardson&lt;/a&gt;在第8章的&amp;rdquo;&amp;quot;&lt;a href=&#34;https://microservices.io/book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务设计模式&lt;/a&gt;&amp;ldquo;&amp;ldquo;一书中做了很好的工作。我强烈建议将该书用作本文和其他微服务模式的教学。在他的&lt;a href=&#34;https://microservices.io/patterns/apigateway.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;microservices.io&lt;/a&gt;网站可以上略扫一下即可知，API Gateway模式，简而言之，是关于策划API以便更好地使用不同类别的消费者。此策略涉及API间接级别。您可能听到的代表API Gateway模式的另一个术语是&amp;quot;服务于前端的后端&amp;rdquo;，其中&amp;quot;前端&amp;quot;可以是单纯前端界面（UI），移动客户端，物联网客户端，甚至是其他服务/应用开发人员。&lt;/p&gt;
&lt;p&gt;在API Gateway模式中，我们明确简化了一组API的调用，以模拟特定用户，客户或消费者的&amp;quot;应用程序&amp;quot;的内聚API。回想一下，当我们使用微服务来构建我们的系统时，&amp;ldquo;应用程序&amp;quot;的概念就会消失。 API Gateway模式有助于重塑此概念。这里的关键在于API网关，当它实现时，它成为客户端和应用程序的API，并负责与任何后端API和其他应用程序网络端点（那些不符合上述API定义的端点）进行通信。&lt;/p&gt;
&lt;p&gt;与上一节中的Ingress控制器不同，此API网关更接近于开发人员的全局视图，并且不太关注为集群外消耗而暴露的端口或服务。这个&amp;quot;API Gateway&amp;quot;也不同于我们对已有API的进行管理所用的API管理观念。这个API网关掩盖了对可能暴露API的后端的调用，但是也可能会谈到较少描述为API的事情，例如对旧系统的RPC调用，使用不符合&amp;quot;REST&amp;quot;式优雅的协议调用，例如JSON over HTTP，gRPC，SOAP，GraphQL，websockets和消息队列这些黑科技。还可以调用这种类型的网关来进行消息级转换，复杂路由，网络负载均衡/回调以及响应的集成。&lt;/p&gt;
&lt;p&gt;如果您熟悉&lt;a href=&#34;https://www.crummy.com/writing/speaking/2008-QCon/act3.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Richardson的REST API的成熟度模型&lt;/a&gt;，那么实现API Gateway模式的API网关会被要求集成更多的Level 0请求（以及介于两者之间的所有内容）而不是Level 1-3实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/richardson-model.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://martinfowler.com/articles/richardsonMaturityModel.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://martinfowler.com/articles/richardsonMaturityModel.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这些类型的网关实现仍然需要解决诸如速率限制，认证/授权，熔断，指标采集，流量路由等一类的事情。 这些类型的网关可以在集群的边缘用作集群入口控制器，也可以在集群的深处用作应用程序网关。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-gateway-pattern.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此类API网关的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://spring.io/projects/spring-cloud-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud Gateway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io Gloo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Netflix/zuul&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix Zuul&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://strongloop.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM-Strongloop Loopback/Microgateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种类型的网关也可以使用更通用的编程或集成语言/框架来构建，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache Camel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io/projects/spring-integration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Integration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ballerina.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ballerina.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://vertx.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Eclipse Vert.x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/en/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NodeJS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于这种类型的API网关与应用程序和服务的开发密切相关，我们希望开发人员能够参与、帮助指定API网关公开的API，了解所涉及的任何mashup逻辑以及需要能够快速测试和更改此API基础结构。我们还希望操作或SRE对API网关的安全性，弹性和可观察性配置有一些看法。此级别的基础架构还必须适应不断发展的按需自助服务开发人员工作流程。再次参见GitOps模型以获取更多信息。&lt;/p&gt;
&lt;h2 id=&#34;谈到服务网格&#34;&gt;谈到服务网格&lt;/h2&gt;
&lt;p&gt;在云基础架构上运行服务架构的一部分包括难以在网络中构建适当级别的可观察性和控制。在解决此问题的先前迭代中，&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们使用应用程序库和有希望的开发人员治理来实现此目的&lt;/a&gt;。然而，在规模和多语言环境中，&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格技术的出现提供了更好的解决方案&lt;/a&gt;。服务网格通过透明实现为平台及其组成服务带来以下功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务到服务（即东西流量）的恢复能力&lt;/li&gt;
&lt;li&gt;安全性包括最终用户验证，双向TLS，服务到服务RBAC / ABAC&lt;/li&gt;
&lt;li&gt;黑盒服务可观察性（专注于网络通信），用于请求/秒，请求延迟，请求失败，熔断事件，分布式跟踪等&lt;/li&gt;
&lt;li&gt;服务到服务速率限制，配额执行等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;精明的读者会认识到，&lt;a href=&#34;https://dzone.com/articles/api-gateway-vs-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API网关和服务网格的功能似乎有些重叠&lt;/a&gt;。服务网格的目标是通过在L7上透明地解决任何服务/应用程序来解决这些问题。换句话说，服务网格希望融入服务（实际上没有被编码到服务的代码中）。另一方面，API网关位于服务网格和应用程序之上（L8？）。服务网格为服务，主机，端口，协议等（东/西流量）之间的请求流带来价值。它们还可以提供基本的集群入口功能，以便为北/南流量带来一些此功能。但是，这不应与API网关可以为南北向流量带来的功能相混淆（如在集群的北/南和向应用程序或应用程序组的北/南）。&lt;/p&gt;
&lt;p&gt;服务网格和API网关在某些领域的功能上重叠，但它们是互补的，因为它们生活在不同的层次并解决不同的问题。理想的解决方案是将每个组件（API Management，API Gateway，Service Mesh）即插即用，并在需要时在组件之间保持良好的界限（或者在不需要它们时将其排除）。同样重要的是找到&lt;a href=&#34;https://developer.ibm.com/apiconnect/2018/12/10/api-management-centralized-or-decentralized/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;适合您的分散开发人员和操作工作流程&lt;/a&gt;的这些工具的实现。尽管这些不同组成部分的术语和身份存在混淆，但我们应该依赖于第一原则并理解我们的架构中这些组件在何处带来价值以及它们如何独立存在并共存互补性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-layers.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;我们很乐意帮忙&#34;&gt;我们很乐意帮忙！&lt;/h2&gt;
&lt;p&gt;一些读者可能知道我热衷于帮助人们，特别是在云，微服务，事件驱动架构和服务网络领域。 在我的公司,&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;，我们正在帮助IT组织认识并成功采用适当级别的网关和服务网格等API技术，以及他们成功优化它们的速度（更重要的是，他们确实需要这些技术！！）。 我们在&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Proxy&lt;/a&gt;，&lt;a href=&#34;https://graphql.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GraphQL&lt;/a&gt;和&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;等技术的基础上构建了&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;，&lt;a href=&#34;https://sqoop.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Scoop&lt;/a&gt;和&lt;a href=&#34;https://supergloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SuperGloo&lt;/a&gt;等工具，以帮助实现API网关和服务网格管理。 请直接联系我们（&lt;a href=&#34;https://twitter.com/soloio_inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@soloio_inc&lt;/a&gt;，&lt;a href=&#34;http://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http：//solo.io&lt;/a&gt;）或直接与我联系（&lt;a href=&#34;http://www.twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt;，&lt;a href=&#34;http://blog.christianposta.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;），深入了解我们的愿景以及我们的技术如何为您的组织提供帮助。 在下一系列博客中，我们将深入探讨API Gateway模式，多集群场景的难点，多服务网格的难点等！ 敬请关注！&lt;/p&gt;
&lt;h2 id=&#34;相关阅读&#34;&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
