<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>api gateway | 云原生社区（中国）</title>
    <link>https://cloudnative.to/tag/api-gateway/</link>
      <atom:link href="https://cloudnative.to/tag/api-gateway/index.xml" rel="self" type="application/rss+xml" />
    <description>api gateway</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Wed, 30 Aug 2023 12:03:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>api gateway</title>
      <link>https://cloudnative.to/tag/api-gateway/</link>
    </image>
    
    <item>
      <title>Gateway API v0.8.0: 引入服务网格支持</title>
      <link>https://cloudnative.to/blog/gateway-api-release/</link>
      <pubDate>Wed, 30 Aug 2023 12:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/gateway-api-release/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://kubernetes.io/blog/2023/08/29/gateway-api-v0-8/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubernetes.io/blog/2023/08/29/gateway-api-v0-8/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;作者：&lt;/strong&gt;&lt;/em&gt; Flynn（Buoyant）、John Howard（Google）、Keith Mattix（Microsoft）、Michael Beaumont（Kong）、Mike Morris（独立）、Rob Scott（Google）&lt;/p&gt;
&lt;p&gt;我们非常高兴地宣布 Gateway API 的 v0.8.0 版本发布了！通过此版本，Gateway API 对服务网格的支持已达到&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/overview/#status&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;实验性状态&lt;/a&gt;。我们期待您的反馈！&lt;/p&gt;
&lt;p&gt;我们特别高兴地宣布，Kuma 2.3+、Linkerd 2.14+ 和 Istio 1.16+ 都是 Gateway API 服务网格支持的完全符合实现。&lt;/p&gt;
&lt;h2 id=&#34;gateway-api-中的服务网格支持&#34;&gt;Gateway API 中的服务网格支持&lt;/h2&gt;
&lt;p&gt;虽然 Gateway API 最初的重点一直是入口（南北）流量，但很快就清楚，相同的基本路由概念也应适用于服务网格（东西）流量。2022 年，Gateway API 子项目启动了&lt;a href=&#34;https://gateway-api.sigs.k8s.io/concepts/gamma/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GAMMA 计划&lt;/a&gt;，这是一个专门的供应商中立工作流，旨在特别研究如何最好地将服务网格支持纳入 Gateway API 资源的框架中，而不需要 Gateway API 的用户重新学习他们了解的有关 API 的一切。&lt;/p&gt;
&lt;p&gt;在过去的一年中，GAMMA 深入研究了使用 Gateway API 用于服务网格的挑战和可能的解决方案。最终结果是少量的&lt;a href=&#34;https://gateway-api.sigs.k8s.io/contributing/enhancement-requests/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;增强提案&lt;/a&gt;，涵盖了许多小时的思考和辩论，并提供了一条最小可行路径，允许使用 Gateway API 用于服务网格。&lt;/p&gt;
&lt;h3 id=&#34;当使用-gateway-api-时网格路由将如何工作&#34;&gt;当使用 Gateway API 时，网格路由将如何工作？&lt;/h3&gt;
&lt;p&gt;您可以在&lt;a href=&#34;https://gateway-api.sigs.k8s.io/concepts/gamma/#how-the-gateway-api-works-for-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway API 网格路由文档&lt;/a&gt;和&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1426/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1426&lt;/a&gt;中找到所有详细信息，但对于 Gateway API v0.8.0，简短的版本是，现在 HTTPRoute 可以有一个“parentRef”，它是一个服务，而不仅仅是一个网关。我们预计在这个领域使用更多 GEP，因为随着我们对服务网格用例的经验不断增加，绑定到服务使得使用 Gateway API 与服务网格成为可能，但仍有几个有趣的用例难以涵盖。&lt;/p&gt;
&lt;p&gt;例如，您可以使用 HTTPRoute 在网格中进行 A-B 测试，如下所示：&lt;/p&gt;
&lt;p&gt;任何具有标头 &lt;code&gt;env: v1&lt;/code&gt; 的 &lt;code&gt;demo-app&lt;/code&gt; 服务的端口 5000 的请求都将路由到 &lt;code&gt;demo-app-v1&lt;/code&gt;，而没有该标头的请求都将路由到 &lt;code&gt;demo-app-v2&lt;/code&gt; - 并且由于这是由服务网格处理而不是入口控制器，因此 A/B 测试可以发生在应用程序的调用图中的任何位置。&lt;/p&gt;
&lt;p&gt;如何知道这将是真正的可移植性？&lt;/p&gt;
&lt;p&gt;Gateway API 在支持的所有功能上都在持续投资一致性测试，网格也不例外。GAMMA 面临的其中一个挑战是，许多这些测试都与一个给定实现提供入口控制器的想法密切相关。许多服务网格不提供入口控制器，要求符合 GAMMA 标准的网格同时实现入口控制器似乎并不切实际。这导致在 Gateway API &lt;em&gt;一致性配置文件&lt;/em&gt;上重新开始工作，如&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1709/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1709&lt;/a&gt;所讨论的那样。&lt;/p&gt;
&lt;p&gt;一致性配置文件的基本思想是，我们可以定义 Gateway API 的子集，并允许实现选择（并记录）他们符合哪些子集。GAMMA 正在添加一个名为“Mesh”的新配置文件，描述在&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1686/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1686&lt;/a&gt;中，仅检查由 GAMMA 定义的网格功能。此时，Kuma 2.3+、Linkerd 2.14+ 和 Istio 1.16+ 都符合“Mesh”配置文件的标准。&lt;/p&gt;
&lt;h2 id=&#34;gateway-api-v080-中还有什么&#34;&gt;Gateway API v0.8.0 中还有什么？&lt;/h2&gt;
&lt;p&gt;这个版本的发布是关于为即将到来的 v1.0 版本做准备，其中 HTTPRoute、Gateway 和 GatewayClass 将毕业为 GA。与此相关的有两个主要更改：CEL 验证和 API 版本更改。&lt;/p&gt;
&lt;h3 id=&#34;cel-验证&#34;&gt;CEL 验证&lt;/h3&gt;
&lt;p&gt;第一个重大变化是，Gateway API v0.8.0 是从 webhook 验证向使用内置于 CRD 中的信息的&lt;a href=&#34;https://kubernetes.io/docs/reference/using-api/cel/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CEL 验证&lt;/a&gt;的转换的开端。这将根据您使用的 Kubernetes 版本而有所不同：&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-125&#34;&gt;Kubernetes 1.25+&lt;/h3&gt;
&lt;p&gt;CEL 验证得到了完全支持，并且几乎所有验证都是在 CEL 中实现的。（唯一的例外是，标头修饰符过滤器中的标头名称只能进行不区分大小写的验证。有关更多信息，请参见&lt;a href=&#34;https://github.com/kubernetes-sigs/gateway-api/issues/2277&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;issue 2277&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;我们建议在这些 Kubernetes 版本上&lt;em&gt;不&lt;/em&gt;使用验证 Webhook。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-123-和-124&#34;&gt;Kubernetes 1.23 和 1.24&lt;/h3&gt;
&lt;p&gt;CEL 验证不受支持，但是 Gateway API v0.8.0 CRD 仍然可以安装。当您升级到 Kubernetes 1.25+ 时，这些 CRD 中包含的验证将自动生效。&lt;/p&gt;
&lt;p&gt;我们建议在这些 Kubernetes 版本上继续使用验证 Webhook。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-122-和更早版本&#34;&gt;Kubernetes 1.22 和更早版本&lt;/h3&gt;
&lt;p&gt;Gateway API 只承诺支持&lt;a href=&#34;https://gateway-api.sigs.k8s.io/concepts/versioning/#supported-versions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最新的 5 个 Kubernetes 版本&lt;/a&gt;。因此，这些版本不再受 Gateway API 的支持，不幸的是，Gateway API v0.8.0 不能在它们上安装，因为包含 CEL 验证的 CRD 将被拒绝。&lt;/p&gt;
&lt;h3 id=&#34;api-版本更改&#34;&gt;API 版本更改&lt;/h3&gt;
&lt;p&gt;随着我们为将 Gateway、GatewayClass 和 HTTPRoute 毕业到 &lt;code&gt;v1&lt;/code&gt; API 版本从 &lt;code&gt;v1beta1&lt;/code&gt; 做准备的过程中，我们继续减少了已毕业到 &lt;code&gt;v1beta1&lt;/code&gt; 的资源的 &lt;code&gt;v1alpha2&lt;/code&gt; 的使用。有关此更改以及此版本中包含的所有其他内容的更多信息，请参见&lt;a href=&#34;https://github.com/kubernetes-sigs/gateway-api/releases/tag/v0.8.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;v0.8.0 发布说明&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;如何开始使用-gateway-api&#34;&gt;如何开始使用 Gateway API？&lt;/h2&gt;
&lt;p&gt;Gateway API 代表了 Kubernetes 中负载平衡、路由和服务网格 API 的未来。已经有超过 20 个&lt;a href=&#34;https://gateway-api.sigs.k8s.io/implementations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;实现&lt;/a&gt;可用（包括入口控制器和服务网格），列表还在不断增长。&lt;/p&gt;
&lt;p&gt;如果您有兴趣开始使用 Gateway API，请查看&lt;a href=&#34;https://gateway-api.sigs.k8s.io/concepts/api-overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 概念文档&lt;/a&gt;，并查看一些&lt;a href=&#34;https://gateway-api.sigs.k8s.io/guides/getting-started/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;指南&lt;/a&gt;以尝试使用它。因为这是一个基于 CRD 的 API，所以您可以在任何 Kubernetes 1.23+ 集群上安装最新版本。&lt;/p&gt;
&lt;p&gt;如果您特别有兴趣帮助 Gateway API 做出贡献，我们将非常乐意接受！请随时在存储库上&lt;a href=&#34;https://github.com/kubernetes-sigs/gateway-api/issues/new/choose&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;打开新问题&lt;/a&gt;，或加入&lt;a href=&#34;https://github.com/kubernetes-sigs/gateway-api/discussions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;讨论&lt;/a&gt;。还请查看&lt;a href=&#34;https://gateway-api.sigs.k8s.io/contributing/community/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;社区页面&lt;/a&gt;，其中包括 Slack 频道和社区会议的链接。我们期待您的到来！&lt;/p&gt;
&lt;h2 id=&#34;更多阅读&#34;&gt;更多阅读：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1324/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1324&lt;/a&gt;提供了 GAMMA 目标和一些重要定义的概述。这个 GEP 值得一读，因为它讨论了问题空间。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1426/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1426&lt;/a&gt;定义了如何使用 Gateway API 路由资源（如 HTTPRoute）管理服务网格内的流量。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1686/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1686&lt;/a&gt;在&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1709/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1709&lt;/a&gt;的工作基础上，为声明符合 Gateway API 的服务网格定义了一个&lt;em&gt;一致性配置文件&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然这些都是&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/overview/#status&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;实验性&lt;/a&gt;模式，但请注意，它们可在 &lt;a href=&#34;https://gateway-api.sigs.k8s.io/concepts/versioning/#release-channels-eg-experimental-standard&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;standard&lt;/code&gt; 发布频道&lt;/a&gt;使用，因为 GAMMA 计划迄今为止不需要引入新的资源或字段。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>KrakenD API 网关更名为 Lura 项目并宣布加入了 Linux 基金会</title>
      <link>https://cloudnative.to/blog/krakend-api-gateway-joins-the-linux-foundation-as-the-lura-project/</link>
      <pubDate>Tue, 18 May 2021 12:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/krakend-api-gateway-joins-the-linux-foundation-as-the-lura-project/</guid>
      <description>&lt;h2 id=&#34;关于-lura-项目&#34;&gt;关于 Lura 项目&lt;/h2&gt;
&lt;p&gt;近日，&lt;a href=&#34;https://www.luraproject.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lura 项目&lt;/a&gt;，原名为 KrakenD 的开源框架，加入了 &lt;a href=&#34;https://training.linuxfoundation.org/training/course-catalog/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linux 基金会&lt;/a&gt;，根据一份新闻声明，“它将是唯一一个在中立、开放论坛中托管的企业级 API 网关”。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.krakend.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KrakenD API 网关&lt;/a&gt;的联合创始人兼首席执行官 &lt;a href=&#34;https://www.linkedin.com/in/alombarte/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Albert Lombarte&lt;/a&gt; 说，该项目现在每月活跃在 100 多万台服务器上。转到 Linux 基金会后，将技术放在了第一位，而不是企业公司的需求。&lt;/p&gt;
&lt;p&gt;“我们是真正的开源信徒，我们相信开源是这个项目的归宿，“Lombarte 说。“我们已经看到，技术与 API 网关玩得不好，所采取的做法不是技术的最佳做法，“而是为了营销或销售产品的需要，为了锁定客户。“而我们希望能解放这一点，“他指出。&lt;/p&gt;
&lt;p&gt;KrakenD API 网关建立在现在被称为 Lura 项目的基础上，Lombarte 解释说，KrakenD 是一个有主见的实现，即它注重速度而不是其他功能。Lura 是一个构建 API 网关的框架，可以根据企业的需求进行定制。它是为速度和可扩展性而设计的。Lombarte 说，Lura 用 Go 语言构建，是一个无状态、高性能的 API 网关框架，为云原生和内部设置而设计，无状态是一个区别点。&lt;/p&gt;
&lt;p&gt;“如果你采取传统的 API 网关，你会发现配置是存储在数据库上的。我们没有任何形式的数据库，所以所有的配置都在一个静态的配置文件中，“Lombarte 说。&amp;quot; &lt;strong&gt;如果你想改变网关的状态，你必须重新部署另一个版本的网关。它就像今天任何公司的任何微服务一样工作。这就是我们和有状态网关的主要区别。&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;此外，有状态网关的问题是可扩展性，Lombarte 说。“因为它们通常连接到一个数据库，而这个数据库是唯一的真实数据来源，所有的节点都需要协调。因此，如果你去找大客户，他们无法正常扩展，因为他们有一个瓶颈，那就是数据库。我们节点甚至不互相通信，所以它们可以线性地扩展到无限大。”&lt;/p&gt;
&lt;p&gt;Lura 的另一个区别点是，其 API 网关超越了传统的 API 网关，&lt;strong&gt;作为多个微服务的聚合器发挥作用，而不是简单地作为一个扩展的代理&lt;/strong&gt;。Lombarte 说，市场上的所有 API 网关都只是“中间有共享关注点的代理”，API 调用到达一个单一的后端服务。相反，Lura 允许聚集许多后端服务，可以通过调用它创建的单一 API 端点到达，而且这些后端服务中的每一个实际上也可以提供不同的 API 类型。&lt;/p&gt;
&lt;p&gt;“当你广泛地谈论 API 网关时，人们通常会想到 API 网关将授权请求，也许还有速率限制。这是每个人对 API 网关的理解，但这只是用其他东西进行代理，“Lombarte 说。“我们所做的是，我们创建一个新的 API，所以你不再消费你的后台，你在消费我们的 API 网关。这就像前端的一个后端。&lt;strong&gt;我们比市场上任何其他 API 网关更接近 GraphQL&lt;/strong&gt;&amp;quot;。&lt;/p&gt;
&lt;p&gt;Lombarte 说，如果你正在寻找这些强调速度的功能，那么 KrakenD 可能是正确的选择，但如果你需要专注于其他功能，那么 Lura 就可以帮助建立你需要的功能。他说，只需 20 到 30 行代码，你就可以使用 Lura 建立并运行一个 API 网关。eBay 和 Mail.ru 是目前使用 Lura 的两个大机构的例子。他说，这项技术提供了速度和无限的线性可扩展性，但也允许他们根据自己的需要定制 API 网关。&lt;/p&gt;
&lt;h2 id=&#34;未来计划&#34;&gt;未来计划&lt;/h2&gt;
&lt;p&gt;在 Lura 捐赠给 Linux 基金会之后，Lombarte 说，Lura 2.0 预计将在不久的将来发布，路线图中的新功能是支持 GraphQL 和能够用自定义插件进一步扩展该项目。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache APISIX 的全流量 API 网关统筹集群流量</title>
      <link>https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/</link>
      <pubDate>Wed, 30 Sep 2020 16:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/</guid>
      <description>&lt;p&gt;本文根据我在云原生学院的分享整理而成，视频见 &lt;a href=&#34;https://www.bilibili.com/video/BV1Gt4y1q7qC&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bilibli&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;bilibili.jpg&#34;&gt;云原生学院&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文将从云原生时代的机遇和挑战说起，介绍一个全新的开源高性能云原生 API 网关——Apache APISIX，探讨如何解决云原生时代 API 网关所面临的一些痛点，最后介绍该开源项目未来的规划。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;h3 id=&#34;云原生的机遇和挑战&#34;&gt;云原生的机遇和挑战&lt;/h3&gt;
&lt;p&gt;很多应用和服务都在向微服务、容器化迁移，形成新的云原生时代。云原生是下一个 5-10 年的技术颠覆，重写了传统企业的技术架构，例如云原生中的 Kubernetes 颠覆了传统操作系统，所有的“主机”（node 上的容器）由 Kubernetes 来控制和编排，非常适用于公有云、私有云、混合云等各种环境。云原生体系的特点之一就是由各种开源项目组成，不同于以往的商业闭源项目，缓解了收费贵等问题，加速了技术落地。现代公司的技术是非常重要的组成部分，在一个商业竞争激烈的时代，公司愈早的占据技术顶峰愈是能够占据商业顶峰。网关作为云原生入口，是掌握云原生的一个必经之地，是开启“财富”的关键钥匙。&lt;/p&gt;
&lt;h3 id=&#34;微服务的演进&#34;&gt;微服务的演进&lt;/h3&gt;
&lt;p&gt;从 2014-2015 年，谷歌搜索引擎上“微服务”关键字的搜索趋势呈直线上升。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps1_hud05ffbb97c9655a38d80df2007e5c7b4_494164_cda53a5f5f024db446901f3d8d546d0f.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps1_hud05ffbb97c9655a38d80df2007e5c7b4_494164_f47dd463b7b47aa1d7fb404f1a9c80de.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps1_hud05ffbb97c9655a38d80df2007e5c7b4_494164_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps1_hud05ffbb97c9655a38d80df2007e5c7b4_494164_cda53a5f5f024db446901f3d8d546d0f.webp&#34;
               width=&#34;760&#34;
               height=&#34;469&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在单体架构上，任一请求都会负载到整个的单体服务集群上。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps2_hub00e849b4190c28b456337b25e008a3c_235692_08e3a0619bd1cb0ca5623d919c4f7f9f.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps2_hub00e849b4190c28b456337b25e008a3c_235692_081c2294ac20561b55d187dfbdb49b53.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps2_hub00e849b4190c28b456337b25e008a3c_235692_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps2_hub00e849b4190c28b456337b25e008a3c_235692_08e3a0619bd1cb0ca5623d919c4f7f9f.webp&#34;
               width=&#34;760&#34;
               height=&#34;308&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在微服务架构上，对应请求会负载到微服务中对应的的子服务集群上。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps3_hu9d7fd3b8af1c798470ea19658e1029ba_508277_dda37ad97c2759be233ec43aa5462b26.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps3_hu9d7fd3b8af1c798470ea19658e1029ba_508277_b4d9209afe0cf7cf94d3192f603585d9.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps3_hu9d7fd3b8af1c798470ea19658e1029ba_508277_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps3_hu9d7fd3b8af1c798470ea19658e1029ba_508277_dda37ad97c2759be233ec43aa5462b26.webp&#34;
               width=&#34;760&#34;
               height=&#34;360&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用微服务进行精细管理后，服务的弹性伸缩、开发团队变得敏捷、服务之间隔离、降低故障率；在流量变动的时候，只需要对有可能变动流量的服务进行对应资源的扩缩容即可，这样可以很明显的节省服务器成本以及更高的承受度；在业务变动的时候，只需要对有可能变动业务的服务进行对应业务模块的变动即可，这样可以很明显的节省人力成本以及更高的控制力；在出现故障时不会导致整体服务不可用。&lt;/p&gt;
&lt;p&gt;但是落地微服务同样的带来了一些问题，比如接口之间通用的功能重复开发、膨胀的服务数量、难以管理。通常的解决方案便是使用 API 网关对其进行管理。&lt;/p&gt;
&lt;h3 id=&#34;微服务与-api-网关&#34;&gt;微服务与 API 网关&lt;/h3&gt;
&lt;p&gt;使用 API 网关进行管理，通常的做法是将微服务框架中功能型的功能统一放到网关上，例如可观测性 metrics、应用性能 apm tracing、限速、身份认证、日志等等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps4_hu84d506acad59869d38b3b43f13a67b2a_419390_5b905b922da2fa7948457a8510033262.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps4_hu84d506acad59869d38b3b43f13a67b2a_419390_281bf8710c53644c5807403497f71c6e.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps4_hu84d506acad59869d38b3b43f13a67b2a_419390_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps4_hu84d506acad59869d38b3b43f13a67b2a_419390_5b905b922da2fa7948457a8510033262.webp&#34;
               width=&#34;760&#34;
               height=&#34;286&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;灰度发布&#34;&gt;灰度发布&lt;/h4&gt;
&lt;p&gt;灰度发布也叫金丝雀发布，起源是，矿井工人发现，金丝雀对瓦斯气体很敏感，矿工会在下井之前，先放一只金丝雀到井中，如果金丝雀不叫了，就代表瓦斯浓度高。灰度发布会将流量按比例划分给已经上线的版本（比如 1.0，占比 90%）以及正在上线的版本（比如 1.01，占比 10%），若观测没有问题，逐步调整二者的流量占比直到流量完全切到 1.01 版本。Apache APISIX 内置的灰度发布支持读取到的 HTTP 请求参数中包含了 NGINX 的所有变量，可以依据变量进行灰度，甚至支持 LUA 代码去运算处理请求的请求体、请求参数。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps6_hu3a7e5756d50561a3c412aaf02916e4e4_472280_1506bef9ac3568cb2fa0c8981d539e28.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps6_hu3a7e5756d50561a3c412aaf02916e4e4_472280_3e2ea4f16d763454fa4c8fb5843bfd2d.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps6_hu3a7e5756d50561a3c412aaf02916e4e4_472280_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps6_hu3a7e5756d50561a3c412aaf02916e4e4_472280_1506bef9ac3568cb2fa0c8981d539e28.webp&#34;
               width=&#34;760&#34;
               height=&#34;319&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;服务熔断&#34;&gt;服务熔断&lt;/h4&gt;
&lt;p&gt;如图所示，当 Invoices 服务出现大量常见错误达到配置的熔断阈值就可以直接熔断不接收请求了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps7_hu54cd4cd03015653ae99a8f0fa47418fa_428019_b1d9b49ee40214788cf8a8edc41838ba.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps7_hu54cd4cd03015653ae99a8f0fa47418fa_428019_370b3238bc68117a5c145432333f76fa.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps7_hu54cd4cd03015653ae99a8f0fa47418fa_428019_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps7_hu54cd4cd03015653ae99a8f0fa47418fa_428019_b1d9b49ee40214788cf8a8edc41838ba.webp&#34;
               width=&#34;760&#34;
               height=&#34;353&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;apache-apisix-在传统和云原生领域的支持粒度&#34;&gt;Apache APISIX 在传统和云原生领域的支持粒度&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;作用在传统 API 网关领域的功能&lt;/th&gt;
&lt;th&gt;作用在云原生 API 网关领域的功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;让 API 请求更安全、更高效的得到处理；&lt;br /&gt;覆盖 Nginx 的所有功能：反向代理、负载均衡；&lt;br /&gt;动态上游、动态 SSL 证书、动态限流限速；主动/被动健康检查、服务熔断&lt;/td&gt;
&lt;td&gt;对接 Prometheus、Zipkin、Skywalking；&lt;br /&gt;gRPC 代理和协议转换 (REST &amp;lt;-&amp;gt; gRPC)；&lt;br /&gt;身份认证：OpenID Relying Party、OP（Auth0、okta……）&lt;br /&gt;高性能、无状态、随意扩容和缩容&lt;br /&gt;动态配置，不用 reload 服务&lt;br /&gt;支持多云、混合云&lt;br /&gt;容器优先，Kubernetes 友好&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;api-生命周期管理全景图&#34;&gt;API 生命周期管理全景图&lt;/h3&gt;
&lt;p&gt;API 生命周期指的是从 API 的设计到 API 的文档和他的 SDK 以及他的 API 的上线之类，甚至还包括 API 的市场等等一整套的解决方案，网关在其中是核心角色。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image-20200929155124157&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image-20200929155124157&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/image-20200929155124157_huecf471fe2c53bc25d53c1fd560f4daa3_234257_33c9f0c098e34ad036327d8416507d91.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/image-20200929155124157_huecf471fe2c53bc25d53c1fd560f4daa3_234257_7ee86511345bb854ec349fcd4c72678c.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/image-20200929155124157_huecf471fe2c53bc25d53c1fd560f4daa3_234257_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/image-20200929155124157_huecf471fe2c53bc25d53c1fd560f4daa3_234257_33c9f0c098e34ad036327d8416507d91.webp&#34;
               width=&#34;757&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image-20200929155124157
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在上半象限都是一些巨头公司，例如 Google、IBM 等等，都是公有云的闭源项目，具有领导地位，跟各自产品深度绑定在一起。在下半象限都是援建者，都是开源项目，例如：Kong，挑战着闭源项目，随着时间的推移我们发现——软件在吞噬世界、开源软件在吞噬软件。以下是近几年发生的很多 API 网关厂商相关的收购案例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2015 年，IBM 收购 StrongLoop&lt;/li&gt;
&lt;li&gt;2015 年，谷歌 6.25 亿美元收购 apigee&lt;/li&gt;
&lt;li&gt;2018 年，Salesforce 65 亿美元收购 MuleSoft&lt;/li&gt;
&lt;li&gt;2018 年，Broadcom 189 亿美元收购 CA Technologies&lt;/li&gt;
&lt;li&gt;2019 年，F5 收购 6.7 亿美元收购 NGINX&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明 API 网关在云原生时代依然扮演者重要的角色&lt;/p&gt;
&lt;h2 id=&#34;深入浅出-apache-apisix&#34;&gt;深入浅出 Apache APISIX&lt;/h2&gt;
&lt;h3 id=&#34;设计思路&#34;&gt;设计思路&lt;/h3&gt;
&lt;p&gt;API 网关的数据面和控制面分离。控制面不仅能控制 Apache APISIX 还能控制其他组件；数据面不仅仅能被我的控制面控制，还能被其他组件所控制&lt;/p&gt;
&lt;p&gt;通过插件机制来方便二次开发和运维。拿 Envoy 来说，Envoy 的插件是使用 C++ 编写的，C++ 本身就具有很大的复杂性；再来对比下 Kong，Kong 开发一个 IP 黑白名单插件需要写 300+ 行代码，并且插件配置解析、插件逻辑等代码分布在 3-4 个文件中；而 Apache APISIX 开发同样功能的插件只需要一个文件并且只需要 70 行代码。&lt;/p&gt;
&lt;p&gt;默认高可用，没有单点故障。因为使用了 ETCD 来存储和分发路由数据&lt;/p&gt;
&lt;p&gt;安全和稳定第一。Apache APISIX 基于 Nginx 实现，支持 mTLS 认证以及敏感信息加密加盐 (salt) 保存。为什么选择 Nginx 呢？它是基于 C 语言开发的程序，性能优化到极致，Nginx 的底层开发做的非常好，并且在大规模适用上得到充分有效的验证，从性能角度上是最佳选择&lt;/p&gt;
&lt;p&gt;高性能。Apache APISIX 基于 Nginx 的网络层，其单核心 QPS 1.5 万，延迟低于 0.7 毫秒。&lt;/p&gt;
&lt;p&gt;运维友好。它支持 Prometheus、SkyWalking 动态追踪、流量复制、故障注入等功能&lt;/p&gt;
&lt;h3 id=&#34;技术架构&#34;&gt;技术架构&lt;/h3&gt;
&lt;p&gt;Apache APISIX 架构如图，其主要分为数据面和控制面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据面：以 Nginx 的网络库为基础，（弃用 Nginx 的路由匹配、静态配置和 C 模块），使用 Lua 和 Nginx 动态控制请求流量，通过插件机制来实现各种流量处理和分发的功能：限流限速、日志记录、安全检测、故障注入等，同时支持用户编写自定义插件来对数据面进行扩充。&lt;/li&gt;
&lt;li&gt;控制面：使用 etcd 来存储和同步网关的配置数据，管理员通过 admin API 或者 dashboard 可以在毫秒级别内通知到所有的数据面节点，同时 etcd 集群也保证了系统的高可用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps15_huad3fed643d36b608f240e2099c8d1d94_465690_b20e902827d072bde1d0b1b5e01d2561.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps15_huad3fed643d36b608f240e2099c8d1d94_465690_9a0c7788e7b8de5d7079b7ef55d8f0f7.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps15_huad3fed643d36b608f240e2099c8d1d94_465690_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps15_huad3fed643d36b608f240e2099c8d1d94_465690_b20e902827d072bde1d0b1b5e01d2561.webp&#34;
               width=&#34;760&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;因为 Apache APISIX 使用了 ETCD 作为配置中心，在对应其他组件时会非常方便，可以把 ETCD 直接就当做服务注册发现中心来使用（服务注册、发现），当然同时也支持 Consul、Eureka、Nacos 等服务注册中心。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps16_hua4f27da2ae27158ee34830ca9d331531_958268_7ce118164c6cb22d9e0ebc793b98f50f.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps16_hua4f27da2ae27158ee34830ca9d331531_958268_eb54ef5676d9408214ec81267799e163.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps16_hua4f27da2ae27158ee34830ca9d331531_958268_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/wps16_hua4f27da2ae27158ee34830ca9d331531_958268_7ce118164c6cb22d9e0ebc793b98f50f.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;高性能&#34;&gt;高性能&lt;/h3&gt;
&lt;p&gt;Apache 只是使用了 Nginx 的网络库而并没有使用路由库，重写优化了路由算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apache APISIX 的路由复杂度是 O (k)，只和 URI 的长度有关，和路由数量无关；kong 的路由时间复杂度是 O (n) ，随着路由数量线性增长，K 指 URI 长度，和路由数量没有关系，例如有一百万条路由，ApiSix 路由的时间复杂度都是一样的，而 Kong 却不是这样的；&lt;/li&gt;
&lt;li&gt;Apache APISIX 的 IP 匹配时间复杂度是 O (1)，不会随着大量 IP 判断而导致 CPU 资源跑满；kong 的最新版本也换用了 Apache APISIX 的 IP 匹配库；不管有多少 IP 都是一次命中，而 Kong 却不是这样的；&lt;/li&gt;
&lt;li&gt;Apache APISIX 的路由匹配，接受 nginx 的所有变量作为条件，并且支持自定义函数；其他网关都是内置的几个条件；&lt;/li&gt;
&lt;li&gt;Apache APISIX 使用 etcd 作为配置中心，没有单点，任意宕掉一台机器，网关集群还能正常运行。其他基于 mysql，postgres 的网关都会有单点问题；&lt;/li&gt;
&lt;li&gt;Apache APISIX 的配置下发只要 1 毫秒就能达到所有网关节点，使用的是 etcd 的 watch；其他网关是定期轮询数据库，一般需要 5 秒才能获取到最新配置；&lt;/li&gt;
&lt;li&gt;只有 Apache APISIX 开放了自定义负载均衡的挂载点，其他网关都不支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;独创的插件编排&#34;&gt;独创的插件编排&lt;/h3&gt;
&lt;p&gt;基于已有插件的基础上，通过在界面上拖拖拽拽就可以生成一个全新的插件。&lt;/p&gt;
&lt;p&gt;通过插件编排的方式可以把 Apache APISIX 的四十多个插件的上下游关系全部串联起来形成一个新的插件。&lt;/p&gt;
&lt;p&gt;当前，Kong 支持 Go 编写的插件，Envoy 支持 Lua、WASM 编写的 filter。那么，Apache APISIX 的使用者为什么要“写”插件？我们认为运维、PM 也可以直接通过浏览器页面创造一个自己的插件。&lt;/p&gt;
&lt;p&gt;为了支持插件编排，Apache APISIX 一方面需要实现微插件、低代码，同时需要底层架构和插件足够灵活。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34;
           src=&#34;https://cloudnative.to/blog/full-traffic-api-gateway-based-on-apache-apisix/low-code-api-gateway-example-en-US.gif&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;同类技术对比&#34;&gt;同类技术对比&lt;/h3&gt;
&lt;h4 id=&#34;apache-apisix-vs-kong&#34;&gt;Apache APISIX vs Kong&lt;/h4&gt;
&lt;p&gt;有对比才更有说服力，Apache APISIX 和 Kong 都是基于 Openresty/LuaJIT 实现的高性能 API 网关，让我们来对比下他们的异同。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;对⽐比项&lt;/th&gt;
&lt;th&gt;APISIX&lt;/th&gt;
&lt;th&gt;Kong&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;技术架构&lt;/td&gt;
&lt;td&gt;Nginx + etcd&lt;/td&gt;
&lt;td&gt;Nginx + postgres&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;高可用&lt;/td&gt;
&lt;td&gt;非常可靠，没有单点&lt;/td&gt;
&lt;td&gt;一般，有数据库的单点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;精细化路由&lt;/td&gt;
&lt;td&gt;支持 Nginx 变量和自定义函数&lt;/td&gt;
&lt;td&gt;固定的⼏个条件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;配置⽣效时间&lt;/td&gt;
&lt;td&gt;事件驱动，小于 1 毫秒&lt;/td&gt;
&lt;td&gt;轮询拉取，5 秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;处理延迟&lt;/td&gt;
&lt;td&gt;0.2 毫秒&lt;/td&gt;
&lt;td&gt;2 毫秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能（单核，开启两个限流和 prometheus 插件）&lt;/td&gt;
&lt;td&gt;18000&lt;/td&gt;
&lt;td&gt;1700&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持流量复制和故障&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;注⼊&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持 SkyWalking&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;插件热更新&lt;/td&gt;
&lt;td&gt;新增、删除、更新插件不用重载服务&lt;/td&gt;
&lt;td&gt;无，每次都需要重载服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;二次开发&lt;/td&gt;
&lt;td&gt;难度低&lt;/td&gt;
&lt;td&gt;难度中等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;本地技术支持&lt;/td&gt;
&lt;td&gt;有，1 小时响应&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;定期巡检和培训&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因此我们发现 Apache APISIX 的分布式可靠性强，路由支持丰富，配置变更生效时间快，网关处理速度快，资源消耗率低，混沌测试支持度高，监控系统 (如 SkyWalking) 支持度高，插件变动动态化程度高以及二次开发难度低。&lt;/p&gt;
&lt;h4 id=&#34;apache-apisix-vs-nginx&#34;&gt;Apache APISIX vs Nginx&lt;/h4&gt;
&lt;p&gt;Nginx 是一款轻量级 Web 服务器、反向代理服务器，由于它的内存占用少、启动极快、高并发能力强，故其在互联网项目中得到广泛应用，距今已经有十多年的历史。但 Nginx 在步入云原生时代后遇到了更多的挑战：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;社区不活跃：没有 github issue 和 PR&lt;/li&gt;
&lt;li&gt;没有跟进云原生：nginx-k8s-controller、nginx unit 的尝试都失败了&lt;/li&gt;
&lt;li&gt;配置不能热加载&lt;/li&gt;
&lt;li&gt;非 http、https 流量的兴起（微服务、物联网……）&lt;/li&gt;
&lt;li&gt;商业化不成功&lt;/li&gt;
&lt;li&gt;被 F5 收购&lt;/li&gt;
&lt;li&gt;后浪：API 网关比如 Kong 和 Apache APISIX，serviceMesh proxy 比如 Envoy 等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开源社区规划&#34;&gt;开源社区规划&lt;/h2&gt;
&lt;h3 id=&#34;运营-apache-孵化器项目的经验&#34;&gt;运营 Apache 孵化器项目的经验&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为了让社区和用户保持习惯和预期，每个月一个版本，雷打不动。&lt;/li&gt;
&lt;li&gt;当天回复邮件列表和 github issue、PR&lt;/li&gt;
&lt;li&gt;频繁的布道和走访用户：每个月一次 meetup，走访过美团、腾讯、华为、贝壳、平安、又拍云、中国移动、思必驰、空中云汇、中国航信等几十家企业，深入了解用户的需求&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;the-apache-way&#34;&gt;The Apache Way&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不看重 github star，更关注如何吸引新的贡献者以及如何让贡献者更加活跃&lt;/li&gt;
&lt;li&gt;贡献不止代码，文档、测试、文章都是贡献，都可以成为 committer 和 PMC&lt;/li&gt;
&lt;li&gt;社区多样性：近 30 位 committer，其中两位欧洲开发者；至少 4 位大学生，甚至有 00 后的后浪贡献者，是 Apache APISIX committer&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;社区大于代码&#34;&gt;社区大于代码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The Apache Way&lt;/li&gt;
&lt;li&gt;活跃的社区，会重构坏的代码；但再好的代码，也会死于独裁的社区&lt;/li&gt;
&lt;li&gt;案例：Apache APISIX dashboard 的重构，社区对于 MySQL 的方案不满，“怨声载道”，然后来自 5 家公司的贡献者一起重构掉它&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;规划&#34;&gt;规划&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2.0 版本（即将发布）：使用 etcd v3 替代 v2&lt;/li&gt;
&lt;li&gt;3.0 版本：废弃 admin API，分离 DP 和 CP&lt;/li&gt;
&lt;li&gt;2021 年的 ﬂag：Apache APISIX 的贡献者超过 200 位&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;
&lt;p&gt;如果你还在被 Nginx 或者 Nginx Ingress 的 reload 性能问题所折磨，又或者对 Kong 的转发能力并不满意，欢迎大家使用 Apache APISIX&lt;/p&gt;
&lt;p&gt;欢迎大家给 Apache APISIX 贡献！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目地址：https://github.com/apache/apisix&lt;/li&gt;
&lt;li&gt;邮箱：&lt;a href=&#34;mailto:wenming@apache.org&#34;&gt;wenming@apache.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;QQ 群：578997126&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感谢&lt;a href=&#34;https://github.com/tristan-tsl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;谭世霖&lt;/a&gt;对本文内容的整理，&lt;a href=&#34;https://github.com/Miss-you&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;厉辉&lt;/a&gt;、&lt;a href=&#34;https://github.com/hyfj44255&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;杨冉宁&lt;/a&gt;、&lt;a href=&#34;https://github.com/rootsongjc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;宋净超&lt;/a&gt;参与审阅。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh 和 API Gateway 关系深度探讨</title>
      <link>https://cloudnative.to/blog/service-mesh-and-api-gateway/</link>
      <pubDate>Tue, 28 Apr 2020 11:20:46 +0800</pubDate>
      <guid>https://cloudnative.to/blog/service-mesh-and-api-gateway/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;关于 Service Mesh 和 API Gateway 之间的关系，这个问题过去两年间经常被问起，社区也有不少文章和资料给出解答。其中不乏 Christian Posta 这样的网红给出过深度介绍。我在这里做一个资料的整理和汇总，结合个人的理解给出一些看法。另外在本文最后，介绍蚂蚁金服在 Service Mesh 和 API Gateway 融合的这个最新领域的一些开创性的实践和探索，希望给大家一个更有体感的认知。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注 1：为了节约篇幅，我们将直奔主题，假定读者对 Service Mesh 和 API Gateway 已有基本的了解。&lt;/p&gt;
&lt;p&gt;备注 2:  这边文章更关注于梳理整个脉络，内容不会展开的特别细，尤其是其他文章已经详细阐述的部分。如果您在浏览本文之后，还想更深入的了解细节，请继续阅读文章最后的参考资料和推荐阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;原本清晰的界限定位和职责&#34;&gt;原本清晰的界限：定位和职责&lt;/h2&gt;
&lt;p&gt;首先，Service Mesh 和 API Gateway 在功能定位和承担的职责上有非常清晰的界限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Mesh：微服务的网络通信基础设施，负责（系统内部的）服务间的通讯&lt;/li&gt;
&lt;li&gt;API Gateway：负责将服务以 API 的形式暴露（给系统外部），以实现业务功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_f7859c7321a401742114a8636976ce86.webp 400w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_c08d37f9ebed334e95e5091043dee125.webp 760w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_f7859c7321a401742114a8636976ce86.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从功能和职责上说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位于最底层的是拆分好的原子微服务，以服务的形式提供各种能力&lt;/li&gt;
&lt;li&gt;在原子微服务上是（可选的）组合服务，某些场景下需要将若干微服务的能力组合起来形成新的服务&lt;/li&gt;
&lt;li&gt;原子微服务和组合服务部署于 &lt;strong&gt;系统内部&lt;/strong&gt;，在采用 Service Mesh 的情况下，由 Service Mesh 提供服务间通讯的能力&lt;/li&gt;
&lt;li&gt;API Gateway 用于将系统内部的这些服务暴露给 &lt;strong&gt;系统外部&lt;/strong&gt;，以 API 的形式接受外部请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从部署上说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Mesh 部署在系统内部：因为原子微服务和组合服务通常不会直接暴露给外部系统&lt;/li&gt;
&lt;li&gt;API Gateway 部署在系统的边缘：一方面暴露在系统之外，对外提供 API 供外部系统访问；一方面部署在系统内部，以访问内部的各种服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里引入两个使用非常广泛的术语：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_209feadfce8c585c7587bba795d19852.webp 400w,
               /blog/service-mesh-and-api-gateway/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_9f17930a636bbbb70cb99750fbba4279.webp 760w,
               /blog/service-mesh-and-api-gateway/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/directions_hua4205b154b414a6c9b162b19a0d449bd_54903_209feadfce8c585c7587bba795d19852.webp&#34;
               width=&#34;760&#34;
               height=&#34;326&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;东西向&lt;/strong&gt;通讯：指服务间的相互访问，其通讯流量在服务间流转，流量都位于系统内部&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;南北向&lt;/strong&gt;通讯：指服务对外部提供访问，通常是通过 API Gateway 提供的 API 对外部暴露，其通讯流量是从系统外部进入系统内部。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;解释一下“东西南北”的由来：如上图所示，通常在地图上习惯性的遵循“上北下南，左东右西”的原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结：Service Mesh 和 API Gateway 在功能和职责上分工明确，界限清晰。但如果事情就这么结束，也就不会出现 Service Mesh 和 API Gateway 关系的讨论了，自然也不会有本文。&lt;/p&gt;
&lt;p&gt;问题的根源在哪里？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈推荐阅读：附录中 Christian Posta 的文章 &amp;ldquo;Do I Need an API Gateway if I Use a Service Mesh?&amp;ldquo;对此有深度分析和讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;哲学问题网关访问内部服务算东西向还是南北向&#34;&gt;哲学问题：网关访问内部服务，算东西向还是南北向？&lt;/h2&gt;
&lt;p&gt;如下图所示，图中黄色的线条表示的是 API Gateway 访问内部服务：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_f7859c7321a401742114a8636976ce86.webp 400w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_c08d37f9ebed334e95e5091043dee125.webp 760w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/relationship-without-bff_hub27c856e6c0599a35ff9a89fa6cf8999_108352_f7859c7321a401742114a8636976ce86.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;问题来了，从流量走向看：这是外部流量进入系统后，开始访问对外暴露的服务，应该属于“南北向”通讯，典型如上图的画法。但从另外一个角度，如果我们将 API Gateway 逻辑上拆分为两个部分，先忽略对外暴露的部分，单独只看  API Gateway  访问内部服务的部分，这时可以视 API Gateway 为一个普通的客户端服务，它和内部服务的通讯更像是“东西向”通讯：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_d8c9a7c4926c5d5d55309d338745e53c.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_d2fde4544697be18226fa1938b906d63.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-access-service_huf0fe3ee17f350710b258c8e9b37cd31f_88997_d8c9a7c4926c5d5d55309d338745e53c.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;所以，API Gateway 作为一个客户端访问内部服务时，到底算南北向还是东西向，就成为一个哲学问题：完全取决于我们如何看待 API Gateway，是作为一个整体，还是逻辑上分拆为对内对外两个部分。&lt;/p&gt;
&lt;p&gt;这个哲学问题并非无厘头，在 API Gateway 的各种产品中，关于如何实现“API Gateway 作为一个客户端访问内部服务” ，就通常分成两个流派：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;泾渭分明：视 API Gateway 和内部服务为两个独立事物，API Gateway 访问内部服务的通讯机制自行实现，独立于服务间通讯的机制&lt;/li&gt;
&lt;li&gt;兼容并济：视 API Gateway 为一个普通的内部服务的客户端，重用其内部服务间通讯的机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而最终决策通常也和产品的定位有关：如果希望维持  API Gateway 的独立产品定位，希望可以在不同的服务间通讯方案下都可以使用，则通常选择前者，典型如 kong；如果和服务间通讯方案有非常深的渊源，则通常选择后者，典型如 springcloud 生态下的 zuul 和 springcloud gateway。&lt;/p&gt;
&lt;p&gt;但无论选择哪个流派，都改变不了一个事实，当“API Gateway 作为一个客户端访问内部服务”时，它的确和一个普通内部服务作为客户端去访问其他服务没有本质差异：服务发现，负载均衡，流量路由，熔断，限流，服务降级，故障注入，日志，监控，链路追踪，访问控制，加密，身份认证&amp;hellip;&amp;hellip; 当我们把网关访问内部服务的功能一一列出来时，发现几乎所有的这些功能都是和服务间调用重复。&lt;/p&gt;
&lt;p&gt;这也就造成了一个普遍现象：如果已有一个成熟的服务间通讯框架，再去考虑实现 API Gateway，重用这些重复的能力就成为自然而然的选择。典型如前面提到的 springcloud 生态下的 zuul 以及后面开发的 springcloud gateway，就是以重用类库的方式实现了这些能力的重用。&lt;/p&gt;
&lt;p&gt;这里又是一个类似的哲学问题：当“API Gateway 作为一个客户端访问内部服务”时，它以重用类库的方式实现了代码级别的能力重用，相当于自行实现了一个和普通服务间通讯方案完全一样的客户端，那这个“客户端”发出来的流量算东西向还是南北向？&lt;/p&gt;
&lt;p&gt;答案不重要。&lt;/p&gt;
&lt;h2 id=&#34;sidecar真正的重合点&#34;&gt;Sidecar：真正的重合点&lt;/h2&gt;
&lt;p&gt;在进入 Service Mesh 时代之后，Service Mesh 和 API gateway 的关系开始是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;功能和职责清晰划分&lt;/li&gt;
&lt;li&gt;客户端访问服务的功能高度重叠&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时两者的关系很清晰，而且由于当时 Service Mesh 和 API Gateway 是不同的产品，两者的重合点只是在功能上。&lt;/p&gt;
&lt;p&gt;而随着时间的推移，当 Service Mesh 产品和 API Gateway 产品开始出现相互渗透时，两者的关系就开始变得暧昧。&lt;/p&gt;
&lt;p&gt;在 Service Mesh 出现之后，如何为基于 Service Mesh 的服务选择合适的 API Gateway 方案，就慢慢开始提上日程，而其中选择重用 Service Mesh 的能力也自然成为一个探索的方向，并逐步出现新式 API Gateway 产品，其想法很直接：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何融合东西向和南北向的通讯方案？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中的一个做法就是基于 Service Mesh 的 Sidecar 来实现 API Gateway，从而在南北向通讯中引入 Service Mesh 这种东西向通讯的方案。这里我们不展开细节，我这里援引一个图片（鸣谢赵化冰同学）来解释这个方案的思路：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_54a5263908e4e52e9730a6748f4385f0.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_f2c217e21995849d90b4de49eb926a78.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hue5f03e6ac5dfd91191c9c2c237194c18_31788_54a5263908e4e52e9730a6748f4385f0.webp&#34;
               width=&#34;760&#34;
               height=&#34;244&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个时候 Service Mesh 和 API Gateway 的关系就变得有意思了，因为 Service Mesh 中 sidecar 的引入，所以前面的“哲学问题”又有了一个新的解法：API Gateway 这次真的可以分拆为两个独立部署的物理实体，而不是逻辑上的两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;API Gateway 本体：实现 API Gateway 除了访问内部服务之外的功能&lt;/li&gt;
&lt;li&gt;Sidecar：按照 Service Mesh 的标准做法，我们视 API Gateway 为一个部署于 Service Mesh 中的普通服务，为这个服务 1:1 的部署 sidecar&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_3ed088127c7942f69ca2ad761a9a698a.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_b1b27cce2d81ade8f80fec6d35b9c9cd.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_huc56418c38975cec51ded52f628b5e565_113155_3ed088127c7942f69ca2ad761a9a698a.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个方案中，原来用于 Service Mesh 的 sidecar，被用在了 API Gateway 中，替代了 API Gateway 中原有的客户端访问的各种功能。这个方案让 API Gateway 的实现简化了很多，也实现了东西向和南北向通讯能力的重用和融合，而 API Gateway 可以更专注于“API Management”的核心功能。&lt;/p&gt;
&lt;p&gt;此时 Service Mesh 和 API Gateway 的关系就从“泾渭分明”变成了“兼容并济”。&lt;/p&gt;
&lt;p&gt;而采用这个方案的公司，通常都是先有 Service Mesh 产品，再基于 Service Mesh 产品规划（或者重新规划）API Gateway 方案，典型如蚂蚁金服的 SOFA Gateway 产品是基于 MOSN，而社区开源产品 Ambassador 和 Gloo 都是基于 Envoy。&lt;/p&gt;
&lt;p&gt;上述方案的优势在于 API Gateway 和 Sidecar 独立部署，职责明确，架构清晰。但是，和 Service Mesh 使用 sidecar 被质疑多一跳会造成性能开销影响效率一样，API Gateway 使用 Sidecar 也被同样的质疑：多了一跳&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;解决“多一跳”问题的方法简单而粗暴，基于 sidecar，将 API Gateway 的功能加进来。这样 API Gateway 本体和 Sidecar 再次合二为一：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_163f8837dff0c118a170820e063a577f.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_020610a9ce6d1f820c23632cfeb9a6c6.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu8317c108d3f682919948f23fbc5672f4_118375_163f8837dff0c118a170820e063a577f.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;至于走到这一步之后，Service Mesh 和 API Gateway 是什么关系：这到底算是 Service Mesh/sidecar融合了API Gateway，还是 API Gateway 融合了 Service Mesh/Sidecar？这个问题就像斑马到底是白底黑纹还是黑底白纹一样，见仁见智。&lt;/p&gt;
&lt;h2 id=&#34;bff把融合进行到底&#34;&gt;BFF：把融合进行到底&lt;/h2&gt;
&lt;p&gt;BFF（Backend For Frontend）的引入会让 Service Mesh 和 API Gateway 走到一个更加亲密的地步。&lt;/p&gt;
&lt;p&gt;先来看看常规的 BFF 的玩法：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_82b1c5385231645bca4414f8c7a003eb.webp 400w,
               /blog/service-mesh-and-api-gateway/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_217f47d97dac77b6bc6774e3d569d025.webp 760w,
               /blog/service-mesh-and-api-gateway/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/relationship-with-bff_hu8eb4e2e0bfa2c646e35850acfa6b3966_122422_82b1c5385231645bca4414f8c7a003eb.webp&#34;
               width=&#34;760&#34;
               height=&#34;338&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这里，多增加了一个 BFF 层，介于 API Gateway 和内部服务（包括组合服务和原子微服务）之间。注意 BFF 的工作模式和组合服务很类似，都是组合多个服务。但差别在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组合服务还属于服务的范畴，只是实现机制上组合了多个服务，对外暴露的依然是一个完整和规范的服务&lt;/li&gt;
&lt;li&gt;BFF 不同，BFF 如名字所示，Backend For Frontend，完全是为了前端而存在，核心目标之一是简化前端的访问&lt;/li&gt;
&lt;li&gt;对我们今天的话题而言，最关键的一点：BFF 完全收口了从外部进入的流量，而组合服务没有，API Gateway 是可以直接访问原子微服务的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;“BFF 完全收口外部流量”，这一点在 API Gateway 和 Sidecar 融合之后，会变得很有想象空间，我们先看按照前面的融合方式，在有 BFF 的情况下，API Gateway 和 Sidecar 融合后的情景：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_96d4d14bd1670e31108c4e81cd7adebe.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_914a3273f0d0926c14625f45e18036f7.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu39aaf57ba28203eee1daf78e231d3f5e_130528_96d4d14bd1670e31108c4e81cd7adebe.webp&#34;
               width=&#34;760&#34;
               height=&#34;374&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;放大一点，单独看 API Gateway 和 BFF：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_42493bb04cbd51ededf65744172d2fe8.webp 400w,
               /blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_be4073244f51e2b800b5fef26058168a.webp 760w,
               /blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu7baae209101f190d2d2f43489815e04f_22604_42493bb04cbd51ededf65744172d2fe8.webp&#34;
               width=&#34;552&#34;
               height=&#34;416&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;注意到，流量从被 API Gateway 接收，到进入 BFF 在这个流程中，这个请求路径中有两个 sidecar：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;和 BFF 部署在一起的，是没有 API Gateway 功能的普通 Sidecar&lt;/li&gt;
&lt;li&gt;API Gateway 和 Sidecar 融合之后，这就是一个“有 API Gateway 功能的大 Sidecar”（或者是“有 Sidecar 功能的特殊 API Gateway”）：虽然扮演了 API Gateway 的角色，但本质上依然包含一个完整功能的 sidecar，和 BFF 自带的 Sidecar 是等同的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，问题来了：为什么要放两个 sidecar 在流程中，缩减到一个会怎么样？我们尝试将两个 Sidecar 合二为一，去掉 BFF 自带的 Sidecar，直接把扮演 API Gateway 的 sidecar 给 BFF 用：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_19bf30930b38a8ff63db84b4411dc7ab.webp 400w,
               /blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_fc053a06ecb1f70b192ebd292acb723b.webp 760w,
               /blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu6ccb64566e4e936a75bbc3febef96f67_14347_19bf30930b38a8ff63db84b4411dc7ab.webp&#34;
               width=&#34;645&#34;
               height=&#34;287&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此时的场景是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流量直接打到 BFF 上（BFF 前面可能会挂其他的网络组件提供负载均衡等功能）&lt;/li&gt;
&lt;li&gt;BFF 的 sidecar 接收流量，完成 API Gateway 的功能，然后将流量转给 BFF&lt;/li&gt;
&lt;li&gt;BFF 通过 sidecar 调用内部服务（和没有合并时一致）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_6a0cf3f9991378844eb7e7cdad30c7fe.webp 400w,
               /blog/service-mesh-and-api-gateway/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_731b76370e8deced8226bd4660256307.webp 760w,
               /blog/service-mesh-and-api-gateway/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/bff-api-gateway_hufa8ab7855af0a1dbc96110c1a7ce59ae_135500_6a0cf3f9991378844eb7e7cdad30c7fe.webp&#34;
               width=&#34;760&#34;
               height=&#34;389&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;注意这里有一个关键点，在前面时特意注明的：“&lt;strong&gt;BFF 完全收口外部流量&lt;/strong&gt;”。这是前提条件，因为原有的 API Gateway 集群已经不再存在，如果 BFF 没能收口全部流量，则这些未能收口的流量会找不到 API Gateway。当然，如果愿意稍微麻烦一点，在部署时清晰的划定需要暴露给外界的服务，直接在这些服务上部署带 API Gateway 功能的 Sidecar，也是可行的，只是管理上会比 BFF 模式要复杂一些。&lt;/p&gt;
&lt;p&gt;另外，在部署上，按照上面的方案，我们会发现：API Gateway“消失”了 —— 不再有一个明确物理部署的 API Gateway 的集群，常规的中心化的网关在这个方案中被融合到每一个 BFF 的实例中，从而实现另外一个重要特性：去中心化。&lt;/p&gt;
&lt;p&gt;上述 Service Mesh 和 API Gateway 融合的方案，并未停留在纸面上。&lt;/p&gt;
&lt;p&gt;在蚂蚁金服内部，我们基于 Service Mesh 和 API Gateway 融合 + 去中心化的思路，进行过开创性的实践和探索。以支付宝移动网关为例，在过去十年间，网关经历了从单体到微服务，从中心化到去中心化，从共享的 gateway.jar 包到利用MOSN实现网关Mesh化/Sidecar化，最终演变成了这样一个方案：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_1ee19086dc89c08fdfb4b06d29218890.webp 400w,
               /blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_9605f0d2f2cc4fed5895eb9fbb8fd01d.webp 760w,
               /blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hued6ae6f94556d57599478cf3a6949453_1852032_1ee19086dc89c08fdfb4b06d29218890.webp&#34;
               width=&#34;760&#34;
               height=&#34;379&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈推荐阅读：附录中我的同事贾岛的文章“蚂蚁金服 API Gateway Mesh 思考与实践”对此有深入介绍和详细描述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文总结了 Service Mesh 和 API Gateway 的关系，整体上说两者的定位和职责“泾渭分明”，但在具体实现上，开始出现融合的趋势：早期传统方式是类库级别的代码复用，最新趋势是 API Gateway 和 Sidecar 合二为一。&lt;/p&gt;
&lt;p&gt;后者的发展才刚刚起步，包括在蚂蚁金服我们也是才开始探索这个方向，但是相信在未来一两年间，社区可能会有更多的类似产品形态出现。&lt;/p&gt;
&lt;p&gt;补充介绍一下文中多次提到的“MOSN”：&lt;/p&gt;
&lt;p&gt;MOSN 是 MOSN 是 Modular Open Smart Network 的简称，是一款使用 Go 语言开发的网络代理软件，由蚂蚁金服开源并经过几十万容器的生产级验证。MOSN 作为云原生的网络数据平面，旨在为服务提供多协议、模块化、智能化、安全的代理能力。MOSN 可以与任何支持 xDS API 的 Service Mesh 集成，亦可以作为独立的四、七层负载均衡，API Gateway、云原生 Ingress 等使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub：https://github.com/mosn/mosn&lt;/li&gt;
&lt;li&gt;官网：https://mosn.io&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;附录参考资料和推荐阅读&#34;&gt;附录：参考资料和推荐阅读&lt;/h2&gt;
&lt;p&gt;意犹未尽的同学，欢迎继续阅读以下内容。&lt;/p&gt;
&lt;p&gt;按文章发表的时间排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://konghq.com/blog/the-difference-between-api-gateways-and-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Difference Between API Gateways and Service Mesh&lt;/a&gt;：2020-02，指导架构师确定何时使用 API 网关以及何时使用服务网格，作者 Marco Palladino，来自 kong。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/microservices/do-i-need-an-api-gateway-if-i-have-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Do I Need an API Gateway if I Use a Service Mesh?&lt;/a&gt;：2020-01，作者 Christian Posta，中文翻译版本请见马若飞同学的 &lt;a href=&#34;https://www.servicemesher.com/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用了 Service Mesh 后我还需要 API 网关吗&lt;/a&gt;，对 Service Mesh 技术和 API 网关的对比，着重分析了两者的功能重合点和分歧点，为技术选型和落地提供了指导思路。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/azCFGyTDGakZqaLEEDMN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;蚂蚁金服 API Gateway Mesh 思考与实践&lt;/a&gt;: 2019-12，作者贾岛，介绍蚂蚁金服支付宝网关的发展和 API Gateway Mesh 的由来，强烈推荐阅读，这个文章非常清晰的介绍了蚂蚁金服在 Service Mesh 和 API Gateway 融合方面的实践。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.servicemesher.com/blog/api-gateways-are-going-through-an-identity-crisis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Gateway 的身份认同危机&lt;/a&gt;: 2019-05, 原文作者 Christian Posta，译者周雨青，讲述 API Gateway 的基本理念如 API 的定义，API Management 的含义，API Gateway 模式，以及服务网格和 API Gateway 的关系。&lt;/li&gt;
&lt;li&gt;长路漫漫踏歌而行：蚂蚁金服 Service Mesh 实践探索：2018-10，我在 QCon 的演讲，我分享了当时蚂蚁金服在服务间通讯范围的探索，提出将服务网格在东西向通讯中的能力重用到南北向通讯中，当时基于 Sidecar 的 SOFA Gateway 产品刚开始开发。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.getambassador.io/api-gateway-vs-service-mesh-104c01fa4784&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Gateway vs Service Mesh&lt;/a&gt;: 2018-09，作者 Richard Li，Datawire 的 CEO，在开发 Ambassador API Gateway。Ambassador 是基于 Envoy 的 API Gateway 开源产品，文章阐述了对服务网格和 API Gateway 的看法，差异，以及对两者集成的看法。&lt;/li&gt;
&lt;li&gt;DreamMesh 抛砖引玉 (9)-API Gateway：2018-03，这个文章也是我写的，2018 年初我和 Service Mesh 社区的一些朋友深入探讨之后，在 DreamMesh 系列博客文章中记录下了当时构想的方案，尤其对 API gateway 和 sidecar 是分是合有详细讨论。当时想法还不够成熟，但大体方向已经有雏形了。鸣谢当时参与讨论的同学！&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/microservices-in-practice/service-mesh-vs-api-gateway-a6d814b9bf56&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh vs API Gateway&lt;/a&gt;: 2017-10，原文作者 &lt;a href=&#34;https://medium.com/@kasunindrasiri&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kasun Indrasiri&lt;/a&gt;，以及 &lt;a href=&#34;https://zhaohuabing.com/2018/04/11/service-mesh-vs-api-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;赵化冰同学翻译的中文版本&lt;/a&gt;，文章不长，主要对比了服务网格和 API Gateway 的产品功能，提出了两者融合的方式——在 API Gateway 中通过服务网格来调用下游服务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Network Functions With ESBs, API Management, and Now.. Service Mesh?&lt;/a&gt;：2017-08，作者 Christian Posta，讲述服务网格与 ESB，消息代理和 API 管理之类的事物的关系。内容非常好，强烈推荐阅读（我不得不吐糟一下：配图太辣眼睛）。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>构建云原生微服务网关 - 篇一：Ambassador</title>
      <link>https://cloudnative.to/blog/cloud-native-api-gateway-part-1/</link>
      <pubDate>Thu, 01 Aug 2019 20:15:43 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-api-gateway-part-1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在微服务架构中，API 网关是一个十分重要的存在。一方面它为外部的流量访问提供了统一的入口，使得可以方便的进行防火墙的策略实施；另一方面，可以在网关处进行流量控制、认证、授权、灰度发布、日志收集、性能分析等各种高级功能，使得业务功能与非业务功能有效解耦，给予了系统架构更大的灵活性。本系列文章尝试分析目前主流的云原生微服务网关，并比较它们各自的优劣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;网关选型标准&#34;&gt;网关选型标准&lt;/h2&gt;
&lt;p&gt;其实 kubernetes 本身有一个 ingress controller，基于 Nginx 或 HAProxy 等 7 层代理进行流量的转发。不过 ingress 只能进行简单的反向代理，不支持流控、灰度、认证、授权等网关必备的功能。所以一般意义认为，ingress 是一个 7 层 http 代理，而非 api 网关。本系列主要分析 Ambassador、Traefik、Kong 等具备&lt;strong&gt;微服务&lt;/strong&gt;所需能力的网关产品。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ambassador&#34;&gt;什么是 Ambassador？&lt;/h2&gt;
&lt;p&gt;这里引用官网的一段描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ambassador 是一个基于 Envoy proxy 构建的，kubernetes 原生的开源微服务网关。Ambassador 在构建之初就致力于支持多个独立的团队，这些团队需要为最终用户快速发布、监控和更新服务。Ambassador 还具有 Kubernetes ingress 和负载均衡的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意这里的几个关键词：&lt;strong&gt;Envoy&lt;/strong&gt;，&lt;strong&gt;kubernetes 原生&lt;/strong&gt;，&lt;strong&gt;微服务&lt;/strong&gt;。现在市面上网关产品不少，不过 Kubernetes 原生的产品倒真的不多。传统的网关产品一般是基于 rest api 或者 yaml 文件来进行配置（谁让这些老大哥出来的早呢，他们火的时候 k8 还没出来呢），而 Ambassador 完全基于 k8s 标准的 annotation 或者 CRD 来进行各类配置，没错，非常的&lt;strong&gt;native&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;ambassador-架构&#34;&gt;Ambassador 架构&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-0dcae8cb18297b27_hu8bdf406e6696a0fec3f8bad4e0d74f39_140610_8b329baa11b79f1bd49b68ba4a5699af.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-0dcae8cb18297b27_hu8bdf406e6696a0fec3f8bad4e0d74f39_140610_94d293736e3b6fdd83c09d73500f1c7b.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-0dcae8cb18297b27_hu8bdf406e6696a0fec3f8bad4e0d74f39_140610_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-0dcae8cb18297b27_hu8bdf406e6696a0fec3f8bad4e0d74f39_140610_8b329baa11b79f1bd49b68ba4a5699af.webp&#34;
               width=&#34;760&#34;
               height=&#34;430&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;了解 istio 的同学，看到这张图会有十分熟悉的感觉，没错，Ambassador 也是具有控制平面和数据平面的。数据平面自然是老伙计 Envoy，Ambassador 的控制平面负责监听 k8s 中的 Service 资源的变化，并将配置下发 Envoy，实际的流量转发通过 Envoy 来完成。（感觉就是一个轻量级的 istio）&lt;/p&gt;
&lt;p&gt;具体流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务所有者在 kubernetes manifests 中定义配置 (通过 annotation 或者 CRD)。&lt;/li&gt;
&lt;li&gt;当 manifest 应用到集群时，kubernetes api 会将更改通知 Ambassador。&lt;/li&gt;
&lt;li&gt;Ambassador 解析更改并将配置转换为一种中间语义。Envoy 的配置由该 IR 生成。&lt;/li&gt;
&lt;li&gt;新的配置通过基于 gRPC 的聚合发现服务（ADS）api 传递给 Envoy。&lt;/li&gt;
&lt;li&gt;流量通过重新配置的 Envoy，而不会断开任何连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;扩展性和可用性&#34;&gt;扩展性和可用性&lt;/h2&gt;
&lt;p&gt;Ambassador 依靠 Kubernetes 实现扩展性、高可用性和持久性。所有 Ambassador 配置都直接存储在 Kubernetes 中（etcd），没有数据库。Ambassador 被打包成一个单独的容器，其中包含控制平面和一个 Ambassador 代理实例。默认情况下，Ambassador 部署为 kubernetes deployment，可以像其他 kubernetes deployment 一样进行扩展和管理。&lt;/p&gt;
&lt;h2 id=&#34;与其他网关产品比较&#34;&gt;与其他网关产品比较&lt;/h2&gt;
&lt;p&gt;目前主流的网关产品可以分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;托管的 API 网关，比如 &lt;a href=&#34;https://aws.amazon.com/api-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon api gateway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;传统的 API 网关，比如 &lt;a href=&#34;https://getkong.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;7 层代理，比如 &lt;a href=&#34;https://traefik.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik&lt;/a&gt;, &lt;a href=&#34;http://nginx.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NGINX&lt;/a&gt;, &lt;a href=&#34;http://www.haproxy.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HAProxy&lt;/a&gt;, or &lt;a href=&#34;https://www.Envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;, 或者是基于这些代理的 Ingress controllers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有这些托管的和传统的 API 网关的问题是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不是自服务的。传统 API 网关上的管理接口不是为开发人员自服务而设计的，为开发人员提供的安全性和可用性有限。&lt;/li&gt;
&lt;li&gt;不是 Kubernetes 原生的。它们通常使用 REST apis 进行配置，这使得采用云原生模式（如 GitOps 和声明式配置）变得很困难。&lt;/li&gt;
&lt;li&gt;为 API 管理而设计，而非微服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说，7 层代理可以用作 API 网关，但需要额外的定制开发来支持微服务用例。事实上，许多 API 网关都将 API 网关所需的附加功能打包在 L7 代理之上。Ambassador 使用 Envoy，而 Kong 使用 Nginx。&lt;/p&gt;
&lt;h2 id=&#34;istio&#34;&gt;Istio&lt;/h2&gt;
&lt;p&gt;Istio 是一个基于 Envoy 的开源服务网格。服务网格用于管理东/西流量，而API网关用于管理南/北流量。一般来说，我们发现南/北流量与东/西流量有很大不同（比如说，在南北流量中你无法控制客户端）。&lt;/p&gt;
&lt;h2 id=&#34;安装-ambassador&#34;&gt;安装 Ambassador&lt;/h2&gt;
&lt;p&gt;Ambassador 安装非常的简单，直接使用 helm 安装。如果对于 helm 还不是很了解，可以参考我之前的文章 &lt;a href=&#34;https://www.jianshu.com/p/290f27841b8d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;helm 介绍&lt;/a&gt;。
使用 helm 安装只需要执行如下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install --name my-release stable/ambassador
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 这边插播一下，推荐使用微软 azure 的 charts 镜像&lt;code&gt;http://mirror.azure.cn/kubernetes/charts/&lt;/code&gt;，基本和官方的同步，且可以正常访问，阿里云的 charts 不知道为什么更新很不及时。
安装完后可以看到有两个 pods&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                          READY     STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ambassador-3655608000-43x86   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          2m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ambassador-3655608000-w63zf   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          2m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果都是都是 running 状态，这样 Ambassador 就安装完成了
接下来我们部署一下官网的应用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;getambassador.io/config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      ---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      apiVersion: ambassador/v1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      kind: Mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      name: tour-ui_mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      prefix: /
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      service: tour:5000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      ---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      apiVersion: ambassador/v1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      kind: Mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      name: tour-backend_mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      prefix: /backend/
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      service: tour:8080
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      labels:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        ambassador:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          - request_label:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;            - backend&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ui&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;backend&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apps/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;replicas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;strategy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RollingUpdate&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour-ui&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;quay.io/datawire/tour:ui-0.2.4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;quote&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;quay.io/datawire/tour:backend-0.2.4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;limits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;100Mi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个 pod 里面有两个容器，分别是前端的 ui 以及后端的 backend。注意 annotation 里面的&lt;code&gt;getambassador.io/config&lt;/code&gt;部分，这就是 ambassador 的配置了，分别定义了两个注释，kind 是&lt;code&gt;Mapping&lt;/code&gt;，定义了前后端的匹配路径，服务名称及端口。这个配置的意思是，凡是匹配上&lt;code&gt;/&lt;/code&gt;的，全部走 tour 的 5000 端口，凡是匹配上&lt;code&gt;/backend&lt;/code&gt;的，全部走 tour 的 8080 端口（对应的就是 tour 的 service 配置）。也可以使用 CRD 方式配置，ambassador 已经默认创建了一组 crd&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;root@MiWiFi-R1CM-srv zuul&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# kubectl get crds|grep ambassador&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;authservices.getambassador.io                  2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;consulresolvers.getambassador.io               2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetesendpointresolvers.getambassador.io   2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetesserviceresolvers.getambassador.io    2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mappings.getambassador.io                      2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;modules.getambassador.io                       2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ratelimitservices.getambassador.io             2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcpmappings.getambassador.io                   2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tlscontexts.getambassador.io                   2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tracingservices.getambassador.io               2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 mapping 就是核心资源，用于路由的转发配置，下面是一个 mapping 资源配置示例&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;items&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;getambassador.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Mapping&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kubectl.kubernetes.io/last-applied-configuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;{&lt;span class=&#34;s2&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;getambassador.io/v1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;kind&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Mapping&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;{&lt;span class=&#34;s2&#34;&gt;&amp;#34;annotations&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;{}&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;nginx&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;namespace&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;default&amp;#34;&lt;/span&gt;}&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spec&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;{&lt;span class=&#34;s2&#34;&gt;&amp;#34;prefix&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/nginx&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;service&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;nginx:80&amp;#34;&lt;/span&gt;}}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2019-07-27T13:36:38Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;generation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resourceVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;420594&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selfLink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/apis/getambassador.io/v1/namespaces/default/mappings/nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;8f1f4d33-b073-11e9-be4c-0800279f163b&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx:80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resourceVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selfLink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一旦你修改了 service 里面的 annotation 设置，ambassador 的控制面会自动将变更下发给 Envoy，全程不需要中断服务。（也要感谢 Envoy 强大的 xDS api）&lt;/p&gt;
&lt;p&gt;下面我们来看一下 Ambassador 的几个使用场景：&lt;/p&gt;
&lt;h2 id=&#34;用例&#34;&gt;用例&lt;/h2&gt;
&lt;h3 id=&#34;用例-1边缘南北路由&#34;&gt;用例 1：边缘（南/北）路由&lt;/h3&gt;
&lt;p&gt;这个是平时最常见的使用场景，网关位于整个集群的入口处，统一去做一些流控、鉴权等方面的工作：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-45238040cc6650c4_hu9a78ab1340ace24316364e507a63d684_654383_09787f1a4401c0f8bbad0bc56f6530ab.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-45238040cc6650c4_hu9a78ab1340ace24316364e507a63d684_654383_d91961dd019880166c342b67e4a660b2.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-45238040cc6650c4_hu9a78ab1340ace24316364e507a63d684_654383_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-45238040cc6650c4_hu9a78ab1340ace24316364e507a63d684_654383_09787f1a4401c0f8bbad0bc56f6530ab.webp&#34;
               width=&#34;760&#34;
               height=&#34;454&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;该场景的关注点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制/路由入口流量的能力&lt;/li&gt;
&lt;li&gt;卸载请求
&lt;ul&gt;
&lt;li&gt;认证（比如要求所有入口流量都必须要进过认证）&lt;/li&gt;
&lt;li&gt;加密（TLS 终端及传输加密）&lt;/li&gt;
&lt;li&gt;重试及超时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;saas service 中的真实用例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-7db0c08aafed66b9_hu20f7e83b2e9c7608cee16e9229828b84_213709_85ada0be71ca3bb3a0a3666e9a89bd58.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-7db0c08aafed66b9_hu20f7e83b2e9c7608cee16e9229828b84_213709_c3661edee9f05617ef196f6dc75be369.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-7db0c08aafed66b9_hu20f7e83b2e9c7608cee16e9229828b84_213709_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-7db0c08aafed66b9_hu20f7e83b2e9c7608cee16e9229828b84_213709_85ada0be71ca3bb3a0a3666e9a89bd58.webp&#34;
               width=&#34;760&#34;
               height=&#34;367&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;用例-2内部南北路由&#34;&gt;用例 2：内部（南/北）路由&lt;/h3&gt;
&lt;p&gt;通常来说，企业内部的系统架构会比较复杂，会有多集群或者多租户，比如一个 kubernetes 的集群和一个 vm 的集群（可能是 openstack），那么在集群之间的流量就是内部的南/北流量，集群之间的流量交互可以通过 ambassador 完成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-90750413b7c7e9f5_huc1feabb3b3a414490d5dfa9c4dc40103_405846_5e02935b14f6ec5b5a30b3e32aa0eafb.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-90750413b7c7e9f5_huc1feabb3b3a414490d5dfa9c4dc40103_405846_9aac33649f7c5fe060e77916d7d91d53.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-90750413b7c7e9f5_huc1feabb3b3a414490d5dfa9c4dc40103_405846_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-90750413b7c7e9f5_huc1feabb3b3a414490d5dfa9c4dc40103_405846_5e02935b14f6ec5b5a30b3e32aa0eafb.webp&#34;
               width=&#34;760&#34;
               height=&#34;447&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此场景的关注点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制/路由多租户流量的能力&lt;/li&gt;
&lt;li&gt;卸载请求
&lt;ul&gt;
&lt;li&gt;匹配（基于 headers）&lt;/li&gt;
&lt;li&gt;重试及超时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;saas service 中的真实用例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-23acd24daab3455b_hu4aa6dec4760eb792f36bc4964dff083e_302570_9c7a2b3abed414693bfb1c34fdb836db.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-23acd24daab3455b_hu4aa6dec4760eb792f36bc4964dff083e_302570_1ca5013f8a5572ddde18f68a1d46ace9.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-23acd24daab3455b_hu4aa6dec4760eb792f36bc4964dff083e_302570_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-23acd24daab3455b_hu4aa6dec4760eb792f36bc4964dff083e_302570_9c7a2b3abed414693bfb1c34fdb836db.webp&#34;
               width=&#34;760&#34;
               height=&#34;371&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;用例-3内部东西路由&#34;&gt;用例 3：内部（东/西）路由&lt;/h3&gt;
&lt;p&gt;这个场景中 Ambassador 已经作为集群内部东西向流量的代理了，配合它自己的控制平面，有点 service mesh 的意思了。区别在于，Ambassador 在这个集群里是处于一个中心节点的位置（一个或一组 ambassador 实例），属于 server proxy 的范畴，而不是 service mesh 里面的 client proxy（sidecar）。这种架构其实和传统的 esb 更加的接近。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-8cec66e2dc3b82c1_hud2323e03413867f76b95fda25d4ce189_416807_ce6f2b85b020f743378a2b33b96e63b9.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-8cec66e2dc3b82c1_hud2323e03413867f76b95fda25d4ce189_416807_c7ff16de2510fa8d7c64009a62c9383b.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-8cec66e2dc3b82c1_hud2323e03413867f76b95fda25d4ce189_416807_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-8cec66e2dc3b82c1_hud2323e03413867f76b95fda25d4ce189_416807_ce6f2b85b020f743378a2b33b96e63b9.webp&#34;
               width=&#34;760&#34;
               height=&#34;459&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此场景关注点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制/路由任意流量的能力（南北向+东西向）&lt;/li&gt;
&lt;li&gt;卸载请求
&lt;ul&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;访问控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家可以看到，已经非常接近于 service mesh 的能力了（也许 ambassador 以后也会出一个 service mesh 产品？）&lt;/p&gt;
&lt;p&gt;saas service 的真实用例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-605fcdf1a7987640_hu020f9ea833ad1b5261b564901f9470a8_235224_f48ef9a82d7b53bd7b5bdbaa1bde73f1.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-605fcdf1a7987640_hu020f9ea833ad1b5261b564901f9470a8_235224_cd7177c34ee038ce6164fb7956f9b9dd.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-605fcdf1a7987640_hu020f9ea833ad1b5261b564901f9470a8_235224_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-605fcdf1a7987640_hu020f9ea833ad1b5261b564901f9470a8_235224_f48ef9a82d7b53bd7b5bdbaa1bde73f1.webp&#34;
               width=&#34;760&#34;
               height=&#34;345&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;服务网格的真实用例（与 istio 集成）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-dbefbeb1c9fcf405_huf2e5170596e015ef27b04ec7522459b5_184471_046e52164cc571f0e1d6545f349e8fd7.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-dbefbeb1c9fcf405_huf2e5170596e015ef27b04ec7522459b5_184471_52e78c4fdfa62a02577d038776419c2f.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-dbefbeb1c9fcf405_huf2e5170596e015ef27b04ec7522459b5_184471_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-dbefbeb1c9fcf405_huf2e5170596e015ef27b04ec7522459b5_184471_046e52164cc571f0e1d6545f349e8fd7.webp&#34;
               width=&#34;760&#34;
               height=&#34;345&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;用例-4流量镜像&#34;&gt;用例 4：流量镜像&lt;/h3&gt;
&lt;p&gt;此场景中可以把流量复制一份到其他服务中（影子流量），通常用于监控、测试等场景&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-85a3899f164466c2_hue9ceca84ce874ed61d1e4e0e3ce76420_242144_a5c0e1daad16550b6cb54bc00b77a0f3.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-85a3899f164466c2_hue9ceca84ce874ed61d1e4e0e3ce76420_242144_3ceb7c521521d87ba120f90bd9884cdb.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-85a3899f164466c2_hue9ceca84ce874ed61d1e4e0e3ce76420_242144_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-85a3899f164466c2_hue9ceca84ce874ed61d1e4e0e3ce76420_242144_a5c0e1daad16550b6cb54bc00b77a0f3.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试代码、发布包的能力&lt;/li&gt;
&lt;li&gt;利用真实的流量/负载&lt;/li&gt;
&lt;li&gt;最小化重复资源&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：上面所描述的几个典型场景其实不光可以使用 Ambassador，而是适用于各类使用 api gateway 或者 proxy 的场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;Ambassador 不同版本之间配置方式的变更如下图所示，configmap 方式是早期使用方式，目前已经被废弃了，现在更推荐使用 CRD 方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-d2aac8fb2c0cbeda_hu319b5bd47535d491d20c4cc26d77f27a_46410_62a411159854a3ebc5db1ef40660b4ac.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-d2aac8fb2c0cbeda_hu319b5bd47535d491d20c4cc26d77f27a_46410_9e9f0fcaf9f8b02d28f5efc608d25dfa.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-d2aac8fb2c0cbeda_hu319b5bd47535d491d20c4cc26d77f27a_46410_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-d2aac8fb2c0cbeda_hu319b5bd47535d491d20c4cc26d77f27a_46410_62a411159854a3ebc5db1ef40660b4ac.webp&#34;
               width=&#34;760&#34;
               height=&#34;201&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;加密的配置方式&#34;&gt;加密的配置方式&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-f9231001054176b2_hu0e18278873a9025e6f57b3a63492be1c_132866_013e305018bf0d428d6ab2e90b3a4a9d.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-f9231001054176b2_hu0e18278873a9025e6f57b3a63492be1c_132866_a53ebed36d1518c11ae7f2cd39b7ea37.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-f9231001054176b2_hu0e18278873a9025e6f57b3a63492be1c_132866_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-f9231001054176b2_hu0e18278873a9025e6f57b3a63492be1c_132866_013e305018bf0d428d6ab2e90b3a4a9d.webp&#34;
               width=&#34;760&#34;
               height=&#34;352&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;认证的配置方式&#34;&gt;认证的配置方式&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-38b74b7b5ed93f2e_huce83d985abfa41cbe73ea263abf7c813_200162_6ecf093e5ad77e38b593447e8afd4ecf.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-38b74b7b5ed93f2e_huce83d985abfa41cbe73ea263abf7c813_200162_fe81727bc94dd2e5c72293fd7a097625.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-38b74b7b5ed93f2e_huce83d985abfa41cbe73ea263abf7c813_200162_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-38b74b7b5ed93f2e_huce83d985abfa41cbe73ea263abf7c813_200162_6ecf093e5ad77e38b593447e8afd4ecf.webp&#34;
               width=&#34;760&#34;
               height=&#34;360&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;路由的配置方式&#34;&gt;路由的配置方式&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-64fc6ccdef6a0386_hu040b4cff851e7701e9464b017f5392f9_145494_42e2ca6220d71f029e81e3cebd9b78dc.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-64fc6ccdef6a0386_hu040b4cff851e7701e9464b017f5392f9_145494_751e240a25371632d2f10e57e66a928e.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-64fc6ccdef6a0386_hu040b4cff851e7701e9464b017f5392f9_145494_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-64fc6ccdef6a0386_hu040b4cff851e7701e9464b017f5392f9_145494_42e2ca6220d71f029e81e3cebd9b78dc.webp&#34;
               width=&#34;760&#34;
               height=&#34;338&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;跟踪的配置方式&#34;&gt;跟踪的配置方式&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-2ed98f1ea3c98531_hu40345bf7c2825f079a83019471fd9ae7_141631_5d7e6913a3f0dd516f5d7d008d978990.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-2ed98f1ea3c98531_hu40345bf7c2825f079a83019471fd9ae7_141631_7b99a3c5f037e57498c857c1c7778be3.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-2ed98f1ea3c98531_hu40345bf7c2825f079a83019471fd9ae7_141631_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-api-gateway-part-1/14871146-2ed98f1ea3c98531_hu40345bf7c2825f079a83019471fd9ae7_141631_5d7e6913a3f0dd516f5d7d008d978990.webp&#34;
               width=&#34;760&#34;
               height=&#34;322&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;ambassador-的不足&#34;&gt;Ambassador 的不足&lt;/h2&gt;
&lt;p&gt;Ambassador 和同类的网关产品类似，分为社区版及商业版，社区版提供了最基础的路由、限速、TLS 加密、跟踪、认证（需要自己实现 external third party authentication service）等能力，但是微服务网关中十分重要的 OAuth2 集成认证、RBAC、custom filter 等功能都是需要在 pro 版中才能实现，这是比较遗憾的一点。尤其是 custom filter，根据我们目前的经验，一个能力完整、功能丰富的微服务网关，必然会引入 custom filter。而 custom filter 也需要使用 Golang 进行编写，对于不熟悉 Golang 的开发人员来说也会比较痛苦。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Ambassador 作为一个较新推出的开源微服务网关产品，与 kubernetes 结合的相当好，基于 annotation 或 CRD 的配置方式与 k8s 浑然一体，甚至让人感觉这就是 k8s 自身功能的一部分，真正做到了&lt;code&gt;kubernetes native&lt;/code&gt;。而底层基于 Envoy 进行流量代理，也让人不需要太担心性能问题。对于路由、加密、基础认证、链路跟踪等场景，可尝试使用。而对于像&lt;code&gt;custom filter&lt;/code&gt;、&lt;code&gt;rbac&lt;/code&gt;、&lt;code&gt;advanced rate limiting&lt;/code&gt;等场景有需求的用户，使用 pro 版本可满足要求。本人也与 Ambassador 开发团队进行了联系，遗憾的是 Ambassador 目前在国内尚未有 reseller，若使用 pro 版，后期技术支持的便利性也是需要考虑的问题。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.getambassador.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.getambassador.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Using Ambassador to build Cloud-Native Applications - Steve Flanders, Omnition @ KubeCon 2019, Shanghai&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何为服务网格选择入口网关？</title>
      <link>https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/</link>
      <pubDate>Wed, 15 May 2019 12:23:01 +0800</pubDate>
      <guid>https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/</guid>
      <description>&lt;p&gt;在启用了 Istio 服务网格的 Kubernetes 集群中，缺省情况下只能在集群内部访问网格中的服务，要如何才能从外部网络访问这些服务呢？Kubernetes 和 Istio 提供了 NodePort，LoadBalancer，Kubernetes Ingress，Istio Gateway 等多种外部流量入口的方式，面对这么多种方式，我们在产品部署中应该如何选择？&lt;/p&gt;
&lt;p&gt;本文将对 Kubernetes 和 Istio 对外提供服务的各种方式进行详细介绍和对比分析，并根据分析结果提出一个可用于产品部署的解决方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;说明：阅读本文要求读者了解 Kubernetes 和 Istio 的基本概念，包括 Pod、Service、NodePort、LoadBalancer、Ingress、Gateway、VirtualService 等。如对这些概念不熟悉，可以在阅读过程中参考文后的相关链接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;内部服务间的通信&#34;&gt;内部服务间的通信&lt;/h2&gt;
&lt;p&gt;首先，我们来回顾一下 Kubernetes 集群内部各个服务之间相互访问的方法。&lt;/p&gt;
&lt;h2 id=&#34;cluster-ip&#34;&gt;Cluster IP&lt;/h2&gt;
&lt;p&gt;Kubernetes 以 Pod 作为应用部署的最小单位。Kubernetes 会根据 Pod 的声明对其进行调度，包括创建、销毁、迁移、水平伸缩等，因此 Pod 的 IP 地址不是固定的，不方便直接采用 Pod IP 对服务进行访问。&lt;/p&gt;
&lt;p&gt;为解决该问题，Kubernetes 提供了 Service 资源，Service 对提供同一个服务的多个 Pod 进行聚合。一个 Service 提供一个虚拟的 Cluster IP，后端对应一个或者多个提供服务的 Pod。在集群中访问该 Service 时，采用 Cluster IP 即可，Kube-proxy 负责将发送到 Cluster IP 的请求转发到后端的 Pod 上。&lt;/p&gt;
&lt;p&gt;Kube-proxy 是一个运行在每个节点上的 go 应用程序，支持三种工作模式：&lt;/p&gt;
&lt;h3 id=&#34;userspace-模式&#34;&gt;userspace 模式&lt;/h3&gt;
&lt;p&gt;该模式下 Kube-proxy 会为每一个 Service 创建一个监听端口。发向 Cluster IP 的请求被 Iptables 规则重定向到 Kube-proxy 监听的端口上，Kube-proxy 根据 LB 算法选择一个提供服务的 Pod 并和其建立链接，以将请求转发到 Pod 上。&lt;br&gt;
该模式下，Kube-proxy 充当了一个四层 Load balancer 的角色。由于 Kube-proxy 运行在 userspace 中，在进行转发处理时会增加两次内核和用户空间之间的数据拷贝，效率较另外两种模式低一些；好处是当后端的 Pod 不可用时，Kube-proxy 可以重试其他 Pod。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-userspace-模式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kube-proxy userspace 模式&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu004e566ffbb697606d214d97c7c998ef_173749_258d4c6b58c6c4521f1bbcd7367f27b7.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu004e566ffbb697606d214d97c7c998ef_173749_9cb85c216dcb7949a0277cb2a4e9c96c.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu004e566ffbb697606d214d97c7c998ef_173749_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu004e566ffbb697606d214d97c7c998ef_173749_258d4c6b58c6c4521f1bbcd7367f27b7.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kube-proxy userspace 模式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图片来自：&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;iptables-模式&#34;&gt;iptables 模式&lt;/h3&gt;
&lt;p&gt;为了避免增加内核和用户空间的数据拷贝操作，提高转发效率，Kube-proxy 提供了 iptables 模式。在该模式下，Kube-proxy 为 service 后端的每个 Pod 创建对应的 iptables 规则，直接将发向 Cluster IP 的请求重定向到一个 Pod IP。&lt;br&gt;
该模式下 Kube-proxy 不承担四层代理的角色，只负责创建 iptables 规则。该模式的优点是较 userspace 模式效率更高，但不能提供灵活的 LB 策略，当后端 Pod 不可用时也无法进行重试。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-iptables-模式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kube-proxy iptables 模式&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hua2531e630bdc8006015b2559d568efcc_213686_1be72a27081caba131a5f81c6608854b.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hua2531e630bdc8006015b2559d568efcc_213686_21265347f7e9647db3d7616e4074809c.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hua2531e630bdc8006015b2559d568efcc_213686_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hua2531e630bdc8006015b2559d568efcc_213686_1be72a27081caba131a5f81c6608854b.webp&#34;
               width=&#34;760&#34;
               height=&#34;526&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kube-proxy iptables 模式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图片来自：&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;ipvs-模式&#34;&gt;ipvs 模式&lt;/h3&gt;
&lt;p&gt;该模式和 iptables 类似，Kube-proxy 监控 Pod 的变化并创建相应的 ipvs rules。ipvs 也是在 kernel 模式下通过 netfilter 实现的，但采用了 hash table 来存储规则，因此在规则较多的情况下，Ipvs 相对 iptables 转发效率更高。除此以外，ipvs 支持更多的 LB 算法。如果要设置 Kube-proxy 为 ipvs 模式，必须在操作系统中安装 IPVS 内核模块。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-ipvs-模式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kube-proxy ipvs 模式&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hud3f3bc54abecdb13e6526c2355d0fa65_173996_c3e1d6f442f8f41b41265d563a1bf57a.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hud3f3bc54abecdb13e6526c2355d0fa65_173996_04f228eb72690b42be57168f95bd1ccb.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hud3f3bc54abecdb13e6526c2355d0fa65_173996_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hud3f3bc54abecdb13e6526c2355d0fa65_173996_c3e1d6f442f8f41b41265d563a1bf57a.webp&#34;
               width=&#34;760&#34;
               height=&#34;524&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kube-proxy ipvs 模式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图片来自：&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;istio-sidecar-proxy&#34;&gt;Istio Sidecar Proxy&lt;/h2&gt;
&lt;p&gt;Cluster IP 解决了服务之间相互访问的问题，但从上面 Kube-proxy 的三种模式可以看到，Cluster IP 的方式只提供了服务发现和基本的 LB 功能。如果要为服务间的通信应用灵活的路由规则以及提供 Metrics collection，distributed tracing 等服务管控功能，就必须得依靠 Istio 提供的服务网格能力了。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中部署 Istio 后，Istio 通过 iptables 和 Sidecar Proxy 接管服务之间的通信，服务间的相互通信不再通过 Kube-proxy，而是通过 Istio 的 Sidecar Proxy 进行。请求流程是这样的：Client 发起的请求被 iptables 重定向到 Sidecar Proxy，Sidecar Proxy 根据从控制面获取的服务发现信息和路由规则，选择一个后端的 Server Pod 创建连接，代理并转发 Client 的请求。&lt;/p&gt;
&lt;p&gt;Istio Sidecar Proxy 和 Kube-proxy 的 userspace 模式的工作机制类似，都是通过在用户空间的一个代理来实现客户端请求的转发和后端多个 Pod 之间的负载均衡。两者的不同点是：Kube-Proxy 工作在四层，而 Sidecar Proxy 则是一个七层代理，可以针对 HTTP，gRPC 等应用层的语义进行处理和转发，因此功能更为强大，可以配合控制面实现更为灵活的路由规则和服务管控功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-sidecar-proxy&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio Sidecar Proxy&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hucd3c3bc3c7bafc84039a0cee4ca4c566_55922_ce6ec5b399da16c115a57e739560ea4a.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hucd3c3bc3c7bafc84039a0cee4ca4c566_55922_dc5817ed09602b6c59e41cbed7493c02.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hucd3c3bc3c7bafc84039a0cee4ca4c566_55922_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hucd3c3bc3c7bafc84039a0cee4ca4c566_55922_ce6ec5b399da16c115a57e739560ea4a.webp&#34;
               width=&#34;636&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio Sidecar Proxy
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h1 id=&#34;如何从外部网络访问&#34;&gt;如何从外部网络访问&lt;/h1&gt;
&lt;p&gt;Kubernetes 的 Pod IP 和 Cluster IP 都只能在集群内部访问，而我们通常需要从外部网络上访问集群中的某些服务，Kubernetes 提供了下述几种方式来为集群提供外部流量入口。&lt;/p&gt;
&lt;h2 id=&#34;nodeport&#34;&gt;NodePort&lt;/h2&gt;
&lt;p&gt;NodePort 在集群中的主机节点上为 Service 提供一个代理端口，以允许从主机网络上对 Service 进行访问。Kubernetes 官网文档只介绍了 NodePort 的功能，并未对其实现原理进行解释。下面我们通过实验来分析 NodePort 的实现机制。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.katacoda.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;www.katacoda.com&lt;/a&gt; 这个网站提供了一个交互式的 Kubernetes playground，注册即可免费实验 Kubernetes 的相关功能，下面我们就使用 Katacoda 来分析 Nodeport 的实现原理。&lt;/p&gt;
&lt;p&gt;在浏览器中输入这个网址：https://www.katacoda.com/courses/kubernetes/networking-introduction，打开后会提供了一个实验用的 Kubernetes 集群，并可以通过网元模拟 Terminal 连接到集群的 Master 节点。&lt;/p&gt;
&lt;p&gt;执行下面的命令创建一个 nodeport 类型的 service。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ cat nodeport.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apiVersion: v1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kind: Service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  name: webapp1-nodeport-svc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  labels:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    app: webapp1-nodeport
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  type: NodePort
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ports:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  - port: &lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    nodePort: &lt;span class=&#34;m&#34;&gt;30080&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  selector:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    app: webapp1-nodeport
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apiVersion: extensions/v1beta1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kind: Deployment
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  name: webapp1-nodeport-deployment
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  replicas: &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  template:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      labels:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        app: webapp1-nodeport
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    spec:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      containers:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      - name: webapp1-nodeport-pod
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        image: katacoda/docker-http-server:latest
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ports:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - containerPort: &lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ kubectl apply -f nodeport.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看创建的 service，可以看到 Kubernetes 创建了一个名为 webapp-nodeport-svc 的 service，并为该 service 在主机节点上创建了 30080 这个 Nodeport。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ kubectl get svc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                   TYPE        CLUSTER-IP      EXTERNAL-IP   PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;        AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetes             ClusterIP   10.96.0.1       &amp;lt;none&amp;gt;        443/TCP        36m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;webapp1-nodeport-svc   NodePort    10.103.188.73   &amp;lt;none&amp;gt;        80:30080/TCP   3m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;webapp-nodeport-svc 后端对应两个 Pod，其 Pod 的 IP 分别为 10.32.0.3 和 10.32.0.5。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ kubectl get pod -o wide
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                                           READY     STATUS    RESTARTS   AGE       IPNODE      NOMINATED NODE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;webapp1-nodeport-deployment-785989576b-cjc5b   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          2m        10.32.0.3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;webapp1-nodeport-deployment-785989576b-tpfqr   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          2m        10.32.0.5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过 netstat 命令可以看到 Kube-proxy 在主机网络上创建了 30080 监听端口，用于接收从主机网络进入的外部流量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ netstat -lnp&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;grep &lt;span class=&#34;m&#34;&gt;30080&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcp6       &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;      &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; :::30080                :::*                    LISTEN      7427/Kube-proxy
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面是 Kube-proxy 创建的相关 iptables 规则以及对应的说明。可以看到 Kube-proxy 为 Nodeport 创建了相应的 IPtable 规则，将发向 30080 这个主机端口上的流量重定向到了后端的两个 Pod IP 上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;iptables-save &amp;gt; iptables-dump
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Generated by iptables-save v1.6.0 on Thu Mar 28 07:33:57 2019&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*nat
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Nodeport规则链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-NODEPORTS - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Service规则链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-SERVICES - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Nodeport和Service共用的规则链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-SVC-J2DWGRZTH4C2LPA4 - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-SEP-4CGFRVESQ3AECDE7 - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-SEP-YLXG4RMKAICGY2B3 - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 将host上30080端口的外部tcp流量转到KUBE-SVC-J2DWGRZTH4C2LPA4链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-NODEPORTS -p tcp -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -m tcp --dport &lt;span class=&#34;m&#34;&gt;30080&lt;/span&gt; -j KUBE-SVC-J2DWGRZTH4C2LPA4
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将发送到Cluster IP 10.103.188.73的内部流量转到KUBE-SVC-J2DWGRZTH4C2LPA4链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;KUBE-SERVICES -d 10.103.188.73/32 -p tcp -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc: cluster IP&amp;#34;&lt;/span&gt; -m tcp --dport &lt;span class=&#34;m&#34;&gt;80&lt;/span&gt; -j KUBE-SVC-J2DWGRZTH4C2LPA4
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将发送到webapp1-nodeport-svc的流量转交到第一个Pod（10.32.0.3）相关的规则链上，比例为50%&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-SVC-J2DWGRZTH4C2LPA4 -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-YLXG4RMKAICGY2B3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将发送到webapp1-nodeport-svc的流量转交到第二个Pod（10.32.0.5）相关的规则链上&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-SVC-J2DWGRZTH4C2LPA4 -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -j KUBE-SEP-4CGFRVESQ3AECDE7
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将请求重定向到Pod 10.32.0.3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-SEP-YLXG4RMKAICGY2B3 -p tcp -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -m tcp -j DNAT --to-destination 10.32.0.3:80
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将请求重定向到Pod 10.32.0.5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-SEP-4CGFRVESQ3AECDE7 -p tcp -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -m tcp -j DNAT --to-destination 10.32.0.5:80
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上面的实验可以看到，通过将一个 Service 定义为 NodePort 类型，Kubernetes 会通过集群中 node 上的 Kube-proxy 为该 Service 在主机网络上创建一个监听端口。Kube-proxy 并不会直接接收该主机端口进入的流量，而是会创建相应的 Iptables 规则，并通过 Iptables 将从该端口收到的流量直接转发到后端的 Pod 中。&lt;/p&gt;
&lt;p&gt;NodePort 的流量转发机制和 Cluster IP 的 iptables 模式类似，唯一不同之处是在主机网络上开了一个“NodePort”来接受外部流量。从上面的规则也可以看出，在创建 Nodeport 时，Kube-proxy 也会同时为 Service 创建 Cluster IP 相关的 iptables 规则。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：除采用 iptables 进行流量转发，NodePort 应该也可以提供 userspace 模式以及 ipvs 模式，这里未就这两种模式进行实验验证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从分析得知，在 NodePort 模式下，集群内外部的通讯如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-nodeport&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;NodePort&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu6e1f2811ddc8851efef39f1f43938ca9_64841_992e563a40bb3913a782ebd1cf5c5f67.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu6e1f2811ddc8851efef39f1f43938ca9_64841_7300066d32267b9dda170394d576eca2.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu6e1f2811ddc8851efef39f1f43938ca9_64841_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu6e1f2811ddc8851efef39f1f43938ca9_64841_992e563a40bb3913a782ebd1cf5c5f67.webp&#34;
               width=&#34;501&#34;
               height=&#34;408&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      NodePort
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;loadbalancer&#34;&gt;LoadBalancer&lt;/h2&gt;
&lt;p&gt;NodePort 提供了一种从外部网络访问 Kubernetes 集群内部 Service 的方法，但该方法存在下面一些限制，导致这种方式主要适用于程序开发，不适合用于产品部署。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes cluster host 的 IP 必须是一个 well-known IP，即客户端必须知道该 IP。但 Cluster 中的 host 是被作为资源池看待的，可以增加删除，每个 host 的 IP 一般也是动态分配的，因此并不能认为 host IP 对客户端而言是 well-known IP。&lt;/li&gt;
&lt;li&gt;客户端访问某一个固定的 host IP 的方式存在单点故障。假如一台 host 宕机了，Kubernetes cluster 会把应用 reload 到另一节点上，但客户端就无法通过该 host 的 nodeport 访问应用了。&lt;/li&gt;
&lt;li&gt;通过一个主机节点作为网络入口，在网络流量较大时存在性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决这些问题，Kubernetes 提供了 LoadBalancer。通过将 Service 定义为 LoadBalancer 类型，Kubernetes 在主机节点的 NodePort 前提供了一个四层的负载均衡器。该四层负载均衡器负责将外部网络流量分发到后面的多个节点的 NodePort 端口上。&lt;/p&gt;
&lt;p&gt;下图展示了 Kubernetes 如何通过 LoadBalancer 方式对外提供流量入口，图中 LoadBalancer 后面接入了两个主机节点上的 NodePort，后端部署了三个 Pod 提供服务。根据集群的规模，可以在 LoadBalancer 后面可以接入更多的主机节点，以进行负荷分担。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-nodebalancer&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;NodeBalancer&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_hu53579f5e7ac717c1b782bc46f1cba810_149526_fa353de61b6e1fdebc5d96f2ef87da93.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_hu53579f5e7ac717c1b782bc46f1cba810_149526_7069003261a3c1f2bc2dce546576fa77.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_hu53579f5e7ac717c1b782bc46f1cba810_149526_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_hu53579f5e7ac717c1b782bc46f1cba810_149526_fa353de61b6e1fdebc5d96f2ef87da93.webp&#34;
               width=&#34;760&#34;
               height=&#34;497&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      NodeBalancer
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：LoadBalancer 类型需要云服务提供商的支持，Service 中的定义只是在 Kubernetes 配置文件中提出了一个要求，即为该 Service 创建 Load Balancer，至于如何创建则是由 Google Cloud 或 Amazon Cloud 等云服务商提供的，创建的 Load Balancer 的过程不在 Kubernetes Cluster 的管理范围中。&lt;/p&gt;
&lt;p&gt;目前 AWS、Azure、CloudStack、GCE 和 OpenStack 等主流的公有云和私有云提供商都可以为 Kubernetes 提供 Load Balancer。一般来说，公有云提供商还会为 Load Balancer 提供一个 External IP，以提供 Internet 接入。如果你的产品没有使用云提供商，而是自建 Kubernetes Cluster，则需要自己提供 LoadBalancer。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ingress&#34;&gt;Ingress&lt;/h2&gt;
&lt;p&gt;LoadBalancer 类型的 Service 提供的是四层负载均衡器，当只需要向外暴露一个服务的时候，采用这种方式是没有问题的。但当一个应用需要对外提供多个服务时，采用该方式则要求为每一个四层服务（IP+Port）都创建一个外部 Load balancer。&lt;/p&gt;
&lt;p&gt;一般来说，同一个应用的多个服务/资源会放在同一个域名下，在这种情况下，创建多个 Load balancer 是完全没有必要的，反而带来了额外的开销和管理成本。另外直接将服务暴露给外部用户也会导致了前端和后端的耦合，影响了后端架构的灵活性，如果以后由于业务需求对服务进行调整会直接影响到客户端。&lt;/p&gt;
&lt;p&gt;在这种情况下，我们可以通过使用 Kubernetes Ingress 来统一网络入口。Kubernetes Ingress 声明了一个应用层（OSI 七层）的负载均衡器，可以根据 HTTP 请求的内容将来自同一个 TCP 端口的请求分发到不同的 Kubernetes Service，其功能包括：&lt;/p&gt;
&lt;h3 id=&#34;按-http-请求的-url-进行路由&#34;&gt;按 HTTP 请求的 URL 进行路由&lt;/h3&gt;
&lt;p&gt;同一个 TCP 端口进来的流量可以根据 URL 路由到 Cluster 中的不同服务，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-按-http-请求的-ulr-进行路由&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;按 HTTP 请求的 ULR 进行路由&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu0bf1b1d2f986925642d684d489b02f8e_67735_f6cb08f427bd8f34c7bfc79238e93df0.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu0bf1b1d2f986925642d684d489b02f8e_67735_eeb9aede9844807d6d64017d98331d43.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu0bf1b1d2f986925642d684d489b02f8e_67735_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu0bf1b1d2f986925642d684d489b02f8e_67735_f6cb08f427bd8f34c7bfc79238e93df0.webp&#34;
               width=&#34;575&#34;
               height=&#34;421&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      按 HTTP 请求的 ULR 进行路由
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;按-http-请求的-host-进行路由&#34;&gt;按 HTTP 请求的 Host 进行路由&lt;/h3&gt;
&lt;p&gt;同一个 IP 进来的流量可以根据 HTTP 请求的 Host 路由到 Cluster 中的不同服务，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-按-http-请求的-host-进行路由&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;按 HTTP 请求的 Host 进行路由&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu5e105bf886f0eb1c393c0a2d9fac8ee7_67380_ed58a288ea2fa9499f1b0b1604e5436d.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu5e105bf886f0eb1c393c0a2d9fac8ee7_67380_261281a773fb889597c435ac2a64c6b9.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu5e105bf886f0eb1c393c0a2d9fac8ee7_67380_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu5e105bf886f0eb1c393c0a2d9fac8ee7_67380_ed58a288ea2fa9499f1b0b1604e5436d.webp&#34;
               width=&#34;572&#34;
               height=&#34;442&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      按 HTTP 请求的 Host 进行路由
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Ingress 规则定义了对七层网关的要求，包括 URL 分发规则，基于不同域名的虚拟主机，SSL 证书等。Kubernetes 使用 Ingress Controller 来监控 Ingress 规则，并通过一个七层网关来实现这些要求，一般可以使用 Nginx，HAProxy，Envoy 等。&lt;/p&gt;
&lt;p&gt;虽然 Ingress Controller 通过七层网关为后端的多个 Service 提供了统一的入口，但由于其部署在集群中，因此并不能直接对外提供服务。实际上 Ingress 需要配合 NodePort 和 LoadBalancer 才能提供对外的流量入口，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用-ingress-nodeportal-和-loadbalancer-提供外部流量入口的拓扑结构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用 Ingress, NodePortal 和 LoadBalancer 提供外部流量入口的拓扑结构&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_huf359bd6ffc0630443f4803d51ab69f67_124888_727fd39cfd5efeda4d39ebf0a26df55a.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_huf359bd6ffc0630443f4803d51ab69f67_124888_c8fc00eb41acd10570c25f0ba86bb514.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_huf359bd6ffc0630443f4803d51ab69f67_124888_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_huf359bd6ffc0630443f4803d51ab69f67_124888_727fd39cfd5efeda4d39ebf0a26df55a.webp&#34;
               width=&#34;760&#34;
               height=&#34;580&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用 Ingress, NodePortal 和 LoadBalancer 提供外部流量入口的拓扑结构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上图描述了如何采用 Ingress 配合 NodePort 和 Load Balancer 为集群提供外部流量入口，从该拓扑图中可以看到该架构的伸缩性非常好，在 NodePort，Ingress，Pod 等不同的接入层面都可以对系统进行水平扩展，以应对不同的外部流量要求。&lt;/p&gt;
&lt;p&gt;上图只展示了逻辑架构，下面的图展示了具体的实现原理：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用-ingress-nodeportal-和-loadbalancer-提供外部流量入口的实现原理&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用 Ingress, NodePortal 和 LoadBalancer 提供外部流量入口的实现原理&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu4535170da61800f13d65ecbf23400376_133379_5a63790dab6a94e405ff4a1c1db8f668.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu4535170da61800f13d65ecbf23400376_133379_7e9bffcc8deb5a0e4ead361a750fcf38.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu4535170da61800f13d65ecbf23400376_133379_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu4535170da61800f13d65ecbf23400376_133379_5a63790dab6a94e405ff4a1c1db8f668.webp&#34;
               width=&#34;518&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用 Ingress, NodePortal 和 LoadBalancer 提供外部流量入口的实现原理
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;流量从外部网络到达 Pod 的完整路径如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;外部请求先通过四层 Load Balancer 进入内部网络&lt;/li&gt;
&lt;li&gt;Load Balancer 将流量分发到后端多个主机节点上的 NodePort (userspace 转发)&lt;/li&gt;
&lt;li&gt;请求从 NodePort 进入到 Ingress Controller (iptabes 规则，Ingress Controller 本身是一个 NodePort 类型的 Service)&lt;/li&gt;
&lt;li&gt;Ingress Controller 根据 Ingress rule 进行七层分发，根据 HTTP 的 URL 和 Host 将请求分发给不同的 Service (userspace 转发)&lt;/li&gt;
&lt;li&gt;Service 将请求最终导入到后端提供服务的 Pod 中 (iptabes 规则)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从前面的介绍可以看到，K8S Ingress 提供了一个基础的七层网关功能的抽象定义，其作用是对外提供一个七层服务的统一入口，并根据 URL/HOST 将请求路由到集群内部不同的服务上。&lt;/p&gt;
&lt;h1 id=&#34;如何为服务网格选择入口网关&#34;&gt;如何为服务网格选择入口网关？&lt;/h1&gt;
&lt;p&gt;在 Istio 服务网格中，通过为每个 Service 部署一个 sidecar 代理，Istio 接管了 Service 之间的请求流量。控制面可以对网格中的所有 sidecar 代理进行统一配置，实现了对网格内部流量的路由控制，从而可以实现灰度发布，流量镜像，故障注入等服务管控功能。但是，Istio 并没有为入口网关提供一个较为完善的解决方案。&lt;/p&gt;
&lt;h2 id=&#34;k8s-ingress&#34;&gt;K8s Ingress&lt;/h2&gt;
&lt;p&gt;在 0.8 版本以前，Istio 缺省采用 K8s Ingress 来作为 Service Mesh 的流量入口。K8s Ingress 统一了应用的流量入口，但存在两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;K8s Ingress 是独立在 Istio 体系之外的，需要单独采用 Ingress rule 进行配置，导致系统入口和内部存在两套互相独立的路由规则配置，运维和管理较为复杂。&lt;/li&gt;
&lt;li&gt;K8s Ingress rule 的功能较弱，不能在入口处实现和网格内部类似的路由规则，也不具备网格 sidecar 的其它能力，导致难以从整体上为应用系统实现灰度发布、分布式跟踪等服务管控功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用-kubernetes-ingress-作为服务网格的流量入口&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用 Kubernetes Ingress 作为服务网格的流量入口&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_hubc2aba9431228d923fffdab87b3c9d23_72021_d5c3c8e21cf3b0e70f22460315c6ac1a.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_hubc2aba9431228d923fffdab87b3c9d23_72021_5d9189928ea684c48392160404ffeade.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_hubc2aba9431228d923fffdab87b3c9d23_72021_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_hubc2aba9431228d923fffdab87b3c9d23_72021_d5c3c8e21cf3b0e70f22460315c6ac1a.webp&#34;
               width=&#34;760&#34;
               height=&#34;346&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用 Kubernetes Ingress 作为服务网格的流量入口
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;istio-gateway&#34;&gt;Istio Gateway&lt;/h2&gt;
&lt;p&gt;Istio 社区意识到了 Ingress 和 Mesh 内部配置割裂的问题，因此从 0.8 版本开始，社区采用了 Gateway 资源代替 K8s Ingress 来表示流量入口。&lt;/p&gt;
&lt;p&gt;Istio Gateway 资源本身只能配置 L4-L6 的功能，例如暴露的端口，TLS 设置等；但 Gateway 可以和绑定一个 VirtualService，在 VirtualService 中可以配置七层路由规则，这些七层路由规则包括根据按照服务版本对请求进行导流，故障注入，HTTP 重定向，HTTP 重写等所有 Mesh 内部支持的路由规则。&lt;/p&gt;
&lt;p&gt;Gateway 和 VirtualService 用于表示 Istio Ingress 的配置模型，Istio Ingress 的缺省实现则采用了和 Sidecar 相同的 Envoy proxy。&lt;/p&gt;
&lt;p&gt;通过该方式，Istio 控制面用一致的配置模型同时控制了入口网关和内部的 sidecar 代理。这些配置包括路由规则，策略检查、Telementry 收集以及其他服务管控功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用-istio-ingress-gateway-作为服务网格的流量入口&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用 Istio Ingress Gateway 作为服务网格的流量入口&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu39d55e73a319f81f74377a388a98b6d1_95311_711aeb1be0ab812cf7a26533d9eee35d.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu39d55e73a319f81f74377a388a98b6d1_95311_d7a398ea58d5e260fae61ca30efcde12.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu39d55e73a319f81f74377a388a98b6d1_95311_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu39d55e73a319f81f74377a388a98b6d1_95311_711aeb1be0ab812cf7a26533d9eee35d.webp&#34;
               width=&#34;737&#34;
               height=&#34;443&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用 Istio Ingress Gateway 作为服务网格的流量入口
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;应用对-api-gateway-的需求&#34;&gt;应用对 API Gateway 的需求&lt;/h2&gt;
&lt;p&gt;采用 Gateway 和 VirtualService 实现的 Istio Ingress Gateway 提供了网络入口处的基础通信功能，包括可靠的通信和灵活的路由规则。但对于一个服务化应用来说，网络入口除了基础的通讯功能之外，还有一些其他的应用层功能需求，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三方系统对 API 的访问控制&lt;/li&gt;
&lt;li&gt;用户对系统的访问控制&lt;/li&gt;
&lt;li&gt;修改请求/返回数据&lt;/li&gt;
&lt;li&gt;服务 API 的生命周期管理&lt;/li&gt;
&lt;li&gt;服务访问的 SLA、限流及计费&lt;/li&gt;
&lt;li&gt;….&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kubernetes-ingress-istio-gateway-and-api-gateway-的功能对比&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kubernetes ingress, Istio gateway and API gateway 的功能对比&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu764b17e734bab8fed08e1cda54902d8f_204376_178de5a1eb415d849fdf76625ad5d50d.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu764b17e734bab8fed08e1cda54902d8f_204376_01aac67f9e108c35276843178888b59d.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu764b17e734bab8fed08e1cda54902d8f_204376_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu764b17e734bab8fed08e1cda54902d8f_204376_178de5a1eb415d849fdf76625ad5d50d.webp&#34;
               width=&#34;760&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kubernetes ingress, Istio gateway and API gateway 的功能对比
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;API Gateway 需求中很大一部分需要根据不同的应用系统进行定制，目前看来暂时不大可能被纳入 K8s Ingress 或者 Istio Gateway 的规范之中。为了满足这些需求，涌现出了各类不同的 k8s Ingress Controller 以及 Istio Ingress Gateway 实现，包括 Ambassador、Kong、Traefik、Solo 等。&lt;/p&gt;
&lt;p&gt;这些网关产品在实现在提供基础的 K8s Ingress 能力的同时，提供了强大的 API Gateway 功能，但由于缺少统一的标准，这些扩展实现之间相互之间并不兼容。而且遗憾的是，目前这些 Ingress controller 都还没有正式提供和 Istio 控制面集成的能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ambassador 将对 Istio 路由规则的支持纳入了 Roadmap &lt;a href=&#34;https://www.getambassador.io/user-guide/with-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.getambassador.io/user-guide/with-istio/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Istio 声称支持 Istio-Based Route Rule Discovery (尚处于实验阶段) &lt;a href=&#34;https://gloo.solo.io/introduction/architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://gloo.solo.io/introduction/architecture/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;采用-api-gateway--sidecar-proxy-作为服务网格的流量入口&#34;&gt;采用 API Gateway + Sidecar Proxy 作为服务网格的流量入口&lt;/h2&gt;
&lt;p&gt;在目前难以找到一个同时具备 API Gateway 和 Istio Ingress 能力的网关的情况下，一个可行的方案是使用 API Gateway 和 Sidecar Proxy 一起为服务网格提供外部流量入口。&lt;/p&gt;
&lt;p&gt;由于 API Gateway 已经具备七层网关的功能，Mesh Ingress 中的 Sidecar 只需要提供 VirtualService 资源的路由能力，并不需要提供 Gateway 资源的网关能力，因此采用 Sidecar Proxy 即可。网络入口处的 Sidecar Proxy 和网格内部应用 Pod 中 Sidecar Proxy 的唯一一点区别是：该 Sidecar 只接管 API Gateway 向 Mesh 内部的流量，并不接管外部流向 API Gateway 的流量；而应用 Pod 中的 Sidecar 需要接管进入应用的所有流量。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用-api-gateway--sidecar-proxy-为服务网格提供流量入口&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用 API Gateway &amp;#43; Sidecar Proxy 为服务网格提供流量入口&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu46b796a40221c3a084a48e1733e26d44_109547_da9dbac348bc0a5a4838f5bd9c5e20d6.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu46b796a40221c3a084a48e1733e26d44_109547_e60e3959167108abc36feb709f2c4219.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu46b796a40221c3a084a48e1733e26d44_109547_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu46b796a40221c3a084a48e1733e26d44_109547_da9dbac348bc0a5a4838f5bd9c5e20d6.webp&#34;
               width=&#34;760&#34;
               height=&#34;383&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用 API Gateway &amp;#43; Sidecar Proxy 为服务网格提供流量入口
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：在实际部署时，API Gateway 前端需要采用 NodePort 和 LoadBalancer 提供外部流量入口。为了突出主题，对上图进行了简化，没有画出 NodePort 和 LoadBalancer。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;采用 API Gateway 和 Sidecar Proxy 一起作为服务网格的流量入口，既能够通过对网关进行定制开发满足产品对 API 网关的各种需求，又可以在网络入口处利用服务网格提供的灵活的路由能力和分布式跟踪，策略等管控功能，是服务网格产品入口网关的一个理想方案。&lt;/p&gt;
&lt;p&gt;性能方面的考虑：从上图可以看到，采用该方案后，外部请求的处理流程在入口处增加了 Sidecar Proxy 这一跳，因此该方式会带来少量的性能损失，但该损失是完全可以接受的。&lt;/p&gt;
&lt;p&gt;对于请求时延而言，在服务网格中，一个外部请求本来就要经过较多的代理和应用进程的处理，在 Ingress 处增加一个代理对整体的时延影响基本忽略不计，而且对于绝大多数应用来说，网络转发所占的时间比例本来就很小，99% 的耗时都在业务逻辑。如果系统对于增加的该时延非常敏感，则建议重新考虑该系统是否需要采用微服务架构和服务网格。&lt;/p&gt;
&lt;p&gt;对于吞吐量而言，如果入口处的网络吞吐量存在瓶颈，则可以通过对 API Gateway + Sidecar Proxy 组成的 Ingress 整体进行水平扩展，来对入口流量进行负荷分担，以提高网格入口的网络吞吐量。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&#34;ref01&#34;&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Virtual IPs and Service Proxie - kubernetes.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhaohuabing.com/2017/11/28/access-application-from-outside/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如何从外部访问 Kubernetes 集群中的应用？ - zhaohuabing.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhaohuabing.com/post/2018-12-27-the-obstacles-to-put-istio-into-production/#service-mesh-and-api-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The obstacles to put Istio into production and how we solve them - kubernetes.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes NodePort vs LoadBalancer vs Ingress? When should I use what? - medium.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway 的身份认同危机</title>
      <link>https://cloudnative.to/blog/api-gateways-are-going-through-an-identity-crisis/</link>
      <pubDate>Mon, 13 May 2019 20:08:37 +0800</pubDate>
      <guid>https://cloudnative.to/blog/api-gateways-are-going-through-an-identity-crisis/</guid>
      <description>&lt;p&gt;如今，API 网关经历了一系列&lt;a href=&#34;https://en.wikipedia.org/wiki/Identity_crisis&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;身份认同危机&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们是集中式共享资源，有助于将 API 暴露和维护到外部实体吗？&lt;/li&gt;
&lt;li&gt;它们是否为集群的 ingress 哨兵，严格控制用户流量在集群的进出？&lt;/li&gt;
&lt;li&gt;或它们是否为某类 API 的集成，以便更简洁地表达 API，具体取决于它所具有的客户端类型？&lt;/li&gt;
&lt;li&gt;当然还有不愿多谈但我经常听到的一个问题：&amp;ldquo;服务网格是否会使 API 网关过时？&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;有关背景&#34;&gt;有关背景&lt;/h2&gt;
&lt;p&gt;随着技术的快速发展，以及行业在技术和架构模式中的快速发展，你会想到&amp;quot;这一切都让我头晕目眩&amp;quot;。在这篇文章中，我希望简化&amp;quot;API 网关&amp;quot;的不同身份，澄清组织中哪些组可能使用 API 网关（他们试图解决的问题），并重新关注第一原则。理想情况下，在本文结束时，您将更好地了解不同团队在不同层面的 API 架构的作用，以及如何从每个层面中获取最大价值。&lt;/p&gt;
&lt;p&gt;在我们深入研究之前，让我们对 API 这个术语非常清楚。&lt;/p&gt;
&lt;h2 id=&#34;我对-api-的定义&#34;&gt;我对 API 的定义：&lt;/h2&gt;
&lt;p&gt;一种明确且有目的地定义的接口，旨在通过网络调用，使软件开发人员能够以受控且舒适的方式对组织内的数据和功能进行编程访问。&lt;/p&gt;
&lt;p&gt;这些接口抽象了实现它们的技术基础结构的细节。对于这些设计好的端点，我们期望能有些一定程度的文档，例如使用指南，稳定性报告和向后兼容性。&lt;/p&gt;
&lt;p&gt;相反，仅仅因为我们可以通过网络与另一个软件通信并不一定意味着远程端点是这个定义好的 API。许多系统彼此通信，往往这种通信更加随意地发生，并且通过耦合和其他因素进行实时交互。&lt;/p&gt;
&lt;p&gt;我们创建 API 以提供对业务部分的深思熟虑的抽象，并实现新的业务功能以及偶发创新。&lt;/p&gt;
&lt;p&gt;在讨论 API 网关时首先列出的是 API 管理。&lt;/p&gt;
&lt;h2 id=&#34;api-管理&#34;&gt;API 管理&lt;/h2&gt;
&lt;p&gt;很多人都在 API 管理方面考虑 API 网关。这是合理的。但是让我们快速了解一下 API 网关到底是做什么的。&lt;/p&gt;
&lt;p&gt;通过&lt;a href=&#34;https://en.wikipedia.org/wiki/API_management&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Management&lt;/a&gt;，我们希望解决：当我们希望公开现有 API 以供其他人使用时，如何跟踪谁使用这些 API，实施允许谁使用这些 API 的策略，建立安全流以进行身份​​验证和授权允许，使用并构建可在设计时使用的服务目录，以促进 API 使用并为有效治理奠定基础。&lt;/p&gt;
&lt;p&gt;我们希望解决：现有的，规划好的 API，我们希望按照我们的条款分享给他人的问题。&lt;/p&gt;
&lt;p&gt;API 管理还可以很好地允许用户（潜在 API 消费者）自助服务，注册不同的 API 消费计划（想一想：指定价格点在给定时间范围内每个端点的每个用户的呼叫数）。我们能够实施这些管理功能的基础设施是我们的 API 流量通过的网关。在这一点上，我们可以执行诸如身份认证，流量限速，指标采集，以及其他策略执行操作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-management-sketch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;利用 API 网关的 API 管理软件示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://apigee.com/api-management/#/homepage&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Apigee&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.3scale.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat 3Scale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mulesoft.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mulesoft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://konghq.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个层面上，我们考虑 API（如上所述）以及如何最好地管理和允许访问它们。我们没有考虑服务器，主机，端口，容器甚至服务（另一个定义不明确的词，但你理解我的！）。&lt;/p&gt;
&lt;p&gt;API 管理（以及它们相应的网关）通常实现为由&amp;quot;平台团队&amp;quot;，&amp;ldquo;集成团队&amp;quot;或其他 API 基础架构团队拥有的严格控制的共享基础架构。通常这样做是为了强制执行一定程度的治理，变更管理和策略。在某些情况下，即使这些基础架构集中部署和管理，它们也可能支持更分散的物理部署。例如，Kong 的首席技术官 Marco Palladino 在评论中指出，Kong 可以选择部署的组件来支持集中式或分布式模型。&lt;/p&gt;
&lt;p&gt;有一点需要注意：我们要注意不要让任何业务逻辑进入这一层。如前一段所述，API 管理是共享基础架构，但由于我们的 API 流量通过它，它倾向于重造&amp;quot;全知全能&amp;rdquo;（思考企业服务总线）治理门户，为通过它，我们必须全盘改造我们的服务。理论上这听起来很棒。实际上，这可能最终成为组织瓶颈。有关更多信息，请参阅此文章：&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Network Functions with ESBs, API Management, and Now… Service Mesh?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;集群入口&#34;&gt;集群入口&lt;/h2&gt;
&lt;p&gt;为了构建和实现 API，我们专注于代码，数据，业务框架等方面。但是，要让这些的东西提供价值，必须对它们进行测试，部署到生产环境中并进行监控。当我们开始部署到云原生平台时，我们开始基于部署，容器，服务，主机，端口等考虑，以便构建我们的应用程序适应该环境。我们大概还需要制作工作流程（CI）和管道（CD），以利用云平台快速迭代，将其提供给客户等。&lt;/p&gt;
&lt;p&gt;在这种环境中，我们可以构建和维护多个集群来托管我们的应用程序，并需要某种方式来访问这些集群内的应用程序和服务。以 Kubernetes 为例。我们可以使用&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Ingress controller&lt;/a&gt;来允许访问 Kubernetes 集群（集群中的其他所有内容都无法从外部访问）。通过这种方式，我们可以非常严格地控制流量可能进入（甚至离开）我们的集群，具有明确定义的入口点，如域名/虚拟 hosts，端口，协议等。&lt;/p&gt;
&lt;p&gt;在这个层面中，我们可能希望某种&amp;quot;&lt;a href=&#34;https://istio.io/docs/tasks/traffic-management/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ingress gateway&lt;/a&gt;&amp;ldquo;成为允许请求和消息进入集群的流量哨兵。在这个层面中，你需要更多考虑的是：&amp;ldquo;我在我的集​​群中有这项服务，我需要集群外部的人能够调用它&amp;rdquo;。这可能是一个服务（暴露 API），一个系统整体，一个 gRPC 服务，一个缓存，一个消息队列，一个数据库等。有些人选择将其称为 API 网关，其中的一些可能实际上做得比流量入口/出口更多，但重点是问题存在于集群级操作上。由于我们倾向于部署更多集群（相对于单个高度多租户集群），我们最终会有更多网络入口点和彼此交互的需求。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/cluster-ingress-sketch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些类型的入口实现的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Envoy Proxy and projects that build upon it including:
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.getambassador.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Datawire Ambassador&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io Gloo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/heptio/contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heptio Contour&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HAProxy
&lt;ul&gt;
&lt;li&gt;Including &lt;a href=&#34;https://docs.openshift.com/container-platform/3.9/install_config/router/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenShift’s Router&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/ingress-nginx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NGINX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://traefik.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Kong/kubernetes-ingress-controller&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此层面的集群入口控制器由平台团队管理，但是这个基础架构通常与更分散的自助服务工作流程相关联（正如您期望从云原生平台那样）。请参阅&lt;a href=&#34;https://www.weave.works/blog/gitops-operations-by-pull-request&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;See the &amp;ldquo;GitOps&amp;rdquo; workflow as described by the good folks at Weaveworks&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;api-gateway-模式&#34;&gt;API Gateway 模式&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;API 网关&amp;quot;这一术语的另一重意思才是我最开始理解的，即它是最接近 API Gateway 模式的那个。 &lt;a href=&#34;https://www.chrisrichardson.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chris Richardson&lt;/a&gt;在第 8 章的&amp;rdquo;&amp;quot;&lt;a href=&#34;https://microservices.io/book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务设计模式&lt;/a&gt;&amp;ldquo;&amp;ldquo;一书中做了很好的工作。我强烈建议将该书用作本文和其他微服务模式的教学。在他的&lt;a href=&#34;https://microservices.io/patterns/apigateway.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;microservices.io&lt;/a&gt;网站可以上略扫一下即可知，API Gateway 模式，简而言之，是关于策划 API 以便更好地使用不同类别的消费者。此策略涉及 API 间接级别。您可能听到的代表 API Gateway 模式的另一个术语是&amp;quot;服务于前端的后端&amp;rdquo;，其中&amp;quot;前端&amp;quot;可以是单纯前端界面（UI），移动客户端，物联网客户端，甚至是其他服务/应用开发人员。&lt;/p&gt;
&lt;p&gt;在 API Gateway 模式中，我们明确简化了一组 API 的调用，以模拟特定用户，客户或消费者的&amp;quot;应用程序&amp;quot;的内聚 API。回想一下，当我们使用微服务来构建我们的系统时，&amp;ldquo;应用程序&amp;quot;的概念就会消失。API Gateway 模式有助于重塑此概念。这里的关键在于 API 网关，当它实现时，它成为客户端和应用程序的 API，并负责与任何后端 API 和其他应用程序网络端点（那些不符合上述 API 定义的端点）进行通信。&lt;/p&gt;
&lt;p&gt;与上一节中的 Ingress 控制器不同，此 API 网关更接近于开发人员的全局视图，并且不太关注为集群外消耗而暴露的端口或服务。这个&amp;quot;API Gateway&amp;quot;也不同于我们对已有 API 的进行管理所用的 API 管理观念。这个 API 网关掩盖了对可能暴露 API 的后端的调用，但是也可能会谈到较少描述为 API 的事情，例如对旧系统的 RPC 调用，使用不符合&amp;quot;REST&amp;quot;式优雅的协议调用，例如 JSON over HTTP，gRPC，SOAP，GraphQL，websockets 和消息队列这些黑科技。还可以调用这种类型的网关来进行消息级转换，复杂路由，网络负载均衡/回调以及响应的集成。&lt;/p&gt;
&lt;p&gt;如果您熟悉&lt;a href=&#34;https://www.crummy.com/writing/speaking/2008-QCon/act3.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Richardson 的 REST API 的成熟度模型&lt;/a&gt;，那么实现 API Gateway 模式的 API 网关会被要求集成更多的 Level 0 请求（以及介于两者之间的所有内容）而不是 Level 1-3 实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/richardson-model.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://martinfowler.com/articles/richardsonMaturityModel.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://martinfowler.com/articles/richardsonMaturityModel.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这些类型的网关实现仍然需要解决诸如速率限制，认证/授权，熔断，指标采集，流量路由等一类的事情。这些类型的网关可以在集群的边缘用作集群入口控制器，也可以在集群的深处用作应用程序网关。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-gateway-pattern.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此类 API 网关的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://spring.io/projects/spring-cloud-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud Gateway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io Gloo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Netflix/zuul&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix Zuul&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://strongloop.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM-Strongloop Loopback/Microgateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种类型的网关也可以使用更通用的编程或集成语言/框架来构建，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache Camel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io/projects/spring-integration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Integration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ballerina.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ballerina.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://vertx.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Eclipse Vert.x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/en/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NodeJS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于这种类型的 API 网关与应用程序和服务的开发密切相关，我们希望开发人员能够参与、帮助指定 API 网关公开的 API，了解所涉及的任何 mashup 逻辑以及需要能够快速测试和更改此 API 基础结构。我们还希望操作或 SRE 对 API 网关的安全性，弹性和可观察性配置有一些看法。此级别的基础架构还必须适应不断发展的按需自助服务开发人员工作流程。再次参见 GitOps 模型以获取更多信息。&lt;/p&gt;
&lt;h2 id=&#34;谈到服务网格&#34;&gt;谈到服务网格&lt;/h2&gt;
&lt;p&gt;在云基础架构上运行服务架构的一部分包括难以在网络中构建适当级别的可观察性和控制。在解决此问题的先前迭代中，&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们使用应用程序库和有希望的开发人员治理来实现此目的&lt;/a&gt;。然而，在规模和多语言环境中，&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格技术的出现提供了更好的解决方案&lt;/a&gt;。服务网格通过透明实现为平台及其组成服务带来以下功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务到服务（即东西流量）的恢复能力&lt;/li&gt;
&lt;li&gt;安全性包括最终用户验证，双向 TLS，服务到服务 RBAC / ABAC&lt;/li&gt;
&lt;li&gt;黑盒服务可观察性（专注于网络通信），用于请求/秒，请求延迟，请求失败，熔断事件，分布式跟踪等&lt;/li&gt;
&lt;li&gt;服务到服务速率限制，配额执行等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;精明的读者会认识到，&lt;a href=&#34;https://dzone.com/articles/api-gateway-vs-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 网关和服务网格的功能似乎有些重叠&lt;/a&gt;。服务网格的目标是通过在 L7 上透明地解决任何服务/应用程序来解决这些问题。换句话说，服务网格希望融入服务（实际上没有被编码到服务的代码中）。另一方面，API 网关位于服务网格和应用程序之上（L8？）。服务网格为服务，主机，端口，协议等（东/西流量）之间的请求流带来价值。它们还可以提供基本的集群入口功能，以便为北/南流量带来一些此功能。但是，这不应与 API 网关可以为南北向流量带来的功能相混淆（如在集群的北/南和向应用程序或应用程序组的北/南）。&lt;/p&gt;
&lt;p&gt;服务网格和 API 网关在某些领域的功能上重叠，但它们是互补的，因为它们生活在不同的层次并解决不同的问题。理想的解决方案是将每个组件（API Management，API Gateway，Service Mesh）即插即用，并在需要时在组件之间保持良好的界限（或者在不需要它们时将其排除）。同样重要的是找到&lt;a href=&#34;https://developer.ibm.com/apiconnect/2018/12/10/api-management-centralized-or-decentralized/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;适合您的分散开发人员和操作工作流程&lt;/a&gt;的这些工具的实现。尽管这些不同组成部分的术语和身份存在混淆，但我们应该依赖于第一原则并理解我们的架构中这些组件在何处带来价值以及它们如何独立存在并共存互补性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-layers.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;我们很乐意帮忙&#34;&gt;我们很乐意帮忙！&lt;/h2&gt;
&lt;p&gt;一些读者可能知道我热衷于帮助人们，特别是在云，微服务，事件驱动架构和服务网络领域。在我的公司，&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;，我们正在帮助 IT 组织认识并成功采用适当级别的网关和服务网格等 API 技术，以及他们成功优化它们的速度（更重要的是，他们确实需要这些技术！！）。我们在&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Proxy&lt;/a&gt;，&lt;a href=&#34;https://graphql.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GraphQL&lt;/a&gt;和&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;等技术的基础上构建了&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;，&lt;a href=&#34;https://sqoop.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Scoop&lt;/a&gt;和&lt;a href=&#34;https://supergloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SuperGloo&lt;/a&gt;等工具，以帮助实现 API 网关和服务网格管理。请直接联系我们（&lt;a href=&#34;https://twitter.com/soloio_inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@soloio_inc&lt;/a&gt;，&lt;a href=&#34;http://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http：//solo.io&lt;/a&gt;）或直接与我联系（&lt;a href=&#34;http://www.twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt;，&lt;a href=&#34;http://blog.christianposta.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;），深入了解我们的愿景以及我们的技术如何为您的组织提供帮助。在下一系列博客中，我们将深入探讨 API Gateway 模式，多集群场景的难点，多服务网格的难点等！敬请关注！&lt;/p&gt;
&lt;h2 id=&#34;相关阅读&#34;&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
