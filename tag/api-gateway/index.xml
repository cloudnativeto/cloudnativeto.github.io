<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>API Gateway | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/tag/api-gateway/</link>
      <atom:link href="https://cloudnativecn.com/tag/api-gateway/index.xml" rel="self" type="application/rss+xml" />
    <description>API Gateway</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Mon, 01 Jan 2024 11:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/media/sharing.png</url>
      <title>API Gateway</title>
      <link>https://cloudnativecn.com/tag/api-gateway/</link>
    </image>
    
    <item>
      <title>2024 年 API 管理趋势预测</title>
      <link>https://cloudnativecn.com/blog/what-will-be-the-api-management-trends-for-2024/</link>
      <pubDate>Mon, 01 Jan 2024 11:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/what-will-be-the-api-management-trends-for-2024/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://thenewstack.io/what-will-be-the-api-management-trends-for-2024/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;What Will Be the API Management Trends for 2024?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们已经审视了 2023 年的发展，并确定了几个可能在明年主导 API 管理领域的关键趋势。&lt;/p&gt;
&lt;p&gt;根据一个想法：API 完全控制了数字世界，预测到本十年结束时，API 管理市场将增长六倍。&lt;/p&gt;
&lt;p&gt;随着越来越多的公司转向 API 为先的架构，API 管理的需求变得至关重要。一家组织可能会管理数百甚至数千个微服务，它们需要工具来有效地编排和监控这些 API。&lt;/p&gt;
&lt;p&gt;因此，随着这种增长的开始，API 管理在未来会带来什么？我们已经审视了 2023 年的发展，并确定了几个可能在 2024 年主导 API 管理领域的关键趋势。&lt;/p&gt;
&lt;h2 id=&#34;是时候实行零信任了这并不是坏事&#34;&gt;是时候实行零信任了（这并不是坏事！）&lt;/h2&gt;
&lt;p&gt;随着 API 的不断增加，安全漏洞、黑客和 API 问题的风险也在增加。将零信任安全概念与你的 API 战略结合起来，倡导一种安全模型，其中不管交互发生在网络边界内还是外部，都不会假定信任。&lt;/p&gt;
&lt;p&gt;这种方法要求对每个试图访问网络内资源的个人和设备进行严格的身份验证，有效地消除了传统的受信任的内部网络概念。在数据泄露和恶意行为者变得越来越复杂的时代，采用零信任框架对于全面的安全至关重要，包括 API、云服务和网络基础设施在内的所有技术方面。&lt;/p&gt;
&lt;p&gt;在 API 管理领域，API 网关在实施零信任架构中起着关键作用。作为第一道防线，这些网关对每个 API 请求执行严格的身份验证和授权策略。它们负责验证凭据，管理访问令牌，并确保每个请求，无论来自组织内部还是外部，都要经过相同严格的安全检查。&lt;/p&gt;
&lt;p&gt;在这个框架中，API 网关不仅仅是流量管理器；它们是安全姿态的一部分，将零信任原则嵌入到 API 交互的核心。它们帮助构建适应持续风险评估、基于上下文的访问控制和深度监控 API 使用模式的动态安全策略。&lt;/p&gt;
&lt;p&gt;在零信任模型中，API 网关演变为安全执行者，对流经 API 的数据的完整性和机密性至关重要。这种演变强调了高级 API 管理工具在维护零信任原则和确保安全和弹性基础设施方面的重要性。&lt;/p&gt;
&lt;h2 id=&#34;多体验架构将成为常态&#34;&gt;“多体验架构”将成为常态&lt;/h2&gt;
&lt;p&gt;随着 2024 年 Gartner 的“多体验架构”概念变得越来越普遍，API 管理的复杂性将升级。组织不再只处理一种类型的 API；他们在同一应用生态系统中处理多种协议和架构。这种情况是现代应用多样性的结果，这些应用不仅包括基于 Web 的门户和本机移动应用，还包括扩展，如手表应用、实时对话界面和人工智能集成。&lt;/p&gt;
&lt;p&gt;每个组件都需要特定的 API 方法。通常情况下，REST API 在外部通信中因其简单性和通用性而受欢迎，而 gRPC 由于其效率和速度而可能被选择用于内部服务通信。与此同时，GraphQL 因其创建联合图和子图的能力而越来越多地用于高度灵活和高效的数据检索，这对于复杂的客户端应用程序是必不可少的。此外，消息代理对于实现需要立即数据更新和交互的应用程序的实时通信至关重要。&lt;/p&gt;
&lt;p&gt;在这种环境下，API 管理的挑战是多方面的。它涉及编排不同类型的 API 并确保在这些不同的架构中实现无缝集成、一致的安全执行和有效的性能监控。解决方案在于高级 API 管理工具和网关，它们能够处理这种多样性。这些工具必须提供复杂的功能，如协议转换、统一的安全策略和可以适应每种 API 类型的独特需求的分析。&lt;/p&gt;
&lt;p&gt;因此，2024 年的 API 管理将涉及到拥抱和管理这种复杂性，提供一个有凝聚力和高效率的框架，支持多体验架构的各种需求。&lt;/p&gt;
&lt;h2 id=&#34;api-管理正在变成组织管理&#34;&gt;API 管理正在变成组织管理&lt;/h2&gt;
&lt;p&gt;有一个著名的故事，来自前亚马逊和谷歌工程师 Steve Yegge，讲述了 Jeff Bezos 在 2002 年在亚马逊网络服务（AWS）制定的一项核心任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;所有团队将通过服务接口公开其数据和功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;团队必须通过这些接口相互通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不允许其他形式的进程间通信：不允许直接链接，不允许直接读取另一个团队的数据存储，不允许共享内存模型，也不允许任何后门。唯一允许的通信是通过网络上的服务接口调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无论他们使用什么技术。HTTP、Corba、Pubsub、自定义协议——都无所谓。贝佐斯不关心。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有服务接口，没有例外，必须从头开始设计，以便能够将接口暴露给外部世界的开发人员。不允许例外。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不这样做的人将被解雇。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;贝佐斯正在为亚马逊的面向服务的体系结构打下基础。二十二年后，这一框架在技术领域普及。这意味着 API 管理实际上是团队在组织内部进行通信和操作的方式。&lt;/p&gt;
&lt;p&gt;API 已经成为组织过程的生命线，代表了从孤立的功能到集成系统的转变。这种转变将 API 管理从技术任务转变为组织领导的核心方面。这带来了几个具体的变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;战略对齐&lt;/strong&gt;。API 管理与业务战略密切对齐。它涉及理解 API 如何能够实现业务目标，如进入新市场、提升客户体验或简化运营。这种战略对齐要求 API 倡议与组织的方向和目标同步。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨职能合作&lt;/strong&gt;。API 不再仅仅是 IT 部门的责任。它们需要跨各种功能领域的合作，包括营销、销售、客户服务和业务发展。这种合作确保 API 以支持多样化的组织需求和机会的方式开发和管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将 API 作为产品的思维方式&lt;/strong&gt;。API 越来越被视为产品，有专门的团队负责它们的生命周期，从构思到淘汰。这种方法涉及定期更新、用户反馈集成和持续改进，就像公司提供的任何其他产品或服务一样。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能指标和分析&lt;/strong&gt;。API 的成功不仅通过技术性能来衡量，还通过其对业务结果的影响来衡量。诸如 API 使用趋势、用户参与度和对收入增长的贡献等指标成为 API 有效性的重要指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，API 的管理不再仅仅关于技术规范或协议，而是关于管理信息分享和服务交付的方式，跨整个组织。这种方法促进了敏捷性、可扩展性和创新，这在今天不断发展的技术领域中是必不可少的。&lt;/p&gt;
&lt;h2 id=&#34;gitops-已经在-api-中使用&#34;&gt;GitOps 已经在 API 中使用&lt;/h2&gt;
&lt;p&gt;将 GitOps 集成到 API 管理中标志着 API 是如何更高效、透明和可靠地开发、部署和维护的一种显著转变。GitOps 是一种将 git 的版本控制原则应用于操作工作流程的方法，对于以更高效、透明和可靠的方式管理 API 的生命周期至关重要。&lt;/p&gt;
&lt;p&gt;在这个框架中，API 的每个方面，从其设计文档和配置到代码和部署清单，都存储在 git 存储库中。这种方法确保了整个 API 生命周期都受到版本控制，允许详细跟踪更改，以及在出现问题时轻松回滚，增强了团队成员之间的协作。&lt;/p&gt;
&lt;p&gt;自动化部署流程是使用 GitOps 管理 API 的一个关键优势。通过利用 git 作为唯一的真相来源，可以设置自动化流水线，以在提交更改时部署 API。这种自动化不仅限于简单的部署，还包括配置和策略的更新，确保 API 的所有方面都得到一致和可靠的更新。团队可以创建与 GitOps 工作流程直接集成的分散的声明性工作流，用于复杂的自定义配置。&lt;/p&gt;
&lt;p&gt;GitOps 还为 API 管理带来了更高级别的安全性。关于更改的拉取请求鼓励同行审查和批准，为引入修改提供了更健壮的流程。此外，git 存储库的不可变性增加了额外的安全性层，因为每个更改都是被跟踪和可审计的。&lt;/p&gt;
&lt;p&gt;GitOps 有望通过引入版本控制、自动化、安全和协作原则来改变 API 管理，从而使 API 开发和管理更加与现代敏捷实践相符，提高了效率和可靠性。&lt;/p&gt;
&lt;h2 id=&#34;开发者体验将成为标配&#34;&gt;开发者体验将成为标配&lt;/h2&gt;
&lt;p&gt;在 2024 年，提供卓越的开发者体验（DevX）将不再是奢侈；它将成为一项必需。未将 DevX 置于优先位置的 API 管理系统越来越有被淘汰的风险，因为以开发者为中心的模式正在成为标准。&lt;/p&gt;
&lt;p&gt;这一变革的基石在于认识到开发者需要与其工作流程相一致并增强生产力的工具和系统。这其中的一个关键方面是采用&lt;a href=&#34;https://thenewstack.io/why-use-infrastructure-as-code/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基础设施即代码&lt;/a&gt;（IaC）实践。IaC 允许开发者通过代码而不是手动流程来管理和配置基础设施。&lt;/p&gt;
&lt;p&gt;另一个关键因素是 API 管理系统支持各种部署环境的能力。随着部署模型的多样化，从本地部署到&lt;a href=&#34;https://www.getambassador.io/kubernetes-glossary/cloud-native&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生&lt;/a&gt;等，一个灵活的 API 管理解决方案，能够适应不同的环境至关重要。&lt;/p&gt;
&lt;p&gt;API 管理系统必须不断发展，以满足现代软件开发实践的需求。未能提供以开发者为中心的体验的系统，其特点包括 IaC、与标准工具的集成、易用性、灵活性和强大的分析功能，将在开发者体验至关重要的环境中难以保持相关性。&lt;/p&gt;
&lt;h2 id=&#34;捆绑随后的解绑&#34;&gt;捆绑随后的解绑&lt;/h2&gt;
&lt;p&gt;API 管理工具的演变正在见证回归到捆绑解决方案，这是与最近的点对点解决方案的趋势相反。与旧的企业捆绑解决方案不同，这些新一代捆绑解决方案适用于更广泛的组织范围，提供了综合的、集成的解决方案。&lt;/p&gt;
&lt;p&gt;API 生态系统的不断复杂和规模的增加推动了这一转变。现代 API 管理需要一种全面的方法，包括强大的身份验证机制、严格的安全协议和自助开发者工具。通过将这些功能整合到&lt;a href=&#34;https://www.getambassador.io/products/edge-stack/api-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;单一的、连贯的包中&lt;/a&gt;，捆绑解决方案提供了一种更简化和高效的 API 管理方式。&lt;/p&gt;
&lt;p&gt;在这些捆绑解决方案中包括网关对于流量管理至关重要，提供了速率限制、请求路由和协议转换等功能。身份验证是另一个关键组成部分，确保通过 OAuth 和 JSON Web Tokens（JWT）等机制安全访问 API。这些捆绑解决方案中的安全功能不仅限于身份验证，还提供了全面的保护，防止 SQL 注入、DDoS 攻击和数据泄露等威胁。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.getambassador.io/products/telepresence&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自助开发者工具&lt;/a&gt;是这些捆绑解决方案的重要组成部分。它们赋予开发者独立创建、测试和部署 API 的能力，减少了对 IT 团队的依赖，加速了开发。这些工具必须包括用户友好的界面、详细的文档和自动化的测试功能。&lt;/p&gt;
&lt;p&gt;API 管理中捆绑解决方案的再次出现代表着对现代 API 景观需求的适应。通过在一个统一的包中提供网关、身份验证、安全和开发者工具，这些捆绑解决方案提供了适用于各种组织需求的多功能和高效的解决方案。&lt;/p&gt;
&lt;h2 id=&#34;未知的人工智能&#34;&gt;未知的人工智能&lt;/h2&gt;
&lt;p&gt;人工智能正在颠覆数十个行业的规则，并以意想不到的方式重塑它们。&lt;/p&gt;
&lt;p&gt;“意想不到”是描述人工智能/机器学习技术将如何扰乱 API 管理生态系统的好方式。KubeCon North America 2023 与 OpenAI Dev Day 同时举行，但两者似乎天差地别。在 KubeCon 上，AI 只轻微&lt;a href=&#34;https://danielbryantuk.medium.com/kubecon-chicago-key-takeaways-3de5ca13b375&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;提及&lt;/a&gt;，似乎 DevOps 和 API 管理行业对人工智能没有太多（尚未！）言论。&lt;/p&gt;
&lt;p&gt;但是，将 AI 排除在外将严重低估 AI 发展的范围和速度。去年这个时候，ChatGPT 才两周大。那时没有人知道它将如何彻底改变技术的各个方面。&lt;/p&gt;
&lt;p&gt;因此，AI/机器学习与 API 战略的融合是不可避免的，可能会彻底改变 API 的开发、管理和优化方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AI 驱动的分析可以提供对 API 使用模式的更深入洞察，从而实现更有效的资源管理和优化。&lt;/li&gt;
&lt;li&gt;AI 可以自动化和增强安全协议，比传统方法更有效地检测异常和潜在威胁。&lt;/li&gt;
&lt;li&gt;AI 可以显着简化 API 开发过程。通过使用机器学习算法，API 可以变得更加自适应和智能，能够以更高的准确性和效率处理复杂请求。这种集成可能导致自我优化的 API，根据实时反馈调整其行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AI 与 API 管理的交汇是即将到来的现实。随着 AI 继续渗透各个领域，其融入 API 生态系统将提供前所未有的效率、安全性和适应性水平，宣告了 API 管理和使用方式的新时代。&lt;/p&gt;
&lt;h2 id=&#34;未知的未知&#34;&gt;未知的未知&lt;/h2&gt;
&lt;p&gt;还有什么在未来？随着技术进步的极速和 API 已经吞噬了整个世界的方式，预测 API 管理的未来就像试图绘制未知领域一样困难。&lt;/p&gt;
&lt;p&gt;这个领域正在迅速发展，受新兴技术和 Paradigm 转变的推动，这使得难以预见未来的变化的全部范围。就像 API 已经改变了数字基础设施一样，未来的创新和方法将进一步重新定义我们今天对 API 管理的理解。&lt;/p&gt;
&lt;p&gt;请告诉我们你认为 2024 年将为 API 管理带来什么，以及你认为明年我们将使用什么令人兴奋的技术。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JWT 在 API 网关中的角色：服务间认证的新视角</title>
      <link>https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/</link>
      <pubDate>Fri, 08 Dec 2023 12:30:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://www.solo.io/blog/jwts-authenticate-services-api-gateways/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.solo.io/blog/jwts-authenticate-services-api-gateways/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要：这篇博客探讨了在云原生架构中使用 JSON Web Tokens（JWTs）进行服务间通信的复杂性。它详细讨论了通过 API 网关和服务网格实现安全认证的两种方法，强调了使用 JWTs 的挑战，包括安全性、密钥管理和性能问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;云原生架构中的 API 网关组件至关重要，因为它将关键的 API 安全性和策略功能卸载到一个公共位置，使后端 API 和服务能够专注于业务逻辑。API 身份验证、授权、审计、限流等任务可能会非常复杂且难以正确实现，因此许多组织选择使用 API 网关来处理它们。&lt;/p&gt;
&lt;p&gt;那么对于服务与服务（S2S）或内部东/西流量呢？强制 S2S 流量“回头”通过 API 网关会引入额外的跳跃、更多的延迟、增加的流量以及效率降低。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-通过-api-网关的-s2s-流量回头示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;通过 API 网关的 S2S 流量“回头”示意图&#34; srcset=&#34;
               /blog/jwts-authenticate-services-api-gateways/hairpin-api-gateway-calls_hu_bd09475ba5b3160e.webp 400w,
               /blog/jwts-authenticate-services-api-gateways/hairpin-api-gateway-calls_hu_317ac3aa12ba4b2.webp 760w,
               /blog/jwts-authenticate-services-api-gateways/hairpin-api-gateway-calls_hu_eb1aa7f2546b931d.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/hairpin-api-gateway-calls_hu_bd09475ba5b3160e.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      通过 API 网关的 S2S 流量“回头”示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但是，如果您跳过 API 网关直接调用服务，如何确保流量的安全性？接收服务如何进行身份验证并知道是谁在调用它？&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-显示-service-b-需要对-service-a-进行身份验证的示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;显示 Service B 需要对 Service A 进行身份验证的示意图&#34; srcset=&#34;
               /blog/jwts-authenticate-services-api-gateways/service-a-b_hu_8606c96738da59ab.webp 400w,
               /blog/jwts-authenticate-services-api-gateways/service-a-b_hu_780487281a6e7f45.webp 760w,
               /blog/jwts-authenticate-services-api-gateways/service-a-b_hu_e0ad8559fe1ef954.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/service-a-b_hu_8606c96738da59ab.webp&#34;
               width=&#34;760&#34;
               height=&#34;248&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      显示 Service B 需要对 Service A 进行身份验证的示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;保障 S2S 通信的两种常见方式是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用传输层安全性（TLS）和客户端证书（双向 TLS 或 mTLS）。&lt;/li&gt;
&lt;li&gt;使用签名的 JSON Web Tokens（JWT）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://www.solo.io/topics/service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格&lt;/a&gt;通过使用第一种方法自动化了许多最佳实践并减轻了与之相关的&lt;a href=&#34;https://istio.io/latest/blog/2023/secure-apps-with-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;开发人员可以选择使用 JWT 进行 S2S 身份验证，但这会“削弱”API 网关的预期功能。也就是说，您曾期望 API 网关处理的所有安全性复杂性和脆弱性必须在每个 S2S 通信的微服务中重新创建和复制。这是一个重大问题，因为使用 JWT 进行 S2S 身份验证会引入复杂性和对细节的严格要求。（有关此主题和下面的场景的更多信息，请观看 Hoot 第 59 集：“&lt;a href=&#34;https://youtu.be/Q2KfNUBfnjo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWT 与 Service-to-Service 身份验证的比较&lt;/a&gt;”。所有演示都可以在我们的&lt;a href=&#34;https://github.com/peterj/jwts-for-services/tree/main&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub 仓库&lt;/a&gt;中找到。）&lt;/p&gt;
&lt;p&gt;虽然有一些出色的处理 JWT 的框架和库，而 JWT 确实有其用武之地，但将 JWT 用于 S2S 流量的身份验证是复杂且繁重的，并且需要开发人员非常准确地完成工作。这种复杂性（或缺乏意识）可能会降低总体安全性，如果开发人员采取捷径或忽视关键属性，可能会降低总体安全性。开发人员还需要以特定于语言和框架的方式执行此操作（例如，使用 Java 解决此问题与使用 Go 或 Node.js 不同）。在所有代码库中维护、打补丁和审核每个实现都需要付出成本。&lt;/p&gt;
&lt;h2 id=&#34;如何使用-jwt-进行-s2s-通信身份验证&#34;&gt;如何使用 JWT 进行 S2S 通信身份验证&lt;/h2&gt;
&lt;p&gt;有两种方法可以创建 JWT 以进行 S2S 通信身份验证：使用身份提供者（IdP）（也称为安全令牌服务或 STS）或允许各个服务自行签署 JWT。（如果您对 JWT 概念不熟悉或需要复习，请查看 Auth0 提供的&lt;a href=&#34;https://auth0.com/docs/secure/tokens/json-web-tokens&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWT 概述&lt;/a&gt;。）&lt;/p&gt;
&lt;h3 id=&#34;选项-1使用-sts-发放令牌&#34;&gt;选项 1：使用 STS 发放令牌&lt;/h3&gt;
&lt;p&gt;第一种方法涉及使用安全令牌服务（STS），这是一个可信任的身份或令牌提供者，例如&lt;a href=&#34;https://www.keycloak.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Keycloak&lt;/a&gt;、&lt;a href=&#34;https://www.okta.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Okta&lt;/a&gt;或&lt;a href=&#34;https://auth0.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Auth0&lt;/a&gt;，用于发放代表特定服务的令牌。&lt;/p&gt;
&lt;p&gt;在此方法中，服务使用长期凭据（例如用户名和密码或 OAuth2.0 客户端凭据）与 STS 交换 JWT，表明“我是 Service A”。&lt;/p&gt;
&lt;p&gt;注意：长期凭据应安全存储并有限使用。例如，您可以在启动时使用它一次来引导身份，并且以后不再使用。此外，这些凭据应仅存储在内存中。&lt;/p&gt;
&lt;p&gt;STS 使用其私钥签署 JWT，可以使用其公钥验证 JWT。然后，Service A 将 JWT 附加到发送给 Service B 的请求中。从这里，Service B 可以通过使用 STS 的公钥验证 JWT 的签名来验证 JWT 是由 STS 签发的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-显示服务如何相互验证的示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;显示服务如何相互验证的示意图&#34; srcset=&#34;
               /blog/jwts-authenticate-services-api-gateways/authentication_hu_e269b19728a694a.webp 400w,
               /blog/jwts-authenticate-services-api-gateways/authentication_hu_f86663aa057cd88d.webp 760w,
               /blog/jwts-authenticate-services-api-gateways/authentication_hu_dd7b2475caacade7.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/authentication_hu_e269b19728a694a.webp&#34;
               width=&#34;760&#34;
               height=&#34;471&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      显示服务如何相互验证的示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了使此工作正常运行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流量必须加密。&lt;/li&gt;
&lt;li&gt;服务 B 必须检查 JWT 的&lt;code&gt;aud&lt;/code&gt;声明、过期时间、颁发时间以及不早于时间。&lt;/li&gt;
&lt;li&gt;当 STS 签发的 JWT 签名密钥轮换时，服务 B 必须准备好更新 STS 的公钥。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;加密流量至关重要，因为在这种情况下使用 JWT 时，它们代表了一个“承载令牌”，因此拥有令牌的任何人都可以冒充 Service A。在 Service A 和 Service B 之间加密流量（例如使用单向服务器 TLS）有助于减轻这个问题。&lt;/p&gt;
&lt;p&gt;Service B 还必须检查 JWT 的过期时间（&lt;code&gt;exp&lt;/code&gt;）、颁发时间（&lt;code&gt;iat&lt;/code&gt;）、不早于时间（&lt;code&gt;nbf&lt;/code&gt;）以及特别是&lt;code&gt;aud&lt;/code&gt;声明，以验证令牌是否有效（未过期，位于其时间窗口内并用于 Service B 的使用）。JWT 使用这个约定来防范重放攻击，其中攻击者冒充 Service B，从 Service A 获取令牌，然后冒充 Service A 来调用 Service C。有效的 Service C 会检查&lt;code&gt;aud&lt;/code&gt;声明，看到代表 Service A 的 JWT 是为 Service B 而设计的，然后拒绝它。&lt;/p&gt;
&lt;p&gt;每次调用服务 A 都必须使用不同的 JWT，因为&lt;code&gt;aud&lt;/code&gt;声明会不同。尝试使用没有&lt;code&gt;aud&lt;/code&gt;声明的 JWT 或使用通配符&lt;code&gt;aud&lt;/code&gt;声明会增加 JWT 被破坏的风险。避免这样做。&lt;/p&gt;
&lt;p&gt;最后，常常被忽略的是轮换 STS 的公钥。在计划的密钥轮换或计划的撤销 STS 用于签署 JWT 的密钥时，Service B（或任何依赖 STS 进行验证的服务）必须能够处理更新的签名公钥。&lt;/p&gt;
&lt;h3 id=&#34;选项-2让服务自行签署其令牌&#34;&gt;选项 2：让服务自行签署其令牌&lt;/h3&gt;
&lt;p&gt;第二种方法使用服务特定的密钥来签署 JWT。可以使用对称密钥或非对称密钥。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-使用特定于服务的密钥进行-s2s-身份验证的示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;使用特定于服务的密钥进行 S2S 身份验证的示意图&#34; srcset=&#34;
               /blog/jwts-authenticate-services-api-gateways/authentication-service-specific-keys_hu_7b4c40d8a0ba63ed.webp 400w,
               /blog/jwts-authenticate-services-api-gateways/authentication-service-specific-keys_hu_a9229388a70790a7.webp 760w,
               /blog/jwts-authenticate-services-api-gateways/authentication-service-specific-keys_hu_297886f3b013786f.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/authentication-service-specific-keys_hu_7b4c40d8a0ba63ed.webp&#34;
               width=&#34;760&#34;
               height=&#34;518&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      使用特定于服务的密钥进行 S2S 身份验证的示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这种情况下，Service A 使用自己的密钥来签署发送给 Service B（或任何其他服务）的 JWT。Service B 将需要 Service A 的公钥（或对称密钥，由于密钥交换和冒充问题更加危险）来验证 Service A 发送的 JWT。实际上，Service B 将需要每个调用它的服务的公钥，这些服务使用 JWT 作为身份验证主体。&lt;/p&gt;
&lt;p&gt;与 STS 签发的 JWT 示例一样，服务之间的流量必须加密，Service B 还必须检查&lt;code&gt;aud&lt;/code&gt;声明，并且您需要一种签署公钥轮换的方法。您还必须为每个调用的服务使用不同的 JWT。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务-b-检查-aud-声明&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;服务 B 检查 aud 声明&#34; srcset=&#34;
               /blog/jwts-authenticate-services-api-gateways/different-jwt-dependent-services_hu_2c21f559dcc4f335.webp 400w,
               /blog/jwts-authenticate-services-api-gateways/different-jwt-dependent-services_hu_eee8d487e2adeff4.webp 760w,
               /blog/jwts-authenticate-services-api-gateways/different-jwt-dependent-services_hu_595e30f1e5cd0c96.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/jwts-authenticate-services-api-gateways/different-jwt-dependent-services_hu_2c21f559dcc4f335.webp&#34;
               width=&#34;760&#34;
               height=&#34;634&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务 B 检查 aud 声明
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;开发人员必须采取措施并跟踪许多内容，以确保一切正确。证书还必须至少分发给一半的服务（接收端的服务）以提供至少单向 TLS。此外，整个过程的关键是密钥管理、轮换和安全保管密钥。&lt;/p&gt;
&lt;h2 id=&#34;jwt-可能出现问题的地方&#34;&gt;JWT 可能出现问题的地方&lt;/h2&gt;
&lt;p&gt;我们已经介绍了 JWT 可用于表示服务身份的一些方式，并提出了关注的领域。在服务架构中，有几个需要密切关注的领域，以避免安全漏洞。如果这些不是牢不可破的，您将为攻击者提供机会来破坏您的系统。&lt;/p&gt;
&lt;p&gt;在使用客户端证书/mTLS（例如服务网格）和JWT进行身份验证之间最重要的区别之一是：JWT通过网络发送敏感的承载令牌材料，而mTLS不会。使用mTLS时，只会发送公钥，而不会发送私钥，会协商会话密钥。如果JWT泄露，JWT是私密材料，可以被重放。对于证书，只有公共证书被共享。&lt;/p&gt;
&lt;p&gt;为防止重播承载令牌，您必须通过设置短暂的到期时间，理想情况下只有几分钟，来限制其暴露。这会增加服务刷新其 JWT 以进行请求的责任。设置数小时、数天或数月的到期时间发生得太频繁。这是一个严重的安全隐患。&lt;/p&gt;
&lt;p&gt;另一个重大的安全漏洞是，在使用 STS 获取 JWT 材料时，您会多次通过网络发送长期凭据（例如客户端凭证流程）。这些长期凭据非常敏感，应谨慎使用（例如，在启动时使用），而不应连续使用。&lt;/p&gt;
&lt;p&gt;此外，使用通配符&lt;code&gt;aud&lt;/code&gt;声明或完全省略&lt;code&gt;aud&lt;/code&gt;声明也是一个重大问题。未能在服务之间一致使用这些约定以进行身份验证会导致严重问题。确保为&lt;em&gt;每个&lt;/em&gt;调用的服务创建具有正确&lt;code&gt;aud&lt;/code&gt;声明的 JWT。&lt;/p&gt;
&lt;p&gt;最后，密钥轮换与短暂到期时间和 aud 声明检查同样重要。在发生违规事件时，使密钥无效是最后的努力，应尽快且高效地处理。&lt;/p&gt;
&lt;h2 id=&#34;jwt-的复杂性是服务网格简化事物的地方&#34;&gt;JWT 的复杂性是服务网格简化事物的地方&lt;/h2&gt;
&lt;p&gt;服务网格简化了服务之间的身份验证，并允许开发人员专注于业务逻辑，而不是正确地处理 JWT 和秘密材料（希望如此）。就像 API 网关应用于处理北/南和入口流量的安全性一样，服务网格应用于处理东/西和 S2S 流量的安全性。保持服务和 API 专注于它们可以提供的不同 iating 业务价值，而不是模板（但极其重要的）的安全性代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gateway API v0.8.0: 引入服务网格支持</title>
      <link>https://cloudnativecn.com/blog/gateway-api-release/</link>
      <pubDate>Wed, 30 Aug 2023 12:03:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/gateway-api-release/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://kubernetes.io/blog/2023/08/29/gateway-api-v0-8/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubernetes.io/blog/2023/08/29/gateway-api-v0-8/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;作者：&lt;/strong&gt;&lt;/em&gt; Flynn（Buoyant）、John Howard（Google）、Keith Mattix（Microsoft）、Michael Beaumont（Kong）、Mike Morris（独立）、Rob Scott（Google）&lt;/p&gt;
&lt;p&gt;我们非常高兴地宣布 Gateway API 的 v0.8.0 版本发布了！通过此版本，Gateway API 对服务网格的支持已达到&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/overview/#status&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;实验性状态&lt;/a&gt;。我们期待您的反馈！&lt;/p&gt;
&lt;p&gt;我们特别高兴地宣布，Kuma 2.3+、Linkerd 2.14+ 和 Istio 1.16+ 都是 Gateway API 服务网格支持的完全符合实现。&lt;/p&gt;
&lt;h2 id=&#34;gateway-api-中的服务网格支持&#34;&gt;Gateway API 中的服务网格支持&lt;/h2&gt;
&lt;p&gt;虽然 Gateway API 最初的重点一直是入口（南北）流量，但很快就清楚，相同的基本路由概念也应适用于服务网格（东西）流量。2022 年，Gateway API 子项目启动了&lt;a href=&#34;https://gateway-api.sigs.k8s.io/concepts/gamma/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GAMMA 计划&lt;/a&gt;，这是一个专门的供应商中立工作流，旨在特别研究如何最好地将服务网格支持纳入 Gateway API 资源的框架中，而不需要 Gateway API 的用户重新学习他们了解的有关 API 的一切。&lt;/p&gt;
&lt;p&gt;在过去的一年中，GAMMA 深入研究了使用 Gateway API 用于服务网格的挑战和可能的解决方案。最终结果是少量的&lt;a href=&#34;https://gateway-api.sigs.k8s.io/contributing/enhancement-requests/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;增强提案&lt;/a&gt;，涵盖了许多小时的思考和辩论，并提供了一条最小可行路径，允许使用 Gateway API 用于服务网格。&lt;/p&gt;
&lt;h3 id=&#34;当使用-gateway-api-时网格路由将如何工作&#34;&gt;当使用 Gateway API 时，网格路由将如何工作？&lt;/h3&gt;
&lt;p&gt;您可以在&lt;a href=&#34;https://gateway-api.sigs.k8s.io/concepts/gamma/#how-the-gateway-api-works-for-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway API 网格路由文档&lt;/a&gt;和&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1426/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1426&lt;/a&gt;中找到所有详细信息，但对于 Gateway API v0.8.0，简短的版本是，现在 HTTPRoute 可以有一个“parentRef”，它是一个服务，而不仅仅是一个网关。我们预计在这个领域使用更多 GEP，因为随着我们对服务网格用例的经验不断增加，绑定到服务使得使用 Gateway API 与服务网格成为可能，但仍有几个有趣的用例难以涵盖。&lt;/p&gt;
&lt;p&gt;例如，您可以使用 HTTPRoute 在网格中进行 A-B 测试，如下所示：&lt;/p&gt;
&lt;p&gt;任何具有标头 &lt;code&gt;env: v1&lt;/code&gt; 的 &lt;code&gt;demo-app&lt;/code&gt; 服务的端口 5000 的请求都将路由到 &lt;code&gt;demo-app-v1&lt;/code&gt;，而没有该标头的请求都将路由到 &lt;code&gt;demo-app-v2&lt;/code&gt; - 并且由于这是由服务网格处理而不是入口控制器，因此 A/B 测试可以发生在应用程序的调用图中的任何位置。&lt;/p&gt;
&lt;p&gt;如何知道这将是真正的可移植性？&lt;/p&gt;
&lt;p&gt;Gateway API 在支持的所有功能上都在持续投资一致性测试，网格也不例外。GAMMA 面临的其中一个挑战是，许多这些测试都与一个给定实现提供入口控制器的想法密切相关。许多服务网格不提供入口控制器，要求符合 GAMMA 标准的网格同时实现入口控制器似乎并不切实际。这导致在 Gateway API &lt;em&gt;一致性配置文件&lt;/em&gt;上重新开始工作，如&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1709/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1709&lt;/a&gt;所讨论的那样。&lt;/p&gt;
&lt;p&gt;一致性配置文件的基本思想是，我们可以定义 Gateway API 的子集，并允许实现选择（并记录）他们符合哪些子集。GAMMA 正在添加一个名为“Mesh”的新配置文件，描述在&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1686/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1686&lt;/a&gt;中，仅检查由 GAMMA 定义的网格功能。此时，Kuma 2.3+、Linkerd 2.14+ 和 Istio 1.16+ 都符合“Mesh”配置文件的标准。&lt;/p&gt;
&lt;h2 id=&#34;gateway-api-v080-中还有什么&#34;&gt;Gateway API v0.8.0 中还有什么？&lt;/h2&gt;
&lt;p&gt;这个版本的发布是关于为即将到来的 v1.0 版本做准备，其中 HTTPRoute、Gateway 和 GatewayClass 将毕业为 GA。与此相关的有两个主要更改：CEL 验证和 API 版本更改。&lt;/p&gt;
&lt;h3 id=&#34;cel-验证&#34;&gt;CEL 验证&lt;/h3&gt;
&lt;p&gt;第一个重大变化是，Gateway API v0.8.0 是从 webhook 验证向使用内置于 CRD 中的信息的&lt;a href=&#34;https://kubernetes.io/docs/reference/using-api/cel/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CEL 验证&lt;/a&gt;的转换的开端。这将根据您使用的 Kubernetes 版本而有所不同：&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-125&#34;&gt;Kubernetes 1.25+&lt;/h3&gt;
&lt;p&gt;CEL 验证得到了完全支持，并且几乎所有验证都是在 CEL 中实现的。（唯一的例外是，标头修饰符过滤器中的标头名称只能进行不区分大小写的验证。有关更多信息，请参见&lt;a href=&#34;https://github.com/kubernetes-sigs/gateway-api/issues/2277&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;issue 2277&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;我们建议在这些 Kubernetes 版本上&lt;em&gt;不&lt;/em&gt;使用验证 Webhook。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-123-和-124&#34;&gt;Kubernetes 1.23 和 1.24&lt;/h3&gt;
&lt;p&gt;CEL 验证不受支持，但是 Gateway API v0.8.0 CRD 仍然可以安装。当您升级到 Kubernetes 1.25+ 时，这些 CRD 中包含的验证将自动生效。&lt;/p&gt;
&lt;p&gt;我们建议在这些 Kubernetes 版本上继续使用验证 Webhook。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-122-和更早版本&#34;&gt;Kubernetes 1.22 和更早版本&lt;/h3&gt;
&lt;p&gt;Gateway API 只承诺支持&lt;a href=&#34;https://gateway-api.sigs.k8s.io/concepts/versioning/#supported-versions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最新的 5 个 Kubernetes 版本&lt;/a&gt;。因此，这些版本不再受 Gateway API 的支持，不幸的是，Gateway API v0.8.0 不能在它们上安装，因为包含 CEL 验证的 CRD 将被拒绝。&lt;/p&gt;
&lt;h3 id=&#34;api-版本更改&#34;&gt;API 版本更改&lt;/h3&gt;
&lt;p&gt;随着我们为将 Gateway、GatewayClass 和 HTTPRoute 毕业到 &lt;code&gt;v1&lt;/code&gt; API 版本从 &lt;code&gt;v1beta1&lt;/code&gt; 做准备的过程中，我们继续减少了已毕业到 &lt;code&gt;v1beta1&lt;/code&gt; 的资源的 &lt;code&gt;v1alpha2&lt;/code&gt; 的使用。有关此更改以及此版本中包含的所有其他内容的更多信息，请参见&lt;a href=&#34;https://github.com/kubernetes-sigs/gateway-api/releases/tag/v0.8.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;v0.8.0 发布说明&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;如何开始使用-gateway-api&#34;&gt;如何开始使用 Gateway API？&lt;/h2&gt;
&lt;p&gt;Gateway API 代表了 Kubernetes 中负载平衡、路由和服务网格 API 的未来。已经有超过 20 个&lt;a href=&#34;https://gateway-api.sigs.k8s.io/implementations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;实现&lt;/a&gt;可用（包括入口控制器和服务网格），列表还在不断增长。&lt;/p&gt;
&lt;p&gt;如果您有兴趣开始使用 Gateway API，请查看&lt;a href=&#34;https://gateway-api.sigs.k8s.io/concepts/api-overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 概念文档&lt;/a&gt;，并查看一些&lt;a href=&#34;https://gateway-api.sigs.k8s.io/guides/getting-started/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;指南&lt;/a&gt;以尝试使用它。因为这是一个基于 CRD 的 API，所以您可以在任何 Kubernetes 1.23+ 集群上安装最新版本。&lt;/p&gt;
&lt;p&gt;如果您特别有兴趣帮助 Gateway API 做出贡献，我们将非常乐意接受！请随时在存储库上&lt;a href=&#34;https://github.com/kubernetes-sigs/gateway-api/issues/new/choose&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;打开新问题&lt;/a&gt;，或加入&lt;a href=&#34;https://github.com/kubernetes-sigs/gateway-api/discussions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;讨论&lt;/a&gt;。还请查看&lt;a href=&#34;https://gateway-api.sigs.k8s.io/contributing/community/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;社区页面&lt;/a&gt;，其中包括 Slack 频道和社区会议的链接。我们期待您的到来！&lt;/p&gt;
&lt;h2 id=&#34;更多阅读&#34;&gt;更多阅读：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1324/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1324&lt;/a&gt;提供了 GAMMA 目标和一些重要定义的概述。这个 GEP 值得一读，因为它讨论了问题空间。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1426/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1426&lt;/a&gt;定义了如何使用 Gateway API 路由资源（如 HTTPRoute）管理服务网格内的流量。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1686/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1686&lt;/a&gt;在&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/gep-1709/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GEP-1709&lt;/a&gt;的工作基础上，为声明符合 Gateway API 的服务网格定义了一个&lt;em&gt;一致性配置文件&lt;/em&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然这些都是&lt;a href=&#34;https://gateway-api.sigs.k8s.io/geps/overview/#status&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;实验性&lt;/a&gt;模式，但请注意，它们可在 &lt;a href=&#34;https://gateway-api.sigs.k8s.io/concepts/versioning/#release-channels-eg-experimental-standard&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;standard&lt;/code&gt; 发布频道&lt;/a&gt;使用，因为 GAMMA 计划迄今为止不需要引入新的资源或字段。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Envoy Gateway 0.3 发布——扩展 Kubernetes Gateway API</title>
      <link>https://cloudnativecn.com/blog/envoy-gateways-latest-v0-3-release-extends-the-kubernetes-gateway-api/</link>
      <pubDate>Tue, 28 Feb 2023 11:20:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/envoy-gateways-latest-v0-3-release-extends-the-kubernetes-gateway-api/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/envoyproxy/gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Gateway&lt;/a&gt; (EG)&lt;a href=&#34;https://tetrate.io/blog/gateway-to-the-future-the-new-gateway-api-and-envoy-gateway-0-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;首次公开发布&lt;/a&gt; 四个月后，我们很高兴地宣布发布 &lt;a href=&#34;https://github.com/envoyproxy/gateway/releases/tag/v0.3.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;版本 0.3&lt;/a&gt; 起。这个最新版本是几位 Tetrate 同事和整个社区其他人辛勤工作的结晶。Envoy Gateway 现在支持整个 &lt;a href=&#34;https://gateway-api.sigs.k8s.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Gateway API&lt;/a&gt;，包括实验部分——添加了一些强大的新功能，使这个免费的开源软件更接近于功能齐全的 API 网关。&lt;/p&gt;
&lt;p&gt;EG 的一大特点是它配置了新的网关 API，而不是旧的和非常有限的 &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ingress API&lt;/a&gt;，或任何为了弥补 Ingress 缺陷的专有 API。虽然 EG 0.2 实现了 Gateway API 的核心部分（完全支持“基本”HTTP 路由），但 EG 0.3 在其 Gateway API 支持方面更进了一步，这可能是了解其新功能的最佳方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持更多 HTTP 功能，例如&lt;a href=&#34;https://gateway.envoyproxy.io/v0.3.0/user/http-urlrewrite.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;URL Rewrite&lt;/a&gt;、&lt;a href=&#34;https://gateway.envoyproxy.io/v0.3.0/user/http-response-headers.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Response Header Operation&lt;/a&gt; 和流量镜像。这些来自 API 规范中的扩展字段。&lt;/li&gt;
&lt;li&gt;支持路由 &lt;a href=&#34;https://gateway.envoyproxy.io/v0.3.0/user/grpc-routing.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC&lt;/a&gt;、&lt;a href=&#34;https://gateway.envoyproxy.io/v0.3.0/user/udp-routing.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UDP&lt;/a&gt; 和原始 &lt;a href=&#34;https://gateway.envoyproxy.io/v0.3.0/user/tcp-routing.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TCP&lt;/a&gt;。这些来自 API 的实验性新部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意这些 API 扩展：我们正在努力为真实用户提供有用的功能。 &lt;a href=&#34;https://github.com/kubernetes/community/tree/master/sig-network&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SIG-NETWORK COMMUNITY&lt;/a&gt; 作为负责网关 API 规范的人员，有负责保护 API，因此他们的工作需要一些实践。作为实施者，我们有更多的自由在具体规范之前开辟一条道路——但我们已经在上游工作以标准化这些扩展。这种在工作实施中对新功能进行的实验是让任何团体接受提议的新 API 的重要一步——它对每个人都有好处。&lt;/p&gt;
&lt;p&gt;这些令人兴奋的新功能确实使 Envoy Gateway 项目超越了人们的好奇心，可以为许多现实世界的用例提供服务。重要的是，它能够提供所有这些，同时基于开放标准 API 并且是免费和开源软件，没有付费层。&lt;/p&gt;
&lt;p&gt;自己试用 Envoy Gateway 0.3 非常简单，只需转到 &lt;a href=&#34;https://gateway.envoyproxy.io/v0.3.0/user/quickstart.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;快速入门指南&lt;/a&gt; 即可开始！如果您想更深入地了解如何使用 &lt;em&gt;minikube&lt;/em&gt; 在本地进行尝试，大多数 &lt;a href=&#34;https://tetrate.io/blog/hands-on-with-the-gateway-api-using-envoy-gateway-0-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EG 0.2 动手指南&lt;/a&gt; 仍然有效。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 Envoy Gateway 0.2 体验新的 Kubernetes Gateway API</title>
      <link>https://cloudnativecn.com/blog/hands-on-with-envoy-gateway/</link>
      <pubDate>Thu, 27 Oct 2022 16:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/hands-on-with-envoy-gateway/</guid>
      <description>&lt;p&gt;在这篇文章中，我们将亲身体验 &lt;a href=&#34;https://github.com/envoyproxy/gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Gateway&lt;/a&gt; 和 &lt;a href=&#34;https://gateway-api.sigs.k8s.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway API&lt;/a&gt;。以下是逐步指导你安装 Envoy Gateway 的说明，以及通过 Envoy 代理在集群外公开 HTTP 应用程序的简单用例。&lt;/p&gt;
&lt;p&gt;如果你不方便运行，我在本文中包含了每个命令的输出，即使你没有 Kubernetes 集群也可以看到它是如何工作的。&lt;/p&gt;
&lt;p&gt;如果你是 GUI 的粉丝，在文章的最后我会附上 Tetrate 基于 &lt;a href=&#34;https://backstage.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Backstage&lt;/a&gt; 的概念验证 &lt;a href=&#34;https://github.com/tetratelabs/eg-backstage-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Gateway GUI&lt;/a&gt; 的屏幕截图和详细信息，以展示针对 Gateway API 构建此类东西是多么容易。&lt;/p&gt;
&lt;h2 id=&#34;创建-kubernetes-集群&#34;&gt;创建 Kubernetes 集群&lt;/h2&gt;
&lt;p&gt;首先运行 Envoy Gateway 和 Kubernetes 集群。最简单、最安全的方法是使用 &lt;a href=&#34;https://minikube.sigs.k8s.io/docs/start/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;minikube&lt;/a&gt; 在本地机器上启动集群。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ minikube start –driver&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;docker --cpus&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; --memory&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;2g
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;😄  minikube v1.27.0 on Arch 22.0.0 &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;x86_64&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	▪ &lt;span class=&#34;nv&#34;&gt;KUBECONFIG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;❗  For more information, see: https://github.com/kubernetes/kubernetes/issues/112135
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;📌  Using Docker Desktop driver with root privileges
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;👍  Starting control plane node minikube in cluster minikube
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🚜  Pulling base image ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🔥  Creating docker container &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CPUs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;2, &lt;span class=&#34;nv&#34;&gt;Memory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;2048MB&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🐳  Preparing Kubernetes v1.25.2 on Docker 20.10.17 ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	▪ Generating certificates and keys ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	▪ Booting up control plane ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	▪ Configuring RBAC rules ...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🔎  Verifying Kubernetes components...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🌟  Enabled addons: storage-provisioner
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🏄  Done! kubectl is now configured to use &lt;span class=&#34;s2&#34;&gt;&amp;#34;minikube&amp;#34;&lt;/span&gt; cluster and &lt;span class=&#34;s2&#34;&gt;&amp;#34;default&amp;#34;&lt;/span&gt; namespace by default
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;安装-envoy-gateway&#34;&gt;安装 Envoy Gateway&lt;/h2&gt;
&lt;p&gt;回想一下，Envoy Gateway 是由新的 Gateway API 配置的，而不是旧的 Ingress API。Gateway API 尚未合并到上游 Kubernetes，因此我们的集群将无法使用它。我们通过为其部署 CRD 来安装该 API。Envoy Gateway 项目提供了一个文件，用于安装 Gateway API 和部署 Envoy Gateway。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f https://github.com/envoyproxy/gateway/releases/download/v0.2.0/install.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这会产生大量资源，我将分几个部分中讨论它们。首先是 Gateway API：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;customresourcedefinition.apiextensions.k8s.io/gatewayclasses.gateway.networking.k8s.io created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;customresourcedefinition.apiextensions.k8s.io/gateways.gateway.networking.k8s.io created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;customresourcedefinition.apiextensions.k8s.io/httproutes.gateway.networking.k8s.io created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;customresourcedefinition.apiextensions.k8s.io/referencegrants.gateway.networking.k8s.io created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;customresourcedefinition.apiextensions.k8s.io/referencepolicies.gateway.networking.k8s.io created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;customresourcedefinition.apiextensions.k8s.io/tcproutes.gateway.networking.k8s.io created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;customresourcedefinition.apiextensions.k8s.io/tlsroutes.gateway.networking.k8s.io created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;customresourcedefinition.apiextensions.k8s.io/udproutes.gateway.networking.k8s.io created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;namespace/gateway-system created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;validatingwebhookconfiguration.admissionregistration.k8s.io/gateway-api-admission created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;service/gateway-api-admission-server created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deployment.apps/gateway-api-admission-server created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;serviceaccount/gateway-api-admission created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;clusterrole.rbac.authorization.k8s.io/gateway-api-admission created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;clusterrolebinding.rbac.authorization.k8s.io/gateway-api-admission created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;role.rbac.authorization.k8s.io/gateway-api-admission created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;rolebinding.rbac.authorization.k8s.io/gateway-api-admission created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;job.batch/gateway-api-admission created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;job.batch/gateway-api-admission-patch created
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如你所见，主要是 CRD。但请注意，安装 Gateway API 还部署了一些工作负载资源，包括 Deployment 等 ——Gateway API 带有一个 webhook 准入控制器来验证我们部署的资源，可以使用以下命令查看：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods --namespace gateway-system
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                                        	READY   STATUS  	RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gateway-api-admission-2dhk5                 	0/1 	Completed   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;      	70s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gateway-api-admission-patch-dbdbc           	0/1 	Completed   &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;      	70s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gateway-api-admission-server-68485ffc97-gt8v4   1/1 	Running 	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;      	70s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;添加到集群 API 中的新 CRD：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl api-resources &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep gateway.networking
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gatewayclasses                	gc       	gateway.networking.k8s.io/v1beta1  	&lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;    	GatewayClass
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gateways                      	gtw      	gateway.networking.k8s.io/v1beta1  	&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;     	Gateway
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;httproutes                                 	gateway.networking.k8s.io/v1beta1  	&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;     	HTTPRoute
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;referencegrants               	refgrant 	gateway.networking.k8s.io/v1alpha2 	&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;     	ReferenceGrant
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;referencepolicies             	refpol   	gateway.networking.k8s.io/v1alpha2 	&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;     	ReferencePolicy
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcproutes                                  	gateway.networking.k8s.io/v1alpha2 	&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;     	TCPRoute
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tlsroutes                                  	gateway.networking.k8s.io/v1alpha2 	&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;     	TLSRoute
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;udproutes                                  	gateway.networking.k8s.io/v1alpha2 	&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;     	UDPRoute
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面是 Envoy Gateway 本身。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;namespace/envoy-gateway-system created
customresourcedefinition.apiextensions.k8s.io/envoyproxies.config.gateway.envoyproxy.io created
serviceaccount/envoy-gateway created
role.rbac.authorization.k8s.io/leader-election-role created
clusterrole.rbac.authorization.k8s.io/envoy-gateway-role created
clusterrole.rbac.authorization.k8s.io/metrics-reader created
clusterrole.rbac.authorization.k8s.io/proxy-role created
rolebinding.rbac.authorization.k8s.io/leader-election-rolebinding created
clusterrolebinding.rbac.authorization.k8s.io/envoy-gateway-rolebinding created
clusterrolebinding.rbac.authorization.k8s.io/proxy-rolebinding created
configmap/envoy-gateway-config created
service/envoy-gateway created
service/envoy-gateway-metrics-service created
deployment.apps/envoy-gateway created
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些是工作负载资源以及相关的安全和网络。片刻之后，我们可以看到正在运行的控制器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods --namespace envoy-gateway-system
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                        	READY   STATUS	RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;envoy-gateway-dc74c4d97-pntbj   2/2 	Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;      	35s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;安装测试应用&#34;&gt;安装测试应用&lt;/h2&gt;
&lt;p&gt;我们还需要一些东西让网关真正将流量转发到 —— 就像我们的一个应用程序一样的东西。我们可以使用 httpbin，Envoy Gateway 项目提供了方便的清单。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f https://raw.githubusercontent.com/istio/istio/master/samples/httpbin/httpbin.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;serviceaccount/httpbin created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;service/httpbin created
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deployment.apps/httpbin created
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这将在默认命名空间中运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods -n default
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                    	READY   STATUS	RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;httpbin-9dbd644c7-fhtw5 	1/1 	Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;      	4m16s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;配置-envoy-gateway&#34;&gt;配置 Envoy Gateway&lt;/h2&gt;
&lt;p&gt;现在我们可以继续配置 Envoy Gateway 以执行一些请求路由。我们需要做的第一件事是注册我们刚刚部署的 Envoy Gateway 控制器，以便其他资源可以引用它来识别配置的网关，以防你在一个集群中部署多个网关。 &lt;code&gt;controllerName&lt;/code&gt; 字段匹配控制器向其运行的 Kubernetes 集群注册的值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f - &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;apiVersion: gateway.networking.k8s.io/v1beta1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;kind: GatewayClass
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  name: my-envoy-gateway
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  controllerName: gateway.envoyproxy.io/gatewayclass-controller
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gatewayclass.gateway.networking.k8s.io/eg created
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以看到关于这个新实例的一些有限信息，假设我们的描述是有效的，我们将看到 &lt;code&gt;ACCEPTED: True&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get gatewayclass -o wide
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME   CONTROLLER                                  	ACCEPTED   AGE 	DESCRIPTION
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;eg 	gateway.envoyproxy.io/gatewayclass-controller   True   	2m38s  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，让我们配置一个 Gateway 对象 —— 这将打开我们希望 Envoy 代理监听的网络端口。对于这个简单的演示，我们将绑定到一个端口而不使用 TLS，因此我将其称为“不安全端口”。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f - &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;apiVersion: gateway.networking.k8s.io/v1beta1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;kind: Gateway
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  name: insecure-port
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  gatewayClassName: my-envoy-gateway
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  listeners:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    - name: http
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      protocol: HTTP
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      port: 8080
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当我们检查它时，我们会发现它并没有就绪。由于我们使用的本地开发集群无法使这种云负载均衡器成为“真正的”负载均衡器（因此地址字段也是空的），因此该批准被搁置。不用担心这个，它仍然可以正常工作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl -n default get gateway -o wide
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME        	CLASS             ADDRESS   READY   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;insecure-port   my-envoy-gateway                     2m54s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，我们可以为一些 HTTP 流量设置路由。在这个简单的示例中，我们匹配任何路径上对 vhost &lt;code&gt;www.example.com&lt;/code&gt; 的任何请求，并将其发送到我们之前部署的 httpbin 实例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl apply -f - &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;apiVersion: gateway.networking.k8s.io/v1beta1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;kind: HTTPRoute
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  name: httpbin
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  parentRefs: [ {name: insecure-port} ]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  hostnames: [&amp;#34;www.example.com&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  rules:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    - matches:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        - path: {type: PathPrefix, value: /}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      backendRefs:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        - {group: &amp;#34;&amp;#34;, kind: Service, name: httpbin, port: 8000, weight: 1}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;httproute.gateway.networking.k8s.io/httpbin created
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;检查这种资源目前并没有向我们展示太多东西，但我们可以看到它至少已部署成功。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get httproute -n default -o wide
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME   	HOSTNAMES         	AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;httpbin	&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;www.example.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;   58s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后要注意的一件事是，直到现在才真正启动了 Envoy 的实例（之前它只是控制器，它本身并不处理流量）。这是代表 Envoy Gateway 的优化：代理的懒创建。检查系统上的 &lt;code&gt;age&lt;/code&gt; 字段，看看它的创建时间。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl get pods -n envoy-gateway-system
NAME                        	READY   STATUS	RESTARTS   AGE
envoy-default-insecure-port-5879556bd4-r5ggw   	1/1 	Running   0      	90s
envoy-gateway-dc74c4d97-pntbj   2/2 	Running   0      	13m
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;启动测试流量&#34;&gt;启动测试流量&lt;/h2&gt;
&lt;p&gt;就像我之前说的，我们无法获得真正的云负载均衡器，因为我们使用的是本地开发集群。但是 minikube 有一个简洁的特性，它将集群的服务暴露给我们的本地机器 —— 包括 Envoy Gateway 启动的代理。我们打开的 8080 端口将在回环中可用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ minikube tunnel
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该命令会阻塞，因此根据我们部署的规则，打开一个新终端以发送将被路由到 httpbin 的请求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl --header &lt;span class=&#34;s2&#34;&gt;&amp;#34;Host: www.example.com&amp;#34;&lt;/span&gt; 127.0.0.1:8080/headers
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HTTP/1.1 &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;server: envoy
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;date: Fri, &lt;span class=&#34;m&#34;&gt;07&lt;/span&gt; Oct &lt;span class=&#34;m&#34;&gt;2022&lt;/span&gt; 12:41:32 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-type: application/json
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;content-length: &lt;span class=&#34;m&#34;&gt;175&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;access-control-allow-origin: *
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;access-control-allow-credentials: &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x-envoy-upstream-service-time: &lt;span class=&#34;m&#34;&gt;14&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;s2&#34;&gt;&amp;#34;headers&amp;#34;&lt;/span&gt;: &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	&lt;span class=&#34;s2&#34;&gt;&amp;#34;Accept&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;application/json, */*&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	&lt;span class=&#34;s2&#34;&gt;&amp;#34;Host&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;www.example.com&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	&lt;span class=&#34;s2&#34;&gt;&amp;#34;User-Agent&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;curl/7.79.1&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	&lt;span class=&#34;s2&#34;&gt;&amp;#34;X-Envoy-Expected-Rq-Timeout-Ms&amp;#34;&lt;/span&gt;: &lt;span class=&#34;s2&#34;&gt;&amp;#34;15000&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这只是一个简单的演示，但你可以探索 Gateway API 的其余部分并开始使用更多功能 ——Envoy Gateway 的文档将是一个很好的指南。&lt;/p&gt;
&lt;h2 id=&#34;示例-gui&#34;&gt;示例 GUI&lt;/h2&gt;
&lt;p&gt;我给出的说明是针对命令行的，但是好的 GUI 是与任何系统交互的好方法。Envoy Gateway 对标准 Gateway API 的实施提供了交互操作接口生态系统。Tetrate 使用 &lt;a href=&#34;https://backstage.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Backstage&lt;/a&gt;（开发者接口的新兴标准）为 Envoy Gateway 构建了一个概念验证 UI。下面我将展示几个从上面检查演示设置的屏幕截图。&lt;/p&gt;
&lt;p&gt;如果你想玩这个，或者 fork 它，&lt;a href=&#34;https://github.com/tetratelabs/eg-backstage-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们已经发布了代码&lt;/a&gt;—— 目前还是 alpha 版本，并且只是一个可以在一周内构建的示例！如果你在 KubeCon Detroit，请到我们的展位，我们可以亲自向你展示！&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ui-for-envoy-gateway&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;UI for Envoy Gateway&#34; srcset=&#34;
               /blog/hands-on-with-envoy-gateway/008vxvgGgy1h7jx53ycsgj30wi0p5ab7_hu_d1273d779d5e4faf.webp 400w,
               /blog/hands-on-with-envoy-gateway/008vxvgGgy1h7jx53ycsgj30wi0p5ab7_hu_eee535e05de0593c.webp 760w,
               /blog/hands-on-with-envoy-gateway/008vxvgGgy1h7jx53ycsgj30wi0p5ab7_hu_6f9dd41377650ba8.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/hands-on-with-envoy-gateway/008vxvgGgy1h7jx53ycsgj30wi0p5ab7_hu_d1273d779d5e4faf.webp&#34;
               width=&#34;760&#34;
               height=&#34;588&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      UI for Envoy Gateway
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-backstage-界面&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Backstage 界面&#34; srcset=&#34;
               /blog/hands-on-with-envoy-gateway/008vxvgGgy1h7jx54gkz4j30wi0p5wg9_hu_7bffb3ec56f48754.webp 400w,
               /blog/hands-on-with-envoy-gateway/008vxvgGgy1h7jx54gkz4j30wi0p5wg9_hu_bad2cf2a7874c3c.webp 760w,
               /blog/hands-on-with-envoy-gateway/008vxvgGgy1h7jx54gkz4j30wi0p5wg9_hu_1f64495655e59257.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/hands-on-with-envoy-gateway/008vxvgGgy1h7jx54gkz4j30wi0p5wg9_hu_7bffb3ec56f48754.webp&#34;
               width=&#34;760&#34;
               height=&#34;588&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Backstage 界面
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果你正在开始使用 Istio 和 Envoy，请&lt;a href=&#34;https://academy.tetrate.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;查看 Tetrate 学院&lt;/a&gt;，你会发现大量的免费课程、研讨会，以及 Tetrate 的 Istio 管理员认证考试。&lt;/p&gt;
&lt;p&gt;要想以最简单的方式安装、管理和升级 Istio，请查看&lt;a href=&#34;https://istio.tetratelabs.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们的开源 Tetrate Istio 发行版（TID）&lt;/a&gt;。TID 是一个经过审查的 Istio 的上游发行版 ——Istio 的加固镜像，具有持续的支持，更容易安装、管理和升级。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>面向未来的网关：新的 Kubernetes Gateway API 和 Envoy Gateway 0.2 介绍</title>
      <link>https://cloudnativecn.com/blog/envoy-gateway-to-the-future/</link>
      <pubDate>Thu, 27 Oct 2022 10:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/envoy-gateway-to-the-future/</guid>
      <description>&lt;p&gt;最近 &lt;a href=&#34;https://blog.envoyproxy.io/introducing-envoy-gateway-ad385cc59532&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Gateway 0.2&lt;/a&gt; 发布了，API 网关的生态系统迎来了新的变化。这篇文章将想你介绍 Kubernetes API 网关领域的最新进展。&lt;/p&gt;
&lt;p&gt;如何将外部的网络请求路由到 Kubernetes 集群？你可以使用入口控制器：一组 HTTP 反向代理，将流量转接到集群中，并由 operator 来管理。也可以使用 Ambassador、Contour、Traefik 或 HAproxy 这类软件。还可以使用云提供商的解决方案，或者只是用默认的的 Nginx Ingress。或者你可能使用一个功能更全面的 API 网关，如 Tyk 或 Kong，或者在 Kubernetes Ingress 前面的另一层有一个单独的网关，如 AWS 的 API 网关，或内部的 F5，可以选择的实在太多。&lt;/p&gt;
&lt;h2 id=&#34;为什么我们需要一个新的入口控制器&#34;&gt;为什么我们需要一个新的入口控制器&lt;/h2&gt;
&lt;p&gt;因为很多入口控制器都有不同程度的限制：有些是基于旧的技术，如 Nginx、HAproxy，甚至是基于 Apache 建立的。这些技术的特性不适用于云原生环境，比如在配置改变时放弃已建立的连接（如果你想深入了解，Ambassador 发表了一篇&lt;a href=&#34;https://blog.getambassador.io/envoy-vs-nginx-vs-haproxy-why-the-open-source-ambassador-api-gateway-chose-envoy-23826aed79ef&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;比较&lt;/a&gt;文章）。云供应商的产品确实倾向于基于更现代的东西（比如 &lt;a href=&#34;https://www.usenix.org/system/files/conference/nsdi18/nsdi18-dalton.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SDN&lt;/a&gt;），但是这可能产生厂商锁定。目前，你只需用一个 Kubernetes API 来指定所有不同选项的配置：Ingress。这个 API 的可配置项很少，几乎任何你想配置的设置都需要通过 annotation 来实现，而不是作为一类字段。&lt;/p&gt;
&lt;h2 id=&#34;envoy-gateway未来-gateway-发展的基础&#34;&gt;Envoy Gateway：未来 Gateway 发展的基础&lt;/h2&gt;
&lt;p&gt;现在又有了新的选择：Envoy Gateway，简称 EG。顾名思义，这是一个基于 Envoy 代理的网关（入口控制器）。它是一个托管在 GitHub 上的 Envoy 社区项目。这不是第一个基于 Envoy 的入口；已经有流行的建立在 Envoy 之上的 Contour 和 Ambassador 等项目。但是这些项目的开发者和更多的人正在一起为 EG 做出贡献，Ambassador 和 Contour 都说他们会在适当的时候&lt;a href=&#34;https://blog.envoyproxy.io/introducing-envoy-gateway-ad385cc59532&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Envoy Gateway 的代码上重构&lt;/a&gt;（也就是说，我们 Tetrate 公司无可否认地为我们在这个项目中的领导作用感到自豪）。&lt;/p&gt;
&lt;p&gt;Envoy 本身是久经考验的入口代理、sidecar 代理，并且正在准备取代&lt;a href=&#34;https://cloud.google.com/docs/security/infrastructure/design#google_front_end_service&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;谷歌的 GFE&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;代码演示&#34;&gt;代码演示&lt;/h3&gt;
&lt;p&gt;如果你想在了解更多关于 Envoy Gateway 的内容之前先演练一番，我已经写了&lt;a href=&#34;https://tetr8.io/3MPT6KT&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一篇姐妹篇&lt;/a&gt;，其中有详细的说明，可以自己设置 Envoy Gateway，如果你没有环境，那篇文章中也包括了我机器上所有的命令输出，这样你就可以看到会发生什么。&lt;/p&gt;
&lt;h2 id=&#34;通往-api-的-gateway&#34;&gt;通往 API 的 Gateway&lt;/h2&gt;
&lt;p&gt;Envoy Gateway 以其最简单的形式 —— 你可能刚刚设置好的系统，将请求转发到其集群中。它根据 HTTP host 和 path 进行路由，也可以根据其他 header 进行路由。每个集群都需要这样做，很高兴看到 Envoy Gateway 在开发的短短 6 个月内就能做到这一点（要了解更多关于 Envoy Gateway 的信息，请看 &lt;a href=&#34;https://www.tetrate.io/envoy-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gateway to a New Frontier&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;超越基本入口的高级功能&#34;&gt;超越基本入口的高级功能&lt;/h3&gt;
&lt;p&gt;然而，许多组织需要比这个基本的 7 层网络路由更多的功能。如果需要像 WAF、body 的模式验证、bot 拦截等，许多人就会使用 API 网关。我们看到很多组织在他们的入口控制器前面部署了一个单独的 API 网关。然而，API 网关可以&lt;em&gt;取代&lt;/em&gt;入口控制器，因为它也可以做路由和流量观察的基本功能。它们可以提供这些功能，因为它们是由与入口控制器相同的代理构建的，例如，Kong 是基于 nginx 的。API 网关产品在市场上很受欢迎，但如果你真的想一想 API 网关是什么，它就是一个 HTTP 代理，有一系列的附加功能（我之前提到的 WAF 等）。这并不是说它们不增加任何价值 —— 它们提供的功能是多种多样的，而且很强大，但有一个共同的功能基线和实现代码。&lt;/p&gt;
&lt;h3 id=&#34;使用-wasm-的动态可扩展性&#34;&gt;使用 Wasm 的动态可扩展性&lt;/h3&gt;
&lt;p&gt;因此，Envoy Gateway 完全有能力发展成为一个全功能的 API 网关。Envoy 实际上已经具备了一些更先进的功能，包括 JWT 验证、OIDC 认证流和速率限制。此外，Envoy 是动态可扩展的；它可以在不重启的情况下加载插件，这意味着可以很容易地按需添加更多的功能。这些插件是以 WASM 字节码的形式提供的，这意味着它们可以用任何可以编译成 WASM 的语言（Tiny Go、Rust 等）编写，而不仅仅是其他代理支持的脚本语言。社区正在开始编写这些插件：缓存可能会首先落地，&lt;a href=&#34;https://coraza.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Coraza&lt;/a&gt; 项目是一个相对成熟的 &lt;code&gt;mod_security&lt;/code&gt; 风格的 WAF，用 Go 编写，可以编译成 WASM，现在可以用于 Envoy 代理。&lt;/p&gt;
&lt;h3 id=&#34;gateway-api-鼓励扩展&#34;&gt;Gateway API 鼓励扩展&lt;/h3&gt;
&lt;p&gt;在入口控制器市场上，扩展和竞争的另一大障碍是 API。需要特定于供应商的注解（或全新的特定于供应商的 API），这些注解很笨重，而且妨碍了交叉兼容。相比之下，Envoy Gateway 是由 Gateway API 配置的，这是 &lt;code&gt;gateway.networking.k8s.io &lt;/code&gt;API 组的一组资源。这个 API 将最终取代 Ingress 资源。它的核心已经比 Ingress 更加灵活和富有表现力，而且它被设计成以可管理的方式增长和扩展。这将允许它发展成为所有南北流量控制的一流模型，从基本的路由到先进的 API 管理功能。这反过来又会将 Envoy Gateway 拥有的所有功能，以一种标准的、与供应商无关的方式暴露出来，让人们在使用这些功能时无需跳过障碍或担心锁定问题。Envoy Gateway 将在 2023 年 3 月的 0.3 版本中支持 Gateway API 的这些新部分。&lt;/p&gt;
&lt;h3 id=&#34;为未来的网关发展提供一个共同的最佳的基础&#34;&gt;为未来的网关发展提供一个共同的、最佳的基础&lt;/h3&gt;
&lt;p&gt;Envoy Gateway 的动力来自于对 API 网关功能堆栈的日益关注。基本的入口正在变得商业化，所以社区正在汇集其资源和专业知识，为未来的网关开发创造一个共同的、最好的基础。同时提供新的 Gateway API 供其实现是非常方便的，Envoy Gateway 的 0.2 版本标志着对目前定义的 Gateway API 核心类型的全面支持。&lt;/p&gt;
&lt;p&gt;扩展到高级用例模型的工作已经开始，现在正在设计 &lt;a href=&#34;https://docs.google.com/document/d/1TlQjBy1utEwgrxE_HVT4-EHpVJ51hgnfMuAh0Q_uNoE/view&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWT auth 配置&lt;/a&gt;，其他的也将陆续推出。插件本身的工作也已经开始（例如，Coraza，一个仿照无处不在的 &lt;code&gt;mod_security&lt;/code&gt; 的 Golang WAF）。虽然这些都有很长的路要走，但我个人非常期待看到这一切在未来一两年的发展。&lt;/p&gt;
&lt;h2 id=&#34;通往服务网格的-gateway&#34;&gt;通往服务网格的 Gateway&lt;/h2&gt;
&lt;p&gt;你可能在想，已经有一类产品支持 OIDC 认证和速率限制等功能了：服务网格。这是真的；最突出的网格，Istio，在其默认配置中为入口部署了一套代理服务器。Istio 现在支持 Gateway API（就像 Envoy Gateway 一样）来配置该入口。我们在 Tetrate 对这种融合感到兴奋：企业现在可以采用 Envoy Gateway 来简单而快速地开展工作。Envoy Gateway 在管理这种南北流量方面做得很好，运行它可以让他们了解 Envoy 在生产中的性能和操作特点。当这些组织准备好控制他们的服务到服务，也就是东西向流量时，他们可以部署 Istio，因为他们已经熟悉了主要的基础组件（Envoy）。虽然他们可能会选择使用 Istio 的入口网关（以保持他们的控制平面数量减少到 1），但他们现有的 Gateway API 资源将继续工作。由于同样基于 Envoy，Istio 的 Ingress 也可以接受任何加载到 Envoy Gateway 的 API Gateway 风格的插件。所有这一切都使得在必要时增加服务网格的力量变得非常容易。&lt;/p&gt;
&lt;h3 id=&#34;用于入口和服务网格的统一-gateway-api&#34;&gt;用于入口和服务网格的统一 Gateway API&lt;/h3&gt;
&lt;p&gt;更重要的是，现在已经有了一个工作组来协调网关和网格网络之间的重叠部分：&lt;a href=&#34;https://gateway-api.sigs.k8s.io/contributing/gamma/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GAMMA 倡议&lt;/a&gt;。GAMMA 是 Gateway API for Mesh Management and Administration 的缩写，这是对 Gateway API 未来发展方向的一个倡议；计划是开始对服务网格的关注进行建模，即东西向流量也是如此。GAMMA 将确保 Envoy Gateway 和服务网格的良好合作，并将关注 Gateway API 的统一，以涵盖入口和网格。我们很高兴看到，这将为许多组织轻松和逐步地采用服务网格，基于一个与产品无关的 API，这对所有人都是好事。&lt;/p&gt;
&lt;h2 id=&#34;结束语&#34;&gt;结束语&lt;/h2&gt;
&lt;p&gt;这篇文章对新的标准 API、Gateway API 和参考实现 Envoy Gateway 作了很好的介绍，希望能对你了解当前的入口网关生态有所帮助。&lt;/p&gt;
&lt;p&gt;如果你想关注 EG 的发展，你可以加入 Envoy slack 的 &lt;code&gt;#gateway&lt;/code&gt; 频道，并在 &lt;a href=&#34;https://github.com/envoyproxy/gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/envoyproxy/gateway&lt;/a&gt; 查看提交和问题。该项目有一个 &lt;a href=&#34;https://github.com/envoyproxy/gateway/blob/main/docs/design/ROADMAP.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;未来几个版本的路线图&lt;/a&gt;，0.3.0 版本发布预期是在 2023 年 3 月。&lt;/p&gt;
&lt;p&gt;如果你想测试一下 Envoy Gateway，我写了一个配套的教程，其中包含了启动和运行的步骤说明。&lt;/p&gt;
&lt;p&gt;如果你正在开始使用 Istio 和 Envoy，请&lt;a href=&#34;https://academy.tetrate.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;查看 Tetrate 学院&lt;/a&gt;，你会发现大量的免费课程、研讨会，以及 Tetrate 的 Istio 管理员认证考试。&lt;/p&gt;
&lt;p&gt;要想以最简单的方式安装、管理和升级 Istio，请查看&lt;a href=&#34;https://istio.tetratelabs.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们的开源 Tetrate Istio 发行版（TID）&lt;/a&gt;。TID 是一个经过审查的 Istio 的上游发行版 ——Istio 的加固镜像，具有持续的支持，更容易安装、管理和升级。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>KrakenD API 网关更名为 Lura 项目并宣布加入了 Linux 基金会</title>
      <link>https://cloudnativecn.com/blog/krakend-api-gateway-joins-the-linux-foundation-as-the-lura-project/</link>
      <pubDate>Tue, 18 May 2021 12:03:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/krakend-api-gateway-joins-the-linux-foundation-as-the-lura-project/</guid>
      <description>&lt;h2 id=&#34;关于-lura-项目&#34;&gt;关于 Lura 项目&lt;/h2&gt;
&lt;p&gt;近日，&lt;a href=&#34;https://www.luraproject.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lura 项目&lt;/a&gt;，原名为 KrakenD 的开源框架，加入了 &lt;a href=&#34;https://training.linuxfoundation.org/training/course-catalog/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linux 基金会&lt;/a&gt;，根据一份新闻声明，“它将是唯一一个在中立、开放论坛中托管的企业级 API 网关”。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.krakend.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KrakenD API 网关&lt;/a&gt;的联合创始人兼首席执行官 &lt;a href=&#34;https://www.linkedin.com/in/alombarte/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Albert Lombarte&lt;/a&gt; 说，该项目现在每月活跃在 100 多万台服务器上。转到 Linux 基金会后，将技术放在了第一位，而不是企业公司的需求。&lt;/p&gt;
&lt;p&gt;“我们是真正的开源信徒，我们相信开源是这个项目的归宿，“Lombarte 说。“我们已经看到，技术与 API 网关玩得不好，所采取的做法不是技术的最佳做法，“而是为了营销或销售产品的需要，为了锁定客户。“而我们希望能解放这一点，“他指出。&lt;/p&gt;
&lt;p&gt;KrakenD API 网关建立在现在被称为 Lura 项目的基础上，Lombarte 解释说，KrakenD 是一个有主见的实现，即它注重速度而不是其他功能。Lura 是一个构建 API 网关的框架，可以根据企业的需求进行定制。它是为速度和可扩展性而设计的。Lombarte 说，Lura 用 Go 语言构建，是一个无状态、高性能的 API 网关框架，为云原生和内部设置而设计，无状态是一个区别点。&lt;/p&gt;
&lt;p&gt;“如果你采取传统的 API 网关，你会发现配置是存储在数据库上的。我们没有任何形式的数据库，所以所有的配置都在一个静态的配置文件中，“Lombarte 说。&amp;quot; &lt;strong&gt;如果你想改变网关的状态，你必须重新部署另一个版本的网关。它就像今天任何公司的任何微服务一样工作。这就是我们和有状态网关的主要区别。&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;此外，有状态网关的问题是可扩展性，Lombarte 说。“因为它们通常连接到一个数据库，而这个数据库是唯一的真实数据来源，所有的节点都需要协调。因此，如果你去找大客户，他们无法正常扩展，因为他们有一个瓶颈，那就是数据库。我们节点甚至不互相通信，所以它们可以线性地扩展到无限大。”&lt;/p&gt;
&lt;p&gt;Lura 的另一个区别点是，其 API 网关超越了传统的 API 网关，&lt;strong&gt;作为多个微服务的聚合器发挥作用，而不是简单地作为一个扩展的代理&lt;/strong&gt;。Lombarte 说，市场上的所有 API 网关都只是“中间有共享关注点的代理”，API 调用到达一个单一的后端服务。相反，Lura 允许聚集许多后端服务，可以通过调用它创建的单一 API 端点到达，而且这些后端服务中的每一个实际上也可以提供不同的 API 类型。&lt;/p&gt;
&lt;p&gt;“当你广泛地谈论 API 网关时，人们通常会想到 API 网关将授权请求，也许还有速率限制。这是每个人对 API 网关的理解，但这只是用其他东西进行代理，“Lombarte 说。“我们所做的是，我们创建一个新的 API，所以你不再消费你的后台，你在消费我们的 API 网关。这就像前端的一个后端。&lt;strong&gt;我们比市场上任何其他 API 网关更接近 GraphQL&lt;/strong&gt;&amp;quot;。&lt;/p&gt;
&lt;p&gt;Lombarte 说，如果你正在寻找这些强调速度的功能，那么 KrakenD 可能是正确的选择，但如果你需要专注于其他功能，那么 Lura 就可以帮助建立你需要的功能。他说，只需 20 到 30 行代码，你就可以使用 Lura 建立并运行一个 API 网关。eBay 和 Mail.ru 是目前使用 Lura 的两个大机构的例子。他说，这项技术提供了速度和无限的线性可扩展性，但也允许他们根据自己的需要定制 API 网关。&lt;/p&gt;
&lt;h2 id=&#34;未来计划&#34;&gt;未来计划&lt;/h2&gt;
&lt;p&gt;在 Lura 捐赠给 Linux 基金会之后，Lombarte 说，Lura 2.0 预计将在不久的将来发布，路线图中的新功能是支持 GraphQL 和能够用自定义插件进一步扩展该项目。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache APISIX 的全流量 API 网关统筹集群流量</title>
      <link>https://cloudnativecn.com/blog/full-traffic-api-gateway-based-on-apache-apisix/</link>
      <pubDate>Wed, 30 Sep 2020 16:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/full-traffic-api-gateway-based-on-apache-apisix/</guid>
      <description>&lt;p&gt;本文根据我在云原生学院的分享整理而成，视频见 &lt;a href=&#34;https://www.bilibili.com/video/BV1Gt4y1q7qC&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bilibli&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;bilibili.jpg&#34;&gt;云原生学院&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文将从云原生时代的机遇和挑战说起，介绍一个全新的开源高性能云原生 API 网关——Apache APISIX，探讨如何解决云原生时代 API 网关所面临的一些痛点，最后介绍该开源项目未来的规划。&lt;/p&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;h3 id=&#34;云原生的机遇和挑战&#34;&gt;云原生的机遇和挑战&lt;/h3&gt;
&lt;p&gt;很多应用和服务都在向微服务、容器化迁移，形成新的云原生时代。云原生是下一个 5-10 年的技术颠覆，重写了传统企业的技术架构，例如云原生中的 Kubernetes 颠覆了传统操作系统，所有的“主机”（node 上的容器）由 Kubernetes 来控制和编排，非常适用于公有云、私有云、混合云等各种环境。云原生体系的特点之一就是由各种开源项目组成，不同于以往的商业闭源项目，缓解了收费贵等问题，加速了技术落地。现代公司的技术是非常重要的组成部分，在一个商业竞争激烈的时代，公司愈早的占据技术顶峰愈是能够占据商业顶峰。网关作为云原生入口，是掌握云原生的一个必经之地，是开启“财富”的关键钥匙。&lt;/p&gt;
&lt;h3 id=&#34;微服务的演进&#34;&gt;微服务的演进&lt;/h3&gt;
&lt;p&gt;从 2014-2015 年，谷歌搜索引擎上“微服务”关键字的搜索趋势呈直线上升。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps1_hu_a05a9d187a468c97.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps1_hu_c902c50fad36a7dc.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps1_hu_978022d34aa17d18.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/full-traffic-api-gateway-based-on-apache-apisix/wps1_hu_a05a9d187a468c97.webp&#34;
               width=&#34;760&#34;
               height=&#34;468&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在单体架构上，任一请求都会负载到整个的单体服务集群上。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps2_hu_cc363ee9df349bd6.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps2_hu_9999fefedd19dd1.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps2_hu_23181617e52d054c.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/full-traffic-api-gateway-based-on-apache-apisix/wps2_hu_cc363ee9df349bd6.webp&#34;
               width=&#34;760&#34;
               height=&#34;309&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在微服务架构上，对应请求会负载到微服务中对应的的子服务集群上。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps3_hu_6e4265d31e1408b3.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps3_hu_2bd379223a8b6e46.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps3_hu_e42fc9e2d80d8605.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/full-traffic-api-gateway-based-on-apache-apisix/wps3_hu_6e4265d31e1408b3.webp&#34;
               width=&#34;760&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用微服务进行精细管理后，服务的弹性伸缩、开发团队变得敏捷、服务之间隔离、降低故障率；在流量变动的时候，只需要对有可能变动流量的服务进行对应资源的扩缩容即可，这样可以很明显的节省服务器成本以及更高的承受度；在业务变动的时候，只需要对有可能变动业务的服务进行对应业务模块的变动即可，这样可以很明显的节省人力成本以及更高的控制力；在出现故障时不会导致整体服务不可用。&lt;/p&gt;
&lt;p&gt;但是落地微服务同样的带来了一些问题，比如接口之间通用的功能重复开发、膨胀的服务数量、难以管理。通常的解决方案便是使用 API 网关对其进行管理。&lt;/p&gt;
&lt;h3 id=&#34;微服务与-api-网关&#34;&gt;微服务与 API 网关&lt;/h3&gt;
&lt;p&gt;使用 API 网关进行管理，通常的做法是将微服务框架中功能型的功能统一放到网关上，例如可观测性 metrics、应用性能 apm tracing、限速、身份认证、日志等等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps4_hu_80ca054ac48fbd73.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps4_hu_84bfbdb22ae981f4.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps4_hu_f23b825bd4fdf367.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/full-traffic-api-gateway-based-on-apache-apisix/wps4_hu_80ca054ac48fbd73.webp&#34;
               width=&#34;760&#34;
               height=&#34;286&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;灰度发布&#34;&gt;灰度发布&lt;/h4&gt;
&lt;p&gt;灰度发布也叫金丝雀发布，起源是，矿井工人发现，金丝雀对瓦斯气体很敏感，矿工会在下井之前，先放一只金丝雀到井中，如果金丝雀不叫了，就代表瓦斯浓度高。灰度发布会将流量按比例划分给已经上线的版本（比如 1.0，占比 90%）以及正在上线的版本（比如 1.01，占比 10%），若观测没有问题，逐步调整二者的流量占比直到流量完全切到 1.01 版本。Apache APISIX 内置的灰度发布支持读取到的 HTTP 请求参数中包含了 NGINX 的所有变量，可以依据变量进行灰度，甚至支持 LUA 代码去运算处理请求的请求体、请求参数。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps6_hu_fcd57ac7691f5d42.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps6_hu_20651a37302fe416.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps6_hu_119da3b57bf6d619.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/full-traffic-api-gateway-based-on-apache-apisix/wps6_hu_fcd57ac7691f5d42.webp&#34;
               width=&#34;760&#34;
               height=&#34;318&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;服务熔断&#34;&gt;服务熔断&lt;/h4&gt;
&lt;p&gt;如图所示，当 Invoices 服务出现大量常见错误达到配置的熔断阈值就可以直接熔断不接收请求了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps7_hu_1067bbdbed0e278f.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps7_hu_187cc62ee57f1795.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps7_hu_be1cfb74826c3ebe.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/full-traffic-api-gateway-based-on-apache-apisix/wps7_hu_1067bbdbed0e278f.webp&#34;
               width=&#34;760&#34;
               height=&#34;353&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;apache-apisix-在传统和云原生领域的支持粒度&#34;&gt;Apache APISIX 在传统和云原生领域的支持粒度&lt;/h4&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;作用在传统 API 网关领域的功能&lt;/th&gt;
          &lt;th&gt;作用在云原生 API 网关领域的功能&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;让 API 请求更安全、更高效的得到处理；&lt;br /&gt;覆盖 Nginx 的所有功能：反向代理、负载均衡；&lt;br /&gt;动态上游、动态 SSL 证书、动态限流限速；主动/被动健康检查、服务熔断&lt;/td&gt;
          &lt;td&gt;对接 Prometheus、Zipkin、Skywalking；&lt;br /&gt;gRPC 代理和协议转换 (REST &amp;lt;-&amp;gt; gRPC)；&lt;br /&gt;身份认证：OpenID Relying Party、OP（Auth0、okta……）&lt;br /&gt;高性能、无状态、随意扩容和缩容&lt;br /&gt;动态配置，不用 reload 服务&lt;br /&gt;支持多云、混合云&lt;br /&gt;容器优先，Kubernetes 友好&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;api-生命周期管理全景图&#34;&gt;API 生命周期管理全景图&lt;/h3&gt;
&lt;p&gt;API 生命周期指的是从 API 的设计到 API 的文档和他的 SDK 以及他的 API 的上线之类，甚至还包括 API 的市场等等一整套的解决方案，网关在其中是核心角色。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image-20200929155124157&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image-20200929155124157&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/image-20200929155124157_hu_a5ed08702783a.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/image-20200929155124157_hu_7853d6ad829c0f9.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/image-20200929155124157_hu_462c01df6f90965d.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/full-traffic-api-gateway-based-on-apache-apisix/image-20200929155124157_hu_a5ed08702783a.webp&#34;
               width=&#34;757&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image-20200929155124157
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在上半象限都是一些巨头公司，例如 Google、IBM 等等，都是公有云的闭源项目，具有领导地位，跟各自产品深度绑定在一起。在下半象限都是援建者，都是开源项目，例如：Kong，挑战着闭源项目，随着时间的推移我们发现——软件在吞噬世界、开源软件在吞噬软件。以下是近几年发生的很多 API 网关厂商相关的收购案例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2015 年，IBM 收购 StrongLoop&lt;/li&gt;
&lt;li&gt;2015 年，谷歌 6.25 亿美元收购 apigee&lt;/li&gt;
&lt;li&gt;2018 年，Salesforce 65 亿美元收购 MuleSoft&lt;/li&gt;
&lt;li&gt;2018 年，Broadcom 189 亿美元收购 CA Technologies&lt;/li&gt;
&lt;li&gt;2019 年，F5 收购 6.7 亿美元收购 NGINX&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明 API 网关在云原生时代依然扮演者重要的角色&lt;/p&gt;
&lt;h2 id=&#34;深入浅出-apache-apisix&#34;&gt;深入浅出 Apache APISIX&lt;/h2&gt;
&lt;h3 id=&#34;设计思路&#34;&gt;设计思路&lt;/h3&gt;
&lt;p&gt;API 网关的数据面和控制面分离。控制面不仅能控制 Apache APISIX 还能控制其他组件；数据面不仅仅能被我的控制面控制，还能被其他组件所控制&lt;/p&gt;
&lt;p&gt;通过插件机制来方便二次开发和运维。拿 Envoy 来说，Envoy 的插件是使用 C++ 编写的，C++ 本身就具有很大的复杂性；再来对比下 Kong，Kong 开发一个 IP 黑白名单插件需要写 300+ 行代码，并且插件配置解析、插件逻辑等代码分布在 3-4 个文件中；而 Apache APISIX 开发同样功能的插件只需要一个文件并且只需要 70 行代码。&lt;/p&gt;
&lt;p&gt;默认高可用，没有单点故障。因为使用了 ETCD 来存储和分发路由数据&lt;/p&gt;
&lt;p&gt;安全和稳定第一。Apache APISIX 基于 Nginx 实现，支持 mTLS 认证以及敏感信息加密加盐 (salt) 保存。为什么选择 Nginx 呢？它是基于 C 语言开发的程序，性能优化到极致，Nginx 的底层开发做的非常好，并且在大规模适用上得到充分有效的验证，从性能角度上是最佳选择&lt;/p&gt;
&lt;p&gt;高性能。Apache APISIX 基于 Nginx 的网络层，其单核心 QPS 1.5 万，延迟低于 0.7 毫秒。&lt;/p&gt;
&lt;p&gt;运维友好。它支持 Prometheus、SkyWalking 动态追踪、流量复制、故障注入等功能&lt;/p&gt;
&lt;h3 id=&#34;技术架构&#34;&gt;技术架构&lt;/h3&gt;
&lt;p&gt;Apache APISIX 架构如图，其主要分为数据面和控制面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据面：以 Nginx 的网络库为基础，（弃用 Nginx 的路由匹配、静态配置和 C 模块），使用 Lua 和 Nginx 动态控制请求流量，通过插件机制来实现各种流量处理和分发的功能：限流限速、日志记录、安全检测、故障注入等，同时支持用户编写自定义插件来对数据面进行扩充。&lt;/li&gt;
&lt;li&gt;控制面：使用 etcd 来存储和同步网关的配置数据，管理员通过 admin API 或者 dashboard 可以在毫秒级别内通知到所有的数据面节点，同时 etcd 集群也保证了系统的高可用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps15_hu_952be84b81f04716.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps15_hu_1aa059ceabcf2f75.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps15_hu_3038c143e59589a2.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/full-traffic-api-gateway-based-on-apache-apisix/wps15_hu_952be84b81f04716.webp&#34;
               width=&#34;760&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;因为 Apache APISIX 使用了 ETCD 作为配置中心，在对应其他组件时会非常方便，可以把 ETCD 直接就当做服务注册发现中心来使用（服务注册、发现），当然同时也支持 Consul、Eureka、Nacos 等服务注册中心。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps16_hu_d9a7563ecaeae7de.webp 400w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps16_hu_e0ccc67fa93b8483.webp 760w,
               /blog/full-traffic-api-gateway-based-on-apache-apisix/wps16_hu_5d7a0e88b51e583d.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/full-traffic-api-gateway-based-on-apache-apisix/wps16_hu_d9a7563ecaeae7de.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;高性能&#34;&gt;高性能&lt;/h3&gt;
&lt;p&gt;Apache 只是使用了 Nginx 的网络库而并没有使用路由库，重写优化了路由算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apache APISIX 的路由复杂度是 O (k)，只和 URI 的长度有关，和路由数量无关；kong 的路由时间复杂度是 O (n) ，随着路由数量线性增长，K 指 URI 长度，和路由数量没有关系，例如有一百万条路由，ApiSix 路由的时间复杂度都是一样的，而 Kong 却不是这样的；&lt;/li&gt;
&lt;li&gt;Apache APISIX 的 IP 匹配时间复杂度是 O (1)，不会随着大量 IP 判断而导致 CPU 资源跑满；kong 的最新版本也换用了 Apache APISIX 的 IP 匹配库；不管有多少 IP 都是一次命中，而 Kong 却不是这样的；&lt;/li&gt;
&lt;li&gt;Apache APISIX 的路由匹配，接受 nginx 的所有变量作为条件，并且支持自定义函数；其他网关都是内置的几个条件；&lt;/li&gt;
&lt;li&gt;Apache APISIX 使用 etcd 作为配置中心，没有单点，任意宕掉一台机器，网关集群还能正常运行。其他基于 mysql，postgres 的网关都会有单点问题；&lt;/li&gt;
&lt;li&gt;Apache APISIX 的配置下发只要 1 毫秒就能达到所有网关节点，使用的是 etcd 的 watch；其他网关是定期轮询数据库，一般需要 5 秒才能获取到最新配置；&lt;/li&gt;
&lt;li&gt;只有 Apache APISIX 开放了自定义负载均衡的挂载点，其他网关都不支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;独创的插件编排&#34;&gt;独创的插件编排&lt;/h3&gt;
&lt;p&gt;基于已有插件的基础上，通过在界面上拖拖拽拽就可以生成一个全新的插件。&lt;/p&gt;
&lt;p&gt;通过插件编排的方式可以把 Apache APISIX 的四十多个插件的上下游关系全部串联起来形成一个新的插件。&lt;/p&gt;
&lt;p&gt;当前，Kong 支持 Go 编写的插件，Envoy 支持 Lua、WASM 编写的 filter。那么，Apache APISIX 的使用者为什么要“写”插件？我们认为运维、PM 也可以直接通过浏览器页面创造一个自己的插件。&lt;/p&gt;
&lt;p&gt;为了支持插件编排，Apache APISIX 一方面需要实现微插件、低代码，同时需要底层架构和插件足够灵活。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34;
           src=&#34;https://cloudnativecn.com/blog/full-traffic-api-gateway-based-on-apache-apisix/low-code-api-gateway-example-en-US.gif&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;同类技术对比&#34;&gt;同类技术对比&lt;/h3&gt;
&lt;h4 id=&#34;apache-apisix-vs-kong&#34;&gt;Apache APISIX vs Kong&lt;/h4&gt;
&lt;p&gt;有对比才更有说服力，Apache APISIX 和 Kong 都是基于 Openresty/LuaJIT 实现的高性能 API 网关，让我们来对比下他们的异同。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;对⽐比项&lt;/th&gt;
          &lt;th&gt;APISIX&lt;/th&gt;
          &lt;th&gt;Kong&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;技术架构&lt;/td&gt;
          &lt;td&gt;Nginx + etcd&lt;/td&gt;
          &lt;td&gt;Nginx + postgres&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;高可用&lt;/td&gt;
          &lt;td&gt;非常可靠，没有单点&lt;/td&gt;
          &lt;td&gt;一般，有数据库的单点&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;精细化路由&lt;/td&gt;
          &lt;td&gt;支持 Nginx 变量和自定义函数&lt;/td&gt;
          &lt;td&gt;固定的⼏个条件&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;配置⽣效时间&lt;/td&gt;
          &lt;td&gt;事件驱动，小于 1 毫秒&lt;/td&gt;
          &lt;td&gt;轮询拉取，5 秒&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;处理延迟&lt;/td&gt;
          &lt;td&gt;0.2 毫秒&lt;/td&gt;
          &lt;td&gt;2 毫秒&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;性能（单核，开启两个限流和 prometheus 插件）&lt;/td&gt;
          &lt;td&gt;18000&lt;/td&gt;
          &lt;td&gt;1700&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;支持流量复制和故障&lt;/td&gt;
          &lt;td&gt;是&lt;/td&gt;
          &lt;td&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;注⼊&lt;/td&gt;
          &lt;td&gt;是&lt;/td&gt;
          &lt;td&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;支持 SkyWalking&lt;/td&gt;
          &lt;td&gt;是&lt;/td&gt;
          &lt;td&gt;否&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;插件热更新&lt;/td&gt;
          &lt;td&gt;新增、删除、更新插件不用重载服务&lt;/td&gt;
          &lt;td&gt;无，每次都需要重载服务&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;二次开发&lt;/td&gt;
          &lt;td&gt;难度低&lt;/td&gt;
          &lt;td&gt;难度中等&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;本地技术支持&lt;/td&gt;
          &lt;td&gt;有，1 小时响应&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;定期巡检和培训&lt;/td&gt;
          &lt;td&gt;有&lt;/td&gt;
          &lt;td&gt;无&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因此我们发现 Apache APISIX 的分布式可靠性强，路由支持丰富，配置变更生效时间快，网关处理速度快，资源消耗率低，混沌测试支持度高，监控系统 (如 SkyWalking) 支持度高，插件变动动态化程度高以及二次开发难度低。&lt;/p&gt;
&lt;h4 id=&#34;apache-apisix-vs-nginx&#34;&gt;Apache APISIX vs Nginx&lt;/h4&gt;
&lt;p&gt;Nginx 是一款轻量级 Web 服务器、反向代理服务器，由于它的内存占用少、启动极快、高并发能力强，故其在互联网项目中得到广泛应用，距今已经有十多年的历史。但 Nginx 在步入云原生时代后遇到了更多的挑战：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;社区不活跃：没有 github issue 和 PR&lt;/li&gt;
&lt;li&gt;没有跟进云原生：nginx-k8s-controller、nginx unit 的尝试都失败了&lt;/li&gt;
&lt;li&gt;配置不能热加载&lt;/li&gt;
&lt;li&gt;非 http、https 流量的兴起（微服务、物联网……）&lt;/li&gt;
&lt;li&gt;商业化不成功&lt;/li&gt;
&lt;li&gt;被 F5 收购&lt;/li&gt;
&lt;li&gt;后浪：API 网关比如 Kong 和 Apache APISIX，serviceMesh proxy 比如 Envoy 等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开源社区规划&#34;&gt;开源社区规划&lt;/h2&gt;
&lt;h3 id=&#34;运营-apache-孵化器项目的经验&#34;&gt;运营 Apache 孵化器项目的经验&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为了让社区和用户保持习惯和预期，每个月一个版本，雷打不动。&lt;/li&gt;
&lt;li&gt;当天回复邮件列表和 github issue、PR&lt;/li&gt;
&lt;li&gt;频繁的布道和走访用户：每个月一次 meetup，走访过美团、腾讯、华为、贝壳、平安、又拍云、中国移动、思必驰、空中云汇、中国航信等几十家企业，深入了解用户的需求&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;the-apache-way&#34;&gt;The Apache Way&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不看重 github star，更关注如何吸引新的贡献者以及如何让贡献者更加活跃&lt;/li&gt;
&lt;li&gt;贡献不止代码，文档、测试、文章都是贡献，都可以成为 committer 和 PMC&lt;/li&gt;
&lt;li&gt;社区多样性：近 30 位 committer，其中两位欧洲开发者；至少 4 位大学生，甚至有 00 后的后浪贡献者，是 Apache APISIX committer&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;社区大于代码&#34;&gt;社区大于代码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The Apache Way&lt;/li&gt;
&lt;li&gt;活跃的社区，会重构坏的代码；但再好的代码，也会死于独裁的社区&lt;/li&gt;
&lt;li&gt;案例：Apache APISIX dashboard 的重构，社区对于 MySQL 的方案不满，“怨声载道”，然后来自 5 家公司的贡献者一起重构掉它&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;规划&#34;&gt;规划&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;2.0 版本（即将发布）：使用 etcd v3 替代 v2&lt;/li&gt;
&lt;li&gt;3.0 版本：废弃 admin API，分离 DP 和 CP&lt;/li&gt;
&lt;li&gt;2021 年的 ﬂag：Apache APISIX 的贡献者超过 200 位&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;
&lt;p&gt;如果你还在被 Nginx 或者 Nginx Ingress 的 reload 性能问题所折磨，又或者对 Kong 的转发能力并不满意，欢迎大家使用 Apache APISIX&lt;/p&gt;
&lt;p&gt;欢迎大家给 Apache APISIX 贡献！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目地址：https://github.com/apache/apisix&lt;/li&gt;
&lt;li&gt;邮箱：&lt;a href=&#34;mailto:wenming@apache.org&#34;&gt;wenming@apache.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;QQ 群：578997126&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感谢&lt;a href=&#34;https://github.com/tristan-tsl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;谭世霖&lt;/a&gt;对本文内容的整理，&lt;a href=&#34;https://github.com/Miss-you&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;厉辉&lt;/a&gt;、&lt;a href=&#34;https://github.com/hyfj44255&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;杨冉宁&lt;/a&gt;、&lt;a href=&#34;https://github.com/rootsongjc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;宋净超&lt;/a&gt;参与审阅。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh 和 API Gateway 关系深度探讨</title>
      <link>https://cloudnativecn.com/blog/service-mesh-and-api-gateway/</link>
      <pubDate>Tue, 28 Apr 2020 11:20:46 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/service-mesh-and-api-gateway/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;关于 Service Mesh 和 API Gateway 之间的关系，这个问题过去两年间经常被问起，社区也有不少文章和资料给出解答。其中不乏 Christian Posta 这样的网红给出过深度介绍。我在这里做一个资料的整理和汇总，结合个人的理解给出一些看法。另外在本文最后，介绍蚂蚁金服在 Service Mesh 和 API Gateway 融合的这个最新领域的一些开创性的实践和探索，希望给大家一个更有体感的认知。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注 1：为了节约篇幅，我们将直奔主题，假定读者对 Service Mesh 和 API Gateway 已有基本的了解。&lt;/p&gt;
&lt;p&gt;备注 2:  这边文章更关注于梳理整个脉络，内容不会展开的特别细，尤其是其他文章已经详细阐述的部分。如果您在浏览本文之后，还想更深入的了解细节，请继续阅读文章最后的参考资料和推荐阅读。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;原本清晰的界限定位和职责&#34;&gt;原本清晰的界限：定位和职责&lt;/h2&gt;
&lt;p&gt;首先，Service Mesh 和 API Gateway 在功能定位和承担的职责上有非常清晰的界限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Mesh：微服务的网络通信基础设施，负责（系统内部的）服务间的通讯&lt;/li&gt;
&lt;li&gt;API Gateway：负责将服务以 API 的形式暴露（给系统外部），以实现业务功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hu_49c9b1d3061bd4dc.webp 400w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hu_82ce5ad669f7b70f.webp 760w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hu_1da5ed7dd8879f8b.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/relationship-without-bff_hu_49c9b1d3061bd4dc.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从功能和职责上说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位于最底层的是拆分好的原子微服务，以服务的形式提供各种能力&lt;/li&gt;
&lt;li&gt;在原子微服务上是（可选的）组合服务，某些场景下需要将若干微服务的能力组合起来形成新的服务&lt;/li&gt;
&lt;li&gt;原子微服务和组合服务部署于 &lt;strong&gt;系统内部&lt;/strong&gt;，在采用 Service Mesh 的情况下，由 Service Mesh 提供服务间通讯的能力&lt;/li&gt;
&lt;li&gt;API Gateway 用于将系统内部的这些服务暴露给 &lt;strong&gt;系统外部&lt;/strong&gt;，以 API 的形式接受外部请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从部署上说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Mesh 部署在系统内部：因为原子微服务和组合服务通常不会直接暴露给外部系统&lt;/li&gt;
&lt;li&gt;API Gateway 部署在系统的边缘：一方面暴露在系统之外，对外提供 API 供外部系统访问；一方面部署在系统内部，以访问内部的各种服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里引入两个使用非常广泛的术语：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/directions_hu_c89db67747e5618b.webp 400w,
               /blog/service-mesh-and-api-gateway/directions_hu_4b5c0696dd02ecc6.webp 760w,
               /blog/service-mesh-and-api-gateway/directions_hu_9f2c8731caedb44e.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/directions_hu_c89db67747e5618b.webp&#34;
               width=&#34;760&#34;
               height=&#34;325&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;东西向&lt;/strong&gt;通讯：指服务间的相互访问，其通讯流量在服务间流转，流量都位于系统内部&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;南北向&lt;/strong&gt;通讯：指服务对外部提供访问，通常是通过 API Gateway 提供的 API 对外部暴露，其通讯流量是从系统外部进入系统内部。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;解释一下“东西南北”的由来：如上图所示，通常在地图上习惯性的遵循“上北下南，左东右西”的原则。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;总结：Service Mesh 和 API Gateway 在功能和职责上分工明确，界限清晰。但如果事情就这么结束，也就不会出现 Service Mesh 和 API Gateway 关系的讨论了，自然也不会有本文。&lt;/p&gt;
&lt;p&gt;问题的根源在哪里？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈推荐阅读：附录中 Christian Posta 的文章 &amp;ldquo;Do I Need an API Gateway if I Use a Service Mesh?&amp;ldquo;对此有深度分析和讲解。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;哲学问题网关访问内部服务算东西向还是南北向&#34;&gt;哲学问题：网关访问内部服务，算东西向还是南北向？&lt;/h2&gt;
&lt;p&gt;如下图所示，图中黄色的线条表示的是 API Gateway 访问内部服务：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hu_49c9b1d3061bd4dc.webp 400w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hu_82ce5ad669f7b70f.webp 760w,
               /blog/service-mesh-and-api-gateway/relationship-without-bff_hu_1da5ed7dd8879f8b.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/relationship-without-bff_hu_49c9b1d3061bd4dc.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;问题来了，从流量走向看：这是外部流量进入系统后，开始访问对外暴露的服务，应该属于“南北向”通讯，典型如上图的画法。但从另外一个角度，如果我们将 API Gateway 逻辑上拆分为两个部分，先忽略对外暴露的部分，单独只看  API Gateway  访问内部服务的部分，这时可以视 API Gateway 为一个普通的客户端服务，它和内部服务的通讯更像是“东西向”通讯：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-access-service_hu_c4c35c0d147fd231.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service_hu_6576c3063a55cbac.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service_hu_25ac025676c923ae.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/api-gateway-access-service_hu_c4c35c0d147fd231.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;所以，API Gateway 作为一个客户端访问内部服务时，到底算南北向还是东西向，就成为一个哲学问题：完全取决于我们如何看待 API Gateway，是作为一个整体，还是逻辑上分拆为对内对外两个部分。&lt;/p&gt;
&lt;p&gt;这个哲学问题并非无厘头，在 API Gateway 的各种产品中，关于如何实现“API Gateway 作为一个客户端访问内部服务” ，就通常分成两个流派：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;泾渭分明：视 API Gateway 和内部服务为两个独立事物，API Gateway 访问内部服务的通讯机制自行实现，独立于服务间通讯的机制&lt;/li&gt;
&lt;li&gt;兼容并济：视 API Gateway 为一个普通的内部服务的客户端，重用其内部服务间通讯的机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而最终决策通常也和产品的定位有关：如果希望维持  API Gateway 的独立产品定位，希望可以在不同的服务间通讯方案下都可以使用，则通常选择前者，典型如 kong；如果和服务间通讯方案有非常深的渊源，则通常选择后者，典型如 springcloud 生态下的 zuul 和 springcloud gateway。&lt;/p&gt;
&lt;p&gt;但无论选择哪个流派，都改变不了一个事实，当“API Gateway 作为一个客户端访问内部服务”时，它的确和一个普通内部服务作为客户端去访问其他服务没有本质差异：服务发现，负载均衡，流量路由，熔断，限流，服务降级，故障注入，日志，监控，链路追踪，访问控制，加密，身份认证&amp;hellip;&amp;hellip; 当我们把网关访问内部服务的功能一一列出来时，发现几乎所有的这些功能都是和服务间调用重复。&lt;/p&gt;
&lt;p&gt;这也就造成了一个普遍现象：如果已有一个成熟的服务间通讯框架，再去考虑实现 API Gateway，重用这些重复的能力就成为自然而然的选择。典型如前面提到的 springcloud 生态下的 zuul 以及后面开发的 springcloud gateway，就是以重用类库的方式实现了这些能力的重用。&lt;/p&gt;
&lt;p&gt;这里又是一个类似的哲学问题：当“API Gateway 作为一个客户端访问内部服务”时，它以重用类库的方式实现了代码级别的能力重用，相当于自行实现了一个和普通服务间通讯方案完全一样的客户端，那这个“客户端”发出来的流量算东西向还是南北向？&lt;/p&gt;
&lt;p&gt;答案不重要。&lt;/p&gt;
&lt;h2 id=&#34;sidecar真正的重合点&#34;&gt;Sidecar：真正的重合点&lt;/h2&gt;
&lt;p&gt;在进入 Service Mesh 时代之后，Service Mesh 和 API gateway 的关系开始是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;功能和职责清晰划分&lt;/li&gt;
&lt;li&gt;客户端访问服务的功能高度重叠&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时两者的关系很清晰，而且由于当时 Service Mesh 和 API Gateway 是不同的产品，两者的重合点只是在功能上。&lt;/p&gt;
&lt;p&gt;而随着时间的推移，当 Service Mesh 产品和 API Gateway 产品开始出现相互渗透时，两者的关系就开始变得暧昧。&lt;/p&gt;
&lt;p&gt;在 Service Mesh 出现之后，如何为基于 Service Mesh 的服务选择合适的 API Gateway 方案，就慢慢开始提上日程，而其中选择重用 Service Mesh 的能力也自然成为一个探索的方向，并逐步出现新式 API Gateway 产品，其想法很直接：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何融合东西向和南北向的通讯方案？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中的一个做法就是基于 Service Mesh 的 Sidecar 来实现 API Gateway，从而在南北向通讯中引入 Service Mesh 这种东西向通讯的方案。这里我们不展开细节，我这里援引一个图片（鸣谢赵化冰同学）来解释这个方案的思路：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hu_2f0776aba4a93cfc.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hu_94fd8e4c46d12d0f.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hu_13faff7c9162c6a4.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/api-gateway-with-service-mesh_hu_2f0776aba4a93cfc.webp&#34;
               width=&#34;760&#34;
               height=&#34;244&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个时候 Service Mesh 和 API Gateway 的关系就变得有意思了，因为 Service Mesh 中 sidecar 的引入，所以前面的“哲学问题”又有了一个新的解法：API Gateway 这次真的可以分拆为两个独立部署的物理实体，而不是逻辑上的两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;API Gateway 本体：实现 API Gateway 除了访问内部服务之外的功能&lt;/li&gt;
&lt;li&gt;Sidecar：按照 Service Mesh 的标准做法，我们视 API Gateway 为一个部署于 Service Mesh 中的普通服务，为这个服务 1:1 的部署 sidecar&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_hu_1f7f269e1cac5832.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_hu_266d638fbc38267.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_hu_a57623157dc4b43a.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/api-gateway-access-service-via-sidecar_hu_1f7f269e1cac5832.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个方案中，原来用于 Service Mesh 的 sidecar，被用在了 API Gateway 中，替代了 API Gateway 中原有的客户端访问的各种功能。这个方案让 API Gateway 的实现简化了很多，也实现了东西向和南北向通讯能力的重用和融合，而 API Gateway 可以更专注于“API Management”的核心功能。&lt;/p&gt;
&lt;p&gt;此时 Service Mesh 和 API Gateway 的关系就从“泾渭分明”变成了“兼容并济”。&lt;/p&gt;
&lt;p&gt;而采用这个方案的公司，通常都是先有 Service Mesh 产品，再基于 Service Mesh 产品规划（或者重新规划）API Gateway 方案，典型如蚂蚁金服的 SOFA Gateway 产品是基于 MOSN，而社区开源产品 Ambassador 和 Gloo 都是基于 Envoy。&lt;/p&gt;
&lt;p&gt;上述方案的优势在于 API Gateway 和 Sidecar 独立部署，职责明确，架构清晰。但是，和 Service Mesh 使用 sidecar 被质疑多一跳会造成性能开销影响效率一样，API Gateway 使用 Sidecar 也被同样的质疑：多了一跳&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;解决“多一跳”问题的方法简单而粗暴，基于 sidecar，将 API Gateway 的功能加进来。这样 API Gateway 本体和 Sidecar 再次合二为一：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu_97f77cd9ae61255.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu_4a375969577581fa.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu_1649570657688a89.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar_hu_97f77cd9ae61255.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;至于走到这一步之后，Service Mesh 和 API Gateway 是什么关系：这到底算是 Service Mesh/sidecar融合了API Gateway，还是 API Gateway 融合了 Service Mesh/Sidecar？这个问题就像斑马到底是白底黑纹还是黑底白纹一样，见仁见智。&lt;/p&gt;
&lt;h2 id=&#34;bff把融合进行到底&#34;&gt;BFF：把融合进行到底&lt;/h2&gt;
&lt;p&gt;BFF（Backend For Frontend）的引入会让 Service Mesh 和 API Gateway 走到一个更加亲密的地步。&lt;/p&gt;
&lt;p&gt;先来看看常规的 BFF 的玩法：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/relationship-with-bff_hu_f01938e92ebfc2dd.webp 400w,
               /blog/service-mesh-and-api-gateway/relationship-with-bff_hu_cae957d6d615f75d.webp 760w,
               /blog/service-mesh-and-api-gateway/relationship-with-bff_hu_195f71b2e4cec321.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/relationship-with-bff_hu_f01938e92ebfc2dd.webp&#34;
               width=&#34;760&#34;
               height=&#34;338&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这里，多增加了一个 BFF 层，介于 API Gateway 和内部服务（包括组合服务和原子微服务）之间。注意 BFF 的工作模式和组合服务很类似，都是组合多个服务。但差别在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组合服务还属于服务的范畴，只是实现机制上组合了多个服务，对外暴露的依然是一个完整和规范的服务&lt;/li&gt;
&lt;li&gt;BFF 不同，BFF 如名字所示，Backend For Frontend，完全是为了前端而存在，核心目标之一是简化前端的访问&lt;/li&gt;
&lt;li&gt;对我们今天的话题而言，最关键的一点：BFF 完全收口了从外部进入的流量，而组合服务没有，API Gateway 是可以直接访问原子微服务的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;“BFF 完全收口外部流量”，这一点在 API Gateway 和 Sidecar 融合之后，会变得很有想象空间，我们先看按照前面的融合方式，在有 BFF 的情况下，API Gateway 和 Sidecar 融合后的情景：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu_5f8b275b2d2671ce.webp 400w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu_db52f77e69774802.webp 760w,
               /blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu_7a8069da4e6425cd.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/api-gateway-based-on-sidecar-with-bff_hu_5f8b275b2d2671ce.webp&#34;
               width=&#34;760&#34;
               height=&#34;374&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;放大一点，单独看 API Gateway 和 BFF：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu_ecac22752d60c7fe.webp 400w,
               /blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu_116e25dea4e846cc.webp 760w,
               /blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu_18b55dd06bea39f0.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/two-sidecar-in-bff_hu_ecac22752d60c7fe.webp&#34;
               width=&#34;552&#34;
               height=&#34;416&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;注意到，流量从被 API Gateway 接收，到进入 BFF 在这个流程中，这个请求路径中有两个 sidecar：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;和 BFF 部署在一起的，是没有 API Gateway 功能的普通 Sidecar&lt;/li&gt;
&lt;li&gt;API Gateway 和 Sidecar 融合之后，这就是一个“有 API Gateway 功能的大 Sidecar”（或者是“有 Sidecar 功能的特殊 API Gateway”）：虽然扮演了 API Gateway 的角色，但本质上依然包含一个完整功能的 sidecar，和 BFF 自带的 Sidecar 是等同的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，问题来了：为什么要放两个 sidecar 在流程中，缩减到一个会怎么样？我们尝试将两个 Sidecar 合二为一，去掉 BFF 自带的 Sidecar，直接把扮演 API Gateway 的 sidecar 给 BFF 用：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu_2fcbea46a1433c81.webp 400w,
               /blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu_601fe09adceee487.webp 760w,
               /blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu_bef86133a27d02fd.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/one-sidecar-in-bff_hu_2fcbea46a1433c81.webp&#34;
               width=&#34;645&#34;
               height=&#34;287&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此时的场景是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流量直接打到 BFF 上（BFF 前面可能会挂其他的网络组件提供负载均衡等功能）&lt;/li&gt;
&lt;li&gt;BFF 的 sidecar 接收流量，完成 API Gateway 的功能，然后将流量转给 BFF&lt;/li&gt;
&lt;li&gt;BFF 通过 sidecar 调用内部服务（和没有合并时一致）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/bff-api-gateway_hu_5edccde3b5b05ab9.webp 400w,
               /blog/service-mesh-and-api-gateway/bff-api-gateway_hu_f56d18806ec7dd80.webp 760w,
               /blog/service-mesh-and-api-gateway/bff-api-gateway_hu_840591f1631921c.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/bff-api-gateway_hu_5edccde3b5b05ab9.webp&#34;
               width=&#34;760&#34;
               height=&#34;388&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;注意这里有一个关键点，在前面时特意注明的：“&lt;strong&gt;BFF 完全收口外部流量&lt;/strong&gt;”。这是前提条件，因为原有的 API Gateway 集群已经不再存在，如果 BFF 没能收口全部流量，则这些未能收口的流量会找不到 API Gateway。当然，如果愿意稍微麻烦一点，在部署时清晰的划定需要暴露给外界的服务，直接在这些服务上部署带 API Gateway 功能的 Sidecar，也是可行的，只是管理上会比 BFF 模式要复杂一些。&lt;/p&gt;
&lt;p&gt;另外，在部署上，按照上面的方案，我们会发现：API Gateway“消失”了 —— 不再有一个明确物理部署的 API Gateway 的集群，常规的中心化的网关在这个方案中被融合到每一个 BFF 的实例中，从而实现另外一个重要特性：去中心化。&lt;/p&gt;
&lt;p&gt;上述 Service Mesh 和 API Gateway 融合的方案，并未停留在纸面上。&lt;/p&gt;
&lt;p&gt;在蚂蚁金服内部，我们基于 Service Mesh 和 API Gateway 融合 + 去中心化的思路，进行过开创性的实践和探索。以支付宝移动网关为例，在过去十年间，网关经历了从单体到微服务，从中心化到去中心化，从共享的 gateway.jar 包到利用MOSN实现网关Mesh化/Sidecar化，最终演变成了这样一个方案：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hu_56cb565bc30086fd.webp 400w,
               /blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hu_130766fee16b715a.webp 760w,
               /blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hu_71d332f43b41748c.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/service-mesh-and-api-gateway/antfin-mesh-gateway_hu_56cb565bc30086fd.webp&#34;
               width=&#34;760&#34;
               height=&#34;379&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强烈推荐阅读：附录中我的同事贾岛的文章“蚂蚁金服 API Gateway Mesh 思考与实践”对此有深入介绍和详细描述。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文总结了 Service Mesh 和 API Gateway 的关系，整体上说两者的定位和职责“泾渭分明”，但在具体实现上，开始出现融合的趋势：早期传统方式是类库级别的代码复用，最新趋势是 API Gateway 和 Sidecar 合二为一。&lt;/p&gt;
&lt;p&gt;后者的发展才刚刚起步，包括在蚂蚁金服我们也是才开始探索这个方向，但是相信在未来一两年间，社区可能会有更多的类似产品形态出现。&lt;/p&gt;
&lt;p&gt;补充介绍一下文中多次提到的“MOSN”：&lt;/p&gt;
&lt;p&gt;MOSN 是 MOSN 是 Modular Open Smart Network 的简称，是一款使用 Go 语言开发的网络代理软件，由蚂蚁金服开源并经过几十万容器的生产级验证。MOSN 作为云原生的网络数据平面，旨在为服务提供多协议、模块化、智能化、安全的代理能力。MOSN 可以与任何支持 xDS API 的 Service Mesh 集成，亦可以作为独立的四、七层负载均衡，API Gateway、云原生 Ingress 等使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub：https://github.com/mosn/mosn&lt;/li&gt;
&lt;li&gt;官网：https://mosn.io&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;附录参考资料和推荐阅读&#34;&gt;附录：参考资料和推荐阅读&lt;/h2&gt;
&lt;p&gt;意犹未尽的同学，欢迎继续阅读以下内容。&lt;/p&gt;
&lt;p&gt;按文章发表的时间排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://konghq.com/blog/the-difference-between-api-gateways-and-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Difference Between API Gateways and Service Mesh&lt;/a&gt;：2020-02，指导架构师确定何时使用 API 网关以及何时使用服务网格，作者 Marco Palladino，来自 kong。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/microservices/do-i-need-an-api-gateway-if-i-have-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Do I Need an API Gateway if I Use a Service Mesh?&lt;/a&gt;：2020-01，作者 Christian Posta，中文翻译版本请见马若飞同学的 &lt;a href=&#34;https://www.servicemesher.com/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用了 Service Mesh 后我还需要 API 网关吗&lt;/a&gt;，对 Service Mesh 技术和 API 网关的对比，着重分析了两者的功能重合点和分歧点，为技术选型和落地提供了指导思路。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/azCFGyTDGakZqaLEEDMN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;蚂蚁金服 API Gateway Mesh 思考与实践&lt;/a&gt;: 2019-12，作者贾岛，介绍蚂蚁金服支付宝网关的发展和 API Gateway Mesh 的由来，强烈推荐阅读，这个文章非常清晰的介绍了蚂蚁金服在 Service Mesh 和 API Gateway 融合方面的实践。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.servicemesher.com/blog/api-gateways-are-going-through-an-identity-crisis/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Gateway 的身份认同危机&lt;/a&gt;: 2019-05, 原文作者 Christian Posta，译者周雨青，讲述 API Gateway 的基本理念如 API 的定义，API Management 的含义，API Gateway 模式，以及服务网格和 API Gateway 的关系。&lt;/li&gt;
&lt;li&gt;长路漫漫踏歌而行：蚂蚁金服 Service Mesh 实践探索：2018-10，我在 QCon 的演讲，我分享了当时蚂蚁金服在服务间通讯范围的探索，提出将服务网格在东西向通讯中的能力重用到南北向通讯中，当时基于 Sidecar 的 SOFA Gateway 产品刚开始开发。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.getambassador.io/api-gateway-vs-service-mesh-104c01fa4784&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Gateway vs Service Mesh&lt;/a&gt;: 2018-09，作者 Richard Li，Datawire 的 CEO，在开发 Ambassador API Gateway。Ambassador 是基于 Envoy 的 API Gateway 开源产品，文章阐述了对服务网格和 API Gateway 的看法，差异，以及对两者集成的看法。&lt;/li&gt;
&lt;li&gt;DreamMesh 抛砖引玉 (9)-API Gateway：2018-03，这个文章也是我写的，2018 年初我和 Service Mesh 社区的一些朋友深入探讨之后，在 DreamMesh 系列博客文章中记录下了当时构想的方案，尤其对 API gateway 和 sidecar 是分是合有详细讨论。当时想法还不够成熟，但大体方向已经有雏形了。鸣谢当时参与讨论的同学！&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/microservices-in-practice/service-mesh-vs-api-gateway-a6d814b9bf56&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh vs API Gateway&lt;/a&gt;: 2017-10，原文作者 &lt;a href=&#34;https://medium.com/@kasunindrasiri&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kasun Indrasiri&lt;/a&gt;，以及 &lt;a href=&#34;https://zhaohuabing.com/2018/04/11/service-mesh-vs-api-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;赵化冰同学翻译的中文版本&lt;/a&gt;，文章不长，主要对比了服务网格和 API Gateway 的产品功能，提出了两者融合的方式——在 API Gateway 中通过服务网格来调用下游服务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Network Functions With ESBs, API Management, and Now.. Service Mesh?&lt;/a&gt;：2017-08，作者 Christian Posta，讲述服务网格与 ESB，消息代理和 API 管理之类的事物的关系。内容非常好，强烈推荐阅读（我不得不吐糟一下：配图太辣眼睛）。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>构建云原生微服务网关 - 篇一：Ambassador</title>
      <link>https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/</link>
      <pubDate>Thu, 01 Aug 2019 20:15:43 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在微服务架构中，API 网关是一个十分重要的存在。一方面它为外部的流量访问提供了统一的入口，使得可以方便的进行防火墙的策略实施；另一方面，可以在网关处进行流量控制、认证、授权、灰度发布、日志收集、性能分析等各种高级功能，使得业务功能与非业务功能有效解耦，给予了系统架构更大的灵活性。本系列文章尝试分析目前主流的云原生微服务网关，并比较它们各自的优劣。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;网关选型标准&#34;&gt;网关选型标准&lt;/h2&gt;
&lt;p&gt;其实 kubernetes 本身有一个 ingress controller，基于 Nginx 或 HAProxy 等 7 层代理进行流量的转发。不过 ingress 只能进行简单的反向代理，不支持流控、灰度、认证、授权等网关必备的功能。所以一般意义认为，ingress 是一个 7 层 http 代理，而非 api 网关。本系列主要分析 Ambassador、Traefik、Kong 等具备&lt;strong&gt;微服务&lt;/strong&gt;所需能力的网关产品。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ambassador&#34;&gt;什么是 Ambassador？&lt;/h2&gt;
&lt;p&gt;这里引用官网的一段描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ambassador 是一个基于 Envoy proxy 构建的，kubernetes 原生的开源微服务网关。Ambassador 在构建之初就致力于支持多个独立的团队，这些团队需要为最终用户快速发布、监控和更新服务。Ambassador 还具有 Kubernetes ingress 和负载均衡的能力。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;注意这里的几个关键词：&lt;strong&gt;Envoy&lt;/strong&gt;，&lt;strong&gt;kubernetes 原生&lt;/strong&gt;，&lt;strong&gt;微服务&lt;/strong&gt;。现在市面上网关产品不少，不过 Kubernetes 原生的产品倒真的不多。传统的网关产品一般是基于 rest api 或者 yaml 文件来进行配置（谁让这些老大哥出来的早呢，他们火的时候 k8 还没出来呢），而 Ambassador 完全基于 k8s 标准的 annotation 或者 CRD 来进行各类配置，没错，非常的&lt;strong&gt;native&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;ambassador-架构&#34;&gt;Ambassador 架构&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-0dcae8cb18297b27_hu_6315b6387f777ee4.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-0dcae8cb18297b27_hu_f8c0a08aa7cc695c.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-0dcae8cb18297b27_hu_4b6c9739f25ac29d.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-0dcae8cb18297b27_hu_6315b6387f777ee4.webp&#34;
               width=&#34;760&#34;
               height=&#34;430&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;了解 istio 的同学，看到这张图会有十分熟悉的感觉，没错，Ambassador 也是具有控制平面和数据平面的。数据平面自然是老伙计 Envoy，Ambassador 的控制平面负责监听 k8s 中的 Service 资源的变化，并将配置下发 Envoy，实际的流量转发通过 Envoy 来完成。（感觉就是一个轻量级的 istio）&lt;/p&gt;
&lt;p&gt;具体流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务所有者在 kubernetes manifests 中定义配置 (通过 annotation 或者 CRD)。&lt;/li&gt;
&lt;li&gt;当 manifest 应用到集群时，kubernetes api 会将更改通知 Ambassador。&lt;/li&gt;
&lt;li&gt;Ambassador 解析更改并将配置转换为一种中间语义。Envoy 的配置由该 IR 生成。&lt;/li&gt;
&lt;li&gt;新的配置通过基于 gRPC 的聚合发现服务（ADS）api 传递给 Envoy。&lt;/li&gt;
&lt;li&gt;流量通过重新配置的 Envoy，而不会断开任何连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;扩展性和可用性&#34;&gt;扩展性和可用性&lt;/h2&gt;
&lt;p&gt;Ambassador 依靠 Kubernetes 实现扩展性、高可用性和持久性。所有 Ambassador 配置都直接存储在 Kubernetes 中（etcd），没有数据库。Ambassador 被打包成一个单独的容器，其中包含控制平面和一个 Ambassador 代理实例。默认情况下，Ambassador 部署为 kubernetes deployment，可以像其他 kubernetes deployment 一样进行扩展和管理。&lt;/p&gt;
&lt;h2 id=&#34;与其他网关产品比较&#34;&gt;与其他网关产品比较&lt;/h2&gt;
&lt;p&gt;目前主流的网关产品可以分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;托管的 API 网关，比如 &lt;a href=&#34;https://aws.amazon.com/api-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon api gateway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;传统的 API 网关，比如 &lt;a href=&#34;https://getkong.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;7 层代理，比如 &lt;a href=&#34;https://traefik.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik&lt;/a&gt;, &lt;a href=&#34;http://nginx.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NGINX&lt;/a&gt;, &lt;a href=&#34;http://www.haproxy.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HAProxy&lt;/a&gt;, or &lt;a href=&#34;https://www.Envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;, 或者是基于这些代理的 Ingress controllers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有这些托管的和传统的 API 网关的问题是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不是自服务的。传统 API 网关上的管理接口不是为开发人员自服务而设计的，为开发人员提供的安全性和可用性有限。&lt;/li&gt;
&lt;li&gt;不是 Kubernetes 原生的。它们通常使用 REST apis 进行配置，这使得采用云原生模式（如 GitOps 和声明式配置）变得很困难。&lt;/li&gt;
&lt;li&gt;为 API 管理而设计，而非微服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说，7 层代理可以用作 API 网关，但需要额外的定制开发来支持微服务用例。事实上，许多 API 网关都将 API 网关所需的附加功能打包在 L7 代理之上。Ambassador 使用 Envoy，而 Kong 使用 Nginx。&lt;/p&gt;
&lt;h2 id=&#34;istio&#34;&gt;Istio&lt;/h2&gt;
&lt;p&gt;Istio 是一个基于 Envoy 的开源服务网格。服务网格用于管理东/西流量，而 API 网关用于管理南/北流量。一般来说，我们发现南/北流量与东/西流量有很大不同（比如说，在南北流量中你无法控制客户端）。&lt;/p&gt;
&lt;h2 id=&#34;安装-ambassador&#34;&gt;安装 Ambassador&lt;/h2&gt;
&lt;p&gt;Ambassador 安装非常的简单，直接使用 helm 安装。如果对于 helm 还不是很了解，可以参考我之前的文章 &lt;a href=&#34;https://www.jianshu.com/p/290f27841b8d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;helm 介绍&lt;/a&gt;。
使用 helm 安装只需要执行如下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install --name my-release stable/ambassador
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt; 这边插播一下，推荐使用微软 azure 的 charts 镜像&lt;code&gt;http://mirror.azure.cn/kubernetes/charts/&lt;/code&gt;，基本和官方的同步，且可以正常访问，阿里云的 charts 不知道为什么更新很不及时。
安装完后可以看到有两个 pods&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl get pods
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                          READY     STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ambassador-3655608000-43x86   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          2m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ambassador-3655608000-w63zf   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          2m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果都是都是 running 状态，这样 Ambassador 就安装完成了
接下来我们部署一下官网的应用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;getambassador.io/config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      ---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      apiVersion: ambassador/v1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      kind: Mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      name: tour-ui_mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      prefix: /
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      service: tour:5000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      ---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      apiVersion: ambassador/v1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      kind: Mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      name: tour-backend_mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      prefix: /backend/
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      service: tour:8080
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      labels:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        ambassador:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          - request_label:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;            - backend&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ui&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;backend&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apps/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;replicas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;strategy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RollingUpdate&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tour-ui&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;quay.io/datawire/tour:ui-0.2.4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;quote&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;quay.io/datawire/tour:backend-0.2.4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;limits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;100Mi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个 pod 里面有两个容器，分别是前端的 ui 以及后端的 backend。注意 annotation 里面的&lt;code&gt;getambassador.io/config&lt;/code&gt;部分，这就是 ambassador 的配置了，分别定义了两个注释，kind 是&lt;code&gt;Mapping&lt;/code&gt;，定义了前后端的匹配路径，服务名称及端口。这个配置的意思是，凡是匹配上&lt;code&gt;/&lt;/code&gt;的，全部走 tour 的 5000 端口，凡是匹配上&lt;code&gt;/backend&lt;/code&gt;的，全部走 tour 的 8080 端口（对应的就是 tour 的 service 配置）。也可以使用 CRD 方式配置，ambassador 已经默认创建了一组 crd&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;root@MiWiFi-R1CM-srv zuul&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# kubectl get crds|grep ambassador&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;authservices.getambassador.io                  2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;consulresolvers.getambassador.io               2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetesendpointresolvers.getambassador.io   2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetesserviceresolvers.getambassador.io    2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mappings.getambassador.io                      2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;modules.getambassador.io                       2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ratelimitservices.getambassador.io             2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcpmappings.getambassador.io                   2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tlscontexts.getambassador.io                   2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tracingservices.getambassador.io               2019-07-27T11:40:58Z
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 mapping 就是核心资源，用于路由的转发配置，下面是一个 mapping 资源配置示例&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;items&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;getambassador.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Mapping&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kubectl.kubernetes.io/last-applied-configuration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        {&amp;#34;apiVersion&amp;#34;:&amp;#34;getambassador.io/v1&amp;#34;,&amp;#34;kind&amp;#34;:&amp;#34;Mapping&amp;#34;,&amp;#34;metadata&amp;#34;:{&amp;#34;annotations&amp;#34;:{},&amp;#34;name&amp;#34;:&amp;#34;nginx&amp;#34;,&amp;#34;namespace&amp;#34;:&amp;#34;default&amp;#34;},&amp;#34;spec&amp;#34;:{&amp;#34;prefix&amp;#34;:&amp;#34;/nginx&amp;#34;,&amp;#34;service&amp;#34;:&amp;#34;nginx:80&amp;#34;}}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;2019-07-27T13:36:38Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;generation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resourceVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;420594&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selfLink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/apis/getambassador.io/v1/namespaces/default/mappings/nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;8f1f4d33-b073-11e9-be4c-0800279f163b&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;service&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx:80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resourceVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selfLink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一旦你修改了 service 里面的 annotation 设置，ambassador 的控制面会自动将变更下发给 Envoy，全程不需要中断服务。（也要感谢 Envoy 强大的 xDS api）&lt;/p&gt;
&lt;p&gt;下面我们来看一下 Ambassador 的几个使用场景：&lt;/p&gt;
&lt;h2 id=&#34;用例&#34;&gt;用例&lt;/h2&gt;
&lt;h3 id=&#34;用例-1边缘南北路由&#34;&gt;用例 1：边缘（南/北）路由&lt;/h3&gt;
&lt;p&gt;这个是平时最常见的使用场景，网关位于整个集群的入口处，统一去做一些流控、鉴权等方面的工作：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-45238040cc6650c4_hu_29d970617d2bd8ed.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-45238040cc6650c4_hu_aface01ccee44495.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-45238040cc6650c4_hu_ff4e20d7f340ab0a.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-45238040cc6650c4_hu_29d970617d2bd8ed.webp&#34;
               width=&#34;760&#34;
               height=&#34;454&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;该场景的关注点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制/路由入口流量的能力&lt;/li&gt;
&lt;li&gt;卸载请求
&lt;ul&gt;
&lt;li&gt;认证（比如要求所有入口流量都必须要进过认证）&lt;/li&gt;
&lt;li&gt;加密（TLS 终端及传输加密）&lt;/li&gt;
&lt;li&gt;重试及超时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;saas service 中的真实用例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-7db0c08aafed66b9_hu_9da9d76268610a66.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-7db0c08aafed66b9_hu_591fdfcc572a1ec8.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-7db0c08aafed66b9_hu_793fe3b5dd5ad4c7.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-7db0c08aafed66b9_hu_9da9d76268610a66.webp&#34;
               width=&#34;760&#34;
               height=&#34;367&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;用例-2内部南北路由&#34;&gt;用例 2：内部（南/北）路由&lt;/h3&gt;
&lt;p&gt;通常来说，企业内部的系统架构会比较复杂，会有多集群或者多租户，比如一个 kubernetes 的集群和一个 vm 的集群（可能是 openstack），那么在集群之间的流量就是内部的南/北流量，集群之间的流量交互可以通过 ambassador 完成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-90750413b7c7e9f5_hu_8978c8f878c912f8.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-90750413b7c7e9f5_hu_ac1d50b28aae961c.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-90750413b7c7e9f5_hu_f91de20284fce7c4.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-90750413b7c7e9f5_hu_8978c8f878c912f8.webp&#34;
               width=&#34;760&#34;
               height=&#34;447&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此场景的关注点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制/路由多租户流量的能力&lt;/li&gt;
&lt;li&gt;卸载请求
&lt;ul&gt;
&lt;li&gt;匹配（基于 headers）&lt;/li&gt;
&lt;li&gt;重试及超时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;saas service 中的真实用例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-23acd24daab3455b_hu_885fa3905512409f.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-23acd24daab3455b_hu_952ae70064a9bcd4.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-23acd24daab3455b_hu_d70f3d4ecb8f2198.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-23acd24daab3455b_hu_885fa3905512409f.webp&#34;
               width=&#34;760&#34;
               height=&#34;371&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;用例-3内部东西路由&#34;&gt;用例 3：内部（东/西）路由&lt;/h3&gt;
&lt;p&gt;这个场景中 Ambassador 已经作为集群内部东西向流量的代理了，配合它自己的控制平面，有点 service mesh 的意思了。区别在于，Ambassador 在这个集群里是处于一个中心节点的位置（一个或一组 ambassador 实例），属于 server proxy 的范畴，而不是 service mesh 里面的 client proxy（sidecar）。这种架构其实和传统的 esb 更加的接近。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-8cec66e2dc3b82c1_hu_5ffd7cb526f4a211.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-8cec66e2dc3b82c1_hu_a90fbffcb4f5a656.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-8cec66e2dc3b82c1_hu_def0107aa6599bf.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-8cec66e2dc3b82c1_hu_5ffd7cb526f4a211.webp&#34;
               width=&#34;760&#34;
               height=&#34;459&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此场景关注点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制/路由任意流量的能力（南北向+东西向）&lt;/li&gt;
&lt;li&gt;卸载请求
&lt;ul&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;访问控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家可以看到，已经非常接近于 service mesh 的能力了（也许 ambassador 以后也会出一个 service mesh 产品？）&lt;/p&gt;
&lt;p&gt;saas service 的真实用例：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-605fcdf1a7987640_hu_4ce1d8a1bc3feb6a.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-605fcdf1a7987640_hu_cd363a115a0591d1.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-605fcdf1a7987640_hu_5237a157f788b5f1.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-605fcdf1a7987640_hu_4ce1d8a1bc3feb6a.webp&#34;
               width=&#34;760&#34;
               height=&#34;345&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;服务网格的真实用例（与 istio 集成）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-dbefbeb1c9fcf405_hu_f8019b4e9851ee18.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-dbefbeb1c9fcf405_hu_cab1b5a1e5e7af87.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-dbefbeb1c9fcf405_hu_2255ea2ad660813e.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-dbefbeb1c9fcf405_hu_f8019b4e9851ee18.webp&#34;
               width=&#34;760&#34;
               height=&#34;345&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;用例-4流量镜像&#34;&gt;用例 4：流量镜像&lt;/h3&gt;
&lt;p&gt;此场景中可以把流量复制一份到其他服务中（影子流量），通常用于监控、测试等场景&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-85a3899f164466c2_hu_c3a78a45c80af7c.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-85a3899f164466c2_hu_9d339d459a8d9342.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-85a3899f164466c2_hu_99cdcf88acac58bf.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-85a3899f164466c2_hu_c3a78a45c80af7c.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试代码、发布包的能力&lt;/li&gt;
&lt;li&gt;利用真实的流量/负载&lt;/li&gt;
&lt;li&gt;最小化重复资源&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：上面所描述的几个典型场景其实不光可以使用 Ambassador，而是适用于各类使用 api gateway 或者 proxy 的场景。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;p&gt;Ambassador 不同版本之间配置方式的变更如下图所示，configmap 方式是早期使用方式，目前已经被废弃了，现在更推荐使用 CRD 方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-d2aac8fb2c0cbeda_hu_c712db1582611276.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-d2aac8fb2c0cbeda_hu_630515610b0b0940.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-d2aac8fb2c0cbeda_hu_f695354c1d99ac1a.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-d2aac8fb2c0cbeda_hu_c712db1582611276.webp&#34;
               width=&#34;760&#34;
               height=&#34;201&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;加密的配置方式&#34;&gt;加密的配置方式&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-f9231001054176b2_hu_891068d478b67364.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-f9231001054176b2_hu_20f350850da8d542.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-f9231001054176b2_hu_f83d3a9b3b087b85.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-f9231001054176b2_hu_891068d478b67364.webp&#34;
               width=&#34;760&#34;
               height=&#34;352&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;认证的配置方式&#34;&gt;认证的配置方式&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-38b74b7b5ed93f2e_hu_ff231774a2b4722f.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-38b74b7b5ed93f2e_hu_d803fd63b6097452.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-38b74b7b5ed93f2e_hu_b80cf1a133c200c2.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-38b74b7b5ed93f2e_hu_ff231774a2b4722f.webp&#34;
               width=&#34;760&#34;
               height=&#34;360&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;路由的配置方式&#34;&gt;路由的配置方式&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-64fc6ccdef6a0386_hu_3fc9a8dbff4f13ea.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-64fc6ccdef6a0386_hu_f79fd24c4b349a14.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-64fc6ccdef6a0386_hu_69adfd720985f1f4.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-64fc6ccdef6a0386_hu_3fc9a8dbff4f13ea.webp&#34;
               width=&#34;760&#34;
               height=&#34;338&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;跟踪的配置方式&#34;&gt;跟踪的配置方式&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-api-gateway-part-1/14871146-2ed98f1ea3c98531_hu_1b2d95b879ab81ea.webp 400w,
               /blog/cloud-native-api-gateway-part-1/14871146-2ed98f1ea3c98531_hu_ae1b7231c69b2aac.webp 760w,
               /blog/cloud-native-api-gateway-part-1/14871146-2ed98f1ea3c98531_hu_855c9ceae02a35f7.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/cloud-native-api-gateway-part-1/14871146-2ed98f1ea3c98531_hu_1b2d95b879ab81ea.webp&#34;
               width=&#34;760&#34;
               height=&#34;322&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;ambassador-的不足&#34;&gt;Ambassador 的不足&lt;/h2&gt;
&lt;p&gt;Ambassador 和同类的网关产品类似，分为社区版及商业版，社区版提供了最基础的路由、限速、TLS 加密、跟踪、认证（需要自己实现 external third party authentication service）等能力，但是微服务网关中十分重要的 OAuth2 集成认证、RBAC、custom filter 等功能都是需要在 pro 版中才能实现，这是比较遗憾的一点。尤其是 custom filter，根据我们目前的经验，一个能力完整、功能丰富的微服务网关，必然会引入 custom filter。而 custom filter 也需要使用 Golang 进行编写，对于不熟悉 Golang 的开发人员来说也会比较痛苦。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Ambassador 作为一个较新推出的开源微服务网关产品，与 kubernetes 结合的相当好，基于 annotation 或 CRD 的配置方式与 k8s 浑然一体，甚至让人感觉这就是 k8s 自身功能的一部分，真正做到了&lt;code&gt;kubernetes native&lt;/code&gt;。而底层基于 Envoy 进行流量代理，也让人不需要太担心性能问题。对于路由、加密、基础认证、链路跟踪等场景，可尝试使用。而对于像&lt;code&gt;custom filter&lt;/code&gt;、&lt;code&gt;rbac&lt;/code&gt;、&lt;code&gt;advanced rate limiting&lt;/code&gt;等场景有需求的用户，使用 pro 版本可满足要求。本人也与 Ambassador 开发团队进行了联系，遗憾的是 Ambassador 目前在国内尚未有 reseller，若使用 pro 版，后期技术支持的便利性也是需要考虑的问题。&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.getambassador.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.getambassador.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Using Ambassador to build Cloud-Native Applications - Steve Flanders, Omnition @ KubeCon 2019, Shanghai&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何为服务网格选择入口网关？</title>
      <link>https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/</link>
      <pubDate>Wed, 15 May 2019 12:23:01 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/</guid>
      <description>&lt;p&gt;在启用了 Istio 服务网格的 Kubernetes 集群中，缺省情况下只能在集群内部访问网格中的服务，要如何才能从外部网络访问这些服务呢？Kubernetes 和 Istio 提供了 NodePort，LoadBalancer，Kubernetes Ingress，Istio Gateway 等多种外部流量入口的方式，面对这么多种方式，我们在产品部署中应该如何选择？&lt;/p&gt;
&lt;p&gt;本文将对 Kubernetes 和 Istio 对外提供服务的各种方式进行详细介绍和对比分析，并根据分析结果提出一个可用于产品部署的解决方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;说明：阅读本文要求读者了解 Kubernetes 和 Istio 的基本概念，包括 Pod、Service、NodePort、LoadBalancer、Ingress、Gateway、VirtualService 等。如对这些概念不熟悉，可以在阅读过程中参考文后的相关链接。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;内部服务间的通信&#34;&gt;内部服务间的通信&lt;/h2&gt;
&lt;p&gt;首先，我们来回顾一下 Kubernetes 集群内部各个服务之间相互访问的方法。&lt;/p&gt;
&lt;h2 id=&#34;cluster-ip&#34;&gt;Cluster IP&lt;/h2&gt;
&lt;p&gt;Kubernetes 以 Pod 作为应用部署的最小单位。Kubernetes 会根据 Pod 的声明对其进行调度，包括创建、销毁、迁移、水平伸缩等，因此 Pod 的 IP 地址不是固定的，不方便直接采用 Pod IP 对服务进行访问。&lt;/p&gt;
&lt;p&gt;为解决该问题，Kubernetes 提供了 Service 资源，Service 对提供同一个服务的多个 Pod 进行聚合。一个 Service 提供一个虚拟的 Cluster IP，后端对应一个或者多个提供服务的 Pod。在集群中访问该 Service 时，采用 Cluster IP 即可，Kube-proxy 负责将发送到 Cluster IP 的请求转发到后端的 Pod 上。&lt;/p&gt;
&lt;p&gt;Kube-proxy 是一个运行在每个节点上的 go 应用程序，支持三种工作模式：&lt;/p&gt;
&lt;h3 id=&#34;userspace-模式&#34;&gt;userspace 模式&lt;/h3&gt;
&lt;p&gt;该模式下 Kube-proxy 会为每一个 Service 创建一个监听端口。发向 Cluster IP 的请求被 Iptables 规则重定向到 Kube-proxy 监听的端口上，Kube-proxy 根据 LB 算法选择一个提供服务的 Pod 并和其建立链接，以将请求转发到 Pod 上。&lt;br&gt;
该模式下，Kube-proxy 充当了一个四层 Load balancer 的角色。由于 Kube-proxy 运行在 userspace 中，在进行转发处理时会增加两次内核和用户空间之间的数据拷贝，效率较另外两种模式低一些；好处是当后端的 Pod 不可用时，Kube-proxy 可以重试其他 Pod。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-userspace-模式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kube-proxy userspace 模式&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu_e7d3f96149cd67c7.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu_fc981ce6d4976430.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu_f7ebea3320e3b5da.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4lmw4z7j20m80cj0tq_hu_e7d3f96149cd67c7.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kube-proxy userspace 模式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图片来自：&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;iptables-模式&#34;&gt;iptables 模式&lt;/h3&gt;
&lt;p&gt;为了避免增加内核和用户空间的数据拷贝操作，提高转发效率，Kube-proxy 提供了 iptables 模式。在该模式下，Kube-proxy 为 service 后端的每个 Pod 创建对应的 iptables 规则，直接将发向 Cluster IP 的请求重定向到一个 Pod IP。&lt;br&gt;
该模式下 Kube-proxy 不承担四层代理的角色，只负责创建 iptables 规则。该模式的优点是较 userspace 模式效率更高，但不能提供灵活的 LB 策略，当后端 Pod 不可用时也无法进行重试。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-iptables-模式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kube-proxy iptables 模式&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hu_3ce2fbd3b9c6a201.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hu_6f1ecd45a54f35b5.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hu_68be05dac420c4d6.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4n2vx1tj20ol0h0dh3_hu_3ce2fbd3b9c6a201.webp&#34;
               width=&#34;760&#34;
               height=&#34;526&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kube-proxy iptables 模式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图片来自：&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;ipvs-模式&#34;&gt;ipvs 模式&lt;/h3&gt;
&lt;p&gt;该模式和 iptables 类似，Kube-proxy 监控 Pod 的变化并创建相应的 ipvs rules。ipvs 也是在 kernel 模式下通过 netfilter 实现的，但采用了 hash table 来存储规则，因此在规则较多的情况下，Ipvs 相对 iptables 转发效率更高。除此以外，ipvs 支持更多的 LB 算法。如果要设置 Kube-proxy 为 ipvs 模式，必须在操作系统中安装 IPVS 内核模块。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kube-proxy-ipvs-模式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kube-proxy ipvs 模式&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hu_a66e92794a3feb33.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hu_3b2e153c22f90c6d.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hu_7b083cce663db92f.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46gy1g1l4nvyl1vj20nj0g83zi_hu_a66e92794a3feb33.webp&#34;
               width=&#34;760&#34;
               height=&#34;524&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kube-proxy ipvs 模式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图片来自：&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;istio-sidecar-proxy&#34;&gt;Istio Sidecar Proxy&lt;/h2&gt;
&lt;p&gt;Cluster IP 解决了服务之间相互访问的问题，但从上面 Kube-proxy 的三种模式可以看到，Cluster IP 的方式只提供了服务发现和基本的 LB 功能。如果要为服务间的通信应用灵活的路由规则以及提供 Metrics collection，distributed tracing 等服务管控功能，就必须得依靠 Istio 提供的服务网格能力了。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中部署 Istio 后，Istio 通过 iptables 和 Sidecar Proxy 接管服务之间的通信，服务间的相互通信不再通过 Kube-proxy，而是通过 Istio 的 Sidecar Proxy 进行。请求流程是这样的：Client 发起的请求被 iptables 重定向到 Sidecar Proxy，Sidecar Proxy 根据从控制面获取的服务发现信息和路由规则，选择一个后端的 Server Pod 创建连接，代理并转发 Client 的请求。&lt;/p&gt;
&lt;p&gt;Istio Sidecar Proxy 和 Kube-proxy 的 userspace 模式的工作机制类似，都是通过在用户空间的一个代理来实现客户端请求的转发和后端多个 Pod 之间的负载均衡。两者的不同点是：Kube-Proxy 工作在四层，而 Sidecar Proxy 则是一个七层代理，可以针对 HTTP，gRPC 等应用层的语义进行处理和转发，因此功能更为强大，可以配合控制面实现更为灵活的路由规则和服务管控功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-sidecar-proxy&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio Sidecar Proxy&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hu_41e5d6df52a989e5.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hu_d89529cca0ec4d0d.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hu_12fe016ebde6fae3.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur74j27j20ho0bujsm_hu_41e5d6df52a989e5.webp&#34;
               width=&#34;636&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio Sidecar Proxy
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h1 id=&#34;如何从外部网络访问&#34;&gt;如何从外部网络访问&lt;/h1&gt;
&lt;p&gt;Kubernetes 的 Pod IP 和 Cluster IP 都只能在集群内部访问，而我们通常需要从外部网络上访问集群中的某些服务，Kubernetes 提供了下述几种方式来为集群提供外部流量入口。&lt;/p&gt;
&lt;h2 id=&#34;nodeport&#34;&gt;NodePort&lt;/h2&gt;
&lt;p&gt;NodePort 在集群中的主机节点上为 Service 提供一个代理端口，以允许从主机网络上对 Service 进行访问。Kubernetes 官网文档只介绍了 NodePort 的功能，并未对其实现原理进行解释。下面我们通过实验来分析 NodePort 的实现机制。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.katacoda.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;www.katacoda.com&lt;/a&gt; 这个网站提供了一个交互式的 Kubernetes playground，注册即可免费实验 Kubernetes 的相关功能，下面我们就使用 Katacoda 来分析 Nodeport 的实现原理。&lt;/p&gt;
&lt;p&gt;在浏览器中输入这个网址：https://www.katacoda.com/courses/kubernetes/networking-introduction，打开后会提供了一个实验用的 Kubernetes 集群，并可以通过网元模拟 Terminal 连接到集群的 Master 节点。&lt;/p&gt;
&lt;p&gt;执行下面的命令创建一个 nodeport 类型的 service。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ cat nodeport.yaml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apiVersion: v1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kind: Service
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  name: webapp1-nodeport-svc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  labels:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    app: webapp1-nodeport
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  type: NodePort
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ports:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  - port: &lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    nodePort: &lt;span class=&#34;m&#34;&gt;30080&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  selector:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    app: webapp1-nodeport
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apiVersion: extensions/v1beta1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kind: Deployment
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  name: webapp1-nodeport-deployment
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  replicas: &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  template:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    metadata:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      labels:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        app: webapp1-nodeport
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    spec:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      containers:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      - name: webapp1-nodeport-pod
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        image: katacoda/docker-http-server:latest
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ports:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - containerPort: &lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ kubectl apply -f nodeport.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看创建的 service，可以看到 Kubernetes 创建了一个名为 webapp-nodeport-svc 的 service，并为该 service 在主机节点上创建了 30080 这个 Nodeport。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ kubectl get svc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                   TYPE        CLUSTER-IP      EXTERNAL-IP   PORT&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;S&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;        AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubernetes             ClusterIP   10.96.0.1       &amp;lt;none&amp;gt;        443/TCP        36m
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;webapp1-nodeport-svc   NodePort    10.103.188.73   &amp;lt;none&amp;gt;        80:30080/TCP   3m
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;webapp-nodeport-svc 后端对应两个 Pod，其 Pod 的 IP 分别为 10.32.0.3 和 10.32.0.5。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ kubectl get pod -o wide
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                                           READY     STATUS    RESTARTS   AGE       IPNODE      NOMINATED NODE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;webapp1-nodeport-deployment-785989576b-cjc5b   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          2m        10.32.0.3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;webapp1-nodeport-deployment-785989576b-tpfqr   1/1       Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          2m        10.32.0.5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过 netstat 命令可以看到 Kube-proxy 在主机网络上创建了 30080 监听端口，用于接收从主机网络进入的外部流量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;master $ netstat -lnp&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;grep &lt;span class=&#34;m&#34;&gt;30080&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tcp6       &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;      &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; :::30080                :::*                    LISTEN      7427/Kube-proxy
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面是 Kube-proxy 创建的相关 iptables 规则以及对应的说明。可以看到 Kube-proxy 为 Nodeport 创建了相应的 IPtable 规则，将发向 30080 这个主机端口上的流量重定向到了后端的两个 Pod IP 上。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;iptables-save &amp;gt; iptables-dump
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Generated by iptables-save v1.6.0 on Thu Mar 28 07:33:57 2019&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*nat
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Nodeport规则链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-NODEPORTS - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Service规则链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-SERVICES - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Nodeport和Service共用的规则链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-SVC-J2DWGRZTH4C2LPA4 - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-SEP-4CGFRVESQ3AECDE7 - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;:KUBE-SEP-YLXG4RMKAICGY2B3 - &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0:0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 将host上30080端口的外部tcp流量转到KUBE-SVC-J2DWGRZTH4C2LPA4链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-NODEPORTS -p tcp -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -m tcp --dport &lt;span class=&#34;m&#34;&gt;30080&lt;/span&gt; -j KUBE-SVC-J2DWGRZTH4C2LPA4
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将发送到Cluster IP 10.103.188.73的内部流量转到KUBE-SVC-J2DWGRZTH4C2LPA4链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;KUBE-SERVICES -d 10.103.188.73/32 -p tcp -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc: cluster IP&amp;#34;&lt;/span&gt; -m tcp --dport &lt;span class=&#34;m&#34;&gt;80&lt;/span&gt; -j KUBE-SVC-J2DWGRZTH4C2LPA4
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将发送到webapp1-nodeport-svc的流量转交到第一个Pod（10.32.0.3）相关的规则链上，比例为50%&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-SVC-J2DWGRZTH4C2LPA4 -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-YLXG4RMKAICGY2B3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将发送到webapp1-nodeport-svc的流量转交到第二个Pod（10.32.0.5）相关的规则链上&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-SVC-J2DWGRZTH4C2LPA4 -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -j KUBE-SEP-4CGFRVESQ3AECDE7
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将请求重定向到Pod 10.32.0.3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-SEP-YLXG4RMKAICGY2B3 -p tcp -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -m tcp -j DNAT --to-destination 10.32.0.3:80
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#将请求重定向到Pod 10.32.0.5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-A KUBE-SEP-4CGFRVESQ3AECDE7 -p tcp -m comment --comment &lt;span class=&#34;s2&#34;&gt;&amp;#34;default/webapp1-nodeport-svc:&amp;#34;&lt;/span&gt; -m tcp -j DNAT --to-destination 10.32.0.5:80
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从上面的实验可以看到，通过将一个 Service 定义为 NodePort 类型，Kubernetes 会通过集群中 node 上的 Kube-proxy 为该 Service 在主机网络上创建一个监听端口。Kube-proxy 并不会直接接收该主机端口进入的流量，而是会创建相应的 Iptables 规则，并通过 Iptables 将从该端口收到的流量直接转发到后端的 Pod 中。&lt;/p&gt;
&lt;p&gt;NodePort 的流量转发机制和 Cluster IP 的 iptables 模式类似，唯一不同之处是在主机网络上开了一个“NodePort”来接受外部流量。从上面的规则也可以看出，在创建 Nodeport 时，Kube-proxy 也会同时为 Service 创建 Cluster IP 相关的 iptables 规则。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：除采用 iptables 进行流量转发，NodePort 应该也可以提供 userspace 模式以及 ipvs 模式，这里未就这两种模式进行实验验证。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;从分析得知，在 NodePort 模式下，集群内外部的通讯如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-nodeport&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;NodePort&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu_e995d58bd62db63d.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu_344cf1f22b74cc24.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu_b3eb248b32851808.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7ink1j20dx0bcabj_hu_e995d58bd62db63d.webp&#34;
               width=&#34;501&#34;
               height=&#34;408&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      NodePort
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;loadbalancer&#34;&gt;LoadBalancer&lt;/h2&gt;
&lt;p&gt;NodePort 提供了一种从外部网络访问 Kubernetes 集群内部 Service 的方法，但该方法存在下面一些限制，导致这种方式主要适用于程序开发，不适合用于产品部署。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes cluster host 的 IP 必须是一个 well-known IP，即客户端必须知道该 IP。但 Cluster 中的 host 是被作为资源池看待的，可以增加删除，每个 host 的 IP 一般也是动态分配的，因此并不能认为 host IP 对客户端而言是 well-known IP。&lt;/li&gt;
&lt;li&gt;客户端访问某一个固定的 host IP 的方式存在单点故障。假如一台 host 宕机了，Kubernetes cluster 会把应用 reload 到另一节点上，但客户端就无法通过该 host 的 nodeport 访问应用了。&lt;/li&gt;
&lt;li&gt;通过一个主机节点作为网络入口，在网络流量较大时存在性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决这些问题，Kubernetes 提供了 LoadBalancer。通过将 Service 定义为 LoadBalancer 类型，Kubernetes 在主机节点的 NodePort 前提供了一个四层的负载均衡器。该四层负载均衡器负责将外部网络流量分发到后面的多个节点的 NodePort 端口上。&lt;/p&gt;
&lt;p&gt;下图展示了 Kubernetes 如何通过 LoadBalancer 方式对外提供流量入口，图中 LoadBalancer 后面接入了两个主机节点上的 NodePort，后端部署了三个 Pod 提供服务。根据集群的规模，可以在 LoadBalancer 后面可以接入更多的主机节点，以进行负荷分担。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-nodebalancer&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;NodeBalancer&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_hu_e082d016d31a7788.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_hu_8007f05a30228627.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_hu_8116e275ba0658e8.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7aa0qj20qv0hl3zr_hu_e082d016d31a7788.webp&#34;
               width=&#34;760&#34;
               height=&#34;497&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      NodeBalancer
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：LoadBalancer 类型需要云服务提供商的支持，Service 中的定义只是在 Kubernetes 配置文件中提出了一个要求，即为该 Service 创建 Load Balancer，至于如何创建则是由 Google Cloud 或 Amazon Cloud 等云服务商提供的，创建的 Load Balancer 的过程不在 Kubernetes Cluster 的管理范围中。&lt;/p&gt;
&lt;p&gt;目前 AWS、Azure、CloudStack、GCE 和 OpenStack 等主流的公有云和私有云提供商都可以为 Kubernetes 提供 Load Balancer。一般来说，公有云提供商还会为 Load Balancer 提供一个 External IP，以提供 Internet 接入。如果你的产品没有使用云提供商，而是自建 Kubernetes Cluster，则需要自己提供 LoadBalancer。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;ingress&#34;&gt;Ingress&lt;/h2&gt;
&lt;p&gt;LoadBalancer 类型的 Service 提供的是四层负载均衡器，当只需要向外暴露一个服务的时候，采用这种方式是没有问题的。但当一个应用需要对外提供多个服务时，采用该方式则要求为每一个四层服务（IP+Port）都创建一个外部 Load balancer。&lt;/p&gt;
&lt;p&gt;一般来说，同一个应用的多个服务/资源会放在同一个域名下，在这种情况下，创建多个 Load balancer 是完全没有必要的，反而带来了额外的开销和管理成本。另外直接将服务暴露给外部用户也会导致了前端和后端的耦合，影响了后端架构的灵活性，如果以后由于业务需求对服务进行调整会直接影响到客户端。&lt;/p&gt;
&lt;p&gt;在这种情况下，我们可以通过使用 Kubernetes Ingress 来统一网络入口。Kubernetes Ingress 声明了一个应用层（OSI 七层）的负载均衡器，可以根据 HTTP 请求的内容将来自同一个 TCP 端口的请求分发到不同的 Kubernetes Service，其功能包括：&lt;/p&gt;
&lt;h3 id=&#34;按-http-请求的-url-进行路由&#34;&gt;按 HTTP 请求的 URL 进行路由&lt;/h3&gt;
&lt;p&gt;同一个 TCP 端口进来的流量可以根据 URL 路由到 Cluster 中的不同服务，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-按-http-请求的-ulr-进行路由&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;按 HTTP 请求的 ULR 进行路由&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu_84cb21516ef379b7.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu_3551e6c0cb233daa.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu_aa243c79653d257e.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur85xbfj20fz0bp0t4_hu_84cb21516ef379b7.webp&#34;
               width=&#34;575&#34;
               height=&#34;421&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      按 HTTP 请求的 ULR 进行路由
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;按-http-请求的-host-进行路由&#34;&gt;按 HTTP 请求的 Host 进行路由&lt;/h3&gt;
&lt;p&gt;同一个 IP 进来的流量可以根据 HTTP 请求的 Host 路由到 Cluster 中的不同服务，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-按-http-请求的-host-进行路由&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;按 HTTP 请求的 Host 进行路由&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu_a689ca579c68529c.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu_7b4680d146a3d680.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu_1c109c6aba00580b.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7zut9j20fw0caaaf_hu_a689ca579c68529c.webp&#34;
               width=&#34;572&#34;
               height=&#34;442&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      按 HTTP 请求的 Host 进行路由
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Ingress 规则定义了对七层网关的要求，包括 URL 分发规则，基于不同域名的虚拟主机，SSL 证书等。Kubernetes 使用 Ingress Controller 来监控 Ingress 规则，并通过一个七层网关来实现这些要求，一般可以使用 Nginx，HAProxy，Envoy 等。&lt;/p&gt;
&lt;p&gt;虽然 Ingress Controller 通过七层网关为后端的多个 Service 提供了统一的入口，但由于其部署在集群中，因此并不能直接对外提供服务。实际上 Ingress 需要配合 NodePort 和 LoadBalancer 才能提供对外的流量入口，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用-ingress-nodeportal-和-loadbalancer-提供外部流量入口的拓扑结构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用 Ingress, NodePortal 和 LoadBalancer 提供外部流量入口的拓扑结构&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_hu_1bdfa867c6e2244d.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_hu_d6d3cac1f691fbbf.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_hu_a946c7e8446330f7.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7vshrj20lw0gpaao_hu_1bdfa867c6e2244d.webp&#34;
               width=&#34;760&#34;
               height=&#34;580&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用 Ingress, NodePortal 和 LoadBalancer 提供外部流量入口的拓扑结构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上图描述了如何采用 Ingress 配合 NodePort 和 Load Balancer 为集群提供外部流量入口，从该拓扑图中可以看到该架构的伸缩性非常好，在 NodePort，Ingress，Pod 等不同的接入层面都可以对系统进行水平扩展，以应对不同的外部流量要求。&lt;/p&gt;
&lt;p&gt;上图只展示了逻辑架构，下面的图展示了具体的实现原理：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用-ingress-nodeportal-和-loadbalancer-提供外部流量入口的实现原理&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用 Ingress, NodePortal 和 LoadBalancer 提供外部流量入口的实现原理&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu_e52787ba26614f9d.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu_e2f615f2647c5d8e.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu_b09077498ed8d393.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7w5yoj20es0lpwfn_hu_e52787ba26614f9d.webp&#34;
               width=&#34;518&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用 Ingress, NodePortal 和 LoadBalancer 提供外部流量入口的实现原理
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;流量从外部网络到达 Pod 的完整路径如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;外部请求先通过四层 Load Balancer 进入内部网络&lt;/li&gt;
&lt;li&gt;Load Balancer 将流量分发到后端多个主机节点上的 NodePort (userspace 转发)&lt;/li&gt;
&lt;li&gt;请求从 NodePort 进入到 Ingress Controller (iptabes 规则，Ingress Controller 本身是一个 NodePort 类型的 Service)&lt;/li&gt;
&lt;li&gt;Ingress Controller 根据 Ingress rule 进行七层分发，根据 HTTP 的 URL 和 Host 将请求分发给不同的 Service (userspace 转发)&lt;/li&gt;
&lt;li&gt;Service 将请求最终导入到后端提供服务的 Pod 中 (iptabes 规则)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从前面的介绍可以看到，K8S Ingress 提供了一个基础的七层网关功能的抽象定义，其作用是对外提供一个七层服务的统一入口，并根据 URL/HOST 将请求路由到集群内部不同的服务上。&lt;/p&gt;
&lt;h1 id=&#34;如何为服务网格选择入口网关&#34;&gt;如何为服务网格选择入口网关？&lt;/h1&gt;
&lt;p&gt;在 Istio 服务网格中，通过为每个 Service 部署一个 sidecar 代理，Istio 接管了 Service 之间的请求流量。控制面可以对网格中的所有 sidecar 代理进行统一配置，实现了对网格内部流量的路由控制，从而可以实现灰度发布，流量镜像，故障注入等服务管控功能。但是，Istio 并没有为入口网关提供一个较为完善的解决方案。&lt;/p&gt;
&lt;h2 id=&#34;k8s-ingress&#34;&gt;K8s Ingress&lt;/h2&gt;
&lt;p&gt;在 0.8 版本以前，Istio 缺省采用 K8s Ingress 来作为 Service Mesh 的流量入口。K8s Ingress 统一了应用的流量入口，但存在两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;K8s Ingress 是独立在 Istio 体系之外的，需要单独采用 Ingress rule 进行配置，导致系统入口和内部存在两套互相独立的路由规则配置，运维和管理较为复杂。&lt;/li&gt;
&lt;li&gt;K8s Ingress rule 的功能较弱，不能在入口处实现和网格内部类似的路由规则，也不具备网格 sidecar 的其它能力，导致难以从整体上为应用系统实现灰度发布、分布式跟踪等服务管控功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用-kubernetes-ingress-作为服务网格的流量入口&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用 Kubernetes Ingress 作为服务网格的流量入口&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_hu_541af135f81b5d41.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_hu_5e8882b66bc09ee7.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_hu_46d3495f90d2a285.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7amu9j20oy0bdwf0_hu_541af135f81b5d41.webp&#34;
               width=&#34;760&#34;
               height=&#34;346&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用 Kubernetes Ingress 作为服务网格的流量入口
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;istio-gateway&#34;&gt;Istio Gateway&lt;/h2&gt;
&lt;p&gt;Istio 社区意识到了 Ingress 和 Mesh 内部配置割裂的问题，因此从 0.8 版本开始，社区采用了 Gateway 资源代替 K8s Ingress 来表示流量入口。&lt;/p&gt;
&lt;p&gt;Istio Gateway 资源本身只能配置 L4-L6 的功能，例如暴露的端口，TLS 设置等；但 Gateway 可以和绑定一个 VirtualService，在 VirtualService 中可以配置七层路由规则，这些七层路由规则包括根据按照服务版本对请求进行导流，故障注入，HTTP 重定向，HTTP 重写等所有 Mesh 内部支持的路由规则。&lt;/p&gt;
&lt;p&gt;Gateway 和 VirtualService 用于表示 Istio Ingress 的配置模型，Istio Ingress 的缺省实现则采用了和 Sidecar 相同的 Envoy proxy。&lt;/p&gt;
&lt;p&gt;通过该方式，Istio 控制面用一致的配置模型同时控制了入口网关和内部的 sidecar 代理。这些配置包括路由规则，策略检查、Telementry 收集以及其他服务管控功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用-istio-ingress-gateway-作为服务网格的流量入口&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用 Istio Ingress Gateway 作为服务网格的流量入口&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu_e7274f68d31bb02e.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu_de2284efafa4f398.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu_16743d20b7587eb.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur6wqsjj20kh0cbaax_hu_e7274f68d31bb02e.webp&#34;
               width=&#34;737&#34;
               height=&#34;443&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用 Istio Ingress Gateway 作为服务网格的流量入口
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;应用对-api-gateway-的需求&#34;&gt;应用对 API Gateway 的需求&lt;/h2&gt;
&lt;p&gt;采用 Gateway 和 VirtualService 实现的 Istio Ingress Gateway 提供了网络入口处的基础通信功能，包括可靠的通信和灵活的路由规则。但对于一个服务化应用来说，网络入口除了基础的通讯功能之外，还有一些其他的应用层功能需求，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三方系统对 API 的访问控制&lt;/li&gt;
&lt;li&gt;用户对系统的访问控制&lt;/li&gt;
&lt;li&gt;修改请求/返回数据&lt;/li&gt;
&lt;li&gt;服务 API 的生命周期管理&lt;/li&gt;
&lt;li&gt;服务访问的 SLA、限流及计费&lt;/li&gt;
&lt;li&gt;….&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kubernetes-ingress-istio-gateway-and-api-gateway-的功能对比&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kubernetes ingress, Istio gateway and API gateway 的功能对比&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu_d44e6c318be70a00.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu_cd8881193fcde764.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu_8381bca07be152a8.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kv0ys0ndj20m80azdiw_hu_d44e6c318be70a00.webp&#34;
               width=&#34;760&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kubernetes ingress, Istio gateway and API gateway 的功能对比
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;API Gateway 需求中很大一部分需要根据不同的应用系统进行定制，目前看来暂时不大可能被纳入 K8s Ingress 或者 Istio Gateway 的规范之中。为了满足这些需求，涌现出了各类不同的 k8s Ingress Controller 以及 Istio Ingress Gateway 实现，包括 Ambassador、Kong、Traefik、Solo 等。&lt;/p&gt;
&lt;p&gt;这些网关产品在实现在提供基础的 K8s Ingress 能力的同时，提供了强大的 API Gateway 功能，但由于缺少统一的标准，这些扩展实现之间相互之间并不兼容。而且遗憾的是，目前这些 Ingress controller 都还没有正式提供和 Istio 控制面集成的能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ambassador 将对 Istio 路由规则的支持纳入了 Roadmap &lt;a href=&#34;https://www.getambassador.io/user-guide/with-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.getambassador.io/user-guide/with-istio/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Istio 声称支持 Istio-Based Route Rule Discovery (尚处于实验阶段) &lt;a href=&#34;https://gloo.solo.io/introduction/architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://gloo.solo.io/introduction/architecture/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;采用-api-gateway--sidecar-proxy-作为服务网格的流量入口&#34;&gt;采用 API Gateway + Sidecar Proxy 作为服务网格的流量入口&lt;/h2&gt;
&lt;p&gt;在目前难以找到一个同时具备 API Gateway 和 Istio Ingress 能力的网关的情况下，一个可行的方案是使用 API Gateway 和 Sidecar Proxy 一起为服务网格提供外部流量入口。&lt;/p&gt;
&lt;p&gt;由于 API Gateway 已经具备七层网关的功能，Mesh Ingress 中的 Sidecar 只需要提供 VirtualService 资源的路由能力，并不需要提供 Gateway 资源的网关能力，因此采用 Sidecar Proxy 即可。网络入口处的 Sidecar Proxy 和网格内部应用 Pod 中 Sidecar Proxy 的唯一一点区别是：该 Sidecar 只接管 API Gateway 向 Mesh 内部的流量，并不接管外部流向 API Gateway 的流量；而应用 Pod 中的 Sidecar 需要接管进入应用的所有流量。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用-api-gateway--sidecar-proxy-为服务网格提供流量入口&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用 API Gateway &amp;#43; Sidecar Proxy 为服务网格提供流量入口&#34; srcset=&#34;
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu_d1059d49bf2922fa.webp 400w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu_9e6ae83e00bbc538.webp 760w,
               /blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu_788f121767cee6b7.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/how-to-pick-gateway-for-service-mesh/6ce41a46ly1g1kur7v8ktj20nt0c0ab2_hu_d1059d49bf2922fa.webp&#34;
               width=&#34;760&#34;
               height=&#34;383&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用 API Gateway + Sidecar Proxy 为服务网格提供流量入口
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：在实际部署时，API Gateway 前端需要采用 NodePort 和 LoadBalancer 提供外部流量入口。为了突出主题，对上图进行了简化，没有画出 NodePort 和 LoadBalancer。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;采用 API Gateway 和 Sidecar Proxy 一起作为服务网格的流量入口，既能够通过对网关进行定制开发满足产品对 API 网关的各种需求，又可以在网络入口处利用服务网格提供的灵活的路由能力和分布式跟踪，策略等管控功能，是服务网格产品入口网关的一个理想方案。&lt;/p&gt;
&lt;p&gt;性能方面的考虑：从上图可以看到，采用该方案后，外部请求的处理流程在入口处增加了 Sidecar Proxy 这一跳，因此该方式会带来少量的性能损失，但该损失是完全可以接受的。&lt;/p&gt;
&lt;p&gt;对于请求时延而言，在服务网格中，一个外部请求本来就要经过较多的代理和应用进程的处理，在 Ingress 处增加一个代理对整体的时延影响基本忽略不计，而且对于绝大多数应用来说，网络转发所占的时间比例本来就很小，99% 的耗时都在业务逻辑。如果系统对于增加的该时延非常敏感，则建议重新考虑该系统是否需要采用微服务架构和服务网格。&lt;/p&gt;
&lt;p&gt;对于吞吐量而言，如果入口处的网络吞吐量存在瓶颈，则可以通过对 API Gateway + Sidecar Proxy 组成的 Ingress 整体进行水平扩展，来对入口流量进行负荷分担，以提高网格入口的网络吞吐量。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&#34;ref01&#34;&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Virtual IPs and Service Proxie - kubernetes.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhaohuabing.com/2017/11/28/access-application-from-outside/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如何从外部访问 Kubernetes 集群中的应用？ - zhaohuabing.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhaohuabing.com/post/2018-12-27-the-obstacles-to-put-istio-into-production/#service-mesh-and-api-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The obstacles to put Istio into production and how we solve them - kubernetes.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes NodePort vs LoadBalancer vs Ingress? When should I use what? - medium.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway 的身份认同危机</title>
      <link>https://cloudnativecn.com/blog/api-gateways-are-going-through-an-identity-crisis/</link>
      <pubDate>Mon, 13 May 2019 20:08:37 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/api-gateways-are-going-through-an-identity-crisis/</guid>
      <description>&lt;p&gt;如今，API 网关经历了一系列&lt;a href=&#34;https://en.wikipedia.org/wiki/Identity_crisis&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;身份认同危机&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们是集中式共享资源，有助于将 API 暴露和维护到外部实体吗？&lt;/li&gt;
&lt;li&gt;它们是否为集群的 ingress 哨兵，严格控制用户流量在集群的进出？&lt;/li&gt;
&lt;li&gt;或它们是否为某类 API 的集成，以便更简洁地表达 API，具体取决于它所具有的客户端类型？&lt;/li&gt;
&lt;li&gt;当然还有不愿多谈但我经常听到的一个问题：&amp;ldquo;服务网格是否会使 API 网关过时？&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;有关背景&#34;&gt;有关背景&lt;/h2&gt;
&lt;p&gt;随着技术的快速发展，以及行业在技术和架构模式中的快速发展，你会想到&amp;quot;这一切都让我头晕目眩&amp;quot;。在这篇文章中，我希望简化&amp;quot;API 网关&amp;quot;的不同身份，澄清组织中哪些组可能使用 API 网关（他们试图解决的问题），并重新关注第一原则。理想情况下，在本文结束时，您将更好地了解不同团队在不同层面的 API 架构的作用，以及如何从每个层面中获取最大价值。&lt;/p&gt;
&lt;p&gt;在我们深入研究之前，让我们对 API 这个术语非常清楚。&lt;/p&gt;
&lt;h2 id=&#34;我对-api-的定义&#34;&gt;我对 API 的定义：&lt;/h2&gt;
&lt;p&gt;一种明确且有目的地定义的接口，旨在通过网络调用，使软件开发人员能够以受控且舒适的方式对组织内的数据和功能进行编程访问。&lt;/p&gt;
&lt;p&gt;这些接口抽象了实现它们的技术基础结构的细节。对于这些设计好的端点，我们期望能有些一定程度的文档，例如使用指南，稳定性报告和向后兼容性。&lt;/p&gt;
&lt;p&gt;相反，仅仅因为我们可以通过网络与另一个软件通信并不一定意味着远程端点是这个定义好的 API。许多系统彼此通信，往往这种通信更加随意地发生，并且通过耦合和其他因素进行实时交互。&lt;/p&gt;
&lt;p&gt;我们创建 API 以提供对业务部分的深思熟虑的抽象，并实现新的业务功能以及偶发创新。&lt;/p&gt;
&lt;p&gt;在讨论 API 网关时首先列出的是 API 管理。&lt;/p&gt;
&lt;h2 id=&#34;api-管理&#34;&gt;API 管理&lt;/h2&gt;
&lt;p&gt;很多人都在 API 管理方面考虑 API 网关。这是合理的。但是让我们快速了解一下 API 网关到底是做什么的。&lt;/p&gt;
&lt;p&gt;通过&lt;a href=&#34;https://en.wikipedia.org/wiki/API_management&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Management&lt;/a&gt;，我们希望解决：当我们希望公开现有 API 以供其他人使用时，如何跟踪谁使用这些 API，实施允许谁使用这些 API 的策略，建立安全流以进行身份​​验证和授权允许，使用并构建可在设计时使用的服务目录，以促进 API 使用并为有效治理奠定基础。&lt;/p&gt;
&lt;p&gt;我们希望解决：现有的，规划好的 API，我们希望按照我们的条款分享给他人的问题。&lt;/p&gt;
&lt;p&gt;API 管理还可以很好地允许用户（潜在 API 消费者）自助服务，注册不同的 API 消费计划（想一想：指定价格点在给定时间范围内每个端点的每个用户的呼叫数）。我们能够实施这些管理功能的基础设施是我们的 API 流量通过的网关。在这一点上，我们可以执行诸如身份认证，流量限速，指标采集，以及其他策略执行操作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-management-sketch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;利用 API 网关的 API 管理软件示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://apigee.com/api-management/#/homepage&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Apigee&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.3scale.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat 3Scale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mulesoft.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mulesoft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://konghq.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个层面上，我们考虑 API（如上所述）以及如何最好地管理和允许访问它们。我们没有考虑服务器，主机，端口，容器甚至服务（另一个定义不明确的词，但你理解我的！）。&lt;/p&gt;
&lt;p&gt;API 管理（以及它们相应的网关）通常实现为由&amp;quot;平台团队&amp;quot;，&amp;ldquo;集成团队&amp;quot;或其他 API 基础架构团队拥有的严格控制的共享基础架构。通常这样做是为了强制执行一定程度的治理，变更管理和策略。在某些情况下，即使这些基础架构集中部署和管理，它们也可能支持更分散的物理部署。例如，Kong 的首席技术官 Marco Palladino 在评论中指出，Kong 可以选择部署的组件来支持集中式或分布式模型。&lt;/p&gt;
&lt;p&gt;有一点需要注意：我们要注意不要让任何业务逻辑进入这一层。如前一段所述，API 管理是共享基础架构，但由于我们的 API 流量通过它，它倾向于重造&amp;quot;全知全能&amp;rdquo;（思考企业服务总线）治理门户，为通过它，我们必须全盘改造我们的服务。理论上这听起来很棒。实际上，这可能最终成为组织瓶颈。有关更多信息，请参阅此文章：&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Network Functions with ESBs, API Management, and Now… Service Mesh?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;集群入口&#34;&gt;集群入口&lt;/h2&gt;
&lt;p&gt;为了构建和实现 API，我们专注于代码，数据，业务框架等方面。但是，要让这些的东西提供价值，必须对它们进行测试，部署到生产环境中并进行监控。当我们开始部署到云原生平台时，我们开始基于部署，容器，服务，主机，端口等考虑，以便构建我们的应用程序适应该环境。我们大概还需要制作工作流程（CI）和管道（CD），以利用云平台快速迭代，将其提供给客户等。&lt;/p&gt;
&lt;p&gt;在这种环境中，我们可以构建和维护多个集群来托管我们的应用程序，并需要某种方式来访问这些集群内的应用程序和服务。以 Kubernetes 为例。我们可以使用&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Ingress controller&lt;/a&gt;来允许访问 Kubernetes 集群（集群中的其他所有内容都无法从外部访问）。通过这种方式，我们可以非常严格地控制流量可能进入（甚至离开）我们的集群，具有明确定义的入口点，如域名/虚拟 hosts，端口，协议等。&lt;/p&gt;
&lt;p&gt;在这个层面中，我们可能希望某种&amp;quot;&lt;a href=&#34;https://istio.io/docs/tasks/traffic-management/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ingress gateway&lt;/a&gt;&amp;ldquo;成为允许请求和消息进入集群的流量哨兵。在这个层面中，你需要更多考虑的是：&amp;ldquo;我在我的集​​群中有这项服务，我需要集群外部的人能够调用它&amp;rdquo;。这可能是一个服务（暴露 API），一个系统整体，一个 gRPC 服务，一个缓存，一个消息队列，一个数据库等。有些人选择将其称为 API 网关，其中的一些可能实际上做得比流量入口/出口更多，但重点是问题存在于集群级操作上。由于我们倾向于部署更多集群（相对于单个高度多租户集群），我们最终会有更多网络入口点和彼此交互的需求。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/cluster-ingress-sketch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些类型的入口实现的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Envoy Proxy and projects that build upon it including:
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.getambassador.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Datawire Ambassador&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io Gloo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/heptio/contour&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Heptio Contour&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HAProxy
&lt;ul&gt;
&lt;li&gt;Including &lt;a href=&#34;https://docs.openshift.com/container-platform/3.9/install_config/router/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenShift’s Router&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/ingress-nginx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NGINX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://traefik.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Kong/kubernetes-ingress-controller&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此层面的集群入口控制器由平台团队管理，但是这个基础架构通常与更分散的自助服务工作流程相关联（正如您期望从云原生平台那样）。请参阅&lt;a href=&#34;https://www.weave.works/blog/gitops-operations-by-pull-request&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;See the &amp;ldquo;GitOps&amp;rdquo; workflow as described by the good folks at Weaveworks&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;api-gateway-模式&#34;&gt;API Gateway 模式&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;API 网关&amp;quot;这一术语的另一重意思才是我最开始理解的，即它是最接近 API Gateway 模式的那个。 &lt;a href=&#34;https://www.chrisrichardson.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chris Richardson&lt;/a&gt;在第 8 章的&amp;rdquo;&amp;quot;&lt;a href=&#34;https://microservices.io/book&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务设计模式&lt;/a&gt;&amp;ldquo;&amp;ldquo;一书中做了很好的工作。我强烈建议将该书用作本文和其他微服务模式的教学。在他的&lt;a href=&#34;https://microservices.io/patterns/apigateway.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;microservices.io&lt;/a&gt;网站可以上略扫一下即可知，API Gateway 模式，简而言之，是关于策划 API 以便更好地使用不同类别的消费者。此策略涉及 API 间接级别。您可能听到的代表 API Gateway 模式的另一个术语是&amp;quot;服务于前端的后端&amp;rdquo;，其中&amp;quot;前端&amp;quot;可以是单纯前端界面（UI），移动客户端，物联网客户端，甚至是其他服务/应用开发人员。&lt;/p&gt;
&lt;p&gt;在 API Gateway 模式中，我们明确简化了一组 API 的调用，以模拟特定用户，客户或消费者的&amp;quot;应用程序&amp;quot;的内聚 API。回想一下，当我们使用微服务来构建我们的系统时，&amp;ldquo;应用程序&amp;quot;的概念就会消失。API Gateway 模式有助于重塑此概念。这里的关键在于 API 网关，当它实现时，它成为客户端和应用程序的 API，并负责与任何后端 API 和其他应用程序网络端点（那些不符合上述 API 定义的端点）进行通信。&lt;/p&gt;
&lt;p&gt;与上一节中的 Ingress 控制器不同，此 API 网关更接近于开发人员的全局视图，并且不太关注为集群外消耗而暴露的端口或服务。这个&amp;quot;API Gateway&amp;quot;也不同于我们对已有 API 的进行管理所用的 API 管理观念。这个 API 网关掩盖了对可能暴露 API 的后端的调用，但是也可能会谈到较少描述为 API 的事情，例如对旧系统的 RPC 调用，使用不符合&amp;quot;REST&amp;quot;式优雅的协议调用，例如 JSON over HTTP，gRPC，SOAP，GraphQL，websockets 和消息队列这些黑科技。还可以调用这种类型的网关来进行消息级转换，复杂路由，网络负载均衡/回调以及响应的集成。&lt;/p&gt;
&lt;p&gt;如果您熟悉&lt;a href=&#34;https://www.crummy.com/writing/speaking/2008-QCon/act3.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Richardson 的 REST API 的成熟度模型&lt;/a&gt;，那么实现 API Gateway 模式的 API 网关会被要求集成更多的 Level 0 请求（以及介于两者之间的所有内容）而不是 Level 1-3 实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/richardson-model.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://martinfowler.com/articles/richardsonMaturityModel.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://martinfowler.com/articles/richardsonMaturityModel.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这些类型的网关实现仍然需要解决诸如速率限制，认证/授权，熔断，指标采集，流量路由等一类的事情。这些类型的网关可以在集群的边缘用作集群入口控制器，也可以在集群的深处用作应用程序网关。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-gateway-pattern.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此类 API 网关的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://spring.io/projects/spring-cloud-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud Gateway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io Gloo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Netflix/zuul&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix Zuul&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://strongloop.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM-Strongloop Loopback/Microgateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种类型的网关也可以使用更通用的编程或集成语言/框架来构建，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/camel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache Camel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://spring.io/projects/spring-integration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Integration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ballerina.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ballerina.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://vertx.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Eclipse Vert.x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/en/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NodeJS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于这种类型的 API 网关与应用程序和服务的开发密切相关，我们希望开发人员能够参与、帮助指定 API 网关公开的 API，了解所涉及的任何 mashup 逻辑以及需要能够快速测试和更改此 API 基础结构。我们还希望操作或 SRE 对 API 网关的安全性，弹性和可观察性配置有一些看法。此级别的基础架构还必须适应不断发展的按需自助服务开发人员工作流程。再次参见 GitOps 模型以获取更多信息。&lt;/p&gt;
&lt;h2 id=&#34;谈到服务网格&#34;&gt;谈到服务网格&lt;/h2&gt;
&lt;p&gt;在云基础架构上运行服务架构的一部分包括难以在网络中构建适当级别的可观察性和控制。在解决此问题的先前迭代中，&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们使用应用程序库和有希望的开发人员治理来实现此目的&lt;/a&gt;。然而，在规模和多语言环境中，&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格技术的出现提供了更好的解决方案&lt;/a&gt;。服务网格通过透明实现为平台及其组成服务带来以下功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务到服务（即东西流量）的恢复能力&lt;/li&gt;
&lt;li&gt;安全性包括最终用户验证，双向 TLS，服务到服务 RBAC / ABAC&lt;/li&gt;
&lt;li&gt;黑盒服务可观察性（专注于网络通信），用于请求/秒，请求延迟，请求失败，熔断事件，分布式跟踪等&lt;/li&gt;
&lt;li&gt;服务到服务速率限制，配额执行等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;精明的读者会认识到，&lt;a href=&#34;https://dzone.com/articles/api-gateway-vs-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API 网关和服务网格的功能似乎有些重叠&lt;/a&gt;。服务网格的目标是通过在 L7 上透明地解决任何服务/应用程序来解决这些问题。换句话说，服务网格希望融入服务（实际上没有被编码到服务的代码中）。另一方面，API 网关位于服务网格和应用程序之上（L8？）。服务网格为服务，主机，端口，协议等（东/西流量）之间的请求流带来价值。它们还可以提供基本的集群入口功能，以便为北/南流量带来一些此功能。但是，这不应与 API 网关可以为南北向流量带来的功能相混淆（如在集群的北/南和向应用程序或应用程序组的北/南）。&lt;/p&gt;
&lt;p&gt;服务网格和 API 网关在某些领域的功能上重叠，但它们是互补的，因为它们生活在不同的层次并解决不同的问题。理想的解决方案是将每个组件（API Management，API Gateway，Service Mesh）即插即用，并在需要时在组件之间保持良好的界限（或者在不需要它们时将其排除）。同样重要的是找到&lt;a href=&#34;https://developer.ibm.com/apiconnect/2018/12/10/api-management-centralized-or-decentralized/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;适合您的分散开发人员和操作工作流程&lt;/a&gt;的这些工具的实现。尽管这些不同组成部分的术语和身份存在混淆，但我们应该依赖于第一原则并理解我们的架构中这些组件在何处带来价值以及它们如何独立存在并共存互补性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://blog.christianposta.com/images/identity-crisis/api-layers.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;我们很乐意帮忙&#34;&gt;我们很乐意帮忙！&lt;/h2&gt;
&lt;p&gt;一些读者可能知道我热衷于帮助人们，特别是在云，微服务，事件驱动架构和服务网络领域。在我的公司，&lt;a href=&#34;https://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo.io&lt;/a&gt;，我们正在帮助 IT 组织认识并成功采用适当级别的网关和服务网格等 API 技术，以及他们成功优化它们的速度（更重要的是，他们确实需要这些技术！！）。我们在&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Proxy&lt;/a&gt;，&lt;a href=&#34;https://graphql.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GraphQL&lt;/a&gt;和&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;等技术的基础上构建了&lt;a href=&#34;https://gloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo&lt;/a&gt;，&lt;a href=&#34;https://sqoop.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Scoop&lt;/a&gt;和&lt;a href=&#34;https://supergloo.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SuperGloo&lt;/a&gt;等工具，以帮助实现 API 网关和服务网格管理。请直接联系我们（&lt;a href=&#34;https://twitter.com/soloio_inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@soloio_inc&lt;/a&gt;，&lt;a href=&#34;http://www.solo.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http：//solo.io&lt;/a&gt;）或直接与我联系（&lt;a href=&#34;http://www.twitter.com/christianposta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@christianposta&lt;/a&gt;，&lt;a href=&#34;http://blog.christianposta.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;），深入了解我们的愿景以及我们的技术如何为您的组织提供帮助。在下一系列博客中，我们将深入探讨 API Gateway 模式，多集群场景的难点，多服务网格的难点等！敬请关注！&lt;/p&gt;
&lt;h2 id=&#34;相关阅读&#34;&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
