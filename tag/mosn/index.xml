<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MOSN | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/tag/mosn/</link>
      <atom:link href="https://cloudnativecn.com/tag/mosn/index.xml" rel="self" type="application/rss+xml" />
    <description>MOSN</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Mon, 21 Jun 2021 10:03:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/media/sharing.png</url>
      <title>MOSN</title>
      <link>https://cloudnativecn.com/tag/mosn/</link>
    </image>
    
    <item>
      <title>蚂蚁开源多运行时项目 Layotto 简介</title>
      <link>https://cloudnativecn.com/blog/mosn-layotto-intro/</link>
      <pubDate>Mon, 21 Jun 2021 10:03:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/mosn-layotto-intro/</guid>
      <description>&lt;p&gt;Service Mesh 在微服务领域已经非常流行，越来越多的公司开始在内部落地，蚂蚁从 Service Mesh 刚出现的时候开始，就一直在这个方向上大力投入，到目前为止，内部的 Mesh 方案已经覆盖数千个应用、数十万容器并且经过了多次大促考验，Service Mesh 带来的业务解耦，平滑升级等优势大大提高了中间件的迭代效率。&lt;/p&gt;
&lt;p&gt;在大规模落地以后，我们又遇到了新的问题，本文主要对 Service Mesh 在蚂蚁内部落地情况进行回顾总结，并分享对 Service Mesh 落地后遇到的新问题的解决方案。&lt;/p&gt;
&lt;h2 id=&#34;一service-mesh-回顾与总结&#34;&gt;一、Service Mesh 回顾与总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A、Service Mesh 的初衷&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq157p298j30u00gv13d_hu4108385746504533479.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq157p298j30u00gv13d_hu10719959660077587604.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq157p298j30u00gv13d_hu17503487021034332083.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq157p298j30u00gv13d_hu4108385746504533479.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在微服务架构下，基础架构团队一般会为应用提供一个封装了各种服务治理能力的 SDK，这种做法虽然保障了应用的正常运行，但缺点也非常明显，每次基础架构团队迭代一个新功能都需要业务方参与升级才能使用，尤其是 bugfix 版本，往往需要强推业务方升级，这里面的痛苦程度每一个基础架构团队成员都深有体会。&lt;/p&gt;
&lt;p&gt;伴随着升级的困难，随之而来的就是应用使用的 SDK 版本差别非常大，生产环境同时跑着各种版本的 SDK，这种现象又会让新功能的迭代必须考虑各种兼容，就好像带着枷锁前进一般，这样随着不断迭代，会让代码维护非常困难，有些祖传逻辑更是一不小心就会掉坑里。&lt;/p&gt;
&lt;p&gt;同时这种“重”SDK 的开发模式，导致异构语言的治理能力非常薄弱，如果想为各种编程语言都提供一个功能完整且能持续迭代的 SDK 其中的成本可想而知。&lt;/p&gt;
&lt;p&gt;18 年的时候，Service Mesh 在国内持续火爆，这种架构理念旨在把服务治理能力跟业务解耦，让两者通过进程级别的通信方式进行交互。在这种架构模式下，服务治理能力从应用中剥离，运行在独立的进程中，迭代升级跟业务进程无关，这就可以让各种服务治理能力快速迭代，并且由于升级成本低，因此每个版本都可以全部升级，解决了历史包袱问题，同时 SDK 变“轻”直接降低了异构语言的治理门槛，再也不用为需要给各个语言开发相同服务治理能力的 SDK 头疼了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B、Service Mesh 落地现状&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq157uliyj30u00gy14n_hu1892226495005012542.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq157uliyj30u00gy14n_hu7802778532532193065.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq157uliyj30u00gy14n_hu1822673971059526451.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq157uliyj30u00gy14n_hu1892226495005012542.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;蚂蚁很快意识到了 Service Mesh 的价值，全力投入到这个方向，用 Go 语言开发了 MOSN 这样可以对标 envoy 的优秀数据面，全权负责服务路由，负载均衡，熔断限流等能力的建设，大大加快了公司内部落地 Service Mesh 的进度。&lt;/p&gt;
&lt;p&gt;现在 MOSN 在蚂蚁内部已经覆盖了数千个应用、数十万容器，新创建的应用默认接入 MOSN，形成闭环。而且在大家最关心的资源占用、性能损耗方面 MOSN 也交出了一份让人满意的答卷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;RT 小于 0.2ms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU 占用增加 0%~2%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存消耗增长小于 15M&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于 Service Mesh 降低了异构语言的服务治理门槛，NodeJS、C++ 等异构技术栈也在持续接入到 MOSN 中。&lt;/p&gt;
&lt;p&gt;在看到 RPC 能力 Mesh 化带来的巨大收益之后，蚂蚁内部还把 MQ，Cache，Config 等中间件能力都进行了 Mesh 化改造，下沉到 MOSN，提高了中间件产品整体的迭代效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C、新的挑战&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用跟基础设施强绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15ggwwej30u00gs7ek_hu11124358981975393492.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15ggwwej30u00gs7ek_hu2664319814919047175.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15ggwwej30u00gs7ek_hu18275828797404069198.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15ggwwej30u00gs7ek_hu11124358981975393492.webp&#34;
               width=&#34;760&#34;
               height=&#34;425&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;一个现代分布式应用，往往会同时依赖 RPC、Cache、MQ、Config 等各种分布式能力来完成业务逻辑的处理。&lt;/p&gt;
&lt;p&gt;当初看到 RPC 下沉的红利以后，其他各种能力也都快速下沉。初期，大家都会以自己最熟悉的方式来开发，这就导致没有统一的规划管理，如上图所示，应用依赖了各种基础设施的 SDK，而每种 SDK 又以自己特有的方式跟 MOSN 进行交互，使用的往往都是由原生基础设施提供的私有协议，这直接导致了复杂的中间件能力虽然下沉，但应用本质上还是被绑定到了基础设施，比如想把缓存从 Redis 迁移到 Memcache 的话，仍旧需要业务方升级 SDK，这种问题在应用上云的大趋势下表现的更为突出，试想一下，如果一个应用要部署在云上，由于该应用依赖了各种基础设施，势必要先把整个基础设施搬到云上才能让应用顺利部署，这其中的成本可想而知。&lt;/p&gt;
&lt;p&gt;因此如何让应用跟基础设施解绑，使其具备可移植能力，能够无感知跨平台部署是我们面临的第一个问题。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;异构语言接入成本高&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15drahdj30u00grwp1_hu15930399819906723496.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15drahdj30u00grwp1_hu8492641632031587916.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15drahdj30u00grwp1_hu9217186800384426510.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15drahdj30u00grwp1_hu15930399819906723496.webp&#34;
               width=&#34;760&#34;
               height=&#34;424&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;事实证明 Service Mesh 确实降低了异构语言的接入门槛，但在越来越多的基础能力下沉到 MOSN 以后，我们逐渐意识到为了让应用跟 MOSN 交互，各种 SDK 里都需要对通信协议，序列化协议进行开发，如果再加上需要对各种异构语言都提供相同的功能，那维护难度就会成倍上涨，&lt;/p&gt;
&lt;p&gt;Service Mesh 让重 SDK 成为了历史，但对于现在各种编程语言百花齐放、各种应用又强依赖基础设施的场景来说，我们发现现有的 SDK 还不够薄，异构语言接入的门槛还不够低，如何进一步降低异构语言的接入门槛是我们面临的第二个问题。&lt;/p&gt;
&lt;h2 id=&#34;二multi-runtime-理论概述&#34;&gt;二、Multi Runtime 理论概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A、什么是 Runtime?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15huvpcj30u00h1aj0_hu7023861356566337596.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15huvpcj30u00h1aj0_hu6074417790757986342.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15huvpcj30u00h1aj0_hu9991929975037014480.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15huvpcj30u00h1aj0_hu7023861356566337596.webp&#34;
               width=&#34;760&#34;
               height=&#34;432&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;20 年初的时候，Bilgin lbryam 发表了一篇名为&lt;/p&gt;
&lt;p&gt;Multi-Runtime Microservices Architecture&lt;/p&gt;
&lt;p&gt;的文章，里面对微服务架构下一阶段的形态进行了讨论。&lt;/p&gt;
&lt;p&gt;如上图所示，作者把分布式服务的需求进行了抽象，总共分为了四大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生命周期（Lifecycle）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主要指应用的编译、打包、部署等事情，在云原生的大趋势下基本被 docker、kubernetes 承包。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;网络（Networking）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可靠的网络是微服务之间进行通信的基本保障，Service Mesh 正是在这方面做了尝试，目前 MOSN、envoy 等流行的数据面的稳定性、实用性都已经得到了充分验证。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;状态（State）&lt;/p&gt;
&lt;p&gt;分布式系统需要的服务编排，工作流，分布式单例，调度，幂等性，有状态的错误恢复，缓存等操作都可以统一归为底层的状态管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绑定（Binding）&lt;/p&gt;
&lt;p&gt;在分布式系统中，不仅需要跟其他系统通信，还需要集成各种外部系统，因此对于协议转换，多种交互模型、错误恢复流程等功能也都有强依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;明确了需求以后，借鉴了 Service Mesh 的思路，作者对分布式服务的架构演进进行了如下总结：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15hhinxj30u00gn13d_hu10140118623145512912.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15hhinxj30u00gn13d_hu14146177979069819258.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15hhinxj30u00gn13d_hu16583928817991983972.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15hhinxj30u00gn13d_hu10140118623145512912.webp&#34;
               width=&#34;760&#34;
               height=&#34;422&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第一阶段就是把各种基础设施能力从应用中剥离解耦，通通变成独立 sidecar 模型伴随着应用一起运行。&lt;/p&gt;
&lt;p&gt;第二阶段是把各种 sidecar 提供的能力统一抽象成若干个 Runtime，这样应用从面向基础组件开发就演变成了面向各种分布式能力开发，彻底屏蔽掉了底层实现细节，而且由于是面向能力，除了调用提供各种能力的 API 之外，应用再也不需要依赖各种各样基础设施提供的 SDK 了。&lt;/p&gt;
&lt;p&gt;作者的思路跟我们希望解决的问题一致，我们决定使用 Runtime 的理念来解决 Service Mesh 发展到现在所遇到的新问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B, Service Mesh vs Runtime&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15awmo2j30u00fhgxm_hu10227862474509872954.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15awmo2j30u00fhgxm_hu3280391388188337667.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15awmo2j30u00fhgxm_hu16042999804962215275.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15awmo2j30u00fhgxm_hu10227862474509872954.webp&#34;
               width=&#34;760&#34;
               height=&#34;392&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了让大家对 Runtime 有一个更加清晰的认识，上图针对 Service Mesh 跟 Runtime 两种理念的定位、交互方式、通信协议以及能力丰富度进行了总结，可以看到相比 Service Mesh 而言，Runtime 提供了语义明确、能力丰富的 API，可以让应用跟它的交互变得更加简单直接。&lt;/p&gt;
&lt;h2 id=&#34;三mosn-子项目-layotto&#34;&gt;三、MOSN 子项目 Layotto&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A、dapr 调研&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq159kxfej30u00gz13c_hu17576767247607710375.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq159kxfej30u00gz13c_hu1115925690357439966.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq159kxfej30u00gz13c_hu12899443580126913703.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq159kxfej30u00gz13c_hu17576767247607710375.webp&#34;
               width=&#34;760&#34;
               height=&#34;430&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;dapr 是社区中一款知名的 Runtime 实现产品，活跃度也比较高，因此我们首先调研了 dapr 的情况，发现 dapr 具有如下优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;提供了多种分布式能力，API 定义清晰，基本能满足一般的使用场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;针对各种能力都提供了不同的实现组件，基本涵盖了常用的中间件产品，用户可以根据需要自由选择。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当考虑如何在公司内部落地 dapr 时，我们提出了两种方案，如上图所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;替换：废弃掉现在的 MOSN，用 dapr 进行替换，这种方案存在两个问题：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a.  dapr 虽然提供了很多分布式能力，但目前并不具备 Service Mesh 包含的丰富的服务治理能力。&lt;/p&gt;
&lt;p&gt;b.  MOSN 在公司内部已经大规模落地，并且经过了多次大促考验，直接用 dapr 来替换 MOSN 稳定性有待验证。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;共存：新增一个 dapr 容器，跟 MOSN 以两个 sidecar 的模式进行部署。这种方案同样存在两个问题：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a.  引入一个新的 sidecar，我们就需要考虑它配套的升级、监控、注入等等事情，运维成本飙升。&lt;/p&gt;
&lt;p&gt;b.  多维护一个容器意味着多了一层挂掉的风险，这会降低现在的系统可用性。&lt;/p&gt;
&lt;p&gt;同样的，如果你目前正在使用 envoy 作为数据面，也会面临上述问题。&lt;/p&gt;
&lt;p&gt;因此我们希望把 Runtime 跟 Service Mesh 两者结合起来，通过一个完整的 sidecar 进行部署，在保证稳定性、运维成本不变的前提下，最大程度复用现有的各种 Mesh 能力。此外我们还希望这部分 Runtime 能力除了跟 MOSN 结合起来之外，未来也可以跟 envoy 结合起来，解决更多场景中的问题，Layotto 就是在这样的背景下诞生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B、Layotto 架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15gyopkj60u00ggako02_hu1041136729881850765.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15gyopkj60u00ggako02_hu12016269781904101308.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15gyopkj60u00ggako02_hu8275413878982701418.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15gyopkj60u00ggako02_hu1041136729881850765.webp&#34;
               width=&#34;760&#34;
               height=&#34;416&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如上图所示，Layotto 是构建在 MOSN 之上，在下层对接了各种基础设施，向上层应用提供了统一的，具有各种各样分布式能力的标准 API。对于接入 Layotto 的应用来说，开发者不再需要关心底层各种组件的实现差异，只需要关注应用需要什么样的能力，然后调用对应能力的 API 即可，这样可以彻底跟底层基础设施解绑。&lt;/p&gt;
&lt;p&gt;对应用来说，交互分为两块，一个是作为 gRPC Client 调用 Layotto 的标准 API，一个是作为 gRPC Server 来实现 Layotto 的回调，得利于 gRPC 优秀的跨语言支持能力，应用不再需要关心通信、序列化等细节问题，进一步降低了异构技术栈的使用门槛。&lt;/p&gt;
&lt;p&gt;除了面向应用，Layotto 也向运维平台提供了统一的接口，这些接口可以把应用跟 sidecar 的运行状态反馈给运维平台，方便 SRE 同学及时了解应用的运行状态并针对不同状态做出不同的举措，该功能考虑到跟 k8s 等已有的平台集成，因此我们提供了 HTTP 协议的访问方式。&lt;/p&gt;
&lt;p&gt;除了 Layotto 本身设计以外，项目还涉及两块标准化建设，首先想要制定一套语义明确，适用场景广泛的 API 并不是一件容易的事情，为此我们跟阿里、dapr 社区进行了合作，希望能够推进 Runtime API 标准化的建设，其次对于 dapr 社区已经实现的各种能力的 Components 来说，我们的原则是优先复用、其次开发，尽量不把精力浪费在已有的组件上面，重复造轮子。&lt;/p&gt;
&lt;p&gt;最后 Layotto 目前虽然是构建在 MOSN 之上，未来我们希望 Layotto 可以跑在 envoy 上，这样只要应用接入了 Service Mesh，无论数据面使用的是 MOSN 还是 envoy，都可以在上面增加 Runtime 能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C、Layotto 的移植性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq1582qecj30u00h949f_hu16952360544182686375.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq1582qecj30u00h949f_hu6915736887240224875.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq1582qecj30u00h949f_hu12876878921360192141.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq1582qecj30u00h949f_hu16952360544182686375.webp&#34;
               width=&#34;760&#34;
               height=&#34;437&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如上图所示，一旦完成 Runtime API 的标准化建设，接入 Layotto 的应用天然具备了可移植性，应用不需要任何改造就可以在私有云以及各种公有云上部署，并且由于使用的是标准 API，应用也可以无需任何改造就在 Layotto 跟 dapr 之间自由切换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;D、名字含义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15f2gjnj30u00gwwod_hu13646760795061874403.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15f2gjnj30u00gwwod_hu13708311460993385633.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15f2gjnj30u00gwwod_hu12526443662870065103.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15f2gjnj30u00gwwod_hu13646760795061874403.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从上面的架构图可以看出，Layotto 项目本身是希望屏蔽基础设施的实现细节，向上层应用统一提供各种分布式能力，这种做法就好像是在应用跟基础设施之间加了一层抽象，因此我们借鉴了 OSI 对网络定义七层模型的思路，希望 Layotto 可以作为第八层对应用提供服务，otto 是意大利语中 8 的意思，Layer otto 就是第八层的意思，简化了一下变成了 Layotto，同时项目代号 L8，也是第八层的意思，这个代号也是设计我们项目 LOGO 时灵感的来源。&lt;/p&gt;
&lt;p&gt;介绍完项目的整体情况，下面对其中四个主要功能的实现细节进行说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E、配置原语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15g0osxj30u00gu48w_hu6520999731976108630.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15g0osxj30u00gu48w_hu6335641713411378940.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15g0osxj30u00gu48w_hu11239249621189936019.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15g0osxj30u00gu48w_hu6520999731976108630.webp&#34;
               width=&#34;760&#34;
               height=&#34;426&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先是分布式系统中经常使用的配置功能，应用一般使用配置中心来做开关或者动态调整应用的运行状态。Layotto 中配置模块的实现包括两部分，一个是对如何定义配置这种能力的 API 的思考，一个是具体的实现，下面逐个来看。&lt;/p&gt;
&lt;p&gt;想要定义一个能满足大部分实际生产诉求的配置 API 并不是一件容易的事，dapr 目前也缺失这个能力，因此我们跟阿里以及 dapr 社区一起合作，为如何定义一版合理的配置 API 进行了激烈讨论。&lt;/p&gt;
&lt;p&gt;目前讨论结果还没有最终确定，因此 Layotto 是基于我们提给社区的第一版草案进行实现，下面对我们的草案进行简要说明。&lt;/p&gt;
&lt;p&gt;我们先定义了一般配置所需的基本元素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;appId：表示配置属于哪个应用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;key：配置的 key&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;content：配置的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;group：配置所属的分组，如果一个 appId 下面的配置过多，我们可以给这些配置进行分组归类，便于维护。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此外我们追加了两种高级特性，用来适配更加复杂的配置使用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;label，用于给配置打标签，比如该配置属于哪个环境，在进行配置查询的时候，我们会使用 label + key 来查询配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tags，用户给配置追加的一些附加信息，如描述信息、创建者信息，最后修改时间等等，方便配置的管理，审计等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于上述定义的配置 API 的具体实现，目前支持查询、订阅、删除、创建、修改五种操作，其中订阅配置变更后的推送使用的是 gRPC 的 stream 特性，而底层实现这些配置能力的组件，我们选择了国内流行的 apollo，后面也会根据需求增加其他实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;F、Pub/Sub 原语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq158ic3jj30u00gwn6v_hu5854632576737569593.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq158ic3jj30u00gwn6v_hu4233439309319239888.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq158ic3jj30u00gwn6v_hu10104836383963669363.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq158ic3jj30u00gwn6v_hu5854632576737569593.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于 Pub/Sub 能力的支持，我们调研了 dapr 现在的实现，发现基本上已经可以满足我们的需求，因此我们直接复用了 dapr 的 API 以及 components，只是在 Layotto 里面做了适配，这为我们节省了大量的重复劳动，我们希望跟 dapr 社区保持一种合作共建的思路，而不是重复造轮子。&lt;/p&gt;
&lt;p&gt;其中 Pub 功能是 App 调用 Layotto 提供的 PublishEvent 接口，而 Sub 功能则是应用通过 gRPC Server 的形式实现了 ListTopicSubscriptions 跟 OnTopicEvent 两个接口，一个用来告诉 Layotto 应用需要订阅哪些 topic，一个用于接收 topic 变化时 Layotto 的回调事件。&lt;/p&gt;
&lt;p&gt;dapr 对于 Pub/Sub 的定义基本满足我们的需求，但在某些场景下仍有不足，dapr 采用了 CloudEvent 标准，因此 Pub 接口没有返回值，这无法满足我们生产场景中要求 Pub 消息以后服务端返回对应的 messageID 的需求，这一点我们已经把需求提交给了 dapr 社区，还在等待反馈，考虑到社区异步协作的机制，我们可能会先社区一步增加返回结果，然后再跟社区探讨一种更好的兼容方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;G、RPC 原语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15fi4ftj30u00h3wou_hu4000211818038595826.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15fi4ftj30u00h3wou_hu17066656259054902403.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15fi4ftj30u00h3wou_hu14520200562112625455.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15fi4ftj30u00h3wou_hu4000211818038595826.webp&#34;
               width=&#34;760&#34;
               height=&#34;432&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;RPC 的能力大家不会陌生，这可能是微服务架构下最最基础的需求，对于 RPC 接口的定义，我们同样参考了 dapr 社区的定义，发现完全可以满足我们的需求，因此接口定义就直接复用 dapr 的，但目前 dapr 提供的 RPC 实现方案还比较薄弱，而 MOSN 经过多年迭代，能力已经非常成熟完善，因此我们大胆把 Runtime 跟 Service Mesh 两种思路结合在一起，把 MOSN 本身作为我们实现 RPC 能力的一个 Component，这样 Layotto 在收到 RPC 请求以后交给 MOSN 进行实际数据传输，这种方案可以通过 istio 动态改变路由规则，降级限流等等设置，相当于直接复用了 Service Mesh 的各种能力，这也说明 Runtime 不是要推翻 Service Mesh，而是要在此基础上继续向前迈一步。&lt;/p&gt;
&lt;p&gt;具体实现细节上，为了更好的跟 MOSN 融合，我们在 RPC 的实现上面加了一层 Channel，默认支持 dubbo，bolt，http 三种常见的 RPC 协议，如果仍然不能满足用户场景，我们还追加了 Before/After 两种 Filter，可以让用户做自定义扩展，实现协议转换等需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;H、Actuator 原语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15c8kvcj30u00h0til_hu2531431223639649396.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15c8kvcj30u00h0til_hu12246719445434174464.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15c8kvcj30u00h0til_hu10606823352657954315.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15c8kvcj30u00h0til_hu2531431223639649396.webp&#34;
               width=&#34;760&#34;
               height=&#34;431&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在实际生产环境中，除了应用所需要的各种分布式能力以外，PaaS 等运维平台往往需要了解应用的运行状态，基于这种需求，我们抽象了一套 Actuator 接口，目前 dapr 还没有提供这方面的能力，因此我们根据内部的需求场景进行了设计，旨在把应用在启动期、运行期等阶段各种各样的信息暴露出去，方便 PaaS 了解应用的运行情况。&lt;/p&gt;
&lt;p&gt;Layotto 把暴露信息分为两大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Health：该模块判断应用当前运行状态是否健康，比如某个强依赖的组件如果初始化失败就需要表示为非健康状态，而对于健康检查的类型我们参考了 k8s，分为：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a.  Readiness：表示应用启动完成，可以开始处理请求。&lt;/p&gt;
&lt;p&gt;b.  Liveness：表示应用存活状态，如果不存活则需要切流等。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Info：该模块预期会暴露应用的一些依赖信息出去，如应用依赖的服务，订阅的配置等等，用于排查问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Health 对外暴露的健康状态分为以下三种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;INIT：表示应用还在启动中，如果应用发布过程中返回该值，这个时候 PaaS 平台应该继续等待应用完成启动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UP：表示应用启动正常，如果应用发布过程中返回该值，意味着 PasS 平台可以开始放入流量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DOWN：表示应用启动失败，如果应用发布过程中返回该值，意味着 PaaS 需要停止发布并通知应用 owner。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到这里关于 Layotto 目前在 Runtime 方向上的探索基本讲完了，我们通过定义明确语义的 API，使用 gRPC 这种标准的交互协议解决了目前面临的基础设施强绑定、异构语言接入成本高两大问题。随着未来 API 标准化的建设，一方面可以让接入 Layotto 的应用无感知的在各种私有云、公有云上面部署，另一方面也能让应用在 Layotto，dapr 之间自由切换，提高研发效率。&lt;/p&gt;
&lt;p&gt;目前 Serverless 领域也是百花齐放，没有一种统一的解决方案，因此 Layotto 除了在上述 Runtime 方向上的投入以外，还在 Serverless 方向上也进行了一些尝试，下面就尝试方案进行介绍。&lt;/p&gt;
&lt;h2 id=&#34;四webassembly-的探索&#34;&gt;四、WebAssembly 的探索&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A、WebAssembly 简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq1590y7tj30u00ggwqv_hu4705674386813387899.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq1590y7tj30u00ggwqv_hu7340230694683862265.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq1590y7tj30u00ggwqv_hu1236613404094387983.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq1590y7tj30u00ggwqv_hu4705674386813387899.webp&#34;
               width=&#34;760&#34;
               height=&#34;416&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;WebAssembly，简称 WASM，是一个二进制指令集，最初是跑在浏览器上来解决 JavaScript 的性能问题，但由于它良好的安全性，隔离性以及语言无关性等优秀特性，很快人们便开始让它跑在浏览器之外的地方，随着 WASI 定义的出现，只需要一个 WASM 运行时，就可以让 WASM 文件随处执行。&lt;/p&gt;
&lt;p&gt;既然 WebAssembly 可以在浏览器以外的地方运行，那么我们是否能把它用在 Serverless 领域？目前已经有人在这方面做了一些尝试，不过如果这种方案真的想落地的话，首先要考虑的就是如何解决运行中的 WebAssembly 对各种基础设施的依赖问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B、WebAssembly 落地原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前 MOSN 通过集成 WASM Runtime 的方式让 WASM 跑在 MOSN 上面，以此来满足对 MOSN 做自定义扩展的需求。同时，Layotto 也是构建在 MOSN 之上，因此我们考虑把二者结合在一起，实现方案如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15d6x2tj30u00g9wng_hu7056850414128484623.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15d6x2tj30u00g9wng_hu13742919450975560925.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15d6x2tj30u00g9wng_hu10583408428955177835.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15d6x2tj30u00g9wng_hu7056850414128484623.webp&#34;
               width=&#34;760&#34;
               height=&#34;412&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;开发者可以使用 Go/C++/Rust 等各种各样自己喜欢的语言来开发应用代码，然后把它们编译成 WASM 文件跑在 MOSN 上面，当 WASM 形态的应用在处理请求的过程中需要依赖各种分布式能力时就可以通过本地函数调用的方式调用 Layotto 提供的标准 API，这样直接解决了 WASM 形态应用的依赖问题。&lt;/p&gt;
&lt;p&gt;目前 Layotto 提供了 Go 跟 Rust 版 WASM 的实现，虽然只支持 demo 级功能，但已经足够让我们看到这种方案的潜在价值。&lt;/p&gt;
&lt;p&gt;此外，WASM 社区目前还处于初期阶段，有很多地方需要完善，我们也给社区提交了一些 PR 共同建设，为 WASM 技术的落地添砖加瓦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C、WebAssembly 落地展望&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq159zou3j30u00g7wqn_hu3306422443617543949.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq159zou3j30u00g7wqn_hu15600812074145514733.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq159zou3j30u00g7wqn_hu3377870693665398702.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq159zou3j30u00g7wqn_hu3306422443617543949.webp&#34;
               width=&#34;760&#34;
               height=&#34;410&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;虽然现在 Layotto 中对 WASM 的使用还处于试验阶段，但我们希望它最终可以成为 Serverless 的一种实现形态，如上图所示，应用通过各种编程语言开发，然后统一编译成 WASM 文件，最后跑在 Layotto+MOSN 上面，而对于应用的运维管理统一由 k8s、docker、prometheus 等产品负责。&lt;/p&gt;
&lt;h2 id=&#34;五社区规划&#34;&gt;五、社区规划&lt;/h2&gt;
&lt;p&gt;最后来看下 Layotto 在社区的做的一些事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A, Layotto vs Dapr&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15ahwq0j30u00gztjk_hu13583979359002135240.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15ahwq0j30u00gztjk_hu12004420219114972591.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15ahwq0j30u00gztjk_hu9996633536420319372.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15ahwq0j30u00gztjk_hu13583979359002135240.webp&#34;
               width=&#34;760&#34;
               height=&#34;430&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上图列出了 Layotto 跟 dapr 现有的能力对比，在 Layotto 的开发过程中，我们借鉴 dapr 的思路，始终以优先复用、其次开发为原则，旨在达成共建的目标，而对于正在建设或者未来要建设的能力来说，我们计划优先在 Layotto 上落地，然后再提给社区，合并到标准 API，鉴于社区异步协作的机制，沟通成本较高，因此短期内可能 Layotto 的 API 会先于社区，但长期来看一定会统一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B、API 共建计划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15bgf6ej30u00gp46v_hu5682610953012680884.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15bgf6ej30u00gp46v_hu4763750622265453420.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15bgf6ej30u00gp46v_hu8819316790498641800.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15bgf6ej30u00gp46v_hu5682610953012680884.webp&#34;
               width=&#34;760&#34;
               height=&#34;423&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;关于如何定义一套标准的 API 以及如何让 Layotto 可以跑在 envoy 上等等事项，我们已经在各个社区进行了深入讨论，并且以后也还会继续推进。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C、Roadmap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15cshaej30u00gwdpz_hu6782167336953396158.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15cshaej30u00gwdpz_hu7140660926694977910.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15cshaej30u00gwdpz_hu888510989500545361.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15cshaej30u00gwdpz_hu6782167336953396158.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Layotto 在目前主要支持 RPC、Config、Pub/Sub、Actuator 四大功能，预计在九月会把精力投入到分布式锁、State、可观测性上面，十二月份会支持 Layotto 插件化，也就是让它可以跑在 envoy 上，同时希望对 WebAssembly 的探索会有进一步的产出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;D、正式开源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Image&#34; srcset=&#34;
               /blog/mosn-layotto-intro/008i3skNly1grq15by16mj30u00ffdpf_hu8885749944556028455.webp 400w,
               /blog/mosn-layotto-intro/008i3skNly1grq15by16mj30u00ffdpf_hu8458641932884311943.webp 760w,
               /blog/mosn-layotto-intro/008i3skNly1grq15by16mj30u00ffdpf_hu17863252802213097743.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/mosn-layotto-intro/008i3skNly1grq15by16mj30u00ffdpf_hu8885749944556028455.webp&#34;
               width=&#34;760&#34;
               height=&#34;391&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Image
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;前面详细介绍了 Layotto 项目，最重要的还是该项目今天作为 MOSN 的子项目正式开源，我们提供了详细的文档以及 demo 示例方便大家快速上手体验。&lt;/p&gt;
&lt;p&gt;对于 API 标准化的建设是一件需要长期推动的事情，同时标准化意味着不是满足一两种场景，而是尽可能的适配大多数使用场景，为此我们希望更多的人可以参与到 Layotto 项目中，描述你的使用场景，讨论 API 的定义方案，一起提交给社区，最终达成 Write once, Run anywhere 的终极目标！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生网络代理 MOSN 的进化之路</title>
      <link>https://cloudnativecn.com/blog/cloud-native-mosn/</link>
      <pubDate>Sat, 29 Aug 2020 09:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/cloud-native-mosn/</guid>
      <description>&lt;p&gt;本文是 2020 年 8 月 15 号在深圳 GIAC（GLOBAL INTERNET ARCHITECTURE CONFERENCE）全球互联网架构大会，由&lt;a href=&#34;https://jimmysong.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;宋净超（Jimmy Song）&lt;/a&gt;出品的云原生专场中的现场实录。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./self.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;王发康（毅松）蚂蚁集团可信原生技术部 技术专家，专注于高性能网络服务器研发，是 MOSN、Tengine 开源项目核心成员，目前关注云原生 Service Mesh、Nginx、Istio 等相关领域，喜欢开源，乐于分享，GItHub：&lt;a href=&#34;https://github.com/wangfakang&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/wangfakang&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;以下是分享全文。&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;YykNg&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/mosn/mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MOSN&lt;/a&gt; 在蚂蚁集团的 Service Mesh 大规模落地后，通过对接 UDPA 打造为 Istio 的数据面之一，本文就其在演进过程中遇到的问题及思考进行展开。对接 UDPA，实现 Istio 融合，并增强 MOSN 服务治理及流量控制能力对接云原生周边组件，实现 MOSN 开箱即用。&lt;/p&gt;
&lt;p&gt;大家下午好，我叫王发康，来自蚂蚁集团可信云原生应用网络团队，之前几年一直从事南北向网关（接入层）的开发和维护，说来也是和流量有着别样的渊缘，现在主要做东西向的流量网关（Service Mesh）开发和设计。今天演讲的主题是《云原生网络代理 MOSN 的进化之路》，主要从如下几点介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MOSN 介绍&lt;/li&gt;
&lt;li&gt;云原生演进&lt;/li&gt;
&lt;li&gt;总结与展望&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name=&#34;l2ZhB&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mosn-介绍&#34;&gt;MOSN 介绍&lt;/h2&gt;
&lt;p&gt;接下来，就 MOSN 的诞生背景、发展历程、MOSN 具备的功能和架构以及内部的落地情况这几个维度介绍下 MOSN。&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;Ep0xZ&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;mosn-诞生背景&#34;&gt;MOSN 诞生背景&lt;/h3&gt;
&lt;p&gt;随着云计算、物联网等技术迅速发展，也促使着微服务的架构一直在进化，其演进过程通常经历了如下四个阶段：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单体&lt;/strong&gt;：一般起始阶段业务很简单，流量也不大，所有的处理都可以在一个服务中完成；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式&lt;/strong&gt;：随着业务操作的多样化以及流量的日益增长，不得不按照服务维度进行拆分，这样相同的服务资源消耗可对等，方便容量评估及管理；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务&lt;/strong&gt;：随着服务的拆分粒度越来越细，其服务的数量一直在增加，由此出现各种微服务治理的需求（限流、鉴权、路由等），于是便出现各种治理组件并以 SDK 插件的方式集成到不同应用中；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service Mesh&lt;/strong&gt;：伴随着服务治理的 SDK 种类、版本、重复等一系列问题，于是把 SDK 的能力剥离到 Sidecar，和业务进行解耦，从而实现业务和中间件能力的并行迭代；&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./micro-service-arch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业务痛点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多语言，中间件组件开发适配成本高&lt;/li&gt;
&lt;li&gt;SDK 升级困难&lt;/li&gt;
&lt;li&gt;服务治理能力弱&lt;/li&gt;
&lt;li&gt;技术不通用，无法复用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;业界解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Envoy (C++)&lt;/li&gt;
&lt;li&gt;Linkerd (活跃度较低)&lt;/li&gt;
&lt;li&gt;NginxMesh (活跃度低)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综合以上业务痛点以及业界现有方案的评估，于是 MOSN 就诞生了。MOSN（Modular Open Smart Network）是用 GoLang 编写的网络代理服务器。作为 Sidecar、API Gateway、云原生 Ingress、Layer 4 或 Layer 7 负载均衡器等场景构建的。随着时间的推移，我们添加了额外的功能，例如多协议框架，多进程插件机制，DSL 以及对 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xDS API&lt;/a&gt; 等的支持，支持 xDS 意味着我们现在可以将 MOSN 用作 Istio 的数据平面。&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;WjNdN&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;mosn-发展历程&#34;&gt;MOSN 发展历程&lt;/h3&gt;
&lt;p&gt;从 2017 年底开始 Service Mesh 技术调研，2018 年 3 月份 MOSN 雏形问世并进行了小规模试点，秉着让更多的用户能够享受这一技术红利的思路，于是 2018 年 6 月正式开源 MOSN。2019 年 618 进行了规模化落地，并在同年的双 11 大促达到了核心支付链路的全覆盖。在通过大规模验证后，MOSN 社区开始在其标准化以及生态方面进行发展和演进。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-history.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;8KL46&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;mosn-功能视图&#34;&gt;MOSN 功能视图&lt;/h3&gt;
&lt;p&gt;MOSN 作为一个通用的数据转发平面，提供多协议卸载、动态服务发现、服务治理（Trace、限流、重试、重写、超时控制等）、丰富的负载均衡算法等功能，可用于 Sidecar、API Gateway、云原生 Ingress、Layer 4 或 Layer 7 负载均衡器等场景。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-features.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;JWpPc&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;mosn-架构解析&#34;&gt;MOSN 架构解析&lt;/h3&gt;
&lt;p&gt;MOSN 采用的是分层的体系结构，其系统分为 NET/IO、Protocol、Stream、Proxy 四层：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-layer-arch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NET/IO 作为网络层，监测连接和数据包的到来，同时作为 listener filter 和 network filter 的挂载点;&lt;/li&gt;
&lt;li&gt;Protocol 作为多协议引擎层，对数据包进行检测，并使用对应协议做 decode/encode 处理;&lt;/li&gt;
&lt;li&gt;Stream 对 decode 的数据包做二次封装为 stream，作为 stream filter 的挂载点;&lt;/li&gt;
&lt;li&gt;Proxy 作为 MOSN 的转发框架，对封装的 stream 做 proxy 处理;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，每一层通过工厂设计模式向外暴露其接口，方便用户灵活地注册自身的需求。通过协程池的方式使得用户以同步的编码风格实现异步功能特性。通过区分协程类型，MOSN 实现了 read 和 proxy worker 两大类协程，read 协程主要是处理网络的读取及协议解析，proxy worker 协程用来完成读取后数据的加工、路由、转发等。其架构如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-gorouting-arch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;MOSN 为了降低 Runtime GC 带来的卡顿，自身做了内存池的封装方便多种对象高效地复用，另外为了提升服务网格之间的建连性能还设计了多种协议的连接池从而方便地实现连接复用及管理。
在连接管理方面，MOSN 设计了多协议连接池，当 Proxy 模块在 Downstream 收到 Request 的时候，在经过路由、负载均衡等模块处理获取到 Upstream Host 以及对应的转发协议时，通过 Cluster Manager 获取对应协议的连接池，如果连接池不存在则创建并加入缓存中，之后在长连接上创建 Stream，并发送数据，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-connpool.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在内存管理方面，MOSN 在 sync.Pool 之上封装了一层资源对的注册管理模块，可以方便的扩展各种类型的对象进行复用和管理。其中 bpool 是用来存储各类对象的构建方法，vpool 用来存放 bpool 中各个实例对象具体的值。运行时通过 bpool 里保存的构建方法来创建对应的对象通过 index 关联记录到 vpool 中，使用完后通过 sync.Pool 进行空闲对象的管理达到复用，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-mempool.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;vZBAy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;mosn-落地情况&#34;&gt;MOSN 落地情况&lt;/h3&gt;
&lt;p&gt;服务在做了 Mesh 化后，有人可能会质疑，增加一跳 Sidecar 转发是否会导致性能下降，其实不然，在蚂蚁的部分业务场景中，部分业务上了 Mesh 后，其 CPU 消耗还比之前低了，原因是之前的一些通用 SDK 能力都下沉到 Sidecar 中，并统一做了一定的优化。另一个好处是，由于 MOSN 使用 GoLang 开发，天然具备其高开发效率，所以也大大的提升了中间件相关能力的研发速度。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-practice-status.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;eO5DX&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mosn-云原生演进&#34;&gt;MOSN 云原生演进&lt;/h2&gt;
&lt;p&gt;在 MOSN 大规模落地并通过双 11 大考后，MOSN 也开始在实践的道路上进行标准化演进。并通过和 Istio 社区的合作，MOSN 实现了 xDS 的适配，可方便的实现 Istio 作为 MOSN 的控制面进行服务配置的管理。另一方面，我们也在积极参加 Istio 相关社区，并贡献了一些通用能力及问题修复的 PR。&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;0ON4N&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;could-native-架构&#34;&gt;Could Native 架构&lt;/h3&gt;
&lt;p&gt;如下图所示，最下面是基础设施层（物理机等），上层进行抽象出 Kubernetes 进行容器资源的调度和管理，再上层就是部署在容器里面的各种服务了，Istio 的能力（服务治理）就在这一层进行发挥的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./could-native-arch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;VgHHB&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;istio-简介&#34;&gt;Istio 简介&lt;/h3&gt;
&lt;p&gt;在介绍 Istio 前，先说下它为什么会出现。10 年前，一般应用都是直接部署在物理机上的，但是随着时间的推移，机型一直变化（如 CPU 核数）就出现了机型对等、环境部署以及弹性扩容等一系列问题，于是就出现了 Docker。但是 Docker 涉及到容器编排、调度、管理等问题，Kubernetes 便随之出现。Kubernetes 在容器管理领域的用途是毋庸置疑的，但是其在微服务治理方面存在一些不足，于是 Istio 便专职解决微服务治理的问题而问世。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./istio.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Istio 弥补了 Kubernetes 在服务治理上的短板，提供服务互连、流量安全、流量控制、可观测性功能。&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;TR3OR&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;mosn-和-istio&#34;&gt;MOSN 和 Istio&lt;/h3&gt;
&lt;p&gt;通过 MOSN 社区几个月的努力及推进，MOSN v0.14.0 版本可以使用 Istio 1.5.x 作为云原生控制面，从而方便的进行微服务的治理。如下是 Istio 官方在 2020 年 7 月 28 号发布了&lt;a href=&#34;https://istio.io/latest/zh/blog/2020/mosn-proxy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Istio 中使用 MOSN：另一个数据平面&lt;/a&gt;博文，即 Istio 数据平面的另一个选择 —— MOSN。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-istio-blog.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如下是 MOSN 在 Istio 1.5 版本中的架构图，MOSN 通过 xDS 协议从 Istio 动态的获取各种服务配置，从而实现服务治理的效果。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-istio-arch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 Service Mesh 领域，使用 Istio 作为控制平面已成为主流。Istio 通过 xDS 协议和数据面进行交互，因此，通过在 MOSN 中实现 xDS，我们就可以使用 Istio 作为 MOSN 的控制面。Istio 的第三方数据平面集成可以通过以下三个步骤实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现 xDS 协议，对齐数据面相关服务治理能力;&lt;/li&gt;
&lt;li&gt;使用 Istio 的脚本并设置相关 &lt;code&gt;SIDECAR&lt;/code&gt; 等参数构建 &lt;code&gt;proxyv2&lt;/code&gt; 镜像;&lt;/li&gt;
&lt;li&gt;通过 istioctl 工具并设置 proxy 相关配置指定具体的数据面;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了对应的改造方案后，于是我们成立了相关 Working Group，带领社区的同学一起进行讨论和改造。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-istio-xmind.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了对 Istio 进行改造（相关能力已经合入 Istio 官方仓库），MOSN 也需要在负载均衡、服务治理及相关框架上做一些适配和增强，其适配列表如下所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-istio-task.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;MOSN 在功能上对齐 Istio 后，就可以使用其进行微服务治理了。在使用前，我们先看看 Istio 中的 VirtualService 等相关策略是如何和 MOSN 进行关联的。如下图所示，在 Istio 中的 VirtualService 做为一个服务的转发描述，其对应到 MOSN 中就是一个 Listener 以及一组对应的路由策略 Routes。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-istio-vs.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在初步了解 MOSN 如何同 Istio 结合后，我们来看看 MOSN 在 Bookinfo 实例中可以做什么：如下是一个经典的多语言服务使用 Istio 做服务治理，在该场景中，MOSN 不仅独立的作为 Ingress Gateway，还作为 Sidecar。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-istio-bookinfo.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过 MOSN 作为 Istio 的数据平面运行 Bookinfo 事例，实现如下服务治理通用能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按 version 路由能力&lt;/li&gt;
&lt;li&gt;按照权重路由能力&lt;/li&gt;
&lt;li&gt;按照特定 header 路由能力&lt;/li&gt;
&lt;li&gt;故障注入能力&lt;/li&gt;
&lt;li&gt;服务熔断自护能力&lt;/li&gt;
&lt;li&gt;透明劫持能力&lt;/li&gt;
&lt;li&gt;超时重试机制&lt;/li&gt;
&lt;li&gt;etc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这里，你可以通过演示教程&lt;a href=&#34;https://www.katacoda.com/mosn/courses/scenarios/mosn-with-istio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《MOSN with Istio》&lt;/a&gt;来学习 MOSN 如何作为 Istio 的数据面进行服务治理。&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;OjQE8&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;开源生态建设&#34;&gt;开源生态建设&lt;/h3&gt;
&lt;p&gt;MOSN 在对接完 Istio 的同时，也和周边的开源生态进行了紧密的合作，如 Dubbo、Sentinel、Skywalking 等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MOSN With Dubbo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MOSN 中提供 Kubernes 和 非 Kubernes 体系下的 Dubbo 服务治理方案。如下图所示，方案 1 是在非 Kubernes 体系下，MOSN 通过集成 dubbo-go 支持服务的 pub/sub，并复用原有的服务注册中心。方案 2 则是在 Kubernes 体系下使用 Istio 进行一步到位的服务治理，MOSN 通过支持 Istio 下的路由策略，实现服务的治理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-dubbo.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MOSN With Sentinel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;限流是微服务治理中的一个重要功能，MOSN 通过集成 Sentinel 并复用其底层的限流能力，从而实现单机限流（令牌桶/漏桶结合）、服务熔断保护（依据服务的成功率）、自适应限流（依据机器的负载），同时目前 Istio 的限流规则也没有一个成熟的 API，我们也和 UDPA 进行了一些限流规则的规范讨论。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-sentinel.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MOSN With Skywalking&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用依赖以及服务与服务之的调用状态是微服务管理中一个重指标，MOSN 社区通过和 Skywalking 合作，把 Skywalking 的 GoLang SDK 集成到 MOSN 中，从而实现 HTTP 系调用链路拓扑展示、QPS 监控、细粒度 RT 如下图所示，同时该功能也在持续演进，接下来会支持 Dubbo Tracing。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-skywalking.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;oDMiO&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;标准化演进&#34;&gt;标准化演进&lt;/h3&gt;
&lt;p&gt;除了开源生态的适配外，MOSN 也在其标准化方面做了一些贡献（如限流、路由的 UDPA 策略提议等）。谷歌在数据面和控制面之间标准化出 UDPA 规范，微软在控制面和应用及工具层面之间标准出 SMI 规范，这所做的一切其实都是围绕“防止锁定，方便用户灵活切换”。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./smi-udpa.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可见“标准”、“规范”的重要性，当然 MOSN 社区也在其相关的标准下做了一些演进和贡献。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;云原生标准 Sidecar 的打造；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标准化参与和建设；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对第一点，MOSN 社区持续在进行 Istio 能力的对齐工作，包括 Istio 侧多 Sidecar 支持以及 MOSN 侧功能对齐 Istio，控制面方面支持注入 MOSN Sidecar、Pilot-agent 的适配以及 Istio 编译构建的适配、负载均衡算法、流量管理体系、流量检测、服务治理等。&lt;/p&gt;
&lt;p&gt;在标准化方面，我们也参与了 UDPA 相关规范讨论，并提出限流通用 API 规范讨论，社区会议讨论组织中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-udpa-flow.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;同时 MOSN 社区也积极地在和 Istio 社区进行沟通以及寻求合作，我们的目标是希望能成为 Istio 官方推荐的 Sidecar 产品，对此我们在 Istio Github 上提了相关 ISSUE，引发了比较大的关注，Istio 官方 Member 成员 @&lt;a href=&#34;https://github.com/howardjohn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;howardjohn&lt;/a&gt; 对此问题进行了非常详细的回答和探讨。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-istio-issue.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-istio-reply0.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;综合 MOSN 社区和 Istio 官方的讨论后，MOSN 社区主导并会参与 Istio 中数据面解耦的事情（比如测试集、镜像构建等），这样使得 Istio 更容易集成第三方的数据面，即 MOSN 社区的用户更方便的集成 Istio 使用。对此 MOSN with Istio 适配的 &lt;a href=&#34;https://docs.google.com/spreadsheets/d/1fALompY9nKZNImOuxQw23xtMD-5rCBrXWziJZkj76bo/edit?usp=sharing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Roadmap&lt;/a&gt; 中新增如下事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;推动 Istio 的镜像构建和数据面解耦，相关 &lt;a href=&#34;https://github.com/istio/istio/issues/24457&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Issue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;推动 Istio 的测试框架和数据面解耦，相关 &lt;a href=&#34;https://github.com/istio/istio/issues/24463&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Issue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对第一点，MOSN 社区向 Istio 贡献 PR，并已合入主干，通过该 PR 可以更方便的让 Istio 的 proxyv2 镜像集成其它数据面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-istio-pr.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;2020 年 7 月 14 号 Istio TOC（Istio 技术委员会）成员 @&lt;a href=&#34;https://github.com/rshriram&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ShriramRajagopalan&lt;/a&gt; 最新&lt;a href=&#34;https://github.com/istio/istio/issues/23753&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;回复&lt;/a&gt;： “也是支持 Istio 中支持多数据面的方案，而且也建议先把 MOSN 做为实验性第三方数据平面纳入到 Istio 的官方博客中，方便用户来试用”：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-istio-reply1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;经过 MOSN 社区不断的努力，在 7 月底，Istio 官方博客正式上线了 &lt;a href=&#34;https://istio.io/latest/zh/blog/2020/mosn-proxy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Istio 中使用 MOSN：另一个数据平面&lt;/a&gt; 博文，取到了 Istio 官方的一定认可。&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;4gtQ8&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结及展望&#34;&gt;总结及展望&lt;/h2&gt;
&lt;p&gt;从 Service Mesh 技术调研，到 MOSN 诞生并小规模试点，再到双 11 规模化落地，并走向开源到标准化演进，一路走来实属不易，这个过程中也离不开 MOSN 开源社区开发者和使用者的贡献与支持。&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;wKWi1&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;合作伙伴及用户&#34;&gt;合作伙伴及用户&lt;/h3&gt;
&lt;p&gt;秉着借力开源，反哺开源的思想，MOSN 社区在众多的合作伙伴的共同努力下，在实践的道路上，一步步的走向标准化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-community-status.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a name=&#34;hvSiX&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;总结及未来展望&#34;&gt;总结及未来展望&lt;/h3&gt;
&lt;p&gt;接下来，MOSN 社区不仅会持续兼容适配新版本的 Istio 的功能，而且还将在以下几个方面进行发力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可编程，如支持面向业务层的 DSL，可方便的控制请求的处理流程，另外也会在 WASM 上进行预研；&lt;/li&gt;
&lt;li&gt;Dapr 模式作为微服务运行时，使得面向 MOSN 编程的服务更轻、更小、启动速度更快；&lt;/li&gt;
&lt;li&gt;被集成，遵循 UDPA 规范，可方便的被 Istio、Kuma 集成，另外 MOSN 里面的通用工具链剥离为 package，方便其它 GoLang 项目复用；&lt;/li&gt;
&lt;li&gt;更多场景 Mesh 化方案支持，Cache Mesh/Message Mesh/Block-chain Mesh 等；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MOSN 是一个开源项目，社区中的任何人都可以使用，参与和改进。我们希望您能加入社区！可以通过&lt;a href=&#34;https://github.com/mosn/community&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;介绍的几种方式了解 MOSN 正在做的事情并参与其中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MOSN 官网      &lt;a href=&#34;http://mosn.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http&lt;/a&gt;&lt;a href=&#34;http://mosn.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;://&lt;/a&gt;&lt;a href=&#34;http://mosn.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mosn.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MOSN Github    &lt;a href=&#34;http://github.com/mosn/mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http&lt;/a&gt;&lt;a href=&#34;http://github.com/mosn/mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;://&lt;/a&gt;&lt;a href=&#34;http://github.com/mosn/mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;github.com/mosn/mosn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Service Mesh   &lt;a href=&#34;https://www.servicemesher.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https&lt;/a&gt;&lt;a href=&#34;https://www.servicemesher.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;://&lt;/a&gt;&lt;a href=&#34;https://www.servicemesher.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;www.servicemesher.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;欢迎加入 MOSN 开源交流群&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./mosn-dingtalk.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Webinar #1</title>
      <link>https://cloudnativecn.com/blog/service-mesh-webinar-1/</link>
      <pubDate>Mon, 18 May 2020 20:12:18 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/service-mesh-webinar-1/</guid>
      <description>&lt;p&gt;Service Mesh Webinar 是由 ServiceMesher 社区和 CNCF 联合发起的线上直播活动，活动将不定期举行，邀请社区成员为大家带来 Service Mesh 领域的知识和实践分享。&lt;/p&gt;
&lt;p&gt;Service Mesh Webinar#1，邀请多点生活平台架构组研发工程师陈鹏，带来分享《多点生活在 Service Mesh 上的实践——Istio + MOSN 在 Dubbo 场景下的探索之路》。&lt;/p&gt;
&lt;p&gt;随着多点生活的业务发展，传统微服务架构的面临升级困难的问题。在云原生的环境下，Service Mesh 能给我们带来什么好处。如何使用社区解决方案兼容现有业务场景，落地成符合自己的 Service Mesh 成为一个难点。服务之间主要通过 Dubbo 交互，本次分享将探索 Istio + MOSN 在 Dubbo 场景下的改造方案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直播时间：2020 年 5 月 28 日（周四）20:00-21:00&lt;/li&gt;
&lt;li&gt;直播地址：&lt;a href=&#34;https://live.bilibili.com/21954520&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://live.bilibili.com/21954520&lt;/a&gt;（欢迎关注直播间）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分享主题&#34;&gt;分享主题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;《多点生活在 Service Mesh 上的实践——Istio + MOSN 在 Dubbo 场景下的探索之路》&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;分享嘉宾&#34;&gt;分享嘉宾&lt;/h2&gt;
&lt;p&gt;陈鹏，多点生活平台架构组研发工程师，开源项目与云原生爱好者，有多年的网上商城、支付系统相关开发经验，2019 年至今从事云原生和 Service Mesh 相关开发工作。&lt;/p&gt;
&lt;h2 id=&#34;详情&#34;&gt;详情&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解决思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 MCP、Pilot、xDS、MOSN 技术，对 Service Mesh 的可切入点分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合现有业务场景和可切入点，明确需要修改的场景，制定符合自己业务场景的 Service Mesh 落地方案，介绍多点生活在 Dubbo 案例的探索及改造方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大纲：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统微服务架构与 Service Mesh 架构
&lt;ul&gt;
&lt;li&gt;传统微服务架构在多点遇到的痛点&lt;/li&gt;
&lt;li&gt;Service Mesh 架构能带来的福利&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Istio 技术点介绍&lt;/li&gt;
&lt;li&gt;在 Dubbo 场景下的改造分析
&lt;ul&gt;
&lt;li&gt;对比 MOSN 和 Envoy 对现有场景的支持&lt;/li&gt;
&lt;li&gt;Istio+MOSN 和 Istio+Envoy 在 Dubbo 场景下如何改造&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MOSN + Istio 具体实现探索
&lt;ul&gt;
&lt;li&gt;MOSN 配置文件介绍、从一个流量进来到转发到具体的远端的流程分析&lt;/li&gt;
&lt;li&gt;Provider 配置信息如何下发到 Sidecar&lt;/li&gt;
&lt;li&gt;从多点现在的实际场景对现有的 Dubbo 改造方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Demo 演示&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服开源的 Service Mesh Sidecar 代理 SOFAMosn 发布 0.4.0 版本</title>
      <link>https://cloudnativecn.com/blog/sofa-mosn-0-4-0-changelog/</link>
      <pubDate>Mon, 17 Dec 2018 11:07:07 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/sofa-mosn-0-4-0-changelog/</guid>
      <description>&lt;p&gt;SOFAMosn 几个月前由蚂蚁金服开源，使用 Go 语言实现，遵循 Envoy xDS 协议，既可以单独作为网络代理使用，也可以作为 Istio/SOFAMesh 中的数据平面 Sidecar 代理。开源地址：https://github.com/alipay/sofa-mosn&lt;/p&gt;
&lt;h2 id=&#34;http-协议优化&#34;&gt;HTTP 协议优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;性能优化：HTTP/1.x 性能提升 30%，HTTP/2.0 性能提升 100%&lt;/li&gt;
&lt;li&gt;IO、流处理接入 MOSN 自研框架，统一架构，并支持 metrics 收集等基础能力&lt;/li&gt;
&lt;li&gt;支持HTTP/1.x、HTTP/2.0协议自动识别&lt;/li&gt;
&lt;li&gt;支持 GRPC&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;流量路由--管理&#34;&gt;流量路由 &amp;amp; 管理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;完善故障注入机制，支持基于路由匹配、后端匹配的延迟、错误响应异常注入&lt;/li&gt;
&lt;li&gt;支持 HTTP 请求 direct response 路由机制&lt;/li&gt;
&lt;li&gt;支持对 HTTP 请求添加自定义 Headers，支持删除指定 Headers&lt;/li&gt;
&lt;li&gt;支持重写 HTTP 请求中 Host、URI&lt;/li&gt;
&lt;li&gt;支持基于计数的失败重试机制&lt;/li&gt;
&lt;li&gt;支持基于 QPS、基于速率限流&lt;/li&gt;
&lt;li&gt;完善 TCP 转发功能，支持灵活的转发特性配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;遥感&#34;&gt;遥感&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;支持对接Mixer上报请求/响应的基本信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;扩展性&#34;&gt;扩展性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;重构、优化协议处理引擎&lt;/li&gt;
&lt;li&gt;支持可扩展的链式路由机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;支持基于 RCU 思路的动态配置更新机制&lt;/li&gt;
&lt;li&gt;新增 MOSN 的管理 API，支持动态修改日志级别，获取运行时生效配置&lt;/li&gt;
&lt;li&gt;支持 RPC 的 Tracing&lt;/li&gt;
&lt;li&gt;修复了一些 bug&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服 Service Mesh 新型网络代理的思考与实践</title>
      <link>https://cloudnativecn.com/blog/microservice-with-service-mesh-at-ant-financial/</link>
      <pubDate>Tue, 04 Dec 2018 17:32:44 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/microservice-with-service-mesh-at-ant-financial/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(136, 136, 136)&#34;&gt;&lt;strong&gt;朵晓东&lt;/strong&gt;&lt;/span&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(62, 58, 57)&#34;&gt;，&lt;/span&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(62, 58, 57)&#34;&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(49, 70, 89)&#34;&gt;花名奕杉，蚂蚁金服高级技术专家。专注企业云计算技术及产品，蚂蚁金融云 PaaS 创始团队核心成员，Antstack 网络产品负责人。开源爱好者，Apache Kylin 创始团队核心成员；SOFAMesh 创始团队核心成员，SOFAMosn 项目负责人。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(62, 58, 57)&#34;&gt;本文根据晓东在 GIAC 上海站的&lt;/span&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(25, 31, 37)&#34;&gt;演讲内容整理&lt;/span&gt;&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(62, 58, 57)&#34;&gt;，完整的分享 PPT 获取方式见文章底部。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng--left--720x4811881188118812&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2018/png/156645/1543544928743-c397c665-a542-490e-9a13-9ccf4b468d5f.png&#34; alt=&#34;image.png | left | 720x481.1881188118812&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png | left | 720x481.1881188118812
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，我是蚂蚁金服系统部的高级技术专家奕杉，今天分享的内容是：《蚂蚁金服在 ServiceMesh 推进落地过程中对新型网络代理的思考和实践》&lt;/p&gt;
&lt;h2 id=&#34;内容结构&#34;&gt;内容结构：&lt;/h2&gt;
&lt;p&gt;主要的分享顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;背景概述&lt;/li&gt;
&lt;li&gt;架构设计及功能特性&lt;/li&gt;
&lt;li&gt;技术案例&lt;/li&gt;
&lt;li&gt;总结展望&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1背景概览&#34;&gt;1、背景、概览：&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218438360-fd1bb4df-7b7f-45b1-a84e-b124fad9eebd.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;ServiceMesh 作为云原生之上的服务网格技术在今年引起了业界的广泛关注，首先我们来看一下目前 ServiceMesh 数据平面的一些方案。&lt;/p&gt;
&lt;p&gt;最为大家熟知的是老牌七层代理 Nginx 和 ISTIO 原生的数据平面 Envoy。Nginx 早已在国内外广泛使用，近两年积极探索 K8S、ServiceMesh 微服务场景，并推出了与  ISTIO 集成的微服务解决方案，试图扩展其场景边界，拿下新的领域，从单纯的 7 层流量代理到云原生时代的智能数据平面转型。但目前看“NgMesh”研发不够活跃，已知的使用方也不多。Envoy 作为 Google 和 Lyft 联合开发的 ISTIO 原生数据平面产品，近两年借助 ServiceMesh 微服务场景快速打开了市场，并在一些互联网公司推广使用，同时引入了一批开发者进行 API 网关等功能网关的开发，发展势头非常好。&lt;/p&gt;
&lt;p&gt;其次 LINKERD 是基于 Rust 的一种高性能数据平面，但其发展空间受到了 Envoy 挤压，业界使用的公司也比较有限。&lt;/p&gt;
&lt;p&gt;蚂蚁金服基于自身诉求自研了基于 Golang 的数据平面 SOFAMosn（后简称 MOSN），并在蚂蚁、UC 等公司落地使用。&lt;/p&gt;
&lt;p&gt;同时对业界开源，提供了一种新的数据平面产品选择。&lt;/p&gt;
&lt;p&gt;此外国内的华为、新浪等公司都基于自身场景提出了数据平面方案并先后进行了开源，数据平面竞争已经从独霸业界的基于 Nginx 二开方案逐步转变为目前的多样化产品同场竞技的局面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218443233-7b74f903-c3e6-4bf4-b5c5-b56d427cc9f0.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么众多大厂纷纷投入研发数据平面呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我个人认为新生技术栈、云原生、微服务快速发展等契机对数据平面提出了场景多样化、功能服务化、云原生亲和等多重挑战。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以往从未像现在这样对数据平面提出过如此多的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据平面需要执行部署运维中的流量切换；&lt;/li&gt;
&lt;li&gt;需要提供云亲和的细粒度流量调度功能；&lt;/li&gt;
&lt;li&gt;需要提供微服务亲和的服务发现、路由组网特性；&lt;/li&gt;
&lt;li&gt;需要以云原生的方式感知资源；&lt;/li&gt;
&lt;li&gt;需要支撑服务粒度、高度自定义的压测、故障测试、线上灰度流量管理；&lt;/li&gt;
&lt;li&gt;需要提供链路级、服务级的安全隔离保护，需要支持多种语言、多种协议的转换分发能力；&lt;/li&gt;
&lt;li&gt;需要能享受系统层面、硬件层面的红利；&lt;/li&gt;
&lt;li&gt;需要为复杂的运维架构（如蚂蚁的 LDC 等）提供可扩展的流量调拨能力等等；&lt;/li&gt;
&lt;li&gt;当然根据每个公司的业务场景可能还有其他的因素。
最后，如何要将这些能力都汇聚在统一的数据平面产品上，弥合南北向、东西向数据平面由于技术栈、团队等差异带来的鸿沟，变成了另一个更为复杂的问题。这里所提到的问题中任何一点扩展开来都可以是一个丰富独立的 Topic，受限于篇幅本次分享只能介绍我们在解决这些问题中的一小部分思考和实践。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2sofamesh-架构--重点特性&#34;&gt;2、SOFAMesh 架构 &amp;amp; 重点特性&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218452941-9329810d-b6a7-484e-a493-a549c70a6181.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先，蚂蚁已经将基于 ISTIO 的 ServiceMesh 方案 &amp;ldquo;SOFAMesh&amp;rdquo; 开源，在控制面我们选择克隆 ISTIO 官方版本并研发符合蚂蚁需求的控制面，在数据面我们选择使用 Golang 研发数据平面 MOSN，目前已经支持了微服务场景所需的大量常用功能。&lt;/p&gt;
&lt;p&gt;这里我根据 ISTIO 的 Task 文档总结了目前 SOFAMesh 支持的一些能力，如：透明拦截适配，细粒度的流控，故障注入，双向链路加密等。对于一些暂时存疑的功能，如 Mixer Check 等，暂时没有支持。目前 SOFAMesh 已在 UC 生产环境落地使用，满足了 Sidecar、Ingress、Egress 多种场景的使用需求。在这里附上  SOFAMesh，SOFAMosn 的 Github 地址，也欢迎大家使用交流。
SOFAMesh：&lt;a href=&#34;https://github.com/alipay/sofa-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/alipay/sofa-mesh&lt;/a&gt;
SOFAMosn：&lt;a href=&#34;https://github.com/alipay/sofa-mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/alipay/sofa-mosn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218458578-9f7bd036-eb1d-489a-bbb8-5c40031def35.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;再来看看蚂蚁内部，由于目前蚂蚁生产环境尚未大量铺开 K8S，并且已经存在一套完善的管控技术体系，加上目前 ISTIO 的性能和稳定性还不满足大规模微服务场景等原因，我们暂时没有选择直接升级到 ISTIO，而是通过优先落地 Sidecar 的方式来赢得 ServiceMesh 解决方案带来的红利。在蚂蚁内部，MOSN 接管了 SOFABoot 应用，代理了服务发现、路由/负载均衡、通信等工作，构成了微服务网格，通过自有的中间件及管控平面进行微服务的管理、治理。同时，我们积极的推进 MOSN 与  SOFA 中间件，网络接入层，安全防护及监控体系的整合，以提供更统一更强大的数据平面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218465864-1a4c61d2-6b0e-45b8-8252-a49d0409bd6e.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来我将介绍 MOSN 支持多协议的方案。&lt;/p&gt;
&lt;p&gt;为了在内部快速落地试错，我们首先支持了内部使用最广泛的 SOFARPC 协议，并对其进行了深度优化。随后我们根据 UC Mesh 化推进遇到的普遍问题提出了 XProtocol 方案，以在不解包的场景下提供路由能力。最后我们深度改造了三方 HTTP/1.1 实现及官方 HTTP/2.0 实现。到目前为止，MOSN 已提供了多种协议的支持。同时 MOSN 提供了两种自定义协议的能力支持使用者通过扩展的方式自定义协议实现，满足需要解包、不需要解包的协议扩展需求。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218470502-0ddf8529-a953-4f5b-a19d-0c8e0940934d.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除协议之外，性能是大家比较关心的另一个问题。为了提供满足生产要求的 7 层转发性能，我们在 IO、协议、内存、协程、网络处理等方面进行了优化，从目前通过 SOFARPC 通信应用的上线情况来看可以满足生产使用要求，在案例分析中我将展示一些性能数据，后续我们也将继续推进性能优化，以达到更好的性能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218475631-74f2953b-9687-4269-bc2f-429f80247dbe.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在安全能力上，SOFAMesh 支持 mTLS，并在蚂蚁内部集成蚂蚁内部的 KMS 完成了 mTLS 落地，同时 RBAC 功能在研发中，此外 WAF、流量镜像能功能也在规划中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218480670-4d7ace4c-7eac-40a7-9a9d-6143c02ddb4e.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在蚂蚁内部基于 MOSN 的网关产品正在研发中，将会在稳定验证后开源。网关场景相对于 Sidecar 场景有一些特性需求，比如说一般会 Hold 住大量长链接，比如说会根据请求内容动态选择后端应用，由于网关可能代理了不同的后端应用，就会需要动态选择后端协议。此外还有一些网关类的通用能力需求，如签名，授权，限流等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218485802-9e65b38f-40fa-4feb-9563-ba068c8da594.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了能基于开源版建设蚂蚁内部的 Sidecar 及网关产品，我们充分考虑了开源版 MOSN 的扩展性，在路由、后端管理、TLS、网络、流处理等各方面提供了扩展性支持。对于其他使用 MOSN 的场景，也可以通过类似的方式来满足自身业务定制需求。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218492236-d4608e03-9513-4267-9067-46276b86c093.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218496748-cd4ed37c-c654-4f3d-ba1b-f0631c268588.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218501467-8d454bcd-9f6b-4803-8fed-fcfd0e692020.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218505963-16adc24e-25b9-4dfa-a481-a5916133664d.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218511973-3e79c724-03b8-43b8-8a01-b994f5a017b9.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了更清晰的展示 MOSN 功能特性，这里将 MOSN 0.4.0 的功能特性通过表格的方式展示出来。可以说 0.4.0 版本已经初步具备了生产所需的大部分功能点，支持云原生场景下的多协议、路由&amp;amp;LB、后端管理、TLS、遥感监测、XDS 对接等功能，并充分优化了性能，目前已经在蚂蚁、UC 生产环境进行了验证。同时在蚂蚁内部我们通过扩展的方式支持了&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(25, 31, 37)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;灰度路由、&lt;/span&gt;&lt;/span&gt; LDC 路由、弹性路由，支持了配置中心等定制需求。后续我们会继续完善功能点，如果有发现未支持的功能可以在 Github 给我们提 Issue，或者直接加入我们 commit code。由于 MOSN 在扩展性上提供了比较好的能力支持，在特定的场景都可以通过扩展的方式来满足需求。&lt;/p&gt;
&lt;h2 id=&#34;3技术案例解析&#34;&gt;3、技术案例解析&lt;/h2&gt;
&lt;p&gt;在介绍了架构、功能特性以后，我将介绍一些落地过程中的技术案例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218522468-7fa7d941-96ee-42e5-afcf-0b1f63ba0c51.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先我们来看在蚂蚁在非 K8S 场景下将 MOSN 作为 Sidecar 接入应用的姿势。
在我们推进落地初期，需要接入 MOSN 的 SOA 应用还没有通过原生 K8S 的方式运行起来，服务发现是基于典型的服务发现中间件来做，也没有直接使用 ISTIO 来落地。在这种情况下，我们通过扩展开源版 MOSN 支持服务发现，将 MOSN 作为服务代理，由其完成服务 Pub/Sub，并代理服务完成 RPC 通信。这里有几个要点，首先由于内核限制我们没有第一时间使用 Iptables 拦截请求，而是通过升级 SOFA 的方式来支持应用切换访问地址，这里需要应用方升级 SOFA 依赖，但不需要改业务代码。&lt;/p&gt;
&lt;p&gt;其次，我们通过扩展开源版服务发现实现的方式支持从蚂蚁配置中心获取后端服务列表。在路由生成上，MOSN 基于完善的服务间依赖关系生成服务路由，由于 SOFA 应用在编码阶段已明确定义了服务依赖并在服务启动时由 MOSN 代理完成 Pub/Sub，MOSN 感知所需的服务依赖关系，并动态生成了出向/入向路由。如果你的使用场景服务之间没有明确的依赖关系，则需要扩展路由机制支持基于完全请求内容的动态路由机制。其次，SOFA 服务寻址基于明确的 id:version 信息，所以这样的服务发现、路由方案同时也适用于类似的 SOA 服务，同时也可以支持标准微服务寻址。这样的扩展方式可以实现基于服务发现中间件的非 K8S 的 Sidecar 注入，来享受 Mesh 思路落地的便利。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218528415-f554183c-9756-43d5-94e6-88bda76fb9b5.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了通过以上方式支持 SOA 化服务外，__SOFAMesh 标准方案提供了一种基于 DNS 的寻址方案，__以在不修改应用的情况下支持标准微服务寻址。
首先通过 DNS 将服务名转化为 IP，同时在 MOSN 路由的 Virtual Host 中配置服务 IP，以及与后端的匹配关系。Client 请求被 Iptables 拦截并转发给 MOSN，MOSN 在处理请求时通过 Tcp Option 的 Original Destination 项拿到目标 IP，并作为 Host 与 Virtual Host 匹配寻址到 Cluster 并做后端 LB 及转发。这样在不进行微服务化改造的情况下就可以进行服务名完成寻址通信了。这里更多细节可以参考敖小剑老师写的 XProtocol 完整&lt;a href=&#34;https://yq.aliyun.com/articles/650936&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;方案&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218533752-5a8d4702-2360-4de0-b636-9d6647849c65.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来我们一起分析另一个在生产环境非常有用的特性，无损平滑升级。
大部分 7 层流量代理，包括 Nginx、Envoy 等，在升级过程中通常会让老进程静默等待一段时间后再退出、或等待时机由新进程控制退出，通过这种方式来保证老进程不再处理到请求。这种方式对于 HTTP/1.x 短链接是比较有用的，但对于 HTTP/1.1长链接、RPC 长链接最终不得不通过暴力断链的方式让 Client 重连、重试，对业务是有一定影响的。凡会造成业务抖动一般都会造成业务方紧张，这会导致新功能升级推动困难。针对这个问题，MOSN 提出了自己的解决方案，在升级过程中无损迁移存量链接，目前支持 HTTP/1.1、无状态 RPC、TLS，后续将基于 Goaway 帧支持 HTTP/2.0。下面我们来看看MOSN 是怎么实现这样能力的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218539299-6752b969-ff5e-4a05-b603-984def368d41.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里我把典型场景抽象成 Client 请求处理和 Server 回复处理两部分，我们先来看看 Client 请求处理。在升级阶段，同时存在新老两个 MOSN 进程，此时可能存在 Client 正在访问老进程的情况，此时老进程会通过 Domian Socket 将 &lt;span data-type=&#34;color&#34; style=&#34;color:rgb(38, 38, 38)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;TCP1 的 FD 及链接状态数据&lt;/span&gt;&lt;/span&gt;传递给新进程，由新进程&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(38, 38, 38)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;创建 TCP3 链接&lt;/span&gt;&lt;/span&gt;并将数据发送到后端 Server 并接收 Server 响应，新进程在收到响应后不再转发给老进程，直接转发给 Client 完成本次请求。此后老进程退出 &lt;span data-type=&#34;color&#34; style=&#34;color:rgb(38, 38, 38)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;Read 流程，不再接受该 TCP1 连接上的数据，同时新进程开始 Read 流程，接受该 TCP1 连接上的数据，完成 Reload 过程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218544265-94ef075e-e737-49c5-9f29-509ae5d57369.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;再来看看第二种情况，在第一步链接迁移完成后仍然可能出现 Server  通过 TCP2 将残留响应发送到老进程的情况，此时老进程会通过 Domian Socket 将请求数据传递给新进程，由新进程回复到 Client。这样就避免了两个 MOSN 进程同时写到 Client 造成乱序的问题。延伸一下，未来基于这样的思考可以与容器 fork 结合提供容器、Pod 层面的无损迁移方案。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218550949-a623f6d9-7082-4c57-a917-34dc4b4760d5.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在迁移过程中我们发现，对于无状态的 HTTP/1.1 长链接，RPC 长链接迁移较为简单，但对于有多回合握手的 TLS 迁移则比较麻烦，这里主要涉及到 TLS 的状态数据迁移，如&lt;span data-type=&#34;color&#34; style=&#34;color:rgb(38, 38, 38)&#34;&gt;&lt;span data-type=&#34;background&#34; style=&#34;background-color:rgb(255, 255, 255)&#34;&gt;加密秘钥，Seq 序列，读缓存数据，Cipher 类型等状态数据都需要做特殊的处理以保证迁移过程不会破坏握手过程。此外，MOSN 还支持对请求链接做明、密文检测，来保证上游可以灰度的开启链路加密。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218555173-754e294d-96e7-4f98-b87a-be20d6e8625e.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我将介绍一下我们在性能优化方面的一些实践。数据来源于 2018 年 8 月份的 0.2.1 开源版。
先介绍一下在 Sidecar 模式下的性能数据，测试场景是一个典型的服务间通信场景，服务 A 通过 MOSN 访问服务 B。这里选用的机型是蚂蚁内部的测试机器。我们测试的场景包括了  SOFARPC、HTTP/1.1、HTTP/2.0 三种协议，测试的工具分别是蚂蚁内部的压测平台、ab、h2load，其中 HTTP/2.0 压测 5 条链接的场景，并且是 H2C，无 TLS 加密。数据场景是 1K 的请求、响应。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218559351-a0af582a-e7a9-4786-9bd5-6ff4bbc38d45.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们来看一下测试结果，可以看到 SOFARPC 性能远好于其他两个协议。需要说明的是，HTTP/1.1 在 0.2.1 版本中直接使用了开源的 FastHTTP，MOSN 没有接管 IO 处理，协议解析等工作，未做任何优化；HTTP/2.0 直接使用了官方实现，MOSN 没有接管 IO 处理，协议解析等工作，未做任何优化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218563811-b588d066-772e-4815-9c54-645552f18d09.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 SOFARPC 的优化上我们从 IO，协议到上层处理做了不少优化，这里简单介绍一些优化经验。首先分享一个踩过的坑，在基于 Golang Connection API 编写读数据代码时，一个常用的方式是通过 SetReadDeadline 来设置读超时，我们发现在读超时很短的情况下，在 2.6.2 内核会比 4.13.0 内核性能下降 30%，而通过绑核可以解决此问题。此外，有很多有用的手段可以用来优化性能，比如说读合并减少协议处理次数，writev 减少系统调用写的次数可以有效提升整体吞吐量。我们通过对比 Golang 和 OS 的 perf 数据发现 Golang 系统调用耗时比 OS 系统调用耗时要多（原因还需要进一步明确），减少 Golang 系统调度总是有效的优化手段。在内存优化方案，首先可以尽量减少内存入堆，对于 100K 以下的内存入栈比入堆更快，并且不会影响 GC，对于不得不入堆的内存，可以通过有效的内存回收复用减少内存创建，减少 GC 压力。其次，在可控的范围内池化协议可以减少 Golang runtime 调度，并减少为了 Golang 为了保证连续栈而调用 morestack 造成的开销。对于单核的场景，需要关注协程数量及协程使用率，避免协程饥饿的情况。对于 perf 发现的热点，需要有针对性的进行优化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218567975-bb82422c-f9b4-4e65-b8a1-f75aa9ea2299.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来看看网关的场景，Client 通过 MOSN 访问 Server，测试条件与单核类似，不过没有限制 MOSN 的 P，也没有绑核。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218573591-604a2ef8-6d26-4a70-b964-6602a0933b03.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从实验结果上看，SOFARPC，HTTP/1.1 的结果基本在预期内，但 HTTP/2.0 性能远低于预期。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218583099-2b7d3d27-4ce1-4fb2-9d60-4e91675ae25d.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们看到 Golang 官方的 HTTP/2.0 实现在多核场景下性能不佳，在 0.4.0 中对官方 HTTP/2.0 进行了性能优化，我们将在 0.4.0 正式发布后更新性能数据。在多核场景下我们仍然选择了单进程模型，根据连接数、负载等变化可以压到 4-8 核。我们也尝试了多进程绑核+reuse port 的方案，多核吞吐量高于单进程 15% 以上，但从容器的适配性，进程模型简单等角度考虑我们仍然选择了单进程模型。在多核场景下需要特别关注全局锁的性能和 IO 的优化，这也是官方 Golang HTTP/2.0 实现性能不佳的重要原因。此外，需要在压测时关注 G 是否频繁切换，P 是否有饥饿等问题，有针对性的进行多核性能优化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218587543-7fecc16f-8a8c-4495-9f8b-f2c9c64ce894.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们再来看看长链接的模式，在这种模式下会有大量链接，但不会出现同时有大量流量的情况。MOSN 针对这种场景提供了基于 NetPoll 的使用模式，我们重点压测了在 10K 链接场景下 SOFARPC 的性能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218592084-9d0ed763-f275-4cf5-a1a8-ed48a3c444ec.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从压测结果上可以看看到，基于 Raw Epoll 的 NetPoll 模式在资源消耗上明显少于原生 Golang IO 的模式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218598786-a27aa543-967c-49ec-b4f8-a0765b53e5bf.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从结果上看，原生  IO 模式还无法高性能的满足 C10K  场景的要求，针对高性能网关场景还是需要通过更有针对性的方案来支持。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218603100-d08d0a74-86a7-4d27-921d-dea4ee8f45c7.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我将介绍 TLS 性能数据，这里通过 Nginx+OpenSSL，Caddy，Caddy+BoringSSL 三种实现来测试 SSL 处理的性能数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218606522-539145be-913f-49c3-a3c4-8a94db917157.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从测试结果可以看到，对于 RSA 加密，使用了 Golang 原生支持的 Caddy 性能明显弱与 OpenSSL 及 Caddy+BoringSSL，但对于 ECDSA 来说 Caddy 弱于 OpenSSL，但明显略好于通过 cgo 调用 BoringSSL 的方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218610013-d5ceba6c-eb5b-455a-95e2-0b9d9e1f01a6.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过进一步分析发现，Golang 对 RSA 的实现是基于 Golang 的，但对 ECDSA 等现代加密算法有汇编优化，比如说对 p256 的一些重点实现方法是移植了 OpenSSL 实现。同时 Golang 对 AES-GCM，SHA，MD 等算法都有汇编优化。如果你需要使用的算法正好在 Golang 的优化范围内，那么完全可以直接使用 Golang 原生实现，可以省去对接 OpenSSL、BoringSSL 的麻烦。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218613994-4ba290e3-8237-4640-8360-71a08e0b23be.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最终总结一些性能优化的结果，到目前为止，在 SOFARPC 协议上对 0.1.0 版本 QPS 提升了 50%，内存使用减少了 40%；HTTP/2.0 经过一轮优化，QPS 提升了一倍，后续会继续推进优化；HTTP/1.1 也有 30%  以上的性能提升。&lt;/p&gt;
&lt;p&gt;此外，Golang 性能优化与 C/C++ 还是有比较大的区别，在 C/C++ 优化过程中，重点观察系统 perf 进行优化，但 Golang 的话需要既需要了解、观察 Golang runtime 的 perf、调度数据，也需要观察 OS 层面 的 perf 数据，并且需要进行结合分析。一些 C/C++ 常用的方式在 Golang 也无法直接使用，比如说在 C 中做无锁替换经常通过整块内存替换指针的方式来保证原子性，但在 Golang 里指针替换并不是原子的，如果分析汇编会发现实际上执行了多条汇编，在实现层面就需要一些特殊的处理。&lt;/p&gt;
&lt;p&gt;由于 Golang 从编译到运行时，从运行单元到系统调用都是一个非常独立并且自包含的体系，他并没有基于 C  的开发套件建立，可以说是非常自成一体了，所以在系统层面的集成上仍然有不少问题需要克服，比如说 cgo  性能，但是由于他的优点也是非常明显的，可以在更多系统软件场景去探索挖掘，完善实现，建立出基于 Golang 世界的系统软件体系。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218618062-dfebd151-3d05-4cb5-b61c-e3cceeef9b37.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，在解决具体问题的过程中我们积累了不少有值得分享的案例，比如说在大流量场景下动态更新存量链接的配置风险策略，Metrics 平滑迁移，支持多层路由判断的可扩展链式路由等，受限于篇幅无法一一展开，后续我们将通过 blog 或 meetup 的方式与大家分享。&lt;/p&gt;
&lt;h2 id=&#34;4总结--展望&#34;&gt;4、总结 &amp;amp; 展望&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218626784-cec880b1-1ccd-447f-8cc6-96302681fd23.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们再看看微服务场景下 SOFAMosn 落地的方案，首先 SOFAMosn 作为 Sidecar 与 SOFABoot APP 融合代理服务、通信、配置等功能，与蚂蚁的 Control Plane 通信完成服务配置更新。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218632502-24c5e08f-cee2-48ae-a27d-744388ef0c7a.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们再从整体视角看看 MOSN、MOSNG 在蚂蚁架构中的位置。MOSN 作为蚂蚁全新的数据平面，会贯穿网络接入、微服务、安全、Serverless 等场景的落地中。我们将推进东西向，南北向技术架构的融合，形成统一的负载网络。在安全方向上，我们将会在微服务级别的安全保障上做更细致的工作，从 2、3、4、7 层做更多的安全隔离工作，例如做到微服务粒度的流量拦截、牵引。在 Serverless 场景，MOSN 将作为 Serving 的前置提供服务。最后 MOSN 将积极地与用户态加速技术，7 层流量拦截服务等基础能力集成，更好的服务于统一负载网络。
从蚂蚁技术栈演进的视角看，在下一代微服务架构、下一代接入网络、零可信微隔离的技术发展的萌芽之下，MOSN 的出现是必然也是偶然，最终将成为新生技术体系落地过程的重点环节，我们将继续探索，逐步形成适合蚂蚁业务场景的数据平面。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image--left&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/lark/0/2018/png/1273/1543218637610-ec08e4e0-420c-4f1f-af82-264c87076597.png&#34; alt=&#34;image | left&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image | left
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我今天要介绍的内容就是这些，欢迎大家关注“金融级分布式架构”，“ServiceMesher”公众号，我们将会有更多技术干货发布在公众号中。同时这里有 SOFAMesh、SOFAMosn 的 Github 地址，欢迎大家 star，或试用，更欢迎大家为我们提出宝贵意见。谢谢大家。
地址：
SOFAMesh: &lt;a href=&#34;https://github.com/alipay/sofa-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/alipay/sofa-mesh&lt;/a&gt;
SOFAMosn: &lt;a href=&#34;https://github.com/alipay/sofa-mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/alipay/sofa-mosn&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ppt-下载&#34;&gt;PPT 下载&lt;/h2&gt;
&lt;p&gt;地址：
&lt;a href=&#34;http://www.sofastack.tech/posts/2018-12-04-01&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.sofastack.tech/posts/2018-12-04-01&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng--left--720x4811881188118812&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2018/png/156645/1543544969503-0a284b24-0a6f-4ff2-9706-093c0cc5cf6b.png&#34; alt=&#34;image.png | left | 720x481.1881188118812&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png | left | 720x481.1881188118812
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服 Service Mesh 渐进式迁移方案</title>
      <link>https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/</link>
      <pubDate>Thu, 29 Nov 2018 14:51:19 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxs8jrwxj30qo0f0dip_hu17553668643899856407.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxs8jrwxj30qo0f0dip_hu411382949100802592.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxs8jrwxj30qo0f0dip_hu9979890587344167898.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxs8jrwxj30qo0f0dip_hu17553668643899856407.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，今天给大家带来的演讲主题是“蚂蚁金服 Service Mesh 渐进式迁移方案”，给大家介绍一下我们蚂蚁金服主站的 Service Mesh 迁移方案，在稍后的内容中我会给大家解释什么是“渐进式”。今天的演讲方式有些特殊，将会是两位讲师合作。我是敖小剑，来自蚂蚁金服中间件团队，另外一位讲师 龙轼，来自 UC 基础研发部。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsexhquj30qo0f0n08_hu17555212753722404249.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsexhquj30qo0f0n08_hu7714013156176249215.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsexhquj30qo0f0n08_hu12313227577358218666.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsexhquj30qo0f0n08_hu17555212753722404249.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今天的内容将会有四块主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Service Mesh 演进路线：介绍蚂蚁金服计划在主站落地 Service Mesh 的方案，由于涉及到大量的存量应用和超大规模，又要保证迁移过程的平滑，因此我们的落地方案相比社区方案要复杂的多。&lt;/li&gt;
&lt;li&gt;实现平滑迁移的关键：介绍在整个迁移方案中，为了实现平滑迁移的几个关键做法，然后今天我们将详细展开其他的一个关键点：DNS 寻址方案。&lt;/li&gt;
&lt;li&gt;DNS 寻址方案的演进：详细介绍 Kubernetes/Istio/SOFAMesh 一路演进过来的 DNS 寻址方式&lt;/li&gt;
&lt;li&gt;DNS 寻址方案的后续规划：介绍我们在 DNS 寻址方案上的后续规划&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前两块内容将由我来为大家介绍，后两块内容将由我的同事 龙轼 为大家介绍。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsiq2z5j30qo0f0grx_hu840852982728901205.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsiq2z5j30qo0f0grx_hu17013214260153466786.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsiq2z5j30qo0f0grx_hu17194587617102522325.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsiq2z5j30qo0f0grx_hu840852982728901205.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在展开内容之前，先看一下背景，Service Mesh 在蚂蚁金服主站落地的背景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标：需要满足我们对长期目标的认可，具体指服务间通讯走 Service Mesh，而且是 Istio 这种带完整的控制平面的 Service Mesh 形态，基础设施要构建在 k8s 之上，而应用的形态要向微服务靠拢。&lt;/li&gt;
&lt;li&gt;现状：而现实是存在很多挑战，首先还有很多应用没有实现微服务化，而且我们的 k8s 普及程度也不够，还有非常多的应用没有运行在 kubernets 之上。Istio 的成熟程度也稍显不足，不够稳定，更大的挑战的是 Istio 目前无法原生支持我们蚂蚁金服的规模，我们还在试图对 Istio 进行改进和扩展。最后，在落地时必须考虑的非常现实的一点：现有系统中为数众多的应用不可能一夜之间全部迁移。&lt;/li&gt;
&lt;li&gt;关键需求：因此在落地实施时，非常重要的需求是：要实现平滑迁移。简单说，微服务 + Service Mesh + kubernetes 是我们的目标，但是如何从现有体系出发，向目标平稳和坚实的迈进，必须给出可行的实践指导。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天演讲的内容，要给大家介绍的就是，在这样的背景下，我们蚂蚁金服选择的 Service Mesh 主站落地演进方案。这个方案预期会在 2019 年初全面铺开。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsmb5l9j30qo0f0q4s_hu17151873623624660758.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsmb5l9j30qo0f0q4s_hu4692970028062881232.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsmb5l9j30qo0f0q4s_hu11686895979462290313.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsmb5l9j30qo0f0q4s_hu17151873623624660758.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;主站落地方案的实施原则，这是我们在过去半年的实践中，总结归纳出来的行为指导：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符合远期规划：一定要有清晰的长期目标，明确的知道未来的大方向。避免走弯路，避免浪费投资，理想状态是计划中的每一步都可以为下一步奠定坚实的基础。即使因为某些原因不得已妥协或绕行，也应该清晰的知道后面应该如何回归，谢绝中途推倒重来——代价太高，无法承受。&lt;/li&gt;
&lt;li&gt;循序渐进：认清现实，如此之大的变革，一定是需要分步进行，不要心存一步登天的幻想，现实可行的方式是小步快跑。将整个过程拆解为若干个大步骤，每一步的工作量和复杂度都控制在一个可以接受的范围内，以保证每一步都简单方便，切实可行。&lt;/li&gt;
&lt;li&gt;有可操作性：在操作层面上，要有足够的弹性，即每个步骤中的工作内容，都应该是可以分批进行。以步步为营的方式，逐步扩大战果，杜绝一刀切。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在接下来的演进路线中，大家将会体会到这三个原则在实际落地时的指导作用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsq62x9j30qo0f0ac4_hu11370591442754456470.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsq62x9j30qo0f0ac4_hu6516956139589827921.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsq62x9j30qo0f0ac4_hu12384342769141486788.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsq62x9j30qo0f0ac4_hu11370591442754456470.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个图的信息量有点大，描述的是 Service Mesh 和 k8s 落地可能的多种演进路线。&lt;/p&gt;
&lt;p&gt;我们先从最下面开始看，这是当前蚂蚁金服主站大多数应用的现状：即应用&amp;quot;部署在非 k8s 上&amp;quot;，应用也&amp;quot;不是 Service Mesh 形态&amp;quot;。然后看最上面，这是我们期望的蚂蚁金服主站未来的应用终极形态：应用&amp;quot;部署在 k8s 上&amp;quot;，应用也迁移到了&amp;quot;Service Mesh 形态&amp;quot;。&lt;/p&gt;
&lt;p&gt;这里有个特别的地方，我们将 Service Mesh 形态细分为两种模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Sidecar 模式：只有 Sidecar，没有控制平面，和外部系统的各种集成都是在 Sidecar 中直接进行。这是第一代的 Service Mesh，Linkerd/Envoy 都是如此，华为基于 ServiceComb 演进而来的 mesher，新浪微博的 Mesh，包括我们蚂蚁金服基于 MOSN 开发的用于取代多语言客户端的 Mesh 方案。&lt;/li&gt;
&lt;li&gt;Istio 模式：有完善的控制平面，可以提供强大的控制能力，而且从数据平面分离，这是第二代的 Service Mesh，典型如 Istio 和 Conkduit/Linkerd 2.0。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之所以将 Service Mesh 形态细分，是因为我们有着这样一个特殊背景：目前的原生 Istio 无法支撑我们蚂蚁金服的规模，因此在改进完善 Istio 之前，我们不得不暂时在 Sidecar 模式下短暂停留。另外一个原因就是考虑到存量应用的迁移，多一个 Sidecar 模式作为中间缓冲，会让整个迁移过程平滑很多。&lt;/p&gt;
&lt;p&gt;现在我们来介绍图中展示的四条演进路线：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左边的路线 1，思路是先将应用迁移 k8s 部署，再迁移到 Service Mesh 形态。这条路线的最大好处，是过程中每个阶段的绝大多数投资都将最终得以保留，因为符合 k8s+service mesh 的远期目标&lt;/li&gt;
&lt;li&gt;右边的路线 2，思路是跳过 k8s，先迁移到 Service Mesh 形态，一路演进到 Istio 模式，然后最后迁移到 k8s。&lt;/li&gt;
&lt;li&gt;中间的路线 3，直接一步到位，这个路线是 Istio 默认的方式，或者说 Istio 根本没有考虑过迁移的问题，默认客户已经有完善的 k8s，然后将改造好的应用直接部署在 Istio 上。这个路线对于蚂蚁金服主站的复杂场景，当然是不现实的。（补充：只是对蚂蚁金服主站不合适，对于大多数公司，规模不是那么巨大，也没有历史负担，也有 k8s 基础，完全可行。）&lt;/li&gt;
&lt;li&gt;还有一条特别的路线 4，走位飘忽，先和路线 2 一样迁移到 Sidecar 模式，然后走回路线 1，上 k8s，再在有 k8s 支持的情况下继续演进到 Istio 模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们来详细分析各条演进路线的优劣和实施条件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxstzrdqj30qo0f040q_hu13547796692049129923.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxstzrdqj30qo0f040q_hu14004918382994380975.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxstzrdqj30qo0f040q_hu4920589787185001513.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxstzrdqj30qo0f040q_hu13547796692049129923.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;演进路线 2，和路线 1 的核心差别，在于：是先上 k8s，还是先上 Service Mesh。而且路线 2 是在非 k8s 条件下一路演进 Service Mesh 到我们期望的终极形态 Istio 模式，这意味着过程中和最终目标有非常大的偏移。&lt;/p&gt;
&lt;p&gt;演进路线 2 的好处，在于第一步非常的自然：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有 k8s 的限制，因此不依赖基础设施，实施方便。毕竟，k8s 普及度是个大问题&lt;/li&gt;
&lt;li&gt;在原有的侵入式框架的客户端 SDK 基础上，通过包裹一个 proxy，重用原有 SDK 的能力，可以非常快速的得到一个基本可用的 Sidecar&lt;/li&gt;
&lt;li&gt;除了多一个 proxy 外，没有引入太多的新概念和新思想，符合现有开发人员/运维人员的心智，容易接受&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，路线 2 特别容易落地，可以快速达成短期目标，直接拿到 Service Mesh 的部分红利，如：多语言支持，方便类库升级等。&lt;/p&gt;
&lt;p&gt;但是，这个路线的问题在于再往后走，开始完善 Service Mesh 的功能以向 Istio 模式靠拢时，由于没有 k8s 的底层支持，因此不得不做大量的工作来提供类 k8s 的功能。尤其是 Istio 的非 k8s 支持，官方方案基本上只是一个 demo，完全不具备生产可用性，要完善好，工作量很大。而关键点在于，这些投入，在迁移到 k8s 时，又因为和 k8s 提供的功能重复而被放弃。&lt;/p&gt;
&lt;p&gt;因此，结合我们前面的原则（符合远期规划，不浪费投资），路线 2 对蚂蚁金服主站落地是不合适的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsx61iuj30qo0f0wg9_hu17954825838760833171.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsx61iuj30qo0f0wg9_hu11156710681561556145.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsx61iuj30qo0f0wg9_hu10715728010610377329.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsx61iuj30qo0f0wg9_hu17954825838760833171.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;演进路线 4 是一个非常特殊的路线，可以理解为路线 1（先上 k8s 再上 Service Mesh）的短期妥协版本。因为路线 1 的前提条件是要先大规模铺开 k8s，将现有应用迁移到 k8s 之后再继续往 Service Mesh 演进，这对于还没有普及 k8s 的公司来说是一个非常高的门槛，很容易因此受阻而无法启动。&lt;/p&gt;
&lt;p&gt;因此，如果暂时不具备 k8s 条件，又不想就此止步，那么选择路线 2 是唯一的出路。而上面我们分析过，路线 2 虽然能够在第一步快速拿到短期红利，但是由于偏离长期目标后续发展会有问题。怎么办？&lt;/p&gt;
&lt;p&gt;路线 4 可以是这种场景下的一个折衷选择：在 k8s 没有铺开之前，第一步沿路线 2 走，先吃下非 k8s 下 Sidecar 模式快速落地的红利。然后第二步避开非 k8s 下继续演进到 Istio 模式的大坑，切换到路线 1，回归长期目标。&lt;/p&gt;
&lt;p&gt;好处非常明显：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 k8s 未铺开前，先往前迈进一步，避免就此卡壳&lt;/li&gt;
&lt;li&gt;和路线 2 一样，第一步可以快速的拿到短期红利&lt;/li&gt;
&lt;li&gt;后续转为路线 1 后，因为符合远期规划，因此后续演进不存在投资浪费的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点就是存在少量的投资浪费，毕竟非 k8s 下的 Sidecar 模式还是有些工作内容在迁移到 k8s 之后会有改动。不过，这个改动不会太大，和拿到的红利相比还是值得的。&lt;/p&gt;
&lt;p&gt;路线 4 在操作时，存在一个变数：现有应用在向 Sidecar 模式的 Service Mesh 迁移，是需要一定时间的。有一种可能，就是在迁移过程中，k8s 的普及开始了。这个变数的发生，取决于 Sidecar 模式的 Service Mesh 普及快，还是 k8s 的普及快。&lt;/p&gt;
&lt;p&gt;对路线 4 的分析结果：这是（k8s 没有普及的）特殊时期的选择。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxszj2wkj30qo0f0abt_hu8926127869760631939.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxszj2wkj30qo0f0abt_hu759603467799741492.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxszj2wkj30qo0f0abt_hu14240602337896349546.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxszj2wkj30qo0f0abt_hu8926127869760631939.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在对四条可能的演进路线分析完成之后，我们来具体介绍蚂蚁金服的最终选择。&lt;/p&gt;
&lt;p&gt;坦言说，在过去半年中，我们的演进路线有几次摇摆和修订，今天我们公布的路线，和过去几个月中我们通过 meetup/技术大会/博客文章 等方式透露出来的方式会有一些变化。主要原因是在过去的这半年中，一方面我们对 Sercice Mesh 的认知更加深入，另一方面是蚂蚁金服的 k8s 背景也在变化。&lt;/p&gt;
&lt;p&gt;首先，在今年年初，我们确认 Service Mesh 大方向时，k8s 还没有在蚂蚁金服普及，而且也没有明确的时间表。因此，我们在一番调研之后，选择了两条腿走路的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在非 k8s 环境下，以 Sidecar 模式先进行少量落地，主要是替换掉原有的多语言客户端（拿短期红利）&lt;/li&gt;
&lt;li&gt;开发 SOFAMesh，集成 MOSN 到 Istio，增加对多种 RPC 协议的支持，增加对 RPC 服务模式的兼容（为最终目标做准备）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在今年 6 月底的杭州第一届 Service Mesh 线下 meetup 中，我们公布了 SOFAMesh 项目，我当时做了一个演讲 &lt;a href=&#34;https://skyao.io/publication/201806-service-mesh-explore/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大规模微服务架构下的 Service Mesh 探索之路&lt;/a&gt; ，有兴趣的同学可以去回顾一下我们当时的背景/需求/设计方案。&lt;/p&gt;
&lt;p&gt;大概在今年九月，我们完成了对非 k8s 下运行 istio 的深入调研，得出的结论是要实现这个模式需要非常多的工作。而且，我们对 Service Mesh 的认知也更加深刻，明确了通过 Service Mesh 将传统中间件能力向以 k8s 为代表的基础设施层下沉的战略方向。期间，内部也明确了 k8s 普及的大方向，因此，综合这两个重要输入，我们选择放弃继续在路线 2 上继续演进（即 istio on 非 k8s）的想法。关于这一点，有兴趣的同学可以去阅读我在 10 月份 QCon 大会上的演讲内容 &lt;a href=&#34;https://skyao.io/publication/201810-ant-finance-service-mesh-practice/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;长路漫漫踏歌而行：蚂蚁金服 Service Mesh 实践探索&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;最近，k8s 普及的时间表再一次明确提前，蚂蚁金服将会在短时间内开启 k8s 的大面积普及。因此，我们的演进路线再一次发生变化。目前最新的演进路线将会是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前还没有开始迁移的应用（处于演进路线图最下方），将按照路线 1 的方式进行迁移：先迁移到 k8s，再迁移到 Sidecar 模式的 Service Mesh&lt;/li&gt;
&lt;li&gt;目前部分已经迁移的应用（路线 2/4 的第一步，非 k8s 部署的 Sidecar 模式），将沿路线 4 迁移，和路线 1 会师&lt;/li&gt;
&lt;li&gt;由于应用众多，因此预计到 k8s + Sidecar 模式 的迁移工作会持续比较长时间，在此期间，我们会同步完善 Istio，和 Istio 官方一起合作来实现 Istio 对超大规模部署的支持&lt;/li&gt;
&lt;li&gt;最后一步，迁移到最终目标（当然这一步的方案依然有很多待定内容，继续努力）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要强调的是：这个演进路线针对的是蚂蚁金服主站的特殊场景，并不具体普适性。大家可以在理解我们演进路线背后的思路和权衡方式之后，再结合自身的实际情况进行决策。比如，我们在 UC 落地时，由于 UC 有完善的 k8s 支持，而且目前落地的规模没那么夸张，因此是直接从&amp;quot;部署在 k8s 上&amp;quot; + &amp;ldquo;不是 Service Mesh 形态&amp;rdquo;，直接迁移到终态的。预计在金融云落实时，也会是如此，因为客户也不会有如此规模。&lt;/p&gt;
&lt;p&gt;总结：前面我们介绍了当应用程序向 Service Mesh 和 K8s 迁移时的几种可能的演进路线，分析了各条路线的利弊。并以蚂蚁金服主站为例，介绍了我们迁移的背景和演进路线的选择思路，希望能够帮助大家更好的理解 Service Mesh 的落地实践，以便在未来设计自家的落地方案时能有所参考。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt3aatgj30qo0f0juh_hu18270771456977028246.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt3aatgj30qo0f0juh_hu6677131665214597266.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt3aatgj30qo0f0juh_hu9738421313106854299.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt3aatgj30qo0f0juh_hu18270771456977028246.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;前面给大家介绍了蚂蚁金服主站的 Service Mesh 演进路线，期间谈到要实现现有应用的平滑迁移。今天的第二个内容，将给大家介绍平滑迁移实现中的几个关键做法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt72zxjj30qo0f0jse_hu1245251061508166087.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt72zxjj30qo0f0jse_hu10550233649163407406.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt72zxjj30qo0f0jse_hu13368184279075945473.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt72zxjj30qo0f0jse_hu1245251061508166087.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先，第一个关键是尽量保证迁移前后服务间网络互通。&lt;/p&gt;
&lt;p&gt;以向 k8s 迁移为例，在非 k8s 环境，典型的服务间访问方式是这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个服务向注册中心注册&lt;/li&gt;
&lt;li&gt;客户端发起访问前，通过注册中心得到目标服务的实例列表信息，如 IP 地址/端口等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在向 k8s 迁移的过程中，我们的做法是保证 k8s 内外网络打通，即服务的 IP 地址（在 k8s 中是 pod ip）是可以相互直接访问的。基于这个前提，服务在迁移到 k8s 的过程中，原有的服务注册/服务发现/发起请求等逻辑都无需修改，是不是在 k8s 内，是不是 pod ip，对原有服务化体系完全是透明的。&lt;/p&gt;
&lt;p&gt;因此，向 k8s 的迁移可以做到对业务应用非常的平滑，基本感知。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt9dqbsj30qo0f00uq_hu669758057755373346.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt9dqbsj30qo0f00uq_hu4210623203992740774.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt9dqbsj30qo0f00uq_hu8124011217942113707.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt9dqbsj30qo0f00uq_hu669758057755373346.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;透明拦截在迁移过程中，可以起到非常关键的作用。&lt;/p&gt;
&lt;p&gt;以 Service-A 要访问 Service-B，在应用向 Sidecar 模式的 Service Mesh 迁移前后，会有有四种排列组合场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Service-A 和 Service-B 都没有迁移到 Serive Mesh：此时请求会直接从 Service-A 发送到 Service-B，称为直连，这是应用在开始迁移到 Service Mesh 之前的标准工作方式&lt;/li&gt;
&lt;li&gt;Service-A 已经迁移到 Service Mesh，Service-B 还没有：此时 Service-A 发出来的请求，会被劫持，然后发送到和 Service-A 一起部署的 Sidecar（称为 Outbound Sidecar），此时链路中只有一个 Sidecar，称为（客户端）单跳&lt;/li&gt;
&lt;li&gt;Service-B 已经迁移到 Service Mesh，Service-A 还没有：此时 Service-A 发出来的请求，在到达 Service-B 时，会被劫持到和 Service-B 一起部署的 Sidecar（称为 Inbound Sidecar），此时链路中也只有一个 Sidecar，称为（服务器端）单跳&lt;/li&gt;
&lt;li&gt;Service-A 和 Service-B 都迁移到 Serive Mesh：此时 Service-A 发出来的请求，会被两次劫持，分别进入 Outbound Sidecar 和 Inbound Sidecar，此时链路中有两个 Sidecar，称为双跳。这是 Istio 的标准工作模式，也是我们迁移完成之后的最终工作模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这四种场景中，所有的网络请求，请求报文都是完全一致的，即不管是否被劫持到 Sidecar，对请求报文都没有影响，也就是对发出请求报文的客户端和接受请求报文的客户端都是透明的，完全无感之。&lt;/p&gt;
&lt;p&gt;因此，在迁移过程中，可以单个服务逐个迁移，甚至服务的单个实例逐个迁移，而无需修改应用本身。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtcjj4wj30qo0f0jt1_hu17230638011840312103.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtcjj4wj30qo0f0jt1_hu2001876550839305115.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtcjj4wj30qo0f0jt1_hu17247244226393576655.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtcjj4wj30qo0f0jt1_hu17230638011840312103.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在展开第三个关键点之前，我们来探讨一下：在 Service Mesh 时代，理想的客户端应该是什么样子？&lt;/p&gt;
&lt;p&gt;图中我们列举了一个传统的侵入式框架的客户端所包含的功能，在侵入式框架中，大部分的功能都是由客户端实现，因此会包含非常多的功能，如服务发现、负载均衡等基本功能，加密、认证、路由等高级功能。在应用迁移到 Service Mesh 之后，这些功能都下沉到 Service Mesh 中。因此，Service Mesh 下的客户端可以进行大幅度的简化，成为一个新的轻量级客户端。&lt;/p&gt;
&lt;p&gt;对于这个轻量级客户端，我们希望可以尽可能的做的轻薄通用：实现简单，不管哪个编程语言都可以做到轻松实现，因此跨语言就方便了。而且越简单之后升级的可能性就会越少，以避免升级客户端。&lt;/p&gt;
&lt;p&gt;那我们来继续看，这个轻量级客户端里面最后还能剩下什么内容？&lt;/p&gt;
&lt;p&gt;图中列出了三个，其中最重要的，也是必不可少的是目标服务的标识，即无论如何简化，最低限度应该告之要访问谁吧？然后是序列化，对于 RPC 类肯定需要提供编解码功能，不过对于 HTTP/REST 类很多语言直接内置了标准实现。然后链路追踪，需要做一点工作来传递诸如 SpanID 之类的参数，同样这块也有可能通过自动埋点来实现。因此，最理想最单薄的客户端，可能只保留最后一个信息：目标服务的标示。&lt;/p&gt;
&lt;p&gt;在侵入式框架下，目标服务的标示是和服务注册/服务发现是直接关联的，这个标示通常都是服务名，通过服务发现机制实现了一个服务名到服务实例的寻址方式。在 Service Mesh 机制下，由于服务发现机制被下沉到 Service Mesh 中，因此只要底层 Service Mesh 能支持，这个目标服务的标示可以不必拘泥于服务名。&lt;/p&gt;
&lt;p&gt;那么，问题来了，对客户端来说：最简单，最通用，支持最广泛的寻址方式是什么？是 DNS！&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtezb6wj30qo0f0dh6_hu1822814960664082946.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtezb6wj30qo0f0dh6_hu2635231500916154865.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtezb6wj30qo0f0dh6_hu4302927772709848278.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtezb6wj30qo0f0dh6_hu1822814960664082946.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在我们的迁移方案中，我们考虑引入 DNS 寻址方式。除了前面说的 DNS 是支持度最好，使用最普遍的寻址方式，在所有的编程语言和平台上都可以支持之外，我们还希望将 DNS 寻址方式作为未来产品的长期方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 SOFAMesh 和 SOFAMosn 中，我们已经基于名为 x-protocol 的方式实现了 DNS 通用寻址方式，用来解决 Dubbo/HSF/SOFA 等传统 SOA 服务模型在 Service Mesh 下的访问问题（备注：具体内容请见我的博客文章 &lt;a href=&#34;https://skyao.io/post/201809-xprotocol-common-address-solution/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFAMesh 中的多协议通用解决方案 x-protocol 介绍系列 (1)-DNS 通用寻址方案&lt;/a&gt; )&lt;/li&gt;
&lt;li&gt;未来在我们的 serverless 产品中，我们希望可以为运行其上的 Function 提供 DNS 寻址支持&lt;/li&gt;
&lt;li&gt;可能还会有其他更加广泛的使用场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在我们的演进过程中，对于客户端 SDK，我们有这样一个思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一方面简化原有的 SDK，去除和 Sidecar 重复的内容（满足短期需求）&lt;/li&gt;
&lt;li&gt;另一方面，考虑到必然有一次客户端 SDK 的更换过程，那么我们希望在简化的同时引入基于 DNS 的通用寻址方式，以便在未来的后续迁移和功能扩展中可以依托这个机制来实现（符合长期目标）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxti92oij30qo0f0wg2_hu10061215789666350819.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxti92oij30qo0f0wg2_hu13634855614754614537.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxti92oij30qo0f0wg2_hu2098034484866273863.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxti92oij30qo0f0wg2_hu10061215789666350819.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图中描述的是在 Service Mesh 下，客户端通过域名来指定要访问的目标服务，然后通过 DNS 解析机制来串联底层的服务注册/DNS 记录更新/透明劫持传递原始信息/Sidecar 查找路由目标等详细实现机制。&lt;/p&gt;
&lt;p&gt;这里仅做简单示意，我就不详细展开了。在接下来的内容中，我的同事，来自 UC 基础研发部的 龙轼 同学，将为大家详细的展开 DNS 寻址方案的细节实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtk2cbej30qo0f0ad5_hu9423653134668945298.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtk2cbej30qo0f0ad5_hu8736823496866094017.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtk2cbej30qo0f0ad5_hu11384743346223529169.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtk2cbej30qo0f0ad5_hu9423653134668945298.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，我是来自 UC 基础研发部的龙轼。感谢小剑老师给我们介绍了蚂蚁和 UC 共建的 Service Mesh 的演进路线和实现平滑迁移的关键。&lt;/p&gt;
&lt;p&gt;接下来由我来向大家分享下实现平滑迁移的关键中的 DNS 寻址方案的演进。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtlzs10j30qo0f0q4l_hu5413147634259939111.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtlzs10j30qo0f0q4l_hu9548934207923494549.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtlzs10j30qo0f0q4l_hu6530137288608778584.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtlzs10j30qo0f0q4l_hu5413147634259939111.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家可以看上面的所示的 DNS 寻址方案的演进，我们先了解下各个服务寻址方案的背景。&lt;/p&gt;
&lt;p&gt;从 SOA 的寻址，到 Kubernetes 的寻址，然后再到 Istio 的寻址，最后是我们的 SOFAMesh 的 DNS 寻址方案。&lt;/p&gt;
&lt;p&gt;它们的寻址方案有什么不同，我们将一一分析它们的细节和总体寻址方案的演进路线。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtnvgf0j30qo0f0gmq_hu12784911823439321742.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtnvgf0j30qo0f0gmq_hu17940103744122620048.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtnvgf0j30qo0f0gmq_hu9503170282671161421.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtnvgf0j30qo0f0gmq_hu12784911823439321742.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;现在大家可以先来看下 SOA 架构下基于服务注册和服务发现的寻址。&lt;/p&gt;
&lt;p&gt;我们可以看到图中的 SOA 其实是单进程多接口的，依赖于 SOA 的服务注册与服务发现的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtovfoxj30qo0f0myc_hu10752728632931640028.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtovfoxj30qo0f0myc_hu15572326141225524398.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtovfoxj30qo0f0myc_hu9448200872656584721.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtovfoxj30qo0f0myc_hu10752728632931640028.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来我们看下 Kubernetes 的 DNS 寻址方式，它的寻址方式其实是通过 DNS 的。&lt;/p&gt;
&lt;p&gt;从图中我们可以看到部署到 K8S 上面的 userservice 服务会生成一条 DNS 记录指向 K8S 的 ClusterIP。&lt;/p&gt;
&lt;p&gt;我们在 Pod 里面发起请求时通过 DNS 的 SearchDomain 域名补全规则就会从 DNS 里面查询得到 ClusterIP，我们可以看出 Kubernetes 的寻址方案是单进程单接口的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtr32x9j30qo0f0gmy_hu9392480871206268285.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtr32x9j30qo0f0gmy_hu7858371629022177813.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtr32x9j30qo0f0gmy_hu15469970191076313587.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtr32x9j30qo0f0gmy_hu9392480871206268285.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;看完 Kubernetes 的服务发现之后我们继续来看 Istio 的服务发现。&lt;/p&gt;
&lt;p&gt;从图中我们可以看出之前的流程都和 K8S 一脉相承，不同的地方在于 Istio 里面有个 SideCar 它把 ClusterIP 拿到之后根据 ClusterIP 从 VirtualHost 里面匹配到 Rule 规则 转发给目标的 Pod 地址。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtt2236j30qo0f00tq_hu12836777091879929596.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtt2236j30qo0f00tq_hu1112292574014908727.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtt2236j30qo0f00tq_hu12391570174007968083.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtt2236j30qo0f00tq_hu12836777091879929596.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们来看下 SOFAMesh 的 DNS 通用寻址方案。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据我们之前分析的 SOA 寻址方案和 Kubernetes 寻址方案，我们可以看出如果我们的微服务不经过拆分和改造想上 Service Mesh 的话我们需要支持 SOA 之前的那种单个 Pod 多个接口的。&lt;/li&gt;
&lt;li&gt;从图中看就是我们需要支持 &lt;code&gt;com.alipay.userservice.interface1&lt;/code&gt;, &lt;code&gt;com.alipay.userservice.interface2&lt;/code&gt; 这些接口解析到 ClusterIP, 我们知道 k8s 中的 service 是不支持的。&lt;/li&gt;
&lt;li&gt;那该如何是好，我们只能在 DNS 上做文章修改 DNS 的记录来实现这一功能。确定了这一方案之后我们来看下我们设计的 DNS 寻址方案实现细节。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtx8cboj30qo0f0q3y_hu11067521504835495447.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtx8cboj30qo0f0q3y_hu10699730910845367609.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtx8cboj30qo0f0q3y_hu18169200124748100771.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtx8cboj30qo0f0q3y_hu11067521504835495447.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家看这张图：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们用 CRD 定义了一个 RPCService 和之前的 Service 有同样的 selector 的标签。&lt;/li&gt;
&lt;li&gt;然后用 RPC Service Controller 对 RPCService 做 Watch，当 RPCService 有更新的时候我们就把接口就是上述的 &lt;code&gt;com.alipay.userservice.interface1&lt;/code&gt; 的记录写入 CoreDNS 里面&lt;/li&gt;
&lt;li&gt;而 interface 是通过 Pod 里面的 Register Agent 来获取 Dubbo 里面暴露的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu1urkdj30qo0f0wf6_hu5150415020972303020.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu1urkdj30qo0f0wf6_hu15134342039573548791.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu1urkdj30qo0f0wf6_hu17043216883152343959.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu1urkdj30qo0f0wf6_hu5150415020972303020.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;好的，说完这个方案的细节之后。我们可以看出其实其他的问题都不大，但是要更新 DNS 的这个我们需要支持。&lt;/p&gt;
&lt;p&gt;一开始我们 K8S 集群里面是用 Kube-DNS 来做 DNS 寻址的，但我们看这张 Kube-DNS 的架构图。&lt;/p&gt;
&lt;p&gt;可以看出修改它成本是比较大的，而且所有的 DNS 都在同一个域里面，这个风险系数很高。如果一旦修改错误势必会影响到之前的 k8s 的 service，导致线上的故障。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu6p6cgj30qo0f0q5b_hu17140730209276352857.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu6p6cgj30qo0f0q5b_hu13139585451628263285.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu6p6cgj30qo0f0q5b_hu90193372001215899.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu6p6cgj30qo0f0q5b_hu17140730209276352857.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个时候我们跟踪到社区的 CoreDNS 项目，我们来看下 CoreDNS 的具体的架构。它采用作为 Web 服务器 Caddy 的服务器框架，延用了 Caddy 中的插件机制，大大的增加了 CoreDNS 的灵活性。&lt;/li&gt;
&lt;li&gt;它的插件机制也特别简单，把所有的插件注册进一个 Map 里面来，在调用的时候从 Map 拿出他们有共同接口的函数。有兴趣的同学可以看下 Caddy 的插件代码实现。&lt;/li&gt;
&lt;li&gt;它的 DNS 协议库采用是由 Google 工程师 Meikg 开发的 DNS 库，他同时也是 SkyDNS 的开发者。&lt;/li&gt;
&lt;li&gt;后端可以采用 UDP/TCP、TLS 或者 gRPC 作为后端数据查询。上面有个 Google 工程师用 gRPC 做了一个 CoreDNS 插件的后端数据查询例子，有兴趣的同学可以看下。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxubqi33j30qo0f0djp_hu11734244903228232233.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxubqi33j30qo0f0djp_hu11540150180056965984.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxubqi33j30qo0f0djp_hu100413751257000458.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxubqi33j30qo0f0djp_hu11734244903228232233.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，既然 CoreDNS 的 Plugins 这么强大，我们可不可以用它来实现我们刚才说到的 Renew DNS 的机制。答案很显然是可以。&lt;/p&gt;
&lt;p&gt;我们看下上面的图，实现 CoreDNS 的插件很简单，只需要继承上面的接口就可以了。CoreDNS 官网有具体的教程在教我们怎么写一个插件。这个就不具体的展开了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuel9hoj30qo0f03zw_hu17557809710933737342.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuel9hoj30qo0f03zw_hu809523799230618471.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuel9hoj30qo0f03zw_hu14229966057304536777.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuel9hoj30qo0f03zw_hu17557809710933737342.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;到了我们最关键的点了：我们应该怎么更新我们的 DNS。其实这点 CoreDNS 社区里面已经有人提出需求用 REST API 的形式提供更新 DNS 的接口。&lt;/li&gt;
&lt;li&gt;互联网任务工程小组也早在 rfc2136 定义了标准的 DNS UPDATE。Google Cloud 和 AWS 都有相应的实现。&lt;/li&gt;
&lt;li&gt;CoreDNS 社区其实已经把接口实现了，但是后端存储是基于 file 的，数据没有落地。蚂蚁和 UC 这边扩展了 ETCD 插件的接口，把对应 DNS UPDATE 接口给实现了，实现 DNS 数据写入 ETCD 里面。&lt;/li&gt;
&lt;li&gt;从图中我们可以看到 &lt;code&gt;rpc.cluster.local&lt;/code&gt; 这个域 和 k8s 域 cluster.local 是在不同的插件链上的。
这样在 k8s 域中没有 dynapirest 插件，我们就不能对 k8s 域中的 DNS 进行更新，这样就把之前 Kube-DNS 改造之后会对 k8s 域里面造成影响给去除了，更加的安全。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuhvylcj30qo0f0n35_hu5134401575104527946.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuhvylcj30qo0f0n35_hu5954794469634116469.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuhvylcj30qo0f0n35_hu7193833627466552601.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuhvylcj30qo0f0n35_hu5134401575104527946.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们可以看下 CoreDNS 后端存储的接口，其实和我们之前对数据操作的接口是没有什么差别的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuk3x3zj30qo0f0go6_hu7465069775502333656.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuk3x3zj30qo0f0go6_hu5783036297029845390.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuk3x3zj30qo0f0go6_hu7345970734131289133.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuk3x3zj30qo0f0go6_hu7465069775502333656.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;目前 CoreDNS 的 DynAPI 还在主库代码没合并的状态。之后 DynAPI 这个项目会独立成一个插件项目。我们可以看下 CoreDNS 社区的 DynAPI 插件进展。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxumjxr1j30qo0f00vw_hu3930926450992642409.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxumjxr1j30qo0f00vw_hu8673284208444344610.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxumjxr1j30qo0f00vw_hu681430271369810322.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxumjxr1j30qo0f00vw_hu3930926450992642409.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，我们来看下我们的 DynAPI 实现 DNS 更新的一个效果。从图中我们可以看出 record.json 里面的一个域名的更新。通过 DynAPI 我们成功把 record.json 的 DNS 记录给更新进去并且 dns 正常工作了。到现在我们通过 CoreDNS 的插件就把 DNS 更新的需求给解决了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuoytkjj30qo0f0q4a_hu14433506951946606252.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuoytkjj30qo0f0q4a_hu4144930813209298582.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuoytkjj30qo0f0q4a_hu12309912959877128998.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuoytkjj30qo0f0q4a_hu14433506951946606252.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其实 CoreDNS 官网还有许多有趣的插件，可以丰富 CoreDNS 的功能和提升 CoreDNS 的性能。大家可以看下中间的 autopath 插件，他把我们多次的在 searchdomain 拼凑的 DNS 记录的查询在在服务器上给实现了。避免了多次的 Client 端和 Server 端的数据交互。有兴趣的同学可以看下 &lt;a href=&#34;https://github.com/coredns/presentations/blob/master/A-Deep-Dive-into-CoreDNS-2018.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A-Deep-Dive-into-CoreDNS-2018&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxurlu6tj30qo0f0q46_hu6837215050465667318.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxurlu6tj30qo0f0q46_hu8688682236038663088.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxurlu6tj30qo0f0q46_hu8737521506918970417.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxurlu6tj30qo0f0q46_hu6837215050465667318.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们把 CoreDNS 的功能开发完了，上线的话很多人关注它的性能。我们这边做了一个简单的性能测试，可以看出 CoreDNS 和 Bind DNS 这种现在比较通用的 DNS 的性能还是有点差距的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuu4eu0j30qo0f0tf3_hu8547790201242924156.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuu4eu0j30qo0f0tf3_hu3054286848937549623.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuu4eu0j30qo0f0tf3_hu8646878970405374377.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuu4eu0j30qo0f0tf3_hu8547790201242924156.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但是，我们通过上面的图可以看到在一定的 QPS 下，CoreDNS 的延时是很低的。我们可以看到所有的延时都落在 4ms 之内。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuwnsanj30qo0f0abw_hu16475334817319539844.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuwnsanj30qo0f0abw_hu2914834869887357290.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuwnsanj30qo0f0abw_hu15181856268325799803.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuwnsanj30qo0f0abw_hu16475334817319539844.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了解决 QPS 的问题，我们通过 Kubernetes 的 HPA 给 CoreDNS 进行横向的扩展。&lt;/p&gt;
&lt;p&gt;一开始我们只是通过 CPU 的维度给 CoreDNS 扩展，但发现波动有点大。之后我们切换成通过 QPS 的维度来进行扩容。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuz1c5ej30qo0f0gmc_hu2250142190497641105.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuz1c5ej30qo0f0gmc_hu9935849559653053342.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuz1c5ej30qo0f0gmc_hu4622317108551547191.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuz1c5ej30qo0f0gmc_hu2250142190497641105.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;CoreDNS 将会在 Kubernetes 1.13 之后成为 Kubernetes 的默认的 DNS 服务。我们将会紧跟社区实施我们的方案并且反馈给社区。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv0youwj30qo0f0tbs_hu12497707475340414068.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv0youwj30qo0f0tbs_hu6648172403981974459.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv0youwj30qo0f0tbs_hu13092789966933946585.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv0youwj30qo0f0tbs_hu12497707475340414068.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们再来看下我们后续的一些规划。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv3cwjjj30qo0f075p_hu15294661393402658117.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv3cwjjj30qo0f075p_hu2604600719935413229.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv3cwjjj30qo0f075p_hu14562927416832785013.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv3cwjjj30qo0f075p_hu15294661393402658117.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可以看到我们的 DynAPI 其实在安全上还是有欠缺的。我们后续会把 HTTP 加强成 HTTPS 协议来增强 DynAPI 的安全性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv5rwbbj30qo0f0dik_hu3906518105751348306.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv5rwbbj30qo0f0dik_hu9426179534414004922.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv5rwbbj30qo0f0dik_hu3015142293711079260.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv5rwbbj30qo0f0dik_hu3906518105751348306.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;还有如果我们 CoreDNS 的后端变化的更新的 Watch 由于 Watch 的范围过大的话，会返回过多的数据。这样会影响到 Watch 的性能，CoreOS 在 ETCD3.2 增加了 proxy 可以让我们根据不同的 ETCD KeySpace 去 Watch，这样大大的提高了 Watch 的性能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv8070fj30qo0f0ab1_hu9826389381836621302.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv8070fj30qo0f0ab1_hu12047437692526578393.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv8070fj30qo0f0ab1_hu3970113720246982603.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv8070fj30qo0f0ab1_hu9826389381836621302.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后一个，我们建议在创建 Kubernetes 集群的时候把 idc 的信息给带进 Kubernetes 的后缀域名中。这样我们之后可以通过 kubernetai 插件把不同的 Kubernetes 集群的域名进行整合通过本 IDC 缓存提高跨 IDC DNS 的访问速度。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvatmutj30qo0f0whk_hu9381523729066358438.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvatmutj30qo0f0whk_hu14618524541188322972.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvatmutj30qo0f0whk_hu16942242724816978885.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvatmutj30qo0f0whk_hu9381523729066358438.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvdouf2j30qo0f0gnc_hu15090141292320241424.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvdouf2j30qo0f0gnc_hu1203709729747675376.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvdouf2j30qo0f0gnc_hu1180726294907465829.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvdouf2j30qo0f0gnc_hu15090141292320241424.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们总结下，总体方面小剑老师给我们讲了蚂蚁金服主站 Service Mesh 的渐进式演进路线和实现平滑迁移的几个关键。具体细节方面我们通过 CoreDNS 的单点突破解决了 SOFAMesh 的 DNS 寻址的问题。&lt;/p&gt;
&lt;p&gt;感谢大家，希望这次演讲能让大家有所收获。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服开源的 SOFAMesh 的通用协议扩展解析</title>
      <link>https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/</link>
      <pubDate>Fri, 31 Aug 2018 12:27:25 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文作者：邵俊雄（熊啸），蚂蚁金服中间件团队高级技术专家，目前主要负责 SOFAMesh 的开发工作。&lt;/p&gt;
&lt;p&gt;本文是基于作者在 &lt;a href=&#34;https://cloudnativecn.com/blog/service-mesh-meetup-shenzhen-20180825&#34;&gt;Service Mesh Meetup #3 深圳&lt;/a&gt;的主题分享《SOFAMesh 的通用协议扩展》部分内容所整理，完整内容见文末的直播回放&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-邵俊雄-蚂蚁金服-service-mesh-sofa-mosn&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;邵俊雄 蚂蚁金服 Service Mesh SOFA MOSN&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusppz003uj318w0u0qdx_hu8686434977478781799.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusppz003uj318w0u0qdx_hu16317789507722809845.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusppz003uj318w0u0qdx_hu4419985129027291163.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusppz003uj318w0u0qdx_hu8686434977478781799.webp&#34;
               width=&#34;760&#34;
               height=&#34;508&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      邵俊雄 蚂蚁金服 Service Mesh SOFA MOSN
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本次分享主要介绍蚂蚁金服在 SOFAMesh 上开发对 SOFARPC 与 HSF 这两个 RPC 框架的支持过程中总结出来的通用协议扩展方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspj4xg2uj30k00b9wfc_hu8396971962923905460.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspj4xg2uj30k00b9wfc_hu10677483950821610675.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspj4xg2uj30k00b9wfc_hu14611262841055703360.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspj4xg2uj30k00b9wfc_hu8396971962923905460.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;1-sofamesh-介绍&#34;&gt;1. SOFAMesh 介绍&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmec6l4j30k00b9aax_hu7818483957906707615.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmec6l4j30k00b9aax_hu13571827726758085169.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmec6l4j30k00b9aax_hu10508560563799315260.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmec6l4j30k00b9aax_hu7818483957906707615.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFAMesh 是蚂蚁从 ISTIO 上游克隆的开源项目，目的是在 ISTIO 的基础上进行控制平面的发展和创新，同时保持和上游 ISTIO 的同步更新，跟随 ISTIO 的发布节奏，当然也会把一些有价值能力贡献给 ISTIO 社区。&lt;/p&gt;
&lt;p&gt;SOFAMesh 的一个重要目标是用蚂蚁自研的 Golang 版 L4/L7 层代理服务器 SOFAMosn 作为数据平面，取代 C++ 开发的 ENVOY。之前的 Meetup 中我们已经探讨过了一个 Golang 版本的数据平面的重要性，我们相信统一控制平面和数据平面的开发语言可以加快 Service Mesh 的技术创新和产品化落地的速度。&lt;/p&gt;
&lt;p&gt;目前我们已经完成了集成 SOFAMosn 的前期开发工作，打包，安装，部署和测试的脚本都已经从 ENVOY 迁移到了 SOFAMosn，所有的镜像也都推到了公开的镜像仓库。下一步 SOFAMesh 将会整体在 UC 内部基于 Kubernetes 的 PAAS 平台中落地，在实际的生产环境中打磨。未来，SOFAMesh 还将在蚂蚁主站落地，在金融级的生产环境中进一步打磨。&lt;/p&gt;
&lt;p&gt;ISTIO 目前仅能支持 TCP/REDIS/MONGO/HTTP 协议，其服务治理规则主要针对 HTTP 服务制定，对于业界目前大量在高并发、低延迟环境下使用的 RPC 框架及通信协议，例如 DUBBO/HSF/SOFA 没有很好的支持，SOFAMesh 把对于 RPC 通信协议的支持作为重点来看待，SOFAMosn 默认就提供对于 SOFA BOLT 协议的支持。&lt;/p&gt;
&lt;p&gt;SOFAMesh 也是控制平面创新发生的地方，我们已经规划了的创新包括 Mesh Operator，RPC Service Controller 等等。未来的 Serverless 平台也会考虑基于 SOFAMesh 打造，SOFAMesh 将为 Serverless 平台提供基于 Reversion 的服务治理能力。Google Cloud 最近联合 CloudFoundry 和 IBM 发布的 Serverless 平台 Knative 同样也是基于 ISTIO 打造，和我们的想法也是不谋而合。&lt;/p&gt;
&lt;p&gt;SOFAMesh 的下一步也是要融合到 PAAS 平台里面去，成为 PAAS 平台基础网络能力的一部分，用于支撑上层的业务更快速的创新，我们还会加强文档和快速上手方面，方便大家试用 SOFAMesh。&lt;/p&gt;
&lt;h2 id=&#34;2-service-mesh-落地中的问题&#34;&gt;2. Service Mesh 落地中的问题&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmm8hvij30k00b93zo_hu14314177116509383937.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmm8hvij30k00b93zo_hu9133943658203582183.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmm8hvij30k00b93zo_hu13570821494157741057.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmm8hvij30k00b93zo_hu14314177116509383937.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二部分是这次分享的重点，主要介绍蚂蚁金服在集成 SOFA/DUBBO 和 HSF 这些框架的过程中碰到的问题和我们的一套通用的解决方案，希望能够加速 Service Mesh 在实际生产中的落地。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总的来说，业界在 Service Mesh 落地的时候主要有下面四种做法，基本上每种我们都思考和尝试过，最后我们也是走了一条循序渐进的道路。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种做法，比较常见，就是不用 ISTIO 只参考它的设计理念，用 ENVOY/MOSN 或者自研的 SIDECAR 结合已经成熟并且大规模部署的注册中心/配置中心组件，快速上线，拿到多语言，灰度发布，安全这些红利，比如唯品会的 OSP Local Proxy, 华为的 Mesher 都是这个套路。其实 ENVOY 最早也是如此，希望用户在 ENVOY 上直接扩展对 Consul, Eurkea 这些注册中心的支持。但是社区没有走这条路，反而对其 XDS API 进行了适配，由此诞生除了 Service Mesh 的控制平面，并进一步演化出了 ISTIO。目前看来这么做的主要问题是无法利用 ISTIO 社区在服务治理上的创新和工作，存在重复的建设，所以后来有了第二种思路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种做法，更进一步，使用 ISTIO，但是把 Kubernetes 剥离出去，适用于很多短期内无法上 Kubernetes 的企业。ISTIO 控制平面本来就提供了这个能力，ISTIO 有两个扩展点，一个通过 Platform Adapter 对接第三方注册中心，另一个 通过 Config Adapter 对接不通的配置存储。这个做法业界最典型的是 Ucloud 的轻量级 Service Mesh 方案，他们把 Pilot Discovery 模块从 ISTIO 里面剥离了出来，增加第三方注册中心的 Platform Adapter，Cofig Store 直接对接 ETCD 集群，可以通过 docker compose 直接跑起来整个 ISTIO。好处是入门更简单了，但是失去了 Kubernetes 提供了基础能力，ISTIO 的武功已经废了大半。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后来又了第三种做法，据说也有不少公司采用，具体做法是把 Kubernetes 做一个虚拟机用，阉割其服务发现，DNS 等能力，用注册中心/配置中心等成熟且大规模应用的产品替代。唯品会前几天发的文章说明他们已经把这个做法在生产中落地了。这种做法一般只使用 POD 和 StatfuleSet，不创建服务和 Endpoints。一般来说，ISTIO 通过 Platform Adapter 对接注册中心，Config Adapter 对应配置中心。相比前两种做法，这个做法更加复杂，好处是成熟的配置中心和注册中心能够快速的落地 ISTIO，不用解决 ISTIO 由于 ETCD 存贮带来的扩展性问题。这个做法还有个变种就是完全不用 ISTIO，直接在 ENVOY/MOSN 上对接注册中心和配置中心，甚至完成 MIXER 的检查和遥测上报的能力。比如唯品会，用的是 DaemonSet，在同一个 Node 上共享 SIDECAR，其 SIDERCAR 组件 OSP Local Proxy 直接集成注册中心/配置中心。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后一个做法是我们努力的方向，向 Kubernetes 原生的方向发展，在生产环境中落地打磨，并和社区一起解决碰到的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;uc-的-uae-20-平台&#34;&gt;UC 的 UAE 2.0 平台&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspr1ugjqj30k00b9q4c_hu8818955179781058787.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspr1ugjqj30k00b9q4c_hu8492945078342692828.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspr1ugjqj30k00b9q4c_hu14566672893380864334.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspr1ugjqj30k00b9q4c_hu8818955179781058787.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;充分利用 Kubernetes 基础设施的能力是未来的方向，只要路走对了，就不怕远，比如说透明路由网络流量是方向，IPTABLES 是一个实现手段，它的性能不够好，那我们就通过引入 Cilium，用 EBPF 代替 IPTABLES。由于 BYPASS 了两次 TCP 协议栈道穿透，转发性能比常用的 loopback 地址 Workaround 方案还要好。更进一步，我们还能把 ISTIO 数据平面的同步检查逻辑，比如访问控制，通过 Cilium 推到内核的虚拟机中执行，从而解决 ISTIO 的另一的性能瓶颈。&lt;/p&gt;
&lt;p&gt;Kubernetes 已经成为了云原生的事实标准，我们应该充分利用 Kubernetes 的能力，借用社区的力量发展自己的技术。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprblc3fj30k00b975n_hu16220362156365582807.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprblc3fj30k00b975n_hu11159521711965864464.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprblc3fj30k00b975n_hu4763018455813835084.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprblc3fj30k00b975n_hu16220362156365582807.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Spring cloud kubernetes 项目给 Spring cloud 项目落地 Kubernetes 提供了支持，但是在整合 ISTIO 的时候碰到了问题，即便使用 Kubernetes 作为注册中心，客户端的负载均衡和服务发现组件也会破坏 ISTIO 对请求规格的依赖，经过负载均衡之后发送给 ISTIO 数据平面的 PODIP 无法被正确的路由的后端的集群，既无法匹配到 Virtual Host。我们通过 BeanFactoryPostProcesser 在请求中带上了 Host 头，指向服务在 Kubernetes 中的域名，从而解决了这个问题，也因此认识到，给微服务框架的 SDK 打补丁，或者说推动微服务框架轻量化可能是一个实现对业务代码无侵入性，必须的代价。&lt;/p&gt;
&lt;p&gt;Envoy 社区目前还没有对非 HTTP 的 RPC 通信协议提供扩展支持，SOFAMosn 目前内部已经基本完成了 DUBBO 扩展的开发工作。&lt;/p&gt;
&lt;p&gt;由于 ISTIO 的服务治理，路由规则都是针对 HTTP 协议定义的，当应用到基于接口，方法调用的 RPC 服务时，会有概念模型匹配的问题，比方说在定义 Content Based Routing 规则的时候。这里，我们选择了把 RPC 协议映射到 HTTP 上去而不是重新定义新的 RPC 路由的 CRD。&lt;/p&gt;
&lt;p&gt;RPC 服务的容器模型也是个麻烦问题，目前大规模使用的 RPC 框架都是从 SOA 发展过来的，基于的还是传统的容器模型。一个容器中往往同时存在多个服务，各自有自己的版本，ISTIO 基于版本的路由要求每个服务都有自己的 POD 和 Service 定义，否则的话 Traffic Splitting 功能就无法完成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprfuxzsj30k00b9q4d_hu6834315005988421866.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprfuxzsj30k00b9q4d_hu16300114127432366663.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprfuxzsj30k00b9q4d_hu8735329342328408307.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprfuxzsj30k00b9q4d_hu6834315005988421866.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;ISTIO 的控制平面抽象，顶层路由对象是 Virtual Host，Virtual Host 包含一组 Domain，通过 Domain 来选择 Virtual Host，Rate limit 也是定义在 Virtual Host 上面。&lt;/p&gt;
&lt;p&gt;在 Outbound，也就是客户端的 SIDECAR 收到请求的时候，ISTIO 为服务生成的 Virtual Host 包含了服务的域名，Cluster VIP 和 端口的多种组合形式，这个形式确保了对 Host 头和 DNS 寻址的支持。Inbound，也就是服务端的 SIDECAR 收到请求的时候因为所有流量都去到后面的服务实例，所以域名是通配所有。&lt;/p&gt;
&lt;p&gt;Route 上定义了超时，熔断，错误注入的策略。Route 上定义的 Header Matcher，Query Parameter Matcher, Path Matcher 等等都是针对 HTTP 协议的，RPC 协议需要进行映射以支持 Content Based Routing。&lt;/p&gt;
&lt;p&gt;Route Action 指向后端集群，支持重定向和直接返回，集群通过名字路由，集群的变动受到 Destination Rule 的影响，主要是反应在 Subset 的变化上，权重信息就定义在这里。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspruhzvvj30k00b9myc_hu6707057259151498689.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspruhzvvj30k00b9myc_hu497097143998307488.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspruhzvvj30k00b9myc_hu2822741639023362081.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspruhzvvj30k00b9myc_hu6707057259151498689.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFA 的注册中心使用 Interface 来识别服务的，服务的配置信息，消费者和提供者列表，以及超时等服务治理信息也定义在注册中心里面，可以认为是一个具备一定服务治理能力的注册中心。&lt;/p&gt;
&lt;p&gt;我们希望能够用 Interface 来调用服务，就是为了适应 RPC 框架的这个基于接口名字识别服务的概念模型。体现在 Kubernetes 里面就是用 Interface 名字当做域名，把请求头映射到 HTTP 头，请求参数映射到 Query Parameter，方法名映射到 Path 上。这样，基于 RPC 请求内容的服务治理就可以定义到方法和参数级别了，即便是蚂蚁金服站内复杂路由规则，比如 LDC 单元化流量调拨，也是可以支持的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusps37dvtj30k00b9gmv_hu13047260444244308097.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusps37dvtj30k00b9gmv_hu12636633453173127165.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusps37dvtj30k00b9gmv_hu1084801489110843602.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusps37dvtj30k00b9gmv_hu13047260444244308097.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们暂不考虑非 Kubernetes 平台的情况，以支持 DUBBO 作为例子&lt;/p&gt;
&lt;p&gt;如果不适用 k8 作为注册中心，需要引入 ZK。&lt;/p&gt;
&lt;p&gt;因为 ISTIO 目前还不支持 ZK，因此需要针对 DUBBO 的注册模型，与 SOFA 类似，通过 Platform Adapter 的方式加入对 DUBBO 的支持。&lt;/p&gt;
&lt;p&gt;如前所述，我们还需要修改 Pilot Discovery 的代码，正确的为 DUBBO 服务生成 Inbound 和 Outbound 的配置，比如 Listener 和 Cluster 的配置信息。我们还需要为把 ISTIO 的路由规则正确的转成 XDS 的路由配置信息。&lt;/p&gt;
&lt;p&gt;当然，我们还需要扩展 MOSN/ENVOY 来支持 DUBBO 协议，这里面有比较大的重复工作，而且还需要保证代码的执行性能。对于 MOSN 来说，需要自行实现 codec 和 stream 模块。&lt;/p&gt;
&lt;h2 id=&#34;3-sofamesh-的统一解决方案&#34;&gt;3. SOFAMesh 的统一解决方案&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspsg3qh9j30k00b9jsu_hu16312618883400769906.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspsg3qh9j30k00b9jsu_hu14907738259447040991.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspsg3qh9j30k00b9jsu_hu2398149953409114497.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspsg3qh9j30k00b9jsu_hu16312618883400769906.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;考虑到支持不同 RPC 框架的大量重复工作和实现过程中的性能保障，我们希望能提供一个统一的解决方案，以高性能和插件化做为重点来支持，并允许用户在性能和功能之间做平衡。&lt;/p&gt;
&lt;p&gt;这个方案是基于 Kubernetes Native 的方式来做的，使用 interface 来寻址服务，因此需要对客户端做轻量化，以做到不侵入用户的业务代码。&lt;/p&gt;
&lt;p&gt;轻量化客户端是要解决客户端 Loadbalance 引起的问题。&lt;/p&gt;
&lt;h2 id=&#34;4-dns-服务寻址方案&#34;&gt;4. DNS 服务寻址方案&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspt4o5olj30k00b9jsg_hu13441666143682676993.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspt4o5olj30k00b9jsg_hu17525694096838239829.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspt4o5olj30k00b9jsg_hu15439647577625112807.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspt4o5olj30k00b9jsg_hu13441666143682676993.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们会在 Kubernetes 的 DNS 之外额外做一层域名抽象，不受 Kubernetes 的规则的限制，比如，允许用户直接使用 interface 作为域名或者按照组织结构来规划域名的层级关系。Kubernetes 的 namespace 往往被用来作为多租户的解决方案，并不适合用来作为企业内不同部门的逻辑划分。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptd7pmnj30k00b9tab_hu13688558573679076632.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptd7pmnj30k00b9tab_hu11790562590045869109.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptd7pmnj30k00b9tab_hu9622582216435160738.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptd7pmnj30k00b9tab_hu13688558573679076632.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;有些微服务应用本身没有版本，版本反应在应用中的服务接口上，往往每个接口服务都有其独立的版本，比如 SOFA 应用，其版本体现在服务接口的实例上（参考 SOFA 应用注册中心结构）。&lt;/p&gt;
&lt;p&gt;蚂蚁主站内部在做蓝绿部署和灰度的时候，往往一次蓝绿发布会有多个应用参与，为了保证引流的准确性，我们会要求流量在整个调用的链路里面全部落到蓝或者绿的实例上，不允许出现交叉调用的情况。所以对于单应用多服务的场景，我们通过 POD label 把接口区分开来，从而做到流量在 POD 间调拨的粘性。&lt;/p&gt;
&lt;p&gt;服务将会被按照接口维度创建，接口的版本和名字会反应在 POD 的 Label 上，这样做会增加运维的工作量，但是可以通过 PAAS 平台提供的工具解决这个痛点。这里面一个隐含的要求是，一个 POD 只会提供一个接口的服务，推动业务走向 Kubernetes Native。&lt;/p&gt;
&lt;p&gt;对于按照 Kubernetes Native 方式创建的应用，应用只暴露一个接口，无需加上 interface 的标签。&lt;/p&gt;
&lt;p&gt;通过 CoreDNS 的 PDSQL 插件支持，为 Cluster VIP 额外添加一个 interface name 的记录。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptj489lj30k00b9759_hu16433665886122965081.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptj489lj30k00b9759_hu3872217267332257917.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptj489lj30k00b9759_hu16680495208647282009.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptj489lj30k00b9759_hu16433665886122965081.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们通过在 Destination Rule 中同时使用 Interface 和 Version 这两个 Label 来选择 Subset，每一个 Subset 都会在 Pilot Discovery 中形成一个可被路由的集群，这样通过 Subset 就可以完成 Traffic Splitting 的功能了。这样一来，蓝绿发布，灰度等能力都可基于这个 RPC 接口和版本来做了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptuwzptj30k00b9q4c_hu4107495960729917432.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptuwzptj30k00b9q4c_hu17135891330970984576.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptuwzptj30k00b9q4c_hu6706347651883611281.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptuwzptj30k00b9q4c_hu4107495960729917432.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;客户端向 Interface 域名发起请求，通过本地的 resolv.conf 文件指引到 CoreDNS 服务器进行域名解析，得到服务的 Cluster VIP。&lt;/p&gt;
&lt;p&gt;客户端以 Cluser VIP 发起请求，经过 IPTables 转发到 SOFAMosn 的 12220 端口。&lt;/p&gt;
&lt;p&gt;SOFAMosn 通过 socket 拿到 original destination 后，在此端口监听的 SOFA 协议 Listener，通过 Virtual Host 的域名找到正确的 Virtual Host。&lt;/p&gt;
&lt;p&gt;SOFAMosn 将请求按照 Pilot Discovery 下发的 Destination Rule 按照权重转发到不通的后端集群。&lt;/p&gt;
&lt;p&gt;Virtual Host 在生成的时候，其域名列表中会包含 Cluster VIP。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspucuaxcj30k00b9my3_hu451573533941362252.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspucuaxcj30k00b9my3_hu6379273054668459084.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspucuaxcj30k00b9my3_hu163569700659489113.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspucuaxcj30k00b9my3_hu451573533941362252.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在寻址方案中，我们为 RPC Service 创建了一个新的 CRD，并创建一个 RPC Service Controller 来 Watch RPC Service。&lt;/p&gt;
&lt;p&gt;RPC Service Controller 监听到 RPC Service 更新后，通过关联的 Service，按策略找到其中一个 POD，向其发起服务列表查询。请求到达 Register Agent，Agent 通过其协议插件从 APP 实例中获取到服务列表信息后返回给 RPC Service Controller。RPC Service Conroller 使用 RPC Service 接口和 Cluster VIP 更新 CoreDNS 中的域名记录。&lt;/p&gt;
&lt;h2 id=&#34;5-x-protocol-通用协议&#34;&gt;5. X-PROTOCOL 通用协议&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspul1v8bj30k00b9jsf_hu17284062735508450001.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspul1v8bj30k00b9jsf_hu9348056867570564781.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspul1v8bj30k00b9jsf_hu17875425300241092499.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspul1v8bj30k00b9jsf_hu17284062735508450001.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;七层代理的性能瓶颈往往是出现在协议数据包的解析上，由于 SIDECAR 的特殊性，它本身往往得不到足够的资源，不得不运行在资源首先的环境，以避免影响应用本身的运行。在实际的部署中，我们常常会把 SIDECARE 限定在单核心上运行，并且限制它能使用的最大内存，这些都让 SIDECAR 的转发性能面临极大的压力。考虑到 ISTIO 的复杂路由规则在实际的业务场景中很多时候并不会全部都用到，我们允许用户在性能和功能之间找到一个平衡。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusput21o3j30k00b9abg_hu9684513422796529262.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusput21o3j30k00b9abg_hu7517392465067516322.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusput21o3j30k00b9abg_hu1756168939180936597.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusput21o3j30k00b9abg_hu9684513422796529262.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个 Listener 的配置是参考 ISTIO 的 HTTP Connection Manager 做的，我们增加了 Downstream Protocol 和 Upstream Protocol 的配置，允许控制层面选择 SOFAMosn 之间的长连接的通行协议，比如使用 HTTP2，利用 HTTP2 的头部压缩能力提高协议的转发性能。x-protocol 配置项对应服务使用的真是通信协议，下发到 SOFAMosn 之后，SOFAMosn 通过分解 x-protocol 协议来进行适配真是请求协议，正确的加载协议插件进行协议处理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspv01mc0j30k00b93zp_hu11507408656968189489.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspv01mc0j30k00b93zp_hu10931303549045497438.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspv01mc0j30k00b93zp_hu897683235188365334.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspv01mc0j30k00b93zp_hu11507408656968189489.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先操作员在 Kubernetes 中创建 DUBBO 应用的服务，指定其 Port Name 为 x-dubbo-user，这很重要，也是 ISTIO 对 POD 的基本要求。SOFAMesh 监听到服务创建之后，开始在 Pilot 中创建 DUBBO 应用集群的 x-protocol 协议的监听器和集群配置，请参考上文的 x-protocol 配置。&lt;/p&gt;
&lt;p&gt;SOFAMosn SIDECAR 启动后，使用期静态配置的 Pilot 集群地址连接到 Pilot 并开始以 SIDECAR 模式，通过 ADS 接口监听配置的变化。&lt;/p&gt;
&lt;p&gt;SOFAMesh 把 Outbound / Inbound 的配置数据通过 ADS 接口发送给监听的 SOFAMosn 实例。&lt;/p&gt;
&lt;p&gt;Inbound 和 Outbound 的 SOFAMosn 之间建立 x-protocol/http2 协议的长连接，协议可以由下发的 x-protocol 配置指定，比如 HTTP2。目前 SOFAMosn 的 HTTP2 实现并还是 PingPong 模型，不推荐用作 SOFAMosn 之间的通信协议，下个 Milestone 改进后，应该是个更好的选择。&lt;/p&gt;
&lt;p&gt;DUBBO 请求数据进入 Outbound 的 Downstream 后，SOFAMosn 会生成一个自增的 stream id，并且从插件中拿到 request id，建立两个 id 的映射表，同时利用插件把 stream id 写到请求数据中。请求经过路由计算，路由到集群，到达 Upstream 后 SOFAMosn 创建一个 x-protocol 的请求对象，把整个 DUBBO 请求数据作为 Payload，附上自定义的头，发送给 上游 Inbound 的 SOFAMosn，并把从插件中拿到的 class name 和 method name 等信息记录到自定义的头中。&lt;/p&gt;
&lt;p&gt;请求数据到达 Inbound 的 Downstream 后，MOSN 会再生成一个自增的 stream id 并通过插件取出 request id，建立映射关系，并写入 stream id。经过路由匹配之后，请求通过 Upstream 发送给后端的服务实例。&lt;/p&gt;
&lt;p&gt;服务实例返回响应，Inbound 的 SOFAMosn 从响应中拿出 request id，通过 ID 映射找回实际的 request id，写回响应对象，然后把请求用 x-protocol 打包，通过 Downstream 返回给 Outbound 的 SOFAMosn。&lt;/p&gt;
&lt;p&gt;Outbound 的 SOFAMosn 收到响应后，拿出响应对象，并通过插件拿回 request id，最后通过 ID 映射关系找回实际的 request id，写回响应对象后，通过 Downstream 返回给应用实例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvmkhhvj30k00b9t9s_hu7234793034854938082.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvmkhhvj30k00b9t9s_hu6569544621153073128.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvmkhhvj30k00b9t9s_hu6662084023719539870.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvmkhhvj30k00b9t9s_hu7234793034854938082.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvsaykoj30k00b9dgv_hu4521163841925068360.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvsaykoj30k00b9dgv_hu9603127121451780024.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvsaykoj30k00b9dgv_hu17400788418378001115.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvsaykoj30k00b9dgv_hu4521163841925068360.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;获得不同层次的能力，所付出的性能开销和接入成本也会不同，可以根据实际情况做出取舍。Golang 的接口特性允许协议插件的开发人员根据需要实现接口，还可以进行接口的组合。&lt;/p&gt;
&lt;p&gt;开箱即用模式作为不解包方案，提供 LabelRouting，LabelAccessControl，LabelFaultInjection，TLS，RateLimits，Metrics 的能力，以高性能和低成本为亮点。&lt;/p&gt;
&lt;p&gt;轻度解包可以获得更多能力，如多路复用，Accesslog，流控，熔断等（视具体协议而定），是性能和能力间的权衡选择。&lt;/p&gt;
&lt;p&gt;更进一步，完全解除协议的头，可以获得将能力最大化，相对的性能开销和成本也同样最大化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvwky7ej30k00b93z9_hu7611410104593945482.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvwky7ej30k00b93z9_hu12950092997318766404.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvwky7ej30k00b93z9_hu12742739208590813439.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvwky7ej30k00b93z9_hu7611410104593945482.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;8 月底发布的 SOFMesh 版本默认将会用 SOFAMosn 代替 ENVOY 做数据平面，ISTIO 自带的 BookInfo 的例子可以提供给大家试用。我们后续还会提供 SOFA/DUBBO 应用的例子。&lt;/p&gt;
&lt;p&gt;目前 SOFAMosn 还不能在 Gateway 模式中使用，即不能用于 Ingress，而且部分高级路由功能，以及熔断，限流等高级治理能力目前还不支持。另外这个版本的 Mixer 节点也去除了，我们会在 9 月份的版本中持续完善 SOFAMosn 和 SOFAMesh，加入高级服务治理能力，同时我们也会完成 Mixer 的 Report 部分能力，放到开源版本中。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文首先介绍蚂蚁金服开源的 SOFAMesh，然后分享在 SOFAMesh 上落地 UC 的 HSF 应用和蚂蚁的 SOFA 应用碰到的问题，以及我们总结出来的解决方案和最佳实践。最后分别就其中有代表性的 DNS 寻址方案和 X-PROTOCOL 协议分享一下做法。希望大家内部的 DUBBO 或者其他功能内部的 RPC 应用在 Service Mesh 落地的时候，能够有个参考。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服开源 Go 语言版 Service Mesh 数据平面 SOFAMosn 性能报告</title>
      <link>https://cloudnativecn.com/blog/sofa-mosn-performance-report-0-1-0/</link>
      <pubDate>Mon, 20 Aug 2018 11:24:33 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/sofa-mosn-performance-report-0-1-0/</guid>
      <description>&lt;p&gt;以下的的性能报告为 SOFAMosn 0.1.0 在做 Bolt 与 HTTP1.x 协议的纯 TCP 转发上与 envoy 的一些性能对比数据，主要表现在 QPS、RTT、失败率/成功率等。&lt;/p&gt;
&lt;p&gt;本文原文来自 &lt;a href=&#34;https://github.com/sofastack/mosn/blob/master/docs/reference/PerformanceReport.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里需要强调的是，为了提高 SOFAMosn 的转发性能，在 0.1.0 版本中，我们做了如下的一些优化手段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在线程模型优化上，使用 worker 协程池处理 stream 事件，使用两个独立的协程分别处理读写 IO&lt;/li&gt;
&lt;li&gt;在单核转发优化上，在指定 &lt;code&gt;P=1&lt;/code&gt; 的情况下，我们通过使用 CPU 绑核的形式来提高系统调用的执行效率以及 cache 的 locality affinity&lt;/li&gt;
&lt;li&gt;在内存优化上，同样是在单核绑核的情况下，我们通过使用 SLAB-style 的回收机制来提高复用，减少内存 copy&lt;/li&gt;
&lt;li&gt;在 IO 优化上，主要是通过读写 buffer 大小以及读写时机和频率等参数的控制上进行调优&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下为具体的性能测试数据。&lt;/p&gt;
&lt;h1 id=&#34;tcp-代理性能数据&#34;&gt;TCP 代理性能数据&lt;/h1&gt;
&lt;p&gt;这里，针对相同的部署模式，我们分别针对上层协议为 &lt;code&gt;&amp;quot;Bolt(SofaRpc相关协议)&amp;quot;&lt;/code&gt; 与 &lt;code&gt;&amp;quot;HTTP1.1&amp;quot;&lt;/code&gt; 来进行对比&lt;/p&gt;
&lt;h2 id=&#34;部署模式&#34;&gt;部署模式&lt;/h2&gt;
&lt;p&gt;压测采用纯代理模式部署，client 进程通过 SOFAMosn 进程作为转发代理访问 server 进程。其中，client 进程，SOFAMosn 进程，server 进程分别运行在属于不同网段的机器中。client 直连访问 server 网络延时为 2.5ms 左右&lt;/p&gt;
&lt;h2 id=&#34;客户端&#34;&gt;客户端&lt;/h2&gt;
&lt;h3 id=&#34;bolt-协议-发送-1k-字符串&#34;&gt;bolt 协议 (发送 1K 字符串)&lt;/h3&gt;
&lt;p&gt;发送 Bolt 协议数据的客户端使用 &amp;ldquo;蚂蚁金服&amp;quot;内部开发的线上压力机，并部署 sofa rpc client。
通过压力机的性能页面，可反映压测过程中的 QPS、成功/失败次数，以及 RT 等参数。&lt;/p&gt;
&lt;h3 id=&#34;http11-协议-发送-1k-字符串&#34;&gt;HTTP1.1 协议 (发送 1K 字符串)&lt;/h3&gt;
&lt;p&gt;使用 ApacheBench/2.3, 测试指令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ab -n &lt;span class=&#34;nv&#34;&gt;$RPC&lt;/span&gt; -c &lt;span class=&#34;nv&#34;&gt;$CPC&lt;/span&gt; -p 1k.txt -T &lt;span class=&#34;s2&#34;&gt;&amp;#34;text/plain&amp;#34;&lt;/span&gt; -k http://11.166.161.136:12200/tcp_bench &amp;gt; ab.log.&lt;span class=&#34;nv&#34;&gt;$CPU_IDX&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;mesh-运行机器规格&#34;&gt;mesh 运行机器规格&lt;/h2&gt;
&lt;p&gt;mesh 运行在容器中，其中 CPU 为独占的一个逻辑核，具体规格如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;类别&lt;/th&gt;
          &lt;th&gt;信息&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;OS&lt;/td&gt;
          &lt;td&gt;3.10.0-327.ali2008.alios7.x86_64&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CPU&lt;/td&gt;
          &lt;td&gt;Intel(R) Xeon(R) CPU E5-2650 v2 @ 2.60GHz X 1&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;upstream-运行机器规格&#34;&gt;upstream 运行机器规格&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;类别&lt;/th&gt;
          &lt;th&gt;信息&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;OS&lt;/td&gt;
          &lt;td&gt;2.6.32-431.17.1.el6.FASTSOCKET&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CPU&lt;/td&gt;
          &lt;td&gt;Intel(R) Xeon(R) CPU E5620 @ 2.40GHz X 16&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;bolt-协议-测试结果&#34;&gt;Bolt 协议 测试结果&lt;/h2&gt;
&lt;h3 id=&#34;性能数据&#34;&gt;性能数据&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;指标&lt;/th&gt;
          &lt;th&gt;SOFAMosn&lt;/th&gt;
          &lt;th&gt;Envoy&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;QPS&lt;/td&gt;
          &lt;td&gt;103500&lt;/td&gt;
          &lt;td&gt;104000&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT&lt;/td&gt;
          &lt;td&gt;16.23ms&lt;/td&gt;
          &lt;td&gt;15.88ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;MEM&lt;/td&gt;
          &lt;td&gt;31m&lt;/td&gt;
          &lt;td&gt;18m&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CPU&lt;/td&gt;
          &lt;td&gt;100%&lt;/td&gt;
          &lt;td&gt;100%&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;
&lt;p&gt;可以看到，在单核 TCP 转发场景下，SOFAMosn 0.1.0 版本和 Envoy 1.7 版本，在满负载情况下的 QPS、RTT、成功数/失败数等性能数据上相差不大，后续版本我们会继续优化。&lt;/p&gt;
&lt;h2 id=&#34;http11-测试结果&#34;&gt;HTTP/1.1 测试结果&lt;/h2&gt;
&lt;p&gt;由于 HTTP/1.1 的请求响应模型为 PING-PONG，因此 QPS 与并发数会呈现正相关。下面分别进行不同并发数的测试。&lt;/p&gt;
&lt;h3 id=&#34;并发-20&#34;&gt;并发 20&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;指标&lt;/th&gt;
          &lt;th&gt;SOFAMosn&lt;/th&gt;
          &lt;th&gt;Envoy&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;QPS&lt;/td&gt;
          &lt;td&gt;5600&lt;/td&gt;
          &lt;td&gt;5600&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(mean)&lt;/td&gt;
          &lt;td&gt;3.549ms&lt;/td&gt;
          &lt;td&gt;3.545ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(P99)&lt;/td&gt;
          &lt;td&gt;4ms&lt;/td&gt;
          &lt;td&gt;4ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(P98)&lt;/td&gt;
          &lt;td&gt;4ms&lt;/td&gt;
          &lt;td&gt;4ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(P95)&lt;/td&gt;
          &lt;td&gt;4ms&lt;/td&gt;
          &lt;td&gt;4ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;MEM&lt;/td&gt;
          &lt;td&gt;24m&lt;/td&gt;
          &lt;td&gt;23m&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CPU&lt;/td&gt;
          &lt;td&gt;40%&lt;/td&gt;
          &lt;td&gt;20%&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;并发-40&#34;&gt;并发 40&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;指标&lt;/th&gt;
          &lt;th&gt;SOFAMosn&lt;/th&gt;
          &lt;th&gt;Envoy&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;QPS&lt;/td&gt;
          &lt;td&gt;11150&lt;/td&gt;
          &lt;td&gt;11200&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(mean)&lt;/td&gt;
          &lt;td&gt;3.583ms&lt;/td&gt;
          &lt;td&gt;3.565ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(P99)&lt;/td&gt;
          &lt;td&gt;4ms&lt;/td&gt;
          &lt;td&gt;4ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(P98)&lt;/td&gt;
          &lt;td&gt;4ms&lt;/td&gt;
          &lt;td&gt;4ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(P95)&lt;/td&gt;
          &lt;td&gt;4ms&lt;/td&gt;
          &lt;td&gt;4ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;MEM&lt;/td&gt;
          &lt;td&gt;34m&lt;/td&gt;
          &lt;td&gt;24m&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CPU&lt;/td&gt;
          &lt;td&gt;70%&lt;/td&gt;
          &lt;td&gt;40%&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;并发-200&#34;&gt;并发 200&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;指标&lt;/th&gt;
          &lt;th&gt;SOFAMosn&lt;/th&gt;
          &lt;th&gt;Envoy&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;QPS&lt;/td&gt;
          &lt;td&gt;29670&lt;/td&gt;
          &lt;td&gt;38800&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(mean)&lt;/td&gt;
          &lt;td&gt;5.715ms&lt;/td&gt;
          &lt;td&gt;5.068ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(P99)&lt;/td&gt;
          &lt;td&gt;16ms&lt;/td&gt;
          &lt;td&gt;7ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(P98)&lt;/td&gt;
          &lt;td&gt;13ms&lt;/td&gt;
          &lt;td&gt;7ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(P95)&lt;/td&gt;
          &lt;td&gt;11ms&lt;/td&gt;
          &lt;td&gt;6ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;MEM&lt;/td&gt;
          &lt;td&gt;96m&lt;/td&gt;
          &lt;td&gt;24m&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CPU&lt;/td&gt;
          &lt;td&gt;100%&lt;/td&gt;
          &lt;td&gt;95%&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;并发-220&#34;&gt;并发 220&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;指标&lt;/th&gt;
          &lt;th&gt;SOFAMosn&lt;/th&gt;
          &lt;th&gt;Envoy&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;QPS&lt;/td&gt;
          &lt;td&gt;30367&lt;/td&gt;
          &lt;td&gt;41070&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(mean)&lt;/td&gt;
          &lt;td&gt;8.201ms&lt;/td&gt;
          &lt;td&gt;5.369ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(P99)&lt;/td&gt;
          &lt;td&gt;20ms&lt;/td&gt;
          &lt;td&gt;9ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(P98)&lt;/td&gt;
          &lt;td&gt;19ms&lt;/td&gt;
          &lt;td&gt;8ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;RT(P95)&lt;/td&gt;
          &lt;td&gt;16ms&lt;/td&gt;
          &lt;td&gt;8ms&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;MEM&lt;/td&gt;
          &lt;td&gt;100m&lt;/td&gt;
          &lt;td&gt;24m&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;CPU&lt;/td&gt;
          &lt;td&gt;100%&lt;/td&gt;
          &lt;td&gt;100%&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;结论-1&#34;&gt;结论&lt;/h3&gt;
&lt;p&gt;可以看到，在上层协议为 HTTP/1.X 时，SOFAMosn 的性能和 Envoy 的性能 存在一定差距，对于这种现象我们的初步结论为：在 PING-PONG 的发包模型下，MOSN 无法进行 read/write 系统调用合并，相比 sofarpc 可以合并的场景，syscall 数量大幅上升，因此导致相比 sofarpc 的场景，http 性能上相比 envoy 会存在差距。针对这个问题，在 0.2.0 版本中，我们会进行相应的优化。&lt;/p&gt;
&lt;h1 id=&#34;附录&#34;&gt;附录&lt;/h1&gt;
&lt;h2 id=&#34;envoy-版本信息&#34;&gt;envoy 版本信息&lt;/h2&gt;
&lt;p&gt;version:1.7 tag:1ef23d481a4701ad4a414d1ef98036bd2ed322e7&lt;/p&gt;
&lt;h2 id=&#34;envoy-tcp-测试配置&#34;&gt;envoy tcp 测试配置&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;static_resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.0.0.0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;12200&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;filter_chains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;filters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy.tcp_proxy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;stat_prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ingress_tcp&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;sofa_server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;clusters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;sofa_server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;connect_timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;25s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;lb_policy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;round_robin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.210.168.5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;12222&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.210.168.5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;12223&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.210.168.5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;12224&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.210.168.5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;12225&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;admin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;access_log_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/dev/null&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.0.0.0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Service Mesh 数据平面 SOFAMosn 深层揭秘</title>
      <link>https://cloudnativecn.com/blog/sofa-mosn-deep-dive/</link>
      <pubDate>Thu, 02 Aug 2018 14:31:43 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/sofa-mosn-deep-dive/</guid>
      <description>&lt;p&gt;MOSN GitHub 地址：https://github.com/sofastack/mosn&lt;/p&gt;
&lt;p&gt;本文作者：朵晓东，花名奕杉，蚂蚁金服高级技术专家，专注云计算技术及产品。Apache Kylin 创始团队核心成员，蚂蚁金融云 PaaS 创始团队核心成员，Antstack 网络产品负责人，SOFAMesh 创始团队核心成员。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-朵晓东-service-mesh-meetup&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;朵晓东 service mesh meetup&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvf883plij30sg0j0n1e_hu6242168963494692018.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvf883plij30sg0j0n1e_hu8009748751443730616.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvf883plij30sg0j0n1e_hu922402134037771932.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvf883plij30sg0j0n1e_hu6242168963494692018.webp&#34;
               width=&#34;760&#34;
               height=&#34;508&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      朵晓东 service mesh meetup
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本文是基于作者在第二届 Service Mesh Meetup 的主题分享《蚂蚁金服 Service Mesh 数据平面 SOFAMosn 深层解密》部分内容所整理，以下是具体内容。关于本次 meetup 的情况请访问&lt;a href=&#34;https://cloudnativecn.com/blog/beijing-meetup-20180729/&#34;&gt;第二届 Service Mesh Meetup 北京站回顾&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;今天给大家带来的分享内容是蚂蚁金服 Service Mesh 数据平面 SOFAMosn 深层揭秘。&lt;/p&gt;
&lt;p&gt;承接小剑老师月初《大规模微服务架构下的 ServiceMesh 探索之路》对 SOFAMosn 的分享，本次聚焦在数据平面在蚂蚁落地的思考和探索。&lt;/p&gt;
&lt;h3 id=&#34;背景&#34;&gt;背景&lt;/h3&gt;
&lt;p&gt;上一次分享小剑老师已经介绍了 SOFAMesh 的技术选型，以及我们在开源和自研方面的一些权衡。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;呼应这个话题我们首先来看一下为什么蚂蚁会选择 Service Mesh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;重点归纳为-4-个方面&#34;&gt;重点归纳为 4 个方面：&lt;/h4&gt;
&lt;p&gt;蚂蚁正在全面拥抱微服务，云原生，不管是 SOFA5，还是兼容 K8S 的容器平台 Sigma 落地，Service Mesh 都是不可获取的重要组件。&lt;/p&gt;
&lt;p&gt;其次，蚂蚁的运维体系在服务层面基于流量调度工作，比如说 LDC 架构在逻辑 zone 间的调度流量，再比如弹性伸缩，本质上也是在异构机房间调度流量，此外还有像逻辑 zone 蓝绿发布，机房容灾等都需要在流量调度能力上更健壮，更灵活，更具扩展性。&lt;/p&gt;
&lt;p&gt;此外，由于蚂蚁的金融属性，我们在服务鉴权等方面有更严格的要求，比如说国密的落地，加密卡内的证书管理，加解密等方面，不止要求更高的安全级别，还要有承载大流量的能力。同时我们看到，zero trust 网络架构也在加速发展，这与我们的诉求不谋而合。&lt;/p&gt;
&lt;p&gt;最后，蚂蚁内部技术栈多样，但多种语言体系融合仍然成本很高。举个例子，非 SOFA 语言与 SOFA 互通要理解配置中心，SOFARPC 的序列化等逻辑，如果在生产环境部署还要理解 LDC 路由规则，而这些共性需求都可以通过下沉到 Mesh 体系来解决。&lt;/p&gt;
&lt;p&gt;了解 SOFAMesh 的同学应该知道，蚂蚁选择了使用 Golang 自研数据平面，做这个决定我们重点考虑了未来的技术选型，跨团队研发效率，蚂蚁现有技术体系，运维体系等因素；同时通过调研和验证，Golang 版本的性能也是我们可以接受的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接下来，我会向大家介绍由蚂蚁和 UC 联合研发的 Mesh 数据平面，我们为它取名 &lt;strong&gt;SOFAMosn&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;架构设计&#34;&gt;架构设计&lt;/h3&gt;
&lt;p&gt;首先我们由浅入深看一下 &lt;strong&gt;SOFAMosn&lt;/strong&gt; 的架构设计&lt;/p&gt;
&lt;h4 id=&#34;1-sofamesh-的整体架构&#34;&gt;1. SOFAMesh 的整体架构&lt;/h4&gt;
&lt;p&gt;大家看到的图示是基于 Istio 的架构，在数据平面我们使用 SOFAMosn 替代了 Envoy，同时加入了一些蚂蚁实践中摸索的改进，比如说 Mixer 的位置，我们考虑把 Mixer 下沉到 SOFAMosn，比如说对 SOFA，DUBBO 协议的支持等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcgxiw5cj31kw0zk45v_hu18098472500891371317.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcgxiw5cj31kw0zk45v_hu2583400818598488899.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcgxiw5cj31kw0zk45v_hu1894932208068549724.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcgxiw5cj31kw0zk45v_hu18098472500891371317.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;0.1.0 版本的 SOFAMosn 支持了 xDS V0.4 api 核心能力，重点支持了 SOFARPC 协议，并在蚂蚁内部在生产环境使用；同时支持了 HTTP/1.1，HTTP/2.0 的基本功能，但目前暂未在生产环境使用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchc91q9j31kw0zkgs2_hu9578178937322324276.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchc91q9j31kw0zkgs2_hu10394852240535598213.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchc91q9j31kw0zkgs2_hu18165818015230543494.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchc91q9j31kw0zkgs2_hu9578178937322324276.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;2-sofamosn-的核心设计思路&#34;&gt;2. SOFAMosn 的核心设计思路&lt;/h4&gt;
&lt;p&gt;首先，将 SOFAMosn 作为代理处理的数据流划分为 4 层，在入方向数据依次经过网络 IO 层，二进制协议处理层，协议流程处理层，转发路由处理层；出向与入向过程基本相反。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchpmtzoj31kw0zkq9h_hu10708909369678717538.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchpmtzoj31kw0zkq9h_hu4249286923747128654.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchpmtzoj31kw0zkq9h_hu13056512626564519203.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvchpmtzoj31kw0zkq9h_hu10708909369678717538.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;了解了分层的基本思路，具体介绍一下各层的具体职能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IO 层&lt;/strong&gt;提供了 IO 读写的封装以及可扩展的 IO 事件订阅机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PROTOCOL 层&lt;/strong&gt;提供了根据不同协议对数据进行序列化/反序列化的处理能力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STREAMING 层&lt;/strong&gt;提供向上的协议一致性，负责 STREAM 生命周期，管理 Client / Server 模式的请求流行为，对 Client 端 stream 提供池化机制等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Proxy 层&lt;/strong&gt;提供路由选择，负载均衡等的能力，让前后端 stream 流转起来。大家可以从这张图清晰的看到单向请求流转的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcj3iaa9j31kw0zkn5w_hu16617897863525435079.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcj3iaa9j31kw0zkn5w_hu2451777179279780049.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcj3iaa9j31kw0zkn5w_hu17053003911829703678.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcj3iaa9j31kw0zkn5w_hu16617897863525435079.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;3-了解了分层设计及转发流程我们再看一下线程模型&#34;&gt;3. 了解了分层设计及转发流程，我们再看一下线程模型&lt;/h4&gt;
&lt;p&gt;我们先看看 0.1.0 版本的线程模型，可以看到每个链接的 IO 协程是成对出现的，读协程负责读取，事件机制及 Codec 逻辑，数据上升到 steam 层，具体的 stream 事件由独立的常驻 worker 协程池负责处理。在 0.2.0 版本中我们将会进行多核优化，读协程将不再负责 codec 逻辑，将转发由 codec worker pool 来进行。从发展方向上看，我们会借鉴 SEDA 的思路，将转发流程中每一阶段的处理抽象为一个 stage，通过 task queue，worker 协程池，controller 的机制来对每一个阶段进行处理。从技术实现上看，Golang 实现 SEDA 机制的组件也更简单。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjbqg8zj31kw0zkn5c_hu10350450550900637399.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjbqg8zj31kw0zkn5c_hu5801734796829727921.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjbqg8zj31kw0zkn5c_hu2357041168925447899.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjbqg8zj31kw0zkn5c_hu10350450550900637399.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjhuyiuj31kw0zkgu6_hu1657740405236911433.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjhuyiuj31kw0zkgu6_hu17566035800523799376.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjhuyiuj31kw0zkgu6_hu491309615219245674.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjhuyiuj31kw0zkgu6_hu1657740405236911433.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;4-sofamosn-的模块划分&#34;&gt;4. SOFAMosn 的模块划分&lt;/h4&gt;
&lt;p&gt;除了刚才介绍了 4 个核心模块，还有如路由模块负责请求的路由寻址，后端管理模块负责管理后端的生命周期，健康度等。其中蓝色的框是 SOFAMosn 0.1.0 会涉及到的功能模块，红色的虚线框是我们规划去实现，或实验的一些 topic。这方面也欢迎大家加入我们一起来建设。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjr017oj31kw0zkqju_hu6900901711139304089.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjr017oj31kw0zkqju_hu12220287180586625008.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjr017oj31kw0zkqju_hu5838007405200783066.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcjr017oj31kw0zkqju_hu6900901711139304089.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后总结一下，模块化，分层解耦是 SOFAMosn 设计的初衷，此外可编程性，事件机制，扩展性，高吞吐量，都是设计中的重要考量因素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;sofamosn-核心能力&#34;&gt;SOFAMosn 核心能力&lt;/h3&gt;
&lt;p&gt;介绍完结构设计方面的一些思路，我们来看看 SOFAMosn 0.1.0 的核心能力。&lt;/p&gt;
&lt;p&gt;在网络核心能力方面，我们将 IO 处理相关能力封装抽象成可编程接口，这部分我们已经做过性能优化，可以单独使用；SOFAMosn 提供了内置的 TCP 代理功能，也做过性能优化，可单独使用；此外 SOFAMosn 支持 TLS 链路加密，目前复用了 Golang 的实现，后面的章节会介绍 Golang TLS 性能实验。SOFAMosn 可以配合 iptables 透明转发支持 TProxy 模式。同时，MOSN 支持平滑 reload，平滑升级。&lt;/p&gt;
&lt;p&gt;在多协议方面，0.1.0 版本中 SOFAMosn 重点支持 SOFARPC，并已运用在蚂蚁生产环境中。同时 SOFAMosn 支持HTTP/1.1，HTTP/2.0 的基本功能，实现方式是使用开源的 HTTP/1.1实现 FastHTTP 和 Golang 自带的 HTTP2 实现。由于 FastHTTP 和 HTTP2 都自带了 IO，链接池等功能，所以这两个协议的支持暂时是脱离 SOFAMosn 整体设计的，性能等方面也还没有做优化，我们会在后续版本迭代考虑将其纳入到 SOFAMosn 的框架体系，并进行性能优化。此外，我们正在研发 Dubbo，HSF 的支持，会在后续版本中推出。同时，目前已支持的 SOFARPC，HTTP/1.1，HTTP/2.0 都支持 Mes h 间的 TLS 链路加密。&lt;/p&gt;
&lt;p&gt;此处，在核心路由方面，0.1.0 版本 SOFAMosn 在核心功能上对齐 Envoy，支持 virtual host 匹配，支持 route match 匹配，支持 subset 路由匹配/负载均衡。&lt;/p&gt;
&lt;p&gt;在后端管理功能方面，支持基础负载均衡算法，支持主动健康检查等必须功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvck8jjfgj31kw0zkgu4_hu12066339168969462893.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvck8jjfgj31kw0zkgu4_hu5239803965960529371.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvck8jjfgj31kw0zkgu4_hu8809168948492953733.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvck8jjfgj31kw0zkgu4_hu12066339168969462893.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除核心功能外，SOFAMosn 根据我们落地的一些经验提供了一些亮点功能。&lt;/p&gt;
&lt;p&gt;首先，SOFAMosn 支持 X-PROTOCOL，一种更轻量级的方式支持自定义 RPC 协议，对于无需解包的相对简单的场景，将 RPC 数据作为 TCP 或者 HTTP/2.0 的 payload 进行转发，同时支持所有无需解包的路由负载策略。&lt;/p&gt;
&lt;p&gt;同时我们计划在 X-PROTOCOL 中加入编解码扩展点，支持需要解包的场景。在平滑升级的支持上，除了经典的传递 listener fd+ 协议层等待方式，SOFAMosn 支持对存量链接进行协议无关的迁移。同时为了部署升级，SOFAMosn 支持指定 / 更新前后端通信协议。&lt;/p&gt;
&lt;p&gt;在 Istio 集成方案上，SOFAMosn 0.1.0 支持 Istio 0.8 版本 Pilot V0.4API 全动态配置运行，支持 xDS on ADS 核心功能，后续版本会不断补齐功能。SOFAMosn 同时支持静态配置模型运行。&lt;/p&gt;
&lt;p&gt;除了能力支持，SOFAMosn 在网络层，协议处理层，基于 TCP 的私有协议层都提供了可扩展的能力，使得自定义业务可以优雅集成。在蚂蚁落地的过程中我们内部的 SOFAMosn 依赖于开源版本，通过可扩展的方式来实现蚂蚁内部的自有业务，在工程落地上提供了可行的方案。&lt;/p&gt;
&lt;h3 id=&#34;性能&#34;&gt;性能&lt;/h3&gt;
&lt;p&gt;在介绍了核心功能以后，我们再看另一个大家非常关注的问题，性能，这也是目前关注度较高的问题之一。&lt;/p&gt;
&lt;p&gt;在 SOFAMosn 0.1.0 版本，我们重点优化了基于 SOFAMosn 整体框架的协议在 Sidecar 模式下单核转发的性能，即 TCP，SOFARPC 的单核转发性能。&lt;/p&gt;
&lt;p&gt;首先我们分享一下我们在单核场景下优化的一些手段和经验。我们使用的方式主要是独占绑核，内存，IO，调度等方面进行优化。&lt;/p&gt;
&lt;p&gt;首先看绑核，在指定 P=1 的情况下，独占绑核不论在系统调用执行效率，cache locality affinity 两个方面都比更表现更好，整体吞吐量提升大约 30%。其次是内存优化，我们采样了 SLAB-style 的回收机制来提高复用，减少内存 copy；&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckkrfijj31kw0zkam1_hu7827382368799083324.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckkrfijj31kw0zkam1_hu12305420187729447814.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckkrfijj31kw0zkam1_hu2805476789601602024.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckkrfijj31kw0zkam1_hu7827382368799083324.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;同时在内存分配上需要考虑 Golang 内存模型的亲和性，尽量减少 arena 区内存申请；最后，大家都知道 Golang 的 GC 需要是你要去熟悉并适应他的，很多细节需要关注，尽量减少 GC scanobject 的压力。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckray2rj31kw0zk7ek_hu13166811526249963553.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckray2rj31kw0zk7ek_hu2668977473407394653.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckray2rj31kw0zk7ek_hu17981241682463726296.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvckray2rj31kw0zk7ek_hu13166811526249963553.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 IO 方案，Golang 的 IO 模型是同步化的，在读方面既要尽可能多读，又要避免频繁调用 SetReadDeadline 造成的的影响，在我们压测下面频繁调用 SetReadDeadline 会对吞吐量有一定影响。在写方面需要适度 buffer，例如由多 worker 协程驱动造成某个 IO 协程频繁写系统 IO 也会造成吞吐量下降。另一个需要注意的方面是，在多协程场景下需要避免读写频率不均衡，这也是造成整体吞吐量下降的一个潜在原因。另外，如果读或写大量触发，会造成大量系统调用，这会引起 Golang runtime 调度成本升高。在 Golang runtime 调度方面，首先会触发协程调度造成时间消耗，同时 runtime 调度本身没有 OS 线程调度灵敏，也会有一定的时间损耗。同时 OS 系统调用本身也有会耗时，会造成性能下降。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里我分享一些我们在性能优化过程中遇到的真实的 case&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;除了 IO 方面的思考，还要关注一下调度均衡方面的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们利用协程池化来避免 runtime.morestack 的问题，其次在单核场景下需要重点关注 G 是否在饥饿状态，造成资源浪费。&lt;/p&gt;
&lt;p&gt;介绍完性能优化的一些过程，我们来看一下目前我们在性能优化上的一些结果，即单核 TCP 转发的性能，和单核 SOFARPC 转发的性能。可以看到，在单核 TCP 转发场景，SOFAMosn 0.1.0 版本和 Envoy 1.7 版本转发性能差距可控，后续版本我们会继续优化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcl25xaej31kw0zkdmu_hu18090935774821982131.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcl25xaej31kw0zkdmu_hu1292977998135530810.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcl25xaej31kw0zkdmu_hu1632212800982697429.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcl25xaej31kw0zkdmu_hu18090935774821982131.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclh0lu9j31kw0zktgn_hu13876980465614908623.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclh0lu9j31kw0zktgn_hu14558319777267219653.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclh0lu9j31kw0zktgn_hu16489833130773119366.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclh0lu9j31kw0zktgn_hu13876980465614908623.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，前面提到过 TLS 的实现，我们再来看一下性能方面的一些探索。首先介绍了一下测试的场景。在这个场景下，我们发现对于 ECDHE 算法，Golang 原生的实现性能虽然低于 Ningx（使用 OpenSSL），但是高于 Golang with boring SSL。通过对具体算法和协议的性能压测，代码调研我们得出如下结论。可以看出对于 ECDHE-P256 加密套件，Golang 原生实现的性能是很不错的，可以放心使用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclp075yj31kw0zkdm4_hu11168591108216843221.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclp075yj31kw0zkdm4_hu6777181870359558538.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclp075yj31kw0zkdm4_hu13308726128602543069.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclp075yj31kw0zkdm4_hu11168591108216843221.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;除了这些优化点以后，我们会在后续版本持续进行性能优化，多核优化，内存优化，同时利用用户态，内核态的加速技术来提升 SOFAMosn 的转发性能。在 TLS 加解密方面，我们将会尝试基于本地加速卡和 Keyless 架构的 Offload 加速，这也是我们在蚂蚁网络从中已经落地的一些技术手段。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclv2763j31kw0zkn4s_hu16457416032041821258.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclv2763j31kw0zkn4s_hu3872326076786011173.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclv2763j31kw0zkn4s_hu16335960443483736136.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvclv2763j31kw0zkn4s_hu16457416032041821258.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;roadmap&#34;&gt;RoadMap&lt;/h3&gt;
&lt;p&gt;最后我介绍一下 SOFAMosn 的 RoadMap（时间为大体范围，具体发布请关注本公众号）：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcm43sg5j31kw0sp1kx_hu17396866437187217410.webp 400w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcm43sg5j31kw0sp1kx_hu16224828891650852280.webp 760w,
               /blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcm43sg5j31kw0sp1kx_hu16587062960677746521.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/sofa-mosn-deep-dive/0069RVTdgy1ftvcm43sg5j31kw0sp1kx_hu17396866437187217410.webp&#34;
               width=&#34;760&#34;
               height=&#34;383&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;8 月第一周我们将发布 SOFAMesh 0.1.0 版本，这个版本重点支持 Proxy 核心能力，支持 xDS V0.4 API 核心功能，支持 SOFARPC 等通信协议。&lt;/p&gt;
&lt;p&gt;8 月底我们将发布 0.2.0 版本，在不断完善提升核心能力的基础上，我们会完善 X-Protocol 的功能和扩展性，以支持私有 RPC 协议扩展；同时我们将支持 Dubbo/HSF 通讯协议，并接入基于 ZK 的服务注册中心。同时我们将重点加强 HTTP/2.0 的功能，性能优化。我们还将支持 K8S operator，使得 SOFA Mesh 可以接入 K8S 资源。&lt;/p&gt;
&lt;p&gt;除功能性补强以外，我们会持续优进行性能优化，重点在多核性能，整体内存优化。此外，我们会持续推进代码优化，完善测试等基础性工作。&lt;/p&gt;
&lt;p&gt;9 月底我们将发布 0.3.0，重点提供 Mixer 集成，提供 precondition，quota，report 功能。同时在 9 月提供熔断和限流的能力。&lt;/p&gt;
&lt;p&gt;目前 SOFAMosn 仍然是一个初级版本，我们将持续投入补充，改进，优化，也欢迎开源社区感兴趣的朋友一起加入 SOFAMesh 开源版的建设。&lt;/p&gt;
&lt;h3 id=&#34;补充&#34;&gt;补充&lt;/h3&gt;
&lt;p&gt;本文基于作者在 Service Mesh Meetup #2 分享的部分内容所整理，现场分享的 PPT 以及视频，可以在 &lt;a href=&#34;https://www.itdks.com/eventlist/detail/2455&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IT 大咖说&lt;/a&gt;观看；&lt;/p&gt;
&lt;p&gt;PPT 下载地址：https://github.com/servicemesher/meetup-slides&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服开源 SOFAMesh—一款基于 Istio 改进和扩展而来的 Service Mesh 大规模落地实践方案</title>
      <link>https://cloudnativecn.com/blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/</link>
      <pubDate>Mon, 16 Jul 2018 15:51:34 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/</guid>
      <description>&lt;p&gt;4 月，蚂蚁金服自主研发的分布式中间件（Scalable Open Financial Architecture，以下简称 SOFA）启动开源计划，并开放多个组件，（相关背景请点击链接阅读《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI0Nzc3MTQyMw==&amp;amp;mid=2247484729&amp;amp;idx=1&amp;amp;sn=0d8dbee2739fb0eef3e4ad699661fd13&amp;amp;chksm=e9abbd49dedc345fd5d6898fd1989710f249d6386bf3d52ae1603365a4a1c3696538bc8b9a8f&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开源 |蚂蚁金服启动分布式中间件开源计划，用于快速构建金融级云原生架构&lt;/a&gt;》、《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI0Nzc3MTQyMw==&amp;amp;mid=2247485026&amp;amp;idx=1&amp;amp;sn=0a367bc67d5fe3a268e3715b17e020ab&amp;amp;chksm=e9abbe12dedc370489102d9307b832457891fdb0530eec5c35c0fb82bc2a3e6dbbc7db8436c4&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开源 | 蚂蚁金服分布式中间件开源第二弹：丰富微服务架构体系&lt;/a&gt;》），这一系列的动作受到大家的关注和支持，SOFA 社区也日益壮大。&lt;/p&gt;
&lt;p&gt;在两轮开源之后，蚂蚁金服自主研发的分布式中间件（Scalable Open Financial Architecture，以下简称 SOFA）在今天推出了&lt;strong&gt;第三轮的开源产品：SOFAMesh&lt;/strong&gt;。和前两轮开源的历经多年沉淀和打磨的成熟产品不同，本轮的开源主角 SOFAMesh，将探索一条和以往产品有所不同的开源道路。下面我们就来看看到底有哪些不同吧！&lt;/p&gt;
&lt;h2 id=&#34;sofamesh-的开源探索之路&#34;&gt;SOFAMesh 的开源探索之路&lt;/h2&gt;
&lt;p&gt;SOFAMesh 尝试在以下几个方面进行自我突破和勇敢探索：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全新的技术领域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Service Mesh 是目前技术社区最为炙手可热的新技术方向，有下一代微服务的明显趋势。但是目前 Service Mesh 技术还处于发展早期，暂时还没有成熟的产品，尤其缺乏大规模的落地实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;较早的开源时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上述背景下，我们选择了将启动不久的 Service Mesh 产品开源在开发早期，也就是还未成熟之时，就对社区开放，开放源码并寻求社区合作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更加开放的态度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 SOFAMesh 上，我们愿意以开源共建的方式来和社区一起推进 Service Mesh 技术的更好发展和实现落地实践，共同打造一个技术先进，功能丰富，具备良好的性能和稳定性，可以实实在在的生产落地的优秀产品。欢迎国内技术社区的朋友们和我们开展不同层面的交流与合作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;务实的产品路线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SOFAMesh 在产品路线上，选择了跟随社区主流，我们选择了目前 Service Mesh 中最有影响力和前景的 Istio。SOFAMesh 会在 Istio 的基础上，提升性能，增加扩展性，并在落地实践上做探索和补充，以弥补目前 Istio 的不足，同时保持与 Istio 社区的步骤一致和持续跟进。&lt;/p&gt;
&lt;h3 id=&#34;sofamesh-介绍&#34;&gt;SOFAMesh 介绍&lt;/h3&gt;
&lt;p&gt;SOFAMesh 将在兼容 Istio 整体架构和协议的基础上，做出部分调整：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sofamesh-architecture&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SOFAMesh architecture&#34; srcset=&#34;
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tNbRwgy1fuyr4vizzwj31kw1biq98_hu13045568273907294865.webp 400w,
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tNbRwgy1fuyr4vizzwj31kw1biq98_hu12133529127151143290.webp 760w,
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tNbRwgy1fuyr4vizzwj31kw1biq98_hu15553107502916656035.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tNbRwgy1fuyr4vizzwj31kw1biq98_hu13045568273907294865.webp&#34;
               width=&#34;760&#34;
               height=&#34;635&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SOFAMesh architecture
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;使用 Golang 语言开发全新的 Sidecar，替代 Envoy&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为了避免 Mixer 带来的性能瓶颈，合并 Mixer 部分功能进入 Sidecar&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pilot 和 Citadel 模块进行了大幅的扩展和增强&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们的目标：打造一个更加务实的 Istio 落地版本！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：以上架构调整的细节以及我们做调整的出发点和原因，请浏览 &lt;a href=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/&#34;&gt;蚂蚁金服大规模微服务架构下的 Service Mesh 探索之路&lt;/a&gt;（可点击查看）一文，有非常详尽的解释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;开源内容&#34;&gt;开源内容&lt;/h3&gt;
&lt;p&gt;在本轮开源中，我们将推出 SOFAMesh 目前正在开发的两大模块：MOSN 和 SOFAPilot。&lt;/p&gt;
&lt;h4 id=&#34;1mosn&#34;&gt;1.MOSN&lt;/h4&gt;
&lt;p&gt;SOFAMesh 中 Golang 版本的 Sidecar，是一个名为 MOSN(Modular Observable Smart Netstub) 的全新开发的模块，实现 Envoy 的功能，兼容 Envoy 的 API，可以和 Istio 集成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sofamesh-mosn&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SOFAMesh MOSN&#34; srcset=&#34;
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75ot24lzj31ec18479s_hu17347057104099349195.webp 400w,
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75ot24lzj31ec18479s_hu11814029116279666506.webp 760w,
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75ot24lzj31ec18479s_hu1930245410041566199.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75ot24lzj31ec18479s_hu17347057104099349195.webp&#34;
               width=&#34;760&#34;
               height=&#34;666&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SOFAMesh MOSN
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，我们会增加对 SOFARPC、Dubbo 等通讯协议的支持，以便更好的迎合国内用户包括我们自身的实际需求。&lt;/p&gt;
&lt;p&gt;由于 Sidecar 相对独立，而且我们也预期会有单独使用 MOSN 的场景，因此 MOSN 的代码仓库是独立于 SOFAMesh 的，地址为：https://github.com/alipay/sofa-mosn&lt;/p&gt;
&lt;p&gt;欢迎大家使用，提供需求、反馈问题、贡献代码或者合作开发。&lt;/p&gt;
&lt;h3 id=&#34;2sofapilot&#34;&gt;2.SOFAPilot&lt;/h3&gt;
&lt;p&gt;我们将大幅扩展和增强 Istio 中的 Pilot 模块：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sofamesh-pilot-architecture&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SOFAMesh Pilot architecture&#34; srcset=&#34;
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75pq8rplj31kw19sn5q_hu3382465311163099153.webp 400w,
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75pq8rplj31kw19sn5q_hu7505699493610745020.webp 760w,
               /blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75pq8rplj31kw19sn5q_hu3227025147099373762.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/introducing-sofamesh-a-solution-for-large-scale-service-mesh-by-ant-financial/006tKfTcgy1ft75pq8rplj31kw19sn5q_hu3382465311163099153.webp&#34;
               width=&#34;760&#34;
               height=&#34;612&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SOFAMesh Pilot architecture
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;增加 SOFARegistry 的 Adapter，提供超大规模服务注册和发现的解决方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增加数据同步模块，以实现多个服务注册中心之间的数据交换。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增加 Open Service Registry API，提供标准化的服务注册功能&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;MOSN 和 SOFAPilot 配合，将可以提供让传统侵入式框架（如 Spring Cloud，Dubbo，SOFA RPC 等）和 Service Mesh 产品可以相互通讯的功能，以便可以平滑的向 Service Mesh 产品演进和过渡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pilot 和后面会陆续开放的 Mixer，Citadel 等 Istio 模块&lt;/strong&gt;，会统一存放在同一个从 Istio Fork 出来的代码仓库中。未来会持续更新 Istio 最新代码，以保持和 Istio 的一致。&lt;/p&gt;
&lt;h2 id=&#34;附录&#34;&gt;附录&lt;/h2&gt;
&lt;p&gt;本文中提到的链接地址合辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alipay/sofa-mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFA MOSN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alipay/sofa-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFAMesh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sofastack.tech/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFAMesh 官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sofastack.tech/sofa-mesh/docs/Hom&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFAMesh 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnativecn.com/blog/the-way-to-service-mesh-in-ant-financial/&#34;&gt;蚂蚁金服大规模微服务架构下的 Service Mesh 探索之路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
