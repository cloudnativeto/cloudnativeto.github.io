<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mosn | 云原生社区</title>
    <link>https://cloudnative.to/tag/mosn/</link>
      <atom:link href="https://cloudnative.to/tag/mosn/index.xml" rel="self" type="application/rss+xml" />
    <description>mosn</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Mon, 18 May 2020 20:12:18 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>mosn</title>
      <link>https://cloudnative.to/tag/mosn/</link>
    </image>
    
    <item>
      <title>Service Mesh Webinar #1</title>
      <link>https://cloudnative.to/blog/service-mesh-webinar-1/</link>
      <pubDate>Mon, 18 May 2020 20:12:18 +0800</pubDate>
      <guid>https://cloudnative.to/blog/service-mesh-webinar-1/</guid>
      <description>&lt;p&gt;Service Mesh Webinar 是由 ServiceMesher 社区和 CNCF 联合发起的线上直播活动，活动将不定期举行，邀请社区成员为大家带来 Service Mesh 领域的知识和实践分享。&lt;/p&gt;
&lt;p&gt;Service Mesh Webinar#1，邀请多点生活平台架构组研发工程师陈鹏，带来分享《多点生活在 Service Mesh 上的实践——Istio + MOSN 在 Dubbo 场景下的探索之路》。&lt;/p&gt;
&lt;p&gt;随着多点生活的业务发展，传统微服务架构的面临升级困难的问题。在云原生的环境下，Service Mesh 能给我们带来什么好处。如何使用社区解决方案兼容现有业务场景，落地成符合自己的 Service Mesh 成为一个难点。服务之间主要通过 Dubbo 交互，本次分享将探索 Istio + MOSN 在 Dubbo 场景下的改造方案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直播时间：2020年5月28日（周四）20:00-21:00&lt;/li&gt;
&lt;li&gt;直播地址：&lt;a href=&#34;https://live.bilibili.com/21954520&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://live.bilibili.com/21954520&lt;/a&gt;（欢迎关注直播间）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分享主题&#34;&gt;分享主题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;《多点生活在 Service Mesh 上的实践——Istio + MOSN 在 Dubbo 场景下的探索之路》&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;分享嘉宾&#34;&gt;分享嘉宾&lt;/h2&gt;
&lt;p&gt;陈鹏，多点生活平台架构组研发工程师，开源项目与云原生爱好者，有多年的网上商城、支付系统相关开发经验，2019年至今从事云原生和 Service Mesh 相关开发工作。&lt;/p&gt;
&lt;h2 id=&#34;详情&#34;&gt;详情&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解决思路:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 MCP、Pilot、xDS、MOSN 技术，对 Service Mesh 的可切入点分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合现有业务场景和可切入点，明确需要修改的场景，制定符合自己业务场景的 Service Mesh 落地方案，介绍多点生活在 Dubbo 案例的探索及改造方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大纲：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统微服务架构与 Service Mesh 架构
&lt;ul&gt;
&lt;li&gt;传统微服务架构在多点遇到的痛点&lt;/li&gt;
&lt;li&gt;Service Mesh 架构能带来的福利&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Istio 技术点介绍&lt;/li&gt;
&lt;li&gt;在 Dubbo 场景下的改造分析
&lt;ul&gt;
&lt;li&gt;对比 MOSN 和 Envoy 对现有场景的支持&lt;/li&gt;
&lt;li&gt;Istio+MOSN 和 Istio+Envoy 在 Dubbo 场景下如何改造&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MOSN + Istio 具体实现探索
&lt;ul&gt;
&lt;li&gt;MOSN 配置文件介绍、从一个流量进来到转发到具体的远端的流程分析&lt;/li&gt;
&lt;li&gt;Provider 配置信息如何下发到 Sidecar&lt;/li&gt;
&lt;li&gt;从多点现在的实际场景对现有的 Dubbo 改造方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Demo 演示&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服开源的Service Mesh Sidecar代理SOFAMosn发布0.4.0版本</title>
      <link>https://cloudnative.to/blog/sofa-mosn-0-4-0-changelog/</link>
      <pubDate>Mon, 17 Dec 2018 11:07:07 +0800</pubDate>
      <guid>https://cloudnative.to/blog/sofa-mosn-0-4-0-changelog/</guid>
      <description>&lt;p&gt;SOFAMosn几个月前由蚂蚁金服开源，使用Go语言实现，遵循Envoy xDS协议，既可以单独作为网络代理使用，也可以作为Istio/SOFAMesh中的数据平面Sidecar 代理。开源地址：https://github.com/alipay/sofa-mosn&lt;/p&gt;
&lt;h2 id=&#34;http协议优化&#34;&gt;HTTP协议优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;性能优化：HTTP/1.x性能提升30%，HTTP/2.0性能提升100%&lt;/li&gt;
&lt;li&gt;IO、流处理接入MOSN自研框架，统一架构，并支持metrics收集等基础能力&lt;/li&gt;
&lt;li&gt;支持HTTP/1.x、HTTP/2.0协议自动识别&lt;/li&gt;
&lt;li&gt;支持GRPC&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;流量路由--管理&#34;&gt;流量路由 &amp;amp; 管理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;完善故障注入机制，支持基于路由匹配、后端匹配的延迟、错误响应异常注入&lt;/li&gt;
&lt;li&gt;支持HTTP请求direct response路由机制&lt;/li&gt;
&lt;li&gt;支持对HTTP请求添加自定义Headers，支持删除指定Headers&lt;/li&gt;
&lt;li&gt;支持重写HTTP请求中Host、URI&lt;/li&gt;
&lt;li&gt;支持基于计数的失败重试机制&lt;/li&gt;
&lt;li&gt;支持基于QPS、基于速率限流&lt;/li&gt;
&lt;li&gt;完善TCP转发功能，支持灵活的转发特性配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;遥感&#34;&gt;遥感&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;支持对接Mixer上报请求/响应的基本信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;扩展性&#34;&gt;扩展性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;重构、优化协议处理引擎&lt;/li&gt;
&lt;li&gt;支持可扩展的链式路由机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;支持基于RCU思路的动态配置更新机制&lt;/li&gt;
&lt;li&gt;新增MOSN的管理API，支持动态修改日志级别，获取运行时生效配置&lt;/li&gt;
&lt;li&gt;支持RPC的Tracing&lt;/li&gt;
&lt;li&gt;修复了一些bug&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服Service Mesh渐进式迁移方案</title>
      <link>https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/</link>
      <pubDate>Thu, 29 Nov 2018 14:51:19 +0800</pubDate>
      <guid>https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxs8jrwxj30qo0f0dip_hu97ec65a8b499e9efd1b82c94e340b8ac_157885_f33814e25ee7dd3a049e2a08ad404675.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxs8jrwxj30qo0f0dip_hu97ec65a8b499e9efd1b82c94e340b8ac_157885_13eea31f47fe2c9c4edac15235b705e1.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxs8jrwxj30qo0f0dip_hu97ec65a8b499e9efd1b82c94e340b8ac_157885_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxs8jrwxj30qo0f0dip_hu97ec65a8b499e9efd1b82c94e340b8ac_157885_f33814e25ee7dd3a049e2a08ad404675.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，今天给大家带来的演讲主题是“蚂蚁金服Service Mesh渐进式迁移方案”，给大家介绍一下我们蚂蚁金服主站的Service Mesh迁移方案，在稍后的内容中我会给大家解释什么是“渐进式”。今天的演讲方式有些特殊，将会是两位讲师合作。我是敖小剑，来自蚂蚁金服中间件团队，另外一位讲师 龙轼 ，来自 UC 基础研发部。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsexhquj30qo0f0n08_hu2b8fd6bbe552567e595be84c9ab79e42_65419_62f9fd671254078c5efbf8fa7139883a.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsexhquj30qo0f0n08_hu2b8fd6bbe552567e595be84c9ab79e42_65419_ba2e610959591d5a090605a1cc5fa997.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsexhquj30qo0f0n08_hu2b8fd6bbe552567e595be84c9ab79e42_65419_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsexhquj30qo0f0n08_hu2b8fd6bbe552567e595be84c9ab79e42_65419_62f9fd671254078c5efbf8fa7139883a.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今天的内容将会有四块主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Service Mesh演进路线：介绍蚂蚁金服计划在主站落地Service Mesh的方案，由于涉及到大量的存量应用和超大规模，又要保证迁移过程的平滑，因此我们的落地方案相比社区方案要复杂的多。&lt;/li&gt;
&lt;li&gt;实现平滑迁移的关键：介绍在整个迁移方案中，为了实现平滑迁移的几个关键做法，然后今天我们将详细展开其他的一个关键点：DNS寻址方案。&lt;/li&gt;
&lt;li&gt;DNS寻址方案的演进：详细介绍Kubernetes/Istio/SOFAMesh一路演进过来的DNS寻址方式&lt;/li&gt;
&lt;li&gt;DNS寻址方案的后续规划：介绍我们在DNS寻址方案上的后续规划&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前两块内容将由我来为大家介绍，后两块内容将由我的同事 龙轼 为大家介绍。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsiq2z5j30qo0f0grx_hu64020a3602ac53da7d01a8fd72086965_91665_1f6c0b7edf015c706470e518dbe2c3a8.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsiq2z5j30qo0f0grx_hu64020a3602ac53da7d01a8fd72086965_91665_1ee8402a9ca38edf73fe7ac0845e337a.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsiq2z5j30qo0f0grx_hu64020a3602ac53da7d01a8fd72086965_91665_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsiq2z5j30qo0f0grx_hu64020a3602ac53da7d01a8fd72086965_91665_1f6c0b7edf015c706470e518dbe2c3a8.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在展开内容之前，先看一下背景，Service Mesh在蚂蚁金服主站落地的背景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标：需要满足我们对长期目标的认可，具体指服务间通讯走Service Mesh，而且是Istio这种带完整的控制平面的Service Mesh形态，基础设施要构建在k8s之上，而应用的形态要向微服务靠拢。&lt;/li&gt;
&lt;li&gt;现状：而现实是存在很多挑战，首先还有很多应用没有实现微服务化，而且我们的k8s普及程度也不够，还有非常多的应用没有运行在kubernets之上。Istio的成熟程度也稍显不足，不够稳定，更大的挑战的是Istio目前无法原生支持我们蚂蚁金服的规模，我们还在试图对Istio进行改进和扩展。最后，在落地时必须考虑的非常现实的一点：现有系统中为数众多的应用不可能一夜之间全部迁移。&lt;/li&gt;
&lt;li&gt;关键需求：因此在落地实施时，非常重要的需求是：要实现平滑迁移。简单说，微服务 + Service Mesh + kubernetes 是我们的目标，但是如何从现有体系出发，向目标平稳和坚实的迈进，必须给出可行的实践指导。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天演讲的内容，要给大家介绍的就是，在这样的背景下，我们蚂蚁金服选择的Service Mesh主站落地演进方案。这个方案预期会在2019年初全面铺开。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsmb5l9j30qo0f0q4s_hu3a88acea1340839df2de8bcade3af543_76376_73fbbac811908623ed355ce1dd2e4ef3.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsmb5l9j30qo0f0q4s_hu3a88acea1340839df2de8bcade3af543_76376_e26a559b962fd540674880df4604155b.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsmb5l9j30qo0f0q4s_hu3a88acea1340839df2de8bcade3af543_76376_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsmb5l9j30qo0f0q4s_hu3a88acea1340839df2de8bcade3af543_76376_73fbbac811908623ed355ce1dd2e4ef3.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;主站落地方案的实施原则，这是我们在过去半年的实践中，总结归纳出来的行为指导：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符合远期规划：一定要有清晰的长期目标，明确的知道未来的大方向。避免走弯路，避免浪费投资，理想状态是计划中的每一步都可以为下一步奠定坚实的基础。即使因为某些原因不得已妥协或绕行，也应该清晰的知道后面应该如何回归，谢绝中途推倒重来——代价太高，无法承受。&lt;/li&gt;
&lt;li&gt;循序渐进：认清现实，如此之大的变革，一定是需要分步进行，不要心存一步登天的幻想，现实可行的方式是小步快跑。将整个过程拆解为若干个大步骤，每一步的工作量和复杂度都控制在一个可以接受的范围内，以保证每一步都简单方便，切实可行。&lt;/li&gt;
&lt;li&gt;有可操作性：在操作层面上，要有足够的弹性，即每个步骤中的工作内容，都应该是可以分批进行。以步步为营的方式，逐步扩大战果，杜绝一刀切。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在接下来的演进路线中，大家将会体会到这三个原则在实际落地时的指导作用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsq62x9j30qo0f0ac4_hu1c9b4e2addd8554b91c815c06e95bc51_126895_110373dc85066c0081c3b28f9979c821.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsq62x9j30qo0f0ac4_hu1c9b4e2addd8554b91c815c06e95bc51_126895_5ed9161c5e41a45f8fd0d391349ecf55.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsq62x9j30qo0f0ac4_hu1c9b4e2addd8554b91c815c06e95bc51_126895_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsq62x9j30qo0f0ac4_hu1c9b4e2addd8554b91c815c06e95bc51_126895_110373dc85066c0081c3b28f9979c821.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个图的信息量有点大，描述的是 Service Mesh 和 k8s 落地可能的多种演进路线。&lt;/p&gt;
&lt;p&gt;我们先从最下面开始看，这是当前蚂蚁金服主站大多数应用的现状：即应用&amp;quot;部署在非k8s上&amp;quot;，应用也&amp;quot;不是Service Mesh形态&amp;quot;。 然后看最上面，这是我们期望的蚂蚁金服主站未来的应用终极形态：应用&amp;quot;部署在k8s上&amp;quot;，应用也迁移到了&amp;quot;Service Mesh形态&amp;quot;。&lt;/p&gt;
&lt;p&gt;这里有个特别的地方，我们将Service Mesh形态细分为两种模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Sidecar模式：只有Sidecar，没有控制平面，和外部系统的各种集成都是在Sidecar中直接进行。这是第一代的Service Mesh，Linkerd/Envoy都是如此，华为基于ServiceComb演进而来的mesher，新浪微博的Mesh，包括我们蚂蚁金服基于MOSN开发的用于取代多语言客户端的Mesh方案。&lt;/li&gt;
&lt;li&gt;Istio模式：有完善的控制平面，可以提供强大的控制能力，而且从数据平面分离，这是第二代的Service Mesh，典型如Istio和Conkduit/Linkerd 2.0。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之所以将Service Mesh形态细分，是因为我们有着这样一个特殊背景：目前的原生Istio无法支撑我们蚂蚁金服的规模，因此在改进完善Istio之前，我们不得不暂时在Sidecar模式下短暂停留。另外一个原因就是考虑到存量应用的迁移，多一个Sidecar模式作为中间缓冲，会让整个迁移过程平滑很多。&lt;/p&gt;
&lt;p&gt;现在我们来介绍图中展示的四条演进路线：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左边的路线1，思路是先将应用迁移k8s部署，再迁移到Service Mesh形态。这条路线的最大好处，是过程中每个阶段的绝大多数投资都将最终得以保留，因为符合k8s+service mesh的远期目标&lt;/li&gt;
&lt;li&gt;右边的路线2，思路是跳过k8s，先迁移到Service Mesh形态，一路演进到Istio模式，然后最后迁移到k8s。&lt;/li&gt;
&lt;li&gt;中间的路线3，直接一步到位，这个路线是Istio默认的方式，或者说Istio根本没有考虑过迁移的问题，默认客户已经有完善的k8s，然后将改造好的应用直接部署在Istio上。这个路线对于蚂蚁金服主站的复杂场景，当然是不现实的。（补充：只是对蚂蚁金服主站不合适，对于大多数公司，规模不是那么巨大，也没有历史负担，也有k8s基础，完全可行。）&lt;/li&gt;
&lt;li&gt;还有一条特别的路线4，走位飘忽，先和路线2一样迁移到Sidecar模式，然后走回路线1，上k8s，再在有k8s支持的情况下继续演进到Istio模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们来详细分析各条演进路线的优劣和实施条件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxstzrdqj30qo0f040q_hud604359bb159cd888459cd7b8c11da78_107276_8828b4bb07477483cc76a09300615276.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxstzrdqj30qo0f040q_hud604359bb159cd888459cd7b8c11da78_107276_5851883b9bb65da5a0a926f0a78b4b04.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxstzrdqj30qo0f040q_hud604359bb159cd888459cd7b8c11da78_107276_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxstzrdqj30qo0f040q_hud604359bb159cd888459cd7b8c11da78_107276_8828b4bb07477483cc76a09300615276.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;演进路线2，和路线1的核心差别，在于：是先上k8s，还是先上Service Mesh。而且路线2是在非k8s条件下一路演进Service Mesh到我们期望的终极形态Istio模式，这意味着过程中和最终目标有非常大的偏移。&lt;/p&gt;
&lt;p&gt;演进路线2的好处，在于第一步非常的自然：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有k8s的限制，因此不依赖基础设施，实施方便。毕竟，k8s普及度是个大问题&lt;/li&gt;
&lt;li&gt;在原有的侵入式框架的客户端SDK基础上，通过包裹一个proxy，重用原有SDK的能力，可以非常快速的得到一个基本可用的Sidecar&lt;/li&gt;
&lt;li&gt;除了多一个proxy外，没有引入太多的新概念和新思想，符合现有开发人员/运维人员的心智，容易接受&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，路线2特别容易落地，可以快速达成短期目标，直接拿到Service Mesh的部分红利，如：多语言支持，方便类库升级等。&lt;/p&gt;
&lt;p&gt;但是，这个路线的问题在于再往后走，开始完善Service Mesh的功能以向Istio模式靠拢时，由于没有k8s的底层支持，因此不得不做大量的工作来提供类k8s的功能。尤其是Istio的非k8s支持，官方方案基本上只是一个demo，完全不具备生产可用性，要完善好，工作量很大。而关键点在于，这些投入，在迁移到k8s时，又因为和k8s提供的功能重复而被放弃。&lt;/p&gt;
&lt;p&gt;因此，结合我们前面的原则（符合远期规划，不浪费投资），路线2对蚂蚁金服主站落地是不合适的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsx61iuj30qo0f0wg9_hu754dbfd5aac8f8067f38b644650fa68b_103508_077b0f453c0ce25bbf07f06007bf4d26.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsx61iuj30qo0f0wg9_hu754dbfd5aac8f8067f38b644650fa68b_103508_83a80d767dc13dbb0215448a2710dd60.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsx61iuj30qo0f0wg9_hu754dbfd5aac8f8067f38b644650fa68b_103508_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxsx61iuj30qo0f0wg9_hu754dbfd5aac8f8067f38b644650fa68b_103508_077b0f453c0ce25bbf07f06007bf4d26.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;演进路线4是一个非常特殊的路线，可以理解为路线1（先上k8s再上Service Mesh）的短期妥协版本。因为路线1的前提条件是要先大规模铺开k8s，将现有应用迁移到k8s之后再继续往Service Mesh演进，这对于还没有普及k8s的公司来说是一个非常高的门槛，很容易因此受阻而无法启动。&lt;/p&gt;
&lt;p&gt;因此，如果暂时不具备k8s条件， 又不想就此止步，那么选择路线2是唯一的出路。而上面我们分析过，路线2虽然能够在第一步快速拿到短期红利，但是由于偏离长期目标后续发展会有问题。怎么办？&lt;/p&gt;
&lt;p&gt;路线4可以是这种场景下的一个折衷选择：在k8s没有铺开之前，第一步沿路线2走，先吃下非k8s下Sidecar模式快速落地的红利。然后第二步避开非k8s下继续演进到Istio模式的大坑，切换到路线1，回归长期目标。&lt;/p&gt;
&lt;p&gt;好处非常明显：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在k8s未铺开前，先往前迈进一步，避免就此卡壳&lt;/li&gt;
&lt;li&gt;和路线2一样，第一步可以快速的拿到短期红利&lt;/li&gt;
&lt;li&gt;后续转为路线1后，因为符合远期规划，因此后续演进不存在投资浪费的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点就是存在少量的投资浪费，毕竟非k8s下的Sidecar模式还是有些工作内容在迁移到k8s之后会有改动。不过，这个改动不会太大，和拿到的红利相比还是值得的。&lt;/p&gt;
&lt;p&gt;路线4在操作时，存在一个变数：现有应用在向Sidecar模式的Service Mesh迁移，是需要一定时间的。有一种可能，就是在迁移过程中，k8s的普及开始了。这个变数的发生，取决于Sidecar模式的Service Mesh普及快，还是k8s的普及快。&lt;/p&gt;
&lt;p&gt;对路线4的分析结果：这是（k8s没有普及的）特殊时期的选择。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxszj2wkj30qo0f0abt_hu722e4117e2e626dfd92d368860c5d25e_118020_0cdfcaee56adb92ece39049ca5a609e3.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxszj2wkj30qo0f0abt_hu722e4117e2e626dfd92d368860c5d25e_118020_cda8a13b46344ecbbbae37743bcdc046.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxszj2wkj30qo0f0abt_hu722e4117e2e626dfd92d368860c5d25e_118020_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxszj2wkj30qo0f0abt_hu722e4117e2e626dfd92d368860c5d25e_118020_0cdfcaee56adb92ece39049ca5a609e3.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在对四条可能的演进路线分析完成之后，我们来具体介绍蚂蚁金服的最终选择。&lt;/p&gt;
&lt;p&gt;坦言说，在过去半年中，我们的演进路线有几次摇摆和修订，今天我们公布的路线，和过去几个月中我们通过 meetup/技术大会/博客文章 等方式透露出来的方式会有一些变化。主要原因是在过去的这半年中，一方面我们对Sercice Mesh的认知更加深入，另一方面是蚂蚁金服的k8s背景也在变化。&lt;/p&gt;
&lt;p&gt;首先，在今年年初，我们确认Service Mesh大方向时，k8s还没有在蚂蚁金服普及，而且也没有明确的时间表。因此，我们在一番调研之后，选择了两条腿走路的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在非k8s环境下，以Sidecar模式先进行少量落地，主要是替换掉原有的多语言客户端 （拿短期红利）&lt;/li&gt;
&lt;li&gt;开发SOFAMesh，集成MOSN到Istio，增加对多种RPC协议的支持，增加对RPC服务模式的兼容（为最终目标做准备 ）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在今年6月底的杭州第一届Service Mesh 线下 meetup 中，我们公布了 SOFAMesh 项目，我当时做了一个演讲 &lt;a href=&#34;https://skyao.io/publication/201806-service-mesh-explore/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大规模微服务架构下的Service Mesh探索之路&lt;/a&gt; ，有兴趣的同学可以去回顾一下我们当时的背景/需求/设计方案。&lt;/p&gt;
&lt;p&gt;大概在今年九月，我们完成了对非k8s下运行istio的深入调研，得出的结论是要实现这个模式需要非常多的工作。而且，我们对Service Mesh的认知也更加深刻，明确了通过Service Mesh将传统中间件能力向以k8s为代表的基础设施层下沉的战略方向。期间，内部也明确了k8s普及的大方向，因此，综合这两个重要输入，我们选择放弃继续在路线2上继续演进（即 istio on 非k8s）的想法。关于这一点，有兴趣的同学可以去阅读我在10月份QCon大会上的演讲内容 &lt;a href=&#34;https://skyao.io/publication/201810-ant-finance-service-mesh-practice/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;长路漫漫踏歌而行：蚂蚁金服Service Mesh实践探索&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;最近，k8s普及的时间表再一次明确提前，蚂蚁金服将会在短时间内开启k8s的大面积普及。因此，我们的演进路线再一次发生变化。目前最新的演进路线将会是这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前还没有开始迁移的应用（处于演进路线图最下方），将按照路线1的方式进行迁移：先迁移到k8s，再迁移到Sidecar模式的Service Mesh&lt;/li&gt;
&lt;li&gt;目前部分已经迁移的应用（路线2/4的第一步，非k8s部署的 Sidecar 模式），将沿路线4迁移，和路线1会师&lt;/li&gt;
&lt;li&gt;由于应用众多，因此预计到 k8s + Sidecar模式 的迁移工作会持续比较长时间，在此期间，我们会同步完善Istio，和Istio官方一起合作来实现Istio对超大规模部署的支持&lt;/li&gt;
&lt;li&gt;最后一步，迁移到最终目标（当然这一步的方案依然有很多待定内容，继续努力）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要强调的是：这个演进路线针对的是蚂蚁金服主站的特殊场景，并不具体普适性。大家可以在理解我们演进路线背后的思路和权衡方式之后，再结合自身的实际情况进行决策。比如，我们在UC落地时，由于UC有完善的k8s支持，而且目前落地的规模没那么夸张，因此是直接从&amp;quot;部署在k8s上&amp;quot; + &amp;ldquo;不是Service Mesh形态&amp;rdquo;，直接迁移到终态的。预计在金融云落实时，也会是如此，因为客户也不会有如此规模。&lt;/p&gt;
&lt;p&gt;总结：前面我们介绍了当应用程序向Service Mesh和K8s迁移时的几种可能的演进路线，分析了各条路线的利弊。并以蚂蚁金服主站为例，介绍了我们迁移的背景和演进路线的选择思路，希望能够帮助大家更好的理解Service Mesh的落地实践，以便在未来设计自家的落地方案时能有所参考。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt3aatgj30qo0f0juh_hudd2637d7e2d197cee5d2aeb059cee1be_66686_07fff39e3f0092d4ce3d0e2683ef3318.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt3aatgj30qo0f0juh_hudd2637d7e2d197cee5d2aeb059cee1be_66686_556cff3bf8a06bd473e942e56a005766.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt3aatgj30qo0f0juh_hudd2637d7e2d197cee5d2aeb059cee1be_66686_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt3aatgj30qo0f0juh_hudd2637d7e2d197cee5d2aeb059cee1be_66686_07fff39e3f0092d4ce3d0e2683ef3318.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;前面给大家介绍了蚂蚁金服主站的Service Mesh演进路线，期间谈到要实现现有应用的平滑迁移。今天的第二个内容，将给大家介绍平滑迁移实现中的几个关键做法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt72zxjj30qo0f0jse_hu882e91c5e6775b846a3030219bc1fb77_75210_eb70ce414fe0301dbe124483cec1a205.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt72zxjj30qo0f0jse_hu882e91c5e6775b846a3030219bc1fb77_75210_da8f5e70d5f37ee8aa70647a257b53ff.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt72zxjj30qo0f0jse_hu882e91c5e6775b846a3030219bc1fb77_75210_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt72zxjj30qo0f0jse_hu882e91c5e6775b846a3030219bc1fb77_75210_eb70ce414fe0301dbe124483cec1a205.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先，第一个关键是尽量保证迁移前后服务间网络互通。&lt;/p&gt;
&lt;p&gt;以向k8s迁移为例，在非k8s环境，典型的服务间访问方式是这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个服务向注册中心注册&lt;/li&gt;
&lt;li&gt;客户端发起访问前，通过注册中心得到目标服务的实例列表信息，如IP地址/端口等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在向k8s迁移的过程中，我们的做法是保证k8s内外网络打通，即服务的IP地址（在k8s中是pod ip）是可以相互直接访问的。基于这个前提，服务在迁移到k8s的过程中，原有的服务注册/服务发现/发起请求等逻辑都无需修改，是不是在k8s内，是不是pod ip，对原有服务化体系完全是透明的。&lt;/p&gt;
&lt;p&gt;因此，向k8s的迁移可以做到对业务应用非常的平滑，基本感知。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt9dqbsj30qo0f00uq_hu984ac7d9794d28429f777ad1bb1289df_110760_d0920ea261d6305bdb48e22281c950e2.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt9dqbsj30qo0f00uq_hu984ac7d9794d28429f777ad1bb1289df_110760_6510e45ebde2fa7328baa3863368d2ef.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt9dqbsj30qo0f00uq_hu984ac7d9794d28429f777ad1bb1289df_110760_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxt9dqbsj30qo0f00uq_hu984ac7d9794d28429f777ad1bb1289df_110760_d0920ea261d6305bdb48e22281c950e2.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;透明拦截在迁移过程中，可以起到非常关键的作用。&lt;/p&gt;
&lt;p&gt;以Service-A要访问Service-B，在应用向Sidecar模式的Service Mesh迁移前后，会有有四种排列组合场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Service-A和Service-B都没有迁移到Serive Mesh：此时请求会直接从Service-A发送到Service-B，称为直连，这是应用在开始迁移到Service Mesh之前的标准工作方式&lt;/li&gt;
&lt;li&gt;Service-A已经迁移到Service Mesh，Service-B还没有：此时Service-A发出来的请求，会被劫持，然后发送到和Service-A一起部署的Sidecar（称为Outbound Sidecar），此时链路中只有一个Sidecar，称为（客户端）单跳&lt;/li&gt;
&lt;li&gt;Service-B已经迁移到Service Mesh，Service-A还没有：此时Service-A发出来的请求，在到达Service-B时，会被劫持到和Service-B一起部署的Sidecar（称为Inbound Sidecar），此时链路中也只有一个Sidecar，称为（服务器端）单跳&lt;/li&gt;
&lt;li&gt;Service-A和Service-B都迁移到Serive Mesh：此时Service-A发出来的请求，会被两次劫持，分别进入Outbound Sidecar和Inbound Sidecar，此时链路中有两个Sidecar，称为双跳。这是Istio的标准工作模式，也是我们迁移完成之后的最终工作模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这四种场景中，所有的网络请求，请求报文都是完全一致的，即不管是否被劫持到Sidecar，对请求报文都没有影响，也就是对发出请求报文的客户端和接受请求报文的客户端都是透明的，完全无感之。&lt;/p&gt;
&lt;p&gt;因此，在迁移过程中，可以单个服务逐个迁移，甚至服务的单个实例逐个迁移，而无需修改应用本身。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtcjj4wj30qo0f0jt1_hu84da03916eab4d2ae6e88da69e15cb20_117398_91a5cee9911844ce20cfee3819e1c911.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtcjj4wj30qo0f0jt1_hu84da03916eab4d2ae6e88da69e15cb20_117398_c0e3e2e4d8879774d72bc2d175ae0b16.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtcjj4wj30qo0f0jt1_hu84da03916eab4d2ae6e88da69e15cb20_117398_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtcjj4wj30qo0f0jt1_hu84da03916eab4d2ae6e88da69e15cb20_117398_91a5cee9911844ce20cfee3819e1c911.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在展开第三个关键点之前，我们来探讨一下：在Service Mesh时代，理想的客户端应该是什么样子？&lt;/p&gt;
&lt;p&gt;图中我们列举了一个传统的侵入式框架的客户端所包含的功能，在侵入式框架中，大部分的功能都是由客户端实现，因此会包含非常多的功能，如服务发现、负载均衡等基本功能，加密、认证、路由等高级功能。在应用迁移到Service Mesh之后，这些功能都下沉到Service Mesh中。因此，Service Mesh下的客户端可以进行大幅度的简化，成为一个新的轻量级客户端。&lt;/p&gt;
&lt;p&gt;对于这个轻量级客户端，我们希望可以尽可能的做的轻薄通用：实现简单，不管哪个编程语言都可以做到轻松实现，因此跨语言就方便了。而且越简单之后升级的可能性就会越少，以避免升级客户端。&lt;/p&gt;
&lt;p&gt;那我们来继续看，这个轻量级客户端里面最后还能剩下什么内容？&lt;/p&gt;
&lt;p&gt;图中列出了三个，其中最重要的，也是必不可少的是目标服务的标识，即无论如何简化，最低限度应该告之要访问谁吧？然后是序列化，对于RPC类肯定需要提供编解码功能，不过对于HTTP/REST类很多语言直接内置了标准实现。然后链路追踪，需要做一点工作来传递诸如SpanID之类的参数，同样这块也有可能通过自动埋点来实现。因此，最理想最单薄的客户端，可能只保留最后一个信息：目标服务的标示。&lt;/p&gt;
&lt;p&gt;在侵入式框架下，目标服务的标示是和服务注册/服务发现是直接关联的，这个标示通常都是服务名，通过服务发现机制实现了一个服务名到服务实例的寻址方式。在Service Mesh机制下，由于服务发现机制被下沉到Service Mesh中，因此只要底层Service Mesh能支持，这个目标服务的标示可以不必拘泥于服务名。&lt;/p&gt;
&lt;p&gt;那么，问题来了，对客户端来说：最简单，最通用，支持最广泛的寻址方式是什么？是DNS！&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtezb6wj30qo0f0dh6_hu12e6679318c885d1c8d59441f97f2e16_81749_24d7b2d1e4f146b9b6347544488c20bf.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtezb6wj30qo0f0dh6_hu12e6679318c885d1c8d59441f97f2e16_81749_0a641d8751c05676bf9919a51771f550.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtezb6wj30qo0f0dh6_hu12e6679318c885d1c8d59441f97f2e16_81749_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtezb6wj30qo0f0dh6_hu12e6679318c885d1c8d59441f97f2e16_81749_24d7b2d1e4f146b9b6347544488c20bf.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在我们的迁移方案中，我们考虑引入DNS寻址方式。除了前面说的DNS是支持度最好，使用最普遍的寻址方式，在所有的编程语言和平台上都可以支持之外，我们还希望将DNS寻址方式作为未来产品的长期方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在SOFAMesh和SOFAMosn中，我们已经基于名为x-protocol的方式实现了DNS通用寻址方式，用来解决Dubbo/HSF/SOFA等传统SOA服务模型在Service Mesh下的访问问题 （备注: 具体内容请见我的博客文章 &lt;a href=&#34;https://skyao.io/post/201809-xprotocol-common-address-solution/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SOFAMesh中的多协议通用解决方案x-protocol介绍系列(1)-DNS通用寻址方案&lt;/a&gt; )&lt;/li&gt;
&lt;li&gt;未来在我们的serverless产品中，我们希望可以为运行其上的Function提供DNS寻址支持&lt;/li&gt;
&lt;li&gt;可能还会有其他更加广泛的使用场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在我们的演进过程中，对于客户端SDK，我们有这样一个思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一方面简化原有的SDK，去除和Sidecar重复的内容（满足短期需求）&lt;/li&gt;
&lt;li&gt;另一方面，考虑到必然有一次客户端SDK的更换过程，那么我们希望在简化的同时引入基于DNS的通用寻址方式，以便在未来的后续迁移和功能扩展中可以依托这个机制来实现 （符合长期目标）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxti92oij30qo0f0wg2_hu5022f37a9e384f05e4bb4041ae958b3f_90688_ffafea72a7cfc4350262e68a974fe0b8.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxti92oij30qo0f0wg2_hu5022f37a9e384f05e4bb4041ae958b3f_90688_0134cb3acd003deefb5164126126f686.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxti92oij30qo0f0wg2_hu5022f37a9e384f05e4bb4041ae958b3f_90688_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxti92oij30qo0f0wg2_hu5022f37a9e384f05e4bb4041ae958b3f_90688_ffafea72a7cfc4350262e68a974fe0b8.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图中描述的是在Service Mesh下，客户端通过域名来指定要访问的目标服务，然后通过DNS解析机制来串联底层的服务注册/DNS记录更新/透明劫持传递原始信息/Sidecar查找路由目标等详细实现机制。&lt;/p&gt;
&lt;p&gt;这里仅做简单示意，我就不详细展开了。在接下来的内容中，我的同事，来自UC基础研发部的 龙轼 同学，将为大家详细的展开DNS寻址方案的细节实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtk2cbej30qo0f0ad5_hu11d97a0fe81461e050a80a215a935a79_70682_46526dc98b792c7ccf0a98129459d054.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtk2cbej30qo0f0ad5_hu11d97a0fe81461e050a80a215a935a79_70682_4e8c90fbffe6889fc5988ae5eeb01f64.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtk2cbej30qo0f0ad5_hu11d97a0fe81461e050a80a215a935a79_70682_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtk2cbej30qo0f0ad5_hu11d97a0fe81461e050a80a215a935a79_70682_46526dc98b792c7ccf0a98129459d054.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，我是来自UC基础研发部的龙轼。 感谢小剑老师给我们介绍了蚂蚁和UC共建的Service Mesh的演进路线和实现平滑迁移的关键。&lt;/p&gt;
&lt;p&gt;接下来由我来向大家分享下实现平滑迁移的关键中的DNS寻址方案的演进。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtlzs10j30qo0f0q4l_hu2ab69ae167aa88f9bc5a9a841e6cf9cc_47686_623cf26f519ff50b32018f19bd60d97a.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtlzs10j30qo0f0q4l_hu2ab69ae167aa88f9bc5a9a841e6cf9cc_47686_2b8bb804eaadc4d280ce43565645ea2c.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtlzs10j30qo0f0q4l_hu2ab69ae167aa88f9bc5a9a841e6cf9cc_47686_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtlzs10j30qo0f0q4l_hu2ab69ae167aa88f9bc5a9a841e6cf9cc_47686_623cf26f519ff50b32018f19bd60d97a.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家可以看上面的所示的DNS寻址方案的演进，我们先了解下各个服务寻址方案的背景。&lt;/p&gt;
&lt;p&gt;从 SOA 的寻址，到 Kubernetes 的寻址，然后再到 Istio 的寻址，最后是我们的 SOFAMesh 的DNS寻址方案。&lt;/p&gt;
&lt;p&gt;它们的寻址方案有什么不同，我们将一一分析它们的细节和总体寻址方案的演进路线。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtnvgf0j30qo0f0gmq_hu2e6bfdd4d1e6072b056fdb689d7d7b23_70347_061aa60931b1fcdd15c1397f9c585833.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtnvgf0j30qo0f0gmq_hu2e6bfdd4d1e6072b056fdb689d7d7b23_70347_0c7b7f9635cb2b66e340de79e4b5e3e4.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtnvgf0j30qo0f0gmq_hu2e6bfdd4d1e6072b056fdb689d7d7b23_70347_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtnvgf0j30qo0f0gmq_hu2e6bfdd4d1e6072b056fdb689d7d7b23_70347_061aa60931b1fcdd15c1397f9c585833.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;现在大家可以先来看下 SOA 架构下基于服务注册和服务发现的寻址。&lt;/p&gt;
&lt;p&gt;我们可以看到图中的 SOA 其实是单进程多接口的，依赖于 SOA 的服务注册与服务发现的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtovfoxj30qo0f0myc_hu46fede31f32e5ca5c7489fe79903bf00_82294_d73de36ab36f30309834d19d6d162900.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtovfoxj30qo0f0myc_hu46fede31f32e5ca5c7489fe79903bf00_82294_da7e377a5de57182a65936c8ff4b9cc6.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtovfoxj30qo0f0myc_hu46fede31f32e5ca5c7489fe79903bf00_82294_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtovfoxj30qo0f0myc_hu46fede31f32e5ca5c7489fe79903bf00_82294_d73de36ab36f30309834d19d6d162900.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来我们看下 Kubernetes 的 DNS 寻址方式，它的寻址方式其实是通过DNS 的。&lt;/p&gt;
&lt;p&gt;从图中我们可以看到部署到K8S 上面的userservice 服务会生成一条DNS记录指向K8S 的ClusterIP。&lt;/p&gt;
&lt;p&gt;我们在 Pod 里面发起请求时通过 DNS 的 SearchDomain 域名补全规则就会从 DNS 里面查询得到ClusterIP，我们可以看出 Kubernetes 的寻址方案是单进程单接口的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtr32x9j30qo0f0gmy_hu0001eaf1bbeae97ee78766c74ece341b_90190_674ac856a4c1ad54b6b9bdcbb041ae1b.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtr32x9j30qo0f0gmy_hu0001eaf1bbeae97ee78766c74ece341b_90190_80ef016262db390270a22f5d1cccef33.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtr32x9j30qo0f0gmy_hu0001eaf1bbeae97ee78766c74ece341b_90190_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtr32x9j30qo0f0gmy_hu0001eaf1bbeae97ee78766c74ece341b_90190_674ac856a4c1ad54b6b9bdcbb041ae1b.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;看完 Kubernetes 的服务发现之后我们继续来看 Istio 的服务发现。&lt;/p&gt;
&lt;p&gt;从图中我们可以看出之前的流程都和 K8S 一脉相承，不同的地方在于 Istio 里面有个 SideCar 它把ClusterIP 拿到之后根据 ClusterIP 从 VirtualHost 里面匹配到 Rule 规则 转发给目标的 Pod 地址。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtt2236j30qo0f00tq_huacd88485823c7a80bccd3c426728f758_77664_91e394c4ae22af3b3103aa1dd3e2f6d5.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtt2236j30qo0f00tq_huacd88485823c7a80bccd3c426728f758_77664_5886c3cefc674c460171ab7043a5ea80.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtt2236j30qo0f00tq_huacd88485823c7a80bccd3c426728f758_77664_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtt2236j30qo0f00tq_huacd88485823c7a80bccd3c426728f758_77664_91e394c4ae22af3b3103aa1dd3e2f6d5.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们来看下 SOFAMesh 的 DNS 通用寻址方案。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据我们之前分析的 SOA 寻址方案和 Kubernetes 寻址方案，我们可以看出如果我们的微服务不经过拆分和改造想上 Service Mesh 的话我们需要支持SOA之前的那种单个Pod 多个接口的。&lt;/li&gt;
&lt;li&gt;从图中看就是我们需要支持 &lt;code&gt;com.alipay.userservice.interface1&lt;/code&gt;, &lt;code&gt;com.alipay.userservice.interface2&lt;/code&gt; 这些接口解析到 ClusterIP, 我们知道k8s 中的service 是不支持的。&lt;/li&gt;
&lt;li&gt;那该如何是好，我们只能在DNS 上做文章修改DNS的记录来实现这一功能。确定了这一方案之后我们来看下我们设计的DNS寻址方案实现细节。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtx8cboj30qo0f0q3y_hu7ba11f5b4726e00e026a1f23e0a57f1f_74263_cac45e0c8aed8cc4f69a19fbef2a23f8.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtx8cboj30qo0f0q3y_hu7ba11f5b4726e00e026a1f23e0a57f1f_74263_573170805ff01174caf83e97fc6cab5b.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtx8cboj30qo0f0q3y_hu7ba11f5b4726e00e026a1f23e0a57f1f_74263_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxtx8cboj30qo0f0q3y_hu7ba11f5b4726e00e026a1f23e0a57f1f_74263_cac45e0c8aed8cc4f69a19fbef2a23f8.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家看这张图:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们用 CRD 定义了一个 RPCService 和之前的 Service 有同样的 selector 的标签。&lt;/li&gt;
&lt;li&gt;然后用 RPC Service Controller 对 RPCService 做 Watch，当 RPCService 有更新的时候我们就把接口就是上述的 &lt;code&gt;com.alipay.userservice.interface1&lt;/code&gt; 的记录写入 CoreDNS 里面&lt;/li&gt;
&lt;li&gt;而 interface 是通过 Pod 里面的 Register Agent 来获取 Dubbo 里面暴露的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu1urkdj30qo0f0wf6_hucb902f54fd34cb6a66ec81cff7b0eca1_51550_84ae7fff2d426b7a6aa5c7f012252919.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu1urkdj30qo0f0wf6_hucb902f54fd34cb6a66ec81cff7b0eca1_51550_260dde339cd7a3748771778d25e79355.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu1urkdj30qo0f0wf6_hucb902f54fd34cb6a66ec81cff7b0eca1_51550_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu1urkdj30qo0f0wf6_hucb902f54fd34cb6a66ec81cff7b0eca1_51550_84ae7fff2d426b7a6aa5c7f012252919.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;好的，说完这个方案的细节之后。我们可以看出其实其他的问题都不大，但是要更新DNS的这个我们需要支持。&lt;/p&gt;
&lt;p&gt;一开始我们 K8S 集群里面是用 Kube-DNS 来做 DNS 寻址的，但我们看这张 Kube-DNS 的架构图。&lt;/p&gt;
&lt;p&gt;可以看出修改它成本是比较大的，而且所有的DNS 都在同一个域里面，这个风险系数很高。 如果一旦修改错误势必会影响到之前的 k8s 的 service，导致线上的故障。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu6p6cgj30qo0f0q5b_hu9c0431f21f90131352810f0650a1b511_71396_55a4d2dc00484751c58f4d269ee2c368.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu6p6cgj30qo0f0q5b_hu9c0431f21f90131352810f0650a1b511_71396_792eb076969418bb1b2395ac90b07b3c.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu6p6cgj30qo0f0q5b_hu9c0431f21f90131352810f0650a1b511_71396_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxu6p6cgj30qo0f0q5b_hu9c0431f21f90131352810f0650a1b511_71396_55a4d2dc00484751c58f4d269ee2c368.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个时候我们跟踪到社区的 CoreDNS 项目，我们来看下 CoreDNS 的具体的架构。  它采用作为 Web 服务器 Caddy 的服务器框架，延用了Caddy 中的插件机制，大大的增加了 CoreDNS 的灵活性。&lt;/li&gt;
&lt;li&gt;它的插件机制也特别简单，把所有的插件注册进一个Map里面来，在调用的时候从Map拿出他们有共同接口的函数。有兴趣的同学可以看下 Caddy 的插件代码实现。&lt;/li&gt;
&lt;li&gt;它的 DNS 协议库采用是由 Google 工程师 Meikg 开发的 DNS 库，他同时也是 SkyDNS 的开发者。&lt;/li&gt;
&lt;li&gt;后端可以采用 UDP/TCP、TLS 或者 gRPC 作为后端数据查询。上面有个Google工程师用 gRPC 做了一个 CoreDNS 插件的后端数据查询例子，有兴趣的同学可以看下。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxubqi33j30qo0f0djp_hu8282bacb0d8cd4fadd95abb5ed4e4572_82820_09c142a3387af5a7284f133a5c1571b0.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxubqi33j30qo0f0djp_hu8282bacb0d8cd4fadd95abb5ed4e4572_82820_b5472055aabfcf04f7848c3854aaf521.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxubqi33j30qo0f0djp_hu8282bacb0d8cd4fadd95abb5ed4e4572_82820_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxubqi33j30qo0f0djp_hu8282bacb0d8cd4fadd95abb5ed4e4572_82820_09c142a3387af5a7284f133a5c1571b0.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，既然 CoreDNS 的 Plugins 这么强大，我们可不可以用它来实现我们刚才说到的 Renew DNS的机制。 答案很显然是可以。&lt;/p&gt;
&lt;p&gt;我们看下上面的图，实现CoreDNS 的插件很简单，只需要继承上面的接口就可以了。 CoreDNS 官网有具体的教程在教我们怎么写一个插件。这个就不具体的展开了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuel9hoj30qo0f03zw_hufc857944063d1298e626e2293dc9cb29_98186_92daf530e81c84d5521266a7abcd8b37.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuel9hoj30qo0f03zw_hufc857944063d1298e626e2293dc9cb29_98186_0ae63ff58207ba9f7d1e95fcae2139cb.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuel9hoj30qo0f03zw_hufc857944063d1298e626e2293dc9cb29_98186_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuel9hoj30qo0f03zw_hufc857944063d1298e626e2293dc9cb29_98186_92daf530e81c84d5521266a7abcd8b37.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;到了我们最关键的点了：我们应该怎么更新我们的DNS。其实这点 CoreDNS 社区里面已经有人提出需求用 REST API 的形式提供更新 DNS 的接口。&lt;/li&gt;
&lt;li&gt;互联网任务工程小组也早在 rfc2136 定义了标准的 DNS UPDATE。 Google Cloud 和AWS 都有相应的实现。&lt;/li&gt;
&lt;li&gt;CoreDNS 社区其实已经把接口实现了，但是后端存储是基于file 的，数据没有落地。 蚂蚁和UC 这边扩展了 ETCD 插件的接口，把对应 DNS UPDATE 接口给实现了，实现 DNS 数据写入ETCD 里面。&lt;/li&gt;
&lt;li&gt;从图中我们可以看到 &lt;code&gt;rpc.cluster.local&lt;/code&gt; 这个域 和 k8s 域 cluster.local 是在不同的插件链上的。
这样在k8s域中没有 dynapirest 插件，我们就不能对k8s域中的DNS进行更新，这样就把之前Kube-DNS改造之后会对k8s域里面造成影响给去除了，更加的安全。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuhvylcj30qo0f0n35_hu05a294bf28ff73e65f367c7ee006e240_83683_57ce738d036f285bcba43fb1f754e74c.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuhvylcj30qo0f0n35_hu05a294bf28ff73e65f367c7ee006e240_83683_eadd6edeaede23dc2236227301e0da57.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuhvylcj30qo0f0n35_hu05a294bf28ff73e65f367c7ee006e240_83683_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuhvylcj30qo0f0n35_hu05a294bf28ff73e65f367c7ee006e240_83683_57ce738d036f285bcba43fb1f754e74c.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们可以看下 CoreDNS 后端存储的接口，其实和我们之前对数据操作的接口是没有什么差别的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuk3x3zj30qo0f0go6_hua086b4ca20d060979e8379df5df961fc_63619_0bfe61a0c06613ac4e47b16839933218.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuk3x3zj30qo0f0go6_hua086b4ca20d060979e8379df5df961fc_63619_02caf347455e71fce3e01255ad8851cd.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuk3x3zj30qo0f0go6_hua086b4ca20d060979e8379df5df961fc_63619_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuk3x3zj30qo0f0go6_hua086b4ca20d060979e8379df5df961fc_63619_0bfe61a0c06613ac4e47b16839933218.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;目前 CoreDNS 的 DynAPI 还在主库代码没合并的状态。之后 DynAPI 这个项目会独立成一个插件项目。我们可以看下 CoreDNS 社区的 DynAPI 插件进展。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxumjxr1j30qo0f00vw_hu4290fc23d7b0f07a229e594f4df0bc34_65463_2c45087148336d295e08f1af0a086202.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxumjxr1j30qo0f00vw_hu4290fc23d7b0f07a229e594f4df0bc34_65463_ad3ad902a1af193ea4e8646cd54bd520.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxumjxr1j30qo0f00vw_hu4290fc23d7b0f07a229e594f4df0bc34_65463_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxumjxr1j30qo0f00vw_hu4290fc23d7b0f07a229e594f4df0bc34_65463_2c45087148336d295e08f1af0a086202.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，我们来看下我们的DynAPI 实现DNS 更新的一个效果。从图中我们可以看出 record.json 里面的一个域名的更新。通过 DynAPI 我们成功把 record.json 的DNS 记录给更新进去并且dns正常工作了。到现在我们通过CoreDNS 的插件就把DNS 更新的需求给解决了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuoytkjj30qo0f0q4a_huaecd81861cfdf766a268f099de8accf5_42940_335abfdfc4375e254c6482aebe802ce0.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuoytkjj30qo0f0q4a_huaecd81861cfdf766a268f099de8accf5_42940_79544ec62cf1d8bc6d61068e6b7f126e.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuoytkjj30qo0f0q4a_huaecd81861cfdf766a268f099de8accf5_42940_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuoytkjj30qo0f0q4a_huaecd81861cfdf766a268f099de8accf5_42940_335abfdfc4375e254c6482aebe802ce0.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其实CoreDNS 官网还有许多有趣的插件，可以丰富 CoreDNS 的功能和提升 CoreDNS 的性能。 大家可以看下中间的 autopath 插件，他把我们多次的在 searchdomain 拼凑的 DNS 记录的查询在在服务器上给实现了。 避免了多次的 Client 端和 Server 端的数据交互。有兴趣的同学可以看下 &lt;a href=&#34;https://github.com/coredns/presentations/blob/master/A-Deep-Dive-into-CoreDNS-2018.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A-Deep-Dive-into-CoreDNS-2018&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxurlu6tj30qo0f0q46_hu697e05cc675181f43b7d82dfcdf952ae_68564_84dc530f93969d30275952185fbece40.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxurlu6tj30qo0f0q46_hu697e05cc675181f43b7d82dfcdf952ae_68564_dd6c1748d6076a017135e4db4fdc70fa.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxurlu6tj30qo0f0q46_hu697e05cc675181f43b7d82dfcdf952ae_68564_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxurlu6tj30qo0f0q46_hu697e05cc675181f43b7d82dfcdf952ae_68564_84dc530f93969d30275952185fbece40.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们把 CoreDNS 的功能开发完了，上线的话很多人关注它的性能。 我们这边做了一个简单的性能测试，可以看出 CoreDNS 和 Bind DNS 这种现在比较通用的DNS的性能还是有点差距的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuu4eu0j30qo0f0tf3_hue7ff765e78b935349b182b3e5cec081b_97289_3b4f2ee963bdda5c3a36a7ffdd8daa8e.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuu4eu0j30qo0f0tf3_hue7ff765e78b935349b182b3e5cec081b_97289_e42e0f242e5be4d351e5be5d10e8c00e.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuu4eu0j30qo0f0tf3_hue7ff765e78b935349b182b3e5cec081b_97289_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuu4eu0j30qo0f0tf3_hue7ff765e78b935349b182b3e5cec081b_97289_3b4f2ee963bdda5c3a36a7ffdd8daa8e.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但是,我们通过上面的图可以看到在一定的QPS 下，CoreDNS 的延时是很低的。 我们可以看到所有的延时都落在4ms 之内。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuwnsanj30qo0f0abw_hu2ed5448edaa54fb5fd6e4e16c5245000_54682_fb19be6f008eebdab32ac9e4f6f1c536.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuwnsanj30qo0f0abw_hu2ed5448edaa54fb5fd6e4e16c5245000_54682_7ebe40a3e5facd4d4653dc2f363147b4.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuwnsanj30qo0f0abw_hu2ed5448edaa54fb5fd6e4e16c5245000_54682_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuwnsanj30qo0f0abw_hu2ed5448edaa54fb5fd6e4e16c5245000_54682_fb19be6f008eebdab32ac9e4f6f1c536.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了解决QPS的问题，我们通过 Kubernetes 的 HPA 给 CoreDNS 进行横向的扩展。&lt;/p&gt;
&lt;p&gt;一开始我们只是通过CPU的维度给 CoreDNS 扩展，但发现波动有点大。 之后我们切换成通过QPS的维度来进行扩容。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuz1c5ej30qo0f0gmc_hud3413c0c7ae70cae78b1dbf9fbf1dabd_60219_92abb891713e0db9be37bb876f67d52b.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuz1c5ej30qo0f0gmc_hud3413c0c7ae70cae78b1dbf9fbf1dabd_60219_c0675bbcb380bf9108e48f4a48d09e4a.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuz1c5ej30qo0f0gmc_hud3413c0c7ae70cae78b1dbf9fbf1dabd_60219_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxuz1c5ej30qo0f0gmc_hud3413c0c7ae70cae78b1dbf9fbf1dabd_60219_92abb891713e0db9be37bb876f67d52b.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;CoreDNS 将会在Kubernetes 1.13 之后成为 Kubernetes 的默认的DNS服务。我们将会紧跟社区实施我们的方案并且反馈给社区。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv0youwj30qo0f0tbs_hu5a00da812b612dd897a14ff5f187b694_66640_6990e1d4e7f383945eb7a753bbfc2b25.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv0youwj30qo0f0tbs_hu5a00da812b612dd897a14ff5f187b694_66640_687c8b560bacbf7ae2928d03cf5289c3.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv0youwj30qo0f0tbs_hu5a00da812b612dd897a14ff5f187b694_66640_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv0youwj30qo0f0tbs_hu5a00da812b612dd897a14ff5f187b694_66640_6990e1d4e7f383945eb7a753bbfc2b25.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们再来看下我们后续的一些规划。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv3cwjjj30qo0f075p_hudc21e1c15e19b5880d25d46c44285063_52107_f6e8004cd53845b1eb174a61b989cf57.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv3cwjjj30qo0f075p_hudc21e1c15e19b5880d25d46c44285063_52107_51379ad05b467bf751822a4a3ec200f8.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv3cwjjj30qo0f075p_hudc21e1c15e19b5880d25d46c44285063_52107_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv3cwjjj30qo0f075p_hudc21e1c15e19b5880d25d46c44285063_52107_f6e8004cd53845b1eb174a61b989cf57.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可以看到我们的 DynAPI 其实在安全上还是有欠缺的。我们后续会把 HTTP 加强成 HTTPS 协议来增强 DynAPI 的安全性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv5rwbbj30qo0f0dik_hu0023aa6a7c91b0cfc4331301c6ac21ae_61855_afcc6e418f1c383625b315a95ce88cae.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv5rwbbj30qo0f0dik_hu0023aa6a7c91b0cfc4331301c6ac21ae_61855_db14f1aab6db1d0a19188f2432632de5.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv5rwbbj30qo0f0dik_hu0023aa6a7c91b0cfc4331301c6ac21ae_61855_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv5rwbbj30qo0f0dik_hu0023aa6a7c91b0cfc4331301c6ac21ae_61855_afcc6e418f1c383625b315a95ce88cae.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;还有如果我们 CoreDNS 的后端变化的更新的 Watch 由于 Watch的范围过大的话，会返回过多的数据。这样会影响到 Watch 的性能，CoreOS 在 ETCD3.2 增加了proxy 可以让我们根据不同的 ETCD KeySpace 去Watch,这样大大的提高了Watch的性能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv8070fj30qo0f0ab1_hu6485f23e60e2e8e9568294bae27898e8_64699_ba5855a52150ea4c23f3e1223840e916.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv8070fj30qo0f0ab1_hu6485f23e60e2e8e9568294bae27898e8_64699_1a155b965fc813b9eeaae068e35548b1.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv8070fj30qo0f0ab1_hu6485f23e60e2e8e9568294bae27898e8_64699_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxv8070fj30qo0f0ab1_hu6485f23e60e2e8e9568294bae27898e8_64699_ba5855a52150ea4c23f3e1223840e916.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后一个，我们建议在创建 Kubernetes 集群的时候把 idc 的信息给带进Kubernetes的后缀域名中。这样我们之后可以通过 kubernetai 插件把不同的 Kubernetes 集群的域名进行整合通过本 IDC 缓存提高跨 IDC DNS 的访问速度。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvatmutj30qo0f0whk_hu2cbabba623e88cebfd9cefff42206c53_65339_e1dc879d8d056e8934685548a93441c2.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvatmutj30qo0f0whk_hu2cbabba623e88cebfd9cefff42206c53_65339_e759cb451668749d76e231270fcec3e3.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvatmutj30qo0f0whk_hu2cbabba623e88cebfd9cefff42206c53_65339_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvatmutj30qo0f0whk_hu2cbabba623e88cebfd9cefff42206c53_65339_e1dc879d8d056e8934685548a93441c2.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvdouf2j30qo0f0gnc_huc1406821e9a2af2652eda43d3e3b0695_55814_5bcc52e2cfe11125f500ceaaaf8794d4.webp 400w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvdouf2j30qo0f0gnc_huc1406821e9a2af2652eda43d3e3b0695_55814_6e9b7c0e8140494d20e81d0021cff817.webp 760w,
               /blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvdouf2j30qo0f0gnc_huc1406821e9a2af2652eda43d3e3b0695_55814_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-service-mesh-adoption-plan/006tNbRwly1fxoxvdouf2j30qo0f0gnc_huc1406821e9a2af2652eda43d3e3b0695_55814_5bcc52e2cfe11125f500ceaaaf8794d4.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们总结下，总体方面小剑老师给我们讲了蚂蚁金服主站 Service Mesh 的渐进式演进路线和实现平滑迁移的几个关键。 具体细节方面我们通过CoreDNS 的单点突破解决了 SOFAMesh 的 DNS 寻址的问题。&lt;/p&gt;
&lt;p&gt;感谢大家，希望这次演讲能让大家有所收获。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>蚂蚁金服开源的 SOFAMesh 的通用协议扩展解析</title>
      <link>https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/</link>
      <pubDate>Fri, 31 Aug 2018 12:27:25 +0800</pubDate>
      <guid>https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文作者：邵俊雄（熊啸），蚂蚁金服中间件团队高级技术专家，目前主要负责 SOFAMesh 的开发工作。&lt;/p&gt;
&lt;p&gt;本文是基于作者在 &lt;a href=&#34;https://cloudnative.to/blog/service-mesh-meetup-shenzhen-20180825&#34;&gt;Service Mesh Meetup #3 深圳&lt;/a&gt;的主题分享《SOFAMesh的通用协议扩展》部分内容所整理，完整内容见文末的直播回放&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-邵俊雄-蚂蚁金服-service-mesh-sofa-mosn&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;邵俊雄 蚂蚁金服 Service Mesh SOFA MOSN&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusppz003uj318w0u0qdx_hu356cc26b796eedeeda320347f4055d04_398496_1aa931f7a530bd6d0dbc931f5a4a6d26.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusppz003uj318w0u0qdx_hu356cc26b796eedeeda320347f4055d04_398496_45df4f8521e275c3ab132b5973bc4b7b.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusppz003uj318w0u0qdx_hu356cc26b796eedeeda320347f4055d04_398496_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusppz003uj318w0u0qdx_hu356cc26b796eedeeda320347f4055d04_398496_1aa931f7a530bd6d0dbc931f5a4a6d26.webp&#34;
               width=&#34;760&#34;
               height=&#34;508&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      邵俊雄 蚂蚁金服 Service Mesh SOFA MOSN
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本次分享主要介绍蚂蚁金服在 SOFAMesh 上开发对 SOFARPC 与 HSF 这两个RPC框架的支持过程中总结出来的通用协议扩展方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspj4xg2uj30k00b9wfc_hu10e8300b3657c3f5e0891fa784654789_35204_4cdd34d4b32980f867eeaaaeba91f23d.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspj4xg2uj30k00b9wfc_hu10e8300b3657c3f5e0891fa784654789_35204_e5deb3b543b9efd38efa1b16b3850b7a.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspj4xg2uj30k00b9wfc_hu10e8300b3657c3f5e0891fa784654789_35204_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspj4xg2uj30k00b9wfc_hu10e8300b3657c3f5e0891fa784654789_35204_4cdd34d4b32980f867eeaaaeba91f23d.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;1-sofamesh-介绍&#34;&gt;1. SOFAMesh 介绍&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmec6l4j30k00b9aax_hu6bf9dc931831babd83d51dd5e2509ef8_35933_13e3eba66abd1b22e38a3e089596958a.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmec6l4j30k00b9aax_hu6bf9dc931831babd83d51dd5e2509ef8_35933_1315744aeb930366dbf65f789f1c554a.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmec6l4j30k00b9aax_hu6bf9dc931831babd83d51dd5e2509ef8_35933_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmec6l4j30k00b9aax_hu6bf9dc931831babd83d51dd5e2509ef8_35933_13e3eba66abd1b22e38a3e089596958a.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFAMesh 是蚂蚁从 ISTIO 上游克隆的开源项目，目的是在 ISTIO 的基础上进行控制平面的发展和创新，同时保持和上游 ISTIO 的同步更新，跟随 ISTIO 的发布节奏，当然也会把一些有价值能力贡献给 ISTIO 社区。&lt;/p&gt;
&lt;p&gt;SOFAMesh 的一个重要目标是用蚂蚁自研的 Golang 版 L4/L7 层代理服务器 SOFAMosn 作为数据平面，取代 C++ 开发的 ENVOY。之前的 Meetup 中我们已经探讨过了一个 Golang 版本的数据平面的重要性，我们相信统一控制平面和数据平面的开发语言可以加快 Service Mesh 的技术创新和产品化落地的速度。&lt;/p&gt;
&lt;p&gt;目前我们已经完成了集成 SOFAMosn 的前期开发工作，打包，安装，部署和测试的脚本都已经从 ENVOY 迁移到了 SOFAMosn，所有的镜像也都推到了公开的镜像仓库。下一步 SOFAMesh 将会整体在 UC 内部基于 Kubernetes 的 PAAS 平台中落地，在实际的生产环境中打磨。未来，SOFAMesh 还将在蚂蚁主站落地，在金融级的生产环境中进一步打磨。&lt;/p&gt;
&lt;p&gt;ISTIO 目前仅能支持 TCP/REDIS/MONGO/HTTP 协议，其服务治理规则主要针对 HTTP 服务制定，对于业界目前大量在高并发、低延迟环境下使用的 RPC 框架及通信协议，例如 DUBBO/HSF/SOFA 没有很好的支持，SOFAMesh 把对于 RPC 通信协议的支持作为重点来看待，SOFAMosn 默认就提供对于 SOFA BOLT 协议的支持。&lt;/p&gt;
&lt;p&gt;SOFAMesh 也是控制平面创新发生的地方，我们已经规划了的创新包括 Mesh Operator，RPC Service Controller 等等。未来的 Serverless 平台也会考虑基于 SOFAMesh 打造，SOFAMesh 将为 Serverless 平台提供基于 Reversion 的服务治理能力。Google Cloud 最近联合 CloudFoundry 和 IBM 发布的 Serverless 平台 Knative 同样也是基于 ISTIO 打造，和我们的想法也是不谋而合。&lt;/p&gt;
&lt;p&gt;SOFAMesh 的下一步也是要融合到 PAAS 平台里面去，成为 PAAS 平台基础网络能力的一部分，用于支撑上层的业务更快速的创新，我们还会加强文档和快速上手方面，方便大家试用 SOFAMesh。&lt;/p&gt;
&lt;h2 id=&#34;2-service-mesh-落地中的问题&#34;&gt;2. Service Mesh 落地中的问题&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmm8hvij30k00b93zo_hu745f9b0f54d8dd24ebd6fe42ed7140c8_45848_d8f20132031f3759eab1429c1413ae99.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmm8hvij30k00b93zo_hu745f9b0f54d8dd24ebd6fe42ed7140c8_45848_bfd7fbcb97c20a140e4549011e8afc00.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmm8hvij30k00b93zo_hu745f9b0f54d8dd24ebd6fe42ed7140c8_45848_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspmm8hvij30k00b93zo_hu745f9b0f54d8dd24ebd6fe42ed7140c8_45848_d8f20132031f3759eab1429c1413ae99.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二部分是这次分享的重点，主要介绍蚂蚁金服在集成 SOFA/DUBBO 和 HSF 这些框架的过程中碰到的问题和我们的一套通用的解决方案，希望能够加速 Service Mesh 在实际生产中的落地。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总的来说，业界在 Service Mesh 落地的时候主要有下面四种做法，基本上每种我们都思考和尝试过，最后我们也是走了一条循序渐进的道路。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一种做法，比较常见，就是不用 ISTIO 只参考它的设计理念，用 ENVOY/MOSN 或者自研的 SIDECAR 结合已经成熟并且大规模部署的注册中心/配置中心组件，快速上线，拿到多语言，灰度发布，安全这些红利，比如唯品会的 OSP Local Proxy, 华为的 Mesher 都是这个套路。其实 ENVOY 最早也是如此，希望用户在 ENVOY 上直接扩展对 Consul, Eurkea 这些注册中心的支持。但是社区没有走这条路，反而对其 XDS API 进行了适配，由此诞生除了 Service Mesh 的控制平面，并进一步演化出了 ISTIO。目前看来这么做的主要问题是无法利用 ISTIO 社区在服务治理上的创新和工作，存在重复的建设，所以后来有了第二种思路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种做法，更进一步，使用 ISTIO， 但是把 Kubernetes 剥离出去，适用于很多短期内无法上 Kubernetes 的企业。ISTIO 控制平面本来就提供了这个能力，ISTIO 有两个扩展点，一个通过 Platform Adapter 对接第三方注册中心，另一个 通过 Config Adapter 对接不通的配置存储。这个做法业界最典型的是 Ucloud 的轻量级 Service Mesh 方案，他们把 Pilot Discovery 模块从 ISTIO 里面剥离了出来，增加第三方注册中心的 Platform Adapter，Cofig Store 直接对接 ETCD 集群，可以通过 docker compose 直接跑起来整个 ISTIO。好处是入门更简单了，但是失去了 Kubernetes 提供了基础能力，ISTIO 的武功已经废了大半。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后来又了第三种做法，据说也有不少公司采用，具体做法是把 Kubernetes 做一个虚拟机用，阉割其服务发现，DNS 等能力，用注册中心/配置中心等成熟且大规模应用的产品替代。唯品会前几天发的文章说明他们已经把这个做法在生产中落地了。这种做法一般只使用 POD 和 StatfuleSet，不创建服务和Endpoints。一般来说， ISTIO 通过 Platform Adapter 对接注册中心，Config Adapter对应配置中心。相比前两种做法，这个做法更加复杂，好处是成熟的配置中心和注册中心能够快速的落地 ISTIO，不用解决 ISTIO 由于 ETCD 存贮带来的扩展性问题。这个做法还有个变种就是完全不用 ISTIO，直接在 ENVOY/MOSN 上对接注册中心和配置中心，甚至完成 MIXER 的检查和遥测上报的能力。比如唯品会，用的是 DaemonSet，在同一个 Node 上共享 SIDECAR，其 SIDERCAR 组件 OSP Local Proxy 直接集成注册中心/配置中心。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后一个做法是我们努力的方向，向 Kubernetes 原生的方向发展，在生产环境中落地打磨，并和社区一起解决碰到的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;uc-的-uae-20-平台&#34;&gt;UC 的 UAE 2.0 平台&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspr1ugjqj30k00b9q4c_hu27fb14e4899109a8042d8cf0102bf5d8_53758_d5ed7f33ae1cd85969b1e26279531e16.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspr1ugjqj30k00b9q4c_hu27fb14e4899109a8042d8cf0102bf5d8_53758_c48f79792bcaded2b3212046454494da.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspr1ugjqj30k00b9q4c_hu27fb14e4899109a8042d8cf0102bf5d8_53758_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspr1ugjqj30k00b9q4c_hu27fb14e4899109a8042d8cf0102bf5d8_53758_d5ed7f33ae1cd85969b1e26279531e16.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;充分利用 Kubernetes 基础设施的能力是未来的方向，只要路走对了，就不怕远，比如说透明路由网络流量是方向，IPTABLES 是一个实现手段，它的性能不够好，那我们就通过引入 Cilium，用 EBPF 代替 IPTABLES。由于 BYPASS 了两次 TCP 协议栈道穿透，转发性能比常用的 loopback 地址 Workaround 方案还要好。更进一步，我们还能把 ISTIO 数据平面的同步检查逻辑，比如访问控制，通过 Cilium 推到内核的虚拟机中执行，从而解决 ISTIO 的另一的性能瓶颈。&lt;/p&gt;
&lt;p&gt;Kubernetes 已经成为了云原生的事实标准，我们应该充分利用 Kubernetes 的能力，借用社区的力量发展自己的技术。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprblc3fj30k00b975n_hu5610707c4ba11e54238b38f3b79f4926_55008_3cb354fcff3024cd7fed08b2f1f80f86.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprblc3fj30k00b975n_hu5610707c4ba11e54238b38f3b79f4926_55008_9b483af5aa2863c1a957a18ce65d9977.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprblc3fj30k00b975n_hu5610707c4ba11e54238b38f3b79f4926_55008_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprblc3fj30k00b975n_hu5610707c4ba11e54238b38f3b79f4926_55008_3cb354fcff3024cd7fed08b2f1f80f86.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Spring cloud kubernetes 项目给 Spring cloud 项目落地 Kubernetes 提供了支持，但是在整合 ISTIO 的时候碰到了问题，即便使用 Kubernetes 作为注册中心，客户端的负载均衡和服务发现组件也会破坏 ISTIO 对请求规格的依赖，经过负载均衡之后发送给 ISTIO 数据平面的 PODIP 无法被正确的路由的后端的集群，既无法匹配到 Virtual Host。我们通过 BeanFactoryPostProcesser 在请求中带上了 Host 头，指向服务在 Kubernetes 中的域名，从而解决了这个问题，也因此认识到，给微服务框架的 SDK打补丁，或者说推动微服务框架轻量化可能是一个实现对业务代码无侵入性，必须的代价。&lt;/p&gt;
&lt;p&gt;Envoy 社区目前还没有对非 HTTP 的 RPC 通信协议提供扩展支持，SOFAMosn 目前内部已经基本完成了 DUBBO 扩展的开发工作。&lt;/p&gt;
&lt;p&gt;由于 ISTIO 的服务治理，路由规则都是针对 HTTP 协议定义的，当应用到基于接口，方法调用的 RPC 服务时，会有概念模型匹配的问题，比方说在定义 Content Based Routing 规则的时候。这里，我们选择了把 RPC 协议映射到 HTTP 上去而不是重新定义新的 RPC 路由的 CRD。&lt;/p&gt;
&lt;p&gt;RPC 服务的容器模型也是个麻烦问题，目前大规模使用的 RPC 框架都是从 SOA 发展过来的，基于的还是传统的容器模型。一个容器中往往同时存在多个服务，各自有自己的版本，ISTIO 基于版本的路由要求每个服务都有自己的 POD 和 Service 定义，否则的话 Traffic Splitting 功能就无法完成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprfuxzsj30k00b9q4d_hu10632f5860e8024935c2495ff57fc5cb_56278_b2e8017f24cb7fb46622cb1131317221.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprfuxzsj30k00b9q4d_hu10632f5860e8024935c2495ff57fc5cb_56278_f38cc7de8dfc462b4cf4733995d08a7d.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprfuxzsj30k00b9q4d_hu10632f5860e8024935c2495ff57fc5cb_56278_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusprfuxzsj30k00b9q4d_hu10632f5860e8024935c2495ff57fc5cb_56278_b2e8017f24cb7fb46622cb1131317221.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;ISTIO 的控制平面抽象，顶层路由对象是 Virtual Host，Virtual Host 包含一组 Domain，通过 Domain 来选择 Virtual Host，Rate limit 也是定义在 Virtual Host 上面。&lt;/p&gt;
&lt;p&gt;在 Outbound，也就是客户端的 SIDECAR 收到请求的时候，ISTIO 为服务生成的 Virtual Host 包含了服务的域名，Cluster VIP 和 端口的多种组合形式，这个形式确保了对 Host 头和 DNS 寻址的支持。Inbound，也就是服务端的 SIDECAR 收到请求的时候因为所有流量都去到后面的服务实例，所以域名是通配所有。&lt;/p&gt;
&lt;p&gt;Route 上定义了超时，熔断，错误注入的策略。Route 上定义的 Header Matcher， Query Parameter Matcher, Path Matcher 等等都是针对 HTTP 协议的，RPC 协议需要进行映射以支持 Content Based Routing。&lt;/p&gt;
&lt;p&gt;Route Action 指向后端集群，支持重定向和直接返回，集群通过名字路由，集群的变动受到 Destination Rule 的影响，主要是反应在 Subset 的变化上，权重信息就定义在这里。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspruhzvvj30k00b9myc_huf105cd2f55f92802d6347fdece36a529_48255_73dabb62cf18bf3d315942a377f280ae.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspruhzvvj30k00b9myc_huf105cd2f55f92802d6347fdece36a529_48255_b365e1b7a6303e832ced2bb2ceaf8aad.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspruhzvvj30k00b9myc_huf105cd2f55f92802d6347fdece36a529_48255_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspruhzvvj30k00b9myc_huf105cd2f55f92802d6347fdece36a529_48255_73dabb62cf18bf3d315942a377f280ae.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SOFA 的注册中心使用 Interface 来识别服务的，服务的配置信息，消费者和提供者列表，以及超时等服务治理信息也定义在注册中心里面，可以认为是一个具备一定服务治理能力的注册中心。&lt;/p&gt;
&lt;p&gt;我们希望能够用 Interface 来调用服务，就是为了适应 RPC 框架的这个基于接口名字识别服务的概念模型。体现在 Kubernetes 里面就是用 Interface 名字当做域名，把请求头映射到 HTTP 头，请求参数映射到 Query Parameter，方法名映射到 Path 上。这样，基于 RPC 请求内容的服务治理就可以定义到方法和参数级别了，即便是蚂蚁金服站内复杂路由规则，比如 LDC 单元化流量调拨，也是可以支持的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusps37dvtj30k00b9gmv_hu7bb67524132e36d6e0b892c7088a6745_48757_5a64966111340139130413e423478e87.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusps37dvtj30k00b9gmv_hu7bb67524132e36d6e0b892c7088a6745_48757_b5b387d5a251256f8bc04e9d69ba02e6.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusps37dvtj30k00b9gmv_hu7bb67524132e36d6e0b892c7088a6745_48757_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusps37dvtj30k00b9gmv_hu7bb67524132e36d6e0b892c7088a6745_48757_5a64966111340139130413e423478e87.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们暂不考虑非 Kubernetes 平台的情况，以支持 DUBBO 作为例子&lt;/p&gt;
&lt;p&gt;如果不适用 k8 作为注册中心，需要引入 ZK。&lt;/p&gt;
&lt;p&gt;因为 ISTIO 目前还不支持 ZK，因此需要针对 DUBBO 的注册模型，与 SOFA 类似，通过 Platform Adapter 的方式加入对 DUBBO 的支持。&lt;/p&gt;
&lt;p&gt;如前所述，我们还需要修改 Pilot Discovery 的代码，正确的为 DUBBO 服务生成 Inbound 和 Outbound 的配置，比如 Listener 和 Cluster 的配置信息。我们还需要为把 ISTIO 的路由规则正确的转成 XDS 的路由配置信息。&lt;/p&gt;
&lt;p&gt;当然，我们还需要扩展 MOSN/ENVOY 来支持 DUBBO 协议，这里面有比较大的重复工作，而且还需要保证代码的执行性能。对于 MOSN 来说，需要自行实现 codec 和 stream 模块。&lt;/p&gt;
&lt;h2 id=&#34;3-sofamesh-的统一解决方案&#34;&gt;3. SOFAMesh 的统一解决方案&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspsg3qh9j30k00b9jsu_huf301852503a95d66aa9aabb623a3ae22_55622_8651785f12c4ae84be5d474db522474d.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspsg3qh9j30k00b9jsu_huf301852503a95d66aa9aabb623a3ae22_55622_945d6e85b029fe196bc1726ba667cabb.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspsg3qh9j30k00b9jsu_huf301852503a95d66aa9aabb623a3ae22_55622_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspsg3qh9j30k00b9jsu_huf301852503a95d66aa9aabb623a3ae22_55622_8651785f12c4ae84be5d474db522474d.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;考虑到支持不同 RPC框架的大量重复工作和实现过程中的性能保障，我们希望能提供一个统一的解决方案，以高性能和插件化做为重点来支持，并允许用户在性能和功能之间做平衡。&lt;/p&gt;
&lt;p&gt;这个方案是基于 Kubernetes Native 的方式来做的，使用 interface 来寻址服务，因此需要对客户端做轻量化，以做到不侵入用户的业务代码。&lt;/p&gt;
&lt;p&gt;轻量化客户端是要解决客户端 Loadbalance 引起的问题。&lt;/p&gt;
&lt;h2 id=&#34;4-dns-服务寻址方案&#34;&gt;4. DNS 服务寻址方案&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspt4o5olj30k00b9jsg_hu2dedd55ea9b52ef5fa1cc0f62adfd567_42451_cc81256a171fee8e96eb3490ff55a050.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspt4o5olj30k00b9jsg_hu2dedd55ea9b52ef5fa1cc0f62adfd567_42451_5aa5039ccb8ef308caaead2f29153a22.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspt4o5olj30k00b9jsg_hu2dedd55ea9b52ef5fa1cc0f62adfd567_42451_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspt4o5olj30k00b9jsg_hu2dedd55ea9b52ef5fa1cc0f62adfd567_42451_cc81256a171fee8e96eb3490ff55a050.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们会在 Kubernetes 的 DNS 之外额外做一层域名抽象，不受 Kubernetes 的规则的限制，比如，允许用户直接使用 interface 作为域名或者按照组织结构来规划域名的层级关系。Kubernetes 的 namespace 往往被用来作为多租户的解决方案，并不适合用来作为企业内不同部门的逻辑划分。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptd7pmnj30k00b9tab_hu0e64a28c21353096d961720f3696dd6c_61226_0a4357f89de1f8b89d928af204c9c722.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptd7pmnj30k00b9tab_hu0e64a28c21353096d961720f3696dd6c_61226_451ee9e235aae51002a6a2d708e11b05.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptd7pmnj30k00b9tab_hu0e64a28c21353096d961720f3696dd6c_61226_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptd7pmnj30k00b9tab_hu0e64a28c21353096d961720f3696dd6c_61226_0a4357f89de1f8b89d928af204c9c722.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;有些微服务应用本身没有版本，版本反应在应用中的服务接口上，往往每个接口服务都有其独立的版本，比如 SOFA 应用，其版本体现在服务接口的实例上（参考 SOFA 应用注册中心结构）。&lt;/p&gt;
&lt;p&gt;蚂蚁主站内部在做蓝绿部署和灰度的时候，往往一次蓝绿发布会有多个应用参与，为了保证引流的准确性，我们会要求流量在整个调用的链路里面全部落到蓝或者绿的实例上，不允许出现交叉调用的情况。所以对于单应用多服务的场景，我们通过 POD label 把接口区分开来，从而做到流量在 POD 间调拨的粘性。&lt;/p&gt;
&lt;p&gt;服务将会被按照接口维度创建，接口的版本和名字会反应在 POD 的 Label 上，这样做会增加运维的工作量，但是可以通过 PAAS 平台提供的工具解决这个痛点。这里面一个隐含的要求是，一个 POD 只会提供一个接口的服务，推动业务走向 Kubernetes Native。&lt;/p&gt;
&lt;p&gt;对于按照 Kubernetes Native 方式创建的应用，应用只暴露一个接口，无需加上 interface 的标签。&lt;/p&gt;
&lt;p&gt;通过 CoreDNS 的 PDSQL 插件支持，为 Cluster VIP 额外添加一个 interface name 的记录。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptj489lj30k00b9759_hue5448e847e5647a9bb67d968f744cf3a_40762_aa00f791baa0d7fdc1184cea3ae6d872.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptj489lj30k00b9759_hue5448e847e5647a9bb67d968f744cf3a_40762_863ac1d423734b2b2ac9a4fc9ebdd3e7.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptj489lj30k00b9759_hue5448e847e5647a9bb67d968f744cf3a_40762_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptj489lj30k00b9759_hue5448e847e5647a9bb67d968f744cf3a_40762_aa00f791baa0d7fdc1184cea3ae6d872.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们通过在 Destination Rule 中同时使用 Interface 和 Version 这两个 Label 来选择 Subset，每一个 Subset 都会在 Pilot Discovery 中形成一个可被路由的集群，这样通过 Subset 就可以完成 Traffic Splitting 的功能了。这样一来，蓝绿发布，灰度等能力都可基于这个RPC 接口和版本来做了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptuwzptj30k00b9q4c_huacb8e3dd37e836a59b1abeb7b7c2f03e_54658_027c479521e52a0e5ea5d0edd8470104.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptuwzptj30k00b9q4c_huacb8e3dd37e836a59b1abeb7b7c2f03e_54658_c38f50ae2f245e48ead3992987c9518b.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptuwzptj30k00b9q4c_huacb8e3dd37e836a59b1abeb7b7c2f03e_54658_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusptuwzptj30k00b9q4c_huacb8e3dd37e836a59b1abeb7b7c2f03e_54658_027c479521e52a0e5ea5d0edd8470104.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;客户端向 Interface 域名发起请求，通过本地的 resolv.conf 文件指引到 CoreDNS 服务器进行域名解析，得到服务的 Cluster VIP。&lt;/p&gt;
&lt;p&gt;客户端以 Cluser VIP 发起请求，经过 IPTables 转发到 SOFAMosn 的 12220 端口。&lt;/p&gt;
&lt;p&gt;SOFAMosn 通过 socket 拿到 original destination 后，在此端口监听的 SOFA 协议 Listener，通过 Virtual Host 的域名找到正确的 Virtual Host。&lt;/p&gt;
&lt;p&gt;SOFAMosn 将请求按照 Pilot Discovery 下发的 Destination Rule 按照权重转发到不通的后端集群。&lt;/p&gt;
&lt;p&gt;Virtual Host 在生成的时候，其域名列表中会包含 Cluster VIP。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspucuaxcj30k00b9my3_hu21199ffd9fb32c953ee991c11de84d87_38691_53e6e3c1475984ed7a1c880d787db224.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspucuaxcj30k00b9my3_hu21199ffd9fb32c953ee991c11de84d87_38691_f0cedc2cc9a5f2b1a99b0aba56fe9e8f.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspucuaxcj30k00b9my3_hu21199ffd9fb32c953ee991c11de84d87_38691_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspucuaxcj30k00b9my3_hu21199ffd9fb32c953ee991c11de84d87_38691_53e6e3c1475984ed7a1c880d787db224.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在寻址方案中，我们为 RPC Service 创建了一个新的 CRD，并创建一个 RPC Service Controller 来 Watch RPC Service。&lt;/p&gt;
&lt;p&gt;RPC Service Controller 监听到 RPC Service 更新后，通过关联的 Service，按策略找到其中一个 POD，向其发起服务列表查询。请求到达 Register Agent，Agent 通过其协议插件从 APP 实例中获取到服务列表信息后返回给 RPC Service Controller。RPC Service Conroller 使用 RPC Service 接口和 Cluster VIP 更新 CoreDNS 中的域名记录。&lt;/p&gt;
&lt;h2 id=&#34;5-x-protocol-通用协议&#34;&gt;5. X-PROTOCOL 通用协议&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspul1v8bj30k00b9jsf_huce80d987ac20f55ce2ef1de52891b1c8_41513_547ed893252b22c7a3f2c2ddff4b9dbf.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspul1v8bj30k00b9jsf_huce80d987ac20f55ce2ef1de52891b1c8_41513_c67b897401246411e8da2475ed610607.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspul1v8bj30k00b9jsf_huce80d987ac20f55ce2ef1de52891b1c8_41513_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspul1v8bj30k00b9jsf_huce80d987ac20f55ce2ef1de52891b1c8_41513_547ed893252b22c7a3f2c2ddff4b9dbf.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;七层代理的性能瓶颈往往是出现在协议数据包的解析上，由于 SIDECAR 的特殊性，它本身往往得不到足够的资源，不得不运行在资源首先的环境，以避免影响应用本身的运行。在实际的部署中，我们常常会把 SIDECARE 限定在单核心上运行，并且限制它能使用的最大内存，这些都让 SIDECAR 的转发性能面临极大的压力。考虑到 ISTIO的复杂路由规则在实际的业务场景中很多时候并不会全部都用到，我们允许用户在性能和功能之间找到一个平衡。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusput21o3j30k00b9abg_hu788a69b10683c52305676cce89aed0c2_55801_c7050eb140afd5a9dc63486e4eaf21bb.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusput21o3j30k00b9abg_hu788a69b10683c52305676cce89aed0c2_55801_8b2b217424f6fe1233c6c57595703ccc.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusput21o3j30k00b9abg_hu788a69b10683c52305676cce89aed0c2_55801_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fusput21o3j30k00b9abg_hu788a69b10683c52305676cce89aed0c2_55801_c7050eb140afd5a9dc63486e4eaf21bb.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个 Listener 的配置是参考 ISTIO 的 HTTP Connection Manager 做的，我们增加了 Downstream Protocol 和 Upstream Protocol 的配置，允许控制层面选择 SOFAMosn 之间的长连接的通行协议，比如使用 HTTP2，利用 HTTP2 的头部压缩能力提高协议的转发性能。x-protocol 配置项对应服务使用的真是通信协议，下发到 SOFAMosn 之后，SOFAMosn 通过分解 x-protocol 协议来进行适配真是请求协议，正确的加载协议插件进行协议处理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspv01mc0j30k00b93zp_hu5342fe108e54ebb5a0acbaa7e259c88f_47483_7ff1924b441433100e3ca0ed0d8a1f7a.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspv01mc0j30k00b93zp_hu5342fe108e54ebb5a0acbaa7e259c88f_47483_4927e63ee2f4040c529813c22a4989cf.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspv01mc0j30k00b93zp_hu5342fe108e54ebb5a0acbaa7e259c88f_47483_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspv01mc0j30k00b93zp_hu5342fe108e54ebb5a0acbaa7e259c88f_47483_7ff1924b441433100e3ca0ed0d8a1f7a.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先操作员在 Kubernetes 中创建 DUBBO 应用的服务，指定其 Port Name 为 x-dubbo-user，这很重要，也是 ISTIO 对 POD 的基本要求。SOFAMesh 监听到服务创建之后，开始在 Pilot 中创建 DUBBO 应用集群的x-protocol 协议的监听器和集群配置，请参考上文的 x-protocol 配置。&lt;/p&gt;
&lt;p&gt;SOFAMosn SIDECAR 启动后，使用期静态配置的 Pilot 集群地址连接到 Pilot 并开始以 SIDECAR 模式，通过 ADS 接口监听配置的变化。&lt;/p&gt;
&lt;p&gt;SOFAMesh 把 Outbound / Inbound 的配置数据通过 ADS 接口发送给监听的 SOFAMosn 实例。&lt;/p&gt;
&lt;p&gt;Inbound 和 Outbound 的 SOFAMosn 之间建立 x-protocol/http2 协议的长连接，协议可以由下发的 x-protocol 配置指定，比如 HTTP2。目前 SOFAMosn 的 HTTP2 实现并还是 PingPong 模型，不推荐用作 SOFAMosn 之间的通信协议，下个 Milestone 改进后，应该是个更好的选择。&lt;/p&gt;
&lt;p&gt;DUBBO 请求数据进入 Outbound 的 Downstream 后，SOFAMosn 会生成一个自增的 stream id，并且从插件中拿到 request id，建立两个 id 的映射表，同时利用插件把 stream id 写到请求数据中。请求经过路由计算，路由到集群，到达 Upstream 后 SOFAMosn 创建一个 x-protocol 的请求对象，把整个 DUBBO 请求数据作为 Payload，附上自定义的头，发送给 上游 Inbound 的 SOFAMosn，并把从插件中拿到的 class name 和 method name 等信息记录到自定义的头中。&lt;/p&gt;
&lt;p&gt;请求数据到达 Inbound 的 Downstream 后，MOSN 会再生成一个自增的 stream id 并通过插件取出 request id，建立映射关系，并写入 stream id。经过路由匹配之后，请求通过 Upstream 发送给后端的服务实例。&lt;/p&gt;
&lt;p&gt;服务实例返回响应，Inbound 的 SOFAMosn 从响应中拿出 request id，通过 ID 映射找回实际的 request id，写回响应对象，然后把请求用 x-protocol 打包，通过 Downstream 返回给 Outbound 的 SOFAMosn。&lt;/p&gt;
&lt;p&gt;Outbound 的 SOFAMosn 收到响应后，拿出响应对象，并通过插件拿回 request id，最后通过 ID 映射关系找回实际的 request id，写回响应对象后，通过 Downstream 返回给应用实例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvmkhhvj30k00b9t9s_hueec25e4b271df57a9b112cc7bd3603ea_43786_30311d13d6742a336d6b2bbaeefe727f.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvmkhhvj30k00b9t9s_hueec25e4b271df57a9b112cc7bd3603ea_43786_5f06a52139d60c2bf4a047516651f51f.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvmkhhvj30k00b9t9s_hueec25e4b271df57a9b112cc7bd3603ea_43786_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvmkhhvj30k00b9t9s_hueec25e4b271df57a9b112cc7bd3603ea_43786_30311d13d6742a336d6b2bbaeefe727f.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvsaykoj30k00b9dgv_hu3f452a3e42ecbb75c01ec805b05598b4_40495_19a5259a299d46f69f7023a0e8d0841b.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvsaykoj30k00b9dgv_hu3f452a3e42ecbb75c01ec805b05598b4_40495_a21835fd5810b07e0f7663069d959858.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvsaykoj30k00b9dgv_hu3f452a3e42ecbb75c01ec805b05598b4_40495_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvsaykoj30k00b9dgv_hu3f452a3e42ecbb75c01ec805b05598b4_40495_19a5259a299d46f69f7023a0e8d0841b.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;获得不同层次的能力，所付出的性能开销和接入成本也会不同，可以根据实际情况做出取舍。Golang 的接口特性允许协议插件的开发人员根据需要实现接口，还可以进行接口的组合。&lt;/p&gt;
&lt;p&gt;开箱即用模式作为不解包方案，提供LabelRouting，LabelAccessControl，LabelFaultInjection，TLS，RateLimits，Metrics的能力，以高性能和低成本为亮点。&lt;/p&gt;
&lt;p&gt;轻度解包可以获得更多能力，如多路复用，Accesslog，流控，熔断等（视具体协议而定），是性能和能力间的权衡选择。&lt;/p&gt;
&lt;p&gt;更进一步，完全解除协议的头，可以获得将能力最大化，相对的性能开销和成本也同样最大化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvwky7ej30k00b93z9_hu8c45a2fd0dccfbc4e17ebdc8b10a43d0_31798_6721e0df36af3bbf44e85d3b020b9ee5.webp 400w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvwky7ej30k00b93z9_hu8c45a2fd0dccfbc4e17ebdc8b10a43d0_31798_58c27ee4c81a858eafab7cfb0b4c0f0f.webp 760w,
               /blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvwky7ej30k00b93z9_hu8c45a2fd0dccfbc4e17ebdc8b10a43d0_31798_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/ant-financial-sofamesh-common-protocol-extension/0069RVTdly1fuspvwky7ej30k00b93z9_hu8c45a2fd0dccfbc4e17ebdc8b10a43d0_31798_6721e0df36af3bbf44e85d3b020b9ee5.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;8月底发布的 SOFMesh 版本默认将会用 SOFAMosn 代替 ENVOY 做数据平面，ISTIO 自带的 BookInfo 的例子可以提供给大家试用。我们后续还会提供 SOFA/DUBBO 应用的例子。&lt;/p&gt;
&lt;p&gt;目前 SOFAMosn 还不能在 Gateway 模式中使用，即不能用于 Ingress，而且部分高级路由功能，以及熔断，限流等高级治理能力目前还不支持。另外这个版本的 Mixer 节点也去除了，我们会在 9 月份的版本中持续完善 SOFAMosn 和 SOFAMesh，加入高级服务治理能力，同时我们也会完成 Mixer 的 Report 部分能力，放到开源版本中。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文首先介绍蚂蚁金服开源的 SOFAMesh ，然后分享在 SOFAMesh 上落地 UC 的 HSF 应用和蚂蚁的 SOFA 应用碰到的问题，以及我们总结出来的解决方案和最佳实践。最后分别就其中有代表性的 DNS 寻址方案和 X-PROTOCOL 协议分享一下做法。希望大家内部的 DUBBO 或者其他功能内部的 RPC 应用在 Service Mesh 落地的时候，能够有个参考。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
