<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>云原生 | 云原生社区（中国）</title>
    <link>https://cloudnative.to/tag/%E4%BA%91%E5%8E%9F%E7%94%9F/</link>
      <atom:link href="https://cloudnative.to/tag/%E4%BA%91%E5%8E%9F%E7%94%9F/index.xml" rel="self" type="application/rss+xml" />
    <description>云原生</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Fri, 02 Feb 2024 13:05:42 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>云原生</title>
      <link>https://cloudnative.to/tag/%E4%BA%91%E5%8E%9F%E7%94%9F/</link>
    </image>
    
    <item>
      <title>后 Serverless 时代的云计算趋势分析</title>
      <link>https://cloudnative.to/blog/cloud-computing-post-serverless-trends/</link>
      <pubDate>Fri, 02 Feb 2024 13:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-computing-post-serverless-trends/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://www.infoq.com/articles/cloud-computing-post-serverless-trends/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud-Computing in the Post-Serverless Era: Current Trends and beyond&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要：这篇文章主要讨论了未来云计算领域的三大趋势：从基本元素到云构件作为服务的转变、从超大规模到超专业化的转变、以及从基础设施到组合式编程作为服务的转变。作者指出，未来的云服务将更加集成编程构件，使得开发人员能够无缝地使用他们喜欢的编程语言来组合应用程序。文章强调了这些趋势对开发人员和运营团队的影响，并指出了这些变化将如何塑造未来以开发人员为中心的云服务。&lt;/p&gt;
&lt;h2 id=&#34;主要观点&#34;&gt;主要观点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无服务器计算正在超越其最初的范围，函数部分或完全被多才多艺的云构件取代，标志着云架构的新时代。&lt;/li&gt;
&lt;li&gt;云市场正朝着高度专业化的垂直多云服务转变，提供独特的、精细粒度的功能，专门满足开发人员的需求。&lt;/li&gt;
&lt;li&gt;即将推出的云服务将充满构件，改变开发人员处理路由、过滤和事件触发等任务的方式，使其更高效和用户友好。&lt;/li&gt;
&lt;li&gt;从基础设施即代码转向构件即代码的趋势显著，开发人员使用熟悉的编程语言进行更直观的云服务配置。&lt;/li&gt;
&lt;li&gt;微服务正在云景观中重新定义，从仅仅是架构边界演变为组织边界，在统一的开发者语言下整合各种云构件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AWS Lambda 将在今年迎来其 10 周年之际，无服务器计算不再仅限于“函数即服务”（FaaS）。今天，无服务器描述了不需要手动配置、提供按需自动扩展和使用基于消耗的定价的云服务。这一转变是云计算中更广泛演变的一部分，无服务器技术不断变革。本文关注无服务器之后的未来，探讨云景观将如何发展超越当前的超级扩展模型以及对开发人员和运营团队的影响。我将探讨塑造这一演变的前三大趋势。&lt;/p&gt;
&lt;h2 id=&#34;从基本构件到构件即服务&#34;&gt;从基本构件到构件即服务&lt;/h2&gt;
&lt;p&gt;在软件开发中，“模块”或“组件”通常指的是执行一组协同操作的自包含软件单元。这个概念与通常在长时间运行的计算服务（如虚拟机（VM）或容器服务）上运行的微服务架构相对应。AWS EC2 是第一个广泛可访问的云计算服务之一，提供可扩展的 VM。引入这样的可扩展、可访问的云资源为微服务架构变得实用和普及提供了基础。这种转变导致将庞大的应用程序分解成可独立部署的微服务单元。&lt;/p&gt;
&lt;p&gt;让我们继续使用软件单元的这个类比。函数是一个代码块，封装了一系列具有定义的输入和输出的单一任务的语句序列。这个代码单元与 FaaS 执行模型非常匹配。在事件触发无需管理基础架构的情况下执行代码的 FaaS 概念在 AWS Lambda 之前已经存在，但缺乏广泛的实施和认可。&lt;/p&gt;
&lt;p&gt;在 AWS Lambda 将 FaaS 带入主流之前，已经有了执行代码以响应事件而无需管理基础架构的 FaaS 概念，如 Google App Engine、Azure WebJobs、IronWorker 和 AWS Elastic Beanstalk 等服务。Lambda 作为 FaaS 的首个重大商业实施，通过简化开发人员的部署流程，成为其流行的催化剂。这一进步导致将微服务转变为更小的、可单独扩展的、事件驱动的操作。&lt;/p&gt;
&lt;p&gt;在向作为服务提供的更小软件单元的演进中，人们可能会想知道我们是否会看到基本的编程元素，如表达式或语句作为服务（例如 int x = a + b;）。然而，演进的方向与此不同。相反，我们正在见证函数的最小化和最终由可配置的云构件替代。在软件开发中，构件涵盖了诸如条件语句（if-else、switch 语句）、循环（for、while）、异常处理（try-catch-finally）或用户定义的数据结构等元素，这些元素在控制程序流程或管理复杂数据类型方面发挥着重要作用。在云服务中，构件与能够组成分布式应用程序的能力相一致，它们互相链接软件模块，如微服务和函数，并管理它们之间的数据流。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-computing-post-serverless-trends/f1_hu2af43fe4a71a9d2c64e3fa98f41d525b_44219_9c980474de5866ca35459826802767be.webp 400w,
               /blog/cloud-computing-post-serverless-trends/f1_hu2af43fe4a71a9d2c64e3fa98f41d525b_44219_8d0ee991f4e49651b2003ee4f6014239.webp 760w,
               /blog/cloud-computing-post-serverless-trends/f1_hu2af43fe4a71a9d2c64e3fa98f41d525b_44219_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-computing-post-serverless-trends/f1_hu2af43fe4a71a9d2c64e3fa98f41d525b_44219_9c980474de5866ca35459826802767be.webp&#34;
               width=&#34;760&#34;
               height=&#34;296&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云构件取代函数，取代微服务，取代庞大的应用程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然以前可能使用函数来过滤、路由、批量处理、拆分事件，或调用另一个云服务或函数，但现在这些操作以及更多操作都可以在你的函数中使用更少的代码，或者在许多情况下根本不需要函数代码。它们可以被可配置的云构件替代，这些构件是云服务的一部分。让我们看一些 AWS 的具体示例，以演示从 Lambda 函数代码到云构件的过渡：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;请求路由&lt;/strong&gt; - 不再使用 Lambda 来解析请求并将其路由到正确的后端端点，而是可以使用&lt;a href=&#34;https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-routes.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API Gateway 路由&lt;/a&gt;进行路由。而且，API Gateway 还可以与其他 AWS 服务集成，直接调用它们，消除了对函数的需求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求验证&lt;/strong&gt; - API Gateway 可以使用 OpenAPI 验证请求的主体、查询字符串参数和标头。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据转换&lt;/strong&gt; - API Gateway 可以使用 Apache Velocity 模板来&lt;a href=&#34;https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;转换&lt;/a&gt;请求和响应数据，以覆盖有效载荷、参数、标头和状态代码，而无需使用 Lambda。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流式数据库更改&lt;/strong&gt; - &lt;a href=&#34;https://aws.amazon.com/blogs/database/dynamodb-streams-use-cases-and-design-patterns/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DynamoDB Streams&lt;/a&gt;会发出所有数据更改。这对于任何数据存储来说都是一个必要的构件，消除了应用程序代码的双重写入和任何数据轮询代码，通过&lt;a href=&#34;https://www.infoq.com/articles/microservices-inside-out/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;将微服务内外颠倒&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件触发&lt;/strong&gt; - &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS 事件源映射&lt;/a&gt;允许通过从事件源读取并调用 Lambda 函数来触发 Lambda。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件过滤&lt;/strong&gt; - &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;事件源映射&lt;/a&gt;可以执行事件过滤，以控制从流或队列中调用 Lambda 函数的哪些记录。这消除了在函数内编写过滤逻辑的需要，并大大减小了函数的大小和成本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件批处理&lt;/strong&gt; - 类似地，事件源映射会将记录批处理成单个有效载荷，然后发送给你的函数。不需要手动循环聚合事件或在处理之前拆分它们。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件转换&lt;/strong&gt; - &lt;a href=&#34;https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes-input-transformation.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EventBridge Pipes&lt;/a&gt;可以在将数据发送到目标之前使用 JSON 路径语法来转换源数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件丰富化&lt;/strong&gt; - EventBridge Pipes 还可以调用另一个端点来丰富请求，然后进一步处理它。这提供了可以完全声明性使用的&lt;a href=&#34;https://www.enterpriseintegrationpatterns.com/patterns/messaging/DataEnricher.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;内容丰富器模式&lt;/a&gt;的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件路由&lt;/strong&gt; - 与请求路由类似，EventBridge &lt;a href=&#34;https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rules.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;规则&lt;/a&gt;可以执行事件路由，允许你从应用程序代码中卸载此责任，并消除 Lambda 函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于结果的路由&lt;/strong&gt; - Lambda &lt;a href=&#34;https://aws.amazon.com/blogs/compute/introducing-aws-lambda-destinations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Destination&lt;/a&gt;允许异步调用将执行结果路由到其他 AWS 服务，以配置代码替换 Lambda 调用代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用其他服务&lt;/strong&gt; - &lt;a href=&#34;https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-services.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;StepFunction&lt;/a&gt; 任务不需要 Lambda 函数来调用其他服务或外部 HTTP 端点。通过这种方式，StepFunction 任务定义可以执行例如&lt;a href=&#34;https://aws.amazon.com/blogs/aws/external-endpoints-and-testing-of-task-states-now-available-in-aws-step-functions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;执行 HTTP 调用&lt;/a&gt;或读取、更新和删除数据库记录等操作，而无需 Lambda 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这只是应用程序代码构件变成无服务器云构件的一些示例。你可以通过配置验证输入值，而不是在函数中使用 if-else 逻辑。你可以在函数之外声明性地定义路由逻辑，而不是使用 case 或 switch 语句从函数内调用其他代码。事件可以在数据更改时触发，批处理或拆分，无需重复构造，例如 for 或 while 循环。&lt;/p&gt;
&lt;p&gt;事件可以在没有函数的情况下进行验证、转换、批处理、路由、过滤和丰富。故障可以在没有 try-catch 代码的情况下进行处理和定向到 &lt;a href=&#34;https://aws.amazon.com/about-aws/whats-new/2023/06/amazon-sqs-dead-letter-queue-redrive-aws-sdk-cli/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DLQs 和回退&lt;/a&gt;，而成功完成可以定向到其他函数和服务端点。将这些构件从应用程序代码移到构件配置中减少了应用程序代码的大小，或者将其移除，消除了安全修补和任何维护的需要。&lt;/p&gt;
&lt;p&gt;在编程中，原语和构件具有不同的含义和作用。原语是编程语言固有的基本数据类型。它包含了基本值，例如整数、浮点数、布尔值或字符，不包含其他类型。与此概念类似，云 - 就像一个巨大的编程运行时 - 正在从基础设施原语（如网络负载均衡器、虚拟机、文件存储和数据库）进化为更精致和可配置的云构件。&lt;/p&gt;
&lt;p&gt;与编程构件类似，这些云构件编排分布式应用程序交互并管理复杂的数据流。然而，这些构件不是孤立的云服务；没有独立的“过滤器服务”或“事件发射器服务”。没有“构件作为服务”，但它们越来越成为核心云原语（如网关、数据存储、消息代理和函数运行时）的重要功能。&lt;/p&gt;
&lt;p&gt;这种演进降低了应用程序代码的复杂性，并在许多情况下消除了自定义函数的需求。这从 FaaS 到 NoFaaS（无麻烦，意味着简单）的转变刚刚开始，有深入的&lt;a href=&#34;https://www.youtube.com/watch?v=sdCA0Y7QDrM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;和 GitHub 上的代码示例。接下来，我将探讨垂直多云服务中构件丰富的云服务的出现。&lt;/p&gt;
&lt;h2 id=&#34;从超大规模到超专业化&#34;&gt;从超大规模到超专业化&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&#34;https://www.diagrid.io/blog/evolution-of-cloud-computing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;无服务器后云时代&lt;/a&gt;，仅提供高度可扩展的云原语（如容器和函数的计算，或诸如键/值存储、事件存储、关系数据库或网络原语等存储服务）已经不再足够。无服务器后云服务必须富含开发者构件，并卸载应用程序的大部分基础设施。这超越了为广泛用户群体进行通用云服务的超大规模；它涉及深度专业化，并向更具要求的用户公开高级构件。&lt;/p&gt;
&lt;p&gt;像 AWS、Azure、GCP 等超大规模云服务提供商，凭借其广泛的服务范围和庞大的用户群体，很好地把握了新用户需求和构件。然而，提供这些更细粒度的开发者构件会增加复杂性。每个服务中的每个新构件都需要深入学习曲线以了解其有效利用的特定内容。因此，在无服务器后时代，我们将看到垂直多云服务的兴起，这些服务在一个领域表现出色。这代表了云服务的超专业化。&lt;/p&gt;
&lt;p&gt;以 Confluent Cloud 为例。虽然所有主要的超大规模云服务提供商（AWS、Azure、GCP 等）都提供 Kafka 服务，但没有一家能够与 Confluent Cloud 提供的开发者体验和构件相匹配。通过其 Kafka 代理、众多的 Kafka 连接器、集成的模式注册表、Flink 处理、数据治理、跟踪和消息浏览器，Confluent Cloud 提供了最丰富和专业化的 Kafka 服务，超越了超大规模云服务提供商的提供。&lt;/p&gt;
&lt;p&gt;这种趋势并不孤立；许多例子包括 MongoDB Atlas 与 DocumentDB、GitLab 与 CodeCommit、DataBricks 与 EMR、RedisLabs 与 ElasticCache 等。除了已建立的云公司外，新一波初创公司正在崭露头角，专注于一个多云原语（如专业化的计算、存储、网络、构件流水线、监控等）并通过开发者构件来丰富它，以提供独特的价值主张。以下是一些专门化于单一开源技术的云服务，旨在提供丰富的构件体验，并吸引用户远离超大规模云服务提供商：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://vercel.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vercel&lt;/a&gt;：以其出色的前端开发者体验而闻名，简化了 Web 应用程序的部署。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://railway.app/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Railway&lt;/a&gt;：以增强后端开发者体验以及简单的部署和扩展管理而著名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://supabase.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Supabase&lt;/a&gt;：是 Firebase 的开源替代方案，提供更灵活的相似功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://fauna.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fauna&lt;/a&gt;：以声明性关系查询和强一致性事务中的功能业务逻辑而闻名的无服务器数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://neon.tech/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Neon&lt;/a&gt;：提供最简单的无服务器 PostgreSQL，具有数据库分支和最小管理开销等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://planetscale.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PlanetScale&lt;/a&gt;：以高级 MySQL 云服务而闻名，侧重于开发友好的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://polyscale.ai/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PolyScale&lt;/a&gt;：专注于通过智能缓存优化数据性能的 AI 驱动缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://upstash.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstash&lt;/a&gt;：提供全托管的低延迟无服务器 Kafka 解决方案，适用于事件流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.diagrid.io/catalyst&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Diagrid Catalyst&lt;/a&gt;：提供用于消息、数据和工作流的无服务器 Dapr API，充当云服务之间的连接纽带。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://temporal.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Temporal&lt;/a&gt;：提供持久的执行，为可靠管理复杂工作流程提供平台。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个列表代表了一个不断增长的生态系统的一部分，这个生态系统是建立在超大规模云服务提供商提供的核心云原语之上的垂直多云服务。它们通过提供一套全面的可编程构件和增强的开发者体验来竞争。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-无服务器云服务通过丰富的开发人员构造超专业地处理一件事&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;无服务器云服务通过丰富的开发人员构造，超专业地处理一件事&#34; srcset=&#34;
               /blog/cloud-computing-post-serverless-trends/f2_hu81d2c012dc32729ef0c06650105a1c99_90677_f625166ab97ebbf6b5053481367e1def.webp 400w,
               /blog/cloud-computing-post-serverless-trends/f2_hu81d2c012dc32729ef0c06650105a1c99_90677_505183c6d3f627cbbabf789248d11149.webp 760w,
               /blog/cloud-computing-post-serverless-trends/f2_hu81d2c012dc32729ef0c06650105a1c99_90677_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-computing-post-serverless-trends/f2_hu81d2c012dc32729ef0c06650105a1c99_90677_f625166ab97ebbf6b5053481367e1def.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      无服务器云服务通过丰富的开发人员构造，超专业地处理一件事
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;一旦完成了这个过渡，缺乏丰富构件的基本云服务，甚至是无服务器的云服务，都会显得像过时的本地软件。存储服务必须像 DynamoDB 一样流式传输更改；消息代理应包括类似于 EventBridge 的构件，用于事件驱动的路由、过滤和终端点调用，包括重试和 DLQs；发布/订阅系统应提供消息批处理、拆分、过滤、转换和丰富功能。&lt;/p&gt;
&lt;p&gt;最终，虽然超大规模云服务提供商通过不断增加的服务数组在水平方向扩展，但超专业化服务提供商在垂直方向增长，提供一个丰富构件的最佳服务，形成一个&lt;a href=&#34;https://www.infoq.com/articles/cloud-bound-applications/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;生态系统&lt;/a&gt;的垂直多云服务。云服务竞争的未来将从基础设施原语转向核心云原语和面向开发者的构件的组合。&lt;/p&gt;
&lt;h2 id=&#34;从基础设施到组合即代码cac&#34;&gt;从基础设施到组合即代码（CaC）&lt;/h2&gt;
&lt;p&gt;云构件越来越模糊了应用程序和基础设施职责之间的界限。下一个演进是云自动化的“左移”，将应用程序和自动化代码集成为工具和责任的一部分。让我们看看这个过渡是如何展开的。&lt;/p&gt;
&lt;p&gt;云基础设施管理的第一代是由基础设施即代码（IaC）定义的，这是一种旨在简化基础设施的供应和管理的模式。这种方法建立在云计算中虚拟化的商品化趋势的基础上。&lt;/p&gt;
&lt;p&gt;最初的 IaC 工具引入了专门用于以可重复的方式创建、配置和管理云资源的领域特定语言（DSL）。像 Chef、Ansible、Puppet 和 Terraform 这样的工具引领了这个阶段。这些工具利用了声明性语言，允许运维团队以代码定义基础设施的期望状态，抽象出底层的复杂性。&lt;/p&gt;
&lt;p&gt;然而，随着云计算从低级粗粒度基础设施过渡到更面向开发者的可编程细粒度构件，使用现有通用编程语言来定义这些构件的趋势正在兴起。新的参与者，如 Pulumi 和 AWS Cloud Development Kit（CDK），处于这一浪潮的前沿，支持诸如 TypeScript、Python、C#、Go 和 Java 等语言。&lt;/p&gt;
&lt;p&gt;采用通用编程语言的转变是由于需要克服声明性语言的局限性，后者在以编程方式定义云构件方面缺乏表现力和灵活性，并且由于云构件配置的责任从运维转向开发者。与适用于低级静态基础设施的声明性语言的静态性质不同，通用编程语言使开发者能够定义动态、逻辑驱动的云构件，实现与应用程序代码更紧密的对齐。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-将应用程序的组成从基础设施转移到开发人员团队&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;将应用程序的组成从基础设施转移到开发人员团队&#34; srcset=&#34;
               /blog/cloud-computing-post-serverless-trends/f3_hu8b369d7de1b4dfcb4a7596d847746bcc_63367_064507ef326821fcd3732d40314b4364.webp 400w,
               /blog/cloud-computing-post-serverless-trends/f3_hu8b369d7de1b4dfcb4a7596d847746bcc_63367_defcd6ae887e69eda11575b28505c3ae.webp 760w,
               /blog/cloud-computing-post-serverless-trends/f3_hu8b369d7de1b4dfcb4a7596d847746bcc_63367_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-computing-post-serverless-trends/f3_hu8b369d7de1b4dfcb4a7596d847746bcc_63367_064507ef326821fcd3732d40314b4364.webp&#34;
               width=&#34;760&#34;
               height=&#34;432&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      将应用程序的组成从基础设施转移到开发人员团队
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;无服务器后云开发人员需要通过创建函数和微服务来实现业务逻辑，但还需要使用可编程云构件将它们组合在一起。这塑造了更广泛的开发者责任集，用于开发和组合云应用程序。例如，具有 Lambda 函数中的业务逻辑的代码还需要 API Gateway 中的路由、过滤和请求转换配置。&lt;/p&gt;
&lt;p&gt;另一个 Lambda 函数可能需要 DynamoDB 流配置来流式传输特定数据更改，EventBridge 路由、过滤和丰富配置。&lt;/p&gt;
&lt;p&gt;第三个应用程序可能将其大部分编排逻辑表达为 StepFunction，其中 Lambda 代码只是一个小任务。开发者，而不是平台工程师或运维成员，可以将这些代码单元组合在一起。工具，如 Pulumi、AWS CDK 和其他工具，允许开发者使用他们选择的语言来实现函数，并使用相同的语言来组合它与云环境的交互，最适合这个时代。&lt;/p&gt;
&lt;p&gt;平台团队仍然可以使用声明性语言，比如 Terraform，来管理、保护、监视和启用云环境中的团队，但以开发者为重点的构件，结合以开发者为重点的云自动化语言，将云构件向左移动，并使开发者能够自助使用云服务成为现实。&lt;/p&gt;
&lt;p&gt;从 DSL 到通用编程语言的过渡标志着 IaC 演进的重要里程碑。它承认了应用程序代码向云构件的过渡，这些构件通常需要开发者更深入地控制资源以满足应用程序需求。这个转变代表了 IaC 工具的成熟，现在需要满足更广泛的基础设施编排需求，为更复杂、更高级的抽象和工具铺平了道路。&lt;/p&gt;
&lt;p&gt;基础设施管理的过程将从静态配置转向更加动态、基于代码的方法。这一演进不仅仅止步于基础设施即代码，它正在超越到一个更加微妙的领域，被称为组合即代码。这一范式进一步模糊了应用程序代码和基础设施之间的界限，导致更加流畅、高效和开发者友好的实践。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;总结趋势及其加强效应，我们观察到编程构件逐渐整合到云服务中。每个计算服务都将集成 CI/CD 流水线；数据库将提供来自边缘的 HTTP 访问并发出更改事件；消息代理将通过过滤、路由、幂等性、转换、DLQ 等功能增强能力。&lt;/p&gt;
&lt;p&gt;基础设施服务正在演变为无服务器 API、从代码中推断的基础设施 (&lt;a href=&#34;https://klo.dev/state-of-infrastructure-from-code-2023/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IfC&lt;/a&gt;)、&lt;a href=&#34;https://vercel.com/blog/framework-defined-infrastructure&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;框架定义的基础设施&lt;/a&gt;，或由开发者明确组合 (CaC)。这一演进导致了更小的函数，有时甚至是 NoFaaS 模式，为超专业化、以开发者为先的垂直多云服务铺平了道路。这些服务将提供&lt;a href=&#34;https://thenewstack.io/raising-the-serverless-bar-infrastructure-apis-unleash-more-value-for-enterprises/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可编程 API 的基础设施&lt;/a&gt;，使开发者能够无缝地使用他们喜欢的编程语言合并其应用程序。&lt;/p&gt;
&lt;p&gt;使用云服务进行应用程序构件的左移将与应用程序编程越来越融合，将微服务从一种架构风格转变为一种组织风格。一个微服务将不再只是一个单一的部署单元或过程边界，而是由开发者选择的单一语言中实现和粘合的函数、容器和云构件组成。未来正在成为超专业化，并专注于以开发者为先的云。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> CNCF 平台白皮书</title>
      <link>https://cloudnative.to/blog/cncf-platforms-white-paper/</link>
      <pubDate>Fri, 14 Apr 2023 11:17:22 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cncf-platforms-white-paper/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;译者注：本文译自 &lt;a href=&#34;https://tag-app-delivery.cncf.io/whitepapers/platforms/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 平台白皮书&lt;/a&gt;，介绍了如何构建云原生计算平台以及平台可能提供的能力。这些能力包括 Web 门户、API、黄金路径模板、自动化、开发环境、可观测性、基础设施服务、数据服务、消息和事件服务、身份和密码管理服务、安全服务和工件存储。此外，该文档还介绍了与平台相关的术语，如平台、平台能力提供者、平台工程师、平台产品经理、平台团队和平台用户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;受 DevOps 所承诺的跨职能合作的启发，平台工程正在企业中作为一种明确的合作形式出现。平台策划和呈现基础功能、框架和体验，以促进和加速应用程序开发人员、数据科学家和信息工作者等内部客户的工作。特别是在云计算领域，平台已经帮助企业实现了云计算长期承诺的价值，例如快速的产品发布、跨基础架构的可移植性、更安全和更弹性的产品以及更高的开发者生产力。&lt;/p&gt;
&lt;p&gt;本文旨在支持企业领导、企业架构师和平台团队领导者提倡、调查和计划云计算内部平台。我们相信平台对企业的实际价值流有重大影响，但只是间接的，因此领导共识和支持对平台团队的长期可持续性和成功至关重要。在本文中，我们将通过讨论平台的价值、如何衡量该价值以及如何实施最大化该价值的平台团队来实现这种支持。&lt;/p&gt;
&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;为什么需要平台？&lt;/li&gt;
&lt;li&gt;什么是平台？&lt;/li&gt;
&lt;li&gt;成功平台的属性&lt;/li&gt;
&lt;li&gt;成功平台团队的属性&lt;/li&gt;
&lt;li&gt;实施平台时的挑战&lt;/li&gt;
&lt;li&gt;如何衡量平台的成功&lt;/li&gt;
&lt;li&gt;平台的功能&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;为什么需要平台&#34;&gt;为什么需要平台？&lt;/h2&gt;
&lt;p&gt;云平台和平台工程是当前热门话题。在深入探讨平台构建的定义、技术和测量之前，先探讨一下驱动平台提供的价值。&lt;/p&gt;
&lt;p&gt;在过去 20-30 年的流程改进中，软件应用程序和产品团队的敏捷性显著提高，为它们提供了基础设施（如计算、网络和存储）和开发人员服务（如构建、测试、交付和可观测性）的灵活服务。这种自主权和流程改进也逐渐使越来越多的支持服务责任转移到产品团队，迫使他们花费越来越多的时间和认知精力处理基础设施问题，从而减少了他们为组织创造价值的时间。&lt;/p&gt;
&lt;p&gt;希望重新聚焦交付团队的核心任务并减少组织内重复的工作，促使企业实施云原生计算平台。通过投资平台，企业可以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减轻产品团队的认知负荷，从而加速产品开发和交付&lt;/li&gt;
&lt;li&gt;通过专家的配置和管理改进依赖于平台能力的产品的可靠性和弹性&lt;/li&gt;
&lt;li&gt;通过在企业内的多个团队之间重用和共享平台工具和知识，加速产品开发和交付&lt;/li&gt;
&lt;li&gt;通过管理平台能力及其周围的用户、工具和流程，减少产品和服务的安全、法规和功能问题的风险&lt;/li&gt;
&lt;li&gt;通过使公共云服务和其他托管提供商的服务具有成本效益和生产力，使其能够代表他们实施实现而保持对用户体验的控制&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些好处部分得益于少量的平台团队服务于众多的产品团队，从而扩大了其影响力；部分得益于平台团队集中管理共同的功能，促进了治理；部分得益于平台团队将用户界面和体验置于首位。&lt;/p&gt;
&lt;p&gt;平台专家团队不仅减轻了对产品团队的共同工作负担，还优化了这些产品中使用的平台能力。平台团队还维护了一组传统的模式、知识和工具，这些都在企业中广泛使用，使开发人员能够快速为基于同一基础构建的其他团队和产品做出贡献。共享的平台模式也允许在模板、模式和能力中嵌入治理和控件。最后，因为平台团队管理提供者并为其提供一致的体验，它们可以为基础但无差异化的能力（例如数据库、身份访问、基础架构运营和应用程序生命周期）的有效使用提供支持。&lt;/p&gt;
&lt;h2 id=&#34;平台是什么&#34;&gt;平台是什么&lt;/h2&gt;
&lt;p&gt;云原生计算的平台是根据平台的用户需求定义和呈现的一组集成功能。它是一个跨应用程序和用例集合的横向层，确保为广泛的应用程序和用例组织提供典型的功能和服务的一致体验。一个好的平台提供了一致的用户体验，用于使用和管理其功能和服务，例如 Web 门户、项目模板和自助式 API。&lt;/p&gt;
&lt;p&gt;根据 Atlassian [ &lt;a href=&#34;https://www.atlassian.com/devops/frameworks/team-topologies&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;1&lt;/a&gt;] 的说法，“平台团队创建可以由众多流程对齐的 [产品] 团队使用的功能，减少了流程对齐 [产品] 团队的资源和认知负荷…… 平台团队可以创建跨不同用户体验或产品的连贯体验。”&lt;/p&gt;
&lt;p&gt;根据 Martin Fowler 和 Evan Bottcher [ &lt;a href=&#34;https://martinfowler.com/articles/talk-about-platforms.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2&lt;/a&gt;] 的说法，“数字平台是一个自助式 API、工具、服务、知识和支持基础，按照一个引人注目的内部产品的方式组织。自治交付团队可以利用该平台以更高的速度交付产品功能，并减少协调。”&lt;/p&gt;
&lt;p&gt;平台应支持的具体功能和场景应由利益相关者和用户确定。虽然平台为这些所需的功能提供支持，但关键是要注意，平台团队并不总是必须自己 &lt;em&gt;实现&lt;/em&gt; 它们。托管服务提供商或专用的内部团队可以维护支持实现，而平台是提供一致性的最薄合理层，能够跨提供的实现提供一致性并满足组织的要求。例如，一个非常简单的“平台”可以是一个 wiki 页面，其中包含链接到标准操作程序，以从提供者那里规定能力，如 [ &lt;a href=&#34;https://teamtopologies.com/key-concepts-content/what-is-a-thinnest-viable-platform-tvp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;3&lt;/a&gt;] 所述。&lt;/p&gt;
&lt;p&gt;因为这些平台只针对企业的内部用户，所以我们通常将它们称为 &lt;em&gt;内部&lt;/em&gt; 平台。&lt;/p&gt;
&lt;p&gt;平台对于云原生架构尤为重要，因为它们比以前的范式更好地将支持功能与特定于应用程序的逻辑分离。在类似云的环境中，资源和功能通常独立管理，并与自定义业务组件集成；这些资源可能包括数据库和对象存储、消息队列和代理、可观测性收集器和仪表板、用户目录和认证系统、任务运行程序和协调器等。内部平台以使它们易于集成到其应用程序和系统中的方式向企业团队提供这些资源。&lt;/p&gt;
&lt;h3 id=&#34;平台成熟度&#34;&gt;平台成熟度&lt;/h3&gt;
&lt;p&gt;在最基本的层面上，内部平台为获取和使用诸如管道运行器、数据库系统或密钥存储等单个服务提供了一致的体验。随着内部平台的成熟，它们也提供了此类服务的&lt;em&gt;组合&lt;/em&gt;，例如针对关键场景（如 Web 应用程序开发或数据分析，即 MLOps）的自助模板。&lt;/p&gt;
&lt;p&gt;企业可通过平台实现的用例可能按以下顺序发展：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;产品开发人员可以按需提供能力并立即使用它们来运行系统，例如计算、存储、数据库或身份验证。&lt;/li&gt;
&lt;li&gt;产品开发人员可以按需提供服务空间并使用它们来运行管道和任务，存储工件和配置，并 / 或收集遥测。&lt;/li&gt;
&lt;li&gt;第三方软件的管理员可以按需提供所需的依赖项，例如数据库，并轻松安装和运行该软件。&lt;/li&gt;
&lt;li&gt;产品开发人员可以从模板中提供完整的环境，组合运行时和开发时所需的服务，以满足特定场景的需求，例如 Web 开发或 MLOps。&lt;/li&gt;
&lt;li&gt;产品开发人员和经理可以通过自动仪表化和标准仪表板观察已部署服务的功能、性能和成本。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过为单个能力或它们的集合提供一致、合规的体验，内部平台最终使用户更轻松、更有效地交付有价值的产品。&lt;/p&gt;
&lt;h2 id=&#34;平台的属性&#34;&gt;平台的属性&lt;/h2&gt;
&lt;p&gt;在定义平台是什么以及组织为什么要建立一个平台之后，让我们识别一些影响平台成功的关键属性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;平台作为产品&lt;/strong&gt;。平台存在是为了服务于其用户的要求，它应该基于这些要求进行设计和演进，类似于任何其他软件产品。平台应该提供必要的能力，以支持产品团队中最常见的用例，并优先考虑那些只被单个团队使用的更具体的能力，以最大化提供的价值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户体验&lt;/strong&gt;。平台应该通过一致的接口提供其功能，并专注于用户体验。平台应该尽力满足其用户的需求，这可能意味着使用 GUI、API、命令行工具、IDE 和门户的组合。例如，平台通常提供部署应用程序的功能。开发人员可能会通过 IDE 消费这样的功能，测试人员可能会使用命令行工具，而产品所有者可能会使用基于 GUI 的 Web 门户。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文档和入门&lt;/strong&gt;。文档是成功软件产品的关键方面之一。为了能够使用平台的功能，用户需要文档和示例。平台应该随着适当的文档交付，以满足其用户的需求。它还应该提供工具来加速新项目的入门，以帮助用户以快速简单的方式消费必要的平台服务。例如，平台可以提供用于在 Kubernetes 上构建、扫描、测试、部署和观察 Web 应用程序的可重用的供应链工作流。这样的工作流可以与一个初始的项目模板和文档捆绑在一起，通常被描述为&lt;em&gt;黄金路径&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自服务&lt;/strong&gt;。平台应该是自服务的。用户必须能够自主和自动地请求和接收功能。这个属性对于平台团队能够启用多个产品团队并根据需要进行扩展是关键的。平台的能力应该随时可用，并且通过上述接口进行最小的手动干预。例如，用户应该能够通过运行命令行工具或在 Web 门户上填写表单来请求数据库并接收其定位器和凭据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减少用户的认知负荷&lt;/strong&gt;。平台的一个重要目标是减少产品团队的认知负荷。平台应该封装实现细节，并隐藏由其架构引起的任何复杂性。例如，平台可能将某些服务委托给云提供商，但用户不应该接触到这些细节。同时，平台还应该允许用户根据需要配置和观察某些服务。用户不应该负责操作平台提供的服务。例如，用户经常需要数据库，但他们不应该管理数据库服务器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可选和可组合&lt;/strong&gt;。平台旨在使产品开发更加高效，因此它们不能成为障碍。平台应该是可组合的，并使产品团队仅使用其提供的部分功能。当必要时，它还应该使产品团队在平台的提供范围之外提供和管理自己的能力。例如，如果平台不提供图形数据库，而产品需要它，那么产品团队应该能够自行提供和操作图形数据库。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;默认安全&lt;/strong&gt;。平台应该默认安全，并提供基于组织规则和标准的合规性和验证能力。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;平台团队的属性&#34;&gt;平台团队的属性&lt;/h2&gt;
&lt;p&gt;平台团队负责平台能力的接口和体验，如 Web 门户、自定义 API 和黄金路径模板。一方面，平台团队与实施基础设施和支持服务的团队合作，以定义一致的体验；另一方面，他们与产品和用户团队合作，收集反馈并确保这些体验满足要求。&lt;/p&gt;
&lt;p&gt;以下是平台团队应负责的工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;研究平台用户需求并计划功能路线图&lt;/li&gt;
&lt;li&gt;推广和倡导平台提议的价值&lt;/li&gt;
&lt;li&gt;管理和开发用于使用和观察能力和服务的接口，包括门户、API、文档和模板以及 CLI 工具&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最重要的是，平台团队必须了解平台用户的需求，以便为他们的平台提供能力和接口，并持续改进。了解用户需求的方式包括用户访谈、交互式黑客马拉松、问题跟踪器和调查以及通过可观测性工具直接观察使用情况。例如，平台团队可以发布一个表单，供用户提交功能请求，主持路线图会议以共享即将推出的功能并审查用户的使用模式以设置优先级。&lt;/p&gt;
&lt;p&gt;入站反馈和周到的设计是产品交付的一面；另一面是出站市场营销和倡导。如果平台确实是基于用户需求构建的，那么这些用户将会很高兴使用提供的能力。平台团队可以通过内部营销活动来促进用户采用，包括广泛的公告、引人入胜的演示和定期的反馈和沟通会议。关键在于满足用户的需求并带领他们踏上旅程，与平台互动并从中受益。&lt;/p&gt;
&lt;p&gt;平台团队不一定运行计算、网络、存储或其他服务。事实上，内部平台应尽可能依赖于&lt;em&gt;外部&lt;/em&gt;提供的服务和功能；平台团队应仅在从受管理供应商或内部基础架构团队处无法获得这些服务和功能时才构建和维护自己的服务。因此，平台团队最负责的是服务和功能的&lt;em&gt;接口&lt;/em&gt;（即 GUI、CLI 和 API）以及平台提供的服务和功能的用户体验。&lt;/p&gt;
&lt;p&gt;例如，平台中的一个 Web 页面可能描述并甚至提供一个按钮来为应用程序进行身份验证；而该功能的实现可能通过云托管的身份验证服务。内部平台团队可能管理网页和 API，但不管理实际的服务实现。平台团队通常应在所需的功能不可在其他地方获得时考虑创建和维护自己的功能。&lt;/p&gt;
&lt;h2 id=&#34;平台的挑战&#34;&gt;平台的挑战&lt;/h2&gt;
&lt;p&gt;虽然平台承诺了很多价值，但也带来了以下挑战，实施者应该注意这些挑战。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;平台团队必须像产品一样对待他们的平台，并与用户一起开发它们。&lt;/li&gt;
&lt;li&gt;平台团队必须仔细选择其优先事项和初始合作伙伴应用程序团队。&lt;/li&gt;
&lt;li&gt;平台团队必须寻求企业领导的支持，并展示其对价值流的影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也许最重要的是将平台作为面向客户的产品，并认识到其成功直接取决于其用户和产品的成功；因此，平台团队与应用程序团队和其他用户合作以优先考虑、规划、实施和迭代平台的功能和用户体验是至关重要的。发布功能和体验而不考虑反馈或依赖自上而下的命令来实现采用的平台团队几乎肯定会遇到用户的阻力和不满，并错过了很多承诺的价值。为了解决这个问题，平台团队应该从一开始就包括产品经理，分享路线图，收集反馈，并全面了解和代表平台用户的需求。&lt;/p&gt;
&lt;p&gt;在采用平台时，选择要启用的正确能力和体验可能至关重要。通常需要且无差异的能力，如管道、数据库和可观测性等，可能是一个很好的起点。平台团队还可以选择首先关注有限数量的参与度高且技能娴熟的应用程序团队。这些团队的详细反馈将改善第一个平台体验；而这些团队的成员将帮助宣传和推广平台，以吸引后续的采用者。&lt;/p&gt;
&lt;p&gt;最后，在大型企业中，快速获得领导支持对于平台团队至关重要。许多企业领导人认为 IT 基础设施是与其主要价值流不相关的开支，并可能试图限制分配给 IT 平台的成本和资源，导致实现效果不佳、承诺未实现和沮丧。为了减轻这种情况，平台团队需要展示其对产品和价值流团队的直接影响和联系（参见前两段），将平台团队呈现为产品团队在向客户提供价值方面的战略合作伙伴。&lt;/p&gt;
&lt;h3 id=&#34;赋能平台团队&#34;&gt;赋能平台团队&lt;/h3&gt;
&lt;p&gt;从这些挑战中可以清楚地看出，平台团队面临着许多不同的责任，这些责任导致认知负荷。与应用程序团队的同事一样，重点是将平台团队的精力集中在与其特定业务相关的体验和功能上。减轻平台团队负担的方法包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;寻求建立最薄的可行平台层，以覆盖来自受管理供应商的实现&lt;/li&gt;
&lt;li&gt;利用开源框架和工具包，为应用程序团队使用创建文档、模板和组合&lt;/li&gt;
&lt;li&gt;确保平台团队在其领域和客户数量方面得到适当的人员配备&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何衡量平台的成功&#34;&gt;如何衡量平台的成功&lt;/h2&gt;
&lt;p&gt;企业将希望衡量其平台计划是否提供了上述价值和属性。此外，在本文中我们强调将内部平台视为产品的重要性，而良好的产品管理取决于定量和定性测量产品的性能。为了满足这些要求，内部平台团队应不断收集用户反馈和测量用户活动。&lt;/p&gt;
&lt;p&gt;与内部平台的其他方面一样，平台团队应使用最小可行的工作量来收集他们需要的反馈。我们将在这里建议度量标准，但最初简单的调查和用户行为分析可能最有价值。&lt;/p&gt;
&lt;p&gt;有助于企业和平台团队了解其平台影响的类别包括以下内容：&lt;/p&gt;
&lt;h3 id=&#34;用户满意度和生产率&#34;&gt;用户满意度和生产率&lt;/h3&gt;
&lt;p&gt;许多平台所寻求的第一个品质是提高用户体验，以增加生产力。反映用户满意度和生产率的指标包括以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;活跃用户和保留：包括所提供的功能数量和用户增长 / 流失&lt;/li&gt;
&lt;li&gt;“净推荐值”（NPS）或其他调查，衡量用户对产品的满意度&lt;/li&gt;
&lt;li&gt;开发人员生产力的度量，如 SPACE 框架中讨论的那些度量 [ &lt;a href=&#34;https://queue.acm.org/detail.cfm?id=3454124&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;4&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;组织效率&#34;&gt;组织效率&lt;/h3&gt;
&lt;p&gt;许多平台所寻求的另一个好处是为大量用户提供常见需求的高效方法。这通常通过启用用户自助服务和减少手动步骤和必要的人类干预来实现，同时实施保障安全和合规性的政策。为了衡量平台在减少常见工作方面的效率，请考虑以下措施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从请求到服务或功能（如数据库或测试环境）的履行的延迟&lt;/li&gt;
&lt;li&gt;将全新的服务构建并部署到生产环境所需的延迟&lt;/li&gt;
&lt;li&gt;新用户提交第一次代码更改到其产品的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;产品和功能交付&#34;&gt;产品和功能交付&lt;/h3&gt;
&lt;p&gt;内部平台的最终目标是更快地向业务客户提供业务价值，因此衡量对企业自身产品和功能发布的影响，可以证明平台的目标已得到实现。Google 的 DevOps 研究和评估（DORA）研究所建议 [ &lt;a href=&#34;https://cloud.google.com/blog/products/devops-sre/the-2019-accelerate-state-of-devops-elite-performance-productivity-and-scaling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;5&lt;/a&gt;] 跟踪以下度量标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署频率&lt;/li&gt;
&lt;li&gt;变更的领先时间&lt;/li&gt;
&lt;li&gt;服务故障后恢复服务的时间&lt;/li&gt;
&lt;li&gt;变更的失败率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，平台团队的关键目标是将基础架构和其他 IT 能力与企业的价值流 - 其产品 - 对齐。因此，组织的产品和应用程序的成功才是衡量平台成功的真正标准。&lt;/p&gt;
&lt;h2 id=&#34;平台的功能&#34;&gt;平台的功能&lt;/h2&gt;
&lt;p&gt;正如我们所描述的，用于云原生计算的平台提供和组合来自许多支持提供者的功能和服务。这些提供者可以是同一企业内的其他团队，也可以是云服务提供商等第三方。简而言之，平台从基础 &lt;em&gt;能力提供者&lt;/em&gt; 到平台用户（如应用程序开发人员）的中间桥梁；在此过程中，实现和执行所需的安全性、性能、成本治理和一致的体验。以下图形说明了产品、平台和能力提供者之间的关系。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-产品平台和能力提供者之间的关系&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;产品、平台和能力提供者之间的关系&#34; srcset=&#34;
               /blog/cncf-platforms-white-paper/platform_components_hue837dc598798d393310eb163b229102d_136246_aceae2f4a2b6670cf3a863651c7ff5da.webp 400w,
               /blog/cncf-platforms-white-paper/platform_components_hue837dc598798d393310eb163b229102d_136246_6b4dfe71a79ffe68e0f58c9a80d29733.webp 760w,
               /blog/cncf-platforms-white-paper/platform_components_hue837dc598798d393310eb163b229102d_136246_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cncf-platforms-white-paper/platform_components_hue837dc598798d393310eb163b229102d_136246_aceae2f4a2b6670cf3a863651c7ff5da.webp&#34;
               width=&#34;760&#34;
               height=&#34;561&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      产品、平台和能力提供者之间的关系
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们在本文中着重讨论了如何构建良好的平台和平台团队；现在在最后一节中，我们将描述平台实际上可能提供的能力。这个列表旨在指导平台构建者，并包括典型的云原生应用程序所需的功能。正如我们一直在强调的，良好的平台反映了其用户的需求，因此最终平台团队应该与其用户一起选择和优先考虑平台所提供的功能。&lt;/p&gt;
&lt;p&gt;能力可以包括几个&lt;em&gt;特性&lt;/em&gt;，意味着父能力域的方面或属性。例如，可观测性可能包括用于收集和发布度量、跟踪和日志以及观察成本和能源消耗的特性。在您的组织中考虑每个特性或方面的需求和优先级。随后的 CNCF 出版物可能会进一步扩展每个域。&lt;/p&gt;
&lt;p&gt;在构建云原生计算平台时要考虑以下能力领域：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用于观察和配置产品和能力的 &lt;strong&gt;Web 门户&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用于自动配置产品和能力的 &lt;strong&gt;APIs&lt;/strong&gt;（和 CLIs）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;“黄金路径”模板和文档&lt;/strong&gt;，以便在产品中实现最佳使用&lt;/li&gt;
&lt;li&gt;用于构建和测试服务和产品的&lt;strong&gt;自动化&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用于交付和验证服务和产品的&lt;strong&gt;自动化&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开发环境&lt;/strong&gt;，如托管的 IDE 和远程连接工具&lt;/li&gt;
&lt;li&gt;使用仪器和仪表板的服务和产品的&lt;strong&gt;可观测性&lt;/strong&gt;，包括功能、性能和成本的观察&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基础设施&lt;/strong&gt;服务，包括计算运行时、可编程网络以及块和卷存储&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据&lt;/strong&gt;服务，包括数据库、缓存和对象存储&lt;/li&gt;
&lt;li&gt;包括代理、队列和事件织物的&lt;strong&gt;消息&lt;/strong&gt;和事件服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;身份和密码&lt;/strong&gt;管理服务，例如服务和用户身份和授权、证书和密钥发行以及静态密码存储&lt;/li&gt;
&lt;li&gt;包括代码和工件的静态分析、运行时分析和策略执行的&lt;strong&gt;安全&lt;/strong&gt;服务&lt;/li&gt;
&lt;li&gt;包括容器镜像和特定语言包、自定义二进制文件和库以及源代码的&lt;strong&gt;工件存储&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下表格旨在帮助读者通过松散相关现有 CNCF 或 CDF 项目来理解每种能力。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;能力&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;示例 CNCF/CDF 项目&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于配置和观察能力的 Web 门户&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;发布文档、服务目录和项目模板。发布有关系统和能力的遥测数据。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Backstage、Skooner、Ortelius&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自动配置能力的 API&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于自动创建、更新、删除和观察能力的结构化格式。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Kubernetes、Crossplane、Operator Framework、Helm、KubeVela&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;黄金路径模板和文档&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于快速项目开发的良好集成代码和能力的模板化组合。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ArtifactHub&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于构建和测试产品的自动化&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自动构建和测试数字产品和服务。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Tekton、Jenkins、Buildpacks、ko、Carvel&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于交付和验证服务的自动化&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自动化和观察服务的交付。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Argo、Flux、Keptn、Flagger、OpenFeature&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;开发环境&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;启用应用程序和系统的研究和开发。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Devfile、Nocalhost、Telepresence、DevSpace&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;应用程序可观测性&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;仪表应用程序，收集和分析遥测数据，并将信息发布给利益相关者。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OpenTelemetry、Jaeger、Prometheus、Thanos、Fluentd、Grafana、OpenCost&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;基础设施服务&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;运行应用程序代码、连接应用程序组件并为应用程序持久化数据&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Kubernetes、Kubevirt、Knative、WasmEdgeCNI、Istio、Cilium、Envoy、Linkerd、CoreDNSRook、Longhorn、Etcd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据服务&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;持久化应用程序的结构化数据&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TiKV、Vitess、SchemaHero&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;消息和事件服务&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使应用程序异步通信&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Strimzi、NATS、gRPC、Knative、Dapr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;身份和密码服务&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确保工作负载具有定位器和密码来使用资源和能力。使服务能够向其他服务识别自己&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Dex、External Secrets、SPIFFE/SPIRE、Teller、cert-manager&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;安全服务&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;观察运行时行为并报告 / 纠正异常。验证构建和工件不包含漏洞。根据企业要求限制平台上的活动；通知和 / 或纠正异常&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Falco、In-toto、KubeArmor、OPA、Kyverno、Cloud Custodian&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;工件存储&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存储、发布和保护用于生产的内置工件。缓存和分析第三方工件。存储源代码。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ArtifactHub、Harbor、Distribution、Porter&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;术语表&#34;&gt;术语表&lt;/h2&gt;
&lt;p&gt;请参见 &lt;a href=&#34;https://glossary.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://glossary.cncf.io/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平台&lt;/strong&gt;聚合能力，为开发人员和运营商开发和交付产品、服务和应用程序提供服务。关于它旨在支持的场景，平台可能被命名为“开发人员平台”、“交付平台”、“应用程序平台”甚至是“云平台”。较旧的术语“平台即服务”或 PaaS 的内涵也具有影响力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平台&lt;/strong&gt;通过提供和管理共同的能力，使开发人员和运营人员能够更快地交付应用程序和服务。平台是平台用户和平台能力提供者之间的桥梁，并由平台团队构建和维护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平台能力提供者&lt;/strong&gt;开发和维护平台提供的能力。提供者可以是外部组织或内部团队，能力可以是基础设施、运行时或其他支持服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平台工程师&lt;/strong&gt;负责开发和维护界面和工具，以便根据平台产品经理提供的要求和说明，在应用程序中启用平台能力的配置和集成。平台开发人员通常分组在平台团队中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平台产品经理&lt;/strong&gt;负责了解平台用户的体验，建立涵盖平台产品差距、需求和机会的路线图，并管理平台团队的日常工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平台团队&lt;/strong&gt;负责开发和维护与平台能力的接口和体验，如 Web 门户、自定义 API 和黄金路径模板。平台团队由平台产品经理管理，并涉及平台开发人员。随着平台的发展和越来越先进，其他角色也可以成为平台团队的一部分，包括但不限于运营商、QA 分析师、UI/UX 设计师、技术作家、开发人员倡导者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平台用户&lt;/strong&gt;包括但不限于应用程序开发人员和运营人员、数据科学家、COTS 软件操作员和信息工作者 - 在平台上运行软件或使用平台提供的能力的任何人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最薄可行平台（TVP）&lt;/strong&gt; 是由 Matthew Skelton 和 Manuel Pais 在书籍 &lt;em&gt;Team Topologies&lt;/em&gt; 中最初定义的一个概念。定义说：“TVP 是在保持平台小的同时确保平台有助于加速和简化团队构建平台的软件交付的谨慎平衡。”。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生绑定应用：一种让开发者专注于业务逻辑的新架构</title>
      <link>https://cloudnative.to/blog/cloud-bound-applications/</link>
      <pubDate>Thu, 16 Mar 2023 12:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-bound-applications/</guid>
      <description>&lt;p&gt;本文作者 Bilgin Ibryam 是 Diagrid 的技术产品经理，致力于开发人员生产力工具。在此之前，他曾在 Red Hat 担任顾问和架构师，同时也是 Apache 软件基金会的提交者和成员。Bilgin 还与人合著了两本关于 Kubernetes 模式和 Camel 设计模式的书。在业余时间，Bilgin 喜欢通过博客和其他方式写作和分享他的知识。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：本文的原标题是《什么是云原生绑定应用》。本文介绍了云绑定应用程序的概念，并探讨了在使用云绑定应用程序时需要考虑的几个关键因素。首先，作者解释了云绑定应用程序是指在构建应用程序时使用云提供的服务和资源。作者强调了使用云绑定应用程序可以带来很多好处，例如降低成本和提高可靠性。然而，作者也指出了在使用云绑定应用程序时需要考虑的几个关键因素，包括云供应商锁定、数据隐私和网络连接可靠性等。最后，作者提供了一些建议，帮助企业在使用云绑定应用程序时避免潜在的风险。例如，选择具有高可用性的云服务提供商，并在使用云绑定应用程序时加强数据安全措施。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;关键要点&#34;&gt;关键要点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;云提供商将重点从基础设施服务转移到开发人员直接使用的应用程序优先服务，从而产生了新的应用程序架构。&lt;/li&gt;
&lt;li&gt;这种架构允许开发人员将集成逻辑和管理责任卸载到云服务，并专注于实现业务逻辑。&lt;/li&gt;
&lt;li&gt;“云绑定”代表了云原生从解决以计算为中心的问题向管理应用集成问题的演进。&lt;/li&gt;
&lt;li&gt;云绑定应用程序使用开放 API 和事实标准将应用程序的内部架构与其外部依赖项分离。&lt;/li&gt;
&lt;li&gt;云绑定应用程序使用开放的 API 和数据格式将应用程序绑定到计算基础设施，并将状态编排、事件驱动的交互和可靠的同步交互等集成责任卸载到云服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用程序优先云服务的日益普及导致应用程序和云服务的集成比以前更深入。应用程序和云之间的运行时边界正在从虚拟机转移到容器和函数。在这个最终架构中，应用程序是“云绑定”的，通过将更多应用程序逻辑和管理责任卸载到云服务，开发人员可以专注于业务逻辑。&lt;/p&gt;
&lt;p&gt;本文通过使用保持灵活性和可移植性的开放 API 和标准将应用程序绑定到云服务来检查整个软件堆栈的商品化。&lt;/p&gt;
&lt;h2 id=&#34;内部架构演变&#34;&gt;内部架构演变&lt;/h2&gt;
&lt;p&gt;应用程序的内部架构通常由一个团队拥有和控制。根据所选的语言和运行时，包、模块、接口、类和函数等工具和抽象可帮助开发人员控制内部边界。领域驱动设计 (DDD) 帮助开发人员设计领域模型，这些模型作为抽象来封装复杂的业务逻辑并调解业务现实与代码之间的差距。&lt;/p&gt;
&lt;p&gt;Hexagonal，Onion 和 Clean 架构可以补充  DDD 并安排具有不同边界和外部化基础设施依赖性的应用程序代码。尽管这些方法在开始时是创新的并且在今天仍然适用，但它们最初是为三层 Java 应用程序开发的，该应用程序由部署在共享应用程序运行时中的 JSP、Servlet 和 EJB 组成。当时的主要焦点是将应用程序逻辑与 UI 和数据库分离，并启用隔离测试。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1内部应用架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1：内部应用架构&#34; srcset=&#34;
               /blog/cloud-bound-applications/1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_df15796544d3641c41413a7e0762e87c.webp 400w,
               /blog/cloud-bound-applications/1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_bda3f593a1aeeaa7aefc5304f3419808.webp 760w,
               /blog/cloud-bound-applications/1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-bound-applications/1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_df15796544d3641c41413a7e0762e87c.webp&#34;
               width=&#34;760&#34;
               height=&#34;619&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1：内部应用架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从那时起，微服务和十二因素应用程序等新挑战和概念不断涌现，并影响了我们设计应用程序的方式。微服务的核心是将应用程序逻辑分离到由单个团队拥有的可独立部署的单元中。十二因素应用程序方法旨在创建在动态云环境中运行和扩展的分布式、无状态应用程序。所有这些架构都引入了原则和最佳实践，这些原则和最佳实践塑造了我们构建应用程序内部架构的方式以及我们管理它的方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2应用程序架构演进时间表&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 2：应用程序架构演进时间表&#34; srcset=&#34;
               /blog/cloud-bound-applications/2_hu40b71820fd7baf24807d72301013b030_29518_bf3b668a3da2548818f7d4950c79bb55.webp 400w,
               /blog/cloud-bound-applications/2_hu40b71820fd7baf24807d72301013b030_29518_4547c53e895ffe872f72f0ba59a89e94.webp 760w,
               /blog/cloud-bound-applications/2_hu40b71820fd7baf24807d72301013b030_29518_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-bound-applications/2_hu40b71820fd7baf24807d72301013b030_29518_bf3b668a3da2548818f7d4950c79bb55.webp&#34;
               width=&#34;760&#34;
               height=&#34;278&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2：应用程序架构演进时间表
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;后来在应用程序架构演变时间表中，容器的主流采用和 Kubernetes 的引入彻底改变了应用程序的打包和编排方式。AWS Lambda 引入了高度可扩展的函数即服务 (FaaS) 的概念，将应用程序粒度的概念提升到一个新的水平，并将完整的基础设施管理责任卸载给云提供商。其他技术趋势，例如服务网格和多运行时微服务架构，也已经出现并将非功能方面商品化，例如网络和分布式开发原语，分别将它们提取到 sidecar 中。受微服务的启发，数据网格架构旨在将应用程序的分析数据架构分解为更小、独立的数据域，每个域都有自己的产品和团队。这些以及最近的趋势，例如应用程序优先的云服务，正在开始重塑应用程序的外部架构，我在本文中将其统称为“云绑定应用程序”。&lt;/p&gt;
&lt;h2 id=&#34;外部架构演化&#34;&gt;外部架构演化&lt;/h2&gt;
&lt;p&gt;外部架构是应用程序与其他团队和组织拥有的其他应用程序和基础设施相交的地方，通常以专用的本地中间件、存储系统或云服务的形式出现。应用程序连接到外部系统并卸载其部分职责的方式形成了外部架构。为了从基础架构中受益，应用程序需要绑定到该基础架构并强制执行清晰的边界以保持其敏捷性。一个应用程序的内部架构和实现应该能够在不改变另一个应用程序的情况下进行更改，外部依赖关系（例如云服务）可以在不改变内部结构的情况下进行交换。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-3外部应用架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 3：外部应用架构&#34; srcset=&#34;
               /blog/cloud-bound-applications/3_huf37fbf5460b713081b06bb34dc5f650c_50572_20a9750e727f34d326372f52c0225b9b.webp 400w,
               /blog/cloud-bound-applications/3_huf37fbf5460b713081b06bb34dc5f650c_50572_4956fef84911f343eb2add80f4d827f7.webp 760w,
               /blog/cloud-bound-applications/3_huf37fbf5460b713081b06bb34dc5f650c_50572_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-bound-applications/3_huf37fbf5460b713081b06bb34dc5f650c_50572_20a9750e727f34d326372f52c0225b9b.webp&#34;
               width=&#34;622&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3：外部应用架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从广义上讲，我们可以将应用程序与其周围环境绑定的方式分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算绑定是在计算平台（例如 Kubernetes、容器服务，甚至是 AWS Lambda 等无服务器函数）上运行应用程序所需的所有绑定、配置、API 和合约。大多数情况下，这些绑定对内部架构是透明的，并且由运营团队而非开发人员配置和使用。容器抽象是当今应用程序计算绑定最广泛的“API”。&lt;/li&gt;
&lt;li&gt;集成绑定是对应用程序所依赖的外部依赖项的所有其他绑定的总称。云服务还使用这些绑定与应用程序交互，通常是通过定义明确的 HTTP“API”或专门的消息传递和存储访问协议，例如 AWS S3、Apache Kafka、Redis API 等。集成绑定不像运行时绑定那样透明。开发人员需要围绕它们实现额外的逻辑，例如重试、TTL、延迟、死信队列 (DLQ) 等，并将它们绑定到应用程序的业务逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用程序在云上运行并通过使用这些绑定来使用其他服务。让我们更详细地了解这些绑定背后的内容。&lt;/p&gt;
&lt;h2 id=&#34;计算绑定&#34;&gt;计算绑定&lt;/h2&gt;
&lt;p&gt;对于运营团队来说，理想情况下，每个应用程序都是一个需要在计算平台上运行的黑盒单元。计算绑定用于管理 Kubernetes、AWS Lambda 和其他服务等平台上应用程序的生命周期。这些绑定以应用程序和应用程序运行平台之间的配置和 API 交互集合的形式形式化和定义。这些交互中的大部分对应用程序是透明的，只有少数 API 需要开发人员实现，例如健康端点和指标 API。这是目前 CNCF 对“云原生”定义  和范围的扩展，只要开发者实现云原生应用，他们可以在云计算平台上绑定运行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-4应用程序和平台计算绑定&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 4：应用程序和平台计算绑定&#34; srcset=&#34;
               /blog/cloud-bound-applications/4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_8757d39fa9a483b002667b7270c9d101.webp 400w,
               /blog/cloud-bound-applications/4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_ec0ac96c3ed0af4f5f841d784cc309c8.webp 760w,
               /blog/cloud-bound-applications/4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-bound-applications/4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_8757d39fa9a483b002667b7270c9d101.webp&#34;
               width=&#34;760&#34;
               height=&#34;616&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4：应用程序和平台计算绑定
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;要在云平台上可靠地运行，应用程序必须在从规范到最佳实践的多个层面上与之绑定。这是通过一组行业标准规范（例如容器 API、指标 API）实现的，例如基于 Prometheus、健康端点或云提供商规范（例如 AWS Lambda 或 AWS ECS 规范）。此外，通过云原生最佳技术和共享知识，例如健康检查、部署策略和放置策略。让我们看看当今使用的常见计算绑定。&lt;/p&gt;
&lt;h3 id=&#34;资源需求&#34;&gt;资源需求&lt;/h3&gt;
&lt;p&gt;包括微服务和函数在内的应用程序需要 CPU、内存和存储等资源。这些资源的定义因所使用的平台而异。例如，在 Kubernetes 上，CPU 和内存是通过请求和限制定义的，而在 AWS Lambda 上，用户 指定运行时分配的内存量，以及对应的 CPU 分配。存储在这些平台上的处理方式也不同，Kubernetes 使用临时存储和卷，而 Lambda 提供临时暂存资源和基于 Amazon EFS 挂载的持久存储。&lt;/p&gt;
&lt;h3 id=&#34;生命周期钩子&#34;&gt;生命周期钩子&lt;/h3&gt;
&lt;p&gt;由平台管理的应用程序通常需要了解重要的生命周期事件。例如，在 Kubernetes 上，init 容器等概念和 PostStart 和 PreStop 等钩子允许应用程序对这些事件做出反应。同样，Lambda 的 extensions API 允许应用程序拦截 Init、Invoke 和 Shutdown 阶段。处理生命周期事件的其他选项包括包装器脚本或特定于语言的运行时修改选项，例如 JVM 的关闭钩子。这些机制形成了平台和应用程序之间的契约，使其能够响应和管理自己的生命周期。&lt;/p&gt;
&lt;h3 id=&#34;健康检查&#34;&gt;健康检查&lt;/h3&gt;
&lt;p&gt;运行状况探测是平台监控应用程序运行状况并在必要时采取纠正措施（例如重新启动应用程序）的一种方式。由于请求的生命周期较短，Lambda 函数没有健康探测，而容器化应用程序和编排器（如 Kubernetes、AWS EKS 和 GCP Cloud Run）确实在其定义中包含 健康探测。这使平台能够确保应用程序平稳运行，并在应用程序运行不平稳时采取措施。&lt;/p&gt;
&lt;h3 id=&#34;部署和放置策略&#34;&gt;部署和放置策略&lt;/h3&gt;
&lt;p&gt;一旦知道所需的资源，计算平台就可以开始管理应用程序的生命周期。要以不损害业务逻辑完整性的方式执行此操作，平台必须了解扩展约束。有些应用程序被设计为单例。例如，它们需要维护已处理事件的顺序并且不能扩展到多个实例。其他有状态应用程序可能是仲裁驱动的，并且需要特定数量的最小实例连续运行才能正常运行。还有一些函数，例如无状态函数，可能有利于快速扩展以解决不断增加的负载峰值问题。一旦建立了应用程序的缩放指南，平台就会控制应用程序实例的启动和终止。&lt;/p&gt;
&lt;p&gt;计算还提供滚动、蓝绿、金丝雀、一次等多种部署策略，来控制服务更新的顺序。除了部署顺序之外，这些平台还允许用户指定放置首选项。例如，Kubernetes 提供标签、污点和容忍度、亲和力和反亲和力等选项，而 Lambda 允许用户在区域和边缘放置类型之间进行选择。这些首选项可确保部署应用程序并满足合规性和性能要求。&lt;/p&gt;
&lt;h3 id=&#34;网络流量&#34;&gt;网络流量&lt;/h3&gt;
&lt;p&gt;计算平台还负责将低级网络流量引导至服务实例。这是因为它负责部署排序、放置和自动缩放，这些都会影响流量如何定向到服务实例。健康检查也可以在流量管理中发挥作用，例如 GCP Cloud Run 和 Kubernetes 中的准备情况检查。通过处理这些任务，计算平台有助于确保流量高效且有效地路由到适当的服务实例。&lt;/p&gt;
&lt;h3 id=&#34;监控和报告&#34;&gt;监控和报告&lt;/h3&gt;
&lt;p&gt;任何用于分布式应用程序的计算平台都必须以日志、指标和跟踪的形式提供深入的应用程序洞察力。目前该领域几乎没有被广泛接受的事实标准：日志最好以结构化格式使用，例如 JSON 或其他行业特定标准。计算平台通常收集日志或为专门的日志提取和分析服务提供扩展点以访问日志。这可以是 Kubernetes 上的 DaemonSet，用于监控的 Lambda 合作伙伴扩展，或 Vercel 边缘功能日志 Drainer。计算平台必须支持指标和追踪数据的收集和分析，以全面了解分布式应用程序的性能和行为。有几种行业标准格式和工具可用于处理此数据 OpenTelemetry (OTEL) for Tracking 计算平台可以提供内置工具来收集和分析这些数据，或者为专门服务提供扩展点来访问数据。无论代码粒度（微服务或函数）或位置（边缘或非边缘）如何，计算平台都必须允许捕获日志、指标和追踪数据，并导出到其他同类最佳的云服务。例如 Honeycomb、DataDog、Grafana 等。&lt;/p&gt;
&lt;h3 id=&#34;计算绑定趋势&#34;&gt;计算绑定趋势&lt;/h3&gt;
&lt;p&gt;计算绑定与语言和应用程序运行时无关，主要由运营团队用于在运行时管理应用程序，而不是开发人员实现它们。&lt;/p&gt;
&lt;p&gt;虽然应用程序的大小和复杂性可能因整体和功能而异，但它们通常打包在具有健康检查端点、实施的生命周期挂钩和公开指标的容器中。了解这些计算绑定将帮助你有效地使用任何基于容器的计算平台，无论是本地 Kubernetes 集群、托管容器服务（例如 AWS ECS、Google Cloud Run、Azure Container App），还是基于函数的运行时（例如作为 AWS Lambda、GCP 函数或边缘运行时，例如 Vercel 边缘函数、CloudFlare worker 或 Netlify edge functions 等。使用开放的事实上的标准 API 不仅可以帮助你创建可移植的应用程序，还可以通过使用可跨云供应商和服务提供商移植的操作实践和工具来限制供应商锁定。&lt;/p&gt;
&lt;h2 id=&#34;集成绑定&#34;&gt;集成绑定&lt;/h2&gt;
&lt;p&gt;另一方面，集成绑定旨在供开发人员而不是运营团队使用。它们以常见的分布式系统实现领域为中心，例如服务调用、事件驱动交互、任务调度和有状态工作流编排。它们通过基于云的类似中间件的服务帮助将应用程序与专用存储系统和外部系统连接起来，在本文中统称为集成云。与容器提供计算抽象的方式相同，集成云服务提供与语言无关的集成抽象作为服务。这些原语独立于用例、应用程序实现、运行时和计算环境。例如重试模式、DLQ 模式、Saga 模式、服务发现和 断路器模式都可以集成为服务使用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5应用程序和平台集成绑定&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 5：应用程序和平台集成绑定&#34; srcset=&#34;
               /blog/cloud-bound-applications/5_hufb20aa7c61dad71a4c335dca460c4126_61270_d8bf9e364f58b2f09b5f0902a734a2a2.webp 400w,
               /blog/cloud-bound-applications/5_hufb20aa7c61dad71a4c335dca460c4126_61270_36cc25a7a9c022f4b9694728d36a7cb2.webp 760w,
               /blog/cloud-bound-applications/5_hufb20aa7c61dad71a4c335dca460c4126_61270_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-bound-applications/5_hufb20aa7c61dad71a4c335dca460c4126_61270_d8bf9e364f58b2f09b5f0902a734a2a2.webp&#34;
               width=&#34;760&#34;
               height=&#34;616&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5：应用程序和平台集成绑定
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今天不存在将所有主要模式公开为独立功能的纯集成云。早期的云服务正在提供其中一些集成原语作为存储系统（如 Kafka、Redis 等）的功能，但这些功能很少单独使用或与其他功能结合使用。这里值得注意的例外是 AWS EventBridge 和 Azure Event Grid 等服务，你可以将它们与来自同一提供商的多个云服务一起使用，但不能直接与其他提供商一起使用。这是一个快速发展的领域，有一些很好的例子和一些尚未填补的空白，但我相信它们会在未来出现。应用程序必须绑定到集成的云服务并卸载其中的一些开发人员职责才能运行。以下是集成云服务的主要类型和绑定方面。&lt;/p&gt;
&lt;h3 id=&#34;集成要求&#34;&gt;集成要求&lt;/h3&gt;
&lt;p&gt;与应用程序可以请求资源并向计算平台表达部署和放置偏好的方式相同，应用程序也可以请求和激活特定的集成绑定。这些绑定可以通过以声明方式传递给平台的配置来激活，或者在运行时通过编程交互来激活。例如，应用程序可以使用声明式和编程式订阅 pub/sub 主题。AWS Lambda 函数事件源可以通过配置以声明方式订阅，也可以通过客户端库或 SDK 请求集成平台注册或注销特定绑定以编程方式订阅。应用程序可以订阅 cron 作业触发器、激活外部系统的连接器、进行配置更改等等，所有这些都在集成云上运行。&lt;/p&gt;
&lt;h3 id=&#34;工作流程编排&#34;&gt;工作流程编排&lt;/h3&gt;
&lt;p&gt;持久服务编排逻辑是一种非常普遍的必需品，也是作为服务进行外部化和消费的主要候选者。因此，工作流编排是当今最著名的集成绑定类型之一。该服务的常见用途包括为服务和业务流程编排实施 Saga 模式、使用 AWS Step Functions、Google Stateful Functions、Azure Durable Functions 进行函数编排、使用 Google Workflow 进行任务分配等等。当使用这样的绑定时，部分应用程序编排状态和逻辑被卸载到另一个服务中。虽然应用程序服务具有内部状态和管理该状态的逻辑，但其他部分是外部的，可能在其他一些云服务中。这代表了当今应用程序作为一个独立的单元进行设计和操作的方式的转变。未来的应用程序不仅数据是外部的，而且集成也将是外部的。随着越来越多地采用集成云，更多的集成数据和逻辑将开始存在于外部。&lt;/p&gt;
&lt;h3 id=&#34;时间触发器&#34;&gt;时间触发器&lt;/h3&gt;
&lt;p&gt;时间绑定表示编排绑定的时间限制专业化。它只有一个目标，即根据给定的策略在特定时间触发各种服务。此类别中的示例包括 AWS EventBridge Scheduler、Google Cloud Scheduler、Upstash Qstack 服务等。&lt;/p&gt;
&lt;h3 id=&#34;事件驱动和消息服务&#34;&gt;事件驱动和消息服务&lt;/h3&gt;
&lt;p&gt;这些绑定充当事件存储来卸载请求和解耦应用程序，但它们越来越不限于存储和扩展以提供消息处理模式。它们在事件存储之上提供开发者原语，例如死信队列、重试、延迟传递和消息处理模式，例如过滤、聚合、重新排序、基于内容的路由、窃听等。这种绑定的例子有 Confluent Cloud kSQL、AWS EventBridge、Decodable Data Pipeline 等。&lt;/p&gt;
&lt;h3 id=&#34;外部连接器&#34;&gt;外部连接器&lt;/h3&gt;
&lt;p&gt;这些绑定有助于连接到外部系统。它们还执行数据规范化、错误处理、协议转换和数据转换。示例包括 Knative 源导入器、AWS EventBridge 连接器、Confluent Cloud 连接器、可解码的 Kafka 连接器、AWS Lambda 源和目标。&lt;/p&gt;
&lt;h3 id=&#34;健康检查-1&#34;&gt;健康检查&lt;/h3&gt;
&lt;p&gt;健康检查对于计算连接至关重要，失败的健康检查通常会导致应用程序重启。集成绑定也需要健康检查，但目的不同：集成健康检查不会影响应用程序的运行时，但它会告诉集成云应用程序是否能够处理集成驱动的交互。失败的集成状态检查会停止集成绑定，直到应用程序返回正常状态并且集成绑定恢复。通常，你可以使用相同的应用程序端点进行计算和集成绑定测试。一个很好的例子是 Dapr 应用程序 健康检查，它可以暂时阻止消费者和连接器。将数据插入不健康的应用程序。&lt;/p&gt;
&lt;h3 id=&#34;其他绑定&#34;&gt;其他绑定&lt;/h3&gt;
&lt;p&gt;还有更多的绑定，属于集成绑定的范畴。例如，Kubernetes Downward API 和 Lambda 环境变量等为应用程序提供内省数据，它为应用程序自省和元数据注入提供了一种简单的机制。配置和秘密绑定，其中秘密不仅在启动时注入到应用程序中，而且任何配置更新都通过 sidecars 推送到应用程序，例如 Hashicorp Vault Sidecar Injector 或者 Dapr 的 Configuration API, Kubernetes 的 Service Binding 设置 规范。和不太常见的模式，例如分布式锁，这也是一个集成绑定提供对共享资源的互斥访问。&lt;/p&gt;
&lt;h3 id=&#34;集成绑定趋势&#34;&gt;集成绑定趋势&lt;/h3&gt;
&lt;p&gt;容器正在成为最流行和广泛使用的可移植格式，用于打包和运行应用程序，无论它们是长期运行的微服务还是短期功能。另一方面，集成绑定可以分为不同的问题域，例如事件驱动的交互、有状态的编排和状态访问，并且在底层存储和使用模式方面有所不同。例如，Apache Kafka 是 事实上的标准、用于文档访问的 AWS S3 API、用于键值缓存的 Redis、用于关系数据访问的 PostgreSQL 等等。使它们成为标准的是围绕它们构建的库、工具和服务的不断增长的生态系统，为成熟度、稳定性和未来的向后兼容性提供了很大程度的保证。但这些 API 本质上仅限于存储访问，并且通常需要开发人员解决应用程序代码中的分布式系统挑战。与堆栈上层软件的商品化一致，集成绑定作为服务提供。越来越多的无服务器云服务提供了额外的集成功能，除了数据访问之外，应用程序代码还可以绑定这些功能。&lt;/p&gt;
&lt;p&gt;在此模型中，云绑定应用程序通常在无服务器计算基础设施上运行，遵循云原生原语。它与其他无服务器云服务绑定，用于服务编排、事件处理或同步交互，如下所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-6云绑定应用程序生态系统&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 6：云绑定应用程序生态系统&#34; srcset=&#34;
               /blog/cloud-bound-applications/6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_00bb2daef51a9f499f02107b5b006301.webp 400w,
               /blog/cloud-bound-applications/6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_2a597427cb8ea2d710a43b0d2a9fe03a.webp 760w,
               /blog/cloud-bound-applications/6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-bound-applications/6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_00bb2daef51a9f499f02107b5b006301.webp&#34;
               width=&#34;760&#34;
               height=&#34;638&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6：云绑定应用程序生态系统
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;CNCF 的 Dapr 是一个将大部分集成绑定和开发人员关注点整合到一个开源 API 中的项目。它提供同步服务调用、有状态服务编排、异步事件驱动交互和特定技术连接器作为 API。类似于容器和 Kubernetes 如何充当计算抽象，Dapr 充当外部服务的抽象。Dapr 还提供了独立于底层云服务且往往必须在应用层实现的集成能力，例如弹性策略、死信队列、延迟交付、跟踪、细粒度授权等。Dapr 被设计为多语言并在应用程序外部运行，从而可以轻松交换外部依赖项而无需更改应用程序的内部架构，如 Hexagon Architecture 中所述。虽然 Dapr 主要由实施应用程序的开发人员使用，但一旦引入，Dapr 就会增强分布式应用程序的可靠性和可见性，为运营和架构师团队提供 整体利益。要了解有关此主题的更多信息，请在今年晚些时候亲自或以虚拟方式参加 QConLondon，我将在那里讨论“应用程序优先的云服务如何改变游戏规则”。&lt;/p&gt;
&lt;h2 id=&#34;后云原生应用&#34;&gt;后云原生应用&lt;/h2&gt;
&lt;p&gt;云绑定应用代表了云原生的进步，从只解决计算问题到管理应用层需求。应用程序堆栈中的云服务从基础设施扩展到应用程序优先服务，加速了这一趋势。我们可以在以开发人员为中心的云服务的爆炸式增长中观察到这种转变，包括状态协调、事件驱动的应用程序基础架构、同步交互、基于云的开发和测试环境以及无服务运行时。这种向应用程序优先的云服务的转变正在产生一种新的应用程序架构，越来越多的应用程序逻辑在云服务中运行。应用程序与第三方云服务的这种混合允许开发人员分担更多责任，但是，它可能会限制不断变化的业务需求所需的灵活性和敏捷性。为了保持应用程序的内部和外部架构独立，应用程序和云服务需要在开发时通过清晰的边界解耦，并在运行时使用定义良好的开放 API 和格式进行深度绑定。正如容器和 Kubernetes 为计算提供了开放的 API，我们需要为应用程序集成抽象提供开放的 API。这将使操作实践和工具以及开发模式、功能和实践的可移植性和重用成为可能。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生网络功能（CNF）应该让每个容器聚焦一个关注点</title>
      <link>https://cloudnative.to/blog/cloud-native-network-functions-concern/</link>
      <pubDate>Thu, 02 Mar 2023 11:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-network-functions-concern/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;译者注：这篇文章介绍了如何编写云原生网络功能（CNF），即在电信领域的网络应用，它们与大多数云原生企业应用有不同的非功能性需求。CNF 需要满足高性能、高可靠性、高安全性和低延迟等指标。文章提出了一个基本的设计原则：每个容器只负责一个关注点，即一个单一的网络功能或子功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;本文主旨&#34;&gt;本文主旨&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Docker 和 Kubernetes 文档都提倡将一个应用程序或每个容器“一个问题”打包的概念。这也可以作为每个应用程序和容器运行“一种进程类型”的指南。&lt;/li&gt;
&lt;li&gt;基于电信的云原生网络功能 (CNF) 具有低延迟、高吞吐量和弹性等特定要求，这激发了多关注点/多进程类型的容器化方法。&lt;/li&gt;
&lt;li&gt;使用多种进程类型实现的高性能电信应用程序应该探索使用 unix 域套接字而不是 TCP 或 HTTP 进行通信，因为这可以加快容器之间的通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://vmblog.com/archive/2022/01/04/the-zeitgeist-of-cloud-native-microservices.aspx#.Y73WvezMJhE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务的详细和简明定义&lt;/a&gt; 很有价值。厚微服务可以是任何利用康威定律并按产品团队边界部署代码的东西。精益微服务是那些遵循粗粒度代码部署的服务，通常在容器中，具有单一的关注点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.infoq.com/articles/cloud-native-network-functions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Native Network Functions&lt;/a&gt;（CNFs）是电信领域的网络应用，非功能性需求不同于大多数云原生企业应用。CNF 通常是 &lt;a href=&#34;https://www.cncf.io/blog/2022/09/12/top-11-things-you-didnt-know-about-cloud-native-statefulness/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;有状态的&lt;/a&gt; 同时需要 &lt;a href=&#34;https://www.cncf.io/blog/2022/09/26/top-9-overlooked-questions-when-designing-your-stateful-cloud-native-network-application/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;低延迟、高吞吐量和弹性&lt;/a&gt;。任何减少或禁止这些要求的架构要么不适合电信发展，要么在其实施中需要特殊例外。这就是瘦微服务模型的挑战，它促进了容器和 CNF 的“一个关点，一个进程”的设计。&lt;/p&gt;
&lt;h2 id=&#34;每个容器聚焦于一个关注点&#34;&gt;每个容器聚焦于一个关注点&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/architecture/best-practices-for-building-containers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google 云文档、&lt;/a&gt;&lt;a href=&#34;https://docs.docker.com/config/containers/multi-service_container/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docker 文档&lt;/a&gt; 和 &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/#how-pods-manage-multiple-containers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 文档&lt;/a&gt; 都提倡每个容器一个应用程序或一个关注点的概念。谷歌云文档使用术语“应用程序”，而 docker 文档使用术语“关注点”并将关注点进一步描述为一组父/子进程，它们是应用程序的一个方面。nginx 实现就是一个很好的例子，它将在启动时创建一组子工作进程。理解单一关注规则的另一种方法是说容器中应该只存在一种进程类型（例如一组 nginx 工作进程）。&lt;/p&gt;
&lt;p&gt;为什么存在这条规则？虽然最初认为这条规则背后的基本原理是降低单个模块、组件、对象等的复杂性，但这条规则背后的真正驱动力是尊重代码的变化率，这个概念借鉴了传统建筑概念和生物学。工件的部署速度应与其更改频率一致。云原生的方式是通过尽最大努力解耦代码来做到这一点。对性能优化的需求通常会助长对解耦的抵制，我们将在后面介绍。&lt;/p&gt;
&lt;p&gt;电信等行业有独立发展的历史。换句话说，在电信行业内，代码、代码库和代码部署都是在一个大型组织内开发的。即使多个子组织共同开发一个大型项目（例如商业级交换机），此类库、项目和最终产品的部署也是集中部署并锁定步骤。鉴于这段历史，即使前面提到的微服务的厚定义存在问题，网络功能更难遵守微服务的薄定义和单一关注点规则也就不足为奇了。&lt;/p&gt;
&lt;h2 id=&#34;每个进程一个关注点的七大好处&#34;&gt;每个进程一个关注点的七大好处&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/monodot&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tom Donohue&lt;/a&gt; 说明了此处重述的&lt;a href=&#34;https://www.tutorialworks.com/containers-single-or-multiple-processes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;单一关注原则&lt;/a&gt; 的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;隔离&lt;/strong&gt;：进程在使用容器命名空间系统时，不会相互干扰。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：与许多类型相比，扩展一个进程或一类进程更容易。这可能是出于复杂性的原因（一种进程类型比许多进程类型更难扩展）或因为变化率不同（一个进程需要根据与其他进程不同的条件增长）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可测试性&lt;/strong&gt;：当假定一个进程独立运行时，它可以独立于其他进程进行测试。这使开发人员可以通过消除额外的变量来更轻松地定位问题的根本原因。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可部署性&lt;/strong&gt;：当进程的二进制文件和依赖项部署在容器中时，部署的变化率相对于二进制文件和容器是粗粒度的，但相对于其他进程及其依赖项是细粒度的。这允许部署根据依赖树中发生更改的位置和时间进行调整，而不是同步重新部署所有内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可组合性&lt;/strong&gt;：进程中只有一个关注点，因此每个容器的进程类型更容易推理，因为它更容易以数字方式共享和口头交流其内容。这使得它更容易在其他项目中重用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;遥测&lt;/strong&gt;：从一个问题或进程类型推断日志消息比与其他问题交错的日志消息更容易。在将所有日志消息打印到 &lt;a href=&#34;https://en.wikipedia.org/wiki/Standard_streams&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标准输出&lt;/a&gt; 的容器中尤其如此，例如 12 因素云原生应用程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编排&lt;/strong&gt;：如果容器中有多个进程类型，则必须在容器内管理次要关注点的生命周期，这实际上意味着在父进程类型中创建编排器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开源云原生运动对电信行业的影响是供应商之间协作的爆炸式增长。与在一个组织的保护伞下开发紧密耦合的软件相反，对更多协作和互操作性的呼吁已经促使来自不同组织的多个项目重新审视单一关注点原则的好处。&lt;/p&gt;
&lt;h2 id=&#34;云原生进程最佳实践&#34;&gt;云原生进程最佳实践&lt;/h2&gt;
&lt;h3 id=&#34;独立于流程顺序&#34;&gt;独立于流程顺序&lt;/h3&gt;
&lt;p&gt;将多个进程类型放在同一个容器中的论据之一是&lt;a href=&#34;https://medium.com/@kelseyhightower/12-fractured-apps-1080c73d481c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;需要更多地控制问题的启动顺序&lt;/a&gt;。例如需要数据库的传统应用程序。如果数据库不可用，应用程序和 Web 服务器可能无法正常启动，因此有人可能会在启动应用程序之前手动启动 docker 文件中的数据库。虽然这确实有效，但这样做会失去关注点松散耦合的七个好处。更好的方法是使您的关注点和流程类型尽可能独立于顺序。&lt;/p&gt;
&lt;h3 id=&#34;你的进程将被终止&#34;&gt;你的进程将被终止&lt;/h3&gt;
&lt;p&gt;Kubernetes 有一个 &lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pod 优先级&lt;/a&gt; 的设置，如果不满足一组条件时，允许用户&lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;抢占或终止&lt;/a&gt; pod。这意味着 pod 需要响应来自这些调度策略的正常关闭请求，否则它们将面临数据损坏和其他错误。这些正常关闭请求以 &lt;a href=&#34;https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SIGTERM 请求&lt;/a&gt; 的形式出现，通常在 SIGKILL 请求发出前 30 秒终止强制过程。当运行多个进程时，所有子进程都需要能够处理正常关闭信号。正如我们稍后将看到的，处理进程的正常关闭可能会导致一些微妙的问题，这些问题在处理多个进程时会变得更糟。&lt;/p&gt;
&lt;p&gt;在电信中，流程顺序独立性和抢占通常由与其管理的流程紧密耦合的编排器处理。有了像 Kubernetes 这样的与应用程序无关的编排器，这些自定义和紧密耦合的编排器时代即将结束，如&lt;a href=&#34;https://kubernetes.io/docs/reference/scheduling/config/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;声明式调度配置&lt;/a&gt;。电信云原生方法可能应该类似于 Erlang 社区对进程的 &amp;ldquo;&lt;a href=&#34;https://erlang.org/download/armstrong_thesis_2003.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;让它失败&lt;/a&gt;&amp;ldquo;方法，其中调用进程对它所调用的进程更加稳健。&lt;/p&gt;
&lt;h3 id=&#34;多进程和应用程序生命周期&#34;&gt;多进程和应用程序生命周期&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/architecture/best-practices-for-building-containers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud&lt;/a&gt; 建议您为每个容器打包一个“应用程序”。在更技术层面上，单个应用程序被定义为具有可能的许多子进程的单个父进程。这一基本原理的主要部分是利用应用程序生命周期中不同的变化率。生命周期是什么意思？生命周期是应用程序的开始、执行和终止。任何具有不同启动、执行或终止原因的进程都应该与其他进程分开（即不紧密耦合）。当我们理清这些问题时，我们可以将它们表示为单独的健康检查、策略和部署配置。然后我们可以声明性地表达这些关注点，在源代码控制中跟踪它们，并在语义上对它们进行版本控制。这使我们能够避免步调一致地升级，导致将不同的应用生命周期锁定在一起。&lt;/p&gt;
&lt;p&gt;管理容器中多个应用程序或进程类型的生命周期的问题源于它们都有&lt;a href=&#34;https://cloud.google.com/architecture/best-practices-for-building-container#package_a_single_app_per_container&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不同的状态&lt;/a&gt;。例如，如果您有一个父进程启动 Apache，然后还启动 Redis，则父进程需要知道如何以及何时启动、监视和终止 Apache 和 Redis。对于您无法控制的代码或二进制文件，此问题甚至更加困难，因为您无法控制这些应用程序如何表达其健康状况。这就是为什么表达程序健康状况的最佳位置，尤其是您无法控制的进程，是在暴露给容器管理系统或编排器（例如 Kubernetes）的配置中，它旨在适应生命周期而不是临时的 bash 脚本。&lt;/p&gt;
&lt;h3 id=&#34;多进程加剧云原生信号和僵尸问题&#34;&gt;多进程加剧云原生信号和僵尸问题&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不处理所谓的 PID 1&lt;/a&gt; 容器中的进程充满了极度隐蔽、难以察觉的问题。当涉及多个进程时，这些问题会加剧。正确处理 PID 1 的两个主要问题是&lt;a href=&#34;https://cloud.google.com/architecture/best-practices-for-building-containers#signal-handling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;处理终止信号和僵尸&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;sigterm&#34;&gt;SIGTERM&lt;/h3&gt;
&lt;p&gt;所有应用程序和进程都必须知道两种类型的关机：正常关机和立即关机。假设一个有状态应用程序希望打开一个重要文件、写入数据并关闭文件而不被中断。在这种情况下，由于 K8s 的抢占功能，应用程序最终会破坏文件。处理此类问题的一种方法是正常关闭。这就是 SIGTERM 信号的作用。它告诉应用程序它将被关闭并开始正常运行以避免损坏或其他错误。在编排系统中，所有进程都应设计为在需要时处理正常关闭。但是启动其他进程的进程呢？为了处理子进程的正常终止，父进程需要向所有子进程传递 SIGTERM 信号，让它们也正常关闭。这就是 PID 1 处理不当的问题所在。除非明确告知，否则像 bash 这样的简单脚本不会将 SIGTERM 信号传递给它们启动的进程。如果您不通过 SIGTERM，将产生非常难以检测的错误。&lt;/p&gt;
&lt;h3 id=&#34;一个隐蔽的-sigterm-错误示例&#34;&gt;一个隐蔽的 SIGTERM 错误示例&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://about.gitlab.com/blog/2022/05/17/how-we-removed-all-502-errors-by-caring-about-pid-1-in-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gitlab 记录&lt;/a&gt;他们遇到了一个问题，即页面上会出现 502 错误，但在一定时间后神秘地自行修复。问题是因为前面提到的正常终止信号 (SIGTERM) 没有被发送到在页面服务资源被删除后打开连接的子进程。众所周知，这个问题很难追踪。&lt;/p&gt;
&lt;h3 id=&#34;僵尸进程&#34;&gt;僵尸进程&lt;/h3&gt;
&lt;p&gt;容器中的&lt;a href=&#34;https://en.m.wikipedia.org/wiki/Process_identifier&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PID 1 进程&lt;/a&gt;也会在子进程终止后清理它们。这看起来很简单，但默认情况下 PID 1 bash 脚本无法正确清理。不清理或收割子进程意味着什么？这些不干净的进程，也称为僵尸进程，填满了所谓的进程表。它们最终会阻止您启动新进程，从而阻止您的整个节点运行。&lt;/p&gt;
&lt;h3 id=&#34;一个合适的初始化系统来处理僵尸和信号&#34;&gt;一个合适的初始化系统来处理僵尸和信号&lt;/h3&gt;
&lt;p&gt;限制僵尸进程影响的一种方法是拥有一个&lt;a href=&#34;https://ahmet.im/blog/minimal-init-process-for-containers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;适当的初始化系统&lt;/a&gt;。如果您正在考虑使用您无法控制的代码（例如 Postgres 数据库）运行 PID 1 进程，则尤其如此。这个进程可能会启动其他进程，然后忘记收割它们。使用适当的 init 系统，任何终止的子进程最终都会被 init 系统回收。&lt;/p&gt;
&lt;p&gt;您可以在容器内运行适当的初始化系统和复杂的监督程序。监督程序有时候被认为是矫枉过正，因为它们占用了太多资源，而且有时过于复杂。复杂监管程序有 supervisord、monit 和 runit。适当的 init 系统比复杂的监管程序小，因此适用于容器。合适的容器初始化系统有 tini、dumb-init 和 s6-overlay。&lt;/p&gt;
&lt;h2 id=&#34;性能和云原生电信进程&#34;&gt;性能和云原生电信进程&lt;/h2&gt;
&lt;p&gt;在容器中运行多个进程的主要动机之一是对性能的渴望。在单独的容器中而不是在同一个容器中运行进程（假设进程间通信是相同的）似乎会降低性能。这种&lt;a href=&#34;https://pythonspeed.com/articles/docker-performance-overhead/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;性能下降可归因于&lt;/a&gt; 容器系统中内置的隔离和安全措施。也可以通过在特权模式下运行容器来删除它，但这会降低安全性。&lt;/p&gt;
&lt;p&gt;人们对将进程分离到多个容器中存在一种误解，那就是所有通信的性能都会受到影响，因为它必须通过 TCP 或更糟糕的 HTTP 进行。这不太对。通过&lt;a href=&#34;https://dev.to/douglassakey/a-simple-example-of-using-unix-domain-socket-in-kubernetes-1fga&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 unix 域套接字进行通信&lt;/a&gt;。这可以在 Kubernetes 中通过使用在 pod 内的所有容器之间共享的卷挂载来配置。&lt;/p&gt;
&lt;p&gt;在电信环境中，数据平面的核心关注点是性能，因此使用线程、共享内存和进程间通信来提高性能。当这些问题密切相关时，它会因为复杂性而增加。在不同容器之间但在同一个 pod 中实现的进程间通信应该有所帮助。电信控制平面通常需要较低的性能，因此可以设计为遗留应用程序&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;为了获得云原生生态系统的最大互操作性和可升级性优势，电信行业需要遵守容器和部署的单一焦点规则。能够做到这一点的供应商将比不能做到这一点的供应商更具竞争优势。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;要了解更多云原生原理，请加入 CNCF 的云原生&lt;a href=&#34;https://github.com/cncf/cnf-wg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络功能工作组&lt;/a&gt;。有关 CNCF 的 CNF 认证计划的信息，该计划&lt;a href=&#34;https://www.cncf.io/certification/cnf/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;验证您网络功能中的云原生最佳实践&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;特别感谢 Denver Williams 对本文的技术审阅。&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache APISIX 借助服务网格实现统一技术栈的全流量管理</title>
      <link>https://cloudnative.to/blog/2022-service-mesh-summit-apache-apisix-mesh/</link>
      <pubDate>Tue, 18 Oct 2022 09:00:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/2022-service-mesh-summit-apache-apisix-mesh/</guid>
      <description>&lt;p&gt;在云原生快速发展的前提下，服务网格领域也开始逐渐火热。目前阶段，大家所熟知的服务网格解决方案很多，每种产品又各有其优势。因此在面对不同的行业或者业务背景时，每个人的选型想法都各不相同。&lt;/p&gt;
&lt;h2 id=&#34;服务网格现状和痛点&#34;&gt;服务网格现状和痛点&lt;/h2&gt;
&lt;p&gt;服务网格的出现其实跟目前业务架构的演进有很大关系。云原生趋势大涨后，大部分企业都开始转型做微服务。在这种背景之下，大家发现 App 开始变得越来越小，每个 App 里面都会一些通用的东西。所以就开始有一些想法“有没有一种技术可以把这些通用的东西沉淀下来”。于是，就出现了 Sidecar（边车）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-1_hubc0f1bc1d26087beda3c0cd52542da94_98869_01fe678353713e672081291f8a440006.webp 400w,
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-1_hubc0f1bc1d26087beda3c0cd52542da94_98869_aaa5411479827a53581c18ebe9cb45cc.webp 760w,
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-1_hubc0f1bc1d26087beda3c0cd52542da94_98869_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-1_hubc0f1bc1d26087beda3c0cd52542da94_98869_01fe678353713e672081291f8a440006.webp&#34;
               width=&#34;760&#34;
               height=&#34;461&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;有了 Sidecar 之后，就可以把一些诸如服务注册发现、流量管理、可观测性和安全防护等功能沉淀到其中，这样业务服务就可以专注于业务逻辑层面的开发。&lt;/p&gt;
&lt;p&gt;但是在出现 Sidecar 模式之后，在实践过程中人们也开始慢慢发现它的一些痛点，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方案众多，一旦选择就难以撤退&lt;/strong&gt;。目前市面上的服务网格方案众多，各种方案中各有差异。一旦确定了其中一个方案，基本就会一直使用下去。但如果在后续使用过程中发现方案无法满足相关业务迭代，再次更换时就会产生巨大的成本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;与基础设施整合成本高&lt;/strong&gt;。服务网格在落地实践中，通常会需要与基础设施进行整合，比如与之前的微服务架构、MQ 或者数据库等基础组件整合。一些遗留问题或者历史技术债务也会对整合过程产生一定的阻力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能损耗与资源的额外消耗&lt;/strong&gt;。目前阶段，不管你选择哪种服务网格方案，它都会存在一定的性能损耗。同时因为 Sidecar 的存在，在配置业务时，就需要为其额外分配资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;扩展难度高&lt;/strong&gt;。一些服务网格方案在配置时，现有的配置方式无法进行协议或功能的扩展，同时也无法通过插拔方式进行自定义扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，在这种业务现状和痛点的催生中，我们就开始思考，是否可以有一种理想的服务网格方案，可以解决当前的现状和痛点呢？&lt;/p&gt;
&lt;h2 id=&#34;理想的服务网格应如何&#34;&gt;理想的服务网格应如何？&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-2_hudfca4c2da72fba858a4f8a291adb1f78_103719_3dedf58007689aaa7e90abb4d0287925.webp 400w,
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-2_hudfca4c2da72fba858a4f8a291adb1f78_103719_fbc2f77705fa5ba0c682ff4ec5f77ad1.webp 760w,
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-2_hudfca4c2da72fba858a4f8a291adb1f78_103719_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-2_hudfca4c2da72fba858a4f8a291adb1f78_103719_3dedf58007689aaa7e90abb4d0287925.webp&#34;
               width=&#34;760&#34;
               height=&#34;411&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在面对相关业务场景时，我们对于服务网格的要求大概如上图所示，即从资源、性能、流量管理和扩展方向有多个维度的需求。当然除了这些之外，在其他层面也会有一些更细致的要求。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先&lt;strong&gt;使用体验&lt;/strong&gt;层面，要做到上手成本更低。因为真正用服务网格的不一定都是开发人员，可能运维人员也比较多。因此上手成本的高低，也是大家选择一个方案的因素之一。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次在技术层面，&lt;strong&gt;控制面&lt;/strong&gt;的配置一定要易于上手，同时对于相关权限能进行严格且安全的管控，而且配置方式要更贴近大众层面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而在&lt;strong&gt;数据面&lt;/strong&gt;，最好是能原生支持多种协议甚至是自定义协议，因为你需要去考虑一些历史系统迁移所带来的问题。由于 Sidecar 的存在，也需要考虑其资源占用在可控范围内，这样可以有效控制成本。同时需要满足一些自定义需求，因此对扩展能力也提出了新的要求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后是在整个&lt;strong&gt;产品生态&lt;/strong&gt;内，不管是社区还是产品修复等，需要「及时响应」的速度去匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然已经有了这么清晰的需求目标，接下来要做的就是去执行和打造这么一个接近理想型的方案了。&lt;/p&gt;
&lt;h2 id=&#34;基于-apisix-的服务网格方案&#34;&gt;基于 APISIX 的服务网格方案&lt;/h2&gt;
&lt;p&gt;Apache APISIX 是一个动态、实时、高性能的云原生 API 网关，提供负载均衡、动态上游、灰度发布、服务熔断、身份认证、可观测性等丰富的流量管理功能。&lt;/p&gt;
&lt;p&gt;目前全球已有数百家企业使用 Apache APISIX 处理关键业务流量，涵盖金融、互联网、制造、零售、运营商等等，比如美国航空航天局（NASA）、欧盟的数字工厂、中国航信、中国移动、腾讯、华为、微博、网易、贝壳找房、360、泰康、奈雪的茶等。因此，基于 APISIX 的服务网格方案将不止在使用程度上，在面向一些行业领域时，也将具有强需求。&lt;/p&gt;
&lt;p&gt;目前这套服务网格方案在架构的选择上，则是采取了控制面 Istio 配合数据面 APISIX 的组成结构。&lt;/p&gt;
&lt;p&gt;首先在控制面上，我们选择了 Istio。因为 Istio 是当下最为流行的服务网格方案，同时它的社区活跃，这使得几乎所有的主流云厂商都对 Istio 进行了支持，这也在一定程度上代表了目前的市场需求和方向。所以在控制面的选择上，我们并没有进行自研模块。而是选择了拥抱 Istio 这个目前更适合也拥有更高接受度的方案。&lt;/p&gt;
&lt;p&gt;而在数据面则是 Apache APISIX 需要发挥优势的部分。作为云原生的 API 网关，APISIX 作为 Istio 的数据面，在这套服务网格方案中究竟进行了哪些动作呢？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-3_hue7ed5e6692fb764dbd8e11010adb24ad_281212_98b0e595a44d4493417bc50ade237c8c.webp 400w,
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-3_hue7ed5e6692fb764dbd8e11010adb24ad_281212_f1813a3808d2cf4bec5c3c03a82a6ee8.webp 760w,
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-3_hue7ed5e6692fb764dbd8e11010adb24ad_281212_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-3_hue7ed5e6692fb764dbd8e11010adb24ad_281212_98b0e595a44d4493417bc50ade237c8c.webp&#34;
               width=&#34;760&#34;
               height=&#34;461&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;熟悉 APISIX 的小伙伴们都知道 APISIX 是使用 etcd 进行数据存储的，但如果我们把 APISIX 作为 Sidecar 使用的话，它的配置从哪里来？这是需要考虑的问题。如果把 etcd 组件也放到 Sidecar 中，会发现整个资源消耗非常大，同时也不够灵活。&lt;/p&gt;
&lt;p&gt;所以在这个过程中，首先在 APISIX 中增加一个名为 xDS 的配置中心，让 APISIX 无需再使用 etcd。然后引入了上图中的 Amesh。Amesh 是一个 Go 编写的程序，编译成一个动态链接库，在 APISIX 启动时进行加载。其使用 xDS 协议与 Istio 进行交互，并将获取到的配置写入到 APISIX 的 xDS 配置中心中，进而生成具体的路由规则，最终使用 APISIX 完成对应请求的路由。&lt;/p&gt;
&lt;p&gt;经过如上架构的配置之后，可以实现如下效果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使 Amesh 与 APISIX 保持生命周期一致，两者可以一起开启或关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得益于 APISIX 原生支持 xDS Discovery，彼此通过 xDS 协议进行转换数据，从而在资源消耗层面实现可控；相比原生 Istio 的 Envoy 方案，可以让资源对象更加轻量化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配合 CRD 对整套方案进行扩展，尤其对 Istio 还未支持的功能，通过 CRD 可以快速方便的扩展。比如对接 APISIX 最为丰富的 plugin 配置，便是通过 CRD 的方式进行配置的；通过将 controller 和 Istio 配合使用，最大发挥了 Istio 与 APISIX 服务网格方案的可扩展性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;方案具体表现&#34;&gt;方案具体表现&lt;/h2&gt;
&lt;h3 id=&#34;性能提升明显&#34;&gt;性能提升明显&lt;/h3&gt;
&lt;p&gt;作为技术产品，数据永远是最直观和最有效的呈现方式。我们将 APISIX 和 Envoy 两者分别作为服务网格方案中的数据面，采用最多 5000 条路由的体量对其进行多种场景的压力测试，最终呈现了如下数据对比。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该测试场景为“匹配 5000 条路由中的第 3000 条路由”。由于测试场景较多，以下仅选取了匹配中间部分的路由进行描述，同时还有匹配头部路由和尾部路由的场景。数据太多不便展示，以下数据为 3000 条路由体量下的测试结果）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-4_hud204da50521f82a45643273ebe0dfe33_148875_9c82393589892769ed8cffee2551fd31.webp 400w,
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-4_hud204da50521f82a45643273ebe0dfe33_148875_1e9628cbf0ec2a2fa77c54970c8f1a9b.webp 760w,
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-4_hud204da50521f82a45643273ebe0dfe33_148875_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-4_hud204da50521f82a45643273ebe0dfe33_148875_9c82393589892769ed8cffee2551fd31.webp&#34;
               width=&#34;760&#34;
               height=&#34;261&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从上图数据可以看出，在 QPS 层面，面对同样的压力和相同机器配置时，APISIX 呈现出了 5 倍的性能提升。同时在请求延迟层面，APISIX 比 Envoy 降低了一个数量级，APISIX 的延迟在微秒级，而 Envoy 在毫秒级别。当然也能看到在这种测下，当 Envoy CPU 已经跑满的情况下，APISIX 的 CPU 消耗才仅为 50%。&lt;/p&gt;
&lt;h3 id=&#34;资源占用降低&#34;&gt;资源占用降低&lt;/h3&gt;
&lt;p&gt;在给服务网格方案注入 Sidecar 时，通常会额外消耗资源。而基于 APISIX 的这套方案，可以降低 60% 的资源消耗。为什么能做到这种程度呢？&lt;/p&gt;
&lt;p&gt;首先是配置按需下发。Istio 在面对 Sidecar 进行资源管理时，本身会自带一些按需下发的策略，比如根据 namespace 进行隔离，但这个过程会给用户操作带来额外的心智负担和管理难度。&lt;/p&gt;
&lt;p&gt;其次是配置本身是否精简。在 Envoy 中的路由配置时，可以通过 Dump 查看它的路由信息，你会发现实际可能没有那么多条路由，但是在 Envoy 中已经成千上万了。这就会带来很多影响，比如影响启动速度，造成一些配置的体积庞大，从而增加资源占用。&lt;/p&gt;
&lt;p&gt;而利用 APISIX 就能避免以上这些烦恼，APISIX 配置精简，降低了存储在内存中数据，加之本身的高性能，降低了 CPU 资源消耗。整套方案中的资源消耗降低了 60% 左右。&lt;/p&gt;
&lt;h3 id=&#34;学习成本低定制化能力强&#34;&gt;学习成本低，定制化能力强&lt;/h3&gt;
&lt;p&gt;APISIX 作为 Apache 软件基金会的活跃开源项目，在社区中提供了非常丰富的文档和学习资源，对于想要上手 APISIX 的朋友来说降低了学习成本。&lt;/p&gt;
&lt;p&gt;其次 APISIX 的源码是基于 Lua 实现的，Lua 语言其实比较容易看懂，因其本身属于轻量级脚本语言，查看 APISIX 源码就会更清晰易懂。&lt;/p&gt;
&lt;p&gt;最后就是基于 APISIX 的二次开发非常方便。当你想要定制针对自己业务进行自定义插件时，不止支持原生的 Lua 语言，也可以借助 APISIX 的 Plugin Runner 来实现类似 Python、Java、Go 甚至 Wasm 等更为熟悉的语言进行二次开发。&lt;/p&gt;
&lt;p&gt;而 APISIX 之所以生态强大，其实也跟产品的强扩展性分不开。&lt;/p&gt;
&lt;p&gt;APISIX 本身提供非常多的插件，涉及安全、日志、可观测性等等。这些插件在 APISIX 作为传统网关组件时，可以发挥地淋漓尽致。但是将 APISIX 配合控制面的 Istio 打造服务网格时，很多资源在 Istio 控制面不支持定义。那这个时候怎么办呢？&lt;/p&gt;
&lt;p&gt;所以就有了自定义 CRD 的出现。比如我们想要做一个故障注入的插件，实际上这个插件在 APISIX 早有提供，因此在这里只需额外配置几个参数即可。当然这里只是拿故障注入插件举例，像 APISIX 中还有安全认证、限流限速等常用插件都可以按照这样的方式接入，从而实现精细化管控。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-5_hua8466fc5507aa2df87799fd52f2728a1_154725_087a5bb0e4a638bf2c6026a9644286ec.webp 400w,
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-5_hua8466fc5507aa2df87799fd52f2728a1_154725_1236f78b7f07580aa8c56a2938e0830b.webp 760w,
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-5_hua8466fc5507aa2df87799fd52f2728a1_154725_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-5_hua8466fc5507aa2df87799fd52f2728a1_154725_087a5bb0e4a638bf2c6026a9644286ec.webp&#34;
               width=&#34;433&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

使用 CRD 这种方式最直接的好处就是它可以让扩展更加原生，使用声明式配置让用户更容易接受，同时不侵入 Istio 的原有配置，实现完美兼容。另一种好处是，对于已经使用 Istio 方案的用户迁移成本比较低。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;综上所述，基于 APISIX 的服务网格方案在上手体验上对于开发者或者使用者而言，更加方便易用同时便于拓展，同时也有着优异的性能表现与丰富的生态支持。得益于 APISIX 产品本身的能力特色，在插件和多协议层面下也拥有很好的功能支持。预计在年底，将为大家带来 APISIX 服务网格下一版本的更新，敬请期待！&lt;/p&gt;
&lt;h2 id=&#34;apisix-服务网格方案的未来展望&#34;&gt;APISIX 服务网格方案的未来展望&lt;/h2&gt;
&lt;p&gt;回过头来看，其实基于 APISIX 服务网格方案已经在朝着前文中提到的痛点进行逐一击破了，APISIX 服务网格也在朝着理想服务网格方案努力中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-6_huf0dfd02f20e0805b8831cf17a8930d3f_267614_5dd9ff6bbfb3a128cee1ce8835e1c4b6.webp 400w,
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-6_huf0dfd02f20e0805b8831cf17a8930d3f_267614_c3b0a665e6750686aac0050fe33e6745.webp 760w,
               /blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-6_huf0dfd02f20e0805b8831cf17a8930d3f_267614_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/2022-service-mesh-summit-apache-apisix-mesh/apisix-service-6_huf0dfd02f20e0805b8831cf17a8930d3f_267614_5dd9ff6bbfb3a128cee1ce8835e1c4b6.webp&#34;
               width=&#34;760&#34;
               height=&#34;371&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用 APISIX 这套服务网格方案可以看到，流量从外部通过 APISIX Ingress 进来，中间经过 APISIX 进行处理。这个过程中，APISIX Ingress 负责处理南北向的流量，Amesh + Istio 这套方案去处理东西向的流量。&lt;/p&gt;
&lt;p&gt;在这样的一个部署架构下，它能带来一些业务层面的价值。比如&lt;strong&gt;节约成本和统一技术栈&lt;/strong&gt;，你可以把原来在传统网关里面使用的通用能力快速复制到服务网格中。这样在业务层面，就可以进行统一的管理，从而控制成本，将网关、Ingress 与服务网格中的经验高度复用。&lt;/p&gt;
&lt;p&gt;在后续的迭代计划中，基于 APISIX 的服务网格方案还会继续深耕，完成诸如以下的计划方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结合 APISIX 的功能，打造 xRPC 能力的实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进行原生异构的多协议支持；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;覆盖包含 Istio 的各类场景和配置，大幅度降低用户迁移成本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结来说，在当下技术发展趋势中，服务网格势必是未来的流行趋势。虽然现在各种方案都还不太完善，但整体都属于螺旋上升的状态。当然，基于 APISIX 的服务网格也正朝着大家心目中的理想型服务网格解决方案奋进。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生网络功能（CNF）介绍</title>
      <link>https://cloudnative.to/blog/cloud-native-network-functions/</link>
      <pubDate>Tue, 23 Aug 2022 11:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-network-functions/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://infoq.com/articles/cloud-native-network-functions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Native Network Functions Are Here&lt;/a&gt;，译者 &lt;a href=&#34;https://jimmysong.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jimmy Song&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;主要收获&#34;&gt;主要收获&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;云原生网络不是另一种方式的 SDN，它以一种完全不同的方式来看待网络。&lt;/li&gt;
&lt;li&gt;虽然 SDN 似乎是把物理网络和机器做了虚拟化，但「云原生网络功能」（Cloud-native Network Functions，下文简称 CNF）不仅仅是容器化的网络和虚拟机，它还将网络功能分割成服务，这是 CNF 与 SDN 的一个主要区别。&lt;/li&gt;
&lt;li&gt;CNF 是 OSI 网络模型中的网络功能（越底层实现起来就越困难），这些功能是根据云原生实践实现的。&lt;/li&gt;
&lt;li&gt;虽然 SDN 数据平面（这里指的是转发数据包）位于硬件 ASIC 上，或在传统内核网络转发的虚拟化盒子里，但 CNF 探索用户平面转发或更新的 eBPF 数据路径转发。&lt;/li&gt;
&lt;li&gt;在云原生数据中心中，偏向于三层的解决方案，但 CNF 的一大驱动力是电信服务提供商，他们经常下降到二层的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在三类云资源（计算、存储和网络）中，网络似乎最难满足云原生的非功能性需求。例如，计算弹性可以通过虚拟机、容器和编排器合理分配，并通过 CI/CD 管道进行管理。网络弹性似乎在实施中有所欠缺。在这篇文章中，我们展示了云原生网络功能将网络应用引入云原生世界的一种尝试。究竟什么是 CNF，为什么它们很重要？&lt;/p&gt;
&lt;h2 id=&#34;sdn-重生我们以前没有试过吗&#34;&gt;SDN 重生？我们以前没有试过吗？&lt;/h2&gt;
&lt;p&gt;不论是在过去还是现在，软件定义网络（SDN）都试图实现网络配置的自动化。CNF 不是另一种 SDN，而是以一种完全不同的方式来看待网络。从某种意义上说，CNF 与 SDN 一样，都是基于软件而非硬件的解决方案。但云原生网络有一套全新的非功能要求，与 SDN 不同。云原生的非功能要求优先考虑弹性，并推而广之，自动化也比 SDN 多得多。这一要求的实现倚重于声明性配置。换句话说，云原生配置应该更喜欢说&amp;quot;想做什么&amp;quot;，而不是&amp;quot;想怎么做&amp;quot;。例如，声明式配置对网络的影响之一是禁止硬编码的 IP 地址。声明式配置允许整个系统自我修复，因为它使人们更容易读懂和回应系统应该是什么样子。然后可以使系统不断地自我修正。云原生系统的其他非功能要求是弹性和可用性，但用扩展冗余而不是扩展技术实现。云原生系统试图通过更高的可服务性和冗余度使子组件具有更高的可用性来解决可靠性问题。例如，在云原生系统中，如果一个顶级组件带有多个冗余的子组件，其中有几个组件是可用的，但有几个组件出现故障，这比一个紧密耦合但&amp;quot;高度可靠 &amp;quot;的组件更可靠。&lt;/p&gt;
&lt;h2 id=&#34;超越虚拟化的网络盒子&#34;&gt;超越虚拟化的网络盒子&lt;/h2&gt;
&lt;p&gt;在某种意义上，&amp;quot;网络功能&amp;quot;并没有被解耦。虚拟网络功能（VNF）开始是网络硬件的虚拟化。VNF 有一个硬件与虚拟化硬件的一对一对应关系，小到网卡、特定应用集成电路（ASIC），大到整个交换机。虽然 SDN 似乎采取物理网络机器并将其虚拟化，但 CNF 不仅仅是容器化的网络虚拟机。CNF 是关于进一步解耦网络功能的。CNF 根据敏捷产品团队的发布周期，将网络功能分组为具有类似变化率的组件，这就摆脱了大公司的大型发布周期。由产品团队发布的软件[^4] 可以被认为是微服务的&amp;quot;厚&amp;quot;定义。微服务的 &amp;ldquo;薄&amp;rdquo; 定义是指作为容器内的单一进程类型交付的软件。通过跟踪开发软件的产品团队，我们发现厚微服务在实践中往往看起来薄微服务很像。&lt;/p&gt;
&lt;p&gt;为了管理微服务，出现了编排器。编排器负责微服务的调度、启动、停止和监控（&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;生命周期&lt;/a&gt;）。有许多编排器，其中 Kubernetes（K8s）是最受欢迎的，但也有特定领域的编排器，如电信领域的编排器。云原生生态系统的早期承诺之一是使编排器 K8s 不被&amp;quot;碎片化&amp;quot;。由 CNCF 维护的官方&lt;a href=&#34;https://www.cncf.io/certification/software-conformance/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;K8s 认证&lt;/a&gt;，确保 K8s 的任何分叉版本都能支持社区规定的 API 和最佳实践。&lt;/p&gt;
&lt;h2 id=&#34;究竟什么是云原生网络功能&#34;&gt;究竟什么是云原生网络功能？&lt;/h2&gt;
&lt;p&gt;云原生网络功能（CNF）位于 OSI 模型的第六层，它出现在了&lt;a href=&#34;https://github.com/cncf/trailmap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生足迹图&lt;/a&gt;中。CNF 在堆栈中的位置越低，良好的云原生实现就越困难。这可能是因为网络需要与编排器和底层主机集成，同时保留其云原生属性。这也可能是因为将以前的网络功能（如转发平面的功能）从共享内存/线程模型中分离出来，形成一个无共享的进程模型，如果不仔细操作，会降低性能。&lt;/p&gt;
&lt;p&gt;为了理解网络功能解耦的影响，了解一下网络层背后的原因是有帮助的。OSI 层的发展使网络创新得以发生，同时保持堆栈上下各层之间的互操作性。在网络层，IP 协议最终成为一个大赢家。在数据链路层，ARP 出现了。多个供应商在每一层的协议层面进行迭代，创造新的协议和协议的新实现。CNF 有机会作为库内的协议、微服务内的协议，甚至作为网络应用内的一组微服务来实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://networkservicemesh.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Network Service Mesh&lt;/a&gt;项目的 Ed Warnicke 曾经说过，对于网络服务来说，&amp;quot;&lt;a href=&#34;https://www.youtube.com/watch?v=OyI2ZuwIc_Q&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据包就是有效载荷&lt;/a&gt;&amp;quot;。这意味着网络应用或服务实际上是对网络数据包或帧进行操作（转换、路由或分析）。以下是 OSI 模型各层的网络功能的一些例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第七层：CoreDNS&lt;/li&gt;
&lt;li&gt;第六层：NFF 数据包检查器&lt;/li&gt;
&lt;li&gt;第五层：Rsocket&lt;/li&gt;
&lt;li&gt;第四层和第三层：Envoy/Network Service Mesh/各种CNI插件&lt;/li&gt;
&lt;li&gt;第二层：基于 VPP 的 VSwitch&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于云原生网络应用，或跨越多层的高阶 CNF，例如 &lt;a href=&#34;https://www.matrixx.com/5g-bss-technology/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MATRIXX 软件&lt;/a&gt;公司的&lt;a href=&#34;https://github.com/cncf/cnf-wg/tree/main/use-case/0003-UC-stateful-cnf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;5G 融合计费系统&lt;/a&gt;和&lt;a href=&#34;https://cdnf.io/cnf_list/bgp/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PANTHEON.tech&lt;/a&gt;公司的&lt;a href=&#34;https://github.com/cncf/cnf-wg/tree/main/use-case/0002-UC-bgp-enterprise&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BGP 服务器&lt;/a&gt;使用案例。&lt;/p&gt;
&lt;p&gt;云原生足迹图在一定程度上描述了云原生应用程序的成熟度。当我们深入研究云原生道路上的每一步时，事情就会变得更加复杂，比如网络、策略和安全。这就是说，在帮助你实现云原生的工具中存在着云原生的反射性。当把它应用于 CNF 时，我们最终不得不像其他云原生应用一样实现网络功能。这方面的总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步从粗粒度的部署开始，通常以容器形式实现。&lt;/li&gt;
&lt;li&gt;第二步是让服务或应用程序在CI/CD管道中以无状态和声明式的配置进行部署。&lt;/li&gt;
&lt;li&gt;第三步是支持部署在同质化节点上的编排器（如 K8s），该编排器管理服务的生命周期。&lt;/li&gt;
&lt;li&gt;第四步确保网络功能有遥测功能，这包括度量（如开放度量兼容的 Prometheus）、追踪（兼容 OpenTracing 的 Jaeger）和事件流兼容的日志（如 Fluentd）。&lt;/li&gt;
&lt;li&gt;云原生成熟度的第五步，服务发现，允许网络服务被集群内部甚至外部的其他消费者发现。&lt;/li&gt;
&lt;li&gt;为了促进声明性配置，第六步概述了策略的重要性，特别是网络和安全政策，通过服务适用和支持。&lt;/li&gt;
&lt;li&gt;第七步是分布式存储，适用于使用有状态工作负载的地方，以确保与云原生环境兼容。&lt;/li&gt;
&lt;li&gt;云原生信息传递、注册表、运行时和软件分发是云原生成熟度的其他阶段，使&lt;a href=&#34;https://github.com/cncf/trailmap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用程序的旅程&lt;/a&gt;更加完善。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;cnf-数据平面&#34;&gt;CNF 数据平面&lt;/h2&gt;
&lt;p&gt;有了 CNF，数据平面（也被称为转发平面）与传统硬件的距离更远。由于云原生原则重视扩展而不是扩大，这意味着拥有更多的同质化商用节点比拥有更少的异质化和专业化节点更受欢迎。正因为如此，出现了一种分解运动，用商用服务器来代替专门的网络交换机的特定应用集成回路（ASIC）。这样做的一个好处是，出现了支持更敏捷的变化速度的数据平面。虽然 SDN 数据平面（这里我们说的是字面意义上的转发数据包）停留在硬件 ASIC 上或传统内核网络转发的虚拟化盒子里，但 CNF 已经开始探索用户数据平面（如&lt;a href=&#34;https://s3-docs.fd.io/vpp/22.10/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VPP&lt;/a&gt;）、eXpress Data Path（XDP）的扩展伯克利包过滤器（eBPF）和 SmartNIC 转发等技术。&lt;/p&gt;
&lt;h2 id=&#34;三层网络升华&#34;&gt;三层网络升华&lt;/h2&gt;
&lt;p&gt;在云原生数据中心中，有一个&lt;a href=&#34;http://docs.projectcalico.org/v3.5/usage/troubleshooting/faq#i-heard-calico-is-suggesting-layer-2-i-thought-you-were-layer-3-whats-happening&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;偏向于三层的解决方案&lt;/a&gt;。能够声明性地指定和自动配置三层网络，这是发展 Kubernetes 网络模型的决定性因素。这些新的云原生网络依靠 IP 地址来连接集群的节点和应用，而不是第二层的 MAC 和 VLAN。然而，这主要是编排器及其应用程序的网络故事。数据中心有多个移动部件，在这个故事中的变化率不同。这三层可以说是在编排器下面（有 SONIC 等网络操作系统，Terraform 等配置工具），在编排器（如 Kubernetes）本身，以及在编排器上面但在容器（如 CNF）内。编排器下面的网络基础设施结构，如数据中心的架顶交换机（可能是分解的），继续拥有第二层配置。电信领域是采用 CNF 的主要驱动力，也继续有无法避免的第二层用例，如多协议标签交换（MPLS）。第二层结构的故事仍在用新的交换软件实现来书写，如&lt;a href=&#34;https://sonic-net.github.io/SONiC/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SONiC&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;网络的配置、部署和自动化是难以实现弹性的一些原因，而弹性是云原生环境的主要优势。这可能是转移到超级服务器（如亚马逊）的决定性因素，即使是在需要更多定制部署的时候。这与电信领域特别相关，因为他们有定制的网络协议，他们可能想为企业客户提供支持（如 MPLS）。CNF 通过基于变化率的网络功能解耦来解决这些部署问题，一直到粗粒度的镜像和进程（如容器）级别。这就避免了网络容易出现的传统的锁步式部署问题。&lt;/p&gt;
&lt;p&gt;CNF 是网络功能，也就是传统上认为位于 OSI 堆栈上的功能，遵循云原生实践来实现，它与云原生生态系统耦合。网络，尤其是电信网络，对非功能的要求由来已久，比如说弹性。电信服务提供商以 911 电话为例，将其作为一个要求极度弹性和可用性的关键任务系统。即便如此，云原生生态系统的非功能属性也得到了服务提供商的关注。这些属性，如可用性（云原生型）、易于部署和弹性，促使电信服务提供商对电信设备供应商（包括物理和软件）施加压力，使其更加云原生。这就要求这些新的网络组件遵循云原生基础设施的最佳实践，以便成为云原生生态系统中的成熟解决方案。这并不容易，因为要把传统上紧密耦合的、对性能有严格要求的组件（如网络数据线）解耦，是非常困难的。&lt;/p&gt;
&lt;p&gt;CNF 空间中的数据平面是一项正在进行的工作，有许多解决方案。仅仅是数据平面的概念就使对 CNF 的理解变得复杂，因为 CNF 不仅仅是一个物理盒子的虚拟化表示。在一个微不足道的层面上，云原生数据中心的网络可以通过集中于默认的内核网络和第三层 IPv4/IPv6 网络来避免这种复杂化。这对于电信公司的用例或网络结构的实施通常是不可行的。这些问题是网络软件解耦的自然发展的一部分，所以没有办法避免。如果 CNF 做得好，就会带来以前没有意识到的可部署性、弹性、易配置性和弹性的新水平。&lt;/p&gt;
&lt;p&gt;要了解更多关于云原生网络功能的信息，请加入 CNCF 的云原生网络功能&lt;a href=&#34;https://github.com/cncf/cnf-wg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;工作小组&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>避免在微服务上失败的 7 个关注点</title>
      <link>https://cloudnative.to/blog/7-ways-to-fail-at-microservices/</link>
      <pubDate>Fri, 18 Feb 2022 16:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/7-ways-to-fail-at-microservices/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://www.infoq.com/articles/microservices-seven-fail/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;7 Ways to Fail at Microservices&lt;/a&gt;，作者总结了她见过的导致微服务落地失败的一些情况，并提出了 7 个重要的关注点以引导大家来尽量避免。译者是在工作闲暇时间完成的翻译，其中难免有不当之处，请读者指正。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文主要观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务是一种手段，而不是目标&lt;/li&gt;
&lt;li&gt;分布式并不能保证解耦性&lt;/li&gt;
&lt;li&gt;合约测试（Contract Testing）是任何微服务架构的重要组成部分&lt;/li&gt;
&lt;li&gt;分解（Decomposition）需要发生在前端、后端和集成层，以及业务逻辑中&lt;/li&gt;
&lt;li&gt;如果企业没有能力快速、独立地发布微服务，那么微服务的许多好处就会丧失&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我（Holly Cummins）是 IBM 的一名 &lt;a href=&#34;https://www.linkedin.com/in/holly-k-cummins&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;技术顾问&lt;/a&gt;，我的一部分工作是帮助企业实现云原生。在去年 11 月的 QCon Plus 上，我介绍了 &lt;a href=&#34;https://plus.qconferences.com/plus2021/presentation/7-ways-fail-microservices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一些不正确的微服务使用方式&lt;/a&gt;。这些问题是基于我的经验来整理的，它们是我在客户现场反复看到的一些问题。&lt;/p&gt;
&lt;p&gt;我看到的第一个问题是，我们有时甚至不知道问题出在哪里。人们觉得我们应该做 &lt;a href=&#34;https://microservices.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务&lt;/a&gt;，但我们并没有真正花足够的时间来定义我们为什么要做微服务。&lt;/p&gt;
&lt;p&gt;我们要解决的是什么问题？现在是什么问题在困扰我们？我们做了微服务之后，什么会更好？这是一个很自然的本能问题，尤其是对于我们这些技术人员来说。我们想直接开始用微服务去解决问题，同时想玩一些这样新的酷炫的技术。尽管这些也非常重要，但更应该清楚我们要通过微服务去解决什么问题。&lt;/p&gt;
&lt;p&gt;容器技术使这种“直接开始用微服务去解决问题”的情况变得更糟：因为容器是一种近乎神奇的技术，这使得它本身就是一个伟大的解决方案 —— 它是如此轻巧，它是如此的便携，它使许多事情变得更好。于是我们最终决定：“因为我已经有了这些容器，如果只在一个容器中运行我的应用程序，那将是对容器能力的严重浪费。我应该在尽可能多的容器中运行它！”不幸的是，“没有足够的容器（来发挥伟大的容器技术的能力）”并不是一个合理（分辨为什么我们需要微服务）的问题陈述。&lt;/p&gt;
&lt;h2 id=&#34;简历驱动的开发&#34;&gt;简历驱动的开发&lt;/h2&gt;
&lt;p&gt;我看到的另一个问题是 &lt;a href=&#34;http://radar.oreilly.com/2014/10/resume-driven-development.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;简历驱动的开发&lt;/a&gt;。我们在看自己的简历时，有时会觉得在应该在“微服务”这部分写点什么。既然什么都不写肯定是不好的，所以我们会想：“我可以通过重新架构我公司的技术架构来让我的个人简历变得更漂亮啊”。读到这里时你可能在想，“不会吧，这也太功利了吧。应该没有人真的会为了完善他们的个人简历来做公司的架构决策吧？”然而事实证明 &amp;hellip;&amp;hellip; 确实是有人会这么做的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/cv-driven-development_hu57a221b907ceb581a1eb0284cb48ee1b_196026_c816807654244563db12c9d4f56539fd.webp 400w,
               /blog/7-ways-to-fail-at-microservices/cv-driven-development_hu57a221b907ceb581a1eb0284cb48ee1b_196026_f322b26eb052afdb31d7c47ffe820d0a.webp 760w,
               /blog/7-ways-to-fail-at-microservices/cv-driven-development_hu57a221b907ceb581a1eb0284cb48ee1b_196026_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/cv-driven-development_hu57a221b907ceb581a1eb0284cb48ee1b_196026_c816807654244563db12c9d4f56539fd.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.redhat.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Red Hat&lt;/a&gt; 公司最近做了一项调查，调查了 &lt;a href=&#34;https://www.redhat.com/en/blog/red-hat-survey-reveals-career-progression-driving-developer-hunger-containers-and-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于容器的开发的主要驱动因素&lt;/a&gt;。职业发展是头号驱动力。职业发展是简历驱动发展的一种更好的说法。&lt;/p&gt;
&lt;p&gt;避免在简历上出现微服务部分的缺口是一件重要的事，因为目前微服务几乎是一种新的主流技术理念。即使我们此刻没有寻找新的工作，我们也不希望成为异类 —— 当我们环顾四周，似乎其 TA 人都在做微服务。于是一种很自然的想法是，如果 TA 们都在做微服务，那我为什么不去做做微服务呢？我把这称为“微服务嫉妒”（Microservice Envy）。&lt;/p&gt;
&lt;h2 id=&#34;微服务不是目标&#34;&gt;微服务不是目标&lt;/h2&gt;
&lt;p&gt;“微服务嫉妒”是一个问题，因为微服务并不是我们应该羡慕的那种东西。我们的一位技术顾问同事有一个讲法，如果一个客户一直在谈论 Netflix 的技术并要求使用微服务，他就知道这个合作可能有问题了。几乎可以肯定的是，他们转向微服务的原因并不正确。如果对话更深入一些，涵盖了耦合和聚合等内容，那么他就知道客户他们转向微服务的原因确实存在问题。&lt;/p&gt;
&lt;p&gt;微服务转型的出发点不应该是微服务本身。微服务是实现业务敏捷性或弹性或同等的更高层次目标的手段。实际上，微服务甚至不是唯一的手段；它只是一种手段而已。&lt;/p&gt;
&lt;h3 id=&#34;分布式单体&#34;&gt;分布式单体&lt;/h3&gt;
&lt;p&gt;重要的是要问：“你是有微服务，还是有一个分布在数百个 Git 仓库的单体？”不幸的是，这就是我们经常看到的情况。一个分布式的单体是一个可怕的东西 —— 很难说它到底怎样，它比纯粹单体更容易出错。在传统的单体中，所有的东西都包含在一个单一的开发环境中，你可以得到一些好处，如编译时检查和 IDE 重构支持。因为你总是在一个进程中执行，你可以得到有保障的函数执行。你不必担心记住分布式计算的谬误和服务发现，以及处理你试图调用的东西已经停止存在的情况，事情是比较安全的。另一方面，如果我们去掉了单体的安全性，但保留了耦合性，我们最终会得到“云原生意大利面条”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;术语“意大利面条架构”（Spaghetti Architecture）可以被定义为一个信息技术问题，它阻碍了企业快速解码和转换其应用程序和数据以满足不断变化的需求的能力。“意大利面条架构”是一个源自一盘意大利面条外观的比喻。每根意大利面条代表每个业务工具，它们被纠结成无限的复杂线。—— 摘自《 &lt;a href=&#34;https://data-sleek.com/what-is-spaghetti-architecture-and-how-to-avoid-it/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;什么是“意大利面架构”和如何避免它&lt;/a&gt; 》。&lt;/p&gt;
&lt;p&gt;【编者按】“意大利面条”这个比喻似乎可以理解为：各个服务虽然看似分离了，但却各种层面上耦合、混合在一起，同时还容易断裂、崩坏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;分布式不等同于解耦&#34;&gt;分布式不等同于解耦&lt;/h2&gt;
&lt;p&gt;几年前，我被邀请到一个陷入困境的项目中去提供援助。当我进入项目时，团队对我说的第一件事就是“每当我们改变一个微服务时，另一个服务就会出现故障”。如果你一直在关注微服务的优势，你就会知道，这与应该发生的事情完全相反。微服务应该是相互独立的，解耦的。然而，如果你把你的系统做成分布式，&lt;a href=&#34;https://en.wikipedia.org/wiki/Decoupling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;解耦&lt;/a&gt; 就变得不那么容易了（它是有代价的）。虽然“分布式”（Distributed）和“解耦”（Decoupled）都以 D 开头，但它们本身不是一回事。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu359d6518fc5452ca9404f75090261076_94737_cc0f1b04f5515335cd3afcf702b97ed5.webp 400w,
               /blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu359d6518fc5452ca9404f75090261076_94737_ccd6e10fa2be8ef9cffd7615aaa3a614.webp 760w,
               /blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu359d6518fc5452ca9404f75090261076_94737_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/distributed-is-not-equal-to-decoupled_hu359d6518fc5452ca9404f75090261076_94737_cc0f1b04f5515335cd3afcf702b97ed5.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;拥有一个高度分布式的系统是很有可能既具有分布式所带来的所有痛苦，同时又仍然是完全纠缠和耦合的。上面提到的困境就是在这种情况下发生的事情。当我开始探索代码库的时候，我不断地在每个代码仓库中看到相同的代码。这个应用程序的对象模型是相当复杂的，有大约 20 个类，其中一些类有 70 个字段。这是一个非常复杂的结构体。&lt;/p&gt;
&lt;p&gt;微服务开发的原则之一是充分的 DRY（Don&amp;rsquo;t Repeat Yourself），避开公共库，因为它们是耦合的来源。在这种情况下，为了避免中央对象库的耦合，每个微服务在其代码中都有一个剪切和粘贴的对象模型副本。但如果领域结构体（Domain Schema）仍然是共享的，就仍然存在耦合。复制对象代码并不能消除耦合，它只是消除了编译时检查的可能性。如果一个字段名改变了，它仍然会破坏所有人，但这种破坏直到运行时才会发生。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hued491104b0f4f55e11372fa5e89163e3_142649_a3fabb65cfe4f0f830a37adc08345324.webp 400w,
               /blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hued491104b0f4f55e11372fa5e89163e3_142649_50c1717433a98797f5aa7be2e246701a.webp 760w,
               /blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hued491104b0f4f55e11372fa5e89163e3_142649_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/bad-case-of-coupling_hued491104b0f4f55e11372fa5e89163e3_142649_a3fabb65cfe4f0f830a37adc08345324.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个悲伤的故事表明了领域驱动设计（Domain-Driven Design）原则在微服务中的重要性。我们要实现的理想情况是，每个微服务都能整齐地映射到一个领域。这样做的一个副作用，也是你做得对的一个标志，就是你的微服务的接口粒度很小。如果我们沿着技术边界而不是领域边界划分，我们最终会出现像我看到的情况；每个微服务都有一个巨大的、脆弱的接口。其结果是一个支离破碎的“意大利面条”式的混乱状态。&lt;/p&gt;
&lt;h3 id=&#34;火星气候轨道飞行器&#34;&gt;火星气候轨道飞行器&lt;/h3&gt;
&lt;p&gt;虽然从技术上讲它是一个航天器，而不是一个微服务平台，但 &lt;a href=&#34;https://en.wikipedia.org/wiki/Mars_Climate_Orbiter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;火星气候轨道器&lt;/a&gt; 很好地展示了分布式和解耦之间的区别。NASA 在 1998 年发射了火星气候轨道器，其任务是研究火星气候。遗憾的是，轨道器没有成功绕过火星；相反，探测器坠入火星。NASA 的事后调查发现，问题源于两个不同的控制系统之间的关系，这两个系统由不同的团队建造。大多数时候，转向是由探测器本身的一个系统完成的。每隔几天，当轨道飞行器进入地球的视野时，佛罗里达州的监督控制系统就会发出航线修正。这大约是一个系统可以做到的分布式；它的一部分在太空中。但这两个系统之间的领域实际上是相似的：都在处理发动机推力的计算。这两个团队在沟通中对界面的样子还不够清楚，所以他们最终使用了不同的单位。太空中的部分使用公制单位，地球上的部分使用英制单位，所以灾难发生了。我们可以肯定地说，在这种情况下，系统是非常分布式的，然而这种分布式并没有帮助。&lt;/p&gt;
&lt;h2 id=&#34;以消费者为导向的合约测试&#34;&gt;以消费者为导向的合约测试&lt;/h2&gt;
&lt;p&gt;这种微妙的沟通问题在有多个团队参与的时候经常发生。令人高兴的是，有一个很好的缓解措施：&lt;a href=&#34;https://pactflow.io/what-is-consumer-driven-contract-testing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;消费者驱动的合约测试&lt;/a&gt;。在 IDE 没有帮助我们进行类型检查的系统中，我们需要测试我们的集成，但我们希望尽量减少全面的集成测试。集成测试很重，运行成本很高，而且本身就是耦合的。如果我们已经投资开发了微服务，我们不想在测试时倒退并制造一个大的集成单体。那么，我们如何让自己得到信心，让我们确信我们正在建立一个真正有效的东西呢？&lt;/p&gt;
&lt;p&gt;数据模拟（Mock）是一种常见的解决方案，但数据模拟本身也有一个问题。为了建立数据模拟，生产团队和消费团队在开发之初就会就接口的情况进行对话。他们达成了一个协议，然后消费团队就去尝试写一个数据模拟，这个模拟看起来就像他们对生产团队所说的代码的理解。在理想的情况下，他们会做得很好。问题是，消费团队经常会把自己的假设也写进了模拟中，而他们也许不是知道其他代码是什么样子的，是否是合适这部分模拟的，毕竟不是消费团队编写的代码。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/problems-with-mocks_hucccbc7d7a7c94fcc2182ca145b011501_102189_893f0aad3c01f7d797cb6f0621aba45e.webp 400w,
               /blog/7-ways-to-fail-at-microservices/problems-with-mocks_hucccbc7d7a7c94fcc2182ca145b011501_102189_ae2ab15c9a5998e5d2caf1c8b66ff811.webp 760w,
               /blog/7-ways-to-fail-at-microservices/problems-with-mocks_hucccbc7d7a7c94fcc2182ca145b011501_102189_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/problems-with-mocks_hucccbc7d7a7c94fcc2182ca145b011501_102189_893f0aad3c01f7d797cb6f0621aba45e.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在顺利的情况下，他们得到了正确的结果。单元测试全部通过，而且在集成阶段也继续通过，一切都很好。不幸的是，这并不总是发生。有时，实际的实现与消费团队所理解的不同，要么是因为生产团队改变了他们的想法，要么是因为某个地方的人做了一个不正确的假设。在这种情况下，测试仍然会通过。然而，当我们真正整合真实的服务时，它就会失败。问题是，模拟的行为没有经过真实服务的验证。生产团队很可能甚至从未见过已经创建的模拟。&lt;/p&gt;
&lt;p&gt;一个更好的选择是有一个消费者驱动的合约测试。合约测试的美妙之处，以及为什么它与模拟不同，是双方都与合约测试互动。对于消费者来说，合约测试就像一个方便的模拟。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/contract-testing_hu88015d9db24c1538b4e07f069e012026_103818_8c0d22741e30d93521127418e3bbc533.webp 400w,
               /blog/7-ways-to-fail-at-microservices/contract-testing_hu88015d9db24c1538b4e07f069e012026_103818_2f2f993e9cb1c7e38b145513e067ea3d.webp 760w,
               /blog/7-ways-to-fail-at-microservices/contract-testing_hu88015d9db24c1538b4e07f069e012026_103818_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/contract-testing_hu88015d9db24c1538b4e07f069e012026_103818_8c0d22741e30d93521127418e3bbc533.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在另一方面，合约测试对于生产团队也是一个方便的功能测试。它是一个更深刻的验证，而不仅仅是像 &lt;a href=&#34;https://swagger.io/specification/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenAPI&lt;/a&gt; 的语法检查。合约测试实际上也会检查语义和行为，这节省了生产团队编写功能测试的时间。&lt;/p&gt;
&lt;p&gt;如果所有的东西都是兼容的并且工作的，所有的合约测试都会通过。这是一个快速的信心提升，因为它们运行起来成本很低、也很轻便。如果生产团队破坏了什么，他们的测试将失败，并提供早期警报，在破坏性变化逃逸到集成环境之前。如果 API 发生变化，新版本的合约就会被双方（或连接的中间人）提出。&lt;/p&gt;
&lt;p&gt;现在有几个不同的合约测试系统。如果你在 Spring 的生态系统中，&lt;a href=&#34;https://spring.io/projects/spring-cloud-contract&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring Cloud Contract&lt;/a&gt; 工作得非常好。如果你是一个多面手，那么我非常喜欢 &lt;a href=&#34;https://pact.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pact&lt;/a&gt;。它有几乎所有你可能使用的语言的绑定。&lt;/p&gt;
&lt;h2 id=&#34;企业的毛球&#34;&gt;企业的毛球&lt;/h2&gt;
&lt;p&gt;当然，即使我们理清了所有的测试，即使我们在业务逻辑层有一套漂亮的解耦微服务，也不能保证成功。在我们的系统中还会有许多其他的元素，这些元素可能是我们在制定真正干净的微服务架构时没有考虑到的。我们对业务逻辑的开发非常投入，而忘记了前台和后台，以及所有的胶水层。在企业架构中，胶水层是非常可能存在的，而且是粘性的。我们的一位架构师把这称为“企业毛球”（Enterprise Hairball）。&lt;/p&gt;
&lt;p&gt;如果我们把所有的功能分解工作都集中在业务层，我们最终往往会得到一堆整齐的解耦的微服务，夹在一个单体的前端和一个单体的数据库层之间。在这些类型的系统中，变革将是一个挑战。然而，作为一个行业，我们正在更好地分解数据库，以便将其映射到各个微服务上，并且我们正在开发微前端。&lt;/p&gt;
&lt;p&gt;但我们还没有完成分解。如果系统不是很复杂，我们将有一个集成层。这可能是消息传递系统，也可能是一些其他的集成解决方案，将复杂的系统拉到一起。即使在架构的其他部分实现现代化架构之后，集成层往往仍然是单体的，不灵活的。团队本身可能处于重大的负荷之下 —— 正如我的同事所称呼的“恐慌的三明治”。因为集成层是单体的，他们必须小心翼翼地安排所有的变化，这就阻碍了其他所有人。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hu0bc7b2a0a5060aff2c75d99d0f98853a_312866_c51e704b864b6ac127e00f6b9e75cb83.webp 400w,
               /blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hu0bc7b2a0a5060aff2c75d99d0f98853a_312866_970206e07ec9fb7bafa9784e559b944f.webp 760w,
               /blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hu0bc7b2a0a5060aff2c75d99d0f98853a_312866_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/integration-layer-sandwich_hu0bc7b2a0a5060aff2c75d99d0f98853a_312866_c51e704b864b6ac127e00f6b9e75cb83.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这可能会带来很多挫折感，特别是对集成团队来说。在外界看来，他们似乎反应迟钝，速度缓慢，尽管他们正在努力工作。为了理清这种耦合，我们需要采用模块化的集成模式。&lt;/p&gt;
&lt;p&gt;如果我们不把集成层、数据库和前端层分割开来，会发生什么？几乎可以肯定的是，我们的微服务不会达到我们想要的效果。“毛球”各部分之间的依赖关系将使任何部分都无法快速移动。业务层的微服务将不能独立部署，部署的速度将明显地不连续。&lt;/p&gt;
&lt;h3 id=&#34;阻碍发布的拖累&#34;&gt;阻碍发布的拖累&lt;/h3&gt;
&lt;p&gt;你们有多少人经历过这种情况？你非常努力地工作，你创造了一些惊人的东西；你知道用户会喜欢它，但它还没有到他们手中。价值被摆在台面上了，但你那令人惊奇的东西却不能被发布。即使你有一个微服务架构，你也会有一个发布看板。所有其它的微服务都需要同时发布，因为它们需要一起测试，这样做的成本太高，除非正好是大批量服务同时发布。即使填写发布清单也很昂贵。大家时常会害怕发布，因为可能在过去曾被低劣的发布所深深地伤害。发布检查表、发布委员会、单线程测试和其它发布方法都是为了减少那些已知的风险。因为整个组织的发布期限是共同的，所以我们最终不得不争分夺秒地在最后期限前把功能塞进去。当然，这也使得发布的风险更大。某个人正在跟踪一个电子表格，上面有所有微服务之间的依赖关系，这些微服务的耦合度比它们应该的要高。然而，发布还是得按期执行。当我们选择微服务时，这并不是我们所希望发生的！所有这些用心良苦设计的流程都成为了拖累，阻碍了价值到达用户手中，而且往往实际上又增加了风险。&lt;/p&gt;
&lt;h2 id=&#34;测试自动化&#34;&gt;测试自动化&lt;/h2&gt;
&lt;p&gt;通常情况下，我们如此害怕发布的原因是在发布中涉及到大量的手工工作。特别是，真正能给我们带来信心的测试并不是自动化的，所以我们需要做大量的工作来弄清楚我们的应用程序是否能工作。当我访问一个客户，听到“我们的测试没有自动化”时，我听到的是“我们不知道我们的代码目前是否工作，它可能工作。上次我们做人工 QA 的时候它是有效的；我们希望它仍然有效”。这是一个可悲的情况。&lt;/p&gt;
&lt;p&gt;如果你关心你们的测试，就把它自动化 —— 质量是你应该关心的东西。特别是如果架构已经偏向于“意大利面条”，并且耦合性已经悄然出现，那么就很可能出现断裂。去“意大利面条化”是很困难的，所以我们要在一个快速反馈的地方，尽可能早地发现断裂。如果你要成为“意大利面条”，至少要成为经过测试的“意大利面条”。&lt;/p&gt;
&lt;h2 id=&#34;发布周期&#34;&gt;发布周期&lt;/h2&gt;
&lt;p&gt;手动测试只是发布过程中涉及的手动流程的一部分。在受监管或以合规性为重点的行业，几乎总是有一堆人工合规性工作。合规性是我们非常关心的事情 —— 所以我们应该把它自动化。&lt;/p&gt;
&lt;p&gt;有了所有这些手工流程和所有这些造成减速的流程，这意味着即使我们正在上云，但我们没有实际得到上云的红利。我们在使用云，但它好像又不是云。讽刺的是，在云中，我们曾经做过的事情、曾经是一个好主意的东西、曾经让我们更安全的事情，实际上正在伤害我们。旧式的治理在云中是行不通的，它不能实现我们所希望的商业结果，而且它失去了很多上云应得的商业利益。&lt;/p&gt;
&lt;p&gt;通过观察发布周期，很容易发现一个企业是否实现了上云的目标。几年前，我的一位同事与一家大型的传统银行进行了一次销售会谈。他们的市场被金融科技公司和新兴的挑战者银行吃掉了，这个企业明白他们为什么会输 —— 他们无法快速地跟上。他们来找我们，解释说他们有大量的 COBOL 资产，而这正是拖累他们的原因（很可能确实如此）。然后他们补充说，他们显然需要摆脱所有的 COBOL 并转向微服务，因为其他人都在做微服务。然后他们又说，他们的发布委员会一年只开两次会。讲到这里的时候，我的同事感觉不妙。如果你的发布委员会每六个月才开一次会，你就知道你的发布节奏将是每六个月一次。你有多少个可独立部署的微服务并不重要，你不可能在这种情况下获得敏捷性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hu008a2e9b52eccbbb2659dc8512dd12ef_176262_72810974ff2ed492aac320a3cb7fe6d7.webp 400w,
               /blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hu008a2e9b52eccbbb2659dc8512dd12ef_176262_423a2b9f3ff0617f4bfb8a2af0b9a582.webp 760w,
               /blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hu008a2e9b52eccbbb2659dc8512dd12ef_176262_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/7-ways-to-fail-at-microservices/be-careful-at-decomposing_hu008a2e9b52eccbbb2659dc8512dd12ef_176262_72810974ff2ed492aac320a3cb7fe6d7.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这家银行需要的帮助并不是真正的技术帮助；他们需要改变他们对风险的思考方式，以及他们的运营方式，他们的发布计划需要进行彻底的改革，他们需要一大堆的自动化。缺乏持续交付的纪律性是阻碍他们获取敏捷的原因，而不是 COBOL。&lt;/p&gt;
&lt;p&gt;“我想进行分解”是一个常见的客户要求，但分解有不止一个意思。当我们希望有一个分解的应用服务时，这并不能保证模块化 —— 有时它只是意味着乱七八糟的东西被分散得更广。如果有一些外部约束，比如发布看板和陈旧的工作流程，让我们总是被限制住，那在我们解决这些问题之前，我们如何分解都可能是徒劳无功的。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Holly Cummins&lt;/strong&gt; 是 IBM 企业战略部的创新领导者，并在 IBM Garage 担任顾问多年。作为 Garage 的一员，她为各行各业的客户提供技术驱动的创新，从银行业到餐饮业，从零售业到非政府组织。Holly 是 Oracle Java 冠军、IBM Q 大使和 JavaOne Rock Star。她与人合著了 Manning 的《Enterprise OSGi in Action》。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生时代需要什么样的存储系统？</title>
      <link>https://cloudnative.to/blog/storage-in-cloud-native-era/</link>
      <pubDate>Tue, 22 Jun 2021 19:51:43 +0800</pubDate>
      <guid>https://cloudnative.to/blog/storage-in-cloud-native-era/</guid>
      <description>&lt;h2 id=&#34;现状&#34;&gt;现状&lt;/h2&gt;
&lt;p&gt;当前，云原生已经成为应用开发者在选择架构设计时的首选。云原生让应用开发者可以将所有精力都集中在开发业务逻辑本身，这极大降低了应用开发者的负担。&lt;/p&gt;
&lt;p&gt;而应用系统的敏捷性、扩展性、可靠性、高可用等，则由基础设施软件和运维团队共同承担。一方面，运维团队需要利用基础设施软件，快速响应业务系统提出的部署、扩容、迁移等需求，另一方面，也要时刻保持业务系统和基础设施软件的稳定运行。这为基础设施软件和运维团队都带来了更大的挑战。&lt;/p&gt;
&lt;p&gt;如何正确的为基础架构软件进行设计和选型，就成为了运维主管们最具挑战的任务之一。&lt;/p&gt;
&lt;h2 id=&#34;云原生场景下的存储系统&#34;&gt;云原生场景下的存储系统&lt;/h2&gt;
&lt;p&gt;存储系统一直以来都是基础设施软件中的核心之一。无论业务采用什么样的运行环境和架构，都离不开存储系统的支撑。&lt;/p&gt;
&lt;p&gt;在过去的 30 年中，业务系统的运行环境经历了巨大的变化，从单独部署的物理机，小规模部署的虚拟化环境，大规模部署的云环境，以及目前的 Kubernetes 平台。在这个变革的过程中，业务系统对平台敏捷性的要求越来越高。在物理机时代，运维人员需要手动配置存储系统和部署业务系统，业务上线以周为单位。而在云原生时代，每分钟都可能发布新的应用版本，每天都可能有大量的业务要上线。&lt;/p&gt;
&lt;p&gt;这意味着，云原生时代的存储系统，除了要满足性能、稳定性、可靠性的要求以外，还要满足业务系统对敏捷性的要求，能够通过统一的编排系统配合业务上线，并且可以实现快速扩容。同时，为了减轻运维管理员的工作负担，存储系统自身的自动化运维能力，也成为运维团队关注的核心焦点。&lt;/p&gt;
&lt;h2 id=&#34;云原生的存储方案&#34;&gt;云原生的存储方案&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/storage-in-cloud-native-era/container-challenge_hu7accfea89fa863bd9ab31bdf7c330e3c_142685_04c02e8a44d097fecd9116fdb9e76046.webp 400w,
               /blog/storage-in-cloud-native-era/container-challenge_hu7accfea89fa863bd9ab31bdf7c330e3c_142685_2658d2db659bef6dd704e4cfbfbc3535.webp 760w,
               /blog/storage-in-cloud-native-era/container-challenge_hu7accfea89fa863bd9ab31bdf7c330e3c_142685_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/storage-in-cloud-native-era/container-challenge_hu7accfea89fa863bd9ab31bdf7c330e3c_142685_04c02e8a44d097fecd9116fdb9e76046.webp&#34;
               width=&#34;760&#34;
               height=&#34;432&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图 1. 使用/部署容器的主要挑战（图片来源于 CNCF 报告）&lt;/p&gt;
&lt;p&gt;从 CNCF 的调查可以看出，目前存储系统依然是云原生场景使用和部署中面临的最主要障碍之一。接下来我们来介绍一下云原生场景下不同存储方案的优劣点。&lt;/p&gt;
&lt;h3 id=&#34;本地磁盘&#34;&gt;本地磁盘&lt;/h3&gt;
&lt;p&gt;本地磁盘是最容易想到的方式，也是从物理机时代就一直在使用的方式。&lt;/p&gt;
&lt;p&gt;在服务器的硬盘槽上插上硬盘，并利用 HBA 卡或软件的方式制作 RAID，划分逻辑卷，格式化成某种文件系统后，挂载到容器中。&lt;/p&gt;
&lt;p&gt;由于磁盘和应用系统中间的 IO 路径最短，本地磁盘可以提供最佳的性能。同时 RAID 提供了一定程度的可靠性的保证，可以避免因单个磁盘故障而导致的数据丢失。因此，目前有大量用户采用这种方式为有状态的应用提供存储服务。&lt;/p&gt;
&lt;p&gt;然而本地磁盘方案也存在着巨大的缺陷。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，本地磁盘无法提供节点级别的高可用，当物理节点发生故障时，由于数据都存储在故障节点上，所以应用无法被恢复到其他节点。如果业务系统有节点级高可用的要求，则必须由业务系统自己实现数据层面的高可用，这极大的增加了业务系统的复杂度。&lt;/li&gt;
&lt;li&gt;其次，本地磁盘在敏捷性上也无法满足业务需求，业务使用的存储空间受限于本地磁盘的大小，如果达到磁盘空间的上限后难以扩容。部署 RAID 也是相当耗时的操作，难以实现在短时间内部署大量的应用系统。&lt;/li&gt;
&lt;li&gt;此外，该方案无论是部署还是故障后的修复，都需要大量人力的参与，这使得本地存储方案的运维成本非常高。同时由于节点间的存储空间无法共享，也很容易造成存储空间的浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总的来说，本地磁盘的方案只适合在业务容器化的初期阶段进行小规模试用，难以在大规模场景下被广泛使用。&lt;/p&gt;
&lt;h3 id=&#34;集中式存储&#34;&gt;集中式存储&lt;/h3&gt;
&lt;p&gt;集中式存储提供了可远程访问共享存储的能力。和本地磁盘的方案相比，集中式存储解决了应用系统高可用的问题，当业务系统所在的服务器发生故障时，由于数据不再存储在服务器本地，而是存储在远端的共享存储中，所以可以在其他节点上把应用拉起来，以实现业务系统的高可用。此外，由于数据集中存储，也一定程度解决了本地存储对磁盘空间浪费的问题。&lt;/p&gt;
&lt;p&gt;很多商用存储都采用集中式存储架构，除了基本的数据读写能力外，还提供了很多高级功能，包括快照、克隆、容灾等等，进一步提升业务数据的可靠性。&lt;/p&gt;
&lt;p&gt;然而集中式存储的架构决定了它不适合云原生的场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集中式存储采用存储控制器加盘柜的形式，控制器负责提供性能和存储功能，盘柜提供可扩展的存储容量。&lt;/li&gt;
&lt;li&gt;尽管集中式存储可以为单个业务系统提供较高的性能保证，但是当面临大量业务并发访问时，存储控制器则成为了性能瓶颈。如果想要满足大量业务对性能需求，需要采用多套集中式存储系统，存储系统的管理成本也会急剧上升。&lt;/li&gt;
&lt;li&gt;此外，由于集中式存储诞生在几十年前，在设计上就没有把敏捷性和运维便利性考虑进去，无法应对短时间内大量 Volume 的并发创建和销毁操作，无法满足业务系统对敏捷性的要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式存储&#34;&gt;分布式存储&lt;/h3&gt;
&lt;p&gt;分布式存储的诞生就是为了解决集中式存储无法解决的问题。&lt;/p&gt;
&lt;p&gt;分布式存储天然具有横向扩展能力，在性能和高可用方面远优于集中式存储，非常适合应对大规模虚拟化场景。与此同时，分布式存储也逐渐具备了企业级存储的能力，包括快照、克隆等等。&lt;/p&gt;
&lt;p&gt;不过，尽管分布式存储在架构上具备众多优点，但在实现难度上具备非常大的挑战，并不是所有的分布式存储都能够充分发挥出分布式架构的优势。在实际的使用过程中，大部分分布式存储的性能和稳定性都难以达到生产级别的标准，这使得很多运维团队不敢轻易地部署分布式存储产品。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/storage-in-cloud-native-era/storage-solution_hud6b7f02bafd4e043bd358d6eab1a1111_75790_aed9ad39a8c1bef7e7dfdc9fad25d9be.webp 400w,
               /blog/storage-in-cloud-native-era/storage-solution_hud6b7f02bafd4e043bd358d6eab1a1111_75790_09a662475fc887f82f85cf0370a79e80.webp 760w,
               /blog/storage-in-cloud-native-era/storage-solution_hud6b7f02bafd4e043bd358d6eab1a1111_75790_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/storage-in-cloud-native-era/storage-solution_hud6b7f02bafd4e043bd358d6eab1a1111_75790_aed9ad39a8c1bef7e7dfdc9fad25d9be.webp&#34;
               width=&#34;760&#34;
               height=&#34;190&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图 2. 不同存储方案对比&lt;/p&gt;
&lt;h2 id=&#34;云原生有状态应用对存储系统的需求&#34;&gt;云原生有状态应用对存储系统的需求&lt;/h2&gt;
&lt;p&gt;谈存储技术无法脱离应用场景。在云原生架构下，大部分业务系统不会处理数据存储的逻辑，而是尽可能将数据存储和处理能力交给数据库来完成。&lt;/p&gt;
&lt;p&gt;目前越来越多的数据库也在采用云原生架构，数据库迎来了云原生时代。云原生数据库将实例运行在容器中，具备了快速部署，快速扩容的能力。同时，云原生数据库也采用了“存算分离”的架构，将数据库计算逻辑和存储逻辑进一步进行分离，存储能力交给更专业的存储系统完成，数据库只专注在数据库的业务逻辑处理。&lt;/p&gt;
&lt;p&gt;在某种程度上讲，我们可以说云原生时代的有状态应用，大部分指的就是“云原生数据库”。接下来，我们分两种典型的数据库类型进行介绍。&lt;/p&gt;
&lt;h3 id=&#34;交易型数据库oltp&#34;&gt;交易型数据库（OLTP）&lt;/h3&gt;
&lt;p&gt;常见的 OLTP 数据库有 MySQL，PostgreSQL 等，通常承载的都是核心交易类业务，对存储系统的数据可靠性、性能要求极高。交易类业务本身对延迟非常敏感，所以存储系统的性能直接决定了 OLTP 系统能提供的能力。存储系统的带宽越高、延迟越低，OLTP 能提供的 TPS 越高。&lt;/p&gt;
&lt;p&gt;每一套业务系统通常都会有 N 套独立的 OLTP 数据库作为业务支撑。由于业务系统会频繁的进行部署以及扩容，所以支撑 OLTP 的存储系统必须具备很高的敏捷性，可以快速提供数据库对存储空间的需求，同时也要方便的进行扩容等操作。&lt;/p&gt;
&lt;p&gt;大部分 OLTP 数据库采用块存储系统作为数据存储系统，因为块存储通常可以提供最佳的性能。此外，商业块存储还提供了快照、克隆等技术，可以很好地保证数据库业务的延续性。&lt;/p&gt;
&lt;h3 id=&#34;分析型数据库olap&#34;&gt;分析型数据库（OLAP）&lt;/h3&gt;
&lt;p&gt;OLAP 数据库主要用在数据分析场景，对存储系统的可靠性以及延迟的要求都不像 OLTP 数据库那么高，且因为数据量巨大，所以对存储成本也非常敏感。&lt;/p&gt;
&lt;p&gt;为了支撑 OLAP 对存储成本的要求，存储系统通常采用 EC 技术，以降低数据存储的成本。而考虑到文件接口难以支撑百亿级别的文件数量，所以 OLAP 使用的存储系统通常采用对象接口，例如 S3 接口。&lt;/p&gt;
&lt;p&gt;OLAP 系统对敏捷性没有特殊的需求，一旦部署好后，最常见的运维操作是扩容，并不会对数据库频繁的进行重新部署和销毁操作。&lt;/p&gt;
&lt;p&gt;基于以上因素，分析型数据库通常采用支持 EC 的对象存储作为数据存储服务，通过 S3 接口访问数据。&lt;/p&gt;
&lt;h3 id=&#34;总结-1&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/storage-in-cloud-native-era/oltp-olap_hu121e44d50800f09dbc418189bbc1e113_76393_78d7d836b45d8d8cde6cfc1023d6062f.webp 400w,
               /blog/storage-in-cloud-native-era/oltp-olap_hu121e44d50800f09dbc418189bbc1e113_76393_edd0c0111e7adf6844e19160f55ec3c1.webp 760w,
               /blog/storage-in-cloud-native-era/oltp-olap_hu121e44d50800f09dbc418189bbc1e113_76393_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/storage-in-cloud-native-era/oltp-olap_hu121e44d50800f09dbc418189bbc1e113_76393_78d7d836b45d8d8cde6cfc1023d6062f.webp&#34;
               width=&#34;760&#34;
               height=&#34;147&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图 3. OLTP 和 OLAP 对存储系统的不同要求&lt;/p&gt;
&lt;h2 id=&#34;多云环境对存储系统带来的新挑战&#34;&gt;多云环境对存储系统带来的新挑战&lt;/h2&gt;
&lt;p&gt;随着云技术越来越成熟，越来越多的企业面临多云的需求：部分对数据安全不敏感且具有大量网络流量的业务需要使用公有云服务，而对数据安全性和服务稳定性要求较高的业务需要使用私有云服务。&lt;/p&gt;
&lt;p&gt;公有云和私有云在产品设计理念上完全不同，产品的使用方式、运维方式、服务质量、产品参数也完全不同。即使同样是公有云或者私有云，不同的服务提供商之间也存在着巨大差异。多云的环境，对企业的运维团队提出了巨大的挑战。&lt;/p&gt;
&lt;p&gt;而云原生架构的诞生，就是为了应对多云的挑战：开发者在设计云原生应用时，只需要关注应用被如何创建和部署，无需关注在哪里运行。&lt;/p&gt;
&lt;p&gt;然而尽管目前有相当多的开发者采用了云原生的架构设计应用系统，但是对于基础架构软件来说，目前还是由不同的云厂商来提供。基础架构的运维人员需要为不同服务商提供的存储系统，准备不同的运维方式，这极大的增加了运维人员的负担。&lt;/p&gt;
&lt;p&gt;由此也诞生一个新的存储系统类别：云原生存储系统。云原生存储系统可以良好的运行在各种不同服务商提供的公有云环境或私有云环境，并且为运维人员提供相同接口和运维方式。云原生存储系统可以极大的降低运维团队的负担。&lt;/p&gt;
&lt;h3 id=&#34;云原生存储有什么不同&#34;&gt;云原生存储有什么不同&lt;/h3&gt;
&lt;p&gt;此处我们以 IOMesh 的架构图作为示例，说明云原生存储的特点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/storage-in-cloud-native-era/iomesh-arch_hufd1ae576ae0b17aba4c7b4af3c97f523_263207_f821e8b5bf3852e035f2d505768f40d4.webp 400w,
               /blog/storage-in-cloud-native-era/iomesh-arch_hufd1ae576ae0b17aba4c7b4af3c97f523_263207_6c433ae553ccf0fcb783a1a8e883b8f1.webp 760w,
               /blog/storage-in-cloud-native-era/iomesh-arch_hufd1ae576ae0b17aba4c7b4af3c97f523_263207_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/storage-in-cloud-native-era/iomesh-arch_hufd1ae576ae0b17aba4c7b4af3c97f523_263207_f821e8b5bf3852e035f2d505768f40d4.webp&#34;
               width=&#34;760&#34;
               height=&#34;632&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图 4. IOMesh 产品架构图&lt;/p&gt;
&lt;p&gt;云原生存储不仅仅可以做到支持在公有云和私有云运行，而且提供了容器化部署、自动运维、声明式接口等特征，让用户可以采用和运维其他云原生应用一样的方式对存储系统进行部署、运维和管理。&lt;/p&gt;
&lt;p&gt;除此之外，云原生存储还需要能够很好地和其他云原生基础设施配合，例如云原生数据库，使得云原生数据库可以真正的在公有云和私有云都能够得到一致的用户体验。&lt;/p&gt;
&lt;h2 id=&#34;如何选择云原生存储&#34;&gt;如何选择云原生存储&lt;/h2&gt;
&lt;p&gt;云原生存储也是存储系统，所以存储系统所必备的可靠性，性能，高可用等等特点都是必不可少的。&lt;/p&gt;
&lt;p&gt;除此之外，“云原生”对存储系统提出了更高的要求。&lt;/p&gt;
&lt;h3 id=&#34;尽量减少环境依赖&#34;&gt;尽量减少环境依赖&lt;/h3&gt;
&lt;p&gt;云原生存储系统应尽量不对软硬件环境存在任何依赖，例如对内核的依赖，对特定的网络设备和磁盘型号的依赖等等。只有尽量少的依赖，才能够做到最大的适配性。&lt;/p&gt;
&lt;h3 id=&#34;避免资源消耗过高&#34;&gt;避免资源消耗过高&lt;/h3&gt;
&lt;p&gt;云原生存储系统以容器的形式和业务系统混合部署在容器平台上。如果存储系统占用过多的计算资源（CPU、内存），则会导致整体投入成本太高。&lt;/p&gt;
&lt;h3 id=&#34;声明式运维方式&#34;&gt;声明式运维方式&lt;/h3&gt;
&lt;p&gt;存储系统应支持通过声明式的接口进行运维管理，同时支持一定程度的自动化运维，包括在线扩容、升级等等。当发生硬件故障时，存储服务可以自动恢复，以保证业务系统不受影响。&lt;/p&gt;
&lt;h3 id=&#34;云原生生态&#34;&gt;云原生生态&lt;/h3&gt;
&lt;p&gt;云原生存储系统应该可以很好地和云原生的运维生态系统结合，包括监控、报警、日志处理等待。&lt;/p&gt;
&lt;h2 id=&#34;云原生存储系统的性能对比&#34;&gt;云原生存储系统的性能对比&lt;/h2&gt;
&lt;p&gt;性能是评判存储系统是否能够支撑核心业务的关键指标。本文将对 4 个常见的云原生存储系统，IOMesh、Longhorn、Portworx、OpenEBS，的性能测试结果进行对比。&lt;/p&gt;
&lt;p&gt;我们准备了三个 Worker 节点作为运行应用和云原生存储的节点，每个节点配备了两块 SATA SSD，四块 SATA HDD，以及万兆网卡。&lt;/p&gt;
&lt;p&gt;在测试中，我们采用最常见的 MySQL 数据库作为有状态应用，并使用 sysbench-tpcc 模拟业务负载。下表提供了四个云原生存储系统在 TPC-C MySQL 测试中的 TPS、QPS 以及 P95 延迟数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/storage-in-cloud-native-era/tpcc-mysql-test-data1_hud244ce5d02ecf298d4a61efb6d66dc6c_142728_2ebefad81adb7a16fb6db71987d3a79b.webp 400w,
               /blog/storage-in-cloud-native-era/tpcc-mysql-test-data1_hud244ce5d02ecf298d4a61efb6d66dc6c_142728_3b53b99f24c6d07b1709d2b1fdd786e8.webp 760w,
               /blog/storage-in-cloud-native-era/tpcc-mysql-test-data1_hud244ce5d02ecf298d4a61efb6d66dc6c_142728_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/storage-in-cloud-native-era/tpcc-mysql-test-data1_hud244ce5d02ecf298d4a61efb6d66dc6c_142728_2ebefad81adb7a16fb6db71987d3a79b.webp&#34;
               width=&#34;760&#34;
               height=&#34;242&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图 5. TPC-C MySQL 综合性能测试&lt;/p&gt;
&lt;p&gt;下图对比了四个云原生存储系统的性能测试结果。图中横轴代表测试时间，纵轴分别代表：TPS、QPS、以及 P95 延迟的瞬时值。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/storage-in-cloud-native-era/tpcc-mysql-test-data2_hu1b6880fd8572a2562530770515e159ee_203457_7c6bed966fe55f6f7dc1f9a9882811b1.webp 400w,
               /blog/storage-in-cloud-native-era/tpcc-mysql-test-data2_hu1b6880fd8572a2562530770515e159ee_203457_0562ea993500e83b8a40a938837bbeea.webp 760w,
               /blog/storage-in-cloud-native-era/tpcc-mysql-test-data2_hu1b6880fd8572a2562530770515e159ee_203457_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/storage-in-cloud-native-era/tpcc-mysql-test-data2_hu1b6880fd8572a2562530770515e159ee_203457_7c6bed966fe55f6f7dc1f9a9882811b1.webp&#34;
               width=&#34;760&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;图 6. TPC-C MySQL 性能稳定性测试&lt;/p&gt;
&lt;p&gt;从以上数据与对比可以明显地看出，IOMesh 在绝对性能，以及性能的稳定性上，都遥遥领先于其他的云原生存储系统，具备为核心生产系统提供存储支撑的能力。&lt;/p&gt;
&lt;h2 id=&#34;总结-2&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;随着云原生时代的到来，越来越多的业务系统会采用云原生架构。存储系统作为承载业务稳定运行的核心组件，在云原生的架构下，也面临着新的挑战。与此同时，数据库以及存储系统自身也受到了云原生架构的影响，逐渐发展出云原生数据库和云原生存储系统。未来可以看到越来越多的云原生数据库和云原生存储出现在数据中心中，成为被广泛使用的技术。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生关乎文化，而不是容器</title>
      <link>https://cloudnative.to/blog/cloud-native-culture-not-container/</link>
      <pubDate>Thu, 18 Mar 2021 11:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-culture-not-container/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://www.infoq.com/articles/cloud-native-culture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud-Native Is about Culture, Not Containers&lt;/a&gt;，文章洋洋洒洒上万字，作者总结了她见过的云原生失败的各种经验教训，还用生动的示例说明了什么不是云原生。译者是在周末闲暇时间仓促间翻译的，其中难免有不当之处，请读者指正。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文主要观点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要一味的微服务，就可以做到非常的云原生。&lt;/li&gt;
&lt;li&gt;在开始云原生转型之前，必须明确云原生对你的团队意味着什么，以及要解决的真正问题是什么。&lt;/li&gt;
&lt;li&gt;如果发布涉及繁琐的仪式，不经常发布，而且所有的微服务都必须同时发布，那么微服务架构的好处将无法得到落实。&lt;/li&gt;
&lt;li&gt;持续集成和部署是你要做的事情，而不是你买的工具。&lt;/li&gt;
&lt;li&gt;过度的治理扼杀了云的效率，但如果你对消耗的东西不够重视，就会造成严重的浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在去年的伦敦 QCon 大会上，我提供了一个关于文化而非容器的云原生会议。让我开始思考文化在云原生中的作用的是 &lt;a href=&#34;https://www.infoq.com/articles/microservices-post-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bilgin Ibryam&lt;/a&gt; 一篇很棒的 &lt;a href=&#34;https://www.infoq.com/articles/microservices-post-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfoQ 文章&lt;/a&gt;。Bilgin 做的其中一件事是将云原生架构定义为很多微服务，通过智能管道连接。我看了之后，觉得它看起来完全不像我写的应用，尽管我认为我在写云原生应用。我是 IBM Garage 的一员，帮助客户实现云原生，然而我很少在我的应用中使用微服务。我创建的应用大多看起来和 Bilgin 的图完全不一样。这是否意味着我做错了，或者说云原生的定义可能有点复杂？&lt;/p&gt;
&lt;p&gt;我不想把 Bilgin 单列出来，因为 Bilgin 的文章叫《后 Kubernetes 时代的微服务》，所以如果他在那篇文章中不是经常说到微服务，那就有点可笑了。事实也是如此，几乎所有关于云原生的定义都把它等同于微服务。无论在哪里，我都不断看到这样的假设：微服务等于云原生，云原生等于微服务。就连云原生计算基金会（CNCF）也曾经把云原生定义为：都是微服务，都是容器，还有一点动态编排在里面。说云原生并不总是涉及微服务，这让我陷入了这个特殊的境地，因为我不仅说 Bilgin 错了，我还说云原生计算基金会错了 —— 他们对云原生了解过什么？我相信我知道的比他们多得多吧？&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-img&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;img&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_huc8e9e7f9f9c3c3dc6b6f64996b523f44_41834_8c051129f84acbba85d9dd1a3330ff5a.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_huc8e9e7f9f9c3c3dc6b6f64996b523f44_41834_b440c03368fc8e4117c92dd9864f184f.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_huc8e9e7f9f9c3c3dc6b6f64996b523f44_41834_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8ezatuj318q0u0dhn_huc8e9e7f9f9c3c3dc6b6f64996b523f44_41834_8c051129f84acbba85d9dd1a3330ff5a.webp&#34;
               width=&#34;760&#34;
               height=&#34;510&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      img
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;显然我不知道在这个问题上，我站在了历史的错误一边。我承认这一点。虽然我站错了历史的一边，但我注意到 CNCF 已经更新了他们对云原生的定义，虽然微服务和容器仍然存在，但它们似乎不像以前那样必须，所以这一点历史可能在我这边！）。不管对不对，我还是要死在我的小山头上，那个 Cloud Native 是关于比微服务更大的东西。微服务是一种方式。它们不是唯一的方式。&lt;/p&gt;
&lt;p&gt;事实上，在我们的社区中，你确实看到了一系列的定义。如果你问一堆人 Cloud Native 是什么意思，有些人会说 &amp;ldquo;生长在云上&amp;rdquo;。这是非常原始的 Cloud Native 定义，早在微服务还没有出现的时候就已经有了。有人会说这是微服务。&lt;/p&gt;
&lt;p&gt;有人会说，&amp;ldquo;哦，不对，不只是微服务，是 Kubernetes 上的微服务，这样才有 Cloud Native&amp;rdquo;。这个我不喜欢，因为在我看来，Cloud Native 不应该是一个技术选择的问题。有时候我看到 Cloud Native 被当做 DevOps 的同义词，因为很多云原生的原则和实践和 DevOps 教的东西很相似。&lt;/p&gt;
&lt;p&gt;有时，我看到云原生的用法只是作为一种说 &amp;ldquo;我们正在开发现代软件&amp;rdquo; 的方式。&amp;ldquo;我们将使用最佳实践；它将是可观察的；它将是健壮的；我们将经常发布，并使一切自动化；简而言之，我们将采用过去 20 年所学到的一切，并以这种方式开发软件，这就是云原生的原因&amp;rdquo;。在这个定义中，云只是一种必然 —— 当然是在云上，因为我们是在 2021 年开发的。&lt;/p&gt;
&lt;p&gt;有时候我看到 Cloud Native 只是用来指云。我们听惯了 Cloud Native，以至于每次说到 Cloud 的时候，都觉得要在后面加上一个 &amp;ldquo;Native&amp;rdquo;，但其实我们只是在说 Cloud。最后，当人们说 Cloud Native 的时候，有时候他们的意思是 idempotent（幂等的）。这个问题是，如果你说 Cloud Native 的意思是 idempotent，其他人就会说：&amp;quot; 什么？我们说的 idempotent 真正的意思是可复用？如果我把它拿去，把它关了，然后再启动，运行结果跟之前也是一样的。这是对云上服务的一个基本要求。”&lt;/p&gt;
&lt;p&gt;有了这些不同的定义，难怪我们在做 Cloud Native 的时候，并不能完全确定我们要做的是什么。&lt;/p&gt;
&lt;h2 id=&#34;为什么&#34;&gt;为什么？&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;我们到底想实现什么？&amp;rdquo; 这是一个非常重要的问题。当我们在思考技术选择和技术风格的时候，我们要从 &amp;ldquo;我做 Cloud Native 是因为别人都在做退到思考我到底想解决什么问题？&amp;rdquo; 为了公平对待 CNCF，他们在对云原生的定义前面就有这个 &amp;ldquo;为什么&amp;rdquo;。他们说：&amp;quot; 云原生就是使用微服务来更快地构建伟大的产品。我们使用微服务不仅仅是因为我们想使用，我们使用微服务是因为微服务帮助我们更快地构建伟大的产品。”&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_hudc24ecc3933f094c1c33c53db28b438f_23618_3936e8010ebac889d061bc8172cd1221.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_hudc24ecc3933f094c1c33c53db28b438f_23618_c493b133882fe5985e75c8891dedef5e.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_hudc24ecc3933f094c1c33c53db28b438f_23618_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8erg3vj30pw0mz0t3_hudc24ecc3933f094c1c33c53db28b438f_23618_3936e8010ebac889d061bc8172cd1221.webp&#34;
               width=&#34;760&#34;
               height=&#34;674&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们退一步确保我们理解要解决的问题。为什么我们之前不能更快地打造出优秀的产品？很容易跳过这一步，我想我们所有人有时候都会犯这样的毛病。有时候我们真正要解决的问题是，别人都在做，所以我们害怕错过，除非我们开始做。一旦我们这样说，FOMO（错失恐惧症）就不是一个很好的决策标准。更糟糕的是，&amp;ldquo;我的简历看起来很沉闷&amp;rdquo; 绝对不是选择技术的正确理由。&lt;/p&gt;
&lt;h2 id=&#34;为什么是云&#34;&gt;为什么是云？&lt;/h2&gt;
&lt;p&gt;我认为要想知道为什么我们应该以云原生的方式来做事情；我们要退一步说：&amp;ldquo;为什么我们在云上做事情？&amp;rdquo; 以下是原因。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;成本&lt;/strong&gt;：当我们刚开始把东西放在云上的时候，价格是主要的动机。我们说：&amp;ldquo;我有这个数据中心，我必须支付电费，我必须支付人员维护它。而且我必须购买所有的硬件。当我可以使用别人的数据中心时，我为什么要这么做呢？&amp;rdquo; 在自己的数据中心和别人的数据中心之间形成成本节约的原因是，自己的数据中心必须为最大需求储备足够的硬件。这有可能是大量的容量，而这些容量在大部分时间是没有使用的。如果是别人的数据中心，你可以集中资源。当需求低迷时，你不会为额外的容量付费。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;弹性&lt;/strong&gt;。云计算为你省钱的原因就是因为它的弹性。你可以扩大规模；你可以缩小规模。当然，这已经是旧闻了。我们都认为弹性是理所当然的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;速度&lt;/strong&gt;：我们现在之所以对云感兴趣，是因为速度。不一定是硬件的速度，虽然有些云硬件的速度可以快得让人眼花缭乱。云是使用 GPU 的一个很好的方式，这多少也是使用量子计算机的唯一方式。不过，更普遍的是，我们可以通过云端将一些东西以某种方式、某种方式更快地推向市场，这比我们不得不将软件打印到光盘上，然后邮寄给人们，甚至比我们不得不在自己的数据中心站立实例的时候还要快。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-因素&#34;&gt;12 因素&lt;/h2&gt;
&lt;p&gt;节约成本、弹性和交付速度都很好，但我们只要在云端就能得到这些。为什么我们需要云原生？我们需要云原生的原因是，很多公司发现他们试图上云，结果被电死了。&lt;/p&gt;
&lt;p&gt;事实证明，云上的东西需要用不同的方式来编写和管理。把这些不同的地方阐述出来，就形成了 12 因素。这 12 个因素是对你应该如何编写云应用的一系列规定，这样你就不会被电死。&lt;/p&gt;
&lt;p&gt;你可以说这 12 个因素描述了如何编写云原生应用 —— 但这 12 个因素与微服务完全没有关系。它们都是关于你如何管理应用的状态。它们是关于如何管理你的日志。12 个因素帮助应用程序变得幂等化，但 &amp;ldquo;12 因素&amp;rdquo; 比 &amp;ldquo;幂等化因素&amp;rdquo; 更吸引人。&lt;/p&gt;
&lt;p&gt;这 12 个因素是在 Docker 进入市场前两年发布的。Docker 容器彻底改变了云的使用方式。容器如此之好，很难夸大其重要性。它们解决了很多问题，创造了新的架构可能性。因为容器是如此的简单，所以可以将一个应用分布在许多容器上。有些公司在 100、200、300、400 或 500 个不同的容器上运行单个应用。与这样的工程实力相比，一个应用如果仅仅分布在 6 个容器上，似乎有点不够用。面对如此少的复杂性，人们很容易想到 &amp;ldquo;我一定是做错了。我还不如那边的开发者呢&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_hue228d1d4931f6fc07738495f3bdf2f2f_70368_9bf1e63da77ac1cf54b66bb9fd7d4dc4.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_hue228d1d4931f6fc07738495f3bdf2f2f_70368_871064dcc79b19c67c5d4b9183bc272e.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_hue228d1d4931f6fc07738495f3bdf2f2f_70368_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8fyo7yj316p0u0q61_hue228d1d4931f6fc07738495f3bdf2f2f_70368_9bf1e63da77ac1cf54b66bb9fd7d4dc4.webp&#34;
               width=&#34;760&#34;
               height=&#34;534&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;事实上，这不是比拼你能拥有多少个容器。容器是很好的，但你拥有的容器数量应该根据你的需求进行调整。&lt;/p&gt;
&lt;h2 id=&#34;速度&#34;&gt;速度&lt;/h2&gt;
&lt;p&gt;让我们试着回忆一下 —— 你的需求又是什么？当我们想到云的时候，我们通常要考虑的是速度。我们之所以想要大量的容器，是因为我们想要更快地将新的东西推向市场。如果我们有很多容器，我们要么把完全一样的东西推向市场，要么以同样的速度推向市场，那么突然之间，这些容器只是一种成本。它们并没有帮助我们，我们正在消耗周期来管理将应用分散在基础设施上的小块应用所带来的复杂性。如果我们有这个神奇的架构，可以让我们对市场做出反应，但我们没有做出反应，那就是一种浪费。如果我们有这个架构，意味着我们可以快速发展，但是我们没有快速发展，那么这也是一种浪费。&lt;/p&gt;
&lt;h2 id=&#34;如何在云原生中失败&#34;&gt;如何在云原生中失败&lt;/h2&gt;
&lt;p&gt;这让我想到了如何在云原生中失败。关于我的背景，我是一个顾问。我是 IBM Garage 的全栈开发人员。我们与初创公司和大公司合作，帮助他们上云，并从云中获得最大的好处。作为其中的一部分，我们帮助他们解决有趣的、艰难的问题，我们帮助他们以比以前更快的速度做软件。为了确保我们真的能从云端获得最大的收益，我们做了精益创业、极限编程、设计思维、DevOps；以及云原生。因为我是一个顾问，所以我看到很多客户都在云计算的旅程中。有时候很顺利，有时候也会有这些陷阱。以下是我看到聪明的客户掉进的一些陷阱。那么，什么是云原生？&lt;/p&gt;
&lt;p&gt;最早的一个陷阱就是关于云原生的意思。如果我说云原生，我是一个意思，而你说云原生，又是另一个意思，我们的沟通就会有问题&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;有时候这并不重要，但有时候却有很大的不同。如果一个人认为目标是微服务，然后另一个人觉得目标是拥有一个幂等的系统，呃哦。或者说，如果一个组织的一部分人想上云，因为他们认为云可以让他们更快地进入市场，但另一部分人上云只是为了和以前完全一样的速度，但更具成本效益，那么我们可能会在以后的道路上发生一些冲突。&lt;/p&gt;
&lt;h2 id=&#34;微服务环境&#34;&gt;微服务环境&lt;/h2&gt;
&lt;p&gt;通常情况下，促使人们对目标产生一些困惑的原因之一是，我们有一种自然的倾向，即看到其他人做着奇妙的事情，并想效仿他们。我们想自己去做那些奇妙的事情，而没有真正思考我们的环境和它们是否适合。我们的一位 IBM 研究员在去和客户谈微服务的时候，有一个启发式的方法。他说：&amp;ldquo;如果他们开始谈论 Netflix，而他们只是一直在谈论 Netflix，他们从来没有提到连贯性，也没有提到耦合，那么可能他们做这件事的原因并不正确。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;有时候我们和客户聊天，他们说：&amp;ldquo;对，我想现代化到微服务。&amp;rdquo; 好吧，微服务不是目标。没有客户会看着你的网站说，&amp;ldquo;哦，微服务。这很好。&amp;rdquo; 客户会看你的网站，并根据它是否满足他们的需求，是否简单和令人愉快，以及，所有这些其他事情来判断它。微服务可以是达到这个目的的一个很好的手段，但它们本身并不是一个目标。我还应该说：微服务是一种手段。它们不一定是实现这一目标的唯一手段。&lt;/p&gt;
&lt;p&gt;我在 IBM Garage 的一位同事与亚太地区的一家银行进行了一些对话。这家银行在响应客户时遇到了问题，因为他们的软件都很老旧、沉重和钙化。他们也遇到了人员问题，因为他们所有的 COBOL 开发人员都老了，而且都要离开工作岗位。因此，银行知道他们必须进行现代化改造。在这个案例中，主要的驱动力不是劳动力的老化，而是竞争力和灵活性。他们被竞争对手打败了，因为他们拥有大量的 COBOL 代码，而每次改变都是昂贵而缓慢的。他们说：&amp;ldquo;好吧，为了解决这个问题，我们需要摆脱所有的 COBOL，我们需要切换到现代微服务架构。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;到目前为止，还不错。我们正准备跳进一些云原生的好东西时，银行又说他们的发布板一年只开两次会。这时，我们又收手了。不管银行的新架构会有多少微服务，这些微服务都会被组装成一个大的单体发布包，每年部署两次。这就是拿了微服务的开销，却没有好处。因为这不是一场看你有多少容器的比赛，大量的容器和缓慢的发布将是一个绝对没有人赢的堆栈。&lt;/p&gt;
&lt;p&gt;大量的微服务被锁定在一个迟缓的发布节奏中，不仅不会是一种胜利，还可能是一种糟糕的损失。当组织尝试微服务时，他们并不总是像图片中的那样，最终得到一个美丽的解耦微服务架构。相反，他们最终得到的是一个分布式单体。这就像一个普通的单体，但要糟糕得多。之所以说这是格外可怕的坏事，是因为一个正常的、非分布式的单体有诸如编译时检查类型和同步的、有保证的内部通信。在单进程中运行会损害你的可扩展性，但这意味着你不能被分布式计算的谬误所困扰。如果你把同样的应用程序，然后只是在互联网上涂抹，不投入任何类型检查或投资于网络问题的错误处理，你不会有更好的客户体验，你会有更糟糕的客户体验。&lt;/p&gt;
&lt;p&gt;在很多情况下，微服务是错误的答案。如果你是一个小团队，你不需要有很多自主的团队，因为每个独立的团队会有大约四分之一的人。假设你没有任何计划，也不希望独立发布部分应用，那么你不会从微服务的独立性中获益。&lt;/p&gt;
&lt;p&gt;为了在你的应用程序的所有这些组件之间提供安全和可靠的通信和可发现性，你刚刚抹过云的一部分，你将需要类似服务网格的东西。你可能在技术曲线上很先进，或者对这个技术曲线有点陌生。你要么不知道服务网格是什么，要么你说：&amp;ldquo;我都知道服务网格是什么。那么复杂，那么夸张。我不需要服务网格。我只想自己搞一个服务网格。&amp;rdquo; 这不一定会给你带来你所希望的结果。你最终还是会得到一个服务网格，但你必须维护它，因为它是你写的！不做微服务的另一个很好的理由是，有时候领域模型就是没有那些天然的断裂点，让你得到漂亮整洁的微服务。在这种情况下，完全有理由说：&amp;ldquo;你知道吗？我就不做了。&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;云原生面条&#34;&gt;云原生面条&lt;/h2&gt;
&lt;p&gt;如果你不从杂乱中走出来，那么你最终会遇到下一个问题，那就是云原生面条。当我看 Netflix 微服务的通信图时，我总觉得有些恐慌。我确信他们知道自己在做什么，而且他们已经想好了，但在我眼里，它看起来完全像意大利面条。让它发挥作用需要很多真正扎实的工程和专门的技能。如果你不具备这种专业性，那么你最终会陷入混乱的局面。&lt;/p&gt;
&lt;p&gt;我被邀请去给一个正在苦苦挣扎的客户做一些支持工作。他们正在开发一个绿地应用，所以他们当然选择了微服务，以尽可能的现代化。他们对我说的第一句话就是：&amp;ldquo;只要我们修改任何代码，其他的东西就会坏掉。&amp;rdquo; 这不是微服务应该发生的事情。事实上，这与我们都被告知如果我们实现微服务会发生的情况完全相反。微服务的梦想是它们是解耦的。遗憾的是，解耦并不是免费的。它当然不会因为你分布式的东西而神奇地发生。当你分布式的东西时，所发生的是你有两个问题而不是一个问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hua99026d7618db83c719668a53fdf5c4b_35607_43213462d1d68b70ced685f6702c1d0a.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hua99026d7618db83c719668a53fdf5c4b_35607_0d0682530e9e5b265df013437c42818a.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hua99026d7618db83c719668a53fdf5c4b_35607_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8brcb6j315h0u0ta7_hua99026d7618db83c719668a53fdf5c4b_35607_43213462d1d68b70ced685f6702c1d0a.webp&#34;
               width=&#34;760&#34;
               height=&#34;549&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生面条还是面条。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的客户的代码之所以这么脆弱，耦合性这么强，其中一个原因是他们的对象模型相当复杂，大约有 20 个类，部分类中有 70 个字段。在微服务系统中处理这种复杂的对象模型是很难的。在这种情况下，他们看了看他们复杂的对象模型，决定：&amp;ldquo;我们知道在我们的微服务之间有共同的代码是非常不好的，因为这样我们就没有解耦。相反，我们要在我们所有的六个微服务中复制和粘贴这个共同的对象模型。因为我们剪切和粘贴它，而不是链接到它，所以我们是解耦的。&amp;rdquo; 嗯，不，你不是解耦的。如果当一件事情发生变化的时候，不管是链接还是复制代码，事情就会中断，这就是耦合。&lt;/p&gt;
&lt;p&gt;在这种情况下，什么是 &amp;ldquo;正确&amp;rdquo; 的做法？在理想的情况下，每个微服务都会整齐地映射到一个域上，而且它们很有区别。如果你有一个大域和很多微小的微服务，那就会有问题了。解决的办法是，要么决定领域真的很大，然后合并微服务，要么做更深层次的领域建模，尝试把对象模型解开，变成不同的边界上下文。&lt;/p&gt;
&lt;p&gt;即使是最干净的域分离，在任何系统中，组件之间总会有一些接触点 —— 这才是系统的本质。这些接触点很容易出错，即使它们是最小的，尤其是当它们是隐藏的。你还记得 &amp;ldquo;火星气候轨道器&amp;rdquo; 吗？与 &amp;ldquo;毅力号&amp;rdquo; 不同的是，它被设计为在安全距离内绕着火星运行，而不是在火星上着陆。遗憾的是，它离火星太近了，被火星的引力拉了进去，然后坠毁了。探测器的失利令人惋惜，根本原因就是个悲剧。轨道器由两个模块控制，一个是探测器，一个是地球上的模块。探测模块是半自主的，因为从地球上大部分时间看不到轨道器。大约每隔三天，行星就会对准，它就会出现在视野中，地球上的团队就会微调它的运行轨迹我猜想当时的指令是这样的：&amp;ldquo;哦，我想你需要向左移动一点，哦，如果你不向右移动一点，你就会错过火星。&amp;rdquo; 除了数字。&lt;/p&gt;
&lt;p&gt;数字是导致问题的原因。地球模块和探测模块是由两个不同的团队建造的两个不同的系统。探测器使用的是英制单位，而 JPL 地面团队使用的是公制单位。尽管这两个系统看起来是独立的，但它们之间有一个非常重要的耦合点。每次地面团队传送指令时，他们发送的指令都会以一种谁也想不到的方式进行解释。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu5f71c6c37ba4e47cf77393bbf0c686cf_36805_80c5f622814ec1e0d26c75c3648f223c.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu5f71c6c37ba4e47cf77393bbf0c686cf_36805_f12c8e72833ae9ea7cc3bc40a8430606.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu5f71c6c37ba4e47cf77393bbf0c686cf_36805_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8auha4j31460u0myk_hu5f71c6c37ba4e47cf77393bbf0c686cf_36805_80c5f622814ec1e0d26c75c3648f223c.webp&#34;
               width=&#34;760&#34;
               height=&#34;568&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个故事的寓意是，分布式系统没有帮助。一部分系统在火星上，一部分系统在地球上，你不能比这更分散。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;微服务需要消费者驱动的接触测试&#34;&gt;微服务需要消费者驱动的接触测试&lt;/h2&gt;
&lt;p&gt;在这种情况下，解决方案，正确的做法是真正明确耦合点是什么，双方各自的期望值是什么。一个很好的方法就是消费者协议驱动的测试（Contract-driven Test）。尽管接触测试（Contract Test）是解决一个大问题的干净利落的办法，但在我们这个行业还没有被广泛使用。我认为部分问题是，它们可能有点棘手，难以学习，这减缓了采用的速度。关于测试的跨团队谈判也会很复杂 —— 尽管如果关于测试的谈判太难，关于实际交互参数的谈判会更难。如果你正在考虑探索接触测试，Spring Contract 或 Pact 是不错的起点。哪一个适合你，取决于你的环境。Spring Contract 很好地集成到了 Spring 生态系统中，而 Pact 是框架无关的，并且支持大量的语言，包括 Java 和 Javascript。&lt;/p&gt;
&lt;p&gt;接触测试远远超出了 OpenAPI 验证的作用，因为它检查的是 API 的语义，而不仅仅是语法。它比 &amp;ldquo;好吧，两边的字段都有相同的名字，所以我们很好。&amp;rdquo; 这是个更有用的检查，它允许你检查，&amp;ldquo;当我得到这些输入时，我的行为是否是预期的行为？我在那边命名的关于那个 API 的假设是否仍然有效？&amp;rdquo; 这些都是你需要检查的东西，因为如果它们不是真的，事情就会变得非常糟糕。&lt;/p&gt;
&lt;p&gt;很多公司都意识到了这个风险，也意识到做微服务的时候系统有不稳定的地方。为了有信心这些东西能一起工作，他们在发布之前会施加一个 UAT 阶段。在任何微服务发布之前，需要有人花几周时间测试它在更广泛的系统中是否正常工作。有了这样的开销，发布不会经常发生。那么这就引出了经典的反模式，那就是不连续的持续集成和持续部署，或者说 I/D。&lt;/p&gt;
&lt;h3 id=&#34;为什么持续集成而不持续部署&#34;&gt;为什么持续集成而不持续部署&lt;/h3&gt;
&lt;p&gt;我和很多客户交流，他们会说：&amp;ldquo;我们有一个 CI/CD。&amp;rdquo; 这给我们敲响了警钟，因为 CI/CD，不应该是你买了一个工具，放在服务器上，然后欣赏，说 &amp;ldquo;有 CI/CD。&amp;ldquo;CD/CD 是你必须要做的事情。这两个字母分别代表持续集成和持续部署或交付。连续在这里意味着 &amp;ldquo;真的经常集成&amp;rdquo; 和 &amp;ldquo;真的经常部署&amp;rdquo;，如果你没有做到这一点，那么根本就不是连续。&lt;/p&gt;
&lt;p&gt;有时候我会无意中听到这样的评论：&amp;ldquo;下周我就把我的分支合并到我们的 CI 系统中&amp;rdquo;。这完全忽略了 &amp;ldquo;CI&amp;rdquo; 中的 &amp;ldquo;C&amp;rdquo;，它代表的是持续。如果你每周合并一次，那就不是连续。这几乎是连续的反义词。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;D&amp;rdquo; 部分可能会更加困难。如果软件每半年才部署一次，CI/CD 服务器可能很有用，但是没有人做 CD。可能有 &amp;ldquo;D&amp;rdquo;，但大家都忘记了 &amp;ldquo;C&amp;rdquo; 的部分。&lt;/p&gt;
&lt;p&gt;到底多长时间推送一次才是合理的？连续性得有多连续？甚至我也承认，一些严格定义的连续会是一个团队中写软件的可笑方式。如果你把每一个角色都推到 main，这在技术上是连续的，但它会在团队中造成混乱。如果你每次提交都集成，并且目标是每小时提交几次，这可能是一个很好的节奏。如果你经常提交，每隔几次提交就集成一次，那么你每天推送几次，这样也是很好的。如果你做的是测试驱动的开发，那么当你得到一个合格的测试时，集成是一个很好的模式。我很提倡基于主干的开发（TBD）。TBD 在调试、实现机会主义重构、避免同事出现大的意外等方面有很多好处。基于主干的开发的技术定义是，你需要每天至少集成一次才算。我有时会听到 &amp;ldquo;每天一次&amp;rdquo; 被描述为 &amp;ldquo;还好&amp;rdquo; 和 &amp;ldquo;就是不连续&amp;rdquo; 之类的。一周一次就真的很成问题了。&lt;/p&gt;
&lt;p&gt;一旦你每个月一次，那就太可怕了。当我加入 IBM 的时候，我们用的是一个构建系统和一个代码仓库，叫 CMVC。对于背景来说，这大概是二十年前的事情，我们整个行业都比较年轻，比较愚蠢。我在 IBM 的第一份工作是帮助构建 WebSphere 应用服务器。我们有一个大型的多站点构建，团队每周有六天开会，包括周六，讨论任何构建失败的问题。那个电话有很多重点，你不希望在 WebSphere 构建电话中被叫起来。我刚从大学毕业，对团队中的软件开发一窍不通，所以一些资深的开发人员把我收在了他们的手下。我至今还记得的一个建议是，避免被 WebSphere 构建调用的方法是将你所有的修改在本地机器上保存半年，然后全部批量推送。&lt;/p&gt;
&lt;p&gt;在这个项目上，我还小，我想，好吧，这似乎不是很正确的建议，但我想你最清楚。事后看来，我意识到 WebSphere 的构建破坏得很严重，因为人们将他们的变化保存了六个月，然后才试图与他们的同事进行整合。很明显，那是行不通的，我们改变了做事的方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_hu0bf9fa706e2a9059ff6e8c97f4fefb6b_30773_86e61329433ac7af2cb3d07eab6d8c41.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_hu0bf9fa706e2a9059ff6e8c97f4fefb6b_30773_0e372ae23d98c76f07aefc43eeed600a.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_hu0bf9fa706e2a9059ff6e8c97f4fefb6b_30773_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8b81awj31bk0u0myq_hu0bf9fa706e2a9059ff6e8c97f4fefb6b_30773_86e61329433ac7af2cb3d07eab6d8c41.webp&#34;
               width=&#34;760&#34;
               height=&#34;480&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你应该多久整合一次？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下一个更难的问题是，你应该多久发布一次？和集成一样，有一个合理的选择范围。你可以每次推送都发布。许多技术公司都这样做。如果你每次迭代部署一次，你还是很有优势的。一个季度发布一次就有点悲哀了。你可以每两年发布一次。现在看来慢得荒唐，但在糟糕的过去，这是我们行业的标准模式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hud35b16ada54f78a3a593c88e70907bc6_23853_7678155a0905b9b0c098f5a387faaf2b.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hud35b16ada54f78a3a593c88e70907bc6_23853_30c1d862200f0de3838649f84ca45e3b.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hud35b16ada54f78a3a593c88e70907bc6_23853_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8c9crij31m70u0abo_hud35b16ada54f78a3a593c88e70907bc6_23853_7678155a0905b9b0c098f5a387faaf2b.webp&#34;
               width=&#34;760&#34;
               height=&#34;392&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多久应该部署到生产中一次？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之所以每次推送都能部署到生产中，是因为部署不等于发布。如果我们的新代码太不完整或者太吓人，无法真正展示给用户，我们仍然可以部署它，但要把它隐藏起来。我们可以让代码实际存在于生产代码库中，但没有任何东西与之相连。这样就很安全了。如果我们已经有点太纠结了，我们可以使用功能标志来翻开和关闭功能。如果我们感觉更冒险，我们可以做 A/B 或亲朋好友测试，这样只有一小部分用户看到我们可怕的代码。金丝雀部署是另一种变化，用于预先检测噩梦，在它们进入主流使用之前。&lt;/p&gt;
&lt;p&gt;不发布有两个不好的后果。它延长了反馈周期，这会影响决策，并使工程师感到悲伤。从经济上讲，这也意味着有库存（工作软件）坐在货架上，而不是送到客户手中。精益原则告诉我们，有库存放在那里，不产生退货，就是浪费。&lt;/p&gt;
&lt;p&gt;那么话题就是，为什么我们不能发布这个？是什么阻止了更频繁的部署？很多组织害怕他们的微服务，他们希望对整个组件进行集成测试，通常是手动集成测试。有一个客户，有大约 60 个微服务，他们希望确保不存在某个聪明的工程师火花可以发布一个微服务而不发布其他 59 个微服务的可能性。为了强制执行这一点，他们为所有的微服务大批量地设置了一个单一的管道。这显然不是微服务的价值取向，即微服务是可以独立部署的。可悲的是，这是他们觉得最安全的方式。&lt;/p&gt;
&lt;p&gt;我们也看到了因为对质量和完整性的担忧，实际上不愿意交付。当然，这些并不荒唐。你不想激怒你的客户。另一方面，就像里德・霍夫曼所说的那样，如果你没有因为第一次发布而感到尴尬，那就太晚了。持续改进是有价值的，让东西被使用也是有价值的。&lt;/p&gt;
&lt;p&gt;如果发布的频率不高，而且是单体的，你就有了这些漂亮的微服务架构，可以让你走得更快，然而你走得很慢。这是坏的业务，也是坏的工程。&lt;/p&gt;
&lt;p&gt;假设你选择了频繁部署。所有保护你的用户不受半成品功能影响的东西，比如自动测试、功能标志、A/B 测试、SRE，都需要大量的自动化。通常当我开始与客户合作时，我们有一个关于测试的问题，他们说：&amp;ldquo;哦，我们的测试不是自动化的。&amp;rdquo; 这意味着他们实际上不知道代码是否在任何特定的点上工作。他们希望它能工作，而且上次检查时可能已经工作了，但我们没有任何办法在不运行手动测试的情况下知道它现在是否工作。&lt;/p&gt;
&lt;p&gt;问题是，退步是会发生的。即使所有的工程师都是最完美的工程师，也有一个不那么完美的外部世界。他们所依赖的系统可能会有意想不到的行为。如果一个依赖更新改变了行为，即使没有人做错任何事情，也会有一些东西被破坏。这就回到了 &amp;ldquo;我们不能交付是因为我们对质量没有信心&amp;rdquo; 的问题上。好吧，让我们解决对质量的信心问题，然后我们就可以交付了。&lt;/p&gt;
&lt;p&gt;我谈到了合同测试。这很便宜，也很简单，可以在单元测试层面进行，当然，你也需要自动化集成测试。你不希望依赖手动集成测试，否则它们会成为瓶颈。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;CI/CD&amp;rdquo; 似乎已经取代了我们词汇中的 &amp;ldquo;构建&amp;rdquo;，但在这两种情况下，它都是你作为一个工程组织所拥有的最有价值的东西之一。它应该是你的朋友，它应该是这种无处不在的存在。有时候构建的方式是，它在某个地方的 Jenkins 系统上被关闭了。稍微勤快一点的人时不时去检查一下网页，发现是红色的，就去告诉同事，最后有人把问题解决了。更好的是只是一个被动的构建指标，大家都可以看到，而不需要单独打开一个页面来查看。如果显示器红了，真的很明显，那就是有变化了，而且很容易看最近的变化。如果你有一个项目，红绿灯就可以用。如果你有微服务，你可能会需要类似一组磁贴的东西。即使你没有微服务，你可能会有好几个项目，所以你需要比红绿灯更完整一点的东西，尽管红绿灯很可爱。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu2a4881e276bdf5d8d62cbf385c723e21_25359_9c84cb997220709bd0436ae780fb3eb7.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu2a4881e276bdf5d8d62cbf385c723e21_25359_302a3a7ba286e724c7196d7ed3f2f713.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu2a4881e276bdf5d8d62cbf385c723e21_25359_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8aipgyj313u0u0my0_hu2a4881e276bdf5d8d62cbf385c723e21_25359_9c84cb997220709bd0436ae780fb3eb7.webp&#34;
               width=&#34;760&#34;
               height=&#34;572&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们不知道什么时候构建好了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你投资你的构建监控，那么你最终会出现破窗的情况。我到了客户那里，第一件事就是看了一下构建，我说：&amp;ldquo;哦，这个构建好像坏了。&amp;rdquo; 他们说：&amp;ldquo;是啊，已经坏了几个星期了。&amp;rdquo; 这时，我就知道我有很多工作要做了！&lt;/p&gt;
&lt;p&gt;为什么一个“破窗”的构建是不好的？这意味着你无法进行自动化集成测试，因为没有任何东西能从构建中做出来。事实上，你甚至无法进行手动集成测试，所以服务间的兼容性可能会恶化，而且没有人会知道。&lt;/p&gt;
&lt;p&gt;新的回归没有被发现，因为这个构建已经红了。也许最糟糕的是，它创造了一种文化，所以当其他构建中的一个红色时，人们并不那么担心，因为它更多的是相同的：&amp;ldquo;现在我们有两个红色。也许我们可以弄到整套的，然后如果我们把它们都弄红了，就能匹配了。&amp;rdquo; 嗯，不，不应该是这样的。&lt;/p&gt;
&lt;h2 id=&#34;锁定的完全僵化的不灵活的云雾缭绕的云端&#34;&gt;锁定的完全僵化的、不灵活的、云雾缭绕的云端&lt;/h2&gt;
&lt;p&gt;这些都是发生在团队层面的挑战。它们是关于我们作为工程师如何管理自己和我们的代码。但当然，尤其是当你到了一定规模的组织，你最终会面临另一系列的挑战，那就是组织如何使用云。我注意到，有些组织喜欢把云，变成一个锁定的、完全僵化的、灵活的、没有云的云。&lt;/p&gt;
&lt;p&gt;如何让一个云端不云端？你说：&amp;ldquo;好吧，我知道你可以走得很快，我知道你所有的自动化支持都走得很快，但是我们有一个流程。我们有一个架构评审委员会，它的会议相当不频繁。&amp;rdquo; 它将在项目准备交付后一个月开会，或者在最坏的情况下，它将在项目已经交付后一个月开会。虽然东西已经交付了，但我们还是在走流程。架构将在已经在现场验证后进行纸面审查，这是愚蠢的。&lt;/p&gt;
&lt;p&gt;有人曾经给我讲过一个故事。一个客户向他们抱怨说，IBM 卖给他们的一些配置软件不能用。当时我们承诺我们的精巧的配置软件可以让他们在十分钟内创建虚拟机。这是几年前的事了，当时 &amp;ldquo;10 分钟创建一个虚拟机&amp;rdquo; 是很先进很酷的。我们向他们承诺，这将是美好的。&lt;/p&gt;
&lt;p&gt;当客户安装好它并开始使用时，他们并没有发现它的美妙。他们以为他们会得到 10 分钟的供应时间，但他们看到的是，他们花了三个月的时间来供应一个云实例。他们回来找我们，他们说：&amp;ldquo;你们的软件完全坏了。你卖错了。你看，花了三个月的时间。&amp;rdquo; 我们对此感到疑惑，于是我们进去做了一些调查。事实证明，发生了什么事，他们创建了一个 84 步的预批准程序，以获得其中的一个实例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_huc8dbcc7071ff7c84ff69f4b98a721ac6_47267_ae9f35ae4c28888bc5e965bdc62681f1.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_huc8dbcc7071ff7c84ff69f4b98a721ac6_47267_5f1ba4586d11577f11e1e0385ec915ea.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_huc8dbcc7071ff7c84ff69f4b98a721ac6_47267_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8gdpbcj31190u0jsy_huc8dbcc7071ff7c84ff69f4b98a721ac6_47267_ae9f35ae4c28888bc5e965bdc62681f1.webp&#34;
               width=&#34;760&#34;
               height=&#34;612&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这款供应软件已经坏了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术有了，但文化没有，所以技术没有用。这是可悲的。我们把这个云，这是一个美丽的云，它有所有这些神奇的属性，它让一切都变得非常简单，然后组织的另一部分人说，&amp;ldquo;哦，这有点可怕。我们不会希望人们真的能够做事情。让我们把它关进笼子里吧！&amp;rdquo; 那种老式的重文案的治理方式是行不通的 —— 同时也是真的让大家很烦。它不会给出结果。更糟糕的是，它实际上不会让事情变得更安全。它可能会使他们更不安全。它肯定会让事情变得更慢，而且要花钱。我们不应该这样做。&lt;/p&gt;
&lt;p&gt;我和另一个客户聊过，那是一家大型汽车公司，他们在云计算供应方面遇到了真正的问题。他们花了很长的时间来获得实例。他们认为，&amp;ldquo;我们要解决这个问题的方法是我们要从供应商 A 转移到供应商 B。&amp;rdquo; 这可能会奏效，但实际上缓慢的问题是他们的内部采购。切换供应商会绕过他们既定的采购流程，所以可能会加快一段时间，但最终，他们的治理团队会注意到新的供应商，并实施控制。一旦发生这种情况，他们就会将监管落实到位，然后恢复现状。他们所有的成本会改变，但实际上没有任何的好处。这有点像，我很抱歉地说，我有时会受到这样的诱惑 —— 如果你看着你的炉子，你决定，&amp;ldquo;哦，那个烤箱很脏。清理很困难，所以我要搬家，所以我没有清洁烤箱。&amp;rdquo; 但后来，当然，同样的事情发生在其他房子，和新的烤箱变得肮脏。你需要一个更可持续的过程，而不是仅仅更换供应商来试图超越自己的采购。&lt;/p&gt;
&lt;p&gt;如果只有开发者在改变，如果只有开发者在走 Cloud Native 的道路，那么就是行不通的。这并不意味着开发者驱动的自由竞争是正确的模式。如果周围没有一些治理，那么云就会变成一个神秘的钱坑。我们很多人都遇到过这样的问题：看着云账单，觉得 &amp;ldquo;嗯。是啊，这么多，我也不明白钱都花到了哪里，也不明白是谁花的。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;用云端配置硬件是如此简单，但这并不意味着硬件是免费的。还是要有人为它付费。硬件很容易配置，也不能保证硬件有用。&lt;/p&gt;
&lt;p&gt;当我刚开始学习 Kubernetes 的时候，我当然也尝试过。我创建了一个集群，但后来我就偏离了轨道，因为我有太多的工作在进行。过了两个月，我又回到我的集群，发现这个集群一个月大约 1000 英镑&amp;hellip;&amp;hellip; 而且是完全没有价值的。太浪费了，我现在想起来还觉得恶心。&lt;/p&gt;
&lt;p&gt;我们的技术使我们能够做的很多事情都是为了提高效率。伟大的管理顾问彼得・德鲁克说过：&amp;ldquo;没有什么比高效地做那些根本不应该做的事情更无用的了。&amp;rdquo; 高效地创建没有价值的 Kubernetes 集群，这不是好事。除了成本高，还有对生态环境的影响。让一个 Kubernetes 集群消耗价值 1000 英镑的电力，什么都不做，对地球不是很好。&lt;/p&gt;
&lt;p&gt;对于我说的很多问题，最初看起来是技术问题，其实是人的问题。我觉得这个有点不一样，因为这个看似是人的问题，其实是技术问题。这个领域其实工具可以帮助我们。比如说，工具可以帮助我们管理浪费，可以检测到闲置的服务器，帮助我们把服务器追溯到发起人。这方面的工具还没有，但已经越来越成熟了。&lt;/p&gt;
&lt;h2 id=&#34;云管理你的云&#34;&gt;云管理你的云&lt;/h2&gt;
&lt;p&gt;这个云管理的工具化最后是在云上，所以你最后是在递归的情况下，要有一些云来管理你的云。我的公司有一个多云管理器，它会看你的工作负载，找出工作负载的形状，从财务上来说，你能让它上的最优化的供应商是什么，然后自动进行这种迁移。我预计我们可能会开始看到越来越多这样的软件，它在看它，然后说：&amp;ldquo;顺便说一下，我可以告诉他的 Kubernetes 集群其实没有流量，它已经在那里待了两个月了。你为什么不去和 Holly 说几句话呢？&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;微服务运维混乱&#34;&gt;微服务运维混乱&lt;/h2&gt;
&lt;p&gt;管理云成本越来越复杂，这反映了一个更普遍的事情，就是云运维越来越复杂。我们正在使用越来越多的云供应商。有越来越多的云实例涌现出来。我们到处都有集群，那么我们到底该如何为这些集群做运维呢？这就是 SRE (Site Reliability Engineering) 的作用。&lt;/p&gt;
&lt;p&gt;网站可靠性工程的目的是使操作更加可重复，减少繁琐，以使服务更加可靠。它实现这一目标的方法之一是将一切自动化，我认为这是一个令人钦佩的目标。像发布这样的事情，我们越是自动化，我们就越能做到，这对工程师和消费者来说都是好事。最终的目标应该是，发布不是一个事件，而是一切照旧。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu1b4e2544684768dd2e18d6411c00dda6_48800_bba402be284753bd21a5fddffb3f7ef7.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu1b4e2544684768dd2e18d6411c00dda6_48800_a1ff915e1f6913e3d984cb93e1d7360e.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu1b4e2544684768dd2e18d6411c00dda6_48800_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8dicqaj30tv0ryt9v_hu1b4e2544684768dd2e18d6411c00dda6_48800_bba402be284753bd21a5fddffb3f7ef7.webp&#34;
               width=&#34;760&#34;
               height=&#34;711&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使发布深感无聊。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之所以能够有这种无聊的感觉，是我们对可回收性有信心，是 SRE 让我们对可回收性有信心。&lt;/p&gt;
&lt;p&gt;我有另一个悲伤的太空故事，这次是来自苏联。在 80 年代，一位工程师想对苏联一个叫 &amp;ldquo;Phobos&amp;rdquo; 的太空探测器的代码进行更新。当时，它是机器代码，都是 0 和 1，而且都是手写的。很显然，你不想用手写的机器代码对一个绕着地球飞驰的航天器进行实时更新，而不进行一些检查。在任何推送之前，代码都会经过验证器，验证器相当于机器代码的 linter。&lt;/p&gt;
&lt;p&gt;这样做很好，直到自动检查器坏了，这时需要进行更改。一位工程师说：&amp;ldquo;哦，但我真的想做这个改动。我就绕过自动检查器，直接把我的代码推送给空间探测器，因为，我的代码当然是完美的。&amp;rdquo; 于是，他们用手写的机器代码，在没有检查的情况下，对绕着地球飞驰的航天器进行了实时更新。能出什么问题呢？&lt;/p&gt;
&lt;p&gt;发生的是一个非常微妙的 bug。一切似乎都在正常工作。不幸的是，工程师忘记了其中一个指令的零点。这就改变了指令，从原来的指令变成了停止探测器的充电鳍旋转的指令。Phobos 号的翅片会转向太阳方向，这样无论它朝向哪个方向，都能收集太阳能。两天来一切都很好，直到电池没电了。一旦探测器没电了，他们就没办法恢复它，因为整个东西都死了。&lt;/p&gt;
&lt;p&gt;这就是一个完全无法恢复的系统的例子。一旦它死了，你就再也找不回来了。你不能只是做一些事情，然后把它恢复到一个干净的空间探测代码副本，因为它在太空中。&lt;/p&gt;
&lt;p&gt;这样的系统是真正无法恢复的。我们很多人认为，我们所有的系统几乎都和空间探测器一样无法恢复，但事实上，只有极少数系统可以恢复。&lt;/p&gt;
&lt;p&gt;我们真正想做的是在这个频谱的顶端，我们可以在几毫秒内恢复，没有数据丢失。如果有任何问题，只是，&amp;ldquo;ping，它被修复&amp;rdquo;。如果有什么问题，它只是，&amp;ldquo;ping，它的固定&amp;rdquo;。这真的很难达到，但有一大堆中间点是现实的目标。&lt;/p&gt;
&lt;p&gt;如果我们恢复的速度很快，但是数据丢失了，那就不太好了，但是我们可以接受。如果我们有交接和人工干预，那对于恢复的速度会慢很多。当我们在考虑频繁部署和部署的时候，非常无聊 —— 我们要有信心，我们在那个上端。我们到达那里的方式，交接不好，自动化，好。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu99c81139a1244bce425b52fd0480ae25_38079_63573985ab98df4f6d7cffb329a3ccac.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu99c81139a1244bce425b52fd0480ae25_38079_78afcc1fc605bac8b2bd104b42a424ea.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu99c81139a1244bce425b52fd0480ae25_38079_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8e64boj311e0u0wfs_hu99c81139a1244bce425b52fd0480ae25_38079_63573985ab98df4f6d7cffb329a3ccac.webp&#34;
               width=&#34;760&#34;
               height=&#34;610&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;云原生成功的方法&#34;&gt;云原生成功的方法&lt;/h2&gt;
&lt;p&gt;这篇文章包含了一大堆关于我所看到的可能出错的事情的悲惨故事。我不想给你留下一个印象，即所有的事情都会出错，因为很多时候，事情确实非常正确。云原生是一种奇妙的软件开发方式，它可以让团队感觉更好，降低成本，让用户更快乐。作为工程师，我们可以把更少的时间花在辛苦和繁琐的事情上，而把更多的时间花在真正想做的事情上&amp;hellip;&amp;hellip; 我们可以更快地进入市场。&lt;/p&gt;
&lt;p&gt;要想达到这种快乐的状态，我们必须在整个组织中保持一致。我们不能让一群人说微服务，一群人说快，一群人说老式治理。这几乎肯定是行不通的，会有很多脾气暴躁的工程师和委屈的财务人员。相反，一个组织应该在整体层面上达成共识，它要实现的目标是什么。一旦同意了这个目标，就应该对反馈进行优化，确保反馈回路尽可能短，因为这才是合理的工程。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu67a014ae3dc46f4f79fc76a563e994e9_8920_e52756870de9791bd2aeb69ea3e646e3.webp 400w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu67a014ae3dc46f4f79fc76a563e994e9_8920_a7777f80a14bb5b8e062222a933ce932.webp 760w,
               /blog/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu67a014ae3dc46f4f79fc76a563e994e9_8920_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/008eGmZEly1goqq8fglzbj304x05sabb_hu67a014ae3dc46f4f79fc76a563e994e9_8920_e52756870de9791bd2aeb69ea3e646e3.webp&#34;
               width=&#34;177&#34;
               height=&#34;208&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Holly Cummins&lt;/strong&gt; 是 IBM 企业战略部的创新领导者，并在 IBM Garage 担任顾问多年。作为 Garage 的一员，她为各行各业的客户提供技术驱动的创新，从银行业到餐饮业，从零售业到非政府组织。Holly 是 Oracle Java 冠军、IBM Q 大使和 JavaOne Rock Star。她与人合著了 Manning 的《Enterprise OSGi in Action》。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生时代——投资人视角下的云原生趋势思考</title>
      <link>https://cloudnative.to/blog/cloud-native-era/</link>
      <pubDate>Thu, 04 Jun 2020 14:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-era/</guid>
      <description>&lt;p&gt;今天我们不讲行业和商业，讲讲 2019 年最热的概念——云原生（Cloud Native）。&lt;/p&gt;
&lt;p&gt;我认为云原生是未来 10 年 IT 发展最重要的趋势，但是它涵盖的概念非常多，需要花很多时间研究，同时浩如烟海的资料分散在网络上各个地方，缺乏系统性的梳理。今年 2 月我在基金内部做过一个分享，今日成文，希望让更多的人有所了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文试图解答：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么云原生概念具有革命性？&lt;/li&gt;
&lt;li&gt;什么是微服务？&lt;/li&gt;
&lt;li&gt;微服务和中台的关系&lt;/li&gt;
&lt;li&gt;容器和微服务为什么是最佳搭档？&lt;/li&gt;
&lt;li&gt;容器化与虚拟化的区别&lt;/li&gt;
&lt;li&gt;API 管理与 API 集成的区别&lt;/li&gt;
&lt;li&gt;Kubernetes 是做什么用的？&lt;/li&gt;
&lt;li&gt;开源软件商业化遇到的典型问题是什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;涉及到的概念包括云原生、DevOps、持续集成、持续交付、持续部署、微服务、API 管理、iPaaS、Service Mesh、Serverless、容器、Docker、Kubernetes 等等，我争取用比较形象和通俗的方式把这些技术概念讲清楚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文内容较多，共分为六个章节。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：云原生及 CNCF 基金会&lt;/li&gt;
&lt;li&gt;第二部分：DevOps 与 CI/CD&lt;/li&gt;
&lt;li&gt;第三部分：微服务、API 管理与集成&lt;/li&gt;
&lt;li&gt;第四部分：容器与 Docker&lt;/li&gt;
&lt;li&gt;第五部分：Kubernetes 与容器编排之战&lt;/li&gt;
&lt;li&gt;第六部分：思考与机会&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第一部分云原生及-cncf-基金会&#34;&gt;第一部分：云原生及 CNCF 基金会&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;从集装箱革命说起&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一本非常有名的书，叫《集装箱改变世界》，说的是看起来平淡无奇的铁箱子，如何从二十世纪起永久性的改变了这个世界，并促进了全球化和全球分工。集装箱的出现和发展是实体货物包装、运输、交付方式的一次革命。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcsfj4ojj30a00dr0t9_hu973692695ef616ae604ebc2a994a8846_31327_45aaad65f0a36e23b5c3565981f20351.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsfj4ojj30a00dr0t9_hu973692695ef616ae604ebc2a994a8846_31327_1d5202486bec08d5347650a8fd1852e5.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsfj4ojj30a00dr0t9_hu973692695ef616ae604ebc2a994a8846_31327_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcsfj4ojj30a00dr0t9_hu973692695ef616ae604ebc2a994a8846_31327_45aaad65f0a36e23b5c3565981f20351.webp&#34;
               width=&#34;360&#34;
               height=&#34;495&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;《经济学家》杂志曾经评价说“没有集装箱，不可能有全球化”。集装箱为什么具有革命性？&lt;/p&gt;
&lt;p&gt;经济全球化的基础就是现代运输体系，而一个高度&lt;strong&gt;自动化、低成本和低复杂性&lt;/strong&gt;的货物运输系统的核心就是集装箱。集装箱最大的成功在于其产品的标准化及由此建立的一整套运输体系。能够让一个载重几十吨的庞然大物实现标准化，并且以此为基础逐步实现全球范围内的船舶、港口、航线、公路、中转站、桥梁、隧道、多试联运相配套的物流系统，这的确堪称人类有史以来创造的伟大奇迹之一，而撬动这个系统的理念就是&lt;strong&gt;标准化和系统化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;改变世界的不仅仅是集装箱本身，还有&lt;strong&gt;一整套货物处理的新方法，包括港口、货船、起重机、卡车，还有发货人的自身操作方式等&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;云原生在 IT 领域的意义非常类似于集装箱，只是里面装载的不再是实体货物，而是虚拟世界的二进制代码和软件。我们将在介绍完众多概念之后再来对应解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生的诞生&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着虚拟化技术的成熟和分布式框架的普及，在容器技术、可持续交付、编排系统等开源社区的推动下，以及微服务等开发理念的带动下，应用上云已经是不可逆转的趋势。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcshblgnj30o805odgc_huc9527362c169906aab04659be7b60a3d_30959_4db42e2597d5c8731ef641ba77a0cf36.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcshblgnj30o805odgc_huc9527362c169906aab04659be7b60a3d_30959_36da18a7bf747a07c14f36291ee50ddd.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcshblgnj30o805odgc_huc9527362c169906aab04659be7b60a3d_30959_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcshblgnj30o805odgc_huc9527362c169906aab04659be7b60a3d_30959_4db42e2597d5c8731ef641ba77a0cf36.webp&#34;
               width=&#34;760&#34;
               height=&#34;178&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;云原生的发展史，来自 CNCF 基金会执行董事 Dan Kohn&lt;/p&gt;
&lt;p&gt;云计算的 3 层划分，即基础设施即服务 (IaaS)、平台即服务 (PaaS)、软件即服务 (SaaS) 为云原生提供了技术基础和方向指引，真正的云化不仅仅是基础设施和平台的变化，应用也需要做出改变，摈弃传统的土方法，在架构设计、开发方式、部署维护等各个阶段和方面都基于云的特点，重新设计，从而建设全新的云化的应用，即云原生应用。&lt;/p&gt;
&lt;p&gt;云原生（Cloud Native）这个概念，是由 Pivotal 的 Matt Stine 于 2013 年首次提出，他还在 2015 年出版了《Migrating to Cloud-Native Application Architectures（&lt;a href=&#34;https://jimmysong.io/migrating-to-cloud-native-application-architectures&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;迁移到云原生应用架构&lt;/a&gt;）》一书。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcsgvptkj30u00mgmyl_hu3e6f78e0cc40012c213b3b2be5648906_66593_093bb96fcf31d6472646eee552e3c58f.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsgvptkj30u00mgmyl_hu3e6f78e0cc40012c213b3b2be5648906_66593_d9a482e7c9db22d0b68c9ba78bac837c.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsgvptkj30u00mgmyl_hu3e6f78e0cc40012c213b3b2be5648906_66593_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcsgvptkj30u00mgmyl_hu3e6f78e0cc40012c213b3b2be5648906_66593_093bb96fcf31d6472646eee552e3c58f.webp&#34;
               width=&#34;760&#34;
               height=&#34;568&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Gartner 提到云原生的定义尚不明确，但含义丰富。云原生对于不同的人和组织来讲，有着不同的理解。众多顶级技术的铸造者、Matt Stine 的东家 Pivotal&lt;a href=&#34;https://tanzu.vmware.com/de/cloud-native&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如此&lt;/a&gt;定义云原生。&lt;/p&gt;
&lt;p&gt;“Cloud native is an approach to building and running applications that fully exploit the advantages of the cloud computing model.”——云原生是一种构建和运行充分利用云计算模型优势的应用程序的方法。&lt;/p&gt;
&lt;p&gt;CNCF 云原生计算基金会&lt;a href=&#34;https://github.com/cncf/toc/blob/master/DEFINITION.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如此&lt;/a&gt;定义云原生：&lt;/p&gt;
&lt;p&gt;“云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格（Service Mesh）、微服务、不可变基础设施和声明式 API。这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。”&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcsk5hxbj30bs0bjq34_hu2d58e0113a12297a1185bcf042fd9351_18294_4ab65397c41d050012f3fb92d43760b0.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsk5hxbj30bs0bjq34_hu2d58e0113a12297a1185bcf042fd9351_18294_af56a44628a7c7409beac40d38df7569.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsk5hxbj30bs0bjq34_hu2d58e0113a12297a1185bcf042fd9351_18294_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcsk5hxbj30bs0bjq34_hu2d58e0113a12297a1185bcf042fd9351_18294_4ab65397c41d050012f3fb92d43760b0.webp&#34;
               width=&#34;424&#34;
               height=&#34;415&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其中服务网格和声明式 API 是新加入的内容，而不可变基础设施指的是应用的基础设施应是不可变的，是一个自包含、自描述可以完全在不同环境中迁移的东西，容器技术正是这一理念实现的基石。&lt;/p&gt;
&lt;p&gt;而 CNCF 同时把云原生计算定义为：&lt;/p&gt;
&lt;p&gt;“Cloud native computing uses an open source software stack to be:&lt;/p&gt;
&lt;p&gt;Containerized. Each part (applications, processes, etc) is packaged in its own container. This facilitates reproducibility, transparency, and resource isolation.&lt;/p&gt;
&lt;p&gt;Dynamically orchestrated. Containers are actively scheduled and managed to optimize resource utilization.&lt;/p&gt;
&lt;p&gt;Microservices-oriented. Applications are segmented into microservices. This significantly increases the overall agility and maintainability of applications.”&lt;/p&gt;
&lt;p&gt;——云原生计算使用的开源技术栈包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器化。每个部分（应用、流程等等）都打包在自己的容器中，这有助于提升复用性、透明度以及改善资源隔离。&lt;/li&gt;
&lt;li&gt;动态编排。容器受到有效的调度和管理，以便优化资源利用。&lt;/li&gt;
&lt;li&gt;以微服务为导向。应用被分割到不同的微服务中，这种分割可以显著的提高应用的整体敏捷性和可维护性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我个人理解，&lt;strong&gt;云原生是指从云的原生应用角度出发，一整套设计、开发、部署、运行、维护的流程、技术栈以及背后文化理念的统称。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下表列举了云原生应用和传统应用的有哪些主要区别。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcsj8rqej30lr08v3zl_hu616ad18a6753a65a53244c5ff2962956_53385_b409cbcd27c8e34dfbf1787a8cac56b2.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsj8rqej30lr08v3zl_hu616ad18a6753a65a53244c5ff2962956_53385_1c654351057ecaf2e674adaadcebd9f9.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsj8rqej30lr08v3zl_hu616ad18a6753a65a53244c5ff2962956_53385_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcsj8rqej30lr08v3zl_hu616ad18a6753a65a53244c5ff2962956_53385_b409cbcd27c8e34dfbf1787a8cac56b2.webp&#34;
               width=&#34;760&#34;
               height=&#34;310&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;要转向云原生应用需要以新的云原生方法开展工作，云原生有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-云原生的发展脉络&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34; 云原生的发展脉络&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcsi9yqzj30l103daab_hucd4ea4faf3ef29e647d5523b459f596d_20215_338a68f25c5247b972eb8f004f6f58de.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsi9yqzj30l103daab_hucd4ea4faf3ef29e647d5523b459f596d_20215_979ff452094976cbb5d68210018f0b53.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsi9yqzj30l103daab_hucd4ea4faf3ef29e647d5523b459f596d_20215_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcsi9yqzj30l103daab_hucd4ea4faf3ef29e647d5523b459f596d_20215_338a68f25c5247b972eb8f004f6f58de.webp&#34;
               width=&#34;757&#34;
               height=&#34;121&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
       云原生的发展脉络
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;云原生背后的价值主张有哪些？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离性：把应用程序打包在容器中加快了代码和组件的重用，并且简化了操作；&lt;/li&gt;
&lt;li&gt;无锁定：开源软件栈支持在任何公共或私有云上或以组合方式进行部署；&lt;/li&gt;
&lt;li&gt;无限扩展：为能够扩展到数万个自修复多租户节点的现代分布式系统环境而优化；&lt;/li&gt;
&lt;li&gt;灵活性和可维护性：将应用程序拆分为具有明确描述的依赖关系的微服务；&lt;/li&gt;
&lt;li&gt;提高效率和资源利用率：动态管理和调度微服务的中央编排流程降低了与维护和操作相关的成本；&lt;/li&gt;
&lt;li&gt;应用的弹性：以应对单个容器甚至数据中心的故障，以及不同级别的需求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2019 年，Gartner 曾经发布报告表示云原生时代已经到来，在未来三年中将有 75% 的全球化企业将在生产中使用容器化的应用。&lt;/p&gt;
&lt;p&gt;请注意，云原生相关技术不仅仅能用于云计算，即便是和云计算即对立又协同的边缘计算，微服务、容器、Kubernetes 依然是事实上的杀手应用和标准。如由著名的 Kubernetes 管理平台创业公司 Rancher 所贡献的 K3s 项目，就是 Kubernetes（K8s）的最轻量级版本，以满足边缘计算和 IOT 环境中，在 x86、ARM64 和 ARMv7 处理器上运行小型、易于管理的 Kubernetes 集群日益增长的需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生计算基金会 CNCF&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提到云原生，就不能不介绍云原生计算基金会 CNCF（Cloud Native Computing Foundation）（&lt;a href=&#34;https://www.cncf.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io&lt;/a&gt;）。CNCF 于 2015 年 7 月由 Google 牵头成立，隶属于 Linux 基金会，初衷是围绕云原生服务云计算，致力于培育和维护一个厂商中立的开源生态系统，维护和集成开源技术，支持编排容器化微服务架构应用，通过将最前沿的模式民主化，让这些创新为大众所用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CNCF 的使命包括以下三点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器化包装&lt;/li&gt;
&lt;li&gt;通过中心编排系统的动态资源管理&lt;/li&gt;
&lt;li&gt;面向微服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全球主流的科技企业和云计算厂商绝大部分都是 CNCF 会员，其中不乏多家来自中国的科技巨头。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-cncf-黄金白金成员&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;CNCF 黄金、白金成员&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcsjo4tmj30u009a0td_hu5d5d8268b4d71e48ddc99a7f50fb7a60_35662_00833668f0d304247b7de25588585e1e.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsjo4tmj30u009a0td_hu5d5d8268b4d71e48ddc99a7f50fb7a60_35662_e9938ab6d38559cdec74f3b0da5eedce.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsjo4tmj30u009a0td_hu5d5d8268b4d71e48ddc99a7f50fb7a60_35662_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcsjo4tmj30u009a0td_hu5d5d8268b4d71e48ddc99a7f50fb7a60_35662_00833668f0d304247b7de25588585e1e.webp&#34;
               width=&#34;760&#34;
               height=&#34;235&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      CNCF 黄金、白金成员
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;截止 2020 年 4 月，CNCF 基金会共托管 49 个云原生项目，每个 CNCF 项目都对应一个成熟度等级，申请成为 CNCF 项目的时候需要确定项目的成熟度级别，Kubernetes 和 Envoy 等项目基于生产可用和高稳定性首先成为毕业项目（9 个），其他项目则根据其成熟度分别位于孵化（17 个）和沙箱（23 个）阶段。CNCF 目前托管的项目共同构成了云原生生态的基石。&lt;/p&gt;
&lt;p&gt;值得注意的是其中有三个来自中国的项目：VMware 中国团队为企业用户设计的 Registry Server 开源项目 Harbor，PingCap 贡献的分布式事务键值数据库 TiKV 以及阿里自研的 P2P 文件分发系统 Dragonfly。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-cncf-项目成熟度等级划分&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;CNCF 项目成熟度等级划分&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcskme7fj30n309gwex_hu731c7558e6808887e45810ff112c5086_28569_7c6850a713f548c34b3053422928d9e6.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcskme7fj30n309gwex_hu731c7558e6808887e45810ff112c5086_28569_32b62981656137068fe18a804533e386.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcskme7fj30n309gwex_hu731c7558e6808887e45810ff112c5086_28569_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcskme7fj30n309gwex_hu731c7558e6808887e45810ff112c5086_28569_7c6850a713f548c34b3053422928d9e6.webp&#34;
               width=&#34;760&#34;
               height=&#34;311&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      CNCF 项目成熟度等级划分
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于企业在复杂的基础架构之上如何推动云原生应用的更好落地，从而更好地适应环境与业务的发展，CNCF 给出了路线图（Trail Map）用于对用户在整体上给出指导建议，共分成十个步骤（容器化；CI/CD；应用定义及编排；监控及分析；服务代理、发现和网格；网络、策略及安全；分布式数据库及存储；流与消息；镜像库与运行时；软件分发）进行实施，而在不同的步骤都可以结合 CNCF 全景图（Landscape）中列出的产品或服务进行选择。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 全景图&lt;/a&gt;则列举了和云原生相关的产品及服务的完整名单，这 1381 个项目共同构成了恢弘庞大的云原生世界。整个全景图按照功能分为 29 个模块，分别归属于 9 种大的类别（应用定义与开发、编排与管理、运行时、配置、平台、可观察性与分析、Serverless、会员和其它）。值得注意的是其中专门有一种分类是&lt;a href=&#34;https://landscape.cncf.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cards from China&lt;/a&gt;，列举了来自中国的 145 个项目，其中不乏许多大家耳熟能详的知名项目，可惜的是数据并不完整。感兴趣的朋友可以自行研究。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcsfsuijj30u00gkjw6_hub7f5d5a8a630c85f80fde65fa38f78f1_183796_fd6a46dbfee50189a0919af0cd0fdf5b.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsfsuijj30u00gkjw6_hub7f5d5a8a630c85f80fde65fa38f78f1_183796_79d55e894967ced4c31e2c288dd41d8d.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsfsuijj30u00gkjw6_hub7f5d5a8a630c85f80fde65fa38f78f1_183796_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcsfsuijj30u00gkjw6_hub7f5d5a8a630c85f80fde65fa38f78f1_183796_fd6a46dbfee50189a0919af0cd0fdf5b.webp&#34;
               width=&#34;760&#34;
               height=&#34;420&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从 CNCF 的理念及野心来看，基于云原生的基础设施正在壮大和蚕食非云的市场，未来极有可能成为整个 IT 生态事实上的意见领袖和领导者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生涵盖的主要概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面提到云原生的代表技术包括容器、服务网格（Service Mesh）、微服务、不可变基础设施和声明式 API。另外一种比较主流的说法是云原生=微服务+DevOps+持续交付 + 容器化，广泛的见诸于各种文章和资料。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcsht0v9j30dc0d53zc_hudf5fcafe0d4030db6e54ec5a9296e4ab_43736_1c795d7bf1f2aaf697e2730d065b62a5.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsht0v9j30dc0d53zc_hudf5fcafe0d4030db6e54ec5a9296e4ab_43736_3131520d9784f49725526f8ab47e35ea.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsht0v9j30dc0d53zc_hudf5fcafe0d4030db6e54ec5a9296e4ab_43736_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcsht0v9j30dc0d53zc_hudf5fcafe0d4030db6e54ec5a9296e4ab_43736_1c795d7bf1f2aaf697e2730d065b62a5.webp&#34;
               width=&#34;480&#34;
               height=&#34;473&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在接下来的《云原生时代》系列报告中，我们将依照这些概念，分成 DevOps 与 CI/CD；微服务、API 管理与集成；容器与 Docker；Kubernetes 与容器编排之战四个部分全面介绍云原生各个组成部分。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcsir2frj30u00jkjsw_huf520331e476df94e760cd757b1c7311b_69154_b6079bb71815632fe61f3a3d21506a59.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsir2frj30u00jkjsw_huf520331e476df94e760cd757b1c7311b_69154_eadae8b714f7bb2eac18b4d097d17f74.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcsir2frj30u00jkjsw_huf520331e476df94e760cd757b1c7311b_69154_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcsir2frj30u00jkjsw_huf520331e476df94e760cd757b1c7311b_69154_b6079bb71815632fe61f3a3d21506a59.webp&#34;
               width=&#34;760&#34;
               height=&#34;496&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;第二部分devops-与-cicd&#34;&gt;第二部分：DevOps 与 CI/CD&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DevOps&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DevOps（Development &amp;amp; Operations，开发和运维）是 09 年提出来的概念，但一直没有太火。直到 14 年，容器与微服务架构的提出，DevOps 才得到了快速的发展。DevOps 不单是一个实现自动化的工具链，而是组织、流程与技术的结合。组织上强调全栈团队、团队特性专一、团队自治；技术上打通开发与运维；流程上强调端到端、可视化、灰度升级、A/B 测试等。&lt;/p&gt;
&lt;p&gt;对于 DevOps，微服务不是必须的，但微服务为 DevOps 提供了最好的架构支撑，对于组织和流程的要求也是一致的。所以，也有人称微服务是 DevOps 架构。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcxhljhcj30iy067dg2_hu27a49568cfe02a4c06767466b6b6e2a0_19966_dd33a607ea7ebf6ce912f89cf321d387.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcxhljhcj30iy067dg2_hu27a49568cfe02a4c06767466b6b6e2a0_19966_5801a0d72e27f28d22768e7eadfd3324.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcxhljhcj30iy067dg2_hu27a49568cfe02a4c06767466b6b6e2a0_19966_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcxhljhcj30iy067dg2_hu27a49568cfe02a4c06767466b6b6e2a0_19966_dd33a607ea7ebf6ce912f89cf321d387.webp&#34;
               width=&#34;682&#34;
               height=&#34;223&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;DevOps 流程示意图&lt;/p&gt;
&lt;p&gt;DevOps 与下面提到的 CI、CD 不同，DevOps 更偏向于一种对于文化氛围的构建。DevOps 也即是促使开发人员与运维人员之间相互协作的文化。DevOps 的概念似乎与持续交付的概念有些类似，两者均旨在促进开发与运维之间的协作，但是实际上两者差别很大：DevOps 更偏向于一种文化的构建，在 DevOps 文化指导下，团队中将包含了具有不同技能的人员（开发、测试等），并通过自动化测试与发布的手段，更快、更高质量的生产软件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续集成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持续集成（CONTINUOUS INTEGRATION，CI）指的是开发人员频繁的（一天多次的）将所有开发者的工作合并到主干上。这些新提交在最终合并到主线之前，都需要通过编译和自动化测试流进行验证，以保障所有的提交在合并主干之后的质量问题，对可能出现的一些问题进行预警。持续集成的核心在于确保新增的代码能够与原先代码正确的集成。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcxh6j37j30rs0c874y_hub9742717b9157c737b64e5f410a1950c_37148_7292823cae457bd0ecb4ef62573776e4.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcxh6j37j30rs0c874y_hub9742717b9157c737b64e5f410a1950c_37148_4b936d85a4ab40eb5c5f64cb3be93cf0.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcxh6j37j30rs0c874y_hub9742717b9157c737b64e5f410a1950c_37148_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcxh6j37j30rs0c874y_hub9742717b9157c737b64e5f410a1950c_37148_7292823cae457bd0ecb4ef62573776e4.webp&#34;
               width=&#34;760&#34;
               height=&#34;334&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;持续集成流程示意图&lt;/p&gt;
&lt;p&gt;持续集成带来的好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;易于定位错误&lt;/li&gt;
&lt;li&gt;易于控制开发流程&lt;/li&gt;
&lt;li&gt;易于 Code Review&lt;/li&gt;
&lt;li&gt;易于减少不必要的工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;持续交付&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与持续集成相比，持续交付（CONTINUOUS DELIVERY，CD）的侧重点在于交付，其核心对象不在于代码，而在于可交付的产物。由于持续集成仅仅针对于新旧代码的集成过程执行了一定的测试，其变动到持续交付后还需要一些额外的流程。与持续集成相比较，持续交付添加了测试 Test-&amp;gt;模拟 Staging-&amp;gt;生产 Production 的流程，也就是为新增的代码添加了一个保证：确保新增的代码在生产环境中是可用的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcxgfn6sj30rs0kkta3_hu79aef990c548ff6fc10faea410aa58cb_64845_2279ab88f5db3b0b4260c9d902725bb3.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcxgfn6sj30rs0kkta3_hu79aef990c548ff6fc10faea410aa58cb_64845_f1c3d3b4e9f1f687e26099f1ab1596de.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcxgfn6sj30rs0kkta3_hu79aef990c548ff6fc10faea410aa58cb_64845_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcxgfn6sj30rs0kkta3_hu79aef990c548ff6fc10faea410aa58cb_64845_2279ab88f5db3b0b4260c9d902725bb3.webp&#34;
               width=&#34;760&#34;
               height=&#34;562&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;持续交付流程示意图&lt;/p&gt;
&lt;p&gt;持续交付带来的好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;繁琐的部署工作没有了。团队不再需要花费几天的时间去准备一个发布&lt;/li&gt;
&lt;li&gt;可以更快的进行交付，这样就加快了与客户之间的反馈环&lt;/li&gt;
&lt;li&gt;轻松应对小变更，加速迭代&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;持续部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持续部署（CONTINUOUS DEPLOYMENT）指的是通过自动化部署的手段将软件功能频繁的进行交付。与持续交付以及持续集成相比，持续部署强调了通过自动部署的手段，对新的软件功能进行集成。同持续交付相比持续集成的区别体现在对生产的自动化。从开发人员提交代码到编译、测试、部署的全流程不需要人工的干预，完全通过自动化的方式执行。这一策略加快了代码提交到功能上线的速度，保证新的功能能够第一时间部署到生产环境并被使用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcxi2ytgj30rs0kkmyj_hu2d0910d2a349dcc215f29b760b38968a_64476_06c0b48b7d513530da4acb7e3d0af4ce.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcxi2ytgj30rs0kkmyj_hu2d0910d2a349dcc215f29b760b38968a_64476_c194358f6cd99afa86b26aef118d2fcb.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcxi2ytgj30rs0kkmyj_hu2d0910d2a349dcc215f29b760b38968a_64476_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcxi2ytgj30rs0kkmyj_hu2d0910d2a349dcc215f29b760b38968a_64476_06c0b48b7d513530da4acb7e3d0af4ce.webp&#34;
               width=&#34;760&#34;
               height=&#34;562&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;持续部署流程示意图&lt;/p&gt;
&lt;p&gt;持续部署带来的好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发布频率更快，因为不需要停下来等待发布。每一处提交都会自动触发发布流&lt;/li&gt;
&lt;li&gt;在小批量发布的时候，风险降低了，发现问题可以很轻松的修复&lt;/li&gt;
&lt;li&gt;客户每天都可以看到持续改进和提升，而不是每个月或者每季度，或者每年&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自动实时的部署上线，是最优的解决办法，但持续部署的要求是团队非常成熟，并且上线前是需要经过 QA 测试的，所以实际情况下很难实现，一般的团队也很难接受，挑战和风险都很大。&lt;/p&gt;
&lt;p&gt;我们总结下，DevOps、持续集成、持续交付、持续部署并不是某种技术栈或者框架，而是开发文化、流程、理念和操作方式。下一部分，我们将介绍云原生最重要的概念之一：微服务。&lt;/p&gt;
&lt;h2 id=&#34;第三部分微服务api-管理与集成&#34;&gt;第三部分：微服务、API 管理与集成&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是微服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微服务（Microservice）概念最早出现于 2012 年，2015 年以后受到越来越多的关注，并且逐渐开始流行开来。其中著名技术大神 Martin Fowler 功不可没，他于 2014 年发表的一篇博客《Microservices: a definition of this new architectural term》（微服务：新技术架构的定义）清晰的定义和阐述了微服务概念。&lt;/p&gt;
&lt;p&gt;“要开始解释什么是微服务之前，先了解单体（Monolithic）应用是很有用的：作为一整个单元构建的应用程序。企业应用由三个重要部分组成：客户端界面（由 HTML、Javascript 组成，使用浏览器访问）、数据库、服务端程序。服务端程序处理 HTTP 请求、执行业务逻辑、检索并更新数据库中的数据、选择和填充 HTML 视图发送给客户端。这个服务端程序是一个单一结构也即一个整体，系统中的任何修改都将导致服务端重新编译和布署一个新版本。&lt;/p&gt;
&lt;p&gt;这样一个单体应用很自然的被构建成为一个系统，虽然可以使用开发语言的基本特性把应用封装成类、函数、命名空间，但是业务中所有请求都要在单一的进程中处理完成，在某些场景中，你可以在开发人员的笔记本电脑中运行和测试，并且通过布署通道将测试通过的程序布署到生产环境中，你还可以水平扩展，利用负载均衡将实例布署到多台服务器中。&lt;/p&gt;
&lt;p&gt;的确，单体应用也非常成功，但是越来越多的人感觉到了不妥，特别是应用程序被发布到云的时候，变更周期被捆绑在一起 - 对应用程序一小部分所做的变更，都需要重新编译和部署整个应用。随着时间的推移，软件开发者很难保持一个好的模块架构，使得单个模块的变更不会影响到其它模块，而且扩展时也只能进行整体扩展，而不能根据需求进行部分扩展。”&amp;ndash; Martin Fowler&lt;/p&gt;
&lt;p&gt;下图是传统单体应用的技术及对应的组织架构，Martin Fowler 称之为大家已熟知的 Siloed Architectures-烟囱式（也称为谷仓）架构。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd08f2z0j30fz0coaax_hu804fbb768ec078ebf2d2021ca0311fb3_32054_d833e09a79d223f72ee1b2401019528c.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd08f2z0j30fz0coaax_hu804fbb768ec078ebf2d2021ca0311fb3_32054_d6f81a8916c46cf687c8d00e83fa536d.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd08f2z0j30fz0coaax_hu804fbb768ec078ebf2d2021ca0311fb3_32054_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd08f2z0j30fz0coaax_hu804fbb768ec078ebf2d2021ca0311fb3_32054_d833e09a79d223f72ee1b2401019528c.webp&#34;
               width=&#34;575&#34;
               height=&#34;456&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;传统单体应用的架构及对应的职能型组织架构&lt;/p&gt;
&lt;p&gt;综上，传统的单体应用有很大的局限性，应用程序随着业务需求的迭代、功能的追加扩展，最终成为一个庞然大物。单体应用的局限性大体包括以下几方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复杂性高：业务规模和团队规模发展的一定阶段，模块耦合严重，代码难以理解，质量变差&lt;/li&gt;
&lt;li&gt;交付效率低：构建和部署耗时长，难以定位问题，开发效率低，全量部署耗时长、影响范围广、风险大，发布频次低&lt;/li&gt;
&lt;li&gt;伸缩性差：单体只能按整体横向扩展，无法分模块垂直扩展&lt;/li&gt;
&lt;li&gt;可靠性差：一个 bug 有可能引起整个应用的崩溃&lt;/li&gt;
&lt;li&gt;阻碍技术创新：受技术栈限制，团队成员使用同一框架和语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决这一问题的银弹就是微服务。&lt;/p&gt;
&lt;p&gt;“微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通（通常是基于 HTTP 的 Restful API)。这些服务要基于业务场景，并使用自动化布署工具进行独立的发布。可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。”&amp;ndash; Martin Fowler&lt;/p&gt;
&lt;p&gt;微服务架构将单体应用，按照业务领域拆分为多个高内聚低耦合的小型服务，每个服务运行在独立进程，由不同的团队开发和维护，服务间采用轻量级通信机制，如 HTTP RESTful API，独立自动部署，可以采用不同的语言及存储方式。微服务体现去中心化、天然分布式，是中台战略落地到 IT 系统的具体实现方式的技术架构，用来解决企业业务快速发展与创新时面临的系统弹性可扩展、敏捷迭代、技术驱动业务创新等难题。&lt;/p&gt;
&lt;p&gt;下图左边是传统的单体应用，右边是微服务模式，图中每种颜色代表一种可拆分的微服务应用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczr2klvj30hr0bzjse_hu69719afe4e9852faff5254a72b71555d_50578_ef8b98d111ccc8dacaf2f360a10dc905.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczr2klvj30hr0bzjse_hu69719afe4e9852faff5254a72b71555d_50578_853c0c35fc2f8f5c5668bead68c9755b.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczr2klvj30hr0bzjse_hu69719afe4e9852faff5254a72b71555d_50578_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczr2klvj30hr0bzjse_hu69719afe4e9852faff5254a72b71555d_50578_ef8b98d111ccc8dacaf2f360a10dc905.webp&#34;
               width=&#34;639&#34;
               height=&#34;431&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;单体应用和微服务&lt;/p&gt;
&lt;p&gt;一个比较形象的例子是装配式建筑。传统建筑（单体应用）的施工周期（开发时间）很长，往往依赖于建筑公司（开发团队）的能力和水平，修建完成后难以搬迁和复用，而装配式建筑（微服务）的梁、板、柱、墙等构件（单个服务）可以事先批量化的在工厂（容器）生产，而在建造过程中，我们可以把构件想象成一块块乐高积木，在施工现场只需把它们拼合在一起，大大提升了施工进度和建筑质量。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczxm11oj30b408c3yf_hu38d139b3887127da3d388b0a47b2ca7a_5164_7afebef3ab924fd8c6274aeb6eb1769a.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczxm11oj30b408c3yf_hu38d139b3887127da3d388b0a47b2ca7a_5164_61aeca639a89814d7ca9d5442c71ec10.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczxm11oj30b408c3yf_hu38d139b3887127da3d388b0a47b2ca7a_5164_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczxm11oj30b408c3yf_hu38d139b3887127da3d388b0a47b2ca7a_5164_7afebef3ab924fd8c6274aeb6eb1769a.webp&#34;
               width=&#34;400&#34;
               height=&#34;300&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;装配式建筑：乐高积木&lt;/p&gt;
&lt;p&gt;微服务的特征包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小：粒度小，专注于一件事&lt;/li&gt;
&lt;li&gt;独：单独的进程。微服务不等于组件，服务是可以直接使用的商品，组件是待加工的原材料&lt;/li&gt;
&lt;li&gt;轻：轻量级通信机制，通常是 HTTP Restful 的接口。此处区别于传统的 SOA（面向服务的架构）&lt;/li&gt;
&lt;li&gt;松：松耦合，可以独立部署。每个微服务可以独立编译、独立部署、独立运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd001wjrj30l20ccgmg_hudc71d667027649ed7b6be57dd56e92f4_43457_8c84326b04d65fb867c5f69c719b0790.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd001wjrj30l20ccgmg_hudc71d667027649ed7b6be57dd56e92f4_43457_9b06c48757d3c9002e62c44f0c3e4f9d.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd001wjrj30l20ccgmg_hudc71d667027649ed7b6be57dd56e92f4_43457_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd001wjrj30l20ccgmg_hudc71d667027649ed7b6be57dd56e92f4_43457_8c84326b04d65fb867c5f69c719b0790.webp&#34;
               width=&#34;758&#34;
               height=&#34;444&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务采用独立的数据库服务，数据去中心化&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczsykmpj30lm0a3wfa_hu54fb28eefbd812e7e2ed43b56fde7b83_41862_aa5a3ba6bf5f44b4a7a2734e287fcdd7.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczsykmpj30lm0a3wfa_hu54fb28eefbd812e7e2ed43b56fde7b83_41862_0c900aa156260c07e33126e76713a240.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczsykmpj30lm0a3wfa_hu54fb28eefbd812e7e2ed43b56fde7b83_41862_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczsykmpj30lm0a3wfa_hu54fb28eefbd812e7e2ed43b56fde7b83_41862_aa5a3ba6bf5f44b4a7a2734e287fcdd7.webp&#34;
               width=&#34;760&#34;
               height=&#34;355&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务运行在独立的进程中，部署去中心化&lt;/p&gt;
&lt;p&gt;微服务架构的好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;易于开发与维护：微服务相对小，易于理解&lt;/li&gt;
&lt;li&gt;独立部署：一个微服务的修改不需要协调其它服务&lt;/li&gt;
&lt;li&gt;伸缩性强：每个服务都可按硬件资源的需求进行独立扩容&lt;/li&gt;
&lt;li&gt;与组织结构相匹配：微服务架构可以更好将架构和组织相匹配，每个团队独立负责某些服务，获得更高的生产力&lt;/li&gt;
&lt;li&gt;技术异构性：使用最适合该服务的技术，降低尝试新技术的成本&lt;/li&gt;
&lt;li&gt;企业环境下的特殊要求：去中心化和集中管控/治理的平衡，分布式数据库和企业闭环数据模型的平衡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;微服务的实践有两个重要问题：什么时候选择微服务架构，以及颗粒度如何拆分，与经验和实际情况息息相关。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd02ry2mj30q10khwfs_huf2a7e0a923f0a28ffc72e30bfab4f74f_62003_84be90a59d0e5d6786b77aadbf2e91f2.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd02ry2mj30q10khwfs_huf2a7e0a923f0a28ffc72e30bfab4f74f_62003_46c95d87235bb1fb6eb633d9dc1c68c5.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd02ry2mj30q10khwfs_huf2a7e0a923f0a28ffc72e30bfab4f74f_62003_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd02ry2mj30q10khwfs_huf2a7e0a923f0a28ffc72e30bfab4f74f_62003_84be90a59d0e5d6786b77aadbf2e91f2.webp&#34;
               width=&#34;760&#34;
               height=&#34;598&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上图来自 Martin Fowler 另一篇叫《&lt;a href=&#34;https://martinfowler.com/bliki/MicroservicePremium.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务进阶&lt;/a&gt;》的文章，揭示了生产率和复杂度的一个关系。在复杂度较小时采用单体应用的生产率更高，复杂度到了一定规模时，单体应用的生产率开始急剧下降，这时对其进行微服务化的拆分才是合算的。&lt;/p&gt;
&lt;p&gt;我个人建议是除非在可见的将来，复杂度都不会显著提高的情况下，才选择单体应用，否则其它时候都应提前为微服务架构做好设计和准备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务基础设施及案例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下图是一个典型的微服务技术架构图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczzj84wj30u00i0wfx_huddfa3f80c6c3686b7706328d2a3a233e_67005_414c35364b651d350d6a2a28aa3bb35b.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczzj84wj30u00i0wfx_huddfa3f80c6c3686b7706328d2a3a233e_67005_5d5fd23305846cf54400097577375bf9.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczzj84wj30u00i0wfx_huddfa3f80c6c3686b7706328d2a3a233e_67005_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczzj84wj30u00i0wfx_huddfa3f80c6c3686b7706328d2a3a233e_67005_414c35364b651d350d6a2a28aa3bb35b.webp&#34;
               width=&#34;760&#34;
               height=&#34;456&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务架构最常见、最广泛使用的框架是基于 Java 的 Spring Cloud（集成了上图里的 Netflix OSS 技术栈），提供了服务发现、负载均衡、故障转移、动态扩展和数据分区等功能，已经成为微服务的最佳实践。&lt;/p&gt;
&lt;p&gt;但是 Spring Cloud 构建在 Java 虚拟机之上，不能满足高并发下的性能要求，所以许多开源产品层出不穷，其中也包括中国互联网企业所贡献的微服务框架，例如华为的 ServiceComb、阿里的 Dubbo 等等。&lt;/p&gt;
&lt;p&gt;下面我们举一个例子。传统的电商的技术架构如下图所示，这是一个单体应用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfkqzedtg2j30ir09vgm0_huaf1bd0fa54c9556b69499d40905d79d4_24232_ae43d6f44279e8f429e658c57f0bc9f2.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfkqzedtg2j30ir09vgm0_huaf1bd0fa54c9556b69499d40905d79d4_24232_719c3f1cbe9e4dba0df80e3baa75336e.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfkqzedtg2j30ir09vgm0_huaf1bd0fa54c9556b69499d40905d79d4_24232_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfkqzedtg2j30ir09vgm0_huaf1bd0fa54c9556b69499d40905d79d4_24232_ae43d6f44279e8f429e658c57f0bc9f2.webp&#34;
               width=&#34;675&#34;
               height=&#34;355&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;所带来的常见问题包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同客户端产品之间，例如小程序、App、网站端有许多相同业务逻辑的重复代码，每个产品都要各自维护一份代码，修改的时候所有地方要一起修改。&lt;/li&gt;
&lt;li&gt;单个应用经常需要给其他应用提供接口，渐渐地越来越复杂，包含了很多本来不属于它的逻辑，代码变得臃肿，功能边界模糊。&lt;/li&gt;
&lt;li&gt;系统代码耦合性高，相互之间逻辑复杂，一旦出现开发离职的情况，继任者需要花很长时间 review 代码，才有可能搞清楚整体架构和逻辑关系。&lt;/li&gt;
&lt;li&gt;多个应用使用一个数据库，依赖性严重，很难重构和优化。所有应用都在一个数据库上操作，数据库很容易出现性能瓶颈。同时数据库成为单点，出现意外整个系统都会受到影响。&lt;/li&gt;
&lt;li&gt;即使只改动一个小功能，也需要整个应用一起发布，发布流程繁琐、上线时间长。并且很容易出现一个小 bug 影响整个系统，每次发布都是胆战心惊，很容易出现开发、运维和测试之间的矛盾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们用微服务重构整个系统：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd01uivsj30jw0ex3z5_hufa034d6c38b281ab68361ce353516d7e_36069_fd4f031bcd4b7b40692290a9139eb8c8.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd01uivsj30jw0ex3z5_hufa034d6c38b281ab68361ce353516d7e_36069_08d8031deda056706d38ccf94fecdd4a.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd01uivsj30jw0ex3z5_hufa034d6c38b281ab68361ce353516d7e_36069_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd01uivsj30jw0ex3z5_hufa034d6c38b281ab68361ce353516d7e_36069_fd4f031bcd4b7b40692290a9139eb8c8.webp&#34;
               width=&#34;716&#34;
               height=&#34;537&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;改造之后，去除了大量冗余代码，系统复用性得到提升；不同的团队专注于不同的微服务，代码和工程质量得到保证；数据库不再存在单点问题，系统健壮性得以提升；前后端分离，业务逻辑更加清晰；降低了系统耦合性，不同的微服务可以分开部署上线，相互之间并不影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组织挑战、康威定律与蜂群理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请注意，微服务理念不仅反映了技术架构的变化，也反映了组织内部沟通结构为了应对更加灵活、快速、碎片化的需求和环境而变化的结果。例如&lt;a href=&#34;https://wiki.mbalib.com/wiki/%E6%B6%B2%E6%80%81%E5%85%AC%E5%8F%B8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;液态组织&lt;/a&gt;就是组织形态应对当前市场环境快速变化的一种输出形式，但实际应该如何构建？&lt;/p&gt;
&lt;p&gt;曾经有一张非常有名的组织架构图，如下图所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczqcikwj30r80qjtd9_hudaf522fe257b4732a6e49e9ca454eb11_188523_24b1274c71580cfeefbf7d7b7886450c.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczqcikwj30r80qjtd9_hudaf522fe257b4732a6e49e9ca454eb11_188523_281b2c7008ee1dd9197c50c3450c0cf9.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczqcikwj30r80qjtd9_hudaf522fe257b4732a6e49e9ca454eb11_188523_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczqcikwj30r80qjtd9_hudaf522fe257b4732a6e49e9ca454eb11_188523_24b1274c71580cfeefbf7d7b7886450c.webp&#34;
               width=&#34;760&#34;
               height=&#34;741&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对一家企业来说，能一步步不断发展壮大，进入一个领域就能迅速突破，这其中的根本核心必然是组织模式。在粗放发展的年代，很少有企业强调内部效率，组织模式绝大部分都类似单体应用，按照职能划分的方式进行管理，从而创造了无数的烟囱/谷仓。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczucghvj30u00fzdgq_huacdaae150e0427ee47bdf8f41b0ee44c_44391_7847656217340619f09f00e69dd4c903.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczucghvj30u00fzdgq_huacdaae150e0427ee47bdf8f41b0ee44c_44391_f67f795cb141e7c0e09616426fe24b23.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczucghvj30u00fzdgq_huacdaae150e0427ee47bdf8f41b0ee44c_44391_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczucghvj30u00fzdgq_huacdaae150e0427ee47bdf8f41b0ee44c_44391_7847656217340619f09f00e69dd4c903.webp&#34;
               width=&#34;760&#34;
               height=&#34;404&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;单体架构和职能型组织模式相似&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd07y5d0j30f00bb75h_hu6f04674ebb84da12b365cf74c63af376_57938_82ec72c1e25624d48051096161fc5953.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd07y5d0j30f00bb75h_hu6f04674ebb84da12b365cf74c63af376_57938_42bd5cc7d12f4c68994ffb3471658c2e.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd07y5d0j30f00bb75h_hu6f04674ebb84da12b365cf74c63af376_57938_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd07y5d0j30f00bb75h_hu6f04674ebb84da12b365cf74c63af376_57938_82ec72c1e25624d48051096161fc5953.webp&#34;
               width=&#34;540&#34;
               height=&#34;407&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;一张著名的图：技术组织造就了难以逾越的谷仓&lt;/p&gt;
&lt;p&gt;我在我的知识星球里提出过&lt;a href=&#34;https://wx.zsxq.com/mweb/views/topicdetail/topicdetail.html%EF%BC%9Ftopic_id%3D421851248852128%26group_id%3D28518855224581&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;企业级产品设计所面临的重要挑战&lt;/a&gt;，其中一个问题是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版本。企业级产品现在经常涉及多个平台和不同的版本，例如 Web、PC、App、钉钉、企业微信、微信小程序、飞书的版本等等，第一会面临重复开发的问题，第二业务逻辑非常复杂，很容易造成产品逻辑和体验的不统一，以及不同版本产品之间逻辑的缺失。例如登录和注册微信小程序可能用的是手机号，而通过邮件注册需要使用的却是邮箱。如何设计一套比较好的产品流程和组织架构，来保证统一完善的产品逻辑及用户体验？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是的，这不仅仅是产品和技术问题，还是组织问题。现在越来越多的企业意识到了最大的挑战在于组织内部，无论是增长黑客还是 MVP 的理念都需要快速灵活的机制来配合。为什么有的组织效率高、能力强，能及时响应客户的需求和环境变化？&lt;/p&gt;
&lt;p&gt;新的组织设计理念认为传统的烟囱形式会成为创建有效增长和盈利途径的障碍，需要解构组织孤岛，采用跨职能组织的形式以支持增长。企业组织设计是非常专业的领域，有许多文章讨论，例如《&lt;a href=&#34;https://flevy.com/blog/winning-your-way-against-organizational-silos-the-strategic-way/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;战胜组织孤岛的战略之路&lt;/a&gt;》，本文不延伸讨论。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd08un2nj30u00iqq3s_hu1c065d38051b70217d1b059740d48298_42303_206d3a732a11e03c1624ed81a76e2448.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd08un2nj30u00iqq3s_hu1c065d38051b70217d1b059740d48298_42303_c0219a1b0bde847bd21a9a2afa1ff6a4.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd08un2nj30u00iqq3s_hu1c065d38051b70217d1b059740d48298_42303_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd08un2nj30u00iqq3s_hu1c065d38051b70217d1b059740d48298_42303_206d3a732a11e03c1624ed81a76e2448.webp&#34;
               width=&#34;760&#34;
               height=&#34;474&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;职能组织与跨职能组织&lt;/p&gt;
&lt;p&gt;我们可以看到单体应用和职能组织，微服务与跨职能组织，在形式上是高度相似的，这引申出微服务背后的理论基础。&lt;/p&gt;
&lt;p&gt;“当希望把一个大型应用拆分成多个部分时，管理层通常将重点放在技术层面。而如果组织架构还按 UI 团队、服务端逻辑团队和数据库团队的标准设立，甚至一个非常简单的变更都将导致跨团队间的项目协作，从而耗费时间和预算审批。一个高效的团队会针对这种情况进行优化，关注它们所涉及的应用逻辑，并从中做出更好的选择。换句话说，逻辑无处不在。这是康威定律的一个实例。”&amp;ndash; Martin Fowler&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;设计系统的架构受制于产生这些设计的组织的沟通结构（Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations）&amp;ndash; Melvyn Conway, 1967&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;康威定律可谓软件架构设计中的第一定律，本质是对商业世界的规律总结，但是因为投稿到编程相关的杂志，后经过《人月神话》这本软件界圣经的引用，并命名为康威定律（Conway&amp;rsquo;s law），因此得以推广。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczv9nl7j30n50f7dhk_huf5636ea6195041b22074e693f5725494_78807_709dd5116c08dfe5791f2e8d9d07a367.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczv9nl7j30n50f7dhk_huf5636ea6195041b22074e693f5725494_78807_b02abe38d8ff4ce3be0fd44eaa46708b.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczv9nl7j30n50f7dhk_huf5636ea6195041b22074e693f5725494_78807_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczv9nl7j30n50f7dhk_huf5636ea6195041b22074e693f5725494_78807_709dd5116c08dfe5791f2e8d9d07a367.webp&#34;
               width=&#34;760&#34;
               height=&#34;499&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;只通过简单的描述可能无法理解康威定律的精髓所在，原文中康威定律可总结为四项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一定律 组织沟通方式会通过系统设计表达出来（Communication dictates design）&lt;/li&gt;
&lt;li&gt;第二定律 时间再多一件事情也不可能做的完美，但总有时间做完一件事情（There is never enough time to do something right, but there is always enough time to do it over）&lt;/li&gt;
&lt;li&gt;第三定律 线型系统和线型组织架构间有潜在的异质同态特性（There is a homomorphism from the linear graph of a system to the linear graph of its design organization）&lt;/li&gt;
&lt;li&gt;第四定律 大的系统组织总是比小系统更倾向于分解（The structures of large systems tend to disintegrate during development, qualitatively more so than with small systems）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如微服务的团队间应该是 inter-operate，not integrate（互操作、不集成）。inter-operate 是定义好系统的边界和接口，在一个团队内全栈，让团队自治，原因就是因为如果团队按照这样的方式组建，将沟通的成本维持在系统内部，每个子系统就会更加内聚，彼此的依赖耦合变弱，跨系统的沟通成本也就能减低。&lt;/p&gt;
&lt;p&gt;康威定律可以上升到哲学的高度进行讨论，但是过于复杂。简言之，微服务架构与组织模式互相决定和影响，协同才能发挥出最大价值。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczyn0ihj30ks0byq3k_hu41c3c9b70eefbd24e527f487b2db4a07_35381_04f7dd14c647856f88f5d584ae6c2c09.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczyn0ihj30ks0byq3k_hu41c3c9b70eefbd24e527f487b2db4a07_35381_b78c509a2bba01d3ee33892bb6cf2237.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczyn0ihj30ks0byq3k_hu41c3c9b70eefbd24e527f487b2db4a07_35381_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczyn0ihj30ks0byq3k_hu41c3c9b70eefbd24e527f487b2db4a07_35381_04f7dd14c647856f88f5d584ae6c2c09.webp&#34;
               width=&#34;748&#34;
               height=&#34;430&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;跨职能组织-微服务架构/团队边界强化服务边界&lt;/p&gt;
&lt;p&gt;凯文·凯利在《失控》中提出了著名的“蜂群理论”，利用蜂巢思维比喻人类的协作带来的群体智慧：依靠成千上万个发条一起驱动一个并行的系统，进行生产，进行自维持。蜂巢思维就是“群体思维”（Collective consciousness）。作为“超级有机体”的蜂群，被称为“分布式系统”，是以生物逻辑建立起来的群集模型。由此形成的蜂巢思维这四个理念至关重要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;去中心化。几乎所有的团队都直接接触用户与市场，因此所有的团队都将围绕市场格局而变，充分重视第一线的敏感度与直觉，从而做到真正的应时而动；&lt;/li&gt;
&lt;li&gt;分布式。与垂直型集团组织不同，这个形态打破单一的行业垂直细分格局。在这种多维度矩阵式结构中，拥有更加专注的功能型团队，可建立起一个紧密围绕具体客户与市场的服务体系；&lt;/li&gt;
&lt;li&gt;强化合作。从控制权、所有权的角度来说，这些组织单元是分离的，因而要建立起一种横向合作的文化，打破物理团队，提倡交流、合作，整体核心竞争力的提升；&lt;/li&gt;
&lt;li&gt;适应变化。市场在不断变化，但因所有的团队都直接接触用户与市场，因此无论个人还是团队，都将不断的学习和进化。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;微服务理念对应的组织模式包括蜂巢型组织，它具有突出的稳定性和抗弯曲能力，特点是：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨组织：它不一定是一个独立的法人实体，而是为了特定目标或项目形成的联盟&lt;/li&gt;
&lt;li&gt;相对统一：蜂巢组织不是一成不变的，当市场需求或组织目标发生变化时立即变化&lt;/li&gt;
&lt;li&gt;分享性：它改变了传统的等级分明的金字塔结构，允许信息横向传递与交流，使信息利用更为充分及时&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这样一个以蜂巢为理念搭建的企业圈层里面，各个独立团队能够得到更好的协助与支撑，不断扩大视野，提高眼界，掌握话语权，团队成员也会更有归属感。这样的团队乃至蜂巢本身，也一定会更有活力和变革力，更加能适应市场的变化。蜂巢型组织有四个突出特点，所谓活系统的特质也正是由此而来：没有强制性的中心控制；次级单位具有自治的特质；次级单位之间彼此高度连接；点对点间的影响通过网络形成了非线性因果关系。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd053on0j30c10ftab4_hub56841497c25a38d13954fdb3d55fade_52341_8236be746ab947ada250e14673469531.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd053on0j30c10ftab4_hub56841497c25a38d13954fdb3d55fade_52341_a294cff735d4f8824521d8569df75e46.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd053on0j30c10ftab4_hub56841497c25a38d13954fdb3d55fade_52341_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd053on0j30c10ftab4_hub56841497c25a38d13954fdb3d55fade_52341_8236be746ab947ada250e14673469531.webp&#34;
               width=&#34;433&#34;
               height=&#34;569&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务：筑巢&lt;/p&gt;
&lt;p&gt;蜂巢型组织的典型案例之一是华为。除了组织架构去中心化的管理模式之外，华为的著名的轮值 CEO 制度正是由此而来，华为有三位轮值 CEO，每六个月轮换一次，这体现了依靠集体民主决策而非一人独裁的理念。&lt;/p&gt;
&lt;p&gt;再例如国美蜂巢式组织变革的实践是将由四个大区管辖 54 个分公司，调整为七个大区直接管辖 200 家分公司的结构，即将原来二级市场里的 146 家分公司独立出来，直接划归大区管辖，而原来四个大区变成七个大区。实践证明，组织扁平化是国美提升供应链效率，提升消费者消费体验的重要战略。&lt;/p&gt;
&lt;p&gt;国外著名的代表案例是微服务先驱 Netflix。Netflix 是一家技术强大的互联网公司，但是它却没有 CTO 职位，产品团队和技术团队 (包括 UI 前端工程团队、Discovery 搜索工程团队和 Platform 平台团队等) 全部汇报首席产品 CPO，产品驱动是该公司的核心文化要素之一，Netflix 称其为 BusDevOps 组织架构。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcztwultj30l50giq4c_hu55d9b371e96205b20fc0b0e2ed29783b_66104_1b7e5d0259d8d79c82132a47b3bea065.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcztwultj30l50giq4c_hu55d9b371e96205b20fc0b0e2ed29783b_66104_b8b9a39f50a33a8ab269ee8bf24ce3d3.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcztwultj30l50giq4c_hu55d9b371e96205b20fc0b0e2ed29783b_66104_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcztwultj30l50giq4c_hu55d9b371e96205b20fc0b0e2ed29783b_66104_1b7e5d0259d8d79c82132a47b3bea065.webp&#34;
               width=&#34;760&#34;
               height=&#34;593&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Netflix：BusDevOps 组织&lt;/p&gt;
&lt;p&gt;在整个系列第二部分中，我们介绍了 DevOps，现在我们可以理解，DevOps 是配合微服务的理念组织构建团队协作的方式，各团队可以独立开发，测试、发布和迭代各自的微服务，互不干扰，沟通协调成本小。全部业务、研发和运维围绕产品开展工作，统一目标，大家都是产品驱动，分别服务于内外不同客户，避免技术驱动 vs 业务驱动的陷阱。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd06mlidj30nm0e2wfs_hu9976f947b57103babfa9d5ce915b6b99_61972_42bc19bf051e3f85c5326cb8e61f5347.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd06mlidj30nm0e2wfs_hu9976f947b57103babfa9d5ce915b6b99_61972_6f9d7028177bd5cb53986ad069c32c09.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd06mlidj30nm0e2wfs_hu9976f947b57103babfa9d5ce915b6b99_61972_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd06mlidj30nm0e2wfs_hu9976f947b57103babfa9d5ce915b6b99_61972_42bc19bf051e3f85c5326cb8e61f5347.webp&#34;
               width=&#34;760&#34;
               height=&#34;452&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;传统水平组织 vs DevOps 驱动的垂直组织&lt;/p&gt;
&lt;p&gt;在某些文章中，认为微服务的切割应该按照组织架构来划分，我反而觉得应该按微服务的分割方式来划分组织架构，&lt;strong&gt;因为归根结底，组织架构应该为业务服务，而不是业务为组织服务&lt;/strong&gt;，组织需要贯彻执行微服务的理念，就必须由微服务驱动组织业务的不断迭代演进。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务与中台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能有人会问，中台的目标不也是为了解决企业内部业务系统烟囱林立，数据孤岛严重，各自为战，缺乏复用性，所以要充分提取业务共性，从而及时应对需求变化，听起来和微服务的目标和理念非常相似，那它们之间有什么异同呢？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd01dzu0j30pu0e4abk_huef76d96fdee9ee179f9eb5dec137299d_69662_e31d9ddd0b32a8a28e04abc4e23be213.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd01dzu0j30pu0e4abk_huef76d96fdee9ee179f9eb5dec137299d_69662_d9cde48306310711474e6fa1dc6fbae6.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd01dzu0j30pu0e4abk_huef76d96fdee9ee179f9eb5dec137299d_69662_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd01dzu0j30pu0e4abk_huef76d96fdee9ee179f9eb5dec137299d_69662_e31d9ddd0b32a8a28e04abc4e23be213.webp&#34;
               width=&#34;760&#34;
               height=&#34;415&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;阿里巴巴中台战略架构图&lt;/p&gt;
&lt;p&gt;来自阿里官方的定义，“企业中台就是，将企业的核心能力随着业务不断发展以数字化形式沉淀到平台，形成以服务为中心，由业务中台和数据中台构建起数据闭环运转的运营体系，供企业更高效的进行业务探索和创新，实现以数字化资产的形态构建企业核心差异化竞争力。”&lt;/p&gt;
&lt;p&gt;中台架构，简单地说，就是企业级能力的复用，一种方法论，企业治理思想。&lt;/p&gt;
&lt;p&gt;微服务，是可独立开发、维护、部署的小型业务单元，是一种技术架构方式。&lt;/p&gt;
&lt;p&gt;所以中台并不是微服务，中台是一种企业治理思想和方法论，偏向于宏观，微服务是技术架构方式，偏向于微观。而中台化的落地，离不开使用微服务架构。&lt;/p&gt;
&lt;p&gt;中台强调核心基础能力的建设，基础能力以原子服务的形式来建设，并通过将原子服务产品化，支撑业务端各种场景的快速迭代和创新；原子服务和微服务所倡导的服务自闭环思想不谋而合，使得微服务成为实现原子服务的合适架构。&lt;/p&gt;
&lt;p&gt;支撑业务场景的应用也是通过服务来实现，其生命周期随业务变化需要非常灵活的调整，这也和微服务强调的快速迭代高度一致，所以业务应用服务也适合通过微服务来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API 管理与 API 集成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们讲讲微服务相关的两个具体领域，API 管理与 API 集成。&lt;/p&gt;
&lt;p&gt;1、全生命周期 API 管理&lt;/p&gt;
&lt;p&gt;上文提到微服务各个服务对外都是以 Restful API 形式提供服务。再加上企业越来越多地使用云服务，各种云服务也提供了众多 API。&lt;/p&gt;
&lt;p&gt;这就导致企业拥有的 API 越来越多，那就当然需要有一个系统把这些 API 统一管理起来。同时，如果能够顺便把这些 API 的权限认证、安全审计等等机制也一并统一了，那就更好了，这样其它系统调用起来就方便多了。能管了以后，当然又会冒出来更多的想法。比如，能不能改一下原有 API 的格式内容？能不能把两个 API 合成一个 API？能不能让一个 API 直接调用另一个 API？能不能把这些 API 的调用自动化串起来？&lt;/p&gt;
&lt;p&gt;简单来说，API 管理就是解决以上这些问题的。我们来看看 Gartner 全生命周期 API 管理领域魔力象限，许多巨头都在里面。值得注意的是，Google 之所以排名第一，是因为它在 2016 年用 6.5 亿美元收购了刚上市一年左右的 Apigee。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczqlzltj30pf0qidh0_hud3d15f4b7c7a849a30fb8032d8178ef4_56447_41ec1c0e07a905c5f9158d5d8434284d.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczqlzltj30pf0qidh0_hud3d15f4b7c7a849a30fb8032d8178ef4_56447_c2a5e6fd7df6625db72c5258a8613d62.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczqlzltj30pf0qidh0_hud3d15f4b7c7a849a30fb8032d8178ef4_56447_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczqlzltj30pf0qidh0_hud3d15f4b7c7a849a30fb8032d8178ef4_56447_41ec1c0e07a905c5f9158d5d8434284d.webp&#34;
               width=&#34;729&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;2019 年全生命周期 API 管理魔力象限&lt;/p&gt;
&lt;p&gt;2、API 网关：微服务基础设施&lt;/p&gt;
&lt;p&gt;全生命周期 API 管理里一个细分的领域是 API 网关（API Gateway），它是微服务 1.0 时代最重要的基础设施。&lt;/p&gt;
&lt;p&gt;API 网关顾名思义，是出现在系统边界上的一个面向 API 的、串行集中式的强管控服务，这里的边界是企业 IT 系统的边界，主要起到隔离外部访问与内部系统的作用，并处理常见的南北向流量。在微服务概念的流行之前，API 网关的实体就已经诞生了，例如银行、证券等领域常见的前置机系统，它也是解决访问认证、报文转换、访问统计等问题的。&lt;/p&gt;
&lt;p&gt;API 网关的流行，源于近几年来，移动应用与企业间互联需求的兴起。移动应用、企业互联，使得后台服务支持的对象，从以前单一的 Web 应用，扩展到多种使用场景，且每种使用场景对后台服务的要求都不尽相同。这不仅增加了后台服务的响应量，还增加了后台服务的复杂性。随着微服务架构概念的提出，API 网关成为了微服务架构的标配组件。&lt;/p&gt;
&lt;p&gt;API 网关作为企业能力开放的一个门户，除了具备基本的请求转发、协议转换、路由等功能，以及高性能和高稳定性外，还需具备良好的扩展性，已便于网关能力的不断增强。在网关实施过程中，要规划好网关层与服务层的交互方式，尽量使得网关层与服务层解耦，便于各个团队工作的独立性。另外，在 API 的管理上，需要提供 API 全生命周期的发布、配置、鉴权、流控、监控等配套的管理功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd00vmcjj30rf0b30tg_huc947e11d27c7108d686fa587b03527ad_39384_a3a0a0eac7d15d84033f581d60da9972.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd00vmcjj30rf0b30tg_huc947e11d27c7108d686fa587b03527ad_39384_bd98d4a470f488ef19eb9c25acddcd1f.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd00vmcjj30rf0b30tg_huc947e11d27c7108d686fa587b03527ad_39384_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd00vmcjj30rf0b30tg_huc947e11d27c7108d686fa587b03527ad_39384_a3a0a0eac7d15d84033f581d60da9972.webp&#34;
               width=&#34;760&#34;
               height=&#34;307&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;API 网关：微服务基础设施&lt;/p&gt;
&lt;p&gt;例如 Uber，在传统的单体架构遇到越来越大挑战的时候，决定改变自己的架构，效仿亚马逊、Netflix、Twitter 等其他超级增长公司，将其整体架构拆分为多个代码库，以形成一个微服务架构。其主要变化是引入了 API 网关，所有的司机和乘客都是通过这个网关连接的。从 API 网关，所有的内部点都连接在一起，如乘客管理、司机管理、行程管理等。每个单元是单独的可部署单元，执行单独的功能。例如：如果你想在账单微服务中更改任何内容，那么只需部署账单微服务，而不必部署其他服务。所有的功能都是单独扩展的，即每个特征之间的相互依赖被移除。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhcztehgnj30lc0l6jsx_hu2b9bad1690378c1ff4d746e6a675c6d7_71166_5f92b128d0cc82fac670a07838cca457.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhcztehgnj30lc0l6jsx_hu2b9bad1690378c1ff4d746e6a675c6d7_71166_55563ecb60c91cd87a360951f3e70e23.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhcztehgnj30lc0l6jsx_hu2b9bad1690378c1ff4d746e6a675c6d7_71166_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhcztehgnj30lc0l6jsx_hu2b9bad1690378c1ff4d746e6a675c6d7_71166_5f92b128d0cc82fac670a07838cca457.webp&#34;
               width=&#34;760&#34;
               height=&#34;754&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Uber 的微服务架构&lt;/p&gt;
&lt;p&gt;API 网关带来的的好处包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网关层对外部和内部进行了隔离，保障了后台服务的安全性&lt;/li&gt;
&lt;li&gt;对外访问控制由网络层面转换成了运维层面，减少变更的流程和错误成本&lt;/li&gt;
&lt;li&gt;减少客户端与服务的耦合，服务可以独立发展。通过网关层来做映射&lt;/li&gt;
&lt;li&gt;通过网关层聚合，减少外部访问的频次，提升访问效率&lt;/li&gt;
&lt;li&gt;节约后端服务开发成本，减少上线风险&lt;/li&gt;
&lt;li&gt;为服务熔断，灰度发布，线上测试提供简单方案。&lt;/li&gt;
&lt;li&gt;便于扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;API 网关常见的解决方案包括 Spring Cloud Gateway、Zuul、Tyk 以及下文要介绍的 Kong。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczshp2sj309c0aqq3p_hu43505da84eb0f2f5347059bf299ee30e_26437_125c03067a7268f1ab5dc7f5324f3b82.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczshp2sj309c0aqq3p_hu43505da84eb0f2f5347059bf299ee30e_26437_984c411b7b640b9a41dd8f07182e3c84.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczshp2sj309c0aqq3p_hu43505da84eb0f2f5347059bf299ee30e_26437_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczshp2sj309c0aqq3p_hu43505da84eb0f2f5347059bf299ee30e_26437_125c03067a7268f1ab5dc7f5324f3b82.webp&#34;
               width=&#34;336&#34;
               height=&#34;386&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
CNCF Landscape: API Gateway&lt;/p&gt;
&lt;p&gt;3、Kong：API 网关独角兽&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczx5107j30k50a2aa7_hu42ce2c85b17dab273556b581eed00218_11269_0820cc55f69f763758745c1a5b1e1d17.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczx5107j30k50a2aa7_hu42ce2c85b17dab273556b581eed00218_11269_4f07f16d35e32718fc4cf9c9caab5bb4.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczx5107j30k50a2aa7_hu42ce2c85b17dab273556b581eed00218_11269_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczx5107j30k50a2aa7_hu42ce2c85b17dab273556b581eed00218_11269_0820cc55f69f763758745c1a5b1e1d17.webp&#34;
               width=&#34;725&#34;
               height=&#34;362&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kong 是我去年起就在关注的一家公司，它的创业历程非常有意思。“Kong 的创始人 Augusto Marietti（简称 Aghi）出生在罗马，因为意大利创业环境很弱，在 2009 年飞来了旧金山。Aghi 刚来就参加了一个早期创业者的小聚会，聚会上参加的人不多，但现在都是如雷贯耳的名字：Uber 的创始人 Travis，Airbnb 的 CEO Brian，Dropbox 的 CEO Drew 和 Box 的 CEO Aaron。Aghi 当时为了省钱，借住在 Uber 创始人 Travis 家，每天睡沙发。&lt;/p&gt;
&lt;p&gt;后来 Travis 搬了家，Aghi 又去了当时只有十多个人的 Airbnb 办公室里借住，当时的 Airbnb 虽然 Bug 很多，但订单量一天天疯涨。在 Travis 的帮助下拿到天使投资后，Aghi 做了一个把云端的组件连接起来的 PaaS 公司，一做就是五六年。由于时机不对，公司濒临破产，Aghi 告诉团队，这么多年公司写了很多小功能，现在可以把代码开放出去，放在网上看看有没有人用，给社区做点贡献。没想到这看似濒死的挣扎，却给公司带来了巨大的转机。&lt;/p&gt;
&lt;p&gt;后来，公司关于 API 管理的代码模块，在 GitHub 上被疯狂下载，Kong 也接到客户要求，希望购买相应的付费企业版。Kong 敏锐地发现了这个大机会，迅速转型成了一个开源软件公司。”如果在 CSDN 博客上搜索，关于 Kong 开源版本的教程比比皆是。这是一个成功的开源软件商业化的案例，听起来经历和 Docker 非常相似。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd0385pwj30n308twff_hue3b5fb7524754274a5f1f338a3dfaaf9_30221_3e5ff06f337925fdf3ea8b6d3123aeb0.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd0385pwj30n308twff_hue3b5fb7524754274a5f1f338a3dfaaf9_30221_ec1b69361c1488f095d0a046c019e682.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd0385pwj30n308twff_hue3b5fb7524754274a5f1f338a3dfaaf9_30221_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd0385pwj30n308twff_hue3b5fb7524754274a5f1f338a3dfaaf9_30221_3e5ff06f337925fdf3ea8b6d3123aeb0.webp&#34;
               width=&#34;760&#34;
               height=&#34;290&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kong 开源版本 Github 主页&lt;/p&gt;
&lt;p&gt;Kong 成长的大背景是软件开发技术正在经历革命性变化，全球 5000 强公司都在转向新的分布式软件架构，因为现代应用程序需要有高度可扩展性、跨平台支持以及处理实时数据流的能力。IDC 预计，到 2022 年 90% 的应用程序将采用微服务架构和第三方代码，35% 的生产应用程序将诞生于云端。由于容器和敏捷方法的采用，预计 2018-2023 年间将诞生 5 亿个新应用程序。&lt;/p&gt;
&lt;p&gt;同时开源软件初期具有的优势也在逐渐显现。Kong 本身基于开源的 Openresty（Nginx+lua），但比 Nginx 提供了更简单的配置方式，数据采用了 Apache Cassandra/PostgreSQL存储，由于底层使用Nginx，所以性能比基于Java的Spring Cloud Gateway 及 Zuul 更为出色。Kong 另外一个非常诱人的地方就是提供了大量的插件来扩展应用，通过设置不同的插件可以为服务提供各种增强的功能。Kong 默认插件包括：身份认证、安全、流量控制、分析监控、转换等等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczz0tuzj30u00ftmxs_huabb8a8487e5f81bb28aaa3ad498c82d9_35007_4f43d3d7eb2451b179d6be53aff8f006.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczz0tuzj30u00ftmxs_huabb8a8487e5f81bb28aaa3ad498c82d9_35007_37da155b6f1374ab52c72992c7d92a6b.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczz0tuzj30u00ftmxs_huabb8a8487e5f81bb28aaa3ad498c82d9_35007_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczz0tuzj30u00ftmxs_huabb8a8487e5f81bb28aaa3ad498c82d9_35007_4f43d3d7eb2451b179d6be53aff8f006.webp&#34;
               width=&#34;760&#34;
               height=&#34;401&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kong 的插件功能&lt;/p&gt;
&lt;p&gt;Kong 提供开源的 Kong Gateway 和商业版 Kong Enterprise 两个产品。例如在插件功能上，商业版本提供更多的选择。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd03s2uwj30qz0kmabu_hua04f461493837df3586c2d51d1a9834e_80658_6b89d0d5d9d90bcc8b7ebb7d75b326cb.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd03s2uwj30qz0kmabu_hua04f461493837df3586c2d51d1a9834e_80658_670d2d79ca18f7f7d54117a347967978.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd03s2uwj30qz0kmabu_hua04f461493837df3586c2d51d1a9834e_80658_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd03s2uwj30qz0kmabu_hua04f461493837df3586c2d51d1a9834e_80658_6b89d0d5d9d90bcc8b7ebb7d75b326cb.webp&#34;
               width=&#34;760&#34;
               height=&#34;581&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kong 的部分插件功能&lt;/p&gt;
&lt;p&gt;Kong 通过云原生、混合和本地部署无缝连接 API 和微服务，便于程序员开发可扩展的微服务应用，推动业务增长。凭借高性能的开源内核和 AI 技术以及机器学习，Kong 将实现全方位的服务生命周期管理，覆盖前期到后期全过程，帮助客户搭建和管理创新产品及服务。它服务于全球 5000 强企业，帮助程序员更方便地开发和管理高性能、可扩展的微服务应用，推动业务增长。&lt;/p&gt;
&lt;p&gt;从业务和融资上来讲，2018 年，Kong 订单大幅增加，公司员工数翻倍，已服务超过 100 家企业客户，包括雅虎日本、法拉利、SoulCycle、WeWork 等，开源软件下载量超过 5400 万次，收入为 500 万美元。2019 年，Kong 完成了 Index Ventures 领投，GGV 纪源资本、World InnovationLab 跟投，老股东 Andreessen Horowitz、Charles Rivers Ventures 追加的 4300 万美元 C 轮融资，至此 Kong 累计融资共计 7100 万美元。&lt;/p&gt;
&lt;p&gt;4、RapidAPI：全球最大 API 市场&lt;/p&gt;
&lt;p&gt;和 Kong 紧密相关的另外一家企业是 RapidAPI，2017 年，Kong 的母公司 Mashape 将其 API 市场业务与&lt;a href=&#34;https://rapidapi.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RapidAPI&lt;/a&gt;合并，从而组成了世界上最大的 API 市场。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczy3s35j30ca09mwet_hu467a3bcb7dff9f1fb73d501798615ad9_18248_f723841dd66c9128a550411a93187ca2.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczy3s35j30ca09mwet_hu467a3bcb7dff9f1fb73d501798615ad9_18248_bf5ea15e4f804c72dcbd4359c14d6f20.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczy3s35j30ca09mwet_hu467a3bcb7dff9f1fb73d501798615ad9_18248_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczy3s35j30ca09mwet_hu467a3bcb7dff9f1fb73d501798615ad9_18248_f723841dd66c9128a550411a93187ca2.webp&#34;
               width=&#34;442&#34;
               height=&#34;346&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;市场研究机构 Ovum Research 曾经表示，API 经济在迅迅猛发展，到 2018 年将成为产值高达 2.2 万亿美元的市场。合并后，RapidAPI 成为了这个市场的主要提供商之一。&lt;/p&gt;
&lt;p&gt;RapidAPI 的首席执行官吉纳在宣布合并的博文中表示，“软件相互连接起来后，其功效就要大得多。不妨想一想。你使用 Facebook 登录到某个游戏应用程序，就能看到玩游戏的所有朋友。当亚马逊的购买门户网站与仓库存货连接起来后，你就能实时获得发货估计日期。如果你在订购机票呢？已经在你的谷歌日历中预定了航班。”吉诺补充道，API 正是让那些连接成为可能的秘诀。“它们让不同的软件得以彼此联系，共享信息，并且简化我们的生活。”&lt;/p&gt;
&lt;p&gt;吉纳在博文中表示这只是开了个头。API 正在迅速发展，打开之前紧闭的许多大门。使用 API，开发人员就有可能从任何地方来访问服务，比如 IBM 公司的超级计算机和谷歌的机器学习模型，这就意味着他们能够充分利用比以前处理的任何资源丰富得多的资源。&lt;/p&gt;
&lt;p&gt;吉纳说：“我们想要让广大开发人员更容易寻找、测试和连接 API。我们的计划始终未变，那就是将世界上的所有 API 统统集中到一个地方。将 Mashape API 市场合并到 RapidAPI 让我们离实现这个目标比以往更近了一步。现在我们每月总共有 370000 名开发人员在调用 3000 亿次 API。也就是说，每秒的 API 调用超过 100000 次。”&lt;/p&gt;
&lt;p&gt;RapidAPI 的市场里包括各种各样类型的 API，例如天气、体育、科技、通讯、图像处理等等，例如获取新闻信息、实时体育比赛比分、天气信息，甚至还包括新冠病毒 API 分类。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd05lhlxj30n30ehta1_hu149d8c9145ed3b0a3846138c90a16a65_62691_3ff96d25929937d01d733a9905332a1a.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd05lhlxj30n30ehta1_hu149d8c9145ed3b0a3846138c90a16a65_62691_126339cffe1f506356d7bcaeaedcc6e6.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd05lhlxj30n30ehta1_hu149d8c9145ed3b0a3846138c90a16a65_62691_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd05lhlxj30n30ehta1_hu149d8c9145ed3b0a3846138c90a16a65_62691_3ff96d25929937d01d733a9905332a1a.webp&#34;
               width=&#34;760&#34;
               height=&#34;476&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;开发商可以自由的为自己的 API 接口定价，下图是 Twilio SMS 接口的报价方案。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczwpo62j30u008e0tk_hu189e10b893a77057accfe12ed4080bf8_44562_243aaf5bf2988262d4c385eecb9bfb49.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczwpo62j30u008e0tk_hu189e10b893a77057accfe12ed4080bf8_44562_d2d138a7c37ab5546324e6ee03429f04.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczwpo62j30u008e0tk_hu189e10b893a77057accfe12ed4080bf8_44562_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczwpo62j30u008e0tk_hu189e10b893a77057accfe12ed4080bf8_44562_243aaf5bf2988262d4c385eecb9bfb49.webp&#34;
               width=&#34;760&#34;
               height=&#34;213&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;2019 年，RapidAPI 完成了由微软领投、A16Z 等跟投的 2500 万美元 B 轮融资，历史累计融资达到 3750 万美元。RapidAPI 表示，它将利用这笔新筹集的资金扩大其 API 市场规模，并推动其新发布的 RapidAPI for Teams 产品。它是一个自助服务平台，使开发人员能够发布，管理和协调 API 和微服务，这些是用于构建现代应用程序的常用组件。&lt;/p&gt;
&lt;p&gt;5、Mulesoft：API 集成/iPaaS/API 管理领头羊&lt;/p&gt;
&lt;p&gt;1）从 SOA 讲起&lt;/p&gt;
&lt;p&gt;讲 API 管理之前，我们得先来说说前文提到过的 SOA（Service-Oriented Architecture，面向服务的架构）。&lt;/p&gt;
&lt;p&gt;简单地说，一个企业建设了许多业务系统，每个系统都拥有自己的数据，那么如何将这些分散各处的数据打通，从而可以进一步加以利用呢？&lt;/p&gt;
&lt;p&gt;这就涉及到企业应用集成（EAI，Enterprise Application Integration）这个领域了。&lt;/p&gt;
&lt;p&gt;传统上，企业应用集成很多是利用 ETL（Extract-Transform-Load，抽取转换加载）工具，把不同系统里的数据经过抽取、过滤、转换，最终导入到一个集中的数据仓库里，然后再做整合应用。但是这种做法也存在很多问题。&lt;/p&gt;
&lt;p&gt;一是只认数据，没有脑子。在数据汇集的过程中，只能针对数据格式本身进行一些处理，很难利用业务系统原有的业务逻辑。&lt;/p&gt;
&lt;p&gt;二是随着各个系统数据体量越来越大，把所有系统的数据都汇到一个数据仓库里就变得越来越困难。&lt;/p&gt;
&lt;p&gt;为了解决这样的问题，SOA 应运而生，就是企业中每个系统都对外发布自己的服务，那么系统之间的集成，就可以通过调用对应系统的服务来解决了。&lt;/p&gt;
&lt;p&gt;但是，随着企业拥有的系统越来越多，这种系统之间相互调用服务接口的集成方式又遇到了新麻烦。&lt;/p&gt;
&lt;p&gt;可能每两个系统之间都需要相互调用服务，这最终就会演变成一个复杂的蜘蛛网结构，使得整个集成变得越来越脆弱，难以维护。&lt;/p&gt;
&lt;p&gt;为了解决这个新问题，ESB（Enterprise Service Bus，企业服务总线）的概念被提出来了，就是把每个系统的服务接口都对接到 ESB 上，这样在系统集成的时候，只需要跟总线打交道，而不再需要直接跟所有其它系统打交道了，从而大大简化了集成的复杂度。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczrjx9cj30u00e03z6_hu295338a468a7fb8954ccffee2167336f_36572_82f758a16799ebee5d2e6785fec99ab2.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczrjx9cj30u00e03z6_hu295338a468a7fb8954ccffee2167336f_36572_1ea560304833cbf56551f29dc86c88d2.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczrjx9cj30u00e03z6_hu295338a468a7fb8954ccffee2167336f_36572_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczrjx9cj30u00e03z6_hu295338a468a7fb8954ccffee2167336f_36572_82f758a16799ebee5d2e6785fec99ab2.webp&#34;
               width=&#34;760&#34;
               height=&#34;355&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用 ESB 前后&lt;/p&gt;
&lt;p&gt;2）Mulesoft&lt;/p&gt;
&lt;p&gt;2018 年 3 月，美国 SaaS 巨头 Salesforce 花费 65 亿美元收购 iPaaS 代表企业 Mulesoft，Mulesoft 于 2017 年在纽交所上市，市值约 30 亿美元。Mulesoft 的核心产品是企业软件集成平台 Anypoint Platform（旧称 Mule ESB），客户可以在 Anypoint 上集成所有业务系统的服务，实现本地系统与云、以及云与云服务的集成。Anypoint Platform/Mule ESB 是世界上使用最广泛的开源 ESB 产品，已拥有超过数百万的下载量，以及来自世界各地数十万个开发人员，财富 500 强中 35% 的企业、全球 10 大银行中的 5 家均使用了该平台。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczs0sxbj30m80bkq3q_hua6d0f902ed5d20eb58871959ac06ef6d_42312_287349a65bae686d403cc9dd0737f174.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczs0sxbj30m80bkq3q_hua6d0f902ed5d20eb58871959ac06ef6d_42312_81285233a214d090c10eb1b5def23312.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczs0sxbj30m80bkq3q_hua6d0f902ed5d20eb58871959ac06ef6d_42312_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczs0sxbj30m80bkq3q_hua6d0f902ed5d20eb58871959ac06ef6d_42312_287349a65bae686d403cc9dd0737f174.webp&#34;
               width=&#34;760&#34;
               height=&#34;395&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Mule ESB&lt;/p&gt;
&lt;p&gt;尽管只有一个产品，但从 Gartner 的划分标准来看，Mulesoft 同时踩在了两个领域里：全生命周期 API 管理和企业集成平台即服务（iPaaS，Enterprise Integration Platform as a Service）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd04q4fyj30i20ivt9b_hu400e8f37e52ecb9926f117516ab48213_34488_de59c8ac6fc5a957ed9d9daf1bdc3293.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd04q4fyj30i20ivt9b_hu400e8f37e52ecb9926f117516ab48213_34488_dd40c1c79d1f7677019d2a88c26436a3.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd04q4fyj30i20ivt9b_hu400e8f37e52ecb9926f117516ab48213_34488_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd04q4fyj30i20ivt9b_hu400e8f37e52ecb9926f117516ab48213_34488_de59c8ac6fc5a957ed9d9daf1bdc3293.webp&#34;
               width=&#34;650&#34;
               height=&#34;679&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Gartner 魔力象限：全生命周期 API 管理&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd063o41j30h70iowfd_hu55b3de6da013206bd2b9cc9679a1f612_28239_33452debbbd4e42a357d9eb54c81fb79.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd063o41j30h70iowfd_hu55b3de6da013206bd2b9cc9679a1f612_28239_2adf590b53133757a6b3c193001c0c24.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd063o41j30h70iowfd_hu55b3de6da013206bd2b9cc9679a1f612_28239_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd063o41j30h70iowfd_hu55b3de6da013206bd2b9cc9679a1f612_28239_33452debbbd4e42a357d9eb54c81fb79.webp&#34;
               width=&#34;619&#34;
               height=&#34;672&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Gartner 魔力象限：企业集成平台即服务&lt;/p&gt;
&lt;p&gt;Mule ESB 同时包括开源和商业版本，在各个技术论坛上遍布其技术教程。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd00gjhhj30jd0gyacl_huab54f47566fb5e68f72a034a5ffb4f30_109881_bc5822bad00b8d39ed4aea2f7db9c8f3.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd00gjhhj30jd0gyacl_huab54f47566fb5e68f72a034a5ffb4f30_109881_717a36fb36948439076d24f3faf2216f.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd00gjhhj30jd0gyacl_huab54f47566fb5e68f72a034a5ffb4f30_109881_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd00gjhhj30jd0gyacl_huab54f47566fb5e68f72a034a5ffb4f30_109881_bc5822bad00b8d39ed4aea2f7db9c8f3.webp&#34;
               width=&#34;697&#34;
               height=&#34;610&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Mule 开源版讨论文章&lt;/p&gt;
&lt;p&gt;Mulesoft 的成长历程非常具有参考意义，他们瞄准了一个有 7000 亿美元空间的市场，目标是解决一个十分困难的 IT 问题 - 集成。在摸索过程中 Mulesoft 不断优化其产品形态和销售方式，例如针对大客户需要的不仅是平台提供的通用功能，还需要更复杂的综合服务。于是 MuleSoft 把他们的销售方式从出售可靠的集成功能，变成了向高级管理人员出售提升企业连接能力的愿景和相应的解决方案，客单价也从 10-30000 美元提升到了 500 万美元。&lt;/p&gt;
&lt;p&gt;3）应用场景与案例&lt;/p&gt;
&lt;p&gt;Mule ESB 的常见应用场景例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旧系统改造，开放系统的服务能力。举个例子，企业有一个电商系统，需要调用 SAP ERP 的订单接口来创建订单，这个时候需要将 SAP 的订单服务暴露成流行的 Restful API，以方便电商系统调用。使用 Mule ESB 可以轻松实现。&lt;/li&gt;
&lt;li&gt;系统集成。企业之间的数据交换，竟然有一半以上是文件的形态进行的，这在互联网思维普及的今天，是不容易想象的。在 10 年前，企业间交换数据采用文件形态的比重占 60%，当时普遍认为这个比重会迅速下降，最终以接口服务形态进行交换的比重会占绝大多数。然而 10 年后直至今天，采用文件形态的依然占 51% 的比重。其实仔细想想，也不无合理。两个对等企业之间，行业上下游多个企业之间，不同系统之间的进行数据交换，采用文件的形式，可能是最简单便捷的方式。举个例子，很多系统之间数据交互可能还是用 FTP 目录。尤其是企业跟企业之间的数据交互，比如，A 企业丢一个 EDI 文件到 B 企业的 FTP 目录，然后 B 企业会从 FTP 目录下载解析并放置到数据库。这个场景用 Mule ESB 实现也很方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfkr0b0eq5j30e604pdfv_hu1f5ddf0575d2c84e40ddaf2b89032271_11334_d51e46578fe85deaa1707c448e03158f.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfkr0b0eq5j30e604pdfv_hu1f5ddf0575d2c84e40ddaf2b89032271_11334_7b8e74a6c2dad1c26dde8c73258841b9.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfkr0b0eq5j30e604pdfv_hu1f5ddf0575d2c84e40ddaf2b89032271_11334_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfkr0b0eq5j30e604pdfv_hu1f5ddf0575d2c84e40ddaf2b89032271_11334_d51e46578fe85deaa1707c448e03158f.webp&#34;
               width=&#34;510&#34;
               height=&#34;169&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;4）Salesforce 为什么收购 Mulesoft&lt;/p&gt;
&lt;p&gt;Salesforce 最初为中小企业提供 SaaS 的 CRM，而随着大客户越来越多，定制化、个性化的需求也越来强烈，所以就需要提供 PaaS 平台解决个性化、定制化的问题。&lt;/p&gt;
&lt;p&gt;而这个定制化，最开始只是以 Salesforce 为核心的功能延伸及简单扩展，而随着个性化需求的不断深入，这种定制已经逐步演变为更大规模的多个骨干数据源之间的数据集成与交换，Salesforce 可能只是多个数据源之一。&lt;/p&gt;
&lt;p&gt;所以也可以说，数据集成是 PaaS 平台的上层建筑，Salesforce 需要帮助客户解决整合不同数据源所带来的挑战。&lt;/p&gt;
&lt;p&gt;收购之后，Salesforce 会将 MuleSoft 植入进 Salesforce Integration Cloud，从而帮助客户连接多个数据源，并计划在之后推出集成云。&lt;/p&gt;
&lt;p&gt;所以，可以看出 Salesforce 其实更在乎的是集成（Integration）这个词。&lt;/p&gt;
&lt;p&gt;5）iPaaS、API 管理与 API 集成&lt;/p&gt;
&lt;p&gt;iPaaS 的集成不光是针对云服务，也包括本地系统，这样就解决了混合云模式下的集成问题。iPaaS 集成的范畴，除了 API 接口之外，一般还会包括更多种类的协议（比如 FTP、数据库），也包括对于文件数据的集成。&lt;/p&gt;
&lt;p&gt;从这个角度来理解，API 管理更关注 API 的治理与整合，iPaaS 关注更大范畴的集成，包含 API 集成的概念。&lt;/p&gt;
&lt;p&gt;6）SOA、ESB 与微服务的关系&lt;/p&gt;
&lt;p&gt;微服务架构和 SOA 架构非常类似，微服务是 SOA 的升华，只不过微服务架构强调的是“业务需要彻底的组件化及服务化”，原单个业务系统会被拆分为多个可以独立开发、设计、部署运行的小应用，这些小应用间通过服务化完成交互和集成。&lt;/p&gt;
&lt;p&gt;ESB 是一种集中式服务治理的架构，看上去微服务中不需要 ESB，Martin Fowler 也不赞同在微服务架构中继续用 ESB。&lt;/p&gt;
&lt;p&gt;我们下面要介绍到的下一代微服务架构核心 - 服务网格*，则可以视为分布式的 ESB。*&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务 2.0：服务网格与 Serverless&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、服务网格&lt;/p&gt;
&lt;p&gt;微服务当前遇到的挑战包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术门槛高：开发团队在实施微服务的过程中，除了基础的服务发现、配置中心和鉴权管理之外，团队在服务治理层面面临了诸多的挑战，包括负载均衡、熔断降级、灰度发布、故障切换、分布式跟踪等，这对开发团队提出了非常高的技术要求。&lt;/li&gt;
&lt;li&gt;代码侵入性强：Spring Cloud、Dubbo 等主流的微服务框架都对业务代码有一定的侵入性，技术升级替换成本高，导致开发团队配合意愿低，微服务落地困难。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决上述问题，号称微服务 2.0 的服务网格（Service Mesh）应运而生。服务网格这个词最早由著名开源服务网格项目 Linkerd 所在的 Buoyant 公司 CEO William Morgan 所提出。按照他的定义，服务网格是一个软件基础设施层，用于控制和监视微服务应用程序中的内部、服务到服务的流量。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd04denmj30u00d8myl_hu9e0839c0ecf53e4bc9080829fc5246d1_64437_f4df3f537e9fe50e1ca06c532b6fe1e9.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd04denmj30u00d8myl_hu9e0839c0ecf53e4bc9080829fc5246d1_64437_63a4bf74249c6bbad679d390a571cc7a.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd04denmj30u00d8myl_hu9e0839c0ecf53e4bc9080829fc5246d1_64437_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd04denmj30u00d8myl_hu9e0839c0ecf53e4bc9080829fc5246d1_64437_f4df3f537e9fe50e1ca06c532b6fe1e9.webp&#34;
               width=&#34;760&#34;
               height=&#34;335&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;服务网格架构&lt;/p&gt;
&lt;p&gt;Sidecar 是服务网格中的核心组成部分，可以看到，上图中每一个微服务都配备了一个 Sidecar。此时用户只需要关心业务逻辑，而不用关心服务治理等非业务功能，非业务功能都由 Sidecar 负责，接管对应服务的入流量和出流量，并将微服务架构中的服务订阅、服务发现、熔断、限流等功能从服务中抽离到 Sidecar 中。&lt;/p&gt;
&lt;p&gt;服务网格和 API 网关是两个联系非常紧密的概念，它们的用途既不同，但是在某些方面又相互重叠。在某种程度上，我们可以认为服务网格是一个&lt;strong&gt;分布式的、微观层面的 API 网关&lt;/strong&gt;，解决微服务服务发现、负债均衡、流量控制等需求。在具体用途上，API 网关处理的是所谓南北向流量即内外部请求；而服务网格处理的是东西向流量即内部服务相互间的访问。想深入了解两者区别的读者可以仔细阅读《&lt;a href=&#34;https://www.infoq.cn/article/4FJXNTHJMio6g75uSX0h%3Ffrom%3Dtimeline&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh 和 API Gateway 关系深度探讨&lt;/a&gt;》这篇文章。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczvrqm9j30u00cu3za_huf63a1dca2148ddbdefd6cd7f9766fe11_39742_56d18d3c0f8b47b29a464b912db2d51a.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczvrqm9j30u00cu3za_huf63a1dca2148ddbdefd6cd7f9766fe11_39742_a7fafee41a5e1aa81a7cdc4eda1ec015.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczvrqm9j30u00cu3za_huf63a1dca2148ddbdefd6cd7f9766fe11_39742_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczvrqm9j30u00cu3za_huf63a1dca2148ddbdefd6cd7f9766fe11_39742_56d18d3c0f8b47b29a464b912db2d51a.webp&#34;
               width=&#34;760&#34;
               height=&#34;325&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;南北向流量 vs 东西向流量&lt;/p&gt;
&lt;p&gt;服务网格相关的著名项目包括 Linkerd、Envoy 和最受欢迎的服务网格框架 Istio。Kong 也于 2019 年发布了基于 Envoy 的开源服务网格产品 Kuma。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd02bfu3j30ox0etaap_hu6884e1d689084912d61e5518cd14a4fd_36230_b402efed25ec17c0542be29fdc759d14.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd02bfu3j30ox0etaap_hu6884e1d689084912d61e5518cd14a4fd_36230_09624d75e7dc9c58c81e08b704fdd742.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd02bfu3j30ox0etaap_hu6884e1d689084912d61e5518cd14a4fd_36230_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd02bfu3j30ox0etaap_hu6884e1d689084912d61e5518cd14a4fd_36230_b402efed25ec17c0542be29fdc759d14.webp&#34;
               width=&#34;760&#34;
               height=&#34;452&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kong 的服务网格产品：Kuma&lt;/p&gt;
&lt;p&gt;下图是 CNCF Landscape 里服务网格分类所罗列的项目，其中 Linkerd 正由 CNCF 进行孵化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczuu6edj309j0asdgl_hu553f56a815f4b0227800c376f4146762_26201_9df71b3888b888a61ab3c1b90180b3d3.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczuu6edj309j0asdgl_hu553f56a815f4b0227800c376f4146762_26201_b40f7d2ccba84a332d3c9047dc108b9b.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczuu6edj309j0asdgl_hu553f56a815f4b0227800c376f4146762_26201_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczuu6edj309j0asdgl_hu553f56a815f4b0227800c376f4146762_26201_9df71b3888b888a61ab3c1b90180b3d3.webp&#34;
               width=&#34;343&#34;
               height=&#34;388&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;2、Serverless&lt;/p&gt;
&lt;p&gt;Serverless（无服务器架构）这个概念在 2012 年时便已经存在，比微服务和服务网格的概念出现都要早，但是直到微服务概念大红大紫之后，Serverless 才重新又被人们所关注。&lt;/p&gt;
&lt;p&gt;Serverless 是一种构建和管理基于微服务架构的完整流程，它与传统架构的不同之处在于，完全由第三方管理，由事件触发，存在于无状态、暂存的计算容器内。Serverless 相关的重要概念包括 FaaS（Functions as a Service，函数即服务）。开发者把函数上传到云厂商的 FaaS 平台，函数只在被请求时才实例化运行，然后被销毁，其它时候不占用任何服务器资源，完全实现按需使用，大幅度降低了服务器占用和成本。&lt;/p&gt;
&lt;p&gt;Serverless 通常适用于实时性要求不高、无状态的场景，例如突发事件处理、数据统计分析、视频解码、离线批量计算等等，像 AWS FaaS 平台 Lambda 限制用户功能必须在 15 分钟内完成。&lt;/p&gt;
&lt;p&gt;相较服务网格，Serverless 概念更为超前，虽然 AWS Lambda、阿里云等许多平台都已经提供对其的支持，但是目前仍处于发展早期，无论是成熟项目数量和企业应用程度都相对有限。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd070ovgj30u00gwdi1_hu257dda19e0b3dc4037144d36b57e5688_93320_d527324ccc993a45a94ec4870485b89e.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd070ovgj30u00gwdi1_hu257dda19e0b3dc4037144d36b57e5688_93320_0cb4c1e032f4e7b900da8b4960f23fa7.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd070ovgj30u00gwdi1_hu257dda19e0b3dc4037144d36b57e5688_93320_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd070ovgj30u00gwdi1_hu257dda19e0b3dc4037144d36b57e5688_93320_d527324ccc993a45a94ec4870485b89e.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;FaaS Landscape&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhczw88rrj30u00b6jsp_hu99a997ebe77eac4e2f74094c6c094f55_62788_d0c4aa41b0a5db7a3942efb1b8934676.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhczw88rrj30u00b6jsp_hu99a997ebe77eac4e2f74094c6c094f55_62788_d7e39b88092d42414f9bc1dad86c146d.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhczw88rrj30u00b6jsp_hu99a997ebe77eac4e2f74094c6c094f55_62788_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhczw88rrj30u00b6jsp_hu99a997ebe77eac4e2f74094c6c094f55_62788_d0c4aa41b0a5db7a3942efb1b8934676.webp&#34;
               width=&#34;760&#34;
               height=&#34;283&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;CNCF Serverless Landscape&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务 vs 宏服务：新的抉择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近，Uber 支付体验平台的工程经理 Gergely Orosz 发布推文表示他们的架构方向已经发生了变化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd07jalej30kd0epgn0_hue6f8cf4bb87a4d0df191155d7792acb9_65797_cb7adbdc96b461bd48aa18d2ef29d859.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd07jalej30kd0epgn0_hue6f8cf4bb87a4d0df191155d7792acb9_65797_9bf99ad3201a86aa92e36b175e0aa289.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd07jalej30kd0epgn0_hue6f8cf4bb87a4d0df191155d7792acb9_65797_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd07jalej30kd0epgn0_hue6f8cf4bb87a4d0df191155d7792acb9_65797_cb7adbdc96b461bd48aa18d2ef29d859.webp&#34;
               width=&#34;733&#34;
               height=&#34;529&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“声明一下，在 Uber，我们正将许多微服务转移到@copyconstruct 所称的 Macroservices 宏服务（大小适中的服务）。
确切地说，B/C 测试和维护成千上万的微服务不仅很难——它可能会带来更多的长期麻烦，而不是解决短期问题。
微服务确实可以帮助团队在早期快速推进。
等你意识到服务越少越好时，已为时已晚。你需要解决很多服务的“困难”部分。
我们在不断增加更多的服务，但也在停止使用服务，并且会更慎重的思考新的服务。“&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;全部的上下文可以在&lt;a href=&#34;https://www.sohu.com/a/387618765_683048&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;阅读。有一篇英文文献中这样描述 Macroservices 宏服务：宏服务应该定义为运行 2-20 个单独服务的应用程序体系结构，每个服务代表一个中等大小的代码库，可处理业务中定义明确的部分。宏服务的关键是拆分服务，最大程度地从拆分中获得收益，同时最大程度地降低运行多个服务的开销。通俗点讲，宏服务介于单体服务到微服务之间，关注的不再是某一个细节点，而是一个业务点。&lt;/p&gt;
&lt;p&gt;实际上，宏服务目前的定义并不清晰，影响和实践相当有限，也并非比微服务更优的解决方案，本质还是不同企业和团队在架构演进中对于系统复杂性的不同度量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微服务的理念不同的团队有不同的实践，例如微服务如何拆分、组织架构如何搭建、技术栈如何选择。&lt;/p&gt;
&lt;p&gt;我们理解，微服务是云原生的核心，后面要介绍到的容器（及 Docker）和 Kubernetes 是实现的技术方法和手段，DevOps 是配合的文化和研发流程，但是微服务带来的启发，更多是思维方式上的转变。&lt;/p&gt;
&lt;h2 id=&#34;第四部分容器和-docker&#34;&gt;第四部分：容器和 Docker&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;虚拟化与容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在容器技术之前，业界的网红是虚拟机。虚拟机技术的代表是 VMware 和 OpenStack，我在虚拟化与超融合系列里做过介绍。很多人都用过虚拟机，就是在操作系统里安装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。在“子电脑”里，可以和正常电脑一样运行程序，例如微信、Word。“子电脑”和“子电脑”之间，相互隔离互不影响。&lt;/p&gt;
&lt;p&gt;虚拟机虽然可以隔离出很多“子电脑”，但占用空间大，启动慢，虚拟机软件可能还要花钱（例如 VMware）。而容器技术恰好没有这些缺点，它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”），启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个 Docker 容器）。此外它占的空间很小，虚拟机一般要几 GB 到几十 GB 的空间，而容器只需要 MB 级甚至 KB 级。虚拟机和以 Docker 为代表的容器都是虚拟化技术，不过容器属于轻量级的虚拟化。下面是两者的主要对比。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1pt1mfj30k20b4wf5_hue84f2835a4720a147baffe7c385f40b5_36930_b80952304e05f79a0f5c5befeb62ef07.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1pt1mfj30k20b4wf5_hue84f2835a4720a147baffe7c385f40b5_36930_4d38e0397ebff2600a1d63be45b03b93.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1pt1mfj30k20b4wf5_hue84f2835a4720a147baffe7c385f40b5_36930_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1pt1mfj30k20b4wf5_hue84f2835a4720a147baffe7c385f40b5_36930_b80952304e05f79a0f5c5befeb62ef07.webp&#34;
               width=&#34;722&#34;
               height=&#34;400&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker 的源起&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们再来看看 Docker，Docker 本身并不是容器，它是创建容器的工具，是应用容器引擎。虽然 Docker 把容器技术推向了巅峰，但容器技术却不是 Docker 发明的。实际上，容器技术连新技术都算不上，因为它的诞生和使用有些年头了，像最早的容器 LXC 发布于 2008 年。&lt;/p&gt;
&lt;p&gt;Docker 本来是做 PaaS 的公司，原来叫做 DotCloud，成立于 2010 年。但比起 Pivotal、Red Hat 等著名企业，DotCloud 运营并不成功。眼看就要失败的时候，2013 年 DotCloud 决定开源自己的容器项目 Docker。但是短短几个月，Docker 迅速崛起，吸引大量的开发者使用。随着 Docker 在开发者中越来越流行，2013 年 10 月，DotCloud 公司正式更名为 Docker，2014 年 8 月，Docker 宣布把 PaaS 业务出售，开始专心致志做 Docker。&lt;/p&gt;
&lt;p&gt;Docker 一词意为码头工人，而它的 logo 则是一个托着许多集装箱的鲸鱼，非常形象：Docker 是鲸鱼，而集装箱则是一个个的容器。在 Docker 的官网上，对于容器有一个一句话的解释“A standardized unit of software”，即“软件的一个标准化单元”。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1q9cxsj308c08caa3_hu3ed26c014721b5cf84a0660c46755f31_12372_ff4185ea4763d95885315952cc66389a.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1q9cxsj308c08caa3_hu3ed26c014721b5cf84a0660c46755f31_12372_8434f8c18a5b381ae3531ff19d6b02ae.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1q9cxsj308c08caa3_hu3ed26c014721b5cf84a0660c46755f31_12372_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1q9cxsj308c08caa3_hu3ed26c014721b5cf84a0660c46755f31_12372_ff4185ea4763d95885315952cc66389a.webp&#34;
               width=&#34;300&#34;
               height=&#34;300&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;下面的图片比较了 Docker 和传统虚拟化的不同之处，容器是在操作系统层面上实现虚拟化，而传统方式是在硬件层面实现，所以导致两者的特性有很大区别，Docker 更小更轻。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1rmwc1j30u00chab5_hu7ce6face9045524f817fa34ff27414be_53354_a78e262d65ab9a75910cc8bdac7c86ca.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1rmwc1j30u00chab5_hu7ce6face9045524f817fa34ff27414be_53354_7b895b00960eab57d37d7e5494dc1021.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1rmwc1j30u00chab5_hu7ce6face9045524f817fa34ff27414be_53354_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1rmwc1j30u00chab5_hu7ce6face9045524f817fa34ff27414be_53354_a78e262d65ab9a75910cc8bdac7c86ca.webp&#34;
               width=&#34;760&#34;
               height=&#34;316&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Docker vs 虚拟化&lt;/p&gt;
&lt;p&gt;而 Docker 与传统的 Linux 容器也并不完全一致。Docker 技术最初是建立在 LXC 技术之上的，大多数人都把 LXC 技术与传统的 Linux 容器联系在一起，尽管后来它已经摆脱了这种依赖性。LXC 作为轻量级虚拟化很有用，但它没有很好的开发人员或用户体验。Docker 技术带来的不仅仅是运行容器的能力，它还简化了创建和构建容器、加载镜像和镜像版本控制等过程。传统的 Linux 容器使用可以管理多个进程的 init 系统，这意味着整个应用可以作为一个整体运行。Docker 鼓励将应用程序分解为它们各自的进程，并提供了实现这一点的工具，这种粒度有不少优点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1t19epj30u00c03zp_hu14212703284908e851c0a8ec92a9d260_56405_0afb4fc3226c75aa792547237e4ae02d.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1t19epj30u00c03zp_hu14212703284908e851c0a8ec92a9d260_56405_168bd667acbef4b15bec6b7b98312d9c.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1t19epj30u00c03zp_hu14212703284908e851c0a8ec92a9d260_56405_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1t19epj30u00c03zp_hu14212703284908e851c0a8ec92a9d260_56405_0afb4fc3226c75aa792547237e4ae02d.webp&#34;
               width=&#34;760&#34;
               height=&#34;304&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;传统 Linux 容器 vs Docker&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker 解决的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，Linux 上我们不愉快的经历之一就是安装软件。因为系统硬件、操作系统环境不一样，软件包有不同的依赖性，所以必须要安装完软件依赖路径上的所有包，这个链条之长，往往要耗费几小时甚至几天的时间。例如下面的案例，我要安装 Docker，系统提示我必须要先安装 selinux-policy、selinux-policy-base、selinux-policy-targeted 三个相关模块。而我安装 selinux-policy 的时候，又提示要先安装 python；安装 python 的时候，又提示我要先安装_bz2、_curses、_curses_panel 等等模块…&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1vzikgj30n30463zc_hue7e9b77434055a534fa2ea3cf02d6e72_43552_c5c3479df092d58400fb20799ce48ae4.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1vzikgj30n30463zc_hue7e9b77434055a534fa2ea3cf02d6e72_43552_f3592a6ed3014be1ee33d800dd6b5d72.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1vzikgj30n30463zc_hue7e9b77434055a534fa2ea3cf02d6e72_43552_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1vzikgj30n30463zc_hue7e9b77434055a534fa2ea3cf02d6e72_43552_c5c3479df092d58400fb20799ce48ae4.webp&#34;
               width=&#34;760&#34;
               height=&#34;137&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1wfhauj30n309ewf7_huec022cc46087f9f56b10fdbf4081e477_38855_ab68cdaf9fd009929f178584a9dd514c.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1wfhauj30n309ewf7_huec022cc46087f9f56b10fdbf4081e477_38855_80c6e5a0d99d95a966b41774329d9a1b.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1wfhauj30n309ewf7_huec022cc46087f9f56b10fdbf4081e477_38855_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1wfhauj30n309ewf7_huec022cc46087f9f56b10fdbf4081e477_38855_ab68cdaf9fd009929f178584a9dd514c.webp&#34;
               width=&#34;760&#34;
               height=&#34;309&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这就是由于环境不统一带来的巨大问题，每天在世界各地的数千万台机器上都会重复上演无数次。那么，如果服务器环境能够标准化，那我们安装任何软件只需要一个版本就可以解决问题。&lt;/p&gt;
&lt;p&gt;同时，如果所有服务器环境统一、标准化，还能保留上面的配置、安装的软件和应用，对于我们来讲就更加有用。Docker 正是在操作系统之上实现了这个标准化、统一化的运行环境，并且把各种不同的配置和应用存储成镜像，供未来使用。这有点类似于我们熟悉的 Ghost 或者虚拟光驱，把需要的环境和状态保留为镜像，随时恢复、随时使用。不过 Ghost 基于操作系统，镜像是一个大文件，管理起来并不方便，恢复速度也很慢，同时不支持跨平台的镜像恢复；而虚拟光驱则是基于软件层面，使用范围有限；而 Docker 正处于两者之间，能完成更多功能的同时，还实现了镜像的快速加载和运行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1s43n7j30is0cuaay_hub8bb3f1e4dd3747eeab5e59e1e6c2bc2_46147_96e05aa61d2036d34535b2bb84d48e4e.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1s43n7j30is0cuaay_hub8bb3f1e4dd3747eeab5e59e1e6c2bc2_46147_957f45f5e0993fe2d674c9e3fb571b90.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1s43n7j30is0cuaay_hub8bb3f1e4dd3747eeab5e59e1e6c2bc2_46147_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1s43n7j30is0cuaay_hub8bb3f1e4dd3747eeab5e59e1e6c2bc2_46147_96e05aa61d2036d34535b2bb84d48e4e.webp&#34;
               width=&#34;676&#34;
               height=&#34;462&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Ghost 软件&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1sjye9j30in0cujsb_huf6732b3a01654c83b4dcfca1dad27445_47477_e2c17a541dac41a71e32e72b23848baa.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1sjye9j30in0cujsb_huf6732b3a01654c83b4dcfca1dad27445_47477_8431747525a414eb139336cb250a0a3c.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1sjye9j30in0cujsb_huf6732b3a01654c83b4dcfca1dad27445_47477_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1sjye9j30in0cujsb_huf6732b3a01654c83b4dcfca1dad27445_47477_e2c17a541dac41a71e32e72b23848baa.webp&#34;
               width=&#34;671&#34;
               height=&#34;462&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;虚拟光驱软件&lt;/p&gt;
&lt;p&gt;我们在上一部分讲微服务的时候，将其比喻成装配式建筑。把这个比喻用在 Docker 上的话，我们只要提前设计好模板（配置环境、部署软件或服务），就能在工厂（Docker）里批量化生产（说复制可能更加合适）出楼板、墙板、楼梯、阳台等构件和配件（容器所装载的、不同的微服务），这些构件在建筑施工现场经过组装拼合（API 访问），就能成为各种各样的建筑（各种类型的产品和应用）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1vf0mtj30kc0d8my2_hu6e6b45e60beef13ff954074fe8434428_46459_a6aeacf07c980aea1dbaf2863645e1de.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1vf0mtj30kc0d8my2_hu6e6b45e60beef13ff954074fe8434428_46459_90fca1cf5faea55edfe6a16313e43a32.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1vf0mtj30kc0d8my2_hu6e6b45e60beef13ff954074fe8434428_46459_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1vf0mtj30kc0d8my2_hu6e6b45e60beef13ff954074fe8434428_46459_a6aeacf07c980aea1dbaf2863645e1de.webp&#34;
               width=&#34;732&#34;
               height=&#34;476&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;装配式建筑由各种构件组成&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1omhx0j30eo09lq3l_hua98dcb7dc1e2eee07a6c6468e39ec4b9_23648_1cea1ec29f979967912333a0ad27a48d.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1omhx0j30eo09lq3l_hua98dcb7dc1e2eee07a6c6468e39ec4b9_23648_7398c6c9d5f974663877e169e23a88f0.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1omhx0j30eo09lq3l_hua98dcb7dc1e2eee07a6c6468e39ec4b9_23648_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1omhx0j30eo09lq3l_hua98dcb7dc1e2eee07a6c6468e39ec4b9_23648_1cea1ec29f979967912333a0ad27a48d.webp&#34;
               width=&#34;528&#34;
               height=&#34;345&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Docker 与各种概念的关系&lt;/p&gt;
&lt;p&gt;所以，Docker 曾经有一句 Slogan 叫做“Build once，Run anywhere（搭建一次，随处可用）”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker 的核心概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker 技术的三大核心概念，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;镜像（Image）&lt;/li&gt;
&lt;li&gt;容器（Container）&lt;/li&gt;
&lt;li&gt;仓库（Repository）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的例子里，设计出来的模板就是 Docker 镜像，生产（复制）出来的构件就是 Docker 容器，而 Docker 仓库则是集中放置管理 Docker 镜像的地方。&lt;/p&gt;
&lt;p&gt;Docker 镜像是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。&lt;/p&gt;
&lt;p&gt;每一种模板（镜像）能够创建出一种构件，但是模板可以由不同的设计师来设计，提供不同用途、不同风格，例如斜顶式阳台、嵌入式阳台、包豪斯风格、蒙德里安风格等等，所有人相互之间可以共享，这就形成了大的公共仓库。&lt;/p&gt;
&lt;p&gt;Docker 官方提供了&lt;a href=&#34;https://hub.docker.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Hub&lt;/a&gt;来维护管理所有的镜像，只是对于免费用户而言，只能创建一个私有仓库。Docker Hub 里提供了大量高质量的官方镜像，例如 Oracle、MySQL、redis、Ubuntu、Nginx、python、Docker（Docker in Docker！）等等，开发人员需要一个环境的时候，可以直接到 Docker 镜像仓库去查找，减少了大量无谓的环境安装工作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1r6q52j30c507qjs1_hu8f0c8a796e739afe6fa2cc1babff9b84_21614_b06f1686e554391ed667ccd3681eb62c.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1r6q52j30c507qjs1_hu8f0c8a796e739afe6fa2cc1babff9b84_21614_f2cbba2f6da5dfb18f7eed3c96f90033.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1r6q52j30c507qjs1_hu8f0c8a796e739afe6fa2cc1babff9b84_21614_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1r6q52j30c507qjs1_hu8f0c8a796e739afe6fa2cc1babff9b84_21614_b06f1686e554391ed667ccd3681eb62c.webp&#34;
               width=&#34;437&#34;
               height=&#34;278&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Docker Hub&lt;/p&gt;
&lt;p&gt;Docker 创始人曾经公布过一个相关数据，Docker Hub 里镜像的下载数量从 2014 年的 100 万次，3 年内猛增到了 120 亿次。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1pbl3pj30u00hpmy6_hue2519e900fb97cc5b2ea2122cfda3d41_49684_e0c6b0a646930f9c9da68fcbe88825e8.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1pbl3pj30u00hpmy6_hue2519e900fb97cc5b2ea2122cfda3d41_49684_902e50cfc45e623e030df6ef07257c81.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1pbl3pj30u00hpmy6_hue2519e900fb97cc5b2ea2122cfda3d41_49684_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1pbl3pj30u00hpmy6_hue2519e900fb97cc5b2ea2122cfda3d41_49684_e0c6b0a646930f9c9da68fcbe88825e8.webp&#34;
               width=&#34;760&#34;
               height=&#34;448&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;下面是我从 Docker Hub 上拉取一个 hello world 演示镜像，并且运行的示例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1qpe32j30lp0g1ac7_huc240fde2dad66d16d54186ab1bbcd480_94239_52ce650fc7518dea64a1e60e63cb6dfa.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1qpe32j30lp0g1ac7_huc240fde2dad66d16d54186ab1bbcd480_94239_daa27ea7360b6e42d23f68c7e521c565.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1qpe32j30lp0g1ac7_huc240fde2dad66d16d54186ab1bbcd480_94239_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1qpe32j30lp0g1ac7_huc240fde2dad66d16d54186ab1bbcd480_94239_52ce650fc7518dea64a1e60e63cb6dfa.webp&#34;
               width=&#34;760&#34;
               height=&#34;561&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker 的好处&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker 给我们带来的好处非常多，下面简单列举几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更高效的利用系统资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了 Docker，我们可以在一台服务器上运行很多应用，充分利用硬件资源。例如现在我们有一台 Linux 服务器，可以构建不同版本的 Ubuntu 镜像启动，并且为不同的用户分配不同的容器。这样用一台服务器就能虚拟出许多运行不同操作系统的虚拟服务器，而对于用户来说，这些都是透明的。许多公有云采用了容器技术为用户提供服务，所以虚拟化与容器共同成为了现代云计算的基石。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更快速的启动时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无须启动完整的操作系统，因此可以做到秒级甚至毫秒级的启动时间，大大的节约了开发、测试、部署的时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证环境一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开发过程中常见的问题之一是环境一致性问题，由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现，而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，再也不会有在线下开发环境中运行正常，而部署到线上有各种错误的情况了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;持续交付和部署&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于开发和运维人员来说，最希望的是一次创建或配置，可以在任意地方正常运行。开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码，无论在多少台服务器中部署都是如此。Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更轻松的迁移&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易，Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，其运行结果是一致的，因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提升复用性，降低耦合性，维护和扩展更轻松&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。安装 Docker 后，我们可以从 Docker Hub 上获取各种各样的操作系统镜像，这个操作很简单，只需要拉取相应的镜像到本地然后运行即可。另外我们可以将数据库、Web 服务器、缓存服务器运行在不同的容器中，降低了各个服务之间的耦合性、便于扩展，Docker Hub 上有各种各样的优秀镜像，我们可以直接拿来使用，不需要自己搭建，应用的部署就像搭积木一样简单。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现沙盒机制，提高了安全性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于应用运行在容器中，与操作系统隔离开，从而使操作系统基本不可能受到破坏。另外如果应用因为攻击而瘫痪，并不需要重启服务器，直接重启容器或者再启动一个镜像就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器与微服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器是微服务和云原生架构的最佳实现载体。微服务与容器几乎是完美的搭配。单体式架构（Monolithic）变成微服务架构（Microservices），相当于一个全能型变成 N 个专能型，每个专能型分配一个隔离的容器，赋予了最大程度的灵活。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1u6cs4j30ia06t74w_hu58853b61b6cd18c38f4dcdc1005a5259_35063_d091a024211f52f94681f5d1d6176213.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1u6cs4j30ia06t74w_hu58853b61b6cd18c38f4dcdc1005a5259_35063_30df210b787d90f24e30ca091e3ce8d6.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1u6cs4j30ia06t74w_hu58853b61b6cd18c38f4dcdc1005a5259_35063_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1u6cs4j30ia06t74w_hu58853b61b6cd18c38f4dcdc1005a5259_35063_d091a024211f52f94681f5d1d6176213.webp&#34;
               width=&#34;658&#34;
               height=&#34;245&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;服务器势必会走上虚拟化的道路，因为虚拟化有太多的优势，例如前文所说的低成本、高利用率、充分灵活、动态调度等等。而采用容器之后，只需要一台服务器，创建十几个容器，用不同的容器，来分别运行不同用途的服务程序。这些容器，随时可以创建，也可以随时销毁。还能够在不停机的情况下，随意变大，随意变小，随意变强，随意变弱，在性能和功耗之间动态平衡。&lt;strong&gt;所以容器化是云计算的终极形态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果把传统 IT 架构比作传统工厂，容器化比作现代化工厂，那么下一部分我们要讲到的 Kubernetes 则会将现代化工厂进一步提升为智能化无人工厂。那么当 Docker 遇到 Kubernetes 之后将会发生什么有趣的事情？让我们拭目以待。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd1uwnt5j30pu0ejq3q_huf1f0648627ed9232de9fbe1dc83db4f0_41763_16abf3a95ad8a7a5b927711a6bb5b533.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1uwnt5j30pu0ejq3q_huf1f0648627ed9232de9fbe1dc83db4f0_41763_9b91df9a3884d902d32aa50040c3a89d.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd1uwnt5j30pu0ejq3q_huf1f0648627ed9232de9fbe1dc83db4f0_41763_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd1uwnt5j30pu0ejq3q_huf1f0648627ed9232de9fbe1dc83db4f0_41763_16abf3a95ad8a7a5b927711a6bb5b533.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;第五部分kubernetes-与容器编排之战&#34;&gt;第五部分：Kubernetes 与容器编排之战&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;容器编排与 Kubernetes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在单机上运行容器，无法发挥它的最大效能，只有形成集群，才能最大程度发挥容器的良好隔离、资源分配与编排管理的优势。所以企业需要一套管理系统，对 Docker 及容器进行更高级更灵活的管理，按照用户的意愿和整个系统的规则，完全自动化的处理好容器之间的各种关系，这叫做编排（Orchestration）。&lt;/p&gt;
&lt;p&gt;Orchestration 这个词来自于音乐领域，是指一种将不同乐器、音色加以合理的编排等手法营造出一个听感交融、平衡的艺术，它完美地描述了容器编排的含义：为单个应用程序（乐队中的每种乐器）提供协同工作的模式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd41k6qpj30k00b9q3k_hu468083c34ae3282b8b98c9455dc1c8d7_35353_bfc3f290ac6658405e4e951af27a3f05.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd41k6qpj30k00b9q3k_hu468083c34ae3282b8b98c9455dc1c8d7_35353_e3ca21d14cff9780f11e2181dfd87b21.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd41k6qpj30k00b9q3k_hu468083c34ae3282b8b98c9455dc1c8d7_35353_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd41k6qpj30k00b9q3k_hu468083c34ae3282b8b98c9455dc1c8d7_35353_bfc3f290ac6658405e4e951af27a3f05.webp&#34;
               width=&#34;720&#34;
               height=&#34;405&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 IT 领域编排可以理解为一种工作流，它能把整个 IT 系统都串接起来，然后自动化运作。在云原生时代，整体式的应用早已成为过去时，应用一般由单独容器化的组件即微服务组成，而这些组件需要通过相互间的协同合作，才能使既定的应用按照设计运作。&lt;/p&gt;
&lt;p&gt;2014 年 6 月，IT 基础设施领域的领先者 Google 发布了&lt;a href=&#34;https://kubernetes.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;（简写为 K8S）。编排概念并不是由 Kubernetes 第一个提出的，Kubernetes 这个单词来自于希腊语，含义是舵手或领航员。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd42l2yjj30u00goq3l_hu520eddc0cfb51eda46986a6147a91c10_38000_1f163520e96fd6bec696342e3cd1377b.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd42l2yjj30u00goq3l_hu520eddc0cfb51eda46986a6147a91c10_38000_e1ea03e3f0d0b1fae73215d2b66a5b9d.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd42l2yjj30u00goq3l_hu520eddc0cfb51eda46986a6147a91c10_38000_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd42l2yjj30u00goq3l_hu520eddc0cfb51eda46986a6147a91c10_38000_1f163520e96fd6bec696342e3cd1377b.webp&#34;
               width=&#34;760&#34;
               height=&#34;423&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes 是基于 Docker 的开源容器集群管理系统，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等整一套功能，因为容器本身可移植，所以 Kubernetes 容器集群能跑在私有云、公有云或者混合云上。&lt;/p&gt;
&lt;p&gt;Kubernetes 属于主从的分布式集群架构，包含 Master 和 Nodes。Master 作为控制节点，调度管理整个系统；Nodes 是运行节点，负责运行应用。Pod 是 Kubernetes 创建或部署的最小单位。一个 Pod 封装一个或多个容器（Container）、存储资源（Volume）、一个独立的网络 IP 以及管理控制容器运行方式的策略选项。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd413an7j30mb0gc3zv_hub097e513def283477bcff97b55b93ad0_64307_a968416a894bd3d85259c07852e77269.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd413an7j30mb0gc3zv_hub097e513def283477bcff97b55b93ad0_64307_9c0c16aebc9dba9be5cc5f0529d375b5.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd413an7j30mb0gc3zv_hub097e513def283477bcff97b55b93ad0_64307_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd413an7j30mb0gc3zv_hub097e513def283477bcff97b55b93ad0_64307_a968416a894bd3d85259c07852e77269.webp&#34;
               width=&#34;760&#34;
               height=&#34;557&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes 的主要功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源调度：资源调度是一套分布式系统最基本的核心指标&lt;/li&gt;
&lt;li&gt;资源管理：控制 Pod 对计算资源、网络资源、存储资源的使用&lt;/li&gt;
&lt;li&gt;服务发现：管理外在的程序或者内部的程序如何访问 Kubernetes 里面的某个 Pod&lt;/li&gt;
&lt;li&gt;健康检查：监控检测服务是否正常运行非常重要&lt;/li&gt;
&lt;li&gt;自动伸缩：因为涉及到环境的快速迁移和复制，虚拟机时代之前都非常难实现。容器化时代很自然的解决了这个问题，Kubernetes 保证了资源的按需扩容&lt;/li&gt;
&lt;li&gt;更新升级：Kubernetes 为服务的滚动和平滑升级提供了很好的机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes 使用案例：滚动发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们举一个 Kubernetes 的应用场景，帮助大家更好的理解 Kubernetes 的用途。&lt;/p&gt;
&lt;p&gt;应用程序升级面临最大挑战是新旧业务切换，将软件从测试的最后阶段带到生产环境，同时要保证系统不间断提供服务。长期以来，业务升级渐渐形成了几个发布策略：蓝绿发布、灰度发布（金丝雀发布）和滚动发布，目的是尽可能避免因发布导致的流量丢失或服务不可用问题。&lt;/p&gt;
&lt;p&gt;在微服务架构盛行的时代，用户希望应用程序时时刻刻可用，为了满足不断变化的新业务，需要不断升级更新应用程序，有时可能需要频繁的发布版本。实现&amp;quot;零停机&amp;quot;、“零感知”的持续集成和持续交付/部署应用程序，一直都是软件升级换代必须面对的难题和追求的理想方式，也是 DevOps 诞生的目的。&lt;/p&gt;
&lt;p&gt;滚动发布/滚动更新（Rolling Update Deployment）是指每次只升级一个或多个服务，升级完成后加入生产环境，不断执行这个过程，直到集群中的全部旧版本升级成为新版本。在整个滚动发布期间，保证始终有可用的副本在运行，从而平滑的发布新版本，实现零停机、用户零感知，是云原生时代非常主流的发布方式。&lt;/p&gt;
&lt;p&gt;下图是滚动发布的流程示意图，Load Balance 是前端的负载均衡器，橙色是正在运行旧版本服务的节点，紫色是正在更新及更新完毕新版本服务的节点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd44v38lj30u00irgmr_hufa7211d4777e03371a0d618d9625b76c_53244_be29bbfd18e1e8b46e59ef9e04c21192.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd44v38lj30u00irgmr_hufa7211d4777e03371a0d618d9625b76c_53244_8c7d5841e83716fe0c2364846229bf0e.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd44v38lj30u00irgmr_hufa7211d4777e03371a0d618d9625b76c_53244_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd44v38lj30u00irgmr_hufa7211d4777e03371a0d618d9625b76c_53244_be29bbfd18e1e8b46e59ef9e04c21192.webp&#34;
               width=&#34;760&#34;
               height=&#34;475&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
滚动发布流程示意图&lt;/p&gt;
&lt;p&gt;可以看到，滚动发布开始后（Step 2），负载均衡器将服务器 A 从集群里摘除，服务器 A 进行新版本的发布，由服务器 B 和服务器 C 对外提供版本 1.0 的服务；Step 3，服务器 A 更新完毕，部署验证成功，负载均衡器将其加入集群，开始和服务器 C 一起对外提供不同版本的服务，同时服务器 B 开始发布；直至服务器 ABC 全部发布完成（Step 5），服务都更新到最新的 2.0 版本。&lt;/p&gt;
&lt;p&gt;滚动发布的优点是用户无感知，平滑过渡，同时不需要冗余服务器，节省资源。不足是部署时间慢，取决于每阶段的更新时间；发布策略较复杂；同时涉及自动化的更新策略、部署验证、回滚机制等等，自动化程度比较高，通常需要复杂的发布工具支撑，而 Kubernetes 正好可以完美的支持这个任务。&lt;/p&gt;
&lt;p&gt;Kubernetes 通用的编排模式是控制循环，用伪代码表示如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd3zpj25j30gb05z3yr_hu48eb0ea69a3e5cd82ee59329acfda30e_20582_b2a3bdffc9864a5e27fb3ec5b62f15dd.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd3zpj25j30gb05z3yr_hu48eb0ea69a3e5cd82ee59329acfda30e_20582_0b7827f54ab039b8ebda4c4b5da4b1c7.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd3zpj25j30gb05z3yr_hu48eb0ea69a3e5cd82ee59329acfda30e_20582_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd3zpj25j30gb05z3yr_hu48eb0ea69a3e5cd82ee59329acfda30e_20582_b2a3bdffc9864a5e27fb3ec5b62f15dd.webp&#34;
               width=&#34;587&#34;
               height=&#34;215&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;解释一下，Kubernetes 集群本身状态就是实际状态，而期望状态来自于用户提交的配置文件。滚动发布的时候，Kubernetes 将会根据这个控制循环，使用一个叫做 Deployment 的控制器，通过创建新的集群（下图中的 v2 版本 ReplicaSet 复制集）将其控制的 Pod 副本从 0 个逐渐变成 3 个，与此同时旧的集群（下图中 v1 版本的 ReplicaSet）管理的 Pod 副本数则从 3 个逐渐变成 0 个，以此将一个集群中正在运行的多个 Pod 交替的逐一升级，实现滚动发布的效果。&lt;/p&gt;
&lt;p&gt;如果在发布刚开始的时候，集群里只有 1 个新版本的 Pod，这个 Pod 有问题启动不起来，那么滚动发布就会停止，开发和运维可以及时介入解决问题。而应用本身还有旧版本的集群和 Pod 在线，所以服务不会受到任何影响。关于滚动发布的详细介绍和互动教程可以阅读&lt;a href=&#34;https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd40nxcyj30cj0e9t95_hu985b81f317d3152d274d1832deb17513_17937_f67819ef740d9d0eb5dff14417a31d11.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd40nxcyj30cj0e9t95_hu985b81f317d3152d274d1832deb17513_17937_bb488fb8a9b4f6122f19c006700cfbad.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd40nxcyj30cj0e9t95_hu985b81f317d3152d274d1832deb17513_17937_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd40nxcyj30cj0e9t95_hu985b81f317d3152d274d1832deb17513_17937_f67819ef740d9d0eb5dff14417a31d11.webp&#34;
               width=&#34;451&#34;
               height=&#34;513&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;下面这张图展示了使用 Kubernetes，配合代码仓库 GitLab、Docker 镜像仓库 Harbor、构建工具 Jenkins，实现自动化的 CI/CD 流程。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd422bxhj30iu0drgmc_hu2e8656fd92ce4659454f071a88a30111_39553_f00142ca5af30dcb9dda1ed9b8330476.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd422bxhj30iu0drgmc_hu2e8656fd92ce4659454f071a88a30111_39553_39405acb2dacc9fd8a97a26492a80d2f.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd422bxhj30iu0drgmc_hu2e8656fd92ce4659454f071a88a30111_39553_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd422bxhj30iu0drgmc_hu2e8656fd92ce4659454f071a88a30111_39553_f00142ca5af30dcb9dda1ed9b8330476.webp&#34;
               width=&#34;678&#34;
               height=&#34;495&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上一部分结束时我们提到，传统 IT 架构好比传统工厂，容器化好比现代化工厂，而 Kubernetes 则是智能化的无人工厂，让容器和应用能够高效自动、井然有序的被控制和管理；Kubernetes 还实现了服务的抽象、解耦、高扩展、统一调度与集中化管理，例如用户可以专注用同样的方式在不同硬件上的应用，比如 GPU 节点池和低优先级的 CPU 节点池。Kubernetes 不仅解决了容器的编排问题，让容器应用进入大规模工业生产，更进一步对云原生应用提供了定义规范，CNCF 整个技术栈都是围绕 Kubernetes 建立，所以 Kubernetes 是云原生生态最重要的基石，可以说“Kubernetes 是云原生时代的 Linux”，即云原生应用的操作系统。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd43148zj30k509rjs6_hu7d04d2bfa0e7e8b79e245342284e82d1_41772_85caa728f35ec641dc00f05c0d9ce1e6.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd43148zj30k509rjs6_hu7d04d2bfa0e7e8b79e245342284e82d1_41772_08502c05e0738d497d2dd740c6e74f6e.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd43148zj30k509rjs6_hu7d04d2bfa0e7e8b79e245342284e82d1_41772_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd43148zj30k509rjs6_hu7d04d2bfa0e7e8b79e245342284e82d1_41772_85caa728f35ec641dc00f05c0d9ce1e6.webp&#34;
               width=&#34;725&#34;
               height=&#34;351&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;高扩展的 Kubernetes：兼容不同的硬件节点&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd407j40j30u00ia775_hu10adfbef3d1bcae9a90eae60e3d287d5_117627_b138ed53758fc60e7589478629431f0c.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd407j40j30u00ia775_hu10adfbef3d1bcae9a90eae60e3d287d5_117627_f8793b688dbe871a10b6c3d47a84a10a.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd407j40j30u00ia775_hu10adfbef3d1bcae9a90eae60e3d287d5_117627_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd407j40j30u00ia775_hu10adfbef3d1bcae9a90eae60e3d287d5_117627_b138ed53758fc60e7589478629431f0c.webp&#34;
               width=&#34;760&#34;
               height=&#34;463&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes：云原生应用的大规模工业生产&lt;/p&gt;
&lt;p&gt;回到本文第一部分，我们曾经用集装箱革命比喻云原生。现在大家已经理解，货船可以类比操作系统，集装箱类比容器，里面装的货物则是一个个的微服务，吊臂、吊桥、起重机等自动化操作设备是 Kubernetes，而一整套集装箱的操作方法和流程则是 DevOps。所有这些加起来构成了现代 PaaS 所具备的能力：操作系统、集群管理、应用编排、应用发布、持续集成等等。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd44ecwrj30f90a9my3_hub6bbbbd06807a13d6fa12b33440adaf1_47351_217642313dc1cfbbdad841f7279266d2.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd44ecwrj30f90a9my3_hub6bbbbd06807a13d6fa12b33440adaf1_47351_86a732125a113aa7e418795b88ff4351.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd44ecwrj30f90a9my3_hub6bbbbd06807a13d6fa12b33440adaf1_47351_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd44ecwrj30f90a9my3_hub6bbbbd06807a13d6fa12b33440adaf1_47351_217642313dc1cfbbdad841f7279266d2.webp&#34;
               width=&#34;549&#34;
               height=&#34;369&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器编排之战&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;意识到容器编排的重要性，Docker 在 2014 年发布了 Docker Swarm（Swarm 是蜂群的意思），以一个整体来对外提供集群管理功能，最大的亮点就是全部使用 Docker 项目原来的容器管理 API 来完成集群管理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd43i9u3j30u00h9dgh_huf4501a3c04d89cc80c2e5d31ce6ae55d_35149_9cac40dcf00613b4f0420b4c94378eeb.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd43i9u3j30u00h9dgh_huf4501a3c04d89cc80c2e5d31ce6ae55d_35149_b6d633ae69ea0771c16d023eea6e6354.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd43i9u3j30u00h9dgh_huf4501a3c04d89cc80c2e5d31ce6ae55d_35149_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd43i9u3j30u00h9dgh_huf4501a3c04d89cc80c2e5d31ce6ae55d_35149_9cac40dcf00613b4f0420b4c94378eeb.webp&#34;
               width=&#34;760&#34;
               height=&#34;437&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;同时从 2014 年底开始，Docker 收购了最先提出容器编排概念的 Fig 项目，并改名为 Compose（Compose 是作曲的意思），它可以用来组装多容器的应用，并在 Swarm 集群中部署分布式应用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd43zdckj30u00fojt2_hu3e070711158b5e77c9eafe434f4bd0d7_75103_0f57956fb8a2a509ebf6db32539dfa47.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd43zdckj30u00fojt2_hu3e070711158b5e77c9eafe434f4bd0d7_75103_b37473e8df31af60c3ce359699f25342.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd43zdckj30u00fojt2_hu3e070711158b5e77c9eafe434f4bd0d7_75103_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd43zdckj30u00fojt2_hu3e070711158b5e77c9eafe434f4bd0d7_75103_0f57956fb8a2a509ebf6db32539dfa47.webp&#34;
               width=&#34;760&#34;
               height=&#34;397&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;2014 年 Kubernetes 发布之后，为了与 Swarm 竞争，在容器编排地位取得绝对的优势，Google、RedHat 等开源基础设施公司共同发起了 CNCF 基金会，希望以 Kubernetes 为基础，建立一个由开源基础设施领域厂商主导、按照独立基金会方式运营的平台社区，来对抗以 Docker 公司为核心的容器商业生态。&lt;/p&gt;
&lt;p&gt;一方面 Kubernetes 脱胎于 Google 内部久负盛名的大规模集群管理系统 Borg，是 Google 在容器化基础设施领域十余年实践经验的沉淀和升华，Google 利用 Kubernetes 的架构和设计思想成功将其所有应用（搜索、地图、视频、金融、社交、人工智能）运行在超过 100 万台服务器、超过 80 个数据中心，每周的 20 亿个容器上，所以 Kubernetes 是唯一具有超过 10 年以上大规模容器生产使用的技术经验和积淀的开源项目。并且 Kubernetes 采用了非常优雅的软件工程设计和开源开放的态度，使得用户可以根据自己的使用场景、通过灵活插拔的方式，采用自定义的网络、存储、调度、监控、日志等模块，所以在 Github 上的各项指标一路飙升，将较为简单、并且生态自闭的 Swarm 项目远远地甩在了后边。CNCF 社区也迅速增加了一系列容器生态的知名工具和项目，大量的公司和初创团队将注意力投向 CNCF 社区而不再是 Docker，CNCF 本质上成为了以 Kubernetes 为核心的生态系统。&lt;/p&gt;
&lt;p&gt;企业服务大厂也纷纷加入 Kubernetes 平台战局，在公有云或者私有 PaaS 平台上来发展自己的 Kubernetes 产品。像微软直接找来 Kubernetes 联合创始人 Brendan Burns 负责领导 Azure 容器服务团队，自身的混合云产品 Azure Stack 也大力支持 Kubernetes。IBM 同样也靠以 Kubernetes 为核心的 PaaS 软件 IBM Cloud Private 来抢占企业私有云容器平台市场，尤其是微服务的管理需求。很早就支持 Kubernetes 的 Redhat，在 2015 年推出的 OpenShift 3.0 版中，不惜放弃自己的容器调度工具，开始支持 Kubernetes，现在更成为了支持跨多云、混合云架构，以及裸机、容器和虚拟机的企业级通用应用管理平台。而虚拟化龙头 VMware 也改为力推主打通吃多家 IaaS 和 Kubernetes 集群管理的容器服务软件，甲骨文也在旗下云端服务支持 Kubernetes。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd3zfu5hj30u00hagno_hu181b41d909cf5f4ff57835bb6493ddd2_89241_d1c563ef85c136c3b5efbb548a423e52.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd3zfu5hj30u00hagno_hu181b41d909cf5f4ff57835bb6493ddd2_89241_1c03454582888d6f9e348282665b50c9.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd3zfu5hj30u00hagno_hu181b41d909cf5f4ff57835bb6493ddd2_89241_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd3zfu5hj30u00hagno_hu181b41d909cf5f4ff57835bb6493ddd2_89241_d1c563ef85c136c3b5efbb548a423e52.webp&#34;
               width=&#34;760&#34;
               height=&#34;438&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在用户、社区和大厂的支持中，Kubernetes 逐步成为企业基础架构的部署标准和新一代的应用服务层。&lt;/p&gt;
&lt;p&gt;2016 年，面对 CNCF 的竞争优势，Docker 公司宣布放弃现有的 Swarm 项目，将容器编排和集群管理功能转到 Docker 项目当中。然而这种改变带来的技术复杂度和维护难度，给 Docker 项目造成了非常不利的局面。不同于 Docker，Kubernetes 推进的民主化架构从 API 到容器运行的每一层，都给开发者暴露出了可扩展的插件机制，鼓励用户通过代码的方式介入每一个阶段。Kubernetes 的变革非常有效，很快在整个容器社区中催生出了大量的、基于 Kubernetes API 和扩展接口的二次创新产品，例如前文提到的 Istio 等等。Docker 公司在 Kubernetes 社区崛起和壮大后，败下阵来。&lt;/p&gt;
&lt;p&gt;2017 年，Docker 公司将容器运行时部分 Containerd 捐献给 CNCF 社区，并在自己主打产品 Docker 企业版中内置 Kubernetes 项目，持续了两年的容器编排之争终于落下帷幕，Kubernetes 成为了最后的胜利者，而 Docker 输掉了最关键的一仗，失去了成为云原生时代操作系统的机会。&lt;/p&gt;
&lt;p&gt;Docker 在最重要的容器编排之战中失败，带给我们的教训包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开源不等于免费，开源是一种商业模式，一个开源组织和开源项目要想生存下去，最重要的基础就是普遍被使用，不然很快就会被竞争者替代&lt;/li&gt;
&lt;li&gt;开源技术终将走向商业，包括 Docker，必然面临企业市场的挑战&lt;/li&gt;
&lt;li&gt;Docker 进入企业级市场，有优势也有劣势，优势是挟 Docker 的大量开发者，劣势是没有做过企业级市场，开发者市场和企业级市场的做法完全不同&lt;/li&gt;
&lt;li&gt;Docker 在竞争中失利，看起来是时机和生态构建的问题，但归根结底是基因和能力问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此系列文章的前五部分，我们详细介绍了云原生的各种理念和技术。在最后一部分，我们将展开总结和思考，分析云原生时代的机遇与挑战。&lt;/p&gt;
&lt;h2 id=&#34;第六部分机会与思考&#34;&gt;第六部分：机会与思考&lt;/h2&gt;
&lt;p&gt;上文主要介绍了 Kubernetes 与容器编排之战，本文的最后一部分将系统性的总结云原生能带给我们什么样的未来，相关的创业和投资机会在哪里。&lt;/p&gt;
&lt;p&gt;每一次 IT 产业架构的变革都会带来巨大的机遇和行业洗牌的挑战。过去的三四十年间，IT 业经历了多次重大的变革，包括 20 世纪七八十年代从大型机向小型机的转移、九十年代 C/S 架构的普及，以及 21 世纪初互联网的兴起，先后造就了 IBM、思科、惠普、Oracle、EMC、SAP 等巨头企业。&lt;/p&gt;
&lt;p&gt;历次 IT 技术革命还有个共同特点：无论原有的基础软硬件公司此前有多么牢不可破的垄断地位，一旦不能符合新的 IT 技术变革的趋势，洗牌在所难免。&lt;/p&gt;
&lt;p&gt;现代云计算的浪潮开始于 2000 年以后，已经造就了 VMware、ServiceNow、Salesforce、Shopify 等数百亿美金的明星企业，以及无数的独角兽公司。&lt;/p&gt;
&lt;p&gt;云计算是通过互联网的方式按需交付基础设施（硬件/服务器）、存储、数据库和各种应用服务，通常这些服务是由 AWS、Azure 等公有云或者私有云平台提供的。&lt;/p&gt;
&lt;p&gt;而云原生是一种理念和架构，用于以针对云环境优化的方式组装上述所有基于云的组件。因此云原生也是一个目的地：对于那些希望实现基础设施和流程现代化，甚至组织文化现代化的企业来说，最终的目标是仔细选择最适合其具体情况的云技术。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd57rbruj30oz0gigme_huc9287c601043f4cb9f021f52bfcc2db5_28066_0b609c02bfb3930fa16fcdb2f9a2b4c6.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd57rbruj30oz0gigme_huc9287c601043f4cb9f021f52bfcc2db5_28066_425ec26357c281f221bbaeb83317f424.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd57rbruj30oz0gigme_huc9287c601043f4cb9f021f52bfcc2db5_28066_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd57rbruj30oz0gigme_huc9287c601043f4cb9f021f52bfcc2db5_28066_0b609c02bfb3930fa16fcdb2f9a2b4c6.webp&#34;
               width=&#34;760&#34;
               height=&#34;502&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;要从云计算中获得最佳效果，需要使用云原生架构；云原生的普及又会促进云计算的加速发展。&lt;/p&gt;
&lt;p&gt;从统计数据和发展趋势来看，云原生被接受的程度和普及速度正在大大加快，例如下图显示，自从 2016 年以来容器的使用量每年都在快速上升。IDC 预计，到 2022 年 90% 的应用程序将采用微服务架构和第三方代码，35% 的生产应用程序将诞生于云端。由于容器和敏捷方法的采用，预计 2018-2023 年间将诞生 5 亿个新应用程序。由数字化转型，以及接受和采用新技术的需求驱动，云原生将更深入地渗透到大型企业组织中。这意味着云原生技术和方法可能会遵循敏捷和 DevOps 的模式，越来越多地吸引更多的利益相关者，包括管理者和业务线领导人，在未来几年内覆盖一半或更多的组织。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd58nr5hj30k80ec74x_hud7df5f4be3028a421b1f004c39001039_36099_bface5f90b13369121ca97d3dd7605df.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd58nr5hj30k80ec74x_hud7df5f4be3028a421b1f004c39001039_36099_fdf57818cdee3bed89b635c45a540d47.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd58nr5hj30k80ec74x_hud7df5f4be3028a421b1f004c39001039_36099_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd58nr5hj30k80ec74x_hud7df5f4be3028a421b1f004c39001039_36099_bface5f90b13369121ca97d3dd7605df.webp&#34;
               width=&#34;728&#34;
               height=&#34;516&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;各种场景容器使用量都在逐步上升&lt;/p&gt;
&lt;p&gt;但目前不是所有的云计算技术和产品都能很好的满足云原生架构分布式、自动化、轻量化的要求，传统的 IT 基础设施正在受到越来越大的冲击，例如传统集中式数据库正在逐渐被分布式数据库所取代，虚拟机技术受到了容器的巨大冲击，分布式监控系统完全替代了传统的监控产品，而传统的安全产品也远远无法满足云原生安全性的要求。&lt;/p&gt;
&lt;p&gt;还需要注意的是，云原生的概念不仅仅只意味着容器、Kubernetes 或 Serverless，也为下一项技术留下了足够的空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生投资的分层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于大多数软件开发组织来说，仍然处于采用微服务和容器的早期阶段。新机遇一方面源自于云原生在各行各业的应用，一方面则是云原生相关新的基础设施。&lt;/p&gt;
&lt;p&gt;CNCF 全景图呈现了比较完整的云原生项目和分类，我们可以将其简化成如下图所示的几种大的分类：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd51e679j30ka0bywfe_hu3a06b8a3e4ebff0b90afbe61f98e3240_46276_4e57f2453d5fc9342958101d92245376.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd51e679j30ka0bywfe_hu3a06b8a3e4ebff0b90afbe61f98e3240_46276_0b517c1a16e8faeb62bdfafb6464c083.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd51e679j30ka0bywfe_hu3a06b8a3e4ebff0b90afbe61f98e3240_46276_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd51e679j30ka0bywfe_hu3a06b8a3e4ebff0b90afbe61f98e3240_46276_4e57f2453d5fc9342958101d92245376.webp&#34;
               width=&#34;730&#34;
               height=&#34;430&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;一共分为 AppDev &amp;amp; DevOps；Management；Runtimes；Infrastructure and Services；Serverless；Observability；Security 八个大的模块。&lt;/p&gt;
&lt;p&gt;从广义的角度来讲，云原生应用的设计、开发、管理、运维、分析与传统应用有非常大的不同，生态的每个环节、技术的每个领域都会有许多机会，例如云原生应用的设计、咨询、开发、培训，需要有方案商、供应商、实施商；在基础设施层面，数据库、开发工具、核心中间件、安全产品等等都会有巨大市场需求，例如 Service Mesh+安全、Serverless+安全、容器 + 安全、多云 + 安全，例如云原生数据的分析处理，例如云原生架构的灾备管理。&lt;/p&gt;
&lt;p&gt;我个人将云原生的生态分为三层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;技术层包括云原生技术相关的基础设施，主要分为两种类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原有技术的替代品：例如 ETCD 取代传统的数据库&lt;/li&gt;
&lt;li&gt;全新基础设施：新技术相关产品，例如 Istio 和 OpenFaaS&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用层主要是云原生在各行业的具体应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;包括云原生相关的培训、咨询、认证等相关服务。&lt;/p&gt;
&lt;p&gt;下面我重点讲讲技术层和应用层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生技术层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的表格里代表性的列举了云原生技术层的几个领域及相关项目。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd56cr01j30lq0e6q49_hu751b5b42e3442aabf022d78f268824a1_62638_8122e4f9d8c999c4c13dff332c5c81fb.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd56cr01j30lq0e6q49_hu751b5b42e3442aabf022d78f268824a1_62638_d0268cd9b06e4d5133d74c56d4f32fcb.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd56cr01j30lq0e6q49_hu751b5b42e3442aabf022d78f268824a1_62638_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd56cr01j30lq0e6q49_hu751b5b42e3442aabf022d78f268824a1_62638_8122e4f9d8c999c4c13dff332c5c81fb.webp&#34;
               width=&#34;760&#34;
               height=&#34;496&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;下图展示了当前这些项目的市场占有率情况。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd54h5y7j30ju0e60te_hu7a646845050fa34bf05d5816de0bb915_25162_61bb03ebf1977e9ce2543ca23bd916a3.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd54h5y7j30ju0e60te_hu7a646845050fa34bf05d5816de0bb915_25162_b93abaac03759b80b94f62a1ddc485bf.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd54h5y7j30ju0e60te_hu7a646845050fa34bf05d5816de0bb915_25162_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd54h5y7j30ju0e60te_hu7a646845050fa34bf05d5816de0bb915_25162_61bb03ebf1977e9ce2543ca23bd916a3.webp&#34;
               width=&#34;714&#34;
               height=&#34;510&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd532sxaj30jt0dnaax_hu56c0689eae877155c1fd89ed532110b8_29383_0b8c101fd12e7da2ad3daa955bed675b.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd532sxaj30jt0dnaax_hu56c0689eae877155c1fd89ed532110b8_29383_fbcd095c6e987c9bdbcc66fc91be0428.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd532sxaj30jt0dnaax_hu56c0689eae877155c1fd89ed532110b8_29383_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd532sxaj30jt0dnaax_hu56c0689eae877155c1fd89ed532110b8_29383_0b8c101fd12e7da2ad3daa955bed675b.webp&#34;
               width=&#34;713&#34;
               height=&#34;491&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd5amzu8j30lm0fejs6_hua5c584276ffcf2a3410612f79c8ad53f_42065_4ecc4f678b36d0f528e4a4ab698b0976.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd5amzu8j30lm0fejs6_hua5c584276ffcf2a3410612f79c8ad53f_42065_e3ccd56b6f6bfce73784a47d15bdc048.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd5amzu8j30lm0fejs6_hua5c584276ffcf2a3410612f79c8ad53f_42065_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd5amzu8j30lm0fejs6_hua5c584276ffcf2a3410612f79c8ad53f_42065_4ecc4f678b36d0f528e4a4ab698b0976.webp&#34;
               width=&#34;760&#34;
               height=&#34;541&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可以看到技术层涉及的范围非常广，机会非常多，本文仅展开介绍其中我比较看好的一个领域 - 云原生安全。&lt;/p&gt;
&lt;p&gt;据 CNCF 统计，采用容器技术的挑战中，开发团队面临的文化挑战、安全性、复杂性、就绪性和监控分别排在前五位。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd51n0kyj30kd0g3q3t_hu61edbdc70eb6af434091f52f14582d47_45481_cae8dccd9e2c227286f884c63aed215a.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd51n0kyj30kd0g3q3t_hu61edbdc70eb6af434091f52f14582d47_45481_6424c7ea7dc8537fb4a7df4108cd5443.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd51n0kyj30kd0g3q3t_hu61edbdc70eb6af434091f52f14582d47_45481_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd51n0kyj30kd0g3q3t_hu61edbdc70eb6af434091f52f14582d47_45481_cae8dccd9e2c227286f884c63aed215a.webp&#34;
               width=&#34;733&#34;
               height=&#34;579&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用容器的挑战&lt;/p&gt;
&lt;p&gt;在云原生架构中，安全问题显得尤其突出的原因有以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快速迁移到云原生架构对企业安全状况和运营产生了深远的影响。在容器、微服务和编排框架的世界中，以持久“状态”运行在“服务器”上的“应用程序”的概念已经过时。现在，该应用程序或服务是一个分布式系统，由多个组件组成，这些组件运行在数量可变的节点上，处于几乎恒定的变化状态。依赖于机器隔离和可预测的系统状态的传统安全控制是无效的。对服务到服务的通信视而不见的安全策略以及缺乏水平可扩展的控件，根本无法跟上当今微服务应用程序的步伐。&lt;/li&gt;
&lt;li&gt;随着企业将工作负载从数据中心转移到 AWS、Google Cloud Platform 和 Microsoft Azure，它们已经改变了购买安全性的方式。他们需要独立于平台的安全工具，这样就不会被绑定到特定的云平台中。&lt;/li&gt;
&lt;li&gt;复杂系统可以创建大量的警报和事件日志，这会是一项惊人的任务。安全项目被堆积如山的繁忙工作所淹没，分析师们疲惫不堪。随着分析师对惊人的数据量变得不敏感，真正的问题就从他们的手指间溜走了。&lt;/li&gt;
&lt;li&gt;DevOps 是一种协作方法，它将开发人员和 IT 操作统一起来，以加快应用程序的构建、测试和部署，它也影响了 IT 安全。当开发人员可以直接将他们的应用程序部署到生产服务器上，因为业务敏捷性需要它时，他们就不能停下来找出安全问题。DevOps 提供了一种完全不同的安全方式，安全自动化有很多机会。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了在云本机环境中保护业务资产，组织必须将安全实践和技术与它们要保护的系统纳入体系结构中。正如 DevOps 支持持续开发和部署一样，“DevSecOps”也必须支持持续的安全管道。这意味着要建立全新的方法、功能和工具，以确保旨在保护云原生系统的解决方案呈现以下基本特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局的实时可见性：局部的或事后的可见性是不够的。无论位于何处，基础架构层和应用程序都必须可见。&lt;/li&gt;
&lt;li&gt;快速、迭代的反馈循环：反馈循环允许安全措施不断适应快速变化的环境。&lt;/li&gt;
&lt;li&gt;解决安全问题的工程方法：自动化、连续测量和受控实验将是解决整个企业安全问题的主要方法，取代手动分析和控制更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，像 Netflix、Lyft 和 Square 等组织已经开始将云原生安全作为工程问题来处理，使用自动化来避免这些陷阱，并使安全团队更加有效。他们还规避了将检测、响应和开发团队分开的烟囱式结构，在构建安全检测机制并将它们与响应编排集成时遵循 DevOps 的思想。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd53kdrqj30u00g1wgq_hu2e1aa261d2213772d76dd121420a5f52_96217_694f5dca3399f73380e94bffb40d226f.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd53kdrqj30u00g1wgq_hu2e1aa261d2213772d76dd121420a5f52_96217_f95b8c8d616e376010639acb16d71574.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd53kdrqj30u00g1wgq_hu2e1aa261d2213772d76dd121420a5f52_96217_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd53kdrqj30u00g1wgq_hu2e1aa261d2213772d76dd121420a5f52_96217_694f5dca3399f73380e94bffb40d226f.webp&#34;
               width=&#34;760&#34;
               height=&#34;406&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;来自 Netflix 的安全检测组件示例&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/security/overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;云原生的安全分为 4C，即代码、容器、集群、云四个层级。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd55vxnwj30u00hb0to_hu2da529e3e4355ac2dba4f2dbf91c03f7_49274_706274aafd2b052437955aa0f4d5b01c.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd55vxnwj30u00hb0to_hu2da529e3e4355ac2dba4f2dbf91c03f7_49274_f038b79fcacdd5cc037d97bb5a412b11.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd55vxnwj30u00hb0to_hu2da529e3e4355ac2dba4f2dbf91c03f7_49274_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd55vxnwj30u00hb0to_hu2da529e3e4355ac2dba4f2dbf91c03f7_49274_706274aafd2b052437955aa0f4d5b01c.webp&#34;
               width=&#34;760&#34;
               height=&#34;439&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;CNCF 全景图中安全与合规子分类里包含的项目如下图所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd524cl8j30u00codhc_hu615c9246443a6475c2bdd14d619ff1c0_66951_b3a0f5d17e2b2ea10b2e523386b21062.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd524cl8j30u00codhc_hu615c9246443a6475c2bdd14d619ff1c0_66951_6cec8a7ebc8abc1863ef9ec60171d536.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd524cl8j30u00codhc_hu615c9246443a6475c2bdd14d619ff1c0_66951_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd524cl8j30u00codhc_hu615c9246443a6475c2bdd14d619ff1c0_66951_b3a0f5d17e2b2ea10b2e523386b21062.webp&#34;
               width=&#34;760&#34;
               height=&#34;321&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;像在我多篇文章里曾经提及的新一代云安全公司，市值 189 亿美金的 CrowdStrike，直接将自己定义为云原生的端点保护平台（Cloud-Native Endpoint Protection Platform），以此同传统的端点保护产品区分开来。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd524cl8j30u00codhc_hu615c9246443a6475c2bdd14d619ff1c0_66951_b3a0f5d17e2b2ea10b2e523386b21062.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd524cl8j30u00codhc_hu615c9246443a6475c2bdd14d619ff1c0_66951_6cec8a7ebc8abc1863ef9ec60171d536.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd524cl8j30u00codhc_hu615c9246443a6475c2bdd14d619ff1c0_66951_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd524cl8j30u00codhc_hu615c9246443a6475c2bdd14d619ff1c0_66951_b3a0f5d17e2b2ea10b2e523386b21062.webp&#34;
               width=&#34;760&#34;
               height=&#34;321&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;下面我介绍几家和云原生安全相关的初创企业。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、Capsule8（B 轮）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Capsule8 是一家由经验丰富的黑客和安全企业家创建的高新科技初创型企业，总部位于纽约布鲁克林，成立于 2016 年秋季，在 2018 年 8 月获得 1500 万美元的 B 轮融资。&lt;/p&gt;
&lt;p&gt;Capsule8 开发了业界第一个也是唯一一个针对 Linux 的实时 0day 攻击检测平台，可主动保护用户的 Linux 基础设施免受攻击。Capsule8 实时 0day 攻击检测平台可显著改善和简化当今基础架构的安全性，同时为未来的容器化环境提供弹性的支持。&lt;/p&gt;
&lt;p&gt;混合云架构已经成为企业 IT 基础设施的重要架构，但其复杂性也使企业面临多种攻击的风险，根据 Capsule8 与 ESG Research 赞助的一项新研究表明，仅 2017 一年就有 42% 的企业报告了混合云环境受到攻击，28% 的企业表示 0day 攻击是这些攻击的起源。&lt;/p&gt;
&lt;p&gt;混合云环境由于存在多云服务商，缺乏中心控制和完整的合规性规划，存在边界模糊，访问策略不一致等问题，加上公有云的暴露面增大，攻击者容易通过攻击薄弱点进入，这也是近年来如软件定义边界 SDP、移动目标防护 MTD 等新方案兴起的原因。&lt;/p&gt;
&lt;p&gt;无论是传统环境，还是混合环境，防护利用 0day 漏洞的高级威胁需要企业安全团队全方位持续防护资产、获得环境的可视性，检测恶意行为。&lt;/p&gt;
&lt;p&gt;Capsules8 平台整体架构图如下所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd59mw2tj30ow09lgm7_hub6f0011b1ca0dd2014268a389b8758de_34776_3574f7e25b5c9ae87355c415a569a7a1.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd59mw2tj30ow09lgm7_hub6f0011b1ca0dd2014268a389b8758de_34776_e2ffe25e9f03061df6551df523ec5c49.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd59mw2tj30ow09lgm7_hub6f0011b1ca0dd2014268a389b8758de_34776_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd59mw2tj30ow09lgm7_hub6f0011b1ca0dd2014268a389b8758de_34776_3574f7e25b5c9ae87355c415a569a7a1.webp&#34;
               width=&#34;760&#34;
               height=&#34;293&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;假设客户生产环境是一个混合云环境，服务器部署于客户侧数据中心、公有云 AWS 和 Azure 中。Capsule8 的整个工作流程主要分为感知、检测、阻断、调查四步。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd57cxruj30kk0arab3_hu4621663758beb403f917de3797f63c10_51838_a64819f68b4036de01d669cf2d8f609d.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd57cxruj30kk0arab3_hu4621663758beb403f917de3797f63c10_51838_359f78d0beafa0c1635d4da08c518ad0.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd57cxruj30kk0arab3_hu4621663758beb403f917de3797f63c10_51838_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd57cxruj30kk0arab3_hu4621663758beb403f917de3797f63c10_51838_a64819f68b4036de01d669cf2d8f609d.webp&#34;
               width=&#34;740&#34;
               height=&#34;387&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd56utpsj30m804uaan_hube7a8400c137883b55adf03ea6851279_20587_d80c8591e9d49985eb2f0f97cb8af549.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd56utpsj30m804uaan_hube7a8400c137883b55adf03ea6851279_20587_643055e83e61945ed234781fea0b0020.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd56utpsj30m804uaan_hube7a8400c137883b55adf03ea6851279_20587_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd56utpsj30m804uaan_hube7a8400c137883b55adf03ea6851279_20587_d80c8591e9d49985eb2f0f97cb8af549.webp&#34;
               width=&#34;760&#34;
               height=&#34;165&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、Aqua Security（C 轮）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Aqua Security 成立于 2015 年，它为基于容器、Serverless 和云原生应用提供保护解决方案。2019 年，Aqua Security 完成了 6200 万美金的 C 轮融资，累计融资超过 1 亿美元。它的客户包括能源、航空航天、互联网、媒体、旅游、零售、制药和酒店业的 100 多家知名企业。&lt;/p&gt;
&lt;p&gt;Aqua Security 的云原生安全平台使用现代化的零接触方法来检测和预防威胁，在整个应用程序生命周期内提供全面的可见性和安全自动化。例如在漏洞管理方面，Aqua 可以实现：&lt;/p&gt;
&lt;p&gt;扫描镜像和功能：Aqua 几乎与所有 CI/CD 工具集成在一起，可在构建镜像和功能时主动扫描，及早发现问题并允许快速修复。&lt;/p&gt;
&lt;p&gt;关注应用风险：下一个挑战是大规模提供安全性。这种情况是指可能要扫描成千上万个镜像的漏洞。但是，其中许多镜像实际上并未在生产中部署，因此即使处于脆弱状态风险也不高。Aqua 提供了对正在运行的工作负载中易受攻击组件的实例化的可见性，这使安全团队可以集中精力修复最容易遭受利用风险的那些组件。&lt;/p&gt;
&lt;p&gt;提供可行建议：Aqua 提供了有关漏洞的具体可行建议，通常是建议升级到特定的版本或者改变配置和环境变量。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd55don4j30rs0eswft_hu895474dae41a19ac739873b6f9de3849_62809_20624e1cbcae7efc12c162cbda7c2f96.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd55don4j30rs0eswft_hu895474dae41a19ac739873b6f9de3849_62809_d1b38e47379e45a7f55a835426d0c3e0.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd55don4j30rs0eswft_hu895474dae41a19ac739873b6f9de3849_62809_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd55don4j30rs0eswft_hu895474dae41a19ac739873b6f9de3849_62809_20624e1cbcae7efc12c162cbda7c2f96.webp&#34;
               width=&#34;760&#34;
               height=&#34;404&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、Twistlock（被收购）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;位于 CNCF 全景图里的 Twistlock 创立于 2015 年。曾经在以色列著名的网安黄埔 8200 部队服役，并在微软企业安全部门工作的 Ben Bernstein 以不到 30 万美元的种子轮开始起家，定位容器安全。Twistlock 自己贴的标签除了容器安全，就是云原生安全。Twistlock 的融资节奏很好，2015 年 5 月天使轮 280 万美元，2016 年 7 月 A 轮 1000 万美元，2017 年 4 月 B 轮 1700 万美元，2018 年 8 月 C 轮 3300 万美元，2019 年就被 Palo Alto Networks 以 4.1 亿美金的价格收购。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd5a46f4j30n30f8wfg_hub6bead08ad5907cdc988b6537ffab863_49080_876096acccdf55eb1ff4395ab333c921.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd5a46f4j30n30f8wfg_hub6bead08ad5907cdc988b6537ffab863_49080_fe7ee594a2f1e5ae3bc8ec19249e6583.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd5a46f4j30n30f8wfg_hub6bead08ad5907cdc988b6537ffab863_49080_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd5a46f4j30n30f8wfg_hub6bead08ad5907cdc988b6537ffab863_49080_876096acccdf55eb1ff4395ab333c921.webp&#34;
               width=&#34;760&#34;
               height=&#34;501&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Twistlock 产品界面&lt;/p&gt;
&lt;p&gt;现在，Twistlock 已经能为 Amazon ECS、Azure、Docker、GCP、Pivotal、OpenShift、Istio 等多个平台提供安全方案。Twistlock 的自己一句话介绍是“领先的全栈，全生命周期容器安全解决方案，保护容器环境及其中运行的应用程序，具有轻量级，可扩展和自动化特性，自动化的策略构建和全开发生命周期内的无缝集成”。&lt;/p&gt;
&lt;p&gt;截至目前，Twistlock 总结了 6 方面的核心能力，分别是漏洞管理、合规、运行时防护、持续集成和持续交付、云原生防火墙和访问控制。像运行时防护包括网络和应用程序防火墙，支持 Docker 和 AWS Fargate 运行安全以及主机防护，可以通过机器学习为每个应用程序进行自动建模，保护网络，文件系统，进程和系统调用。云原生防火墙方面，Twistlock 包括 3 层防火墙和 7 层防火墙，它可以自动学习应用程序的网络拓扑，并为所有微服务提供应用程序的微分段，可以检测和阻止 XSS 攻击、SQL 注入等威胁，还可以自动模拟所有微服务之间的所有流量，并允许安全团队集中查看和实施安全流量，同时自动阻止异常，无需手动创建和管理规则。&lt;/p&gt;
&lt;p&gt;除了云原生安全领域，以及前文介绍过的 Kong、RapidAPI 之外，我再介绍三家知名的云原生技术层创业企业。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、Rancher（D 轮）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在本文第一部分我们提过 Rancher（中文意思是放牧人）这家公司，它的创始人梁胜职业生涯贯穿软件开发与云计算的发展历史。作为耶鲁大学计算机博士、Java 语言 J2SE 平台核心组件 JNI 的作者、JVM 的领导设计与开发者，梁胜 2000 年离开 Sun 创办了应用防火墙软件公司 Teros Networks 并担任 CTO，2001 年公司被 Citrix 收购。2008 年梁胜第二次创业创建了&lt;a href=&#34;http://Cloud.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud.com&lt;/a&gt;，并推出了著名的云计算管理软件 CloudStack，他也因此被誉为“CloudStack 之父”，2011 年&lt;a href=&#34;http://Cloud.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud.com&lt;/a&gt;被 Citrix 又以 2 亿美金收购，他成为 Citrix 首位华人 CTO。随后 2014 年梁胜创立了容器管理公司 Rancher Labs。&lt;a href=&#34;https://rancher.com/why-were-building-a-container-infrastructure-platform-at-rancher-labs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这是&lt;/a&gt;他创建公司的初衷。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd5866lfj30n308ngml_hu19186595288ea22e634e69dcc9ea59bf_28037_490e44c2868b92e239c1b279fe23c2da.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd5866lfj30n308ngml_hu19186595288ea22e634e69dcc9ea59bf_28037_cf1daf1753576cbce850796ae6995a2c.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd5866lfj30n308ngml_hu19186595288ea22e634e69dcc9ea59bf_28037_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd5866lfj30n308ngml_hu19186595288ea22e634e69dcc9ea59bf_28037_490e44c2868b92e239c1b279fe23c2da.webp&#34;
               width=&#34;760&#34;
               height=&#34;284&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Rancher 是一个容器管理平台，通过 Rancher 可以实现 Docker 和 Kubernetes 的轻松部署。Rancher 由基础设施编排、容器编排与调度、应用商店、企业级权限管理组成。下图展示了 Rancher 的主要组件和功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd52js77j30u00ci401_hu25390062dc1464937adba0cdf98b5c99_70174_8a6034c28368c2e8b2846691019ea520.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd52js77j30u00ci401_hu25390062dc1464937adba0cdf98b5c99_70174_d78cab249663bea49672628b50d70818.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd52js77j30u00ci401_hu25390062dc1464937adba0cdf98b5c99_70174_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd52js77j30u00ci401_hu25390062dc1464937adba0cdf98b5c99_70174_8a6034c28368c2e8b2846691019ea520.webp&#34;
               width=&#34;760&#34;
               height=&#34;317&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今年 3 月份，Rancher 对外公布了 4000 万美元的 D 轮融资，由此 Rancher 累计融资高达 9500 万美元。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、HashiCorp（E 轮）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HashiCorp（简称为 Hashi，日语“桥梁”的含义）是我一直非常看好的一家云原生技术企业，不过最近因为禁止中国企业使用其商业产品而被刷屏。它成立于 2012 年，主要开发 DevOps 和云管理基础设施相关产品，日裔创始人及 CTO Mitchell Hashimoto 从 12 岁就开始创业，目前年仅 30 岁，公司主要产品都出自于他的手笔。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd5azfe4j30u00k0ta9_hu8e3d34857a1c83ad5add7db79fd7675c_70950_7f19e76d8da7a9df2951def73cf88b65.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd5azfe4j30u00k0ta9_hu8e3d34857a1c83ad5add7db79fd7675c_70950_b77e027ad91ff06aafe7ebb1651a9285.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd5azfe4j30u00k0ta9_hu8e3d34857a1c83ad5add7db79fd7675c_70950_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd5azfe4j30u00k0ta9_hu8e3d34857a1c83ad5add7db79fd7675c_70950_7f19e76d8da7a9df2951def73cf88b65.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;HashiCorp 旗下包含多款知名的云原生相关开源产品，我们自上而下的来看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nomad：程序自动化，集群管理器和调度器，专为微服务和批量处理工作流设计。与 Kubernetes 相比，Nomad 通用性更强。&lt;/li&gt;
&lt;li&gt;Vault：安全自动化，企业级私密信息管理工具。&lt;/li&gt;
&lt;li&gt;Terraform：基础架构自动化，安全有效地构建、更改和版本控制基础设施的工具。&lt;/li&gt;
&lt;li&gt;Packer：镜像工具，旨在通过简易的方式自动化构建镜像。&lt;/li&gt;
&lt;li&gt;Vagrant：用于创建和部署虚拟化开发环境的工具，由 Mitchell Hashimoto 在 23 岁时开发，并成为其创建 HashiCorp 的基石。&lt;/li&gt;
&lt;li&gt;Consul：网络自动化、服务网格解决方案，它提供了一个功能齐全的控制平面，主要功能包括服务发现、健康检查、键值存储、安全服务通信、多数据中心等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今年 3 月 HashiCorp 对外公布了 1.75 亿美元的 E 轮融资，投后估值为 51 亿美元。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、Snowflake（G 轮）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Snowflake 成立于 2012 年，创始人 Bob Muglia 曾在微软工作 23 年，拥有丰富的数据库经验。Bob Muglia 认为，NoSQL 型数据库并不能完全适应业务要求，基于云端的数据仓库省去了相关软硬件的设置需要，降低了使用门槛。Snowflake 包括数据引擎在内的几乎所有技术都是自己研发的，在数据库和数据处理方面拥有非常多的专利，它是一个云原生的 SQL 数据仓库，完全针对云计算特点设计，部署在 AWS 等云端平台上，可以将用户所有的数据集中在一个地方，用户只需加载数据然后运行查询就可以查找到各种结构化或半结构化的数据。&lt;/p&gt;
&lt;p&gt;为什么要使用云原生数据仓库？&lt;/p&gt;
&lt;p&gt;作为一个类别，云原生的数据仓库提供了许多好处。首先，它们使公司摆脱了对设备和机器的担忧：在过去的物理服务器时代，公司需要操心服务器机房，或者至少是运行软件或存储数据的特定机器。构建这个物理基础设施是启动或扩展软件公司的一个巨大障碍。现在，服务器成本要低得多，只需点击几下鼠标就可以创建云端数据仓库。公司只需要按需处理和存储数据，并为他们使用的东西付费。云的使用还可以为公司提供更多的冗余和支持，因为他们不再需要担心单个服务器的故障和整个操作的崩溃。大型云服务提供商拥有多个备份系统，可以在全球数据中心之间自动扩展，以保持一切正常运行。这对客户公司来说是双赢的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd5429q0j30l109rjs1_hu4e8cdd22fa5492e1000904c3b83a230f_36728_9d635b76592479044df7c6d2426dd085.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd5429q0j30l109rjs1_hu4e8cdd22fa5492e1000904c3b83a230f_36728_a06fb5a6dfc98d15de1ae63b0bfa748b.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd5429q0j30l109rjs1_hu4e8cdd22fa5492e1000904c3b83a230f_36728_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd5429q0j30l109rjs1_hu4e8cdd22fa5492e1000904c3b83a230f_36728_9d635b76592479044df7c6d2426dd085.webp&#34;
               width=&#34;757&#34;
               height=&#34;351&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;作为一个基于云的数据仓库，Snowflake 具有很强的灵活性和可伸缩性。Snowflake 基于订阅的模型将存储和计算服务分离，允许它们独立运行。当用户构建插入 Snowflake 的新解决方案时，他们只支付存储数据或根据需要分析数据的费用。此外，该系统还构建了一个相互连接的云服务器阵列，将数据分散，允许组织内的单个用户或组访问他们需要的特定数据，而无需复杂的数据传输，简化了连接和分析。&lt;/p&gt;
&lt;p&gt;对于云原生数据仓库来说，能够在不影响底层的情况下快速查询数据并使用实时数据执行分析是一个强大的功能。由于数据不断地被各种各样的系统所创建，其中许多系统最初都是云端固有的，因此实时分析这些数据的能力对现代公司至关重要。实时分析会根据需要，只对特定实例和项目收费而不产生更高的成本。&lt;/p&gt;
&lt;p&gt;Snowflake 在今年 2 月份完成了 4.79 亿美元的 G 轮融资，估值高达 124 亿美元，投资机构包括 Salesforce Ventures，Snowflake 还由此宣布了与 Salesforce 的战略合作伙伴关系。Snowflake 在《福布斯》最新的“云 100 强”榜单中位列第二，仅次于 Stripe。&lt;/p&gt;
&lt;p&gt;云原生技术层的机会我还在《&lt;a href=&#34;http://mp.weixin.qq.com/s%3F__biz%3DMzA4MzA4ODY4MA%3D%3D%26mid%3D2656633045%26idx%3D1%26sn%3Dbcf34dc1bffd8de08fba4d64226c5020%26chksm%3D84566492b321ed843bed999a651e0f7275d0fd149e3313e86a961ec5d0c15fdfe330f458d7e2%26scene%3D21%23wechat_redirect&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;信天研报 | 虚拟化与超融合（一）&lt;/a&gt;》系列里提到过，由于容器技术对于传统虚拟机的冲击，众多创业公司正在解构 VMware，这将在该系列详细讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;云原生应用层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;云原生能广泛应用在所有的行业，并发挥其快速、灵活、弹性、扩展性强、迁移能力强等多种优势。在这里我仅抛砖引玉，分析下云原生游戏的优点。&lt;/p&gt;
&lt;p&gt;围绕云游戏的许多讨论都集中在其“杀死控制台”的潜力上，从而消除了本地硬件玩游戏的需求。但是，对硬件的持续关注未能抓住云游戏的真正潜力。云游戏的真正创新不仅仅在于我们怎么玩游戏方式，还在于我们玩什么游戏：“云原生”游戏将完全颠覆游戏体验本身，以及这些游戏的销售和销售方式。&lt;/p&gt;
&lt;p&gt;云原生游戏是专门为云开发的游戏，其中客户端和服务器托管在同一架构中，有可能产生全新的游戏体验和商业模式。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;病毒式传播&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;大多数 MMO（Massively Multiplayer Online，大型多人在线）游戏具有固有的网络效应，这意味着与更多玩家一起玩游戏会更加有趣。然而，MMO 通常会遇到冷启动问题：一开始，没有足够的参与者来创造积极的体验，从而导致新用户的流失。与朋友合作玩耍是最好的招募和留住新用户的方式，但是在此过程中可能会遇到很多障碍。例如，用户可以在不同时间或在不同平台上玩。由于不透明的配对规则和服务器限制，在游戏中寻找朋友可能很麻烦。&lt;/p&gt;
&lt;p&gt;利用云原生开发的 MMO 游戏本质上是跨平台的，因此可以从任何设备上访问。没有下载、安装，或者加载时间，用户不用再为了补丁或者一个游戏的副本需要等待三个小时。&lt;/p&gt;
&lt;p&gt;为了简化入门过程，云原生游戏可以使用深层链接来无缝地允许新玩家加入朋友的游戏会话。同时，想要获得更轻松体验的用户可以实时选择确切的时点来参加比赛或作为旁观者。&lt;/p&gt;
&lt;p&gt;这些支持云的功能共同加速了多人游戏固有的网络效果。如果成功的话，第一个云原生 MMO 游戏可能会完全通过玩家主导的招募而快速发展，其病毒增长曲线比传统的 MMO 更类似于 Facebook。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创造视频营销机会&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了更强大的病毒性之外，云原生游戏还将为 AAA（3A 大作，高成本、高体量、高质量）游戏提供新的营销形式。传统上 AAA 游戏依赖于广告牌和展示广告等营销方式。在没有安装时间的情况下，潜在玩家将能够单击链接立即尝试一款游戏—这是一个巨大的进步。&lt;/p&gt;
&lt;p&gt;随着云游戏的普及，视频和有影响力的营销将变得越来越重要。销售佣金和“点击加入”可能会成为云游戏经济中网络大 V 收入的最大来源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现 AI 驱动的实时内容生成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于客户端和服务器在同一个网络中，云原生游戏可以方便的跟踪和收集用户旅程中几乎所有的数据，这使得我们可以以开创性的方式在游戏中增强人工智能和机器学习能力。&lt;/p&gt;
&lt;p&gt;例如，游戏长期以来通过出售改变玩家外观或周围世界的化妆品来赚钱。由于云提供无限的数据、处理能力和最小的客户端 - 服务器延迟，人工智能可以实时生成完全动态的环境。以下是基于 Nvidia 深度学习系统的剪辑，显示用户在 AI 的帮助下修改了一个逼真的虚拟环境：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-era/007S8ZIlly1gfhd59dajrj30sg0ebgnv_hu14db7a7a36f57bbb2315dac5a6b4fa01_103467_efcfccaf732c7f177a1ad4b1161c3483.webp 400w,
               /blog/cloud-native-era/007S8ZIlly1gfhd59dajrj30sg0ebgnv_hu14db7a7a36f57bbb2315dac5a6b4fa01_103467_09350993851650611504250b12525496.webp 760w,
               /blog/cloud-native-era/007S8ZIlly1gfhd59dajrj30sg0ebgnv_hu14db7a7a36f57bbb2315dac5a6b4fa01_103467_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-era/007S8ZIlly1gfhd59dajrj30sg0ebgnv_hu14db7a7a36f57bbb2315dac5a6b4fa01_103467_efcfccaf732c7f177a1ad4b1161c3483.webp&#34;
               width=&#34;760&#34;
               height=&#34;382&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;将来，实时内容生成可能会催生新的、沉浸式的故事讲述方法。下一代的“选择你自己的冒险”可能是一个虚拟世界，实时适应你的选择。为了使这些虚拟世界货币化、个性化，自发性的广告可能会出现，类似于《少数派报告》中的生物识别广告。&lt;/p&gt;
&lt;p&gt;更远的未来，AI 驱动、程序生成的世界可以为用户提供一个无尽的游乐场，那时距离《头号玩家》里的绿洲世界或者著名的网络世界 - 元界（Metaverse）已经不远。&lt;/p&gt;
&lt;p&gt;预计我们将在两三年内看到第一款云原生游戏上市，在谷歌、微软、亚马逊和其他许多公司的投资推动下，下一代云原生游戏将有潜力重塑我们所知道的游戏体验。&lt;/p&gt;
&lt;p&gt;在上述认知的推动下，A16Z、腾讯、淡马锡投资了免费沙盒 MMO 游戏 Roblox 的 1.5 亿美金的 G 轮，相应估值高达 40 亿美元，他们认为未来游戏将不再只是游戏，甚至将比电影和音乐加在一起的规模还大。游戏的发展也将推动技术革新，而 Roblox 作为世界上最大的社交平台和多人游戏平台之一，接下来将有望成为未来的 Metaverse。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在最后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至此，这篇接近 4 万字的《云原生时代》已接近尾声。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我们再来梳理下本文的核心观点：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;云原生、中台、微服务、CI/CD、Devops、SaaS 背后的理念是一致的&lt;/li&gt;
&lt;li&gt;即更快速、更灵活、更轻量、更自动，从开发开始，不断实现企业的产品目标和业务目标&lt;/li&gt;
&lt;li&gt;类似理念涉及的维度包括开发、产品、运维、销售，从产品、服务到组织结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;如何判断云原生技术层的项目？&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否拥有核心技术是关键&lt;/li&gt;
&lt;li&gt;单点产品的价值和延展性要足够强。参照 Rancher、HashiCorp、Kong&lt;/li&gt;
&lt;li&gt;面向客户提供一整套产品化的解决方案具有更大价值&lt;/li&gt;
&lt;li&gt;在云原生体系里，开源项目比普通商业项目更占优势。开源项目更容易被其它产品支持和集成；云原生架构早期使用者以开发者为主，开源项目更容易快速建立口碑和影响力；在社区支持下，开源项目质量更容易得到保证&lt;/li&gt;
&lt;li&gt;尽量选择成熟和被市场验证的技术和产品&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;国内的创业机会是否已经到来？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;国内已经出现了像 PingCap、Kylin、SkyWalking、Dubbo、ServiceComb 等优秀的开源项目，在云原生技术不断成熟和普及、国内开源文化和社区逐渐兴起、去 IOE 和自主可控的时代背景下，国内对标海外的创业机会将会不断涌现。不过由于国内企业 IT 水平参差不齐，像 API 集成、API 管理等领域的创业时机尚早，所以选择合适的产品切入点和行业将成为成败的关键，另外团队对软件本质的理解、销售和客户服务能力也是相当重要的因素。&lt;/p&gt;
&lt;p&gt;最后，我真心希望未来 3 到 5 年中国新一代的基础软件企业能够高举国产化的大旗，灯火辉煌。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.anquanke.com/post/id/171987&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;绿盟科技解读 2019 创新沙盒&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.uedbox.com/post/56424/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;被 Palo Alto 4.1 亿美元收购的 Twistlock 是一家什么公司？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.raincapital.vc/blog/2020/3/17/detection-engineering-for-cloud-native-security&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DETECTION ENGINEERING FOR CLOUD-NATIVE SECURITY&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/nulige/articles/10929182.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一文搞懂蓝绿发布、灰度发布和滚动发布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/luoahong/p/12358346.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;深入剖析 Kubernetes 学习笔记：“控制器”模型（16）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sohu.com/a/211846555_617676&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;技术专栏 | 云原生应用之路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/chenqionghe/p/11454248.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;极简 Docker 和 Kubernetes 发展史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/karamos/article/details/80124967&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker 生态到底会不会重蹈 Hadoop 的覆辙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/apanly/p/8784096.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;金丝雀发布、滚动发布、蓝绿发布到底有什么差别？关键点是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.forbes.com/sites/janakirammsv/2020/03/04/15-most-interesting-cloud-native-trends-from-the-cncf-survey/#5f8d93dd34d5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;15 Most Interesting Cloud Native Trends From The CNCF Survey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_38987057/article/details/85263234&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;10 分钟看懂 Docker 和 K8S&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/chenqionghe/p/11454248.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;极简 Docker 和 Kubernetes 发展史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/yellowzf3/article/details/103046573&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;“中台不就是微服务吗？有啥区别？”&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/cf2SudS8x8F0v/article/details/82836707&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;火热的云原生到底是什么？一文了解云原生四要素！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/009d98e30b2a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大神告诉你如何理解微服务框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/4FJXNTHJMio6g75uSX0h?from=timeline&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh 和 API Gateway 关系深度探讨&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/skabyy/p/11396571.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一文详解微服务架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u013970991/article/details/53333921&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Martin Fowler 关于微服务的原文翻译（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yq.aliyun.com/articles/8611&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务架构的理论基础 - 康威定律&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codetd.com/en/article/7965165&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A text interpretation of the cloud native (rpm)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/_1Cx9nNRNqc_P-S91B5LWA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;走访了十几家美国企业服务公司，我们写下了这篇万字文章 | GGV 投资笔记第一期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/d411e8650f92&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;从 Uber 微服务看最佳实践如何炼成？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sohu.com/a/144114294_465914&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mashape 和 RapidAPI 合并，组成全球最大的应用编程接口（API）集市！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://new.qq.com/omn/20200418/20200418A073KV00.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;放弃微服务，改用宏服务，Uber 这波什么操作？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1583992&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;腾讯大牛深入浅出详解云原生&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sohu.com/a/235470843_99984800&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;【零壹视界】从 Salesforce 收购 Mulesoft 说起，白话讲讲企业数据交换 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/65089ec63e1e&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EnjoyingSoft 之 Mule ESB 开发教程第一篇：初识 Mule ESB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/imyalost/p/6792724.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_35368183/article/details/84558134&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;持续集成、持续交付、持续部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sohu.com/a/313149935_115128&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为什么你必须了解云原生？！ &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackify.com/cloud-native/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;What is Cloud-Native? Is It Hype or The Future of Software Development?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;本文转载自：蒋宇捷的企业服务投资洞察。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/143417185&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生时代（一）云原生及 CNCF 基金会&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/143424111&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生时代（二）：DevOps 与 CI/CD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/143472291&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生时代（三）：微服务、API 管理与集成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/144292368&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生时代（四）：容器和 Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/144452103&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生时代（五）：Kubernetes 与容器编排之战&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/145871049&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生时代（六）：机会与思考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>利用 OAM 和 Dapr 的云原生应用的未来</title>
      <link>https://cloudnative.to/blog/the-future-of-cloud-native-applications-with-oam-and-dapr/</link>
      <pubDate>Sun, 26 Jan 2020 10:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/the-future-of-cloud-native-applications-with-oam-and-dapr/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://hugomsbarona.medium.com/the-future-of-cloud-native-applications-with-oam-and-dapr-ed5766c8d583&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Future of Cloud Native Applications With OAM and Dapr&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在 2019 年 11 月 4 日至 8 日于佛罗里达州奥兰多举办的&lt;a href=&#34;https://www.microsoft.com/en-us/ignite&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2019 年微软 Ignite 大会上&lt;/a&gt;，Azure 首席技术官 Mark Russinovich 介绍了微软开发的两个创新和革命性的项目，旨在解决当今 IT 专业人士和开发人员在试图构建基于微服务的应用程序时的一系列现有问题。这场会议被命名为《基于开放应用模型（OAM）和分布式应用运行时（Dapr）的云原生应用的未来》。&lt;/p&gt;
&lt;h2 id=&#34;开放式应用模型oam&#34;&gt;开放式应用模型（OAM）&lt;/h2&gt;
&lt;p&gt;因此，其中一个项目与开放应用模型（OAM）有关。它代表了一个开放的标准，允许我们建立云原生应用程序，与平台无关，并遵循关注点分离的原则，通过将应用程序的定义与应用程序的部署和托管基础设施的细节分离，为我们提供一些好处。&lt;/p&gt;
&lt;p&gt;将应用程序的定义与操作细节分开，使应用程序开发人员能够专注于其应用程序的关键要素，并将其从部署地点和方式的操作细节中抽象出来。另外，关注点的分离允许平台架构师开发可重复使用的组件，而应用开发者则专注于将这些组件与他们的代码集成，以快速、轻松地构建可靠的应用。在所有这些方面，OAM 在那些有不同角色的场景中特别有用，比如在下面的图片中，构建和管理应用程序，因为它允许你有一个关注点的分离，所以开发和管理你的应用程序的不同角色可以专注于他们任务的关键因素。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-应用程序开发和部署生命周期中的角色&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;应用程序开发和部署生命周期中的角色&#34; srcset=&#34;
               /blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tisc22aj30vp0hoq5q_hu45a9d590de1d29227fec557b414e4b13_94502_f6232efed1e167e0845dbed3f74af7e3.webp 400w,
               /blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tisc22aj30vp0hoq5q_hu45a9d590de1d29227fec557b414e4b13_94502_f35639bb173e91536f49cc99ca992473.webp 760w,
               /blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tisc22aj30vp0hoq5q_hu45a9d590de1d29227fec557b414e4b13_94502_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tisc22aj30vp0hoq5q_hu45a9d590de1d29227fec557b414e4b13_94502_f6232efed1e167e0845dbed3f74af7e3.webp&#34;
               width=&#34;760&#34;
               height=&#34;423&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      应用程序开发和部署生命周期中的角色
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OAM 引入了几个概念，组成了你的应用程序。其中一个概念是代表你的应用程序的 Component（组件）。这些组件可能是服务，如 SQL 数据库或带有相应负载均衡器的.NET WebAPI。开发人员可以创建代码，将其打包成一个组件，然后创建清单，描述不同组件和其他应用程序之间的关系。有了这个，你就把组件的实现和这些组件如何在一个完整的分布式应用架构中结合起来的描述分开了。&lt;/p&gt;
&lt;p&gt;为了将这些组件转化为具体的应用程序，应用程序运维使用这些组件的配置来形成一个可以被部署的应用程序的具体实例。配置资源是使应用程序运维能够从开发人员提供的组件中运行一个真正的应用程序。&lt;/p&gt;
&lt;p&gt;最后一个概念是 Trait（特征），而你使用它们的集合来描述你的应用环境的特征和它的能力，如自动扩展和入口等等。这些特征允许你根据要求和背景，将你的应用程序部署到具有不同特征的不同环境。然后，这些特征可以由基础设施运维进行配置，以满足其环境的独特操作要求。&lt;/p&gt;
&lt;p&gt;最后但同样重要的是，该规范在设计上是可扩展的。同样，OAM 使平台提供者能够通过 Trait（特征）系统公开其平台的独特特征，这种方式使应用开发者能够在支持必要特征的地方建立跨平台的应用。&lt;/p&gt;
&lt;h2 id=&#34;分布式应用程序运行时dapr&#34;&gt;分布式应用程序运行时（Dapr）&lt;/h2&gt;
&lt;p&gt;Dapr 是一个可移植的、事件驱动的运行时，它使开发人员能够轻松地建立弹性的、无状态和有状态的微服务应用程序，并在云和边缘上运行，并拥抱语言和开发人员框架的多样性。它遵循&lt;strong&gt;Sidecar 架构&lt;/strong&gt;，所以它使用一个连接到你的每个组件的 Sidecar 节点，所以它可以扩展和增强你的应用程序的功能，如服务发现、负载均衡、流量管理等。&lt;/p&gt;
&lt;p&gt;使用这种编程模型，开发人员能够创建微服务应用程序，而不需要携带那么多在构建分布式应用程序过程中引入复杂性的因素，如弹性、可扩展性、服务身份和发现、负载均衡、状态管理等等。Dapr 将这些复杂的因素从开发人员那里抽象出来，这样他们就可以专注于他们正在编写的代码。&lt;/p&gt;
&lt;p&gt;Dapr 的另一个重要方面是与托管我们应用程序的平台有关。Dapr 使我们能够在云端、企业内部、甚至是边缘的多种环境中运行我们的应用程序，包括任何可用于托管应用程序的 Kubernetes 集群。&lt;/p&gt;
&lt;p&gt;最后，同样重要的是，Dapr 允许你利用你最喜欢的编程语言来构建你的分布式应用，并克服你在现今的一些服务中可能面临的编程语言和版本的限制，以构建基于微服务的应用。&lt;/p&gt;
&lt;p&gt;下面的图片提供了一个使用 Dapr 的微服务应用架构的概述。基本上，你使用你喜欢的编程语言或框架，如 Java、Node.js、Python、.NET Core 等，构建构成你的应用程序的服务，然后你的服务使用其可用的标准 API，并使用 HTTP 或 gRPC 协议与 Dapr 通信。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-使用-dapr-的微服务应用架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;使用 Dapr 的微服务应用架构&#34; srcset=&#34;
               /blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tov7gp1j312w0ie40c_hu198ab340490603f20172a016979736e8_47874_7db98abed6898b65bf9d72d0a600fb08.webp 400w,
               /blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tov7gp1j312w0ie40c_hu198ab340490603f20172a016979736e8_47874_540a7b1e050d364ed38b0aaceeda7f99.webp 760w,
               /blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tov7gp1j312w0ie40c_hu198ab340490603f20172a016979736e8_47874_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-future-of-cloud-native-applications-with-oam-and-dapr/008i3skNly1gx6tov7gp1j312w0ie40c_hu198ab340490603f20172a016979736e8_47874_7db98abed6898b65bf9d72d0a600fb08.webp&#34;
               width=&#34;760&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      使用 Dapr 的微服务应用架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;因此，我们有 OAM，它代表了一种规范，允许你定义和建立跨平台的应用程序，在云和边缘上运行，为你提供关注点的分离，让你的团队专注于他们任务和责任的关键要素。&lt;/p&gt;
&lt;p&gt;然后，我们把 Dapr 作为一个运行时，通过提供关注点的分离和促进一些影响构建这种应用的复杂性的因素，降低了构建基于微服务的分布式应用的复杂性。此外，Dapr 允许应用程序在 &amp;ldquo;云和边缘 &amp;ldquo;计算基础设施之间进行移植，并克服目前开发人员在构建此类应用程序时面临的移植问题。&lt;/p&gt;
&lt;p&gt;如果你想获得与这些项目有关的更多细节，请看以下资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://azure.microsoft.com/en-au/resources/videos/ignite-2019-mark-russinovich-presents-the-future-of-cloud-native-applications-with-oam-and-dapr/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mark Russinovich 介绍 OAM 和 Dapr 的云原生应用的未来&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;开放应用模式（OAM）官方网站 - &lt;a href=&#34;https://oam.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://oam.dev/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;分布式应用程序运行时（Dapr）官方网站 - &lt;a href=&#34;https://dapr.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dapr.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>云原生生态周报（Cloud Native Weekly）第 3 期</title>
      <link>https://cloudnative.to/blog/cloud-native-weekly-03/</link>
      <pubDate>Tue, 07 May 2019 15:12:53 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-weekly-03/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;摘要：&lt;/em&gt; Docker Hub 遭入侵，19 万账号被泄露；Java 8 终于开始提供良好的容器支持；Snyk 年度安全报告出炉，容器安全问题形势空前严峻。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;业界要闻&#34;&gt;业界要闻&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnbeta.com/articles/tech/841873.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Docker Hub 遭入侵，19 万账号被泄露&lt;/strong&gt;&lt;/a&gt; &lt;strong&gt;:&lt;/strong&gt; 4 月 25 日 Docker 官方邮件曝露，因为 Hub 的一个数据库收到非授权访问，影响了约 19 万用户的用户名和哈希后的密码，以及用户自动构建的 Github 和 Bitbucket Token。Docker 公司建议用户修改其登录密码。如果您在公有云上的应用依赖于来自 Docker Hub 的镜像，我们强烈建议您登录容器服务控制台更新相应的 docker login 信息或 kubernetes secret。此外，阿里云容器镜像服务&lt;a href=&#34;https://promotion.aliyun.com/ntms/act/acree.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;企业版&lt;/a&gt;提供网络访问控制、独享 OSS Bucket 加密存储等安全加固功能，最大程度保障您的镜像仓库的安全。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.softwaremill.com/docker-support-in-new-java-8-finally-fd595df0ca54&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Java 8 终于开始提供良好的容器支持&lt;/strong&gt;&lt;/a&gt;**：**长久以来，容器 和 Java 就像一对“欢喜冤家”。一方面，容器技术的“不可变基础设施”特性为开发者带来了无比宝贵的依赖与环境一致性保证；但另一方面，Linux 容器通过 Cgroups 对应用进行资源限制的方式跟所有依赖于 JVM 进行资源分配的编程语言都产生了本质的冲突。而就在上周，最近发布的 OpenJDK 镜像 &lt;strong&gt;openjdk:8u212-jdk&lt;/strong&gt; 终于能够让 Java 8 运行时在容器里面为应用分配出合理的 CPU 数目和堆栈大小了。自此，发布 Java 容器应用的痛苦经历，可能要一去不复返了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Snyk 年度安全报告出炉，容器安全问题形势空前严峻：&lt;strong&gt;知名开源安全厂商 Snyk 在年初发布了 2019 年度安全报告。报告中指出：“随着容器技术在 2019 年继续在 IT 环境中爆发式增长，针对容器安全的威胁正在迅猛增加，&lt;strong&gt;任何一家企业现在都必须比以往更加重视&lt;/strong&gt;&lt;a href=&#34;https://help.aliyun.com/document_detail/60751.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;容器镜像安全&lt;/strong&gt;&lt;/a&gt;&lt;/strong&gt;，并将此作为企业的首要任务&lt;/strong&gt;”。报告详情，请&lt;a href=&#34;https://snyk.io/opensourcesecurity-2019/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击此处查看全文&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;上游重要进展&#34;&gt;上游重要进展&lt;/h2&gt;
&lt;p&gt;Kubernetes 项目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;**Kubernetes 集群联邦 v1（Federation v1）正式宣布废弃。**K8s 社区近日宣布将 Federation v1 代码库正式废弃。Federation v1 即 Kubernetes 项目原“集群联邦”特性，旨在通过一个统一的入口管理多个 Kubernetes 集群。&lt;strong&gt;但是，这个特性逐步被设计成了在多个 Kubernetes 集群之上构建一个“Federation 层”的方式来实现&lt;/strong&gt;，从而背离了 Kubernetes 项目的设计初衷。最终，在 RedHat、CoreOS、Google 等多位社区成员的推动下，社区开始全面拥抱 &lt;a href=&#34;https://github.com/kubernetes-sigs/federation-v2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Federation v2&lt;/a&gt;：&lt;strong&gt;一个完全旁路控制、以 K8s API 为核心的多集群管理方案。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/sig-release/tree/master/releases/release-1.15&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Kubernetes 1.15 进入发布节奏&lt;/strong&gt; &lt;/a&gt;K8s 1.15 发布进入日程，5 月 30 日即将 Code Freeze（即：不接受任何功能性 PR）。&lt;/li&gt;
&lt;li&gt;[**&lt;a href=&#34;https://github.com/kubernetes/enhancements/pull/958&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KEP] Ephemeral Containers KEP 合并，进入编码阶段**&lt;/a&gt;。
Ephemeral container 旨在通过在 Pod 里启动一个临时容器的方式，来为用户提供对 Pod 和容器应用进行 debug 和 trouble shooting 的能力。**这种通过“容器设计模式”而非 SSH 等传统手段解决运维难题的思路，对于“不可变基础设施”的重要性不言而喻，**阿里巴巴在“全站云化”过程中也采用了同样的设计来解决类似问题。在上游完成该功能的编码实现后，会通过 kubectl debug 命令方便用户直接使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Knative 项目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;**Knative 逐步弃用原 Build 项目。**按照计划，Tektoncd/Pipeline 子项目已经在 v0.2.0 时移除了对 Build 的依赖。最近，Knative Serving v1beta1 也移除了对 Build 的依赖，目前，社区已经开始制定弃用 Build 的确切方式并通知到 knative 开发者社区。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/eventing/issues/930&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;knative 正在考虑为事件触发（Trigger）引入更高级的规则和策略。&lt;/strong&gt;&lt;/a&gt; 社区正在就 Advanced Filtering 设计一个 提案。该提案提议基于 &lt;a href=&#34;https://github.com/google/cel-spec/blob/9cdb3682ba04109d2e03d9b048986bae113bf36f/doc/intro.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CEL&lt;/a&gt; （Google 维护的一种表达式语言）来进行事件的过滤。具体来说，Trigger 的 filter 字段会增加一个 Spec 字段，然后在 Spec 字段下使用 CEL 语法完成对事件的过滤规则定义。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Istio/Envoy 项目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/about/notes/1.1.4/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Istio 1.1.4 本周正式发布&lt;/strong&gt;&lt;/a&gt;，其中一个重要的功能是更改了 Pilot 的默认行为，对出口流量的控制变化。除了之前通过 Service Entry 与配置特定范围 IP 段来支持访问外部服务，新版本中通过设置环境变量 PILOT_ENABLE_FALLTHROUGH_ROUTE 允许 Envoy 代理将请求传递给未在网格内部配置的服务。更多可以参考&lt;a href=&#34;https://yq.aliyun.com/articles/655489?source_type=cnvol_429_wenzhang&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 流量管理实践&lt;/a&gt;系列文章。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/envoy/issues/6614&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Envoy 正通过 ORCA 改善负载均衡的精准度&lt;/strong&gt;&lt;/a&gt;。
目前 Envoy 可以用于进行负载均衡决策的信息主要是权重和连接数等信息，为了能让 Envoy 的负载均衡更加精准需要为 Envoy 提供更多的决策因素。比如本地和远程机器的负载情况、CPU、内存等信息，更复杂的还可以利用应用程序特定的指标信息来进行决策，比如队列长度。而 ORCA 的目的是定义 Envoy 和上游代理之间传递这些信息的标准。该功能的提出者希望 ORCA 可以成为 Universal Data Plane API (UDPA)。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/envoy/pull/5910&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Envoy 正引入 RPC 去代替共享内存机制以便提高统计模块的的扩展性&lt;/strong&gt;&lt;/a&gt;。
Envoy 当下通过共享内存的方式来保存 stats 数据的这种方式存在很多局限性，比如需要限制 stats 使用固定的内存大小，当有大量集群的时候没办法扩展。这给他升级 stats 子系统的架构带来了不少的阻碍。因此他希望可以通过将 stats 数据以堆内存的方式来保存，然后通过 RPC 在新老进程中传递。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/envoyproxy/envoy/pull/6552&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Envoy 正在 xDS 协议中增加 VHDS 协议减小动态路由信息的更新粒度&lt;/strong&gt;&lt;/a&gt;。
现状是，Envoy 中的路由配置是通过 RDS 来动态更新的，但是 RDS 的粒度太粗了，包含了一个 Listener 下所有的路由配置信息。由于一个 Listener 下面可能会有多个服务，每一个服务对应一个 Virtual Host，因此在更新路由的时候，如果只是其中一个 Virtual Host 更新了，那么会导致所有的路由配置都重新下发而导致通讯负荷偏重。引入 VHDS 就是为了只下发变化的路由信息，从而将更新的路由配置信息量缩小。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Containerd 项目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containerd/containerd/pull/3148&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Non-root&lt;/strong&gt;&lt;/a&gt;&lt;a href=&#34;https://github.com/containerd/containerd/pull/3148&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;用户运行&lt;/strong&gt;&lt;/a&gt;&lt;a href=&#34;https://github.com/containerd/containerd/pull/3148&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; &lt;strong&gt;containerd&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;：&lt;/strong&gt; 近日，社区正在尝试实现无需 root 权限就可以运行 containerd 的能力。在这种场景下，用户可以提前准备好容器所需要的 rootfs，但是 containerd 服务端在清理容器时依然会尝试去 unmount rootfs，对于没有 root 权限的 containerd 进程而言，该步骤必定会失败（mount 操作必须要有 root 权限）。目前 Pivotal 的工程师正在解决这个问题，这种 non-root 模式可以为解决云上安全问题提供新的思路，&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;开源项目推荐&#34;&gt;开源项目推荐&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;本周，我们向您推荐&lt;/strong&gt; &lt;a href=&#34;https://github.com/ilhaan/kubeCDN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;kubeCDN&lt;/strong&gt;&lt;/a&gt; &lt;strong&gt;项目&lt;/strong&gt;。
kubeCDN 项目是一个基于 Kubernetes 实现的自托管 CDN 方案，只要将它部署在分布在不同地域（Region）的 Kubernetes 集群上，你就拥有了一个跨地域进行内容分发的 CDN 网络。而更重要的是，通过 kubeCDN，用户不再需要第三方的内容分发网络，从而重新控制了原本就属于自己的从服务器到用户设备的数据流。kubeCDN 目前只是一个个人项目**，但是这里体现出来的思想确实至关重要的：在不久的未来，每一朵云、每一个数据中心里都会布满 Kubernetes 项目，这将会成为未来云时代基础设施的“第一假设”。** 推荐你阅读 &lt;a href=&#34;https://www.infoq.cn/article/trfu-uB4FPhAB4uLvL4R?utm_source=tuicool&amp;amp;utm_medium=referral&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfoQ 的解读文章&lt;/a&gt;来进一步了解 kubeCND。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;本周阅读推荐&#34;&gt;本周阅读推荐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《Knative 入门——构建基于 Kubernetes 的现代化 Serviceless 应用》中文版，这是一本 O’Reilly 出品的免费电子书，已经由 servicemesher 社区组织完成翻译。提供 &lt;a href=&#34;http://www.servicemesher.com/getting-started-with-knative/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在线阅读&lt;/a&gt; 和 &lt;a href=&#34;http://t.cn/EaB8g6d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PDF 下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;信通院发起的云原生产业联盟出具《云原生技术实践白皮书》，白皮书系统性地梳理了云原生概念、关键技术、应用场景、发展趋势及实践案例。&lt;a href=&#34;https://files.alicdn.com/tpsservice/dd44ce32c783473b595382cad5857ef5.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PDF 链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《&lt;a href=&#34;https://www.infoq.cn/article/7642QHo6vmZvQxFw9&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;阿里云 PB 级 Kubernetes 日志平台建设实践&lt;/a&gt;》Kubernetes 近两年来发展十分迅速，已经成为容器编排领域的事实标准，但是 Kubernetes 中日志采集相对困难。本文来自 InfoQ 记者的采访，文中谈及了如何让使用者专注在“分析”上，远离琐碎的工作。&lt;/li&gt;
&lt;li&gt;《&lt;a href=&#34;https://programmaticponderings.com/2019/04/17/istio-observability-with-go-grpc-and-protocol-buffers-based-microservices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Observability with Go, gRPC, and Protocol Buffers-based Microservices&lt;/a&gt;》，这是一篇很长的博文，介绍可以与 Istio 相适配的观测性组件，用实际的例子演示了如何对以 Go 语言、Protobuf 和 gRPC 为基础的微服务框架进行全面的观测。如果你还对 Prometheus、Grafana、Jaeger 和 Kiali 这几个组件感到既熟悉又陌生，并且好奇如何把它们组合在一起使用来提升微服务的可观测性，这个博客的内容应该会对你很有帮助。&lt;/li&gt;
&lt;li&gt;《&lt;a href=&#34;https://www.infoq.cn/article/hhk37_UC1FgJFCQyIk7c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生的新思考：为什么说容器已经无处不在了？&lt;/a&gt;》这篇文章在对云原生技术总结的同时，对未来应用趋势走向进行了展望。“云原生不但可以很好的支持互联网应用，也在深刻影响着新的计算架构、新的智能数据应用。以容器、服务网格、微服务、Serverless 为代表的云原生技术，带来一种全新的方式来构建应用。”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;名词解释：KEP - Kubernetes Enhancement Proposal，即 Kubernetes 上游设计文档&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本周报由阿里巴巴容器平台联合蚂蚁金服共同发布&lt;/p&gt;
&lt;p&gt;本周作者：张磊，临石，浔鸣，天千，至简，傅伟，汤志敏，王夕宁
责任编辑：木环&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生生态周报（Cloud Native Weekly）第 2 期</title>
      <link>https://cloudnative.to/blog/cloud-native-weekly-02/</link>
      <pubDate>Tue, 23 Apr 2019 10:44:45 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-weekly-02/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/cloud-native-weekly-02/006tNc79ly1g2cdd5x4mfj31uo0m8di3_hu7fbfa01bf0205f46a5a270d12f50b328_41552_44c86f4b067024ac55d462bb41bf1851.webp 400w,
               /blog/cloud-native-weekly-02/006tNc79ly1g2cdd5x4mfj31uo0m8di3_hu7fbfa01bf0205f46a5a270d12f50b328_41552_77aa6e52ebbb430bf7d527937fa0dfc3.webp 760w,
               /blog/cloud-native-weekly-02/006tNc79ly1g2cdd5x4mfj31uo0m8di3_hu7fbfa01bf0205f46a5a270d12f50b328_41552_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cloud-native-weekly-02/006tNc79ly1g2cdd5x4mfj31uo0m8di3_hu7fbfa01bf0205f46a5a270d12f50b328_41552_44c86f4b067024ac55d462bb41bf1851.webp&#34;
               width=&#34;760&#34;
               height=&#34;253&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本周报由阿里巴巴容器平台联合蚂蚁金服共同发布&lt;/p&gt;
&lt;p&gt;本周作者：傅伟，敖小剑，张磊，临石，南异，心贵，王夕宁，长虑&lt;/p&gt;
&lt;p&gt;责任编辑：木环&lt;/p&gt;
&lt;h2 id=&#34;业界要闻&#34;&gt;业界要闻&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tuicool.com/articles/Jfaeqy2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes External Secrets&lt;/a&gt;  近日，世界上最大的域名托管公司 Godaddy 公司，正式宣布并详细解读了其开源的 K8s 外部 Secrets 管理项目： &lt;a href=&#34;https://github.com/godaddy/kubernetes-external-secrets&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes External Secrets&lt;/a&gt;，简称 KES。这个项目定义了 ExternalSecrets API，让开发者可以在 K8s 内部以和使用内部 Secret 相似的方式使用外部系统提供的 Secrets，大大简化了开发者为了让应用获取外部 Secrets 所需要的工作量。从安全的角度，这个方案降低了使用外部 Secret 时候的攻击面（外部 Secret 是通过一个 K8s API 暴露的，而不是之前的每个应用自己实现），也降低了应用在适配外部 Secret 时候的难度。另外，&lt;a href=&#34;https://github.com/AliyunContainerService/ack-kms-plugin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes KMS plugin 开源插件&lt;/a&gt; ，采用信封加密的方式与密钥管理能力结合，对进行 K8s secret 的存储加密。建议安全相关技术人员重点关注。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/y2V3PwOK5qbdmjFsuNTGkg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 官方宣布&lt;/a&gt;为中国开发者提供免费的云原生技术公开课。这些课程将专注于云原生技术堆栈，包括技术深度探索与动手实验课程，旨在帮助和指导中国开发人员在生产环境中使用云原生技术，并了解其用例和优势。此前，著名社区 Stackoverflow 发布了 2019 年开发者调研报告，报告有近九万人参与，Top 3 最受热爱开发平台是分别是 Linux（83.1%）、Docker（77.8%）和 Kubernetes（76.8%）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;上游重要进展&#34;&gt;上游重要进展&lt;/h2&gt;
&lt;p&gt;Kubernetes 项目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[重要性能优化] 2X performance improvement on both required and preferred PodAffinity. (&lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/76243&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;#76243&lt;/a&gt;, &lt;a href=&#34;https://github.com/Huang-Wei&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@Huang-Wei&lt;/a&gt;) 这是一个重要的性能优化。这个提交将 PodAffinity 调度的效率实现了两倍的提高。&lt;strong&gt;要知道，PodAffinity/Anti-affinity 调度规则是目前 K8s 默认调度器最大的性能瓶颈点，这次修复很值得关注。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;[重要安全增强] &lt;a href=&#34;https://github.com/kubernetes/enhancements/pull/944&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KEP: Node-Scoped DaemonSet&lt;/a&gt;: K8s 项目现在提供一种叫 Node-Scoped DaemonSet。这种 DaemonSet 的独特之处，在于它拥有、并且只能拥有自己所在的节点 kubelet 相同的权限，并且遵循同 kubelet 相同的鉴权流程。**这种设计，避免了以往 DaemonSet 权限泛滥的问题（比如：我们现在就可以让 DaemonSet 只能访问到属于该 Node 的 API 资源）。**这个特性发布后，DaemonSet 一直以来都 是 K8s 集群里最优先被黑客们关照的尴尬局面有望从根本上得到缓解。&lt;/li&gt;
&lt;li&gt;[重要功能补丁] &lt;a href=&#34;https://github.com/kubernetes/enhancements/pull/953&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KEP: Add kubelet support lxcfs&lt;/a&gt;: 一直以来，容器里面通过 /proc 文件系统查看 CPU、内存等信息不准确都是一个让人头疼的问题，而挂载 lxcfs 则是这个问题的最常见解决办法。&lt;strong&gt;现在，K8s 上游正在提议将 lxcfs 作为默认支持&lt;/strong&gt;，如果得以合并的话，那对于开发者和运维人员来说，都是个喜闻乐见的事情。&lt;strong&gt;不过，lxcfs 本身是一个需要额外安装的软件，很可能会成为这个阻碍设计的 blocker。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Knative 项目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[Serving v1beta1 API proposal(https://docs.google.com/presentation/d/10wuLMFXyol731WKuO5x7lalWrH0A6YVHa4exIERQaQ8/edit#slide=id.p)&lt;strong&gt;Knative serving API 准备升级到 v1beta1 版本&lt;/strong&gt;，其目标之一是使用标准的 PodSpec，以便更方便的从 K8s Deployment 迁移过来。这个版本和 v1alpha1 对比主要变更有：去掉了 runLatest，缺省默认就是 runLatest；Release 模式可以通过配置 traffic 实现，可以指定各个版本的流量比例；取消 Manual 模式；提供 revision 生成名字的控制；停用 Serving 内置的 Build。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/eventing/issues/918&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Triggers don&amp;rsquo;t use Istio VirtualServices&lt;/a&gt;：Knative Eventing 原有的实现，依赖于 Istio 的 VirtualService 来重写 Host Header，使得接下来 Broker 可以通过 Host  Header 来识别此 Event 是发给哪个 Trigger 的。而最新的做法，则是通过  URL 来进行区分（比如：http://foo-broker-filter-1da3a.default.svc.cluster.local/my-trigger 代表此事件是发送给 my-trigger 的)，&lt;strong&gt;从而解除了 Trigger 对 Istio  VirtualService 的依赖&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/knative/eventing/issues/294&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Remove Istio as a dependency&lt;/a&gt;：除了上述解耦之外，Knative Eventing Channel 和 Bus 的绑定目前也是通过 istio 的 VirtualService 实现的。在这个新的实现方案中，Provisioners 直接把  Bus 的 主机名写到 channel 的状态当中，就不再需要 Istio VirtualService 来充当 Proxy 了。&lt;strong&gt;这些提交，都在透出这样一个事实：Knative 正在逐步减少对 Istio 的各种依赖，这对于一个真正、适用于更广泛场景的 Serverless 基础设施来说，是非常重要的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Istio 项目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[重要安全增强]最近在 Envoy 代理中发现了两个安全漏洞（CVE 2019-9900 和 CVE 2019-9901）。这些漏洞现在已经在 Envoy 版本 1.9.1 中修补，并且相应地嵌入在 Istio 1.1.2 和 Istio 1.0.7 中的 Envoy 版本中。由于 Envoy 是 Istio 不可分割的一部分，因此建议用户立即更新 Istio 以降低这些漏洞带来的安全风险。&lt;/li&gt;
&lt;li&gt;[性能提升] Istio 1.1 中的新增强功能可以提高应用程序性能和服务管理效率，从而实现扩展，Pilot CPU 使用率降低了 90％, 内存使用率降低 50％。业界已有尝试在 Kubernetes 中使用 Pilot 实现服务的流量管理，对应用服务提供多版本管理、灵活的流量治理策略，以支持多种灰度发布场景。可以参考&lt;a href=&#34;https://yq.aliyun.com/articles/667297?source_type=cnvol_422_wenzhang&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Istio 管理应用的灰度发布&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;containerd 项目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containerd/containerd/issues/3198&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;runc v2 shim &lt;/a&gt;&lt;a href=&#34;https://github.com/containerd/containerd/issues/3198&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;支持&lt;/a&gt;&lt;a href=&#34;https://github.com/containerd/containerd/issues/3198&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; cgroup &lt;/a&gt;&lt;a href=&#34;https://github.com/containerd/containerd/issues/3198&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;设置&lt;/a&gt;：containerd 目前支持多个容器使用&lt;a href=&#34;https://github.com/containerd/containerd/pull/3004&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;同一个&lt;/a&gt;&lt;a href=&#34;https://github.com/containerd/containerd/pull/3004&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; containerd-shim &lt;/a&gt;&lt;a href=&#34;https://github.com/containerd/containerd/pull/3004&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;来管理&lt;/a&gt; - 一个 Pod 就可以使用一个 containerd-shim 来管理一组容器，减少 containerd-shim 对系统资源的开销。但是目前新的 shim v2 没有提供配置 Cgroup 接口，这个功能会在 1.3 Release 中解决。有了这个能力之后，上层应用就可以将 containerd-shim 资源控制也纳入 Pod 资源管理体系中，严格控制系统服务占用的资源大小。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containerd/containerd/issues/3210&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;containerd 插件 ID 管理&lt;/a&gt;：containerd 允许开发者将自定义的组件注册到服务里，提供了可插拔的能力。但是当前 containerd 插件的管理是假设 ID 是唯一，这会导致相同 ID 的插件加载结果不可预测。当前该问题还在讨论中，计划在 1.3 Release 中解决。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;本周云原生最佳实践&#34;&gt;本周云原生最佳实践&lt;/h2&gt;
&lt;p&gt;传统富容器运维模式如何云原生化？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在很多企业当中长期以来都在使用富容器模式，即：在业务容器里安装 systemd、sshd、监控进程等系统进程，模拟一个虚拟机的行为。这种运维方式固然方便业务迁入，但是也跟云原生理念中的“不可变基础设施”产生了本质冲突。比如：容器里的内容被操作人员频繁变化给升级、发布带来了众多运维隐患；富容器模式导致开发人员其实并不了解容器概念，在容器里随机位置写日志甚至用户数据等高风险的行为屡见不鲜。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;来自阿里巴巴“全站云化”的实践&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;将富容器容器运行时替换为支持 CRI 体系的标准容器运行时比如 containerd 等。目前阿里已经将 PouchContainer 全面升级为 containerd 发行版。&lt;/li&gt;
&lt;li&gt;把富容器里面的耦合在一起进程、服务进行拆分，变成一个 Pod 里的多个容器，下面是“全站云化”采用的拆分方法：   (1)  业务容器：运行业务主进程，允许 exec 方式进入；(2)  运维 Sidecar 容器：日志收集、debugger、运维辅助进程等；(3)  业务辅助容器：Service Mesh 的 agent&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开源项目推荐&#34;&gt;开源项目推荐&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;本周我们向您推荐&lt;a href=&#34;https://spiffe.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 项目&lt;/a&gt;。SPIFFE，从运维人员的第一感觉而言，是解决证书下发问题的。以往的安全体系更注重自然人的身份认证，而在 SPIFFE 里面所有的运行实体都有身份。一个案例就是 K8s 上的每个 pod 都配置相应的身份，对于多云和混合云的安全角度讲，SPIFFE 的好处在于不被供应商的安全认证体系绑定，可以达到跨云/跨域的身份认证，从而确保安全。下面是我们搜集的一些关于 SPIFFE 的不错的公开资料，有兴趣可以去了解：
&lt;ul&gt;
&lt;li&gt;项目的主要发起人 Evan 的&lt;a href=&#34;https://v.qq.com/x/page/t07113umnwq.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SPIRE 是 SPIFFE 的实现，和 Service Mesh 结合详见&lt;a href=&#34;https://segmentfault.com/a/1190000018432444&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这篇文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.aqniu.com/learn/39145.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE&lt;/a&gt;&lt;a href=&#34;https://www.aqniu.com/learn/39145.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;的零信任安全机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;本周阅读推荐&#34;&gt;本周阅读推荐&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.servicemesher.com/blog/knative-whittling-down-the-code/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative：精简代码之道&lt;/a&gt;，作者 Brian McClain | 译者 孙海洲。这篇文章用循序渐进的例子对“什么是 Knative”做出了很好的回答。如果你现在对 Knative 的认识还停留在三张分别叫做 Build，Serving 和 Eventing 的插图的话，那可能阅读一下这篇文章会让你对它们的理解更加形象。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yq.aliyun.com/articles/695315?source_type=cnvol_422_wenzhang&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spark in action on Kubernetes - 存储篇&lt;/a&gt;，by Alibaba 莫源。存储永远是大数据计算的核心之一，随着新计算场景的不断涌现和硬件技术的飞速发展，存储的适配关系到大规模计算的成本、性能、稳定性等核心竞争要素。本文继上面分析 K8s 中的 Spark Operator 之后，从硬件限制、计算成本和存储成本几个角度，讨论了云原生时代来临后存储如何解决&lt;strong&gt;成本低、存得多、读写快&lt;/strong&gt;这几个挑战，详细介绍了阿里云上相关产品在不同场景下的表现，并总结了不同场景下适用的存储解决方案以及选择的原因。如果你是 K8s 和大数据方面的开发者和使用者，这是一篇你不应该错过的博客，可以快速的帮你梳理当前技术下存储的场景和典型解决方案。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>云原生生态周报（Cloud Native Weekly）第 1 期</title>
      <link>https://cloudnative.to/blog/cloud-native-weekly-01/</link>
      <pubDate>Tue, 16 Apr 2019 19:35:39 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cloud-native-weekly-01/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本周作者：张磊 临石 禅鸣 至简 宋净超&lt;/p&gt;
&lt;p&gt;编辑：木环&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是 Cloud Native 周报第一期。&lt;/p&gt;
&lt;h2 id=&#34;业界要闻&#34;&gt;业界要闻&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在上周于旧金山举办的 Google Cloud Next 2019 大会上，Google Cloud 正式发布了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/run/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Run&lt;/a&gt;。这是一个跟 Microsoft Azure ACI，AWS Fargate 类似的容器实例服务。但与 ACI 和 Fargate 基于虚拟机技术栈的实现不同，Google 的 Cloud Run 服务则是基于 &lt;a href=&#34;https://github.com/knative/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knative&lt;/a&gt; 这个 Kubernetes 原生的 Serverless 基础设施项目完成的。这也是业界第一个基于 Knative + Kubernetes + gVisor 体系的 Serverless 服务。此外，&lt;a href=&#34;https://cloud.google.com/run/pricing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Run 的计费模型&lt;/a&gt;也颇具创新性：它不像 Fargate 那样完全按请求数目计费，而是将所有并发的请求算在一个计费单位内，这有望大大减低用户需要支付的成本。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/traffic-director/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traffic Director&lt;/a&gt;。一个与 AWS App Mesh 对标的 Service Mesh 产品。Traffic Director 通过 xDS 协议与数据平面的 Envoy 进行通讯，可分别与 Google Cloud 的&lt;a href=&#34;https://cloud.google.com/compute/docs/instance-groups/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MIG&lt;/a&gt;和&lt;a href=&#34;https://cloud.google.com/load-balancing/docs/negs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NEG&lt;/a&gt;两款产品结合去提供 Service Mesh 的能力。Traffic Director 的功能与开源 Istio 项目中的 Pilot-discovery 相似，也复用了 Istio 的不少技术实现（比如，通过 iptables 完成流量透明拦截）。Traffic Director 支持全球负载均衡、集中式的集群健康检查、流量驱动的自动扩缩容等功能，帮助客户在全球部署与管理高弹性的无状态应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于 Google Cloud Next 上其他一些比较有意思的发布，你可以阅读 &lt;a href=&#34;https://techcrunch.com/2019/04/10/the-6-most-important-announcements-from-google-cloud-next-2019/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TechCrunch 上的这篇文章&lt;/a&gt;来进一步了解。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;上游重要进展&#34;&gt;上游重要进展&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/enhancements/pull/900&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KEP: Rebase K8s images to distroless&lt;/a&gt;  Kubernetes 即将使用 gcr.io/distroless/static:latest 作为 K8s 核心镜像和 addon 镜像的统一 base 镜像。优势如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使得镜像体积更小，也更加安全。&lt;/li&gt;
&lt;li&gt;极大的减少冗余的 K8s image 的数量。&lt;/li&gt;
&lt;li&gt;通过对底层镜像的统一管理，可以使得 K8s image 更加安全（比如 CVE 的防护），更易于维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/enhancements/pull/906/files&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kustomize: Generator and Transformer Plugins&lt;/a&gt; 将 Kustomize 进行解耦，各项功能由各个 plugin 进行实现，现有的基础功能会作为内置插件。这意味着 Kubernetes 在向基于 Kustomize 的原生应用管理能力上又迈出了坚实的一步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/enhancements/pull/830/files&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Port Troubleshooting Running Pods proposal to KEP&lt;/a&gt; 为 kubectl 添加一个 debug 命令，开发者可以用这个命令来和特定 pod 中的所有容器进行交互和访问。这里的关键设计，在于 Kubernetes 巧妙的利用了 sidecar 容器实现了对应用的非侵入式的 debug，非常值得学习。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/enhancements/pull/887/files&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;keps: sig-node: initial pod overhead proposal&lt;/a&gt; 这个 KEP（Kubernetes Enhancement Proposal）设计了一套机制，使 Pod 能够对系统层面的 额外资源消耗（overhead）进行审计。这里的 overhead 主要包括以下两个部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统组件比如 kubelet，Docker, Linux Kernel，以及 Fluentd 等日志组件带来的 额外资源消耗&lt;/li&gt;
&lt;li&gt;沙箱容器运行时（Sandbox container runtime，比如 KataContainers）本身因为虚拟化和独立 Guest Kernel 所带来的额外的资源消耗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/enhancements/pull/909/files&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RuntimeClass scheduling] native scheduler support, ready to implement&lt;/a&gt; 在这个设计中，Kubernetes RuntimeClass 的信息会被 Kubernetes 直接转义成 Toleration/Taint 信息从而使用 Kubernetes 的默认调度器即可处理。这个设计实现后，Kubernetes 就有了根据应用的需求，自主选择使用 KataContainers 还是 Docker 来运行应用的能力，值得期待。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;开源项目推荐&#34;&gt;开源项目推荐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/kubecost/introducing-kubecost-a-better-approach-to-kubernetes-cost-monitoring-b5450c3ae940&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubecost: 让你的 Kubernetes 服务花费一目了然&lt;/a&gt; 本周，我们强烈推荐你了解一下这个名叫 &lt;a href=&#34;https://github.com/kubecost&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubecost&lt;/a&gt; 的开源项目。它能够按照 Kubernetes 的原生 API 比如 Pod，Deployment，Service，Namespace 等概念逐层监控并详细的计算和展现出每一层上你的真实花费。更重要的是，无论你下层用的是 AWS 还是 GCP，Kubecost 内置的成本模型都可以应对自如。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;本周阅读推荐&#34;&gt;本周阅读推荐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;技术博文：&lt;a href=&#34;https://leebriggs.co.uk/blog/2019/04/13/the-fargate-illusion.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Fargate 幻象》&lt;/a&gt;by Lee Briggs。众所周知，Fargate 是 AWS 目前主推的容器实例服务产品。但是，Fargate 这种产品形态，是不是就是开发者想要的云产品的未来呢？本周，推荐你阅读一篇深入剖析 Fargate 服务的技术博文《Fargate 幻象》。这篇文章不仅能带你理解关于 Fargate 服务的方方面面，也能从一位开发者的角度，跟你聊聊作者眼中到底什么才是 Kubernetes 最具吸引力的“魔法”所在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;技术博文：&lt;a href=&#34;https://itnext.io/benchmark-results-of-kubernetes-network-plugins-cni-over-10gbit-s-network-updated-april-2019-4a9886efe9c4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Benchmark results of Kubernetes netwokr plugins (CNI) over 10Gbit/s network》&lt;/a&gt;，by Alexis Ducastel。这个系列博客专注对 K8s 不同 CNI 网络插件的性能测试，上一篇博客发布于 2018 年 11 月，随着 K8s 1.14 的发布，作者对 up-to-date 的网络插件的性能重新进行了对比。对比的 CNI 包括：Calico v3.3，Canal v3.3，Cilium 1.3.0，Flannel 0.10.0，Kube-router 0.2.1，Romana 2.0.2，WeavNet 2.4.1；对比的内容包括安装难度（Installation）、安全、性能和资源消耗。测试结果不出意外的说明了没有一个 CNI 是所有方面的全能冠军，如何根据自身的需求选择合适的 CNI 方案？阅读这篇文章也需要可以给你很多启发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;技术博文：&lt;a href=&#34;https://crate.io/a/infrastructure-as-code-part-one/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Infrastructure as Code, Part One》&lt;/a&gt;，by Emily Woods。Infrastructure as Code（IaC）是时下非常火热的概念，然而究竟什么是 IaC，谁应该去关心它，它能解决什么痛点，不同的人有不同的答案。这篇博客从一个常见的升级失败展开，讨论我们需要什么样的集群和应用管理方式，集群管理者和应用开发者究竟以什么样的方式共享知识才能更加高效的协作，并描述 IaC 的实践应该如何展开。这篇文章对每一个软件工程师都会有帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;技术博文：&lt;a href=&#34;http://www.servicemesher.com/blog/data-plane-setup/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Istio Sidecar 注入过程解密》&lt;/a&gt;by Manish Chugtu，崔秀龙 译。Sidecar 模式是 Istio 项目工作的核心依赖，也是 Kubernetes 项目“容器设计模式”的最重要的一种。那么你是否会好奇，Istio 中 Istio Sidecar 注入到底是如何完成的呢？相信这篇精心翻译的博文一定能帮你一解究竟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;技术博文：&lt;a href=&#34;http://www.servicemesher.com/blog/istio-cni-note/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Istio 学习笔记：Istio CNI 插件》&lt;/a&gt;by 陈鹏。当前实现将用户 Pod 流量转发到 proxy 的默认方式是使用 privileged 权限的 istio-init 这个 InitContainer 来做的（运行脚本写入 iptables），而 Istio CNI 插件的主要设计目标是消除这个 privileged 权限的 InitContainer，换成利用 k8s CNI 机制来实现相同功能的替代方案。你是否好奇过，这个改进到底是如何实现的？这篇文章，三言两语之间就能为你解释清楚。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
