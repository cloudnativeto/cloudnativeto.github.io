<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Slime | 云原生社区</title>
    <link>https://cloudnative.to/tag/slime/</link>
      <atom:link href="https://cloudnative.to/tag/slime/index.xml" rel="self" type="application/rss+xml" />
    <description>Slime</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 30 Nov 2021 10:03:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>Slime</title>
      <link>https://cloudnative.to/tag/slime/</link>
    </image>
    
    <item>
      <title>网易开源 Istio 扩展项目 Slime 简介——基于 Istio 的智能服务网格管理器</title>
      <link>https://cloudnative.to/blog/smart-istio-management-plane-slime/</link>
      <pubDate>Tue, 30 Nov 2021 10:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/smart-istio-management-plane-slime/</guid>
      <description>&lt;p&gt;最近我在研究 Istio 生态中的开源项目，&lt;a href=&#34;https://github.com/slime-io/slime/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime&lt;/a&gt; 这个项目开源与 2021 年初，是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器。Slime 基于 Kubernetes Operator 实现，可作为 Istio 的 CRD 管理器，无须对 Istio 做任何定制化改造，就可以定义动态的服务治理策略，从而达到自动便捷使用 Istio 和 Envoy 高阶功能的目的。&lt;/p&gt;
&lt;h2 id=&#34;slime-试图解决的问题&#34;&gt;Slime 试图解决的问题&lt;/h2&gt;
&lt;p&gt;Slime 项目的诞生主要为了解决以下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网格内所有服务配置全量下到所有 Sidecar Proxy，导致其消耗大量资源使得应用性能变差的问题&lt;/li&gt;
&lt;li&gt;如何在 Istio 中实现高阶扩展的问题：比如扩展 HTTP 插件；根据服务的资源使用率做到自适应限流&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Slime 解决以上问题的答案是构建 Istio 的控制平面，具体做法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建可拔插控制器&lt;/li&gt;
&lt;li&gt;数据平面监控&lt;/li&gt;
&lt;li&gt;CRD 转换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过以上方式 Slime 可以实现&lt;strong&gt;配置懒加载&lt;/strong&gt;和&lt;strong&gt;插件管理器&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;slime-架构&#34;&gt;Slime 架构&lt;/h2&gt;
&lt;p&gt;Slime 内部分为三大模块，其架构图如下所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-slime-内部架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Slime 内部架构图&#34; srcset=&#34;
               /blog/smart-istio-management-plane-slime/slime-internal-arch_hu87ccfa2b228543dc01157d57cb2e0461_80106_09e59d94028a5eb7d1c92308bac130b2.webp 400w,
               /blog/smart-istio-management-plane-slime/slime-internal-arch_hu87ccfa2b228543dc01157d57cb2e0461_80106_fa19bfbee76ae91dbe029a84b4b353d7.webp 760w,
               /blog/smart-istio-management-plane-slime/slime-internal-arch_hu87ccfa2b228543dc01157d57cb2e0461_80106_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/smart-istio-management-plane-slime/slime-internal-arch_hu87ccfa2b228543dc01157d57cb2e0461_80106_09e59d94028a5eb7d1c92308bac130b2.webp&#34;
               width=&#34;760&#34;
               height=&#34;403&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Slime 内部架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Slime 内部三大组件为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;slime-boot&lt;/code&gt;：在 Kubernetes 上部署 Slime 模块的 operator。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slime-controller&lt;/code&gt;：Slime 的核心组件，监听 Slime CRD 并将其转换为Istio CRD。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slime-metric&lt;/code&gt;：用于获取服务 metrics 信息的组件，&lt;code&gt;slime-controller&lt;/code&gt; 会根据其获取的信息动态调整服务治理规则。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前 Slime 内置了三个控制器子模块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;配置懒加载（按需加载）&lt;/strong&gt;：用户无须手动配置 &lt;code&gt;SidecarScope&lt;/code&gt;，Istio 可以按需加载服务配置和服务发现信息；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP 插件管理&lt;/strong&gt;：使用新的 CRD——&lt;code&gt;pluginmanager/envoyplugin&lt;/code&gt; 包装了可读性，摒弃了可维护性较差的 &lt;code&gt;envoyfilter&lt;/code&gt;，使得插件扩展更为便捷；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自适应限流&lt;/strong&gt;：结合监控信息自动调整限流策略；&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;什么是 SidecarScope？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SidecarScope 是在 Istio 1.1 版本中引入的，它并不是一个直接面向用户的配置项，而是 Sidecar 资源的包装器，具体来说就是 &lt;a href=&#34;../config/networking/sidecar.md&#34;&gt;Sidecar 资源&lt;/a&gt;中的 &lt;code&gt;egress&lt;/code&gt; 选项。通过该配置可以减少 Istio 向 Sidecar 下发的数据量，例如只向某个命名空间中的某些服务下发某些 hosts 的访问配置，从而提高应用提高性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;使用-slime-作为-istio-的控制平面&#34;&gt;使用 Slime 作为 Istio 的控制平面&lt;/h2&gt;
&lt;p&gt;为了解决这些问题，Slime 在 Istio 之上构建了更高层次的抽象，相当于为 Istio 构建了一层管理平面，其工作流程图如下所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-slime-工作流程图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Slime 工作流程图&#34; srcset=&#34;
               /blog/smart-istio-management-plane-slime/slime-flow-chart_hu1b18980b09abbae63ee4d2f3513dfb0c_178799_afddcb2e55215c1662754255d87375f7.webp 400w,
               /blog/smart-istio-management-plane-slime/slime-flow-chart_hu1b18980b09abbae63ee4d2f3513dfb0c_178799_72c0d4084f5b4f31d6c291f6c2b02422.webp 760w,
               /blog/smart-istio-management-plane-slime/slime-flow-chart_hu1b18980b09abbae63ee4d2f3513dfb0c_178799_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/smart-istio-management-plane-slime/slime-flow-chart_hu1b18980b09abbae63ee4d2f3513dfb0c_178799_afddcb2e55215c1662754255d87375f7.webp&#34;
               width=&#34;760&#34;
               height=&#34;417&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Slime 工作流程图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Slime Operator 根据管理员的配置在 Kubernetes 中完成 Slime 组件的初始化；&lt;/li&gt;
&lt;li&gt;开发者创建符合 Slime CRD 规范的配置并应用到 Kubernetes 集群中；&lt;/li&gt;
&lt;li&gt;Slime 查询 Prometheus 中保存的相关服务的监控数据，结合 Slime CRD 中自适应部分的配置，将 Slime CRD 转换为 Istio CRD，同时将其推送到 Global Proxy 中；&lt;/li&gt;
&lt;li&gt;Istio 监听 Istio CRD 的创建；&lt;/li&gt;
&lt;li&gt;Istio 将 Sidecar Proxy 的配置信息推送到数据平面相应的 Sidecar Proxy 中；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上只是一个对 Slime 工作流程的一个笼统的介绍，更多详细信息请参考 &lt;a href=&#34;https://github.com/slime-io/slime/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;配置懒加载&#34;&gt;配置懒加载&lt;/h2&gt;
&lt;p&gt;为了解决数据平面中 Sidecar Proxy 资源消耗过大及网络延迟问题，Slime 使用了配置懒加载（按需加载 Sidecar 配置）的方案。该方案的核心思想是向每个 Sidecar Proxy 中只下发其所 Pod 中服务所需的配置，而不是将网格中的所有服务信息全量下发。所以 Slime 需要获取每个服务的调用关系这样才能得到其所需的 Sidecar Proxy 配置。&lt;/p&gt;
&lt;p&gt;Slime 实现 Sidecar Proxy 配置懒加载的方法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让数据平面中的所有服务的首次调用都通过一个 Global Proxy，该 Proxy 可以记录所有服务的调用和依赖信息，根据该依赖信息更新 Istio 中 Sidecar 资源的配置；&lt;/li&gt;
&lt;li&gt;当某个服务的调用链被 VirtualService 中的路由信息重新定义时， Global Proxy 原有记录就失效了，需要一个新的数据结构来维护该服务的调用关系。Slime 创建了名为 &lt;code&gt;ServiceFence&lt;/code&gt;  的 CRD 来维护服务调用关系以解决服务信息缺失问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用-global-proxy-初始化服务调用拓扑&#34;&gt;使用 Global Proxy 初始化服务调用拓扑&lt;/h3&gt;
&lt;p&gt;Slime 在数据平面中部署 Global Proxy（也叫做 Global Sidecar，但其与应用的 Pod 不是一对一的关系，笔者更倾向于称其为 Global Proxy），该代理同样使用 Envoy 构建，在每个需要启动配置懒加载的命名空间中部署一个或在整个网格中只部署一个，所有缺失服务发现信息的调用（你也可以手动配置服务调用关系），都会被兜底路由劫持到 Global Proxy，经过其首次转发后，Slime 便可感知到被调用方的信息，然后根据其对应服务的 VirtualService，找到服务名和真实后端的映射关系，将两者的都加入 SidecarScope，以后该服务的调用就不再需要经过 Global Proxy 了。&lt;/p&gt;
&lt;h3 id=&#34;使用-servicefence-维护服务调用拓扑&#34;&gt;使用 ServiceFence 维护服务调用拓扑&lt;/h3&gt;
&lt;p&gt;在使用 Global Proxy 初始化服务调用拓扑后，一旦服务调用链有变动的话怎么办？对此 Slime 创建了 ServiceFence 的 CRD。使用 ServiceFence 可以维护服务名和后端服务的映射关系。Slime 根据其对应服务的 VirtualService，找到 Kubernetes 服务名和真实后端（host）的映射关系，将两者的都加入 Sidecar 的配置中。ServiceFence 管理生成的 SidecarScope 的生命周期，自动清理长时间不用的调用关系，从而避免上述问题。&lt;/p&gt;
&lt;h3 id=&#34;如何开启配置懒加载&#34;&gt;如何开启配置懒加载&lt;/h3&gt;
&lt;p&gt;配置懒加载功能对于终端用户是透明的，只需要 Kubernetes  Service 上打上 &lt;code&gt;istio.dependency.servicefence/status:&amp;quot;true&amp;quot;&lt;/code&gt; 的标签，表明该服务需要开启配置懒加载，剩下的事情交给 Slime Operator 来完成即可。&lt;/p&gt;
&lt;h2 id=&#34;http-插件管理&#34;&gt;HTTP 插件管理&lt;/h2&gt;
&lt;p&gt;Istio 中的插件扩展只能通过 EnvoyFilter 来实现，因为它是 xDS 层面的配置，管理和维护这样的配置需要耗费大量的精力，也极容易出错。因此，Slime 在 EnvoyFilter 的基础上做了一层面向插件的抽象。&lt;/p&gt;
&lt;p&gt;Slime 共有两个 CRD 用于 HTTP 插件管理，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PluginManager&lt;/strong&gt;：配置为哪些负载开启哪些插件，插件的配置顺序即为执行顺序；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EnvoyPlugin&lt;/strong&gt;：EnvoyPlugin 不关心每个插件的具体配置，具体配置会被放在 EnvoyFilter 资源的 &lt;code&gt;patch.typed_config&lt;/code&gt; 结构中透传），EnvoyPlugin 的核心思想是将插件配置在需要的维度中做聚合，从而限定插件的生鲜范围。这样做一方面更加贴合插件使用者的习惯，另一方面也降低了上层配置的冗余，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于 Slime 中插件管理的详细使用方式请见 &lt;a href=&#34;https://github.com/slime-io/slime/blob/master/doc/zh/plugin_manager.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;自适应限流&#34;&gt;自适应限流&lt;/h2&gt;
&lt;p&gt;Envoy 内置的限流组件功能单一，只能以实例维度配置限流值，无法做到根据应用负载的自适应限流。Slime 通过与 Prometheus metric server 对接，实时的获取监控情况，来动态配置限流值。&lt;/p&gt;
&lt;p&gt;Slime 自适应限流的流程图如下所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-slime-的自适应限流流程图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Slime 的自适应限流流程图&#34; srcset=&#34;
               /blog/smart-istio-management-plane-slime/slime-smart-limiter_hu5e7db63c0da53e2a3e810ecd532d42a3_74160_a4a7dba729f04055ddb43dea734c1180.webp 400w,
               /blog/smart-istio-management-plane-slime/slime-smart-limiter_hu5e7db63c0da53e2a3e810ecd532d42a3_74160_0128687c8cc78fc4fec7c1dfd403b01b.webp 760w,
               /blog/smart-istio-management-plane-slime/slime-smart-limiter_hu5e7db63c0da53e2a3e810ecd532d42a3_74160_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/smart-istio-management-plane-slime/slime-smart-limiter_hu5e7db63c0da53e2a3e810ecd532d42a3_74160_a4a7dba729f04055ddb43dea734c1180.webp&#34;
               width=&#34;760&#34;
               height=&#34;571&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Slime 的自适应限流流程图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Slime 的自适应限流的流程分为两部分，一部分为 SmartLimiter 到 EnvoyFilter 的转换，另一部分为获取监控数据。目前 Slime 支持从 Kubernetes Metric Server 获取服务的CPU、内存、副本数等数据。Slime 还对外提供了一套监控数据接口（Metric Discovery Server），通过 MDS，可以将自定义的监控指标同步给限流组件。&lt;/p&gt;
&lt;p&gt;Slime 创建的 CRD &lt;code&gt;SmartLimiter&lt;/code&gt; 用于配置自适应限流。其的配置是接近自然语义，例如希望在 CPU 超过 80% 时触发服务 A 的访问限制，限额为 30QPS，对应的SmartLimiter 定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;microservice.netease.com/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;SmartLimiter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;descriptors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fill_interval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;seconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;quota&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;30/{pod}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 30为该服务的额度，将其均分给每个 pod，加入有 3 个 pod，则每个 pod 的限流为 10&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{cpu}&amp;gt;0.8&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 根据监控项{cpu}的值自动填充该模板&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;更多&#34;&gt;更多&lt;/h2&gt;
&lt;p&gt;Slime 开源于 2021 年初，本文发稿时该项目仍处于初级阶段，本文大量参考了杨笛航在云原生社区中的分享 &lt;a href=&#34;https://cloudnative.to/blog/netease-slime/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime：让 Istio 服务网格变得更加高效与智能&lt;/a&gt; 及 Slime 的 &lt;a href=&#34;https://github.com/slime-io/slime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt;。感兴趣的读者可以关注下这个项目的 GitHub，进一步了解它。&lt;/p&gt;
&lt;p&gt;另外欢迎关注服务网格和 Istio 的朋友加入&lt;a href=&#34;https://cloudnative.to/sig-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区 Istio SIG&lt;/a&gt;，一起参与讨论和交流。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/blog/netease-slime/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime：让 Istio 服务网格变得更加高效与智能 - cloudnative.to&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/slime-io/slime/blob/master/README_ZH.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime GitHub 文档 - github.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/docs/reference/config/networking/sidecar/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sidecar - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>都 2021 年了，对于服务网格，社区到底在讨论什么？</title>
      <link>https://cloudnative.to/blog/jimmy-service-mesh-talk/</link>
      <pubDate>Wed, 24 Nov 2021 10:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/jimmy-service-mesh-talk/</guid>
      <description>&lt;p&gt;本文根据 2021 年 11 月 22 日晚我应极客邦邀请在「极客时间训练营」的直播分享《云原生漫谈：聊聊 Service Mesh 的现状》整理而成，赵化冰参与了本文的审校。&lt;/p&gt;
&lt;p&gt;本来极客时间是想邀请我分享云原生的，但我觉得那个范围太大，在一次分享中只能泛泛而谈，无法聚焦到一个具体的点，因此我想还是先聚焦在服务网格这一个专题上吧。云原生社区最近倒是在做一个&lt;a href=&#34;https://mp.weixin.qq.com/s/FWUkc1HJobhZgb26pG73Cg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生系列的分享&lt;/a&gt;，大家可以关注下。&lt;/p&gt;
&lt;p&gt;这是我今天分享的大纲：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一探讨下服务网格跟云原生的关系&lt;/li&gt;
&lt;li&gt;第二是给大家陈述下我观察到的目前社区里关于服务网格有哪些争论&lt;/li&gt;
&lt;li&gt;第三是给大家介绍几个服务网格的相关的开源项目&lt;/li&gt;
&lt;li&gt;最后是畅想下服务网格未来的发展&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;服务网格与云原生的关系&#34;&gt;服务网格与云原生的关系&lt;/h2&gt;
&lt;p&gt;首先我们将探讨下服务网格与云原生的关系。&lt;/p&gt;
&lt;h3 id=&#34;服务网格容器编排大战后的产物&#34;&gt;服务网格——容器编排大战后的产物&lt;/h3&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-docker-swarm-vs-kubernetes-vs-mesos&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Docker Swarm vs Kubernetes vs Mesos&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp7oq2980j313w0eqq56_hub2c2421074918c66e7c3d63f751a9a3a_90627_c04183e7d83c5129ff899575af76b768.webp 400w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp7oq2980j313w0eqq56_hub2c2421074918c66e7c3d63f751a9a3a_90627_fe1eb1e6afbc2bf779ed090ea3d8f863.webp 760w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp7oq2980j313w0eqq56_hub2c2421074918c66e7c3d63f751a9a3a_90627_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/008i3skNly1gwp7oq2980j313w0eqq56_hub2c2421074918c66e7c3d63f751a9a3a_90627_c04183e7d83c5129ff899575af76b768.webp&#34;
               width=&#34;760&#34;
               height=&#34;281&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Docker Swarm vs Kubernetes vs Mesos
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果你关注云原生领域足够早的话，应该还会对 2015 到 2017 年间的容器编排大战记忆犹新。关于服务网格的起源已经无需多言。2017 年 Kubernetes 获得了容器大战的胜利，微服务的理念已经深入人心，容器化的趋势可谓势不可挡。Kubernetes 架构趋向成熟，慢慢变得无聊，以 Linkerd、Istio 为代表的服务网格技术进入了 CNCF 定义的云原生关键技术视野中。&lt;/p&gt;
&lt;p&gt;服务网格将微服务中的通用的功能给下沉到了基础设施层，让开发者可以更加专注于业务逻辑，从而加快服务交付，这与整个云原生的理念的一致的。你不需要再在应用中集成笨重的 SDK，为不同语言开发和维护 SDK，应用部署完后，使用服务网格进行 Day 2 操作即可。&lt;/p&gt;
&lt;p&gt;Kubernetes 设计之初就是按照云原生的理念设计的，云原生中有个重要概念就是微服务的架构设计，当将单体应用拆分微服务后， 随着服务数量的增多，如何微服务进行管理以保证服务的 SLA 呢？为了从架构层面上解决这个问题，解放程序员的创造性，避免繁琐的服务发现、监控、分布式追踪等事务，服务网格应运而生。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-微服务关注点&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;微服务关注点&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp7qas2vtj30v70u0whb_hue5667b441245558c6178653686291efd_109834_718164cfe522271a9154e91199d5afca.webp 400w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp7qas2vtj30v70u0whb_hue5667b441245558c6178653686291efd_109834_82f2c5956ec0b48e9e08ac57af74e566.webp 760w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp7qas2vtj30v70u0whb_hue5667b441245558c6178653686291efd_109834_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/008i3skNly1gwp7qas2vtj30v70u0whb_hue5667b441245558c6178653686291efd_109834_718164cfe522271a9154e91199d5afca.webp&#34;
               width=&#34;760&#34;
               height=&#34;731&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      微服务关注点
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;来源：&lt;em&gt;&lt;a href=&#34;https://developers.redhat.com/blog/2016/12/09/spring-cloud-for-microservices-compared-to-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://developers.redhat.com/blog/2016/12/09/spring-cloud-for-microservices-compared-to-kubernetes&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;服务网格被誉为下一代微服务，从右面这幅图里我们可以看到微服务的一些关注点，这些关注点很多与 Kubernetes 的功能是重合的，既然这些作为平台级的功能 Kubernetes 已经提供了，为什么还要使用服务网格呢？其实 Kubernetes 关注的还是应用的生命周期，它管理的对象是资源和部署，对于服务的管控力度很小。而服务网格正好弥补了这个缺陷。服务网格可以连接、控制、观察和保护微服务。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-vs-xds-vs-istio&#34;&gt;Kubernetes vs xDS vs Istio&lt;/h3&gt;
&lt;p&gt;这幅图展示的是 Kubernetes 和 Istio 的分层架构图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-kubernetes-vs-service-mesh&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kubernetes vs Service mesh&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/008i3skNly1gxdhnnh4lxj31820p0gps_huc6a06ccc46be41b97669536a31391769_157085_40f7304f96ea36e36e3a07a5d25fa674.webp 400w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gxdhnnh4lxj31820p0gps_huc6a06ccc46be41b97669536a31391769_157085_4e8e8b1643a0f3ad9a830f6be6587712.webp 760w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gxdhnnh4lxj31820p0gps_huc6a06ccc46be41b97669536a31391769_157085_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/008i3skNly1gxdhnnh4lxj31820p0gps_huc6a06ccc46be41b97669536a31391769_157085_40f7304f96ea36e36e3a07a5d25fa674.webp&#34;
               width=&#34;760&#34;
               height=&#34;431&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kubernetes vs Service mesh
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从图中我们可以看到 kube-proxy 的设置是全局的，无法对每个服务进行细粒度的控制，Kubernetes 可以做的只有拓扑感知路由、将流量就近路由，为 Pod 设置进出站的网络策略。&lt;/p&gt;
&lt;p&gt;而服务网格通过 sidecar proxy 的方式将 Kubernetes 中的流量控制从服务层中抽离出来，为每个 Pod 中注入代理，并通过一个控制平面来操控这些分布式代理。这样可以实现更大的弹性。&lt;/p&gt;
&lt;p&gt;Kube-proxy 实现了一个 Kubernetes 服务的多个 pod 实例之间的流量负载均衡，但如何对这些服务之间的流量进行精细化控制–比如将流量按百分比划分给不同的应用版本（这些应用版本都是同一个服务的一部分，但在不同的部署上），或者做金丝雀发布（灰度发布）和蓝绿发布？&lt;/p&gt;
&lt;p&gt;Kubernetes 社区给出了一个使用 Deployment 做金丝雀发布的方法，本质上是通过修改 pod 的标签来给部署的服务分配不同的 pod。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-envoy-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Envoy 架构图&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/envoy-arch_huc044cb3d9b491193667c35824f281f2f_199961_b3386fe8c961c96f109bc82ba523b187.webp 400w,
               /blog/jimmy-service-mesh-talk/envoy-arch_huc044cb3d9b491193667c35824f281f2f_199961_fa064a5117d48fc300192778df34196d.webp 760w,
               /blog/jimmy-service-mesh-talk/envoy-arch_huc044cb3d9b491193667c35824f281f2f_199961_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/envoy-arch_huc044cb3d9b491193667c35824f281f2f_199961_b3386fe8c961c96f109bc82ba523b187.webp&#34;
               width=&#34;760&#34;
               height=&#34;550&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Envoy 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;目前在中国最流行的服务网格开源实现是 Istio，也有很多公司对 Istio 进行了二次开发，比如蚂蚁、网易、腾讯等，其实 Istio 是在 Envoy 的基础上开发的，从它开源的第一天起就默认使用了 Envoy 作为它的分布式代理。Envoy 开创性的创造了 xDS 协议，用于分布式网关配置，大大简化了大规模分布式网络的配置。2019 年蚂蚁开源的 MOSN 同样支持了 xDS。Envoy 还是 CNCF 中最早毕业的项目之一，经过大规模的生产应用考验。可以说 Istio 的诞生已经有了很好的基础。&lt;/p&gt;
&lt;p&gt;下表是 Kubernetes、xDS、Istio 三者之间的资源抽象对比。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Kubernetes&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;xDS&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Istio 服务网格&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Endpoint&lt;/td&gt;
&lt;td&gt;Endpoint&lt;/td&gt;
&lt;td&gt;WorkloadEntry&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Service&lt;/td&gt;
&lt;td&gt;Route&lt;/td&gt;
&lt;td&gt;VirtualService&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kube-proxy&lt;/td&gt;
&lt;td&gt;Route&lt;/td&gt;
&lt;td&gt;DestinationRule&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kube-proxy&lt;/td&gt;
&lt;td&gt;Listener&lt;/td&gt;
&lt;td&gt;EnvoyFilter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ingress&lt;/td&gt;
&lt;td&gt;Listener&lt;/td&gt;
&lt;td&gt;Gateway&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Service&lt;/td&gt;
&lt;td&gt;Cluster&lt;/td&gt;
&lt;td&gt;ServiceEntry&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;kube-proxy 组件、xDS 和 Istio 对流量管理的抽象后，现在我们仅从流量管理的角度来看看这三个组件 / 协议的比较。请注意，三者并不完全等同。Kubernetes 更加注重的是应用层面的流量管理，xDS 是更加抽象的协议层面的配置下发，而 Istio 是服务层面的配置。&lt;/p&gt;
&lt;h3 id=&#34;服务网格云原生网络基础设施&#34;&gt;服务网格——云原生网络基础设施&lt;/h3&gt;
&lt;p&gt;在列举过以上 Kubernetes 和服务网格的对比后，我们可以看出服务网格在云原生应用架构中的地位。那就是构建一个云原生网络基础设施，具体来说就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量管理：控制服务间的流量和API调用流，使调用更可靠，增强不同环境下的网络鲁棒性。&lt;/li&gt;
&lt;li&gt;可观测性：了解服务之间的依赖关系和它们之间的性质和流量，提供快速识别定位问题的能力。&lt;/li&gt;
&lt;li&gt;策略实施：通过配置网格而不是以改变代码的方式来控制服务之间的访问策略。&lt;/li&gt;
&lt;li&gt;服务识别与安全：提供在网格里的服务可识别性和安全性保护。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;社区里关于-istio-和服务网格的争论&#34;&gt;社区里关于 Istio 和服务网格的争论&lt;/h2&gt;
&lt;p&gt;然而构建基础设施，可谓牵一发而动全身。理想很丰满，现实很骨感。关于服务网格和 Istio，在社区中也不乏争论。我们来看看有这些争论主要有哪些。&lt;/p&gt;
&lt;p&gt;这里列举了我在社区中观察到的关于 Istio 和服务网格最常见的几个问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有人在生产使用 Istio 吗？&lt;/li&gt;
&lt;li&gt;为 pod 注入 sidecar 后带来的大量资源消耗，影响应用性能？&lt;/li&gt;
&lt;li&gt;Istio 支持的协议有限，不易扩展？&lt;/li&gt;
&lt;li&gt;Istio 太过复杂，老的服务迁移成本太高，业界经验太少，学习曲线陡峭？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一个问题，也是很多人刚加入社区和了解这门技术的时候，问的第一个问题，那是有人在生产使用 Istio 吗？&lt;/p&gt;
&lt;p&gt;随着对 Istio 研究的深入，很多人就会抛出第二个问题，为 pod 注入 sidecar 后带来的大量资源消耗，会影响应用性能吗？&lt;/p&gt;
&lt;p&gt;如果能问到第三个问题，说明对 Istio 有比较强的需求了，大多是使用了自定义的 RPC，对 Istio 的协议扩展有需求。
最后一个问题是抱怨 Istio 的概念太过复杂，也没有一个清晰的迁移路径可以使用，学习曲线太过陡峭。&lt;/p&gt;
&lt;p&gt;下面我将一一回答这些问题。&lt;/p&gt;
&lt;h3 id=&#34;istio-架构稳定生产可用生态渐起&#34;&gt;Istio 架构稳定，生产可用，生态渐起&lt;/h3&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-发布时间表&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio 发布时间表&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp7wvt1g8j32yo0nk78g_hu6485f23e60e2e8e9568294bae27898e8_149889_6bd14414dcaf4f7ff268fd5ebc85eaf4.webp 400w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp7wvt1g8j32yo0nk78g_hu6485f23e60e2e8e9568294bae27898e8_149889_23fb46490f44d04fc093c85710460822.webp 760w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp7wvt1g8j32yo0nk78g_hu6485f23e60e2e8e9568294bae27898e8_149889_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/008i3skNly1gwp7wvt1g8j32yo0nk78g_hu6485f23e60e2e8e9568294bae27898e8_149889_6bd14414dcaf4f7ff268fd5ebc85eaf4.webp&#34;
               width=&#34;760&#34;
               height=&#34;168&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio 发布时间表
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先我们来看下 Istio 的发布时间表，1.12 版本在上周刚刚发布，这里列举了从它开源到 1.8 版本发布的时间表。2018 年可以说是服务网格爆发之年，Tetrate 也在这一年成立。自1.5 版本起 Istio 正式确立了当前的架构。Istio 社区也也举办了丰富多彩的活动，2021 年 3 月首届 IstioCon 召开，7 月 Istio Meetup China 在北京举行，2022 年 1 月，Service Mesh Summit 2022 也将在上海举行。&lt;/p&gt;
&lt;p&gt;Istio 有着庞大的社区以及&lt;a href=&#34;https://istio.io/latest/about/case-studies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;供应商和用户群体&lt;/a&gt;。目前主流公有云全都支持了 Istio 服务网格，如阿里云、华为云、腾讯云、网易云等，Istio 的官网上也列举了几十个社区用户，云原生社区 Istio SIG 还陆续举办了八场 &lt;a href=&#34;https://cloudnative.to/sig-istio/big-talk/overview.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 大咖说&lt;/a&gt;，百度、腾讯、网易、小红书、小电科技都来分享过他们的 Istio 实践。&lt;/p&gt;
&lt;p&gt;还有很多企业基于 Istio 做了二次开发或者适配或者为其开发插件，可以说是 Istio 架构已稳定，生产可用，生态正在萌芽中。&lt;/p&gt;
&lt;h3 id=&#34;服务网格对应用性能的影响&#34;&gt;服务网格对应用性能的影响&lt;/h3&gt;
&lt;p&gt;服务网格为了做到对应用程序透明，默认采用了 iptables 流量劫持的方式，当服务数量大的时候会有大量的 iptables 规则，影响网络性能，你可以使用 &lt;a href=&#34;https://cloudnative.to/blog/how-ebpf-streamlines-the-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 这样的技术来提高应用性能，但是该技术对操作系统内核的版本要求比较高，很少有企业能够达到。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-中的智能-dns-代理&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio 中的智能 DNS 代理&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp81fy0vqj31lq0nq41q_hub2b5a7dbce4fa921d9444e7622a39079_121662_1c95be6a38c8d862448d8de641e329d2.webp 400w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp81fy0vqj31lq0nq41q_hub2b5a7dbce4fa921d9444e7622a39079_121662_833794e306f656f4db46bfa98289fc95.webp 760w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp81fy0vqj31lq0nq41q_hub2b5a7dbce4fa921d9444e7622a39079_121662_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/008i3skNly1gwp81fy0vqj31lq0nq41q_hub2b5a7dbce4fa921d9444e7622a39079_121662_1c95be6a38c8d862448d8de641e329d2.webp&#34;
               width=&#34;760&#34;
               height=&#34;312&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio 中的智能 DNS 代理
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&#34;https://cloudnative.to/blog/istio-dns-proxy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://cloudnative.to/blog/istio-dns-proxy/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有一种方式，也是&lt;a href=&#34;https://cloudnative.to/sig-istio/big-talk/ep08.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;小红书使用的方式&lt;/a&gt;，那就是利用 Istio 1.8 中引入的智能 DNS 代理功能。首先使用 ServiceEntry 定义服务，让所有服务属于一个 VIP 范围，再利用 Istio 的智能 DNS 代理功能，让sidecar只拦截 VIP 网段的流量，这样可以减少 iptables 规则，从而提高性能。如果想深入了解这个做法的细节，大家可以去浏览 &lt;a href=&#34;https://www.bilibili.com/video/BV12b4y187ae/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 大咖说第八期的分享视频&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Istio 在初期是将整个网格内的所有服务的路由信息全量下发到所有的 proxy sidecar 中，会导致 sidecar 占用大量资源，后来 Istio 引入了 &lt;a href=&#34;https://istio.io/latest/docs/reference/config/networking/sidecar/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sidecar 资源&lt;/a&gt;来精细化控制需要下发的代理配置范围，另外还有企业自己开发了配置懒加载功能，例如腾讯云开源的 &lt;a href=&#34;https://github.com/aeraki-framework/aeraki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aeraki&lt;/a&gt;、网易开源的 &lt;a href=&#34;https://github.com/slime-io/slime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime&lt;/a&gt; 都可以实现配置懒加载。我们会在 Istio 开源生态中介绍这两个开源项目。&lt;/p&gt;
&lt;p&gt;最后是一个涉及到 Sidecar proxy 运维的问题，如何在保证流量不断的情况下，升级所有 Envoy 代理，这个阿里开源的 &lt;a href=&#34;https://github.com/openkruise/kruise&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenKruise&lt;/a&gt; 中的 &lt;a href=&#34;https://xie.infoq.cn/article/23ae6d3f0d0260b4797a708a0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SidecarSet&lt;/a&gt; 资源已经给出了解决方案。&lt;/p&gt;
&lt;p&gt;另外 Sidecar 的引入带来的资源消耗以及网络延迟也是在合理的范围内，大家可以参考 Istio 官方博客上的 &lt;a href=&#34;https://istio.io/latest/zh/blog/2019/performance-best-practices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh 基准性能测试&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;扩展-istio-服务网格&#34;&gt;扩展 Istio 服务网格&lt;/h3&gt;
&lt;p&gt;下一个问题是关于扩展 Istio 服务网格的。目前官方社区给出的方案是使用 WebAssembly，目前这种扩展方式在国内用的还比较少，而且性能也堪忧。我观察到的大部分解决方案都是自定义 CRD，基于 Istio 构建服务网格管理平面。&lt;/p&gt;
&lt;p&gt;另外，让 Istio 支持异构环境，适用于一切工作负载，如虚拟机、容器，这个对于终端用户来说也有很强的需求，因为这可以让用户很方便的从传统负载迁移应用到服务网格中。最后是多集群、多网格的混合云流量管理，这个属于比较高阶的需求了。&lt;/p&gt;
&lt;h3 id=&#34;陡峭的学习曲线&#34;&gt;陡峭的学习曲线&lt;/h3&gt;
&lt;p&gt;以下列举的是 Istio 学习资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/zh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 官网中文文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://events.istio.io/istiocon-2021/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IstioCon 2021&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Istio Meetup China&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tetratelabs/istio-weekly&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 大咖说/Istio Weekly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/sig-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区 Istio SIG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://academy.tetrate.io/courses/istio-fundamentals-zh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 基础教程（中文）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://academy.tetrate.io/courses/certified-istio-administrator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Certified Istio Administrator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio 开源至今已有 4 年时间，2018 年时我和敖小剑一起创建了 ServiceMesher 社区，当时组织过 9 次 Service Mesh Meetup，同其他服务网格爱好者一起翻译了 Istio 的官方文档。我还在今年初参与了 IstioCon 2021 的筹办及首届 Istio Meetup China。可以说是亲眼目睹了国内服务网格技术的应用和发展，在这期间也写过和翻译过大量的文章，加入 Tetrate 后，我还参与发布了 Istio 基础教程，免费提供给大家学习。同时 Tetrate 也推出了认证 Istio 管理员考试，用于培养更多行业人才。&lt;/p&gt;
&lt;p&gt;云原生社区组织了 Istio SIG，还推出了 Istio 大咖说直播栏目，为大家分享 Istio 服务网格实践经验。&lt;/p&gt;
&lt;p&gt;下图是 &lt;a href=&#34;https://academy.tetrate.io/courses/istio-fundamentals-zh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 基础教程&lt;/a&gt;的首页截图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-基础教程tetrate-出品&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio 基础教程（Tetrate 出品）&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8rr51ikj31ah0u043i_hu4c150b7fbbf605e276653eeefabc8bbc_187849_c413547c6a4811b7575a157e7d163e97.webp 400w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8rr51ikj31ah0u043i_hu4c150b7fbbf605e276653eeefabc8bbc_187849_7a9143d92cf17ae50b32fcefd7b89894.webp 760w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8rr51ikj31ah0u043i_hu4c150b7fbbf605e276653eeefabc8bbc_187849_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/008i3skNly1gwp8rr51ikj31ah0u043i_hu4c150b7fbbf605e276653eeefabc8bbc_187849_c413547c6a4811b7575a157e7d163e97.webp&#34;
               width=&#34;760&#34;
               height=&#34;491&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio 基础教程（Tetrate 出品）
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果你是刚开始接触服务网格和 Istio，可以先从 Istio 基础教程开始学起。这个线上系列课程是图文并茂的中文课程，可以免费参加。&lt;/p&gt;
&lt;p&gt;好了，我们再来了解下服务网格的社区项目。&lt;/p&gt;
&lt;h2 id=&#34;istio-开源生态&#34;&gt;Istio 开源生态&lt;/h2&gt;
&lt;p&gt;下表中罗列的是基于 Istio 的开源项目。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;项目名称&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;开源时间&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;类别&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;主导公司&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Star 数量&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;与 Istio 的关系&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/envoyproxy/envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2016年 9 月&lt;/td&gt;
&lt;td&gt;网络代理&lt;/td&gt;
&lt;td&gt;云原生高性能边缘/中间服务代理&lt;/td&gt;
&lt;td&gt;Lyft&lt;/td&gt;
&lt;td&gt;18300&lt;/td&gt;
&lt;td&gt;默认的数据平面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/istio/istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2017 年 5 月&lt;/td&gt;
&lt;td&gt;服务网格&lt;/td&gt;
&lt;td&gt;连接、保护、控制和观察服务。&lt;/td&gt;
&lt;td&gt;Google&lt;/td&gt;
&lt;td&gt;28400&lt;/td&gt;
&lt;td&gt;控制平面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/emissary-ingress/emissary&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Emissary Gateway&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2018 年 2 月&lt;/td&gt;
&lt;td&gt;网关&lt;/td&gt;
&lt;td&gt;用于微服务的 Kubernetes 原生 API 网关，基于 Envoy 构建&lt;/td&gt;
&lt;td&gt;Ambassador&lt;/td&gt;
&lt;td&gt;3500&lt;/td&gt;
&lt;td&gt;可连接 Istio&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/apache/apisix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;APISIX&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2019 年 6 月&lt;/td&gt;
&lt;td&gt;网关&lt;/td&gt;
&lt;td&gt;云原生 API 网关&lt;/td&gt;
&lt;td&gt;API7&lt;/td&gt;
&lt;td&gt;7400&lt;/td&gt;
&lt;td&gt;可作为 Istio 的数据平面运行也可以单独作为网关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/mosn/mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MOSN&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2019 年 12 月&lt;/td&gt;
&lt;td&gt;代理&lt;/td&gt;
&lt;td&gt;云原生边缘网关及代理&lt;/td&gt;
&lt;td&gt;蚂蚁&lt;/td&gt;
&lt;td&gt;3400&lt;/td&gt;
&lt;td&gt;可作为 Istio 数据平面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/slime-io/slime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slime&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2021 年 1月&lt;/td&gt;
&lt;td&gt;扩展&lt;/td&gt;
&lt;td&gt;基于 Istio 的智能服务网格管理器&lt;/td&gt;
&lt;td&gt;网易&lt;/td&gt;
&lt;td&gt;204&lt;/td&gt;
&lt;td&gt;为 Istio 增加一个管理平面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/tetratelabs/getmesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GetMesh&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2021 年 2 月&lt;/td&gt;
&lt;td&gt;工具&lt;/td&gt;
&lt;td&gt;Istio 集成和命令行管理工具&lt;/td&gt;
&lt;td&gt;Tetrate&lt;/td&gt;
&lt;td&gt;91&lt;/td&gt;
&lt;td&gt;实用工具，可用于 Istio 多版本管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/aeraki-framework/aeraki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aeraki&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2021 年 3 月&lt;/td&gt;
&lt;td&gt;扩展&lt;/td&gt;
&lt;td&gt;管理 Istio 的任何七层负载&lt;/td&gt;
&lt;td&gt;腾讯&lt;/td&gt;
&lt;td&gt;307&lt;/td&gt;
&lt;td&gt;扩展多协议支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/mosn/layotto/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Layotto&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2021 年 6 月&lt;/td&gt;
&lt;td&gt;运行时&lt;/td&gt;
&lt;td&gt;云原生应用运行时&lt;/td&gt;
&lt;td&gt;蚂蚁&lt;/td&gt;
&lt;td&gt;325&lt;/td&gt;
&lt;td&gt;可以作为 Istio 的数据平面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/hango-io/hango-gateway&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hango Gateway&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2021 年 8 月&lt;/td&gt;
&lt;td&gt;网关&lt;/td&gt;
&lt;td&gt;基于 Envoy 和 Istio 构建的 API 网关&lt;/td&gt;
&lt;td&gt;网易&lt;/td&gt;
&lt;td&gt;187&lt;/td&gt;
&lt;td&gt;可与 Istio 集成&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从 2017 年 5 月 Istio 开源至今也有 4 年多了，虽然该项目在 GitHub 上已经有很高的关注度，并发布了 10 几个版本，但其开源生态还在萌芽期。这张表列举了 Istio 生态中的开源项目，统计截止到 2021 年 11 月 11 日，表格按照开源时间排序。这些项目在 Istio 服务网格之上增强了网关、扩展和实用工具等。我将挑选其中 2 个来着重分享下。&lt;/p&gt;
&lt;h3 id=&#34;slime基于-istio-的智能服务网格管理器&#34;&gt;Slime：基于 Istio 的智能服务网格管理器&lt;/h3&gt;
&lt;p&gt;Slime 是由网易数帆微服务团队开源的一款基于 Istio 的智能网格管理器。Slime 基于 Kubernetes Operator 实现，可作为 Istio 的 CRD 管理器，无缝对接 Istio，无须做任何定制化改造，定义动态的服务治理策略，从而达到自动便捷使用 Istio 和 Envoy 高阶功能的目的。&lt;/p&gt;
&lt;p&gt;Slime 试图解决以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Istio 中如何实现高阶扩展的问题，比如扩展 HTTP 插件，限流功能比较单薄，无法根据服务的资源使用率做到自适应限流&lt;/li&gt;
&lt;li&gt;解决 Sidecar 配置全量下发消耗大量资源导致应用性能变差的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Slime 解决以上问题的答案是构建 Istio 的管理平面，其核心思路是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建可拔插控制器&lt;/li&gt;
&lt;li&gt;数据平面监控&lt;/li&gt;
&lt;li&gt;CRD 转换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图是 Istio 作为 Istio 管理平面的流程图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-slime-如何作为-istio-的控制平面&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Slime 如何作为 Istio 的控制平面&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8td6cowj31i90u0aei_hu85129372a2d9cf04b657896a70ce4ca2_167382_f5bf3d0943d7bcb18f91ce76e8e0092d.webp 400w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8td6cowj31i90u0aei_hu85129372a2d9cf04b657896a70ce4ca2_167382_f6543a58e0f34ba0b547ff630cfa5d40.webp 760w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8td6cowj31i90u0aei_hu85129372a2d9cf04b657896a70ce4ca2_167382_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/008i3skNly1gwp8td6cowj31i90u0aei_hu85129372a2d9cf04b657896a70ce4ca2_167382_f5bf3d0943d7bcb18f91ce76e8e0092d.webp&#34;
               width=&#34;760&#34;
               height=&#34;421&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Slime 如何作为 Istio 的控制平面
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Slime 管理 Istio 的具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Slime Operator 根据管理员的配置在 Kubernetes 中完成 Slime 组件的初始化；&lt;/li&gt;
&lt;li&gt;开发者创建符合 Slime CRD 规范的配置并应用到 Kubernetes 集群中；&lt;/li&gt;
&lt;li&gt;Slime 查询 Prometheus 中保存的相关服务的监控数据，结合 Slime CRD 中自适应部分的配置，将 Slime CRD 转换为 Istio CRD，同时将其推送到 Global Proxy 中；&lt;/li&gt;
&lt;li&gt;Istio 监听 Istio CRD 的创建；&lt;/li&gt;
&lt;li&gt;Istio 将 Sidecar Proxy 的配置信息推送到数据平面相应的 Sidecar Proxy 中；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图展示的 Slime 的内部架构图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-slime-内部架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Slime 内部架构图&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8uzsj2wj31ac0oktb4_huab9c965a2e0227996f45a72cf26b4410_93814_9ecffc668142a6290023a5d3c170875e.webp 400w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8uzsj2wj31ac0oktb4_huab9c965a2e0227996f45a72cf26b4410_93814_7a3684a37ad8a40fc7a91ab557d060c9.webp 760w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8uzsj2wj31ac0oktb4_huab9c965a2e0227996f45a72cf26b4410_93814_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/008i3skNly1gwp8uzsj2wj31ac0oktb4_huab9c965a2e0227996f45a72cf26b4410_93814_9ecffc668142a6290023a5d3c170875e.webp&#34;
               width=&#34;760&#34;
               height=&#34;403&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Slime 内部架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;作为 Istio 的管理平面，可以将 Slime 的核心看做是 Istio 的一个 Operator。&lt;/p&gt;
&lt;p&gt;Slime 内部分为三大组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;slime-boot&lt;/strong&gt;：在 Kubernetes 上部署 Slime 模块的 operator。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slime-controller&lt;/strong&gt;：Slime 的核心组件，监听 Slime CRD 并将其转换为Istio CRD。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;slime-metric&lt;/strong&gt;：用于获取服务 metrics 信息的组件，slime-controller 会根据其获取的信息动态调整服务治理规则。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图展示的是 Slime 自适应限流的架构图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-slime-自适应限流架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Slime 自适应限流架构图&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8xghoh2j311k0u0dim_hub5c0d03ef4378e1e9d487b3326051b73_111755_7c64e9506ae18c94f4b497fbfbbbd6b9.webp 400w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8xghoh2j311k0u0dim_hub5c0d03ef4378e1e9d487b3326051b73_111755_621573fc32fe0b18f56c5b2e38e1abb2.webp 760w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8xghoh2j311k0u0dim_hub5c0d03ef4378e1e9d487b3326051b73_111755_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/008i3skNly1gwp8xghoh2j311k0u0dim_hub5c0d03ef4378e1e9d487b3326051b73_111755_7c64e9506ae18c94f4b497fbfbbbd6b9.webp&#34;
               width=&#34;760&#34;
               height=&#34;607&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Slime 自适应限流架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Envoy 内置的限流组件功能单一，只能以实例维度配置限流值，无法做到根据应用负载的自适应限流。Slime 通过与 Prometheus metric server 对接，实时的获取监控情况，来动态配置限流值。&lt;/p&gt;
&lt;p&gt;Slime 的自适应限流的流程分为两部分，一部分为 SmartLimiter 到 &lt;a href=&#34;https://istio.io/latest/docs/reference/config/networking/envoy-filter/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EnvoyFilter&lt;/a&gt; 的转换，另一部分为获取监控数据。目前 Slime 支持从 Kubernetes Metric Server 获取服务的CPU、内存、副本数等数据。Slime 还对外提供了一套监控数据接口（Metric Discovery Server），通过 MDS，可以将自定义的监控指标同步给限流组件。&lt;/p&gt;
&lt;p&gt;Slime 创建的 CRD SmartLimiter 用于配置自适应限流。其的配置是接近自然语义，例如希望在 CPU 超过 80% 时触发服务 A 的访问限制，限额为 30QPS，对应的 SmartLimiter 定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;microservice.netease.com/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;SmartLimiter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;descriptors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fill_interval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;seconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;quota&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;30/{pod}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 30 为该服务的额度，将其均分给每个 pod，加入有 3 个 pod，则每个 pod 的限流为 10&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{cpu}&amp;gt;0.8&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 根据监控项{cpu}的值自动填充该模板&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;aeraki在-istio-中管理任何七层协议&#34;&gt;Aeraki：在 Istio 中管理任何七层协议&lt;/h3&gt;
&lt;p&gt;Aeraki 是腾讯云在 2021 年 3 月开源的一个服务网格领域的项目。Aeraki 提供了一个端到端的云原生服务网格协议扩展解决方案，以一种非侵入的方式为 Istio 提供了强大的第三方协议扩展能力，支持在 Istio 中对 Dubbo、Thrift、Redis，以及对私有协议进行流量管理。Aeraki 的架构如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-aeraki-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Aeraki 架构图&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8ytw57sj31f40u0785_hub0b9c14f269610a66d50e1cd7e50b372_71273_44d67ec4fad1ce7267922460d804e5fa.webp 400w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8ytw57sj31f40u0785_hub0b9c14f269610a66d50e1cd7e50b372_71273_2ba0b165aa7fa469fb523f2e87e10ac3.webp 760w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp8ytw57sj31f40u0785_hub0b9c14f269610a66d50e1cd7e50b372_71273_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/008i3skNly1gwp8ytw57sj31f40u0785_hub0b9c14f269610a66d50e1cd7e50b372_71273_44d67ec4fad1ce7267922460d804e5fa.webp&#34;
               width=&#34;760&#34;
               height=&#34;383&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Aeraki 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&#34;https://istio.io/latest/blog/2021/aeraki/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://istio.io/latest/blog/2021/aeraki/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从 Aeraki 架构图中可以看到，Aeraki 协议扩展解决方案包含了两个组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Aeraki：Aeraki 作为一个 Istio 增强组件运行在控制面，通过自定义 CRD 向运维提供了用户友好的流量规则配置。Aeraki 将这些流量规则配置翻译为 Envoy 配置，通过 Istio 下发到数据面的 sidecar 代理上。Aeraki 还作为一个 RDS 服务器为数据面的 MetaProtocol Proxy 提供动态路由。Aeraki 提供的 RDS 和 Envoy 的 RDS 有所不同，Envoy RDS 主要为 HTTP 协议提供动态路由，而 Aeraki RDS 旨在为所有基于 MetaProtocol 框架开发的七层协议提供动态路由能力。&lt;/li&gt;
&lt;li&gt;MetaProtocol Proxy：基于 Envoy 实现的一个通用七层协议代理。依托 Envoy 成熟的基础库，MetaProtocol Proxy 是在 Envoy 代码基础上的扩展。它为七层协议统一实现了服务发现、负载均衡、RDS 动态路由、流量镜像、故障注入、本地/全局限流等基础能力，大大降低了在 Envoy 上开发第三方协议的难度，只需要实现编解码的接口，就可以基于 MetaProtocol 快速开发一个第三方协议插件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有使用 MetaProtocol Proxy，要让 Envoy 识别一个七层协议，则需要编写一个完整的 TCP filter，这个 filter 需要实现路由、限流、遥测等能力，需要投入大量的人力。对于大部分的七层协议来说，需要的流量管理能力是类似的，因此没有必要在每个七层协议的 filter 实现中重复这部分工作。Aeraki 项目采用了一个 MetaProtocol Proxy 来统一实现这些能力，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-metaprotocol-proxy-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;MetaProtocol Proxy 架构图&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/metaprotocol-proxy_hu891ca5b4ba1e8919f164483e1eb2712c_87513_bb89cc950fa61a201ff7e5606893d1af.webp 400w,
               /blog/jimmy-service-mesh-talk/metaprotocol-proxy_hu891ca5b4ba1e8919f164483e1eb2712c_87513_2ee7291b2a643ae218fd73df28b4d30b.webp 760w,
               /blog/jimmy-service-mesh-talk/metaprotocol-proxy_hu891ca5b4ba1e8919f164483e1eb2712c_87513_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/metaprotocol-proxy_hu891ca5b4ba1e8919f164483e1eb2712c_87513_bb89cc950fa61a201ff7e5606893d1af.webp&#34;
               width=&#34;760&#34;
               height=&#34;223&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      MetaProtocol Proxy 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;基于 MetaProtocol Proxy，只需要实现编解码接口部分的代码就可以编写一个新的七层协议 Envoy Filter。除此之外，无需添加一行代码，Aeraki 就可以在控制面提供该七层协议的配置下发和 RDS 动态路由配置。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-采用-metaprotocol-编写-envoy-filter-的对比&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;采用 MetaProtocol 编写 Envoy Filter 的对比&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/metaprotocol-proxy-codec_huadfb319489190fc72c744bf0fd56314b_79775_7382be43f28a91f56bc8cbb07c38c0db.webp 400w,
               /blog/jimmy-service-mesh-talk/metaprotocol-proxy-codec_huadfb319489190fc72c744bf0fd56314b_79775_0ddec13af23609216e2a8df6e7aacbd4.webp 760w,
               /blog/jimmy-service-mesh-talk/metaprotocol-proxy-codec_huadfb319489190fc72c744bf0fd56314b_79775_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/metaprotocol-proxy-codec_huadfb319489190fc72c744bf0fd56314b_79775_7382be43f28a91f56bc8cbb07c38c0db.webp&#34;
               width=&#34;760&#34;
               height=&#34;340&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      采用 MetaProtocol 编写 Envoy Filter 的对比
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Aeraki + MetaProtocol 套件降低了在 Istio 中管理第三方协议的难度，将 Istio 扩展成为一个支持所有协议的全栈服务网格。目前 Aeraki 项目已经基于 MetaProtocol 实现了 Dubbo 和 Thrift 协议。相对 Envoy 自带的 Dubbo 和 Thrift Filter，基于 MetaProtocol 的 Dubbo 和 Thrift 实现功能更为强大，提供了 RDS 动态路由，可以在不中断存量链接的情况下对流量进行高级的路由管理，并且提供了非常灵活的 Metadata 路由机制，理论上可以采用协议数据包中携带的任意字段进行路由。QQ 音乐和央视频 APP 等业务也正在基于 Aeraki 和 MetaProtocol 进行开发，以将一些私有协议纳入到服务网格中进行管理。&lt;/p&gt;
&lt;p&gt;除此之外，&lt;a href=&#34;https://github.com/aeraki-framework&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Aeraki Framework&lt;/a&gt; 中还提供了 xDS 配置下发优化的 lazyXDS 插件、Consul、etcd、Zookeeper 等各种第三方服务注册表对接适配，Istio 运维实战电子书等工具，旨在解决 Istio 在落地中遇到的各种实际问题，加速服务网格的成熟和产品化。&lt;/p&gt;
&lt;h2 id=&#34;服务网格的未来发展&#34;&gt;服务网格的未来发展&lt;/h2&gt;
&lt;p&gt;最后我想讲一下对于服务网格未来发展的一些看法。&lt;/p&gt;
&lt;h3 id=&#34;让-istio-适用于一切环境和一切工作负载&#34;&gt;让 Istio 适用于一切环境和一切工作负载&lt;/h3&gt;
&lt;p&gt;我们看到了网易、腾讯主要是通过构建 Operator 来扩展 Istio，然而这种扩展对于多集群管理来说并不够用。我们知道我们目前的基础设施很多是在向云原生化或者是容器化转型，那么就存在一个容器、虚拟机等共存的环境。这就是异构环境，这些不同环境的流量如何统一管理呢？其实使用 Istio 是可以做到的。同样是要在 Istio 之上构建一个管理平面，并增加一个抽象层，增加适用于集群管理的 CRD，比如集群流量配置、集群策略配置等。另外还要在每个集群中部署一个 Gateway，统一连接到一个边缘代理，让所有的集群互联。这也是 Tetrate Service Bridge 的产品理念。&lt;/p&gt;
&lt;p&gt;下面展示的 &lt;a href=&#34;https://www.tetrate.io/tetrate-service-bridge/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Service Bridge&lt;/a&gt; 架构图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-image-20211123181346493&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image-20211123181346493&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/tsb_hu796ddb18625e77a47c7c78e4a438dbae_124177_230c8cf6df9c72a423d5ca6191df947d.webp 400w,
               /blog/jimmy-service-mesh-talk/tsb_hu796ddb18625e77a47c7c78e4a438dbae_124177_c51552fe961eb783cbcea8feb49d3c8a.webp 760w,
               /blog/jimmy-service-mesh-talk/tsb_hu796ddb18625e77a47c7c78e4a438dbae_124177_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/tsb_hu796ddb18625e77a47c7c78e4a438dbae_124177_230c8cf6df9c72a423d5ca6191df947d.webp&#34;
               width=&#34;760&#34;
               height=&#34;360&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image-20211123181346493
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;api-网关与服务网格的融合&#34;&gt;API 网关与服务网格的融合&lt;/h3&gt;
&lt;p&gt;下图展示了使用 Istio Gateway、Kubernetes Ingress、API Gateway 及 NodePort/LB 暴露 Istio mesh 中服务的四种方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-访问-istio-网格中服务的几种方式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;访问 Istio 网格中服务的几种方式&#34; srcset=&#34;
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp935mcd0j31200u0n10_hu50b34a22c1dedbd2c873e2427d3385e1_145632_21141110b08869213402f208d65674c9.webp 400w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp935mcd0j31200u0n10_hu50b34a22c1dedbd2c873e2427d3385e1_145632_8f92bc82d2eb0e4e64c6784474416feb.webp 760w,
               /blog/jimmy-service-mesh-talk/008i3skNly1gwp935mcd0j31200u0n10_hu50b34a22c1dedbd2c873e2427d3385e1_145632_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/jimmy-service-mesh-talk/008i3skNly1gwp935mcd0j31200u0n10_hu50b34a22c1dedbd2c873e2427d3385e1_145632_21141110b08869213402f208d65674c9.webp&#34;
               width=&#34;760&#34;
               height=&#34;600&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      访问 Istio 网格中服务的几种方式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;其中阴影表示的是 Istio mesh，mesh 中的的流量属于集群内部（东西向）流量，而客户端访问 Kubernetes 集群内服务的流量属于外部（南北向）流量。不过因为 Ingress、Gateway 也是部署在 Kubernetes 集群内的，这些节点访问集群内其他服务的流量就难以归属了。&lt;/p&gt;
&lt;p&gt;在 Istio mesh 中你可以使用多种 Kubernetes Ingress Controller 来充当入口网关，当然你还可以直接使用 Istio 内置的 Istio 网关，对于策略控制、流量管理和用量监控可以直接通过 Istio 网关来完成，这样做的好处是通过 Istio 的控制平面来直接管理网关，而不需要再借助其他工具。但是对于 API 声明周期管理、复杂的计费、协议转换和认证等功能，传统的 API 网关可能更适合你。所以，你可以根据自己的需求来选择，也可以组合使用。&lt;/p&gt;
&lt;p&gt;下表中列出了 Istio Mesh 中暴露服务的四种方式。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;方式&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;控制器&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NodePort/LoadBalancer&lt;/td&gt;
&lt;td&gt;Kubernetes&lt;/td&gt;
&lt;td&gt;负载均衡&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kubernetes Ingress&lt;/td&gt;
&lt;td&gt;Ingress Controller&lt;/td&gt;
&lt;td&gt;负载均衡、TLS、虚拟主机、流量路由&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Istio Gateway&lt;/td&gt;
&lt;td&gt;Istio&lt;/td&gt;
&lt;td&gt;负载均衡、TLS、虚拟主机、高级流量路由、其他 Istio 的高级功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;API 网关&lt;/td&gt;
&lt;td&gt;API Gateway&lt;/td&gt;
&lt;td&gt;负载均衡、TLS、虚拟主机、流量路由、API 生命周期管理、权限认证、数据聚合、账单和速率限制&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;目前有些传统的反向代理也在向 Service Mesh 方向发展，如 Nginx 构建了 Nginx Service Mesh，Traefik 构建了 Traefik Mesh。还有的 API 网关产品也向 Service Mesh 方向挺进，比如 Kong 发展出了 Kuma。在未来，我们会看到更多 API 网关、反向代理和服务网格的融合产品出现。&lt;/p&gt;
&lt;h3 id=&#34;你是否真的需要服务网格&#34;&gt;你是否真的需要服务网格？&lt;/h3&gt;
&lt;p&gt;在使用服务网格前，请考虑以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你的团队多少人里投入服务网格开发？使用 Kubernetes、Istio 的经验？&lt;/li&gt;
&lt;li&gt;你有多少微服务？这些微服务使用什么语言？&lt;/li&gt;
&lt;li&gt;你的服务都运行在哪些平台上？&lt;/li&gt;
&lt;li&gt;你的应用已经容器化并使用 Kubernetes 管理了吗？&lt;/li&gt;
&lt;li&gt;你的服务有多少是部署在虚拟机、有多少是部署到 Kubernetes 集群上，比例如何？&lt;/li&gt;
&lt;li&gt;你的团队有制定转移到云原生架构的计划吗？&lt;/li&gt;
&lt;li&gt;你想使用 Istio 的什么功能？Istio 的稳定性是否能够满足你的需求？&lt;/li&gt;
&lt;li&gt;你是否可以忍受 Istio 带来的性能损耗？&lt;/li&gt;
&lt;li&gt;你选择自建或者采购？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;最后总结一下今天的分享：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从容器编排争霸到服务网格，我们可以看到云原生乃至整个云计算就是标准之争。&lt;/li&gt;
&lt;li&gt;服务网格的目标是成为云原生的网络基础设施，任重而道远。&lt;/li&gt;
&lt;li&gt;服务网格只是云原生庞大技术栈中的一环，不要一叶障目，技术的发展是永无止境的。&lt;/li&gt;
&lt;li&gt;Istio 架构已经稳定，生产可用，生态正处于萌芽中。&lt;/li&gt;
&lt;li&gt;对于终端用户来说适合自己的才是最好的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本人才疏学浅，因为时间的原因，很多内容没有深入展开和探讨，最后欢迎大家加入&lt;a href=&#34;https://cloudnative.to/sig-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区 Istio SIG&lt;/a&gt; 一起交流学习 Istio 和服务网格技术。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slime：让Istio服务网格变得更加高效与智能</title>
      <link>https://cloudnative.to/blog/netease-slime/</link>
      <pubDate>Tue, 26 Jan 2021 10:03:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/netease-slime/</guid>
      <description>&lt;p&gt;注：本文是本人在云原生社区直播分享的内容整理，视频见 &lt;a href=&#34;https://www.bilibili.com/video/BV18o4y1y75e/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;B 站&lt;/a&gt;，PPT 可以在 &lt;a href=&#34;https://github.com/tetratelabs/istio-weekly/tree/main/istio-big-talk/003&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; 下载。&lt;/p&gt;
&lt;p&gt;Slime是网易数帆微服务团队开源的服务网格组件，它可以作为Istio的CRD管理器，旨在通过更为简单的配置实现Istio/Envoy的高阶功能。目前slime包含三个非常实用的子模块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置懒加载: 无须手动配置SidecarScope，按需加载配置和服务发现信息&lt;/li&gt;
&lt;li&gt;Http插件管理: 使用新的的CRD pluginmanager/envoyplugin包装了可读性，摒弃了可维护性较差的envoyfilter，使得插件扩展更为便捷&lt;/li&gt;
&lt;li&gt;自适应限流: 结合监控信息自动调整限流策略 后续我们团队会开放更多实用功能在slime中，希望slime能帮助使用者更好的驾驭Istio这艘小帆船&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-背景&#34;&gt;1. 背景&lt;/h2&gt;
&lt;p&gt;服务网格作为新一代微服务架构，采用sidecar模式，实现了业务逻辑和微服务治理逻辑的物理解耦，降低微服务框架的开发与运维成本。权责清晰，易维护，可观测，多语言支持等一些列优势使其逐渐成为微服务话题中的焦点。而Istio+Envoy作为其使用最为广泛的实现一直占据着C位，背靠Google的大树，Istio已隐隐具备了成为业界标准的趋势。&lt;/p&gt;
&lt;p&gt;欲戴皇冠，必承其重。站在风口浪尖的Istio，获得赞誉的同时也引来了不少非议。项目的优势自不必说，Istio有着一套行之有效的上层抽象，通过配置VirtualService，DestinationRule等CR可以实现版本分流，灰度发布，负载均衡等功能，但是在面对本地限流，黑白名单，降级等微服务治理的高阶功能时，这套抽象显得力有不逮，起初Istio给出的解决方案是Mixer，将这些原本属于数据面的功能上升到Mixer Adapter中，虽然解决了功能扩展的问题，但其集中式的架构遭到了不少关注者对其性能的质疑。最终，Istio在新版本中自断其臂，弃用了Mixer，这就使得高阶功能的扩展成为目前版本的一块空白。另一方面Istio配置是全量推送的，这就意味着在大规模的网格场景下需推送海量配置，为了减少推送配置量，用户不得不事先搞清楚服务间的依赖关系，配置SidecarScope做配置隔离，而这无疑增加了运维人员的心智负担，易用性和性能成为不可兼得的鱼和熊掌。&lt;/p&gt;
&lt;p&gt;针对Istio目前的一些弊端，我们团队开启了slime项目。该项目是基于k8s-operator实现的，作为Istio的CRD管理器，&lt;strong&gt;可以无缝对接Istio，无需任何的定制化改造&lt;/strong&gt;。slime内部采用了模块化的架构，目前包含了三个非常实用的子模块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置懒加载：无须手动配置SidecarScope，按需加载配置信息和服务发现信息，解决了全量推送的问题。&lt;/li&gt;
&lt;li&gt;Http插件管理：使用新的的CRD pluginmanager/envoyplugin包装了可读性，可维护性较差的envoyfilter，使得插件扩展更为便捷。&lt;/li&gt;
&lt;li&gt;自适应限流：可结合监控信息自动调整限流策略，填补了Istio限流功能的短板。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-配置懒加载&#34;&gt;2. 配置懒加载&lt;/h2&gt;
&lt;p&gt;随着服务网格上业务规模的逐步变大，我们遇到的第一个问题就是配置全量下发导致的性能问题，它对数据面和控制面都有较为严重的性能影响：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使数据面收到大量冗余配置
a) Envoy启动时间变长
b) Envoy内存开销增加
c) 占据Envoy主线程，阻塞Pilot事件推送&lt;/li&gt;
&lt;li&gt;增加控制面处理推送事件复杂度
a) Pilot推送时内存增加，易引发OOM
b) 配置下发时延增加
为了使Istio能支持一定量级的集群，我们不得不事先要求业务方在服务发布时，告知该服务所依赖的服务，并以此设置SidecarScope屏蔽无关服务的配置和服务发现信息。但是在推行过程中却遇到了阻力，一方面是依赖服务的信息不好获取，另一方面一旦业务方配置有误，会导致调用出现问题。这个规定使得原本想要上网格的业务变得望而却步。
















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/netease-slime/008eGmZEly1gn14jo6707j30fx08aq3x_hu9d9b3d32060d62a1caadcb1149402be2_18630_4e757e1262c1147fd07e60e732daa584.webp 400w,
               /blog/netease-slime/008eGmZEly1gn14jo6707j30fx08aq3x_hu9d9b3d32060d62a1caadcb1149402be2_18630_def4988484355708e2baee8f9d06d2a9.webp 760w,
               /blog/netease-slime/008eGmZEly1gn14jo6707j30fx08aq3x_hu9d9b3d32060d62a1caadcb1149402be2_18630_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/netease-slime/008eGmZEly1gn14jo6707j30fx08aq3x_hu9d9b3d32060d62a1caadcb1149402be2_18630_4e757e1262c1147fd07e60e732daa584.webp&#34;
               width=&#34;573&#34;
               height=&#34;298&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有什么办法可以使服务按需获取配置呢？最容易想到的是从服务调用关系中获取该信息，但是在缺失被调用方服务发现信息的情况下，是无法成功访问的，这就会导致一些容错率低的服务不能接受这种方案，另一方面访问不成功时获得的服务调用关系也并不可靠。换而言之，如果有办法使服务在不具备被调用方配置信息和服务发现信息的情况下能够成功调用，就可以通过自动生成SidecarScope的方式实现配置懒加载（按需加载）。&lt;/p&gt;
&lt;p&gt;我们想到的办法是构建一条兜底路由，这条兜底路由的backend是一个全局共享的sidecar，我们称之为global-sidecar，它拥有全量的配置和服务发现信息。缺失服务发现信息的调用，都会被兜底路由劫持到global-sidecar，global-sidecar为其做二次代理，转发到对应的后端服务。
















&lt;figure  id=&#34;figure-lazyload-bookinfo-p1png&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;lazyload-bookinfo-p1.png&#34; srcset=&#34;
               /blog/netease-slime/008eGmZEly1gn14jqlmrrj314e0trjud_hu78441fe870e00139f49eeffde2c68d4d_99581_1d8a17b6f565e4c1bce8eb1ae4dac89e.webp 400w,
               /blog/netease-slime/008eGmZEly1gn14jqlmrrj314e0trjud_hu78441fe870e00139f49eeffde2c68d4d_99581_1eb4c8a3a42fe9fcd803be24b07d2267.webp 760w,
               /blog/netease-slime/008eGmZEly1gn14jqlmrrj314e0trjud_hu78441fe870e00139f49eeffde2c68d4d_99581_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/netease-slime/008eGmZEly1gn14jqlmrrj314e0trjud_hu78441fe870e00139f49eeffde2c68d4d_99581_1d8a17b6f565e4c1bce8eb1ae4dac89e.webp&#34;
               width=&#34;760&#34;
               height=&#34;560&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      lazyload-bookinfo-p1.png
    &lt;/figcaption&gt;&lt;/figure&gt;

global-sidecar在完成代理后会将服务调用信息上报给slime，slime根据调用信息更新Scope，首次调用后，服务便可感知到被调用方的信息，不再需要global-sidecar转发，如下图所示。
















&lt;figure  id=&#34;figure-lazyload-bookinfo-p2png&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;lazyload-bookinfo-p2.png&#34; srcset=&#34;
               /blog/netease-slime/008eGmZEly1gn14jq39tzj314d0pd76x_hu3e7de8fdd955ad6d10f80e22c67d7840_102241_f7c677198765a3dd06a7805d627044c5.webp 400w,
               /blog/netease-slime/008eGmZEly1gn14jq39tzj314d0pd76x_hu3e7de8fdd955ad6d10f80e22c67d7840_102241_ebd14565af24831e8543351d45303ed0.webp 760w,
               /blog/netease-slime/008eGmZEly1gn14jq39tzj314d0pd76x_hu3e7de8fdd955ad6d10f80e22c67d7840_102241_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/netease-slime/008eGmZEly1gn14jq39tzj314d0pd76x_hu3e7de8fdd955ad6d10f80e22c67d7840_102241_f7c677198765a3dd06a7805d627044c5.webp&#34;
               width=&#34;760&#34;
               height=&#34;478&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      lazyload-bookinfo-p2.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在实现配置懒加载的过程中，我们也遇到了另外一个问题，当被调用服务服务名被vs中的路由规则导向另一个服务时，slime只能将被调用服务添加到Scope中，被导向服务的服务发现信息依然缺失，导致再次调用时出现503。为了解决这个问题，我们引入了自研CRD——ServiceFence，通过它可以构建起服务名和后端服务的映射关系。slime根据其对应服务的VirtualService，找到服务名和真实后端的映射关系，将两者的都加入scope中，将可避免上述问题。
















&lt;figure  id=&#34;figure-llpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;ll.png&#34; srcset=&#34;
               /blog/netease-slime/008eGmZEly1gn14jnq6spj30pv0om0uq_hu4db535e0fbafab13120785372d1cd0e0_72650_55bd6303e284d5e42d73e1f8099fcca8.webp 400w,
               /blog/netease-slime/008eGmZEly1gn14jnq6spj30pv0om0uq_hu4db535e0fbafab13120785372d1cd0e0_72650_6853e5e6f4210814472eeb76e519d5b3.webp 760w,
               /blog/netease-slime/008eGmZEly1gn14jnq6spj30pv0om0uq_hu4db535e0fbafab13120785372d1cd0e0_72650_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/netease-slime/008eGmZEly1gn14jnq6spj30pv0om0uq_hu4db535e0fbafab13120785372d1cd0e0_72650_55bd6303e284d5e42d73e1f8099fcca8.webp&#34;
               width=&#34;760&#34;
               height=&#34;723&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      ll.png
    &lt;/figcaption&gt;&lt;/figure&gt;

ServiceFence也可以对生成的SidecarScope的生命周期做管理，可以自动清理长时间不用的调用关系。
当然上述这些CRD的生成和维护都是自动的，用户即不需要关心ServiceFence资源也不需要关心SidecarScope资源，只需要在Service上打上&lt;code&gt;istio.dependency.servicefence/status: &amp;quot;true&amp;quot;&lt;/code&gt;的标签，表明该服务需要开启配置懒加载即可。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-自动依赖&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;自动依赖&#34; srcset=&#34;
               /blog/netease-slime/008eGmZEly1gn14jp6fd2j30je0a0dgs_hu624f43d7e96e92825b1cd05461f33eb7_19063_7ccf90a69505a497bfe21ab744dd87a3.webp 400w,
               /blog/netease-slime/008eGmZEly1gn14jp6fd2j30je0a0dgs_hu624f43d7e96e92825b1cd05461f33eb7_19063_4f5b6d7284b8e12ca385f0b1b67a6687.webp 760w,
               /blog/netease-slime/008eGmZEly1gn14jp6fd2j30je0a0dgs_hu624f43d7e96e92825b1cd05461f33eb7_19063_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/netease-slime/008eGmZEly1gn14jp6fd2j30je0a0dgs_hu624f43d7e96e92825b1cd05461f33eb7_19063_7ccf90a69505a497bfe21ab744dd87a3.webp&#34;
               width=&#34;698&#34;
               height=&#34;360&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      自动依赖
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;3-http插件管理&#34;&gt;3. Http插件管理&lt;/h2&gt;
&lt;p&gt;在网关场景下，流量管理比较复杂，需要使用定制化插件来处理流量，在开发slime的插件模块之前，插件扩展只能通过EnvoyFilter来实现，EnvoyFilter是xDS层面的配置，管理和维护这样的配置需要耗费大量的精力，同时出错率也极高。&lt;/p&gt;
&lt;p&gt;为了简化插件管理的难度，我们决定在EnvoyFilter上层做一层面向插件管理的抽象。xDS中关于HTTP插件的配置有两段，一部分在LDS中，作为&lt;code&gt;HttpConnectionManager&lt;/code&gt;的SubFilter，它决定了哪些插件将被加载以及插件的执行顺序。另一部分在RDS中，并且有两个粒度，分别是VirtualHost粒度的&lt;code&gt;perFilterConfig&lt;/code&gt;以及route粒度的&lt;code&gt;perFilterConfig&lt;/code&gt;，这部分决定了当前Host或者是路由需要进行的插件行为。&lt;/p&gt;
&lt;p&gt;LDS中的部分被我们抽象为PluginManager，我们可以通过enable选项启停插件。通过PluginManager也可以管理插件的执行优先级，其中的插件顺序和LDS插件链中的顺序是一致的，越靠前的插件执行优先级越高，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-plugin_pluginmanagerpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;plugin_pluginmanager.png&#34; srcset=&#34;
               /blog/netease-slime/008eGmZEly1gn14jopgblj30rm0a1aax_hu91f2220b054ad572f6b5cdb24ede2af0_41820_459e3b6eee207e80d35ffff0cd101332.webp 400w,
               /blog/netease-slime/008eGmZEly1gn14jopgblj30rm0a1aax_hu91f2220b054ad572f6b5cdb24ede2af0_41820_4b6d5d13000f062cda0cf9cfa5829d58.webp 760w,
               /blog/netease-slime/008eGmZEly1gn14jopgblj30rm0a1aax_hu91f2220b054ad572f6b5cdb24ede2af0_41820_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/netease-slime/008eGmZEly1gn14jopgblj30rm0a1aax_hu91f2220b054ad572f6b5cdb24ede2af0_41820_459e3b6eee207e80d35ffff0cd101332.webp&#34;
               width=&#34;760&#34;
               height=&#34;276&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      plugin_pluginmanager.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;RDS中的部分被抽象为EnvoyPlugin，通过EnvoyPlugin的Host/Route字段可以设置插件配置的生效范围。EnvoyPlugin更加贴合网关的配置模型，在网关的控制台上，后端服务往往被映射为某个Host下的某几个API接口，例如我们需要为服务A配置自研的黑白名单插件以及trace采样插件，A服务在网关上的接口为&lt;code&gt;/abc&lt;/code&gt;和&lt;code&gt;/xyz&lt;/code&gt;，针对该服务的插件配置就会被映射为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;microservice.netease.com/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;EnvoyPlugin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway-proxy-svc-a &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;gateway-system&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;gateway&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;gateway-system/gateway-proxy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;gwtest.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;route：&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;abc&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;xyz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;plugins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;com.netease.iprestriction&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;inline&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;settings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;m&#34;&gt;1.1.1.1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;BLACK &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;com.netease.resty&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;inline&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;settings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;plugins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sample_rate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.001&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;whitelist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;aaa&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;neTraceSample &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;EnvoyPlugin不关心每个插件的具体配置（具体配置会被放在type.struct结构中透传处理），它更关心的是插件生效范围，使用者可以将插件配置在需要的维度中做聚合，这样做一方面更加贴合插件使用者的习惯，另一方面也降低了上层配置的冗余，下图展示了EnvoyPlugin在xDS层面的映射关系，虽然xDS层面仍旧会展开，但至少在管理它们的时候，我们面对的是一个有序聚合的数组，而非一颗庞大的插件树。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-plugin_envoypluginpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;plugin_envoyplugin.png&#34; srcset=&#34;
               /blog/netease-slime/008eGmZEly1gn14jr57r4j30ws0u077g_hu0c148fe8c9e64a0a25deb3d2c8ec1148_90383_5ec999e36bc63c3351bbe6bdc0882dbc.webp 400w,
               /blog/netease-slime/008eGmZEly1gn14jr57r4j30ws0u077g_hu0c148fe8c9e64a0a25deb3d2c8ec1148_90383_71fd1fba5af9b98f288737dfaa5e1925.webp 760w,
               /blog/netease-slime/008eGmZEly1gn14jr57r4j30ws0u077g_hu0c148fe8c9e64a0a25deb3d2c8ec1148_90383_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/netease-slime/008eGmZEly1gn14jr57r4j30ws0u077g_hu0c148fe8c9e64a0a25deb3d2c8ec1148_90383_5ec999e36bc63c3351bbe6bdc0882dbc.webp&#34;
               width=&#34;760&#34;
               height=&#34;696&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      plugin_envoyplugin.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;4-自适应限流&#34;&gt;4. 自适应限流&lt;/h2&gt;
&lt;p&gt;随着Mixer的移除，要实现服务网格中的限流变得非常复杂。全局限流需要配置额外部署 RLS (Ratelimit Server)，即使是本地限流也需要借助Envoy内建插件——&lt;code&gt;envoy.local.ratelimit&lt;/code&gt;，为此使用者不得不再次面对复杂的EnvoyFilter配置。相较于二代微服务框架中成熟的限流组件而言，Envoy的本地限流组件功能也略显简单，例如，无法做到自适应限流，只能以实例维度配置限流值等。&lt;/p&gt;
&lt;p&gt;为了解决Istio中服务限流的短板，我们开发了自适应限流模块，在易用性方面，我们也为其设计了一套新的API——SmartLimiter。自适应限流的主体架构分为两部分，一部分为SmartLimiter到EnvoyFilter的转换逻辑，另一部分为监控数据获取。目前slime支持从K8S metric-server获取服务的CPU，Memory，副本数等数据，当然我们也对外提供了一套监控数据对接接口（Metric Discovery Server），通过MDS，可以将自定义的监控指标同步给限流组件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-limit_archpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;limit_arch.png&#34; srcset=&#34;
               /blog/netease-slime/008eGmZEly1gn14jmrfv8j30j40dgwet_hu65510fccb102dc897ae92957339220c8_26899_f0b32be4cc0054fd8a9d96a75e35af0c.webp 400w,
               /blog/netease-slime/008eGmZEly1gn14jmrfv8j30j40dgwet_hu65510fccb102dc897ae92957339220c8_26899_c1a6827ef9e57de5bb18b2e5e11fa906.webp 760w,
               /blog/netease-slime/008eGmZEly1gn14jmrfv8j30j40dgwet_hu65510fccb102dc897ae92957339220c8_26899_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/netease-slime/008eGmZEly1gn14jmrfv8j30j40dgwet_hu65510fccb102dc897ae92957339220c8_26899_f0b32be4cc0054fd8a9d96a75e35af0c.webp&#34;
               width=&#34;688&#34;
               height=&#34;484&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      limit_arch.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SmartLimiter的配置是比较接近自然语义的，例如希望在CPU超过80%时触发服务A的访问限制，限额为30QPS，对应的SmartLimiter定义如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;microservice.netease.com/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;SmartLimiter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;descriptors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;action&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fill_interval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;seconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;quota&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;30/{pod}&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 30为该服务的额度，将其均分给每个pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{cpu}&amp;gt;0.8&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 根据监控项{cpu}的值自动填充该模板&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最终产生的限流行为，如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-limitpng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;limit.png&#34; srcset=&#34;
               /blog/netease-slime/008eGmZEly1gn14jpmamcj30k20l6myl_hu1cf9a2341e8a3b71b32e76be39c6b6ac_41052_a50e07ac46d6d654f86cf1f56e32dcc2.webp 400w,
               /blog/netease-slime/008eGmZEly1gn14jpmamcj30k20l6myl_hu1cf9a2341e8a3b71b32e76be39c6b6ac_41052_7e8cb5e12e489792093a17d9921c52e1.webp 760w,
               /blog/netease-slime/008eGmZEly1gn14jpmamcj30k20l6myl_hu1cf9a2341e8a3b71b32e76be39c6b6ac_41052_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/netease-slime/008eGmZEly1gn14jpmamcj30k20l6myl_hu1cf9a2341e8a3b71b32e76be39c6b6ac_41052_a50e07ac46d6d654f86cf1f56e32dcc2.webp&#34;
               width=&#34;720&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      limit.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;5-如何获取和使用slime&#34;&gt;5. 如何获取和使用slime&lt;/h2&gt;
&lt;p&gt;slime的源码已经开放，你可以在&lt;a href=&#34;https://github.com/slime-io/slime&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;获得slime的最新动态，后续我们团队会开放更多实用功能在slime中。你也可以阅读&lt;a href=&#34;https://github.com/slime-io/slime/blob/master/README_ZH.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用指引&lt;/a&gt;快速上手slime。在使用指引中，我们基于bookinfo为slime编写了简单的例子，希望能帮助到你们。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，slime仍处于早期阶段，希望有更多的mesher加入我们或为我们提出建议，帮助我们完善它。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;希望slime能帮助使用者更好的驾驭Istio这艘帆船！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;杨笛航，Istio社区成员，网易数帆架构师，负责轻舟Service Mesh配置管理，并主导slime组件设计与研发，参与网易严选和网易传媒的Service Mesh建设。具有三年Istio控制面功能拓展和性能优化经验。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
