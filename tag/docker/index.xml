<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker | 云原生社区（中国）</title>
    <link>https://cloudnativecn.com/tag/docker/</link>
      <atom:link href="https://cloudnativecn.com/tag/docker/index.xml" rel="self" type="application/rss+xml" />
    <description>Docker</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 19 Sep 2023 12:03:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnativecn.com/media/sharing.png</url>
      <title>Docker</title>
      <link>https://cloudnativecn.com/tag/docker/</link>
    </image>
    
    <item>
      <title>如何在 Docker 容器中运行 GUI 应用程序</title>
      <link>https://cloudnativecn.com/blog/run-gui-applications-as-containers-with-x11docker/</link>
      <pubDate>Tue, 19 Sep 2023 12:03:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/run-gui-applications-as-containers-with-x11docker/</guid>
      <description>&lt;p&gt;摘要：本文介绍了如何在 Docker 容器中运行 GUI 应用程序。通过使用 x11docker 应用程序，可以轻松启动带有桌面环境的 GUI 容器，并提供了许多功能，如 GPU 硬件加速、声音、剪贴板共享等。文章还提供了安装 Docker 运行时引擎和 x11docker 的详细步骤，并演示了使用 VLC 媒体播放器在容器中运行 GUI 应用程序的示例。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文译自：&lt;a href=&#34;https://thenewstack.io/run-gui-applications-as-containers-with-x11docker/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://thenewstack.io/run-gui-applications-as-containers-with-x11docker/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为开发人员，您可能需要使用 GUI 容器进行工作。如果是这种情况，您会很快发现，传统的 Docker 运行时引擎并不支持运行 GUI 应用程序（除非它们是基于 Web 的类型）。当您想要开发容器化的 GUI 应用程序时，您该怎么办呢？&lt;/p&gt;
&lt;p&gt;幸运的是，有许多第三方应用程序可以在桌面上轻松启动 GUI 容器。正如您可能预期的那样，这需要一个桌面环境（否则，您将在更传统的基于服务器的设置上进行开发）。其中一个应用程序叫做 &lt;a href=&#34;https://github.com/mviereck/x11docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;x11docker&lt;/a&gt;。顾名思义，此应用程序与 Linux X 显示服务器配合使用（这意味着您需要一个 Linux 发行版才能使其正常工作）。&lt;/p&gt;
&lt;p&gt;x11docker 应用程序包括以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPU 硬件加速&lt;/li&gt;
&lt;li&gt;PulseAudio 或 ALSA 声音&lt;/li&gt;
&lt;li&gt;剪贴板共享&lt;/li&gt;
&lt;li&gt;打印机和摄像头访问&lt;/li&gt;
&lt;li&gt;持久的主目录&lt;/li&gt;
&lt;li&gt;Wayland 支持&lt;/li&gt;
&lt;li&gt;语言区域设置创建&lt;/li&gt;
&lt;li&gt;容器内的多个 init 系统和 DBus&lt;/li&gt;
&lt;li&gt;支持多个容器运行时和后端（包括 Podman）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;您可能会问：“X11 不安全吗？”是的，确实。幸运的是，x11docker 通过使用多个 X 服务器来避免 X 服务器泄漏。因此，您可以放心使用该工具，而不必担心会暴露自己、系统或容器给典型的 X11 服务器弱点。&lt;/p&gt;
&lt;p&gt;需要记住的一件事是，x11docker 创建了一个非特权容器用户。该用户的密码为 x11docker，并限制了容器的功能。因此，某些应用程序可能无法按预期方式运行。例如，当尝试从容器内运行 Tor 浏览器时，它无法访问 /dev/stdout，这意味着容器将无法运行。但并不是所有容器都是如此。我将用 VLC 媒体播放器进行演示，该播放器可以按预期运行。&lt;/p&gt;
&lt;p&gt;接下来，我将向您展示如何在运行中的基于 Ubuntu 的桌面操作系统实例上安装 x11docker。当然，首先您必须安装 Docker 运行时引擎。为此，我将向您展示两种不同的方法。&lt;/p&gt;
&lt;p&gt;准备好了吗？我们开始吧。&lt;/p&gt;
&lt;h2 id=&#34;所需的工具&#34;&gt;所需的工具&lt;/h2&gt;
&lt;p&gt;正如我已经提到的，您需要运行中的基于 Ubuntu 的 Linux 桌面发行版实例。您还需要一个具有 sudo 权限的用户。就这些。&lt;/p&gt;
&lt;h2 id=&#34;安装-docker&#34;&gt;安装 Docker&lt;/h2&gt;
&lt;p&gt;首先，我们将使用传统的方法安装 Docker 运行时引擎。首先要做的是使用以下命令将官方 Docker GPG 添加到系统中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -fsSL &amp;lt;https://download.docker.com/linux/ubuntu/gpg&amp;gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，我们必须添加 Docker 仓库，以便安装软件。使用以下命令完成此操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] &amp;lt;https://download.docker.com/linux/ubuntu&amp;gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;lsb_release -cs&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; stable&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo tee /etc/apt/sources.list.d/docker.list &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;gt&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; /dev/null
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;添加仓库后，我们将使用以下命令安装一些依赖项：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release -y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用以下命令更新 apt：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get update
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，我们可以使用以下命令安装 Docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install docker-ce docker-ce-cli containerd.io -y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了能够在不使用 &lt;em&gt;sudo&lt;/em&gt; 的情况下运行 Docker 命令（这可能存在安全风险），请使用以下命令将您的用户添加到 docker 用户组中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo usermod -aG docker &lt;span class=&#34;nv&#34;&gt;$USER&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注销并重新登录以使更改生效。&lt;/p&gt;
&lt;p&gt;如果您希望采用快速方式，可以使用以下命令安装 Docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install curl wget uidmap -y
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wget -qO- https://get.docker.com/ &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要能够以无特权方式运行 Docker，请执行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;dockerd-rootless-setuptool.sh install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;如何安装-x11docker&#34;&gt;如何安装 x11docker&lt;/h2&gt;
&lt;p&gt;在安装 x11docker 之前，我们必须安装一些依赖项。可以使用以下命令完成此操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt-get install xpra xserver-xephyr xinit xauth xclip x11-xserver-utils x11-utils -y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，使用以下命令安装 x11docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -fsSL https://raw.githubusercontent.com/mviereck/x11docker/master/x11docker &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo bash -s -- --update
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，您可以使用以下命令更新 x11docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo x11docker --update
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;如何使用-x11docker&#34;&gt;如何使用 x11docker&lt;/h2&gt;
&lt;p&gt;安装了 x11docker 之后，就可以开始测试了。让我们使用 VLC 应用程序容器进行测试。首先，使用以下命令拉取镜像：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker pull jess/vlc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;拉取镜像后，使用以下命令（借助 x11docker）运行 VLC：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;x11docker --pulseaudio --share&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$HOME&lt;/span&gt;/Videos jess/vlc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您应该会看到 VLC 窗口打开，准备好供使用（图 1）。它的速度比直接安装在您的桌面上要慢一些，但除此之外，它应该按预期工作。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/run-gui-applications-as-containers-with-x11docker/docker_hu_c73d0da09d0d6fe8.webp 400w,
               /blog/run-gui-applications-as-containers-with-x11docker/docker_hu_7b5b09cbf653fd1e.webp 760w,
               /blog/run-gui-applications-as-containers-with-x11docker/docker_hu_23450f2a4c7a5b91.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/run-gui-applications-as-containers-with-x11docker/docker_hu_c73d0da09d0d6fe8.webp&#34;
               width=&#34;621&#34;
               height=&#34;486&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当然，如果您是开发人员，这对您帮助不大，因为您想要开发自己的容器。您可以始终创建要使用的映像，对其进行标记，将其推送到您选择的存储库，使用 docker pull 命令将其拉到开发系统上，然后使用 x11docker 部署容器。&lt;/p&gt;
&lt;p&gt;就是这样。现在，您可以通过 x11docker 在 Docker 容器中运行 GUI 应用程序了。借助自己的图像部署自己的定制容器，看看它的工作原理。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WebAssembly：无需容器就能运行 Docker！</title>
      <link>https://cloudnativecn.com/blog/docker-without-containers/</link>
      <pubDate>Thu, 27 Apr 2023 06:27:22 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/docker-without-containers/</guid>
      <description>&lt;p&gt;最近，Docker 宣布与 WasmEdge 合作，在 Docker 生态系统中支持 &lt;a href=&#34;https://docs.docker.com/desktop/wasm/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WebAssembly&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文将介绍什么是 WebAssembly，以及为什么它与 Docker 生态系统相关，并提供一些实践示例。我们假设您熟悉 Docker 工具集。我们将使用我们的 &lt;a href=&#34;https://wasmlabs.dev/articles/php-wasm32-wasi-port/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WebAssembly PHP 的端口&lt;/a&gt; 来演示如何构建 PHP 解释器，将其打包为 OCI 镜像的一部分，并使用 Docker 运行它。&lt;/p&gt;
&lt;p&gt;请注意，本文的重点是获得实践经验，而不是讨论技术细节。您可以复制以下示例，也可以只读到最后，因为我们还将提供输出。&lt;/p&gt;
&lt;h2 id=&#34;webassembly---什么为什么&#34;&gt;WebAssembly - 什么？为什么？&lt;/h2&gt;
&lt;p&gt;这是一个非常基本的介绍。如果您已经熟悉该技术，则可以跳到动手环节。&lt;/p&gt;
&lt;h3 id=&#34;什么是-webassembly&#34;&gt;什么是 WebAssembly？&lt;/h3&gt;
&lt;p&gt;WebAssembly（或 Wasm）是一个开放标准，定义了一种二进制指令格式，可以从不同的源语言创建可移植的二进制可执行文件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/docker-without-containers/1_hu_abc27f74f154f239.webp 400w,
               /blog/docker-without-containers/1_hu_47e0fdf9614deada.webp 760w,
               /blog/docker-without-containers/1_hu_e75c39f4b21137ab.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/docker-without-containers/1_hu_abc27f74f154f239.webp&#34;
               width=&#34;757&#34;
               height=&#34;181&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些二进制文件可以在各种环境中运行。它起源于 web，并得到所有主要浏览器的支持。&lt;/p&gt;
&lt;h3 id=&#34;wasm-在浏览器中是如何工作的&#34;&gt;Wasm 在浏览器中是如何工作的？&lt;/h3&gt;
&lt;p&gt;浏览器引擎集成了一个 Wasm 虚拟机，通常称为 Wasm 运行时，它可以运行 Wasm 二进制指令。有编译器工具链（如 Emscripten）可以将源代码编译为 Wasm 目标。这允许将传统应用程序移植到浏览器，并直接与在客户端 Web 应用程序中运行的 JS 代码通信。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/docker-without-containers/2_hu_14807bd2b27c7693.webp 400w,
               /blog/docker-without-containers/2_hu_4cc9d0fd804841e7.webp 760w,
               /blog/docker-without-containers/2_hu_a3cc3f5d6dcc52ba.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/docker-without-containers/2_hu_14807bd2b27c7693.webp&#34;
               width=&#34;757&#34;
               height=&#34;312&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些技术使传统桌面应用程序可以在浏览器中运行。现在它们可以在任何您拥有浏览器的设备上运行。一些著名的例子是 &lt;a href=&#34;https://earth.google.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Earth&lt;/a&gt; 和计算机视觉的 &lt;a href=&#34;https://opencv.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open CV&lt;/a&gt; 库。&lt;/p&gt;
&lt;h3 id=&#34;wasm-在服务器上是如何工作的&#34;&gt;Wasm 在服务器上是如何工作的？&lt;/h3&gt;
&lt;p&gt;有一些 Wasm 运行时可以在浏览器之外运行，包括传统操作系统，如 Linux、Windows 和 macOS。由于它们不能依赖于 JavaScript 引擎的可用性，它们使用不同的接口（例如 WASI，&lt;a href=&#34;https://wasi.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WebAssembly 系统接口&lt;/a&gt;）与外界通信。这些运行时允许 Wasm 应用程序以与 POSIX 类似（但不完全相同）的方式与其主机系统交互。像 WASI SDK 和 wasi-libc 这样的项目可以帮助人们将现有的 POSIX 兼容应用程序编译到 WebAssembly。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/docker-without-containers/3_hu_b17dae37d7eee3f0.webp 400w,
               /blog/docker-without-containers/3_hu_46de7252e8401a08.webp 760w,
               /blog/docker-without-containers/3_hu_68079f8dbfed2015.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/docker-without-containers/3_hu_b17dae37d7eee3f0.webp&#34;
               width=&#34;757&#34;
               height=&#34;306&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;您只需要将应用程序编译为 Wasm 模块一次，然后就可以在任何地方运行完全相同的二进制文件。&lt;/p&gt;
&lt;h3 id=&#34;什么使-wasm-如此出色&#34;&gt;什么使 Wasm 如此出色？&lt;/h3&gt;
&lt;p&gt;一些使 Wasm 在浏览器中出色的功能也使其对服务器端开发非常有吸引力：&lt;/p&gt;
&lt;p&gt;🌐 开放 - 它是行业广泛采用的标准。与过去的浏览器之争不同，主要公司正在协作标准化 WASI 和 WebAssembly 应用程序。&lt;/p&gt;
&lt;p&gt;🚀 快速 - 它可以通过大多数运行时的 JIT/AOT 能力提供类似本机的速度。不像启动 VM 或启动容器那样有冷启动。&lt;/p&gt;
&lt;p&gt;🔒 安全 - Wasm 运行时默认情况下是隔离的，并允许安全地访问内存。基于能力的模型确保 Wasm 应用程序仅能访问其明确允许的内容。安全的供应链。&lt;/p&gt;
&lt;p&gt;💼 可移植 - 在几个主要运行时中，支持大多数 CPU（x86、ARM、RISC-V）和大多数操作系统，包括 Linux、Windows、macOS、Android、ESXi，甚至非 POSIX 的操作系统。&lt;/p&gt;
&lt;p&gt;🔋 高效 - Wasm 应用程序可以通过最小的内存占用和 CPU 要求运行。&lt;/p&gt;
&lt;p&gt;🗣️ 多语言支持 - 40 多种语言可以编译为 Wasm，并具有现代的、不断改进的工具链。&lt;/p&gt;
&lt;h3 id=&#34;服务器平台演进的下一步&#34;&gt;服务器平台演进的下一步？&lt;/h3&gt;
&lt;p&gt;您可能已经看到过 Docker 的共同创始人之一 Solomon Hykes 的这段 &lt;a href=&#34;https://twitter.com/solomonstre/status/1111004913222324225&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;引述&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 WASM+WASI 在 2008 年存在，我们就不需要创建 Docker 了。这就是它的重要性。WebAssembly 在服务器上是计算的未来。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;确实，WASM+WASI 似乎是服务器端软件基础架构演进的下一步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在过去，我们有物理硬件可用。我们会在每个盒子上仔细安装操作系统和应用程序，并逐个维护它们。&lt;/li&gt;
&lt;li&gt;然后，随着由 VMware 开创的 VM 的采用，事情变得更容易了。人们可以复制、克隆和移动 VM 跨硬件盒。但这仍然需要在 VM 中安装操作系统和应用程序。&lt;/li&gt;
&lt;li&gt;然后，容器出现了，由 Docker 推广，它使得在极简的包装上下文中运行应用程序配置变得更加容易，而不会影响主机操作系统上的任何其他应用程序。然而，这仍然需要分发应用程序与其运行时和必要的库捆绑在一起。安全边界由 Linux 内核提供。&lt;/li&gt;
&lt;li&gt;我们现在有了 WebAssembly。它的技术特点和可移植性使得分发应用程序变得可能，无需运输 OS 级别的依赖项，并且可以在严格的安全约束下运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考虑到所有这些，开发人员通常会将 WebAssembly 视为容器的“继承者”和基础架构部署的下一个逻辑步骤。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/docker-without-containers/4_hu_f37980f50df3e843.webp 400w,
               /blog/docker-without-containers/4_hu_2f345ae3e755e1bb.webp 760w,
               /blog/docker-without-containers/4_hu_ebe0eeeea8708617.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/docker-without-containers/4_hu_f37980f50df3e843.webp&#34;
               width=&#34;757&#34;
               height=&#34;212&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然而，另一种看待 WebAssembly 的方式是作为 Docker 工具链的替代“后端”。您可以使用相同的命令行工具和工作流程，但是，而不是使用 Linux 容器，它是使用基于 WebAssembly 的容器等价物实现的。本文的其余部分探讨了这个概念，这就是我们所说的“没有容器的 Docker”标题。&lt;/p&gt;
&lt;h3 id=&#34;wasm-如何与-docker-配合使用&#34;&gt;Wasm 如何与 Docker 配合使用？&lt;/h3&gt;
&lt;p&gt;Docker Desktop 现在包括对 WebAssembly 的支持。它是使用一个称为 &lt;a href=&#34;https://github.com/WasmEdge/Wasmedge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WasmEdge&lt;/a&gt; 的 Wasm 运行时运行 Wasm 应用程序的 containerd shim 实现的。这意味着，与运行容器镜像中的二进制文件的单独进程不同，您现在可以在 WasmEdge 运行时中运行 Wasm 应用程序，模拟容器。&lt;/p&gt;
&lt;p&gt;因此，容器镜像不需要包含正在运行的应用程序的 OS 或运行时上下文——单个 Wasm 二进制文件就足够了。&lt;/p&gt;
&lt;p&gt;这在 Docker 的 &lt;a href=&#34;https://www.docker.com/blog/docker-wasm-technical-preview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wasm 技术预览文章&lt;/a&gt; 中有详细说明。&lt;/p&gt;
&lt;h3 id=&#34;什么是-wasmedge&#34;&gt;什么是 WasmEdge？&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/WasmEdge/Wasmedge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WasmEdge&lt;/a&gt; 是一个高性能的 WebAssembly 运行时，具有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是开源的，是 &lt;a href=&#34;https://cncf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF&lt;/a&gt; 的一部分。&lt;/li&gt;
&lt;li&gt;支持所有主要的 CPU 架构（x86、ARM、RISC-V）。&lt;/li&gt;
&lt;li&gt;支持所有主要的操作系统（Linux、Windows、macOS），以及其他操作系统，如 seL4 RTOS、Android。&lt;/li&gt;
&lt;li&gt;为云原生和 Edge 应用程序进行了优化。&lt;/li&gt;
&lt;li&gt;是可扩展的，支持标准和新兴技术
&lt;ul&gt;
&lt;li&gt;与 Tensorflow、OpenVINO、PyTorch 一起进行 AI 推理&lt;/li&gt;
&lt;li&gt;支持使用 Tokio 进行异步网络。支持微服务、数据库客户端、消息队列等。&lt;/li&gt;
&lt;li&gt;与容器生态系统、Docker 和 Kubernetes 完美集成（正如本文所示！）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解释性语言呢&#34;&gt;解释性语言呢？&lt;/h3&gt;
&lt;p&gt;到目前为止，我们只提到了编译语言（如 C 和 Rust）可以针对 WebAssembly。对于解释性语言（如 Python、Ruby 和 PHP），方法是不同的：它们的解释器是用 C 编写的，可以编译为 WebAssembly。然后，这个解释器编译为 Wasm，可以用于执行源代码文件，通常以 .py、.rb、.php 等结尾。一旦编译为 Wasm，任何具有 Wasm 运行时的平台都将能够运行那些解释性语言，即使实际的解释器从未原生地编译为该平台。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/docker-without-containers/5_hu_51e4b56940cf0201.webp 400w,
               /blog/docker-without-containers/5_hu_bb636249887b3d68.webp 760w,
               /blog/docker-without-containers/5_hu_2b1a46fc8923a5cc.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/docker-without-containers/5_hu_51e4b56940cf0201.webp&#34;
               width=&#34;757&#34;
               height=&#34;332&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;实际演示&#34;&gt;实际演示&lt;/h2&gt;
&lt;p&gt;让我们开始吧！在实际演示中，我们将使用编译为 Wasm 的 PHP 解释器。我们将：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建一个 &lt;a href=&#34;https://wasmlabs.dev/articles/docker-without-containers/#building-a-wasm-container&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wasm 容器&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;比较 &lt;a href=&#34;https://wasmlabs.dev/articles/docker-without-containers/#native-vs-wasm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wasm 和本地&lt;/a&gt; 二进制文件。&lt;/li&gt;
&lt;li&gt;比较 &lt;a href=&#34;https://wasmlabs.dev/articles/docker-without-containers/#traditional-vs-wasm-containers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;传统和 Wasm&lt;/a&gt; 容器。&lt;/li&gt;
&lt;li&gt;展示了 &lt;a href=&#34;https://wasmlabs.dev/articles/docker-without-containers/#wasm-portability&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wasm 的可移植性&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;先决条件&#34;&gt;先决条件&lt;/h2&gt;
&lt;p&gt;如果您想在本地复制演示，您需要准备一些或全部以下内容的环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WASI SDK - 从旧 C 代码构建 WebAssembly 应用程序&lt;/li&gt;
&lt;li&gt;PHP - 为了进行本地 PHP 二进制文件比较&lt;/li&gt;
&lt;li&gt;WasmEdge 运行时 - 运行 WebAssembly 应用程序&lt;/li&gt;
&lt;li&gt;Docker Desktop + Wasm（在撰写本文时，可在 &lt;a href=&#34;https://docs.docker.com/desktop/release-notes/#4150&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;版本 4.15&lt;/a&gt; 中稳定测试版中使用）以能够运行 Wasm 容器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们还利用了&lt;a href=&#34;https://github.com/vmware-labs/webassembly-language-runtimes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;“Wasm 语言运行时”&lt;/a&gt;存储库，该存储库提供了将 PHP 解释器构建为 WebAssembly 应用程序的方法。&lt;/p&gt;
&lt;p&gt;您可以通过以下方式开始检查演示分支：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone --depth&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; -b php-wasmedge-demo &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &amp;lt;https://github.com/vmware-labs/webassembly-language-runtimes.git&amp;gt; wlr-demo
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; wlr-demo
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;构建一个-wasm-容器&#34;&gt;构建一个 Wasm 容器&lt;/h2&gt;
&lt;p&gt;首先，我们将展示如何构建一个类似于 PHP 解释器的基于 C 的应用程序。&lt;/p&gt;
&lt;p&gt;构建过程使用 WASI-SDK 工具集。它包括一个可以构建为 wasm32-wasi 目标的 clang 编译器，以及实现在 WASI 上的基本 POSIX 系统调用接口的 wasi-libc。使用 WASI SDK，我们可以从 PHP 的 C 代码库构建 Wasm 模块。然后，我们只需要一个基于 scratch 的非常简单的 Dockerfile 就可以制作一个 OCI 镜像，该镜像可以使用 Docker+Wasm 运行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/docker-without-containers/6_hu_fc0c99bf3d6d530.webp 400w,
               /blog/docker-without-containers/6_hu_46240391baad1d97.webp 760w,
               /blog/docker-without-containers/6_hu_ee3e4f36d3b999d9.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/docker-without-containers/6_hu_fc0c99bf3d6d530.webp&#34;
               width=&#34;757&#34;
               height=&#34;212&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;构建-wasm-二进制文件&#34;&gt;构建 WASM 二进制文件&lt;/h3&gt;
&lt;p&gt;假设你在 &lt;code&gt;wlr-demo&lt;/code&gt; 文件夹中，你可以运行以下命令来构建 Wasm 二进制文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;WASI_SDK_ROOT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/opt/wasi-sdk/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;WASMLABS_RUNTIME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;wasmedge
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./wl-make.sh php/php-7.4.32/ &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; tree build-output/php/php-7.4.32/bin/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;... &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt; a few minutes and hundreds of build log lines&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;build-output/php/php-7.4.32/bin/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;├── php-cgi-wasmedge
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;└── php-wasmedge
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;PHP 是使用 &lt;em&gt;autoconf&lt;/em&gt; 和 &lt;em&gt;make&lt;/em&gt; 构建的。因此，如果你查看 &lt;code&gt;scripts/wl-build.sh&lt;/code&gt; 脚本，你会注意到我们设置了所有相关变量，如 &lt;code&gt;CC&lt;/code&gt;、&lt;code&gt;LD&lt;/code&gt;、&lt;code&gt;CXX&lt;/code&gt; 等，以使用来自 WASI_SDK 的编译器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;WASI_SYSROOT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;WASI_SDK_ROOT&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;/share/wasi-sysroot&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;WASI_SDK_ROOT&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/bin/clang
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;LD&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;WASI_SDK_ROOT&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/bin/wasm-ld
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;CXX&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;WASI_SDK_ROOT&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/bin/clang++
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;WASI_SDK_ROOT&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/bin/llvm-nm
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;AR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;WASI_SDK_ROOT&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/bin/llvm-ar
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;RANLIB&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;WASI_SDK_ROOT&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/bin/llvm-ranlib
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，进一步研究 &lt;code&gt;php/php-7.4.32/wl-build.sh&lt;/code&gt;，你可以看到我们像往常一样使用 &lt;em&gt;autoconf&lt;/em&gt; 构建过程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;./configure --host&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;wasm32-wasi &lt;span class=&#34;nv&#34;&gt;host_alias&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;wasm32-musl-wasi &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   --target&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;wasm32-wasi &lt;span class=&#34;nv&#34;&gt;target_alias&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;wasm32-musl-wasi &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;PHP_CONFIGURE&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make -j &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;MAKE_TARGETS&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;exit&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;WASI 还在不断发展，许多 POSIX 调用仍然无法在其上实现。因此，为了构建 PHP，我们不得不在原始代码库的基础上应用几个补丁。&lt;/p&gt;
&lt;p&gt;我们在上面看到了输出二进制文件到 &lt;code&gt;build-output/php/php-7.4.32&lt;/code&gt;。在接下来的例子中，我们将使用专门为 WasmEdge 构建的 &lt;code&gt;php-wasmedge&lt;/code&gt; 二进制文件，因为它提供了服务器端套接字支持，这还不是 WASI 的一部分。&lt;/p&gt;
&lt;h3 id=&#34;优化二进制文件&#34;&gt;优化二进制文件&lt;/h3&gt;
&lt;p&gt;Wasm 是一种虚拟指令集，因此任何运行时的默认行为都是实时解释这些指令。当然，在某些情况下这可能会使事情变慢。因此，为了在 WasmEdge 中获得最佳性能，您可以创建一个 AOT（ahead-of-time）优化二进制文件，该文件在当前机器上本地运行，但仍可以在其他机器上解释。&lt;/p&gt;
&lt;p&gt;要创建该优化二进制文件，请运行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wasmedgec --enable-all --optimize &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   build-output/php/php-7.4.32/bin/php-wasmedge &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   build-output/php/php-7.4.32/bin/php-wasmedge-aot
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们将在以下示例中使用此 &lt;code&gt;build-output/php/php-7.4.32/bin/php-wasmedge-aot&lt;/code&gt; 二进制文件。要了解有关 WasmEdge AOT 优化二进制文件的更多信息，请查看 &lt;a href=&#34;https://wasmlabs.dev/articles/docker-without-containers/build-output/php/php-7.4.32/bin/php-wasmedge-aot&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此处&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;构建-oci-镜像&#34;&gt;构建 OCI 镜像&lt;/h3&gt;
&lt;p&gt;现在我们有了二进制文件，我们可以将其包装在 OCI 镜像中。&lt;/p&gt;
&lt;p&gt;让我们来看看 &lt;code&gt;images/php/Dockerfile.cli&lt;/code&gt;。我们只需要复制 Wasm 二进制文件并将其设置为 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; scratch&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ARG&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PHP_TAG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;php-7.4.32&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ARG&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PHP_BINARY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;php
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; build-output/php/&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;PHP_TAG&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/bin/&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;PHP_BINARY&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; /php.wasm&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENTRYPOINT&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;php.wasm&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们还可以向镜像添加更多内容，当 Wasm 二进制文件在 Docker 中运行时，这些内容将可访问。例如，在 &lt;code&gt;images/php/Dockerfile.server&lt;/code&gt; 中，我们还添加了一些 docroot 内容，以便在容器启动时由 &lt;code&gt;php.wasm&lt;/code&gt; 服务。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; scratch&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ARG&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PHP_TAG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;php-7.4.32&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ARG&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;PHP_BINARY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;php
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; build-output/php/&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;PHP_TAG&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/bin/&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;PHP_BINARY&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; /php.wasm&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COPY&lt;/span&gt; images/php/docroot /docroot&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ENTRYPOINT&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;php.wasm&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;-S&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0.0.0.0:8080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;-t&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/docroot&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;基于上述文件，我们可以轻松地在本地构建我们的 &lt;code&gt;php-wasm&lt;/code&gt; 镜像。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker build --build-arg &lt;span class=&#34;nv&#34;&gt;PHP_BINARY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;php-wasmedge-aot -t ghcr.io/vmware-labs/php-wasm:7.4.32-cli-aot -f images/php/Dockerfile.cli .
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker build --build-arg &lt;span class=&#34;nv&#34;&gt;PHP_BINARY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;php-wasmedge-aot -t ghcr.io/vmware-labs/php-wasm:7.4.32-server-aot -f images/php/Dockerfile.server .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;原生-vs-wasm&#34;&gt;原生 vs Wasm&lt;/h2&gt;
&lt;p&gt;现在让我们将原生 PHP 二进制文件与 Wasm 二进制文件进行比较。在本地和 Docker 容器中都使用相同的 &lt;code&gt;index.php&lt;/code&gt; 文件运行它，并比较我们运行它时得到的结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;php&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;php-wasmedge-aot&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;传统容器中的 &lt;code&gt;php&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;Wasm 容器中的 &lt;code&gt;php-wasmedge-aot&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/docker-without-containers/7_hu_6386af0538f04b9.webp 400w,
               /blog/docker-without-containers/7_hu_1ad4fb35e891b71b.webp 760w,
               /blog/docker-without-containers/7_hu_51fdcb60edbe2f17.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/docker-without-containers/7_hu_6386af0538f04b9.webp&#34;
               width=&#34;757&#34;
               height=&#34;326&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在以下所有示例中，我们都使用相同的 &lt;code&gt;images/php/docroot/index.php&lt;/code&gt; 文件，因此让我们来看看。简而言之，此脚本将：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;phpversion&lt;/code&gt; 和 &lt;code&gt;php_uname&lt;/code&gt; 显示解释器版本和正在运行的平台&lt;/li&gt;
&lt;li&gt;打印脚本可以访问的所有环境变量的名称&lt;/li&gt;
&lt;li&gt;使用当前时间和日期打印一个 hello 消息&lt;/li&gt;
&lt;li&gt;列出根目录 &lt;code&gt;/&lt;/code&gt; 的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;html&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;h1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Hello from PHP &lt;span class=&#34;cp&#34;&gt;&amp;lt;?php echo phpversion() ?&amp;gt;&lt;/span&gt; running on &amp;#34;&lt;span class=&#34;cp&#34;&gt;&amp;lt;?php echo php_uname()?&amp;gt;&lt;/span&gt;&amp;#34;&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;h1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;h2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;List env variable names&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;h2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&amp;lt;?php
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;$php_env_vars_count = count(getenv());
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;echo &amp;#34;Running with $php_env_vars_count environment variables:\\n&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;foreach (getenv() as $key =&amp;gt; $value) {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;    echo  $key . &amp;#34; &amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;echo &amp;#34;\\n&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;?&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;h2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Hello&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;h2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&amp;lt;?php
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;$date = getdate();
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;$message = &amp;#34;Today, &amp;#34; . $date[&amp;#39;weekday&amp;#39;] . &amp;#34;, &amp;#34; . $date[&amp;#39;year&amp;#39;] . &amp;#34;-&amp;#34; . $date[&amp;#39;mon&amp;#39;] . &amp;#34;-&amp;#34; . $date[&amp;#39;mday&amp;#39;];
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;$message .= &amp;#34;, at &amp;#34; . $date[&amp;#39;hours&amp;#39;] . &amp;#34;:&amp;#34; . $date[&amp;#39;minutes&amp;#39;] . &amp;#34;:&amp;#34; . $date[&amp;#39;seconds&amp;#39;];
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;$message .= &amp;#34; we greet you with this message!\\n&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;echo $message;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;?&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;h2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Contents of &amp;#39;/&amp;#39;&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;h2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&amp;lt;?php
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;foreach (array_diff(scandir(&amp;#39;/&amp;#39;), array(&amp;#39;.&amp;#39;, &amp;#39;..&amp;#39;)) as $key =&amp;gt; $value) {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;    echo  $value . &amp;#34; &amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;echo &amp;#34;\\n&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;?&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;html&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;原生运行-indexphp-的-php&#34;&gt;原生运行 index.php 的 PHP&lt;/h3&gt;
&lt;p&gt;当我们使用原生的 &lt;code&gt;php&lt;/code&gt; 二进制文件时，我们会看到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 Linux 的平台&lt;/li&gt;
&lt;li&gt;脚本可以访问的 58 个环境变量列表（如果需要的话）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt; 中所有文件和文件夹的列表，这些都是脚本可以访问的&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ php -f images/php/docroot/index.php
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;body&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h1&amp;gt;Hello from PHP 7.4.3 running on &lt;span class=&#34;s2&#34;&gt;&amp;#34;Linux alexandrov-z01 5.15.79.1-microsoft-standard-WSL2 #1 SMP Wed Nov 23 01:01:46 UTC 2022 x86_64&amp;#34;&lt;/span&gt;&amp;lt;/h1&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h2&amp;gt;List env variable names&amp;lt;/h2&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Running with &lt;span class=&#34;m&#34;&gt;58&lt;/span&gt; environment variables:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SHELL NVM_INC WSL2_GUI_APPS_ENABLED rvm_prefix WSL_DISTRO_NAME TMUX rvm_stored_umask TMUX_PLUGIN_MANAGER_PATH MY_RUBY_HOME NAME RUBY_VERSION PWD NIX_PROFILES LOGNAME rvm_version rvm_user_install_flag MOTD_SHOWN HOME LANG WSL_INTEROP LS_COLORS WASMTIME_HOME WAYLAND_DISPLAY NIX_SSL_CERT_FILE PROMPT_COMMAND NVM_DIR rvm_bin_path GEM_PATH GEM_HOME LESSCLOSE TERM CPLUS_INCLUDE_PATH LESSOPEN USER TMUX_PANE LIBRARY_PATH rvm_loaded_flag DISPLAY SHLVL NVM_CD_FLAGS LD_LIBRARY_PATH XDG_RUNTIME_DIR PS1 WSLENV XDG_DATA_DIRS PATH DBUS_SESSION_BUS_ADDRESS C_INCLUDE_PATH NVM_BIN HOSTTYPE WASMER_CACHE_DIR IRBRC PULSE_SERVER rvm_path WASMER_DIR OLDPWD BASH_FUNC_cr-open%% _
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h2&amp;gt;Hello&amp;lt;/h2&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Today, Wednesday, 2022-12-14, at 12:0:36 we greet you with this message!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h2&amp;gt;Contents of &lt;span class=&#34;s1&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&amp;lt;/h2&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;apps bin boot dev docroot etc home init lib lib32 lib64 libx32 lost+found media mnt nix opt path proc root run sbin snap srv sys tmp usr var wsl.localhost
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/body&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;php-aot-wasm-运行-indexphp&#34;&gt;php-aot-wasm 运行 index.php&lt;/h3&gt;
&lt;p&gt;当我们使用&lt;code&gt;php-aot-wasm&lt;/code&gt;与 Wasmedge 结合使用时，我们发现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wasi/wasm32平台&lt;/li&gt;
&lt;li&gt;没有环境变量，因为没有将任何环境变量显式暴露给 Wasm 应用程序&lt;/li&gt;
&lt;li&gt;Wasm 应用程序没有被明确授权访问&lt;code&gt;/&lt;/code&gt;，因此尝试列出其内容时会出现错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，要使&lt;code&gt;php-wasmedge-aot&lt;/code&gt;可以访问读取&lt;code&gt;index.php&lt;/code&gt;文件，我们必须明确说明我们想要预先打开&lt;code&gt;images/php/docroot&lt;/code&gt;以便 WasmEdge 可以访问它作为 Wasm 应用程序上下文中的&lt;code&gt;/docroot&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这很容易显示了 Wasm 除了可移植性之外的最大优点之一。我们获得了更好的安全性，因为除非明确说明，否则没有任何内容是可访问的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ wasmedge --dir /docroot:&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/images/php/docroot &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   build-output/php/php-7.4.32/bin/php-wasmedge-aot -f /docroot/index.php
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;body&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h1&amp;gt;Hello from PHP 7.4.32 running on &lt;span class=&#34;s2&#34;&gt;&amp;#34;wasi (none) 0.0.0 0.0.0 wasm32&amp;#34;&lt;/span&gt;&amp;lt;/h1&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h2&amp;gt;List env variable names&amp;lt;/h2&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Running with &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; environment variables:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h2&amp;gt;Hello&amp;lt;/h2&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Today, Wednesday, 2022-12-14, at 10:8:46 we greet you with this message!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h2&amp;gt;Contents of &lt;span class=&#34;s1&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&amp;lt;/h2&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Warning: scandir&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;/&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;: failed to open dir: Capabilities insufficient in /docroot/index.php on line &lt;span class=&#34;m&#34;&gt;27&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Warning: scandir&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;: &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;errno 76&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;: Capabilities insufficient in /docroot/index.php on line &lt;span class=&#34;m&#34;&gt;27&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Warning: array_diff&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;: Expected parameter &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; to be an array, bool given in /docroot/index.php on line &lt;span class=&#34;m&#34;&gt;27&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Warning: Invalid argument supplied &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; foreach&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; in /docroot/index.php on line &lt;span class=&#34;m&#34;&gt;27&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/body&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;容器中运行-indexphp-的-php&#34;&gt;容器中运行 index.php 的 PHP&lt;/h3&gt;
&lt;p&gt;当我们使用传统容器中的“php”时，我们会看到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 Linux 的平台&lt;/li&gt;
&lt;li&gt;脚本具有访问权限的 14 个环境变量列表&lt;/li&gt;
&lt;li&gt;带有当前时间和日期的问候消息&lt;/li&gt;
&lt;li&gt;根文件夹&lt;code&gt;/&lt;/code&gt;的内容列表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与在主机上使用“php”的情况相比，这已经有所改善。由于环境变量和&lt;code&gt;/&lt;/code&gt;的内容是“虚拟”的，因此仅存在于容器内。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run --rm &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   -v &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/images/php/docroot:/docroot &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   php:7.4.32-cli &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   php -f /docroot/index.php
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;body&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h1&amp;gt;Hello from PHP 7.4.32 running on &lt;span class=&#34;s2&#34;&gt;&amp;#34;Linux 227b2bc2f611 5.15.79.1-microsoft-standard-WSL2 #1 SMP Wed Nov 23 01:01:46 UTC 2022 x86_64&amp;#34;&lt;/span&gt;&amp;lt;/h1&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h2&amp;gt;List env variable names&amp;lt;/h2&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Running with &lt;span class=&#34;m&#34;&gt;14&lt;/span&gt; environment variables:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HOSTNAME PHP_INI_DIR HOME PHP_LDFLAGS PHP_CFLAGS PHP_VERSION GPG_KEYS PHP_CPPFLAGS PHP_ASC_URL PHP_URL PATH PHPIZE_DEPS PWD PHP_SHA256
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h2&amp;gt;Hello&amp;lt;/h2&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Today, Wednesday, 2022-12-14, at 10:15:35 we greet you with this message!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h2&amp;gt;Contents of &lt;span class=&#34;s1&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&amp;lt;/h2&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bin boot dev docroot etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/body&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;容器中运行-indexphp-的-php-aot-wasm&#34;&gt;容器中运行 index.php 的 php-aot-wasm&lt;/h3&gt;
&lt;p&gt;当我们使用&lt;code&gt;php-aot-wasm&lt;/code&gt;与 Wasmedge 结合使用时，我们发现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wasi / wasm32 平台&lt;/li&gt;
&lt;li&gt;只有 2 个基础架构环境变量，使用运行在 containerd 中的 WasmEdge shim 预设&lt;/li&gt;
&lt;li&gt;显示了容器中&lt;code&gt;/&lt;/code&gt;中的所有文件和文件夹的列表，这是 Wasm 应用程序明确预先打开以便访问的（WasmEdge shim 中的逻辑的一部分）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：如果您更加细心，您将会看到为了从此镜像运行容器，我们必须：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;code&gt;runtime=io.containerd.wasmedge.v1&lt;/code&gt;明确地指定运行时&lt;/li&gt;
&lt;li&gt;直接传递命令行参数到&lt;code&gt;php.wasm&lt;/code&gt;，而不包括二进制文件本身。向上滚动并查看传统 PHP 容器，包括&lt;code&gt;php&lt;/code&gt;二进制文件（并不是必要的）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，即使是在 Docker 中，Wasm 也加强了运行 index.php 的安全性，因为暴露给它的东西要少得多。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run --rm &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   --runtime&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;io.containerd.wasmedge.v1 &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   -v &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/images/php/docroot:/docroot &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   ghcr.io/vmware-labs/php-wasm:7.4.32-cli-aot &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   -f /docroot/index.php
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;body&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h1&amp;gt;Hello from PHP 7.4.32 running on &lt;span class=&#34;s2&#34;&gt;&amp;#34;wasi (none) 0.0.0 0.0.0 wasm32&amp;#34;&lt;/span&gt;&amp;lt;/h1&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h2&amp;gt;List env variable names&amp;lt;/h2&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Running with &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; environment variables:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;PATH HOSTNAME
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h2&amp;gt;Hello&amp;lt;/h2&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Today, Wednesday, 2022-12-14, at 11:33:10 we greet you with this message!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;h2&amp;gt;Contents of &lt;span class=&#34;s1&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&amp;lt;/h2&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docroot etc php.wasm
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/body&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;传统容器与-wasm-容器&#34;&gt;传统容器与 wasm 容器&lt;/h2&gt;
&lt;p&gt;我们成功地构建和运行了一个 Wasm 二进制文件，并将其作为容器运行。我们看到了 Wasm 容器和传统容器之间的输出差异以及 Wasm 带来的高级“沙盒”性能。让我们看看我们可以轻松看到的两种容器类型之间的其他差异。&lt;/p&gt;
&lt;p&gt;首先，我们将运行两个守护程序容器，并查看如何解释有关它们的一些统计信息。然后，我们将检查容器镜像中的差异。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/docker-without-containers/8_hu_63ede3317c58d360.webp 400w,
               /blog/docker-without-containers/8_hu_c11ab40cd00636a8.webp 760w,
               /blog/docker-without-containers/8_hu_3e7a6c7546c4769c.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/docker-without-containers/8_hu_63ede3317c58d360.webp&#34;
               width=&#34;757&#34;
               height=&#34;465&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;容器统计&#34;&gt;容器统计&lt;/h3&gt;
&lt;p&gt;我们将运行两个守护程序容器 - 一个来自传统的&lt;code&gt;php&lt;/code&gt;镜像，另一个来自&lt;code&gt;php-wasm&lt;/code&gt;镜像。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run --rm -d &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   -p 8083:8080 -v &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/images/php/docroot:/docroot &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   php:7.4.32-cli &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   -S 0.0.0.0:8080 -t /docroot
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run --rm -d &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   --runtime&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;io.containerd.wasmedge.v1 &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   -p 8082:8080 -v &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/images/php/docroot:/docroot &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   ghcr.io/vmware-labs/php-wasm:7.4.32-cli-aot
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   -S 0.0.0.0:8080 -t /docroot
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是，如果我们查看&lt;code&gt;docker stats&lt;/code&gt;，我们将只看到传统容器的统计信息。由于 Docker+Wasm 是 beta 功能，这可能会发生变化。因此，如果想要查看正在发生的情况，可以监视控制组。每个传统容器都有自己的控制组，如&lt;code&gt;docker/ee44...&lt;/code&gt;所示。另一方面，Wasm 容器包含在&lt;code&gt;podruntime/docker&lt;/code&gt;控制组中，您可以间接观察它们的 CPU 或内存消耗。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ systemd-cgtop -kP --depth&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Control Group           Tasks    %CPU     Memory
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;podruntime              &lt;span class=&#34;m&#34;&gt;145&lt;/span&gt;      0.1      636.3M
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;podruntime/docker       &lt;span class=&#34;m&#34;&gt;145&lt;/span&gt;      0.1      636.3M
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker                  &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;        0.0      39.7M
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker/ee444b...        &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;        0.0      6.7M
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;镜像大小&#34;&gt;镜像大小&lt;/h3&gt;
&lt;p&gt;首先，探索镜像时，我们会发现 Wasm 容器镜像比传统容器镜像小得多。即使是“php”容器的&lt;code&gt;alpine&lt;/code&gt;版本也比 Wasm 容器大。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker images
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;REPOSITORY                     TAG                 IMAGE ID       CREATED          SIZE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;php                            7.4.32-cli          680c4ba36f1b   &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; hours ago      166MB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;php                            7.4.32-cli-alpine   a785f7973660   &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; minutes ago    30.1MB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ghcr.io/vmware-labs/php-wasm   7.4.32-cli-aot      63460740f6d5   &lt;span class=&#34;m&#34;&gt;44&lt;/span&gt; minutes ago   5.35MB
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是因为使用 Wasm 时，我们只需要将可执行二进制文件放入容器中，而传统容器还需要一些来自操作系统的基本库和文件。&lt;/p&gt;
&lt;p&gt;这种大小上的差异对第一次拉取镜像的速度以及镜像在本地仓库中所占用的空间都有很大的益处。&lt;/p&gt;
&lt;h2 id=&#34;wasm-的可移植性&#34;&gt;Wasm 的可移植性&lt;/h2&gt;
&lt;p&gt;Wasm 最好的一点就是可移植性。当我们想要一个可移植的应用程序时，Docker 已经成为了传统容器的首选。然而，除了镜像大小之外，传统容器还绑定在它们运行的平台的架构上。我们中的许多人都经历过为支持不同架构构建软件的版本并将其打包到每个架构的不同镜像中的起伏。&lt;/p&gt;
&lt;p&gt;WebAssembly 带来了真正的可移植性。您可以编译一次二进制文件并在任何地方运行它。为了证明这种可移植性，我们准备了几个示例，演示了如何通过我们为 WebAssembly 构建的 PHP 解释器运行 WordPress。&lt;/p&gt;
&lt;p&gt;当它以独立的 Wasm 应用程序运行时，PHP 将为 WordPress 提供服务。同样地，它也可以在 Docker+Wasm 容器中运行。它还可以在嵌入 Wasm 运行时的任何应用程序中运行。在我们的示例中，这是 apache httpd，它通过 mod_wasm 可以将 Wasm 应用程序用作内容处理程序。最后，PHP.wasm 也可以在浏览器中运行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/docker-without-containers/9_hu_4e3eef5b73f96e24.webp 400w,
               /blog/docker-without-containers/9_hu_4c53ddb2769a6302.webp 760w,
               /blog/docker-without-containers/9_hu_adb4000e61bce232.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/docker-without-containers/9_hu_4e3eef5b73f96e24.webp&#34;
               width=&#34;757&#34;
               height=&#34;308&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;通过-wasmedge-提供-wordpress&#34;&gt;通过 WasmEdge 提供 WordPress&lt;/h3&gt;
&lt;p&gt;我们为此演示准备了一个紧凑的 WordPress+Sqlite 示例。由于它是 &lt;code&gt;ghcr.io/vmware-labs/php-wasm:7.4.32-server-wordpress&lt;/code&gt; 容器映像的一部分，因此让我们首先将其下载到本地。&lt;/p&gt;
&lt;p&gt;这条命令只会创建一个临时容器（拉取镜像），将 WordPress 文件复制到 &lt;code&gt;/tmp/wp/docroot&lt;/code&gt; 中，然后删除容器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;container_id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;docker create ghcr.io/vmware-labs/php-wasm:7.4.32-server-wordpress&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   mkdir /tmp/wp &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   docker cp &lt;span class=&#34;nv&#34;&gt;$container_id&lt;/span&gt;:/docroot /tmp/wp/ &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   docker rm &lt;span class=&#34;nv&#34;&gt;$container_id&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们有了 WordPress，让我们使用以下命令提供服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wasmedge --dir /docroot:/tmp/wp/docroot &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   build-output/php/php-7.4.32/bin/php-wasmedge-aot &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   -S 0.0.0.0:8085 -t /docroot
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您可以转到 &lt;a href=&#34;http://localhost:8085/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://localhost:8085&lt;/a&gt; 并享受由 PHP Wasm 解释器提供的 WordPress。&lt;/p&gt;
&lt;h3 id=&#34;通过-dockerwasm-提供-wordpress&#34;&gt;通过 Docker+Wasm 提供 WordPress&lt;/h3&gt;
&lt;p&gt;当然，使用 Docker，事情要简单得多。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run --rm --runtime&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;io.containerd.wasmedge.v1 &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   -p 8086:8080 -v /tmp/wp/docroot/:/docroot/ &lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   ghcr.io/vmware-labs/php-wasm:7.4.32-cli-aot
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   -S 0.0.0.0:8080 -t /docroot
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您可以转到 &lt;a href=&#34;http://localhost:8086/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://localhost:8086&lt;/a&gt; 并享受由 PHP Wasm 解释器提供的 WordPress，这一次它在 Docker 容器中运行。&lt;/p&gt;
&lt;h3 id=&#34;通过-apache-httpd-中的-mod_wasm-提供-wordpress&#34;&gt;通过 Apache HTTPD 中的 mod_wasm 提供 WordPress&lt;/h3&gt;
&lt;p&gt;Apache HTTPD 是最广泛使用的 HTTP 服务器之一。现在，通过 mod_wasm，它也可以运行 WebAssembly 应用程序。为了避免在本地安装和配置它，我们准备了一个容器，其中包含 Apache HTTPD、mod_wasm 和 WordPress。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run -p 8087:8080 projects.registry.vmware.com/wasmlabs/containers/php-mod-wasm:wordpress
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您可以转到 &lt;a href=&#34;http://localhost:8087/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://localhost:8087&lt;/a&gt; 并享受由 Apache HTTPD 中加载的 mod_wasm 提供的 PHP Wasm 解释器提供的 WordPress。&lt;/p&gt;
&lt;h3 id=&#34;直接在浏览器中提供-wordpress&#34;&gt;直接在浏览器中提供 WordPress&lt;/h3&gt;
&lt;p&gt;只需转到 [&lt;a href=&#34;https://wordpress.wasmlabs.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://wordpress.wasmlabs.dev&lt;/a&gt;] 查看示例。您将看到一个框架，其中 PHP Wasm 解释器正在现场渲染 WordPress。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;感谢您阅读本文。这是很多内容要消化，但我们希望它有助于了解 WebAssembly 的功能以及它如何与您现有的代码库和工具（包括 Docker）一起使用。期待看到您使用 Wasm 构建的内容！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 Docker 和 WebAssembly 打造容器的新时代！</title>
      <link>https://cloudnativecn.com/blog/docker-wasm-quick-intro/</link>
      <pubDate>Mon, 17 Apr 2023 10:27:22 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/docker-wasm-quick-intro/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;译者注：本文译自 &lt;a href=&#34;https://medium.com/@guglielmino/docker-webassembly-a-quick-intro-730c38e8390c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker + WebAssembly: a quick intro | by Fabrizio Guglielmino | Medium&lt;/a&gt;，本文介绍了使用 Docker 和 WebAssembly 创建容器的过程。通过比较标准 Docker 容器和 WebAssembly 容器，作者指出 WebAssembly 容器具有性能优势、架构中立等优点，但也存在不成熟的问题。WebAssembly 容器有望彻底改变容器化应用程序的方式。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;今天，我想展示一种实用且有趣的使用 Docker 的方式：在容器中使用 WebAssembly。&lt;/p&gt;
&lt;p&gt;我说“实用的方式”，这就是为什么我假设您有一些经验：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Docker（当然）&lt;/li&gt;
&lt;li&gt;Rust（实际上，只是为了理解“Hello World”）&lt;/li&gt;
&lt;li&gt;WebAssembly；只需要对其有一个基本的了解（注意：我将在讨论中交替使用 WASM 和 WebAssembly 这两个术语）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于我即将展示的内容，简单说一下：一个 Docker 容器是一个包含运行环境的映像的运行实例。运行环境通常是一个操作系统，大多数情况下是 Linux。操作系统是运行应用程序的必要条件。&lt;/p&gt;
&lt;p&gt;如果我们能够在最小化依赖关系的情况下运行应用程序，甚至不需要任何依赖关系，会怎样呢？&lt;/p&gt;
&lt;p&gt;这就是我想谈论的想法：使用 WASM，以及 Docker 中（目前测试版）的支持，我们将创建一个不含任何操作系统基础镜像的容器。&lt;/p&gt;
&lt;h2 id=&#34;为什么是-webassembly-容器&#34;&gt;为什么是 WebAssembly 容器？&lt;/h2&gt;
&lt;p&gt;引用 Docker 的作者 Solomon Hykes 的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“如果 WASM+WASI 在 2008 年就存在了，我们就不需要创造 Docker 了。”&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;这可能足够了，但让我们列举一些具体的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;安全性&lt;/strong&gt;：仅部署我们的代码可以减少“攻击面”，从而提高整体安全性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大小&lt;/strong&gt;：我们可以创建比等效于带有操作系统的应用程序更小得多的容器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能&lt;/strong&gt;：如您所料，没有操作系统层，WASM 容器可以表现出更好的性能（不总是正确的，但平均而言是正确的）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;架构中立性&lt;/strong&gt;：Docker 容器是为特定目标架构（arm、x86 等）编译的，只能在具有相同架构的主机上运行。相比之下，WebAssembly 是架构中立的，这意味着只要运行时可用，应用程序就可以在任何底层架构上运行。这提供了几个优点，例如在不需要重新编译的情况下在多个平台上运行相同的代码以及在以前不受支持的平台上运行代码的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之，使用 WebAssembly 容器有一些有趣的好处！&lt;/p&gt;
&lt;h2 id=&#34;让我们开始吧&#34;&gt;让我们开始吧&lt;/h2&gt;
&lt;p&gt;本文将高度实用，只涉及该主题的表面，并留下许多细节。这些细节将在将来的文章中深入探讨，尽管已经有许多很好的资源可用。&lt;/p&gt;
&lt;p&gt;让我们从一个基本应用程序开始。尽管在这个例子中是用 Rust 编写的，但使用的语言并不重要，只要它支持 WebAssembly 作为编译目标即可。&lt;/p&gt;
&lt;p&gt;假设在计算机上已经安装了 Rust（&lt;a href=&#34;https://www.rust-lang.org/tools/install&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如果没有&lt;/a&gt;），让我们使用 &lt;code&gt;cargo new rust-wasm-docker&lt;/code&gt; 创建一个新的 Rust 应用程序&lt;/p&gt;
&lt;p&gt;这将创建最小化的 Rust 应用程序结构。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;total 8
drwxr-xr-x@ 3 fabrizio  staff   96 Jan 12 20:55 src
-rw-r--r--@ 1 fabrizio  staff  186 Jan 12 20:55 Cargo.toml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以保留提供的最小应用程序代码，这是一个相当常见和易读的“Hello World”。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# cat src/main.rs
fn main() {
    println!(&amp;#34;Hello, world!&amp;#34;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;让我们尝试使用 &lt;code&gt;cargo run&lt;/code&gt; 运行，输出应该是“Hello, world!”。&lt;/p&gt;
&lt;h2 id=&#34;常见的-docker-方式&#34;&gt;常见的 Docker 方式&lt;/h2&gt;
&lt;p&gt;如果没有 WebAssembly 的方法，我们将创建一个 Docker 镜像：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM rust:latest

WORKDIR /usr/src/myapp
COPY . .

RUN cargo install --path .

CMD [&amp;#34;wasm-docker-hello&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是一个非常简单的 &lt;code&gt;Dockerfile&lt;/code&gt; ，它使用 Docker Hub 的 &lt;code&gt;rust&lt;/code&gt; 基本镜像，将源从当前主机目录复制到镜像中的 &lt;code&gt;/usr/src/myapp&lt;/code&gt; ，运行 &lt;code&gt;cargo install&lt;/code&gt; 来编译应用程序，最终将应用程序二进制文件定义为容器命令。&lt;/p&gt;
&lt;p&gt;假设 Docker 已经安装在计算机上（&lt;a href=&#34;https://docs.docker.com/get-docker/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如果没有&lt;/a&gt;），我们可以使用以下命令创建一个镜像： &lt;code&gt;docker build -t hello-docker .&lt;/code&gt; 该命令使用当前目录中的 Dockerfile 构建镜像，并将其标记为“hello-docker”。&lt;/p&gt;
&lt;p&gt;然后，在构建镜像后，我们可以使用 &lt;code&gt;docker run hello-world&lt;/code&gt; 运行它。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# docker run hello-docker&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Hello, world!
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，让我们尝试进行另一个快速测试，稍后在本文中更清楚地说明 WebAssembly 容器的区别。我们可以使用 &lt;code&gt;bash&lt;/code&gt; shell 覆盖默认命令来运行我们的镜像。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run -it hello-docker bash
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;root@be1902d5e9b6:/usr/src/myapp#
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出可能略有不同，因为容器 ID（be1902d5e9b6）在每次运行容器时都是随机生成的。无论如何，这里的重要点是，您可以获取一个 shell 与之交互，就像在任何常见的 Linux 机器上一样。&lt;/p&gt;
&lt;h2 id=&#34;走进-webassembly&#34;&gt;走进 WebAssembly&lt;/h2&gt;
&lt;p&gt;现在，让我回顾一下我们到目前为止所做的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们创建了一个非常（非常）简单的 Rust 应用程序&lt;/li&gt;
&lt;li&gt;我们在主机机器上构建和运行了该应用程序&lt;/li&gt;
&lt;li&gt;我们创建了一个 &lt;code&gt;Dockerfile&lt;/code&gt; 来构建应用程序和镜像&lt;/li&gt;
&lt;li&gt;我们通过成功运行它来测试了 Docker 镜像的功能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来呢？目标是仅使用我们的应用程序创建一个 docker 镜像。要非常明确：这意味着一个不含任何操作系统的镜像作为运行环境。实际上，我运行了 &lt;code&gt;docker run -it hello-docker bash&lt;/code&gt; 来展示我们创建的镜像实际上是一个带有我们的应用程序捆绑的 Linux 运行环境。&lt;/p&gt;
&lt;p&gt;在继续之前，我们需要配置一些工具。首先，我们必须设置编译 WebAssembly + WASI 的能力，然后启用实验性的 Docker 功能以运行 WASM 容器。&lt;/p&gt;
&lt;p&gt;让我们开始使用 &lt;code&gt;rustup target add wasm32-wasi&lt;/code&gt; 安装 WASI。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WASI（WebAssembly 系统接口）是一组规范和 API，提供了执行 WebAssembly 代码的标准接口，这些代码不在 Web 浏览器中运行，例如在服务器或独立应用程序中运行。它允许 WebAssembly 模块访问系统资源，如文件系统和网络，并提供安全的沙箱环境。它提供了使 WebAssembly 成为独立可执行格式所需的关键功能，使其能够用于各种超越 Web 的场景。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;到目前为止一切顺利！现在可以运行 &lt;code&gt;cargo build --target wasm32-wasi&lt;/code&gt; 编译 WebAssembly。如果尝试，我们将在 &lt;code&gt;target/wasm32-wasi/debug&lt;/code&gt; 目录中获得一个名为 &lt;code&gt;wasm-docker-hello.wasm&lt;/code&gt; 的文件。很好，但是我们该如何运行此二进制文件？尝试像普通可执行文件一样执行它，如 &lt;code&gt;. ./target/wasm32-wasi/debug/wasm-docker-hello.wasm&lt;/code&gt;，我们会收到错误，为什么？实际上，错误是不言自明的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;zsh: &lt;span class=&#34;nb&#34;&gt;exec&lt;/span&gt; format error: ./target/wasm32-wasi/debug/wasm-docker-hello.wasm
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;wasm 文件不是为我们主机的本机架构（无论是 x86_64、arm 还是其他）构建的。我们需要一个 &lt;strong&gt;WebAssembly 运行时&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;webassembly-运行时将-wasm-带到各处&#34;&gt;WebAssembly 运行时：将 WASM 带到各处&lt;/h2&gt;
&lt;p&gt;有许多 WASM 运行时。WebAssembly 最初是为在 Web 浏览器中使用而设计的，在这种情况下，运行时不需要，因为 &lt;strong&gt;浏览器充当运行时&lt;/strong&gt;。但是，在创建命令行应用程序的情况下，需要运行时，对于完整的应用程序、服务器等也是如此。&lt;/p&gt;
&lt;p&gt;我们将安装 &lt;strong&gt;WasmEdge&lt;/strong&gt;，这是 Docker 用于执行我们的 WASM 镜像的运行时。如果您在 Mac OS 或 Linux 机器上，可以使用以下命令进行安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -sSf &amp;lt;https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh&amp;gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; bash
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如需完整的安装说明（包括 Windows），请在此处查看 &lt;a href=&#34;https://wasmedge.org/book/en/quick_start/install.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://wasmedge.org/book/en/quick_start/install.html&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;启用-dockerwasm-集成&#34;&gt;启用 Docker+WASM 集成&lt;/h2&gt;
&lt;p&gt;最后一步是启用 Docker 中的 WASM 支持，这是目前的实验性功能。可以通过启用 containerd 镜像存储库来完成此操作。&lt;/p&gt;
&lt;p&gt;使用 Docker Desktop，只需在设置页面中打开该功能即可。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/docker-wasm-quick-intro/ui_hu_d9a860403954b80f.webp 400w,
               /blog/docker-wasm-quick-intro/ui_hu_b6ccfbec65000534.webp 760w,
               /blog/docker-wasm-quick-intro/ui_hu_daf3a74f4920fd25.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/docker-wasm-quick-intro/ui_hu_d9a860403954b80f.webp&#34;
               width=&#34;760&#34;
               height=&#34;357&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;详细说明可以在此处找到 &lt;a href=&#34;https://docs.docker.com/desktop/wasm/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://docs.docker.com/desktop/wasm/&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;准备创建无操作系统的容器&#34;&gt;准备创建“无操作系统“的容器&lt;/h2&gt;
&lt;p&gt;现在我们已经准备好创建一个新的 Dockerfile（我们将其命名为 &lt;code&gt;Dockerfile.wasm&lt;/code&gt; 以区分它与以前的文件），内容如下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;FROM scratch
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;COPY target/wasm32-wasi/debug/wasm-docker-hello.wasm /app.wasm
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ENTRYPOINT &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;app.wasm&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它非常简短和易懂，但有几个要点需要强调：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它以“FROM scratch”开始，表示该镜像是从头开始构建的，不会继承任何操作系统环境&lt;/li&gt;
&lt;li&gt;我们将编译后的二进制文件复制到镜像中，在前一个示例中，我们复制了源文件并在构建镜像过程中对其进行了编译，这里我们使用已经编译好的（在主机上）wasm 二进制文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ENTRYPOINT&lt;/code&gt; 是二进制文件本身，这里没有指定运行时&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;构建我们的镜像，方式与我们为“通用”镜像所做的方式相同。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker build -t wasm-docker -f Dockerfile.wasm .
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;也许有人已经注意到了一个有趣的点：Docker 如何知道在 ENTRYPOINT 指向.wasm 二进制文件的镜像中使用 &lt;strong&gt;WasmEdge&lt;/strong&gt; 作为运行时？我们已经测试过，直接运行.wasm 文件不起作用。&lt;/p&gt;
&lt;p&gt;实际上没有，我们需要在启动容器时指定运行时。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run --runtime&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;io.containerd.wasmedge.v1 --platform&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;wasi/wasm32 b678ba11b941
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们指定 &lt;code&gt;--runtime&lt;/code&gt; 告诉 Docker 使用 WasmEdge 作为运行时，并指定 &lt;code&gt;--platform&lt;/code&gt; 使用 WASI 接口作为平台。就这样，如果您按照所有步骤操作，您应该看到一个令人兴奋的“Hello, world!”。&lt;/p&gt;
&lt;p&gt;当然，我是开玩笑的，比较镜像大小使用 &lt;code&gt;docker images&lt;/code&gt; 命令可以看到更有趣的结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;REPOSITORY                  TAG       IMAGE ID       CREATED         SIZE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hello-docker                latest    e9ed5014b408   &lt;span class=&#34;m&#34;&gt;7&lt;/span&gt; seconds ago   544MB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wasm-docker                 latest    b678ba11b941   &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; seconds ago   507kB
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;hello-docker&lt;/code&gt; 是我们在开始时构建的镜像，尺寸差异巨大。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在本文中，我们比较了标准 Docker 容器和 WASM 容器。标准 Docker 容器和 WebAssembly 容器都有各自独特的优点和限制，但 WASM 正在展示成为一种高度有前途的容器化技术，尤其是对于某些用例。与标准 Docker 容器相比，WebAssembly 提供了性能优势，例如更快的启动时间、更低的内存使用率以及代码和主机系统之间更好的隔离。此外，WebAssembly 是架构中立的，这意味着只要运行时可用，应用程序就可以在任何底层架构上运行。这提供了多种优势，例如在多个平台上运行相同的代码而无需重新编译，并能在以前不支持的平台上运行代码。甚至可以在诸如物联网、边缘计算等受限设备上扩展容器的使用。&lt;/p&gt;
&lt;p&gt;然而，值得注意的是，WebAssembly 仍处于早期阶段，尚不成熟，尚不具备广泛采用的条件。尽管如此，重要的是要关注这项技术，因为它有潜力彻底改变我们容器化应用程序的方式。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生架构师进阶指南</title>
      <link>https://cloudnativecn.com/blog/advanced-guide-for-cloudnative-architects/</link>
      <pubDate>Wed, 14 Dec 2022 15:00:00 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/advanced-guide-for-cloudnative-architects/</guid>
      <description>&lt;p&gt;伴随着云计算的浪潮，云原生的概念也应运而生，从 2015 年 CNCF 云原生基金会的成立，已经持续高速发展了 7 年时间。而 Kubernetes 作为云原生的代表就像是一个全新的云操作系统，围绕着它诞生了丰富的上层应用和生态。&lt;/p&gt;
&lt;p&gt;迄今为止，CNCF 在其公布的云原生全景图中，显示了目前近 30 个领域、数百个项目的繁荣发展，云原生技术的广度和深度得到了前所未有的发展。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-cncf-landscape&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/1.png&#34; alt=&#34;CNCF Landscape&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      CNCF Landscape
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;面对这庞杂的技术领域和技术工具，我们往往不知道要从哪儿下手开始学习。即便掌握了云原生核心技术 Docker 和 K8s，不过在工程实践中，这远远是不够的。&lt;/p&gt;
&lt;p&gt;那当我们有了云原生基础之后，&lt;strong&gt;想要进一步实现职业晋升，我建议你从下面的几个方面去学习：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-云原生架构师必须掌握的技能&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/2.jpeg&#34; alt=&#34;云原生架构师必须掌握的技能&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      云原生架构师必须掌握的技能
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;总结来说，你需要聚焦在下面几个领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器和镜像：Docker&lt;/li&gt;
&lt;li&gt;持续集成：GitHub Action、Jenkins、Tekton&lt;/li&gt;
&lt;li&gt;镜像仓库：Harbor&lt;/li&gt;
&lt;li&gt;应用定义：Helm、Kustomize&lt;/li&gt;
&lt;li&gt;持续部署：FluxCD、ArgoCD&lt;/li&gt;
&lt;li&gt;秘钥管理：Vault&lt;/li&gt;
&lt;li&gt;容器编排：K8s&lt;/li&gt;
&lt;li&gt;网关：Ingress-Nginx&lt;/li&gt;
&lt;li&gt;日志：Grafana Loki、Fluentd&lt;/li&gt;
&lt;li&gt;监控：Grafana&lt;/li&gt;
&lt;li&gt;告警：Prometheus&lt;/li&gt;
&lt;li&gt;应用开发：Nocalhost&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，这些领域的项目在云原生工程实践中并不是独立的，&lt;strong&gt;你需要掌握并把它们连接起来，才能将项目迁移到云原生架构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面对这么多的领域和技术，怎么学习它们才能更加高效呢？下面是根据我的学习经验总结的学习路径，你可以参考：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段：学习 Docker 和 K8s 的基础知识；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段：学习 CI/CD 领域的技术；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三阶段：学习日志、监控和告警领域的技术。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;三个学习阶段&#34;&gt;三个学习阶段&lt;/h2&gt;
&lt;h3 id=&#34;第一阶段&#34;&gt;第一阶段&lt;/h3&gt;
&lt;p&gt;在第一阶段，你需要学习 Docker 和 K8s 的基础知识。其中，Docker 相关的知识包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;镜像是什么，有什么作用？&lt;/li&gt;
&lt;li&gt;怎么将业务代码构建为镜像？&lt;/li&gt;
&lt;li&gt;如何选择合适的基础镜像？&lt;/li&gt;
&lt;li&gt;Docker 的其他基本操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在学习了 Docker 相关知识后，接下来就要开始学习 K8s 相关知识，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是 K8s 的工作负载？&lt;/li&gt;
&lt;li&gt;Service 的作用是什么？&lt;/li&gt;
&lt;li&gt;应用配置如何迁移？&lt;/li&gt;
&lt;li&gt;如何对外暴露服务？&lt;/li&gt;
&lt;li&gt;如何配置 HPA 扩缩容？&lt;/li&gt;
&lt;li&gt;Kubectl 的基本操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个阶段学习完成后，在工作中使用 Docker 和 K8s 基本上就没太大问题了。&lt;/p&gt;
&lt;h3 id=&#34;第二阶段&#34;&gt;第二阶段&lt;/h3&gt;
&lt;p&gt;当具备了 Docker 和 K8s 的基础知识后，接下来就需要学习 CI/CD 领域的技术了。其中，CI 领域包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何使用 Jenkins 自动构建镜像？&lt;/li&gt;
&lt;li&gt;如何使用 GitHub Action 自动构建镜像？&lt;/li&gt;
&lt;li&gt;如何自建 Tekton 构建镜像？&lt;/li&gt;
&lt;li&gt;如何使用 Tekton 搭建私有镜像仓库？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，再深入学习 CD 领域的技术，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何定义应用，Helm 还是 Kustomize？&lt;/li&gt;
&lt;li&gt;如何使用 ArgoCD 搭建 GitOps 工作流？&lt;/li&gt;
&lt;li&gt;如何管理 GitOps 中的秘钥&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到了这个阶段，也就具备在实际项目中搭建完整的 GitOps 工作流的能力了。&lt;/p&gt;
&lt;h3 id=&#34;第三阶段&#34;&gt;第三阶段&lt;/h3&gt;
&lt;p&gt;为了让分布式系统具有更好的可观测性，在第三阶段我们需要学习日志、监控和告警的知识，他们包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何使用 Loki 搭建轻量级的日志系统？&lt;/li&gt;
&lt;li&gt;如何使用 EFK 搭建日志系统？&lt;/li&gt;
&lt;li&gt;如何使用 Grafana 和 Prometheus 搭建监控系统？&lt;/li&gt;
&lt;li&gt;如何使用 Prometheus AlertManager 搭建告警系统？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到了第三个阶段，你已经基本上掌握完整的云原生知识体系了。&lt;/p&gt;
&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;p&gt;这种学习方式适合有一定基础并且动手能力强的同学，它们缺少体系化的学习过程，当需要将不同领域的工具进行连接时缺少可参考的最佳实践的案例。&lt;/p&gt;
&lt;h2 id=&#34;选择体系化的课程&#34;&gt;选择体系化的课程&lt;/h2&gt;
&lt;p&gt;还有一种可行的学习方法是选择一门体系化的课程，这里我推荐王炜的极客时间新专栏《云原生架构与 GitOps 实战》。你可以从零上手，一步一步入门云原生，一次学习云原生的所有知识点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-扫码报名&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/post.jpeg&#34; alt=&#34;扫码报名&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      扫码报名
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;也可以&lt;a href=&#34;https://time.geekbang.org/column/intro/100312001?code=PlMU9ITPlnun1QAjTGtDtNxkTtgSRZZzLJlQZHrEKtI%3D&amp;amp;utm_term=SPoster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击这里&lt;/a&gt;查看课程介绍&lt;/p&gt;
&lt;p&gt;这里也分享一张课程的学习路径，跟着这条路径，就可以高效地解决“怎么学”的问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-课程学习路径&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/3.jpg&#34; alt=&#34;课程学习路径&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      课程学习路径
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;课程目录&#34;&gt;课程目录&lt;/h3&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-课程目录&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/4.jpeg&#34; alt=&#34;课程目录&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      课程目录
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;关于王炜&#34;&gt;关于王炜&lt;/h3&gt;
&lt;p&gt;王炜，现在深圳氦三科技的联合创始人，他之前就职于腾讯云 CODING 担任架构师，也是&lt;strong&gt;中国云原生社区深圳站的负责人&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;出版了 &lt;strong&gt;《Spinnaker 实战：云原生多云环境的持续部署方案》&lt;/strong&gt;，参与编写了 &lt;strong&gt;《深入理解 Istio：云原生服务网格进阶实战》&lt;/strong&gt; 以及 &lt;strong&gt;《软件研发效能权威指南》&lt;/strong&gt; 的云原生开发部分。&lt;/p&gt;
&lt;p&gt;同时，他也是云原生开发工具 &lt;strong&gt;Nocalhost&lt;/strong&gt; 项目的核心作者。&lt;/p&gt;
&lt;h3 id=&#34;课程售价&#34;&gt;课程售价&lt;/h3&gt;
&lt;p&gt;课程原价 ¥129&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;今日早鸟 6 折秒杀，到手 ￥ 79！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你是新用户，只需要 ￥ 59！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;a href=&#34;https://time.geekbang.org/column/intro/100312001?code=PlMU9ITPlnun1QAjTGtDtNxkTtgSRZZzLJlQZHrEKtI%3D&amp;amp;utm_term=SPoster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;，立享 6 折，跟着王炜学习云原生架构与 GitOps。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生初学者入门必读</title>
      <link>https://cloudnativecn.com/blog/must-read-for-cloud-native-beginner/</link>
      <pubDate>Fri, 23 Oct 2020 14:18:40 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/must-read-for-cloud-native-beginner/</guid>
      <description>&lt;h2 id=&#34;为什么写这篇文章&#34;&gt;为什么写这篇文章&lt;/h2&gt;
&lt;p&gt;看到这个标题后，大家可能会问“都已经 2020 年了，Kubernetes 开源有 6 年时间了，为什么还要写一篇 Kubernetes 入门的文章？”我想说的是，Kubernetes 还远远没有达到我们想象的那么普及。众多的开发者，平时忙于各自的业务开发，学习新技术的时间有限；还有大量的学生群体，可能还仅仅停留在“知道有这门技术”的阶段，远远没有入门。这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。&lt;/p&gt;
&lt;p&gt;因为云原生的知识体系过于庞杂，本文主要讲解容器、Kubernetes 及服务网格的入门概念，关于云原生的更多细节将在后续文章中推出。另外大家也可以关注云原生社区推出的 &lt;a href=&#34;https://github.com/cloudnativeto/cloudnative-knowledge-map&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生知识图谱&lt;/a&gt; 项目，进一步了解云原生。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 一词来自希腊语，意思是“飞行员”或“舵手”。这个名字很贴切，Kubernetes 可以帮助你在波涛汹涌的容器海洋中航行。&lt;/p&gt;
&lt;p&gt;Kubernetes 是做什么的？什么是 Docker？什么是容器编排？Kubernetes 是如何工作和扩展的？你可能还有很多其他的问题，本文将一一为你解答。&lt;/p&gt;
&lt;p&gt;这篇文章适合初学者，尤其是那些工作忙碌，没有办法抽出太多时间来了解 Kubernetes 和云原生的开发者们，希望本文可以帮助你进入 Kubernetes 的世界。&lt;/p&gt;
&lt;p&gt;简而言之，Kubernetes 提供了一个平台或工具来帮助你快速协调或扩展容器化应用，特别是在 &lt;a href=&#34;https://docker.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker&lt;/a&gt; 容器。让我们深入了解一下这些概念。&lt;/p&gt;
&lt;h2 id=&#34;容器和容器化&#34;&gt;容器和容器化&lt;/h2&gt;
&lt;p&gt;那么什么是容器呢？&lt;/p&gt;
&lt;p&gt;要讨论容器化首先要谈到虚拟机 (VM)，顾名思义，虚拟机就是可以远程连接的虚拟服务器，比如 AWS 的 EC2 或阿里云的 ECS。&lt;/p&gt;
&lt;p&gt;接下来，假如你要在虚拟机上运行一个网络应用——包括一个 MySQL 数据库、一个 Vue 前端和一些 Java 库，在 Ubuntu 操作系统 (OS) 上运行。你不用熟悉其中的每一个技术——你只要记住，一个应用程序由各种组件、服务和库组成，它们运行在操作系统上。&lt;/p&gt;
&lt;p&gt;现在，将应用程序打包成一个虚拟机镜像，这个镜像中包括了 Ubuntu 操作系统。这使得虚拟机变得非常笨重——通常有几个 G 的大小。&lt;/p&gt;
&lt;p&gt;虚拟机镜像包含了整个操作系统及所有的库，对应用程序来说，这个镜像过于臃肿，其中大部分组件并没有被应用程序直接调用。如果你需要重新创建、备份或扩展这个应用程序，就需要复制整个环境（虚拟机镜像），在新环境中启动应用通常需要几十秒甚至几分钟时间。如果你想单独升级应用中的某个组件，比如说 Vue 应用，就需要重建整个虚拟机镜像。另外，如果你的两个应用依赖同一个底层镜像，升级底层镜像会同时影响这两个应用，而有时候，你只需要升级其中一个应用的依赖而已。这就是所谓的“依赖陷阱”。&lt;/p&gt;
&lt;p&gt;解决这个问题的办法就是容器。容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）。所以在上面的例子中，Ubuntu 操作系统就是一个单元（容器）。MySQL 数据库是另一个容器，Vue 环境和随之而来的库也是一个容器。&lt;/p&gt;
&lt;p&gt;但是，MySQL 数据库是如何自己“运行”的？数据库本身肯定也要在操作系统上运行吧？没错！&lt;/p&gt;
&lt;p&gt;更高层次的容器，比如 MySQL 容器，实际上会包含必要的库来与底层的操作系统容器通信和集成。所以你可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。&lt;/p&gt;
&lt;p&gt;与容器相关的一个重要概念是&lt;strong&gt;微服务&lt;/strong&gt;。将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。上面的例子中，我们会为 Vue 前端创建一个微服务，为 MySQL 数据库创建另一个微服务，为 Java 中间件部分创建另一个微服务，以此类推。很明显，微服务与容器化是相辅相成的。&lt;/p&gt;
&lt;h2 id=&#34;从-docker-开始&#34;&gt;从 Docker 开始&lt;/h2&gt;
&lt;p&gt;现在你已经对容器有一定了解了吧？Docker 是最常用的容器化工具，也是最流行的容器运行时。&lt;/p&gt;
&lt;p&gt;Docker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macOS 都支持 Docker。&lt;/p&gt;
&lt;p&gt;还有其他的容器化工具，如 &lt;a href=&#34;https://coreos.com/rkt/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CoreOS rkt&lt;/a&gt;、&lt;a href=&#34;http://mesos.apache.org/documentation/latest/mesos-containerizer/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mesos Containerizer&lt;/a&gt; 和 &lt;a href=&#34;https://linuxcontainers.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LXC&lt;/a&gt;。但是目前，绝大多数的容器化应用都是在 Docker 上运行的。&lt;/p&gt;
&lt;h2 id=&#34;再到-kubernetes&#34;&gt;再到 Kubernetes&lt;/h2&gt;
&lt;p&gt;首先，简单介绍一下历史。Kubernetes 是 Google 基于其内部容器调度平台 Borg 的经验开发的。2014 年开源，并作为 CNCF（云原生计算基金会）的核心发起项目。&lt;/p&gt;
&lt;p&gt;那么 Kubernetes 又跟容器是什么关系呢？让我们再回到上面的例子。假设我们的应用爆火，每天的注册用户越来越多。&lt;/p&gt;
&lt;p&gt;现在，我们需要增加后端资源，使浏览我们网站的用户在浏览页面时加载时间不会过长或者超时。最简单的方式就是增加容器的数量，然后使用负载均衡器将传入的负载（以用户请求的形式）分配给容器。&lt;/p&gt;
&lt;p&gt;这样做虽然行之有效，但也只能在用户规模有限的情况下使用。当用户请求达到几十万或几百万时，这种方法也是不可扩展的。你需要管理几十个也许是几百个负载均衡器，这本身就是另一个令人头疼的问题。如果我们想对网站或应用进行任何升级，也会遇到问题，因为负载均衡不会考虑到应用升级的问题。我们需要单独配置每个负载均衡器，然后升级该均衡器所服务的容器。想象一下，当你有 20 个负载均衡器和每周 5 或 6 个小的更新时，你将不得不进行大量的手工劳动。&lt;/p&gt;
&lt;p&gt;我们需要的是一种可以一次性将变更传递给所有受控容器的方法，同时也需要一种可以轻松地调度可用容器的方法，这个过程还必须要是自动化的，这正是 Kubernetes 所做的事情。&lt;/p&gt;
&lt;p&gt;接下来，我们将探讨 Kubernetes 究竟是如何工作的，它的各种组件和服务，以及更多关于如何使用 Kubernetes 来编排、管理和监控容器化环境。为了简单起见，假设我们使用的是 Docker 容器，尽管如前所述，Kubernetes 除了支持 Docker 之外，还支持其他几种容器平台。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-架构和组件&#34;&gt;Kubernetes 架构和组件&lt;/h2&gt;
&lt;p&gt;首先，最重要的是你需要认识到 Kubernetes 利用了“期望状态”原则。就是说，你定义了组件的期望状态，而 Kubernetes 要将它们始终调整到这个状态。&lt;/p&gt;
&lt;p&gt;例如，你想让你的 Web 服务器始终运行在 4 个容器中，以达到负载均衡的目的，你的数据库复制到 3 个不同的容器中，以达到冗余的目的。这就是你想要的状态。如果这 7 个容器中的任何一个出现故障，Kubernetes 引擎会检测到这一点，并自动创建出一个新的容器，以确保维持所需的状态。&lt;/p&gt;
&lt;p&gt;现在我们来定义一些 Kubernetes 的重要组件。&lt;/p&gt;
&lt;p&gt;当你第一次设置 Kubernetes 时，你会创建一个集群。所有其他组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间 (namespace)，它们是同一个物理集群的一部分。这与你可以在同一物理服务器上创建多个虚拟机的方式非常相似。如果你不需要，也没有明确定义的命名空间，那么你的集群将在始终存在的默认命名空间中创建。&lt;/p&gt;
&lt;p&gt;Kubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。&lt;/p&gt;
&lt;p&gt;主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。&lt;/p&gt;
&lt;p&gt;Master 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。&lt;/p&gt;
&lt;p&gt;Woker 节点是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的逻辑而非物理的工作单位称为 pod。一个 pod 类似于 Docker 中的容器。记得我们在前面讲到，容器可以让你创建独立、隔离的工作单元，可以独立运行。但是要创建复杂的应用程序，比如 Web 服务器，你经常需要结合多个容器，然后在一个 pod 中一起运行和管理。这就是 pod 的设计目的——一个 pod 允许你把多个容器，并指定它们如何组合在一起来创建应用程序。而这也进一步明确了 Docker 和 Kubernetes 之间的关系——一个 Kubernetes pod 通常包含一个或多个 Docker 容器，所有的容器都作为一个单元来管理。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的 service 是一组逻辑上的 pod。把一个 service 看成是一个 pod 的逻辑分组，它提供了一个单一的 IP 地址和 DNS 名称，你可以通过它访问服务内的所有 pod。有了服务，就可以非常容易地设置和管理负载均衡，当你需要扩展 Kubernetes pod 时，这对你有很大的帮助，我们很快就会看到。&lt;/p&gt;
&lt;p&gt;ReplicationController 或 ReplicaSet 是 Kubernetes 的另一个关键功能。它是负责实际管理 pod 生命周期的组件——当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubectl&#34;&gt;什么是 Kubectl？&lt;/h2&gt;
&lt;p&gt;kubectl 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-中的自动扩展&#34;&gt;Kubernetes 中的自动扩展&lt;/h2&gt;
&lt;p&gt;请记住，我们使用 Kubernetes 而不是直接使用 Docker 的原因之一，是因为 Kubernetes 能够自动扩展应用实例的数量以满足工作负载的需求。&lt;/p&gt;
&lt;p&gt;自动缩放是通过集群设置来实现的，当服务需求增加时，增加节点数量，当需求减少时，则减少节点数量。但也要记住，节点是“物理”结构——我们把“物理”放在引号里，因为要记住，很多时候，它们实际上是虚拟机。&lt;/p&gt;
&lt;p&gt;无论如何，节点是物理机器的事实意味着我们的云平台必须允许 Kubernetes 引擎创建新机器。各种云提供商对 Kubernetes 支持基本都满足这一点。&lt;/p&gt;
&lt;p&gt;我们再继续说一些概念，这次是和网络有关的。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubernetes-ingress-和-egress&#34;&gt;什么是 kubernetes Ingress 和 Egress？&lt;/h2&gt;
&lt;p&gt;外部用户或应用程序与 Kubernetes pod 交互，就像 pod 是一个真正的服务器一样。我们需要设置安全规则允许哪些流量可以进入和离开“服务器”，就像我们为托管应用程序的服务器定义安全规则一样。&lt;/p&gt;
&lt;p&gt;进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 egress。我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 / 流量的地方。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ingress-controller&#34;&gt;什么是 Ingress Controller？&lt;/h2&gt;
&lt;p&gt;但是在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。&lt;/p&gt;
&lt;h2 id=&#34;什么是-replica-和-replicaset&#34;&gt;什么是 Replica 和 ReplicaSet？&lt;/h2&gt;
&lt;p&gt;为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是“让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。&lt;/p&gt;
&lt;p&gt;所需状态是在 deployment 中定义的。Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。&lt;/p&gt;
&lt;p&gt;因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。&lt;/p&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://jimmysong.io/blog/what-is-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格 (Service Mesh)&lt;/a&gt; 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 &lt;a href=&#34;https://jimmysong.io/blog/post-kubernetes-era/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 次世代的云原生应用&lt;/a&gt; 的重要组成部分。&lt;/p&gt;
&lt;p&gt;服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）——就是 MySQL 数据库、Node.js 前端、负载均衡器等。&lt;/p&gt;
&lt;p&gt;所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更——这些变更对其他容器是完全透明的。&lt;/p&gt;
&lt;p&gt;如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。&lt;/p&gt;
&lt;p&gt;在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。关于服务网格的更多内容请参考 &lt;a href=&#34;https://www.servicemesher.com/istio-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Handbook——Istio 服务网格进阶实战&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在下一部分中，我们将展开更多关于 Kubernetes 的话题：如何开始学习 Kubernetes，如何在本地安装和测试 Kubernetes，以及 Kubernetes 的一些优秀的监控工具。&lt;/p&gt;
&lt;h2 id=&#34;如何学习-kubernetes&#34;&gt;如何学习 Kubernetes？&lt;/h2&gt;
&lt;p&gt;自学 Kubernetes 知识基本上有三种不同的途径，我们在这里只提供了一个指导大纲。&lt;/p&gt;
&lt;h3 id=&#34;一从零开始学习和安装-kubernetes&#34;&gt;一、从零开始学习和安装 Kubernetes&lt;/h3&gt;
&lt;p&gt;要想真正掌握 Kubernetes，最好的办法莫过于自己从头开始安装 Kubernetes。不过要注意的是，从零开始安装 Kubernetes 并不是一件容易的事情。安装 Kubernetes 并不是简单的“下载文件 -&amp;gt; 点击安装”式的操作，Kubernetes 由多个组件组成，这些组件必须单独安装和配置。而在此之前，你也需要相当的技术储备来做安装前的准备，比如熟悉 Linux 操作系统。如果你决定使用这种方式学习的话，推荐你阅读 &lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。此外，请记住，尽管 Kubernetes 作为一个开源解决方案在技术上是免费的，但它确实有一些隐藏的成本，只不过对初学者来说可能并不明显。&lt;/p&gt;
&lt;h3 id=&#34;二kubernetes-自托管解决方案&#34;&gt;二、Kubernetes 自托管解决方案&lt;/h3&gt;
&lt;p&gt;这些解决方案样是一些工具和实用程序，大大简化了在本地计算机上安装和配置小型 Kubernetes 集群的任务。它们是学习 Kubernetes 的好方法，同时对于新手来说也不会太难，又足够小巧可以到安装在个人电脑上。最流行的自托管 Kubernetes 工具和环境是 &lt;a href=&#34;https://github.com/kubernetes/minikube&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Minikube&lt;/a&gt;、&lt;a href=&#34;https://github.com/ubuntu/microk8s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MicroK8s&lt;/a&gt;、&lt;a href=&#34;https://docs.docker.com/docker-for-windows/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Desktop&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/kubernetes-sigs/kind&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kind&lt;/a&gt;。这些解决方案往往有一些限制，例如，Minikube 只允许创建一个节点。尽管有这些缺点，但这些工具还是非常值得推荐，因为它们将易学性和成本效益结合起来，对于刚开始使用 Kubernetes 的初学者来说，是一个很好的选择。&lt;/p&gt;
&lt;h3 id=&#34;三云托管的解决方案&#34;&gt;三、云托管的解决方案&lt;/h3&gt;
&lt;p&gt;如今各大云供应商都提供了定制化的 Kubernetes 解决方案来。你也可以通过线上教学平台如 &lt;a href=&#34;https://katacoda.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Katacoda&lt;/a&gt; 上的免费课程来学习 Kubernetes，它们都是云托管的，你不需要自己安装，只不过你需要云供应商的集群需要付费。&lt;/p&gt;
&lt;h2 id=&#34;本地测试和调试-kubernetes&#34;&gt;本地测试和调试 Kubernetes&lt;/h2&gt;
&lt;p&gt;作为本地安装 Kubernetes 的一部分，你很可能还需要一些测试和调试能力，以确保一切都在顺利运行，特别是定义入口和出口策略等棘手的任务。此外，还有 Kubernetes 附加组件的生态系统，你可能想使用这些组件来扩展 Kubernetes 集群的功能。添加所有这些都需要进行更多的测试，以确保它们能与你的 Kubernetes 集群完美的集成。&lt;/p&gt;
&lt;p&gt;用于在本地开发和调试 Kubernetes 服务的工具有：&lt;a href=&#34;https://github.com/microsoft/mindaro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microsoft Bridge to Kubernetes&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/telepresenceio/telepresence&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;telepresence&lt;/a&gt;。这些工具可以让你在本地运行单个服务，同时将该服务连接到远程 Kubernetes 集群。这样你就可以让自己的本地机器作为 Kubernetes 集群中的一部分来运行——这对于在本地而不是在生产集群上开发服务非常有用。&lt;/p&gt;
&lt;p&gt;Kubernetes 项目也了解到了 Kubernetes 安装对端到端 (E2E) 测试的需求。为此，项目核心团队一直在确保在最近的版本中更恰当地支持 E2E 测试。这包括诸如允许测试重用和纳入更多附加组件和驱动程序的测试等。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-监控工具&#34;&gt;Kubernetes 监控工具&lt;/h2&gt;
&lt;p&gt;Kubernetes 提供了应用程序在集群的每个层次上的资源使用情况的详细信息——容器、pod、服务。这些详细信息使你能够评估应用程序的性能，确定哪些瓶颈可以解决以提高整体性能。&lt;/p&gt;
&lt;p&gt;毕竟，监控可以帮助你了解应用和集群运行情况的详细信息，这对于学习 Kubernetes 是十分有帮助的。&lt;/p&gt;
&lt;p&gt;Kubernetes 包含两个内置度量收集工具用于监控：&lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;资源管道和全度量管道&lt;/a&gt;。资源管道是一个较低级和较有限的工具，主要集中在与各种控制器相关的指标上。全指标管道，顾名思义，从几乎所有集群组件中获取并显示更丰富的指标。&lt;/p&gt;
&lt;p&gt;还有一些第三方工具可以安装并集成到 Kubernetes 集群中。对于 Kubernetes 来说，最普遍使用的两个工具是 Prometheus 和 Grafana。&lt;/p&gt;
&lt;h3 id=&#34;prometheus-监控&#34;&gt;Prometheus 监控&lt;/h3&gt;
&lt;p&gt;Prometheus 是一个功能丰富的开源监控和警报工具。Prometheus 包含一个内部数据存储用来收集指标，如生成的时间序列数据。Prometheus 还拥有众多插件，允许它将数据暴露给各种外部解决方案，并从其他数据源导入数据，包括所有主要公有云监控解决方案。&lt;/p&gt;
&lt;h3 id=&#34;grafana-仪表盘&#34;&gt;Grafana 仪表盘&lt;/h3&gt;
&lt;p&gt;Grafana 是一个优秀的仪表盘、分析和数据可视化工具。它没有 Prometheus 的全功能数据收集能力，但 Prometheus 又没有 Grafana 的数据呈现界面。事实上，他们最好是结合在一起使用——Prometheus 负责数据收集和汇总，Grafana 负责数据展示。它们共同创造了一个强大的组合，涵盖了数据收集、基本警报和可视化。&lt;/p&gt;
&lt;h3 id=&#34;高级警报&#34;&gt;高级警报&lt;/h3&gt;
&lt;p&gt;对于高级警报，你可以添加 &lt;a href=&#34;https://www.nagios.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nagios&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/prometheus/alertmanager&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus Alertmanager&lt;/a&gt; 等工具。这些警报工具通常有大量的集成。你可以为自定义值班团队，然后定义你想要监控的参数，例如“当任何 pod 不可用时”或“当任何节点无法访问时”、“当容量达到 90%”等，然后通过电子邮件、短信、手机应用提醒、电话呼叫等方式向值班人员发送自定义通知。你还可以创建升级策略，比如，如果一个被定义为“危急”的警报在 10 分钟内没有值班人员确认，那么就将警报升级（发送警报）到该人员的经理。&lt;/p&gt;
&lt;p&gt;现在，你应该已经对 Docker 和 Kubernetes 有了大体的认识。了解了 Kubernetes 的作用，知道它是如何进行容器化应用部署和管理的。&lt;/p&gt;
&lt;p&gt;调试和监控技术不仅仅是运维需要，你也可以把它当作学习方式。有什么比边做边学更好呢？&lt;/p&gt;
&lt;p&gt;请记住，如果你的应用规模太小，而且预计用户需求不会有太大变化或重大波动（比如一个只在公司内部使用的应用），那么 Kubernetes 对你来说可能没有必要，这种情况下，直接使用 Docker 就足够了。&lt;/p&gt;
&lt;h2 id=&#34;更多&#34;&gt;更多&lt;/h2&gt;
&lt;p&gt;云原生领域的开源项目众多（见 &lt;a href=&#34;https://jimmysong.io/awesome-cloud-native&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Awesome Cloud Native/云原生开源项目大全&lt;/a&gt;），其中有大量的优秀项目可供我们学习。此外，Kubernetes 开源已经多年时间，网上有大量的学习资料，业界出版过很多 &lt;a href=&#34;https://jimmysong.io/cloud-native/note/books/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;书籍&lt;/a&gt;，建议大家通过阅读 &lt;a href=&#34;https://kubernetes.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt; 和实践来学习，也可以参考我编写的 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;推荐大家加入我发起创办的 &lt;a href=&#34;https://cloudnative.to&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区&lt;/a&gt;，这是一个立足中国，放眼世界的云原生终端用户社区，致力于云原生技术的传播和应用。云原生社区主办的 &lt;a href=&#34;https://github.com/cloudnativeto/academy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生学院&lt;/a&gt; 定期邀请云原生和开源领域的大咖在 B 站上进行直播分享，成员自发组织了多个 SIG（特别兴趣小组）进行讨论学习。欢迎加入我们，共同学习和交流云原生技术。如果你想从事服务网格领域，加入一家由开源技术而构建的全球化公司，欢迎大家关注我所在的服务网格公司 &lt;a href=&#34;https://mp.weixin.qq.com/s/_da1ZgA9-wnT5t_bFuw6AQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么要选择 Service Mesh？</title>
      <link>https://cloudnativecn.com/blog/why-is-service-mesh/</link>
      <pubDate>Thu, 08 Nov 2018 15:20:46 +0800</pubDate>
      <guid>https://cloudnativecn.com/blog/why-is-service-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/@tak2siva/why-is-service-mesh-8ebcd6ed9eb5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;除非你长期与世隔绝，否则你应该听说过 Kubernetes，他已经称为高速发展的互联网公司的一条准则。最近又有一个热门话题&amp;ndash;Service Mesh（服务网格），它已经被这些高速发展公司用来解决一些特定的问题。所以如果你想了解什么是 Service Mesh，接下来我可以给你一个更好的解释。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0r3hzbzlj20zk0ilnmj_hu_fdfae543529586c7.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0r3hzbzlj20zk0ilnmj_hu_ce6e3d59bb2bc9cc.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0r3hzbzlj20zk0ilnmj_hu_cd74eebf59201772.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/why-is-service-mesh/7267315bgy1fx0r3hzbzlj20zk0ilnmj_hu_fdfae543529586c7.webp&#34;
               width=&#34;690&#34;
               height=&#34;361&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;互联网应用的演进&#34;&gt;互联网应用的演进&lt;/h2&gt;
&lt;p&gt;为了理解 Sevice Mesh 的重要性，我们通过四个阶段来简短的回顾下互联网应用的发展历程。&lt;/p&gt;
&lt;h3 id=&#34;阶段-0单体应用&#34;&gt;阶段 0：单体应用&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0r9265r7j208s06omxs_hu_f6e00b79e14d43e1.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0r9265r7j208s06omxs_hu_e54c60e791edb644.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0r9265r7j208s06omxs_hu_2377de4e20a7883b.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/why-is-service-mesh/7267315bgy1fx0r9265r7j208s06omxs_hu_f6e00b79e14d43e1.webp&#34;
               width=&#34;316&#34;
               height=&#34;240&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;还记得那些年吗？所有的代码库都打包成一个可执行和部署的软件包。当然，至今在某些使用场景下这个方式依然是很管用的。但是对于一些业务快速增长的互联网公司，在应用的可扩展性、快速部署和所有权等方面遇到了阻力。&lt;/p&gt;
&lt;h3 id=&#34;阶段-1微服务&#34;&gt;阶段 1：微服务&lt;/h3&gt;
&lt;p&gt;微服务的思思想很简单，依照 SLA（服务等级协议）将单体应用拆分成多个模块。这种方式运行效果显著，所以广泛为企业所接受。现在，每个团队都用他们喜爱的语言、框架等自由地设计他们的微服务。然后它开始看起来就像下面这样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0si4ef85j218g0n4tde_hu_c85e1bbac4cdefde.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0si4ef85j218g0n4tde_hu_d96fda889a400143.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0si4ef85j218g0n4tde_hu_b99f723c569cb820.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/why-is-service-mesh/7267315bgy1fx0si4ef85j218g0n4tde_hu_c85e1bbac4cdefde.webp&#34;
               width=&#34;690&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们曾经在我的一个项目中开玩笑说，那里有各种语言的微服务:)&lt;/p&gt;
&lt;p&gt;尽管微服务解决了单体应用的一些问题，但现在公司有一些严重问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为每个微服务定义 VM（虚拟机）规范&lt;/li&gt;
&lt;li&gt;维护系统级别依赖操作系统版本、自动化工具（如 chef）等&lt;/li&gt;
&lt;li&gt;监控每个服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对负责构建和部署的人来说这就是一个噩梦。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0vg3ks7aj20dc07iq53_hu_e65032ffc8d43816.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0vg3ks7aj20dc07iq53_hu_17cfc93214141335.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0vg3ks7aj20dc07iq53_hu_b5456a377ca4e7e5.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/why-is-service-mesh/7267315bgy1fx0vg3ks7aj20dc07iq53_hu_e65032ffc8d43816.webp&#34;
               width=&#34;480&#34;
               height=&#34;270&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而且这些服务在虚拟机中共享同一个 OS，但为了达到可移植性，服务之间需要隔离或者被封装到独立的 VM 镜像。微服务典型的架构设计如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0vt7d9woj218g0n4tc3_hu_3eddf934058c05f4.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0vt7d9woj218g0n4tc3_hu_7df5aeab2f0e406d.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0vt7d9woj218g0n4tc3_hu_f7aea0a3ba89f947.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/why-is-service-mesh/7267315bgy1fx0vt7d9woj218g0n4tc3_hu_3eddf934058c05f4.webp&#34;
               width=&#34;690&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但为每个服务/副本安装在一台独立的虚拟机上，花费是非常高的。&lt;/p&gt;
&lt;h3 id=&#34;阶段-2容器化&#34;&gt;阶段 2：容器化&lt;/h3&gt;
&lt;p&gt;容器是利用 Linux 中的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Cgroups&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cgroups&lt;/a&gt; 和 &lt;a href=&#34;https://en.wikipedia.org/wiki/Linux_namespaces&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;namespace&lt;/a&gt; 的一种新的操作系统级别的虚拟化技术，通过共享主机的操作系统，实现为不同的应用隔离运行环境的。Docker 是目前最流行的容器运行时。&lt;/p&gt;
&lt;p&gt;所以我们会为每个微服务创建一个容器镜像并以容器形式发布成服务。这样不仅可以在一个操作系统上实现应用运行环境的隔离，而且启动新的容器相比于启动新的 VM 速度更快、成本也更低！使用容器技术之后的微服务设计看起来就像这样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0wzyguoej218g0n4ju8_hu_1b6b2bc3d41d03f8.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0wzyguoej218g0n4ju8_hu_27c70f4994ab1c3.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0wzyguoej218g0n4ju8_hu_1b637634b2c51ea1.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/why-is-service-mesh/7267315bgy1fx0wzyguoej218g0n4ju8_hu_1b6b2bc3d41d03f8.webp&#34;
               width=&#34;690&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;容器化解决了构建和部署的问题，但还没有完美的监控解决方案！那要怎么办？我们还有其他问题吗？管理容器！&lt;/p&gt;
&lt;p&gt;使用容器运行一个可靠的基础设施层需要注意以下几个重要的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器的可用性&lt;/li&gt;
&lt;li&gt;生成容器&lt;/li&gt;
&lt;li&gt;扩容/缩容&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;调度容器到多个主机&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;阶段-3容器编排&#34;&gt;阶段 3：容器编排&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx1kwi5nvpj205t05o74e_hu_f25e000fb2595a21.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx1kwi5nvpj205t05o74e_hu_6497bedacc666291.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx1kwi5nvpj205t05o74e_hu_c192a52d10f6c73b.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/why-is-service-mesh/7267315bgy1fx1kwi5nvpj205t05o74e_hu_f25e000fb2595a21.webp&#34;
               width=&#34;209&#34;
               height=&#34;204&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes 是当下最流行的容器编排工具，它彻底改变了我们对基础设施的看法。Kubernetes 侧重于健康检查，可用性，负载均衡，服务发现，扩展性，跨主机调度容器等等，很神奇！&lt;/p&gt;
&lt;p&gt;我们要的就是这样吗？&lt;/p&gt;
&lt;p&gt;并不完全是，仅仅这样还不能解决在微服务阶段提到的服务监控/观测的问题。这只是冰山一角。微服务是分布式的，所以管理微服务不是件容易的事。&lt;/p&gt;
&lt;p&gt;我们需要考虑一些最佳实践来便捷地运行微服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Metrics（延迟，成功率等）&lt;/li&gt;
&lt;li&gt;分布式链路追踪&lt;/li&gt;
&lt;li&gt;客户端负载均衡&lt;/li&gt;
&lt;li&gt;熔断&lt;/li&gt;
&lt;li&gt;流量迁移&lt;/li&gt;
&lt;li&gt;限速&lt;/li&gt;
&lt;li&gt;访问日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;像 Netflix 这样的公司已经推出了几种工具，并接受了那些运行微服务的做法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netflix Spectator（Metrics）&lt;/li&gt;
&lt;li&gt;Netflix Ribbon（客户端负载均衡/服务发现）&lt;/li&gt;
&lt;li&gt;Netflix Hystrix（熔断器）&lt;/li&gt;
&lt;li&gt;Netflix Zuul（边界路由）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，为了满足这些最佳实践的唯一方法是在每个微服务上使用一个客户端库来解决每个问题。所以每个服务的结构看起来就像这样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx1ojjkrfuj212g0fymz5_hu_d7d5ca5020a2f3b9.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx1ojjkrfuj212g0fymz5_hu_c3be44dc0a453df1.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx1ojjkrfuj212g0fymz5_hu_eee7ba33d23e573.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/why-is-service-mesh/7267315bgy1fx1ojjkrfuj212g0fymz5_hu_d7d5ca5020a2f3b9.webp&#34;
               width=&#34;690&#34;
               height=&#34;286&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但这是针对像 Service A 这样的用 JAVA 写的服务，那其他的服务要怎么办？
如果我使用其他语言没有类似 java 的库要怎么办？
怎样才能让所有团队使用/维护/升级库版本？
我们公司有上百个服务，我要修改所有应用都使用上面的库吗？&lt;/p&gt;
&lt;p&gt;发现了吗？自微服务诞生以来，这些一直都是个问题（语言限制、应用代码改造）。&lt;/p&gt;
&lt;h3 id=&#34;阶段-4服务网格&#34;&gt;阶段 4：服务网格&lt;/h3&gt;
&lt;p&gt;目前有多种代理为 Service Mesh 提供解决方案，如：&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;、Linkerd 和 Nginx。本文只关注 Envoy 的 Service Mesh。&lt;/p&gt;
&lt;p&gt;Envoy 是针对微服务产生的这些问题设计出来的服务代理。&lt;/p&gt;
&lt;p&gt;Envoy 能够作为 &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SideCar&lt;/a&gt; 运行在每个应用的旁边，形成抽象的应用网络。当基础设施中的所有服务流量通过 Envoy 网格流动时，通过一致的可观察性来问题区域变得容易。&lt;/p&gt;
&lt;p&gt;如下图所示，当把 Envoy 作为 SideCar 添加到服务后，所有微服务的入站和出站流量都通过各自的 Envoy 代理&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx1t3tisq1j218g0n4q5x_hu_e855539fcf612a1d.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx1t3tisq1j218g0n4q5x_hu_c1251f47e1eafdb.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx1t3tisq1j218g0n4q5x_hu_7de9816412fac1db.webp 1200w&#34;
               src=&#34;https://cloudnativecn.com/blog/why-is-service-mesh/7267315bgy1fx1t3tisq1j218g0n4q5x_hu_e855539fcf612a1d.webp&#34;
               width=&#34;690&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Envoy 拥有许多方便的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持 HTTP,HTTP/2 和 gRPC&lt;/li&gt;
&lt;li&gt;健康检查&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;Metrics&lt;/li&gt;
&lt;li&gt;追踪&lt;/li&gt;
&lt;li&gt;访问日志&lt;/li&gt;
&lt;li&gt;熔断&lt;/li&gt;
&lt;li&gt;重试策略&lt;/li&gt;
&lt;li&gt;超时配置&lt;/li&gt;
&lt;li&gt;限速&lt;/li&gt;
&lt;li&gt;支持 Statsd、Prometheus&lt;/li&gt;
&lt;li&gt;流量迁移&lt;/li&gt;
&lt;li&gt;通过发现服务来动态调整配置（XDS）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等……&lt;/p&gt;
&lt;p&gt;所以通过从服务中抽象出整个网络，使用 Envoy 作为 SideCar 形成网格组成数据平面，允许我们控制上面列出的能力。&lt;/p&gt;
&lt;p&gt;欢迎反馈，谢谢！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
