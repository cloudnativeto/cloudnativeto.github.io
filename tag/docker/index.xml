<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker | 云原生社区（中国）</title>
    <link>https://cloudnative.to/tag/docker/</link>
      <atom:link href="https://cloudnative.to/tag/docker/index.xml" rel="self" type="application/rss+xml" />
    <description>Docker</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Wed, 14 Dec 2022 15:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>Docker</title>
      <link>https://cloudnative.to/tag/docker/</link>
    </image>
    
    <item>
      <title>云原生架构师进阶指南</title>
      <link>https://cloudnative.to/blog/advanced-guide-for-cloudnative-architects/</link>
      <pubDate>Wed, 14 Dec 2022 15:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/advanced-guide-for-cloudnative-architects/</guid>
      <description>&lt;p&gt;伴随着云计算的浪潮，云原生的概念也应运而生，从 2015 年 CNCF 云原生基金会的成立，已经持续高速发展了 7 年时间。而 Kubernetes 作为云原生的代表就像是一个全新的云操作系统，围绕着它诞生了丰富的上层应用和生态。&lt;/p&gt;
&lt;p&gt;迄今为止，CNCF 在其公布的云原生全景图中，显示了目前近 30 个领域、数百个项目的繁荣发展，云原生技术的广度和深度得到了前所未有的发展。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-cncf-landscape&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/1.png&#34; alt=&#34;CNCF Landscape&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      CNCF Landscape
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;面对这庞杂的技术领域和技术工具，我们往往不知道要从哪儿下手开始学习。即便掌握了云原生核心技术 Docker 和 K8s，不过在工程实践中，这远远是不够的。&lt;/p&gt;
&lt;p&gt;那当我们有了云原生基础之后，&lt;strong&gt;想要进一步实现职业晋升，我建议你从下面的几个方面去学习：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-云原生架构师必须掌握的技能&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/2.jpeg&#34; alt=&#34;云原生架构师必须掌握的技能&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      云原生架构师必须掌握的技能
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;总结来说，你需要聚焦在下面几个领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器和镜像：Docker&lt;/li&gt;
&lt;li&gt;持续集成：GitHub Action、Jenkins、Tekton&lt;/li&gt;
&lt;li&gt;镜像仓库：Harbor&lt;/li&gt;
&lt;li&gt;应用定义：Helm、Kustomize&lt;/li&gt;
&lt;li&gt;持续部署：FluxCD、ArgoCD&lt;/li&gt;
&lt;li&gt;秘钥管理：Vault&lt;/li&gt;
&lt;li&gt;容器编排：K8s&lt;/li&gt;
&lt;li&gt;网关：Ingress-Nginx&lt;/li&gt;
&lt;li&gt;日志：Grafana Loki、Fluentd&lt;/li&gt;
&lt;li&gt;监控：Grafana&lt;/li&gt;
&lt;li&gt;告警：Prometheus&lt;/li&gt;
&lt;li&gt;应用开发：Nocalhost&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，这些领域的项目在云原生工程实践中并不是独立的，&lt;strong&gt;你需要掌握并把它们连接起来，才能将项目迁移到云原生架构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面对这么多的领域和技术，怎么学习它们才能更加高效呢？下面是根据我的学习经验总结的学习路径，你可以参考：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段：学习 Docker 和 K8s 的基础知识；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段：学习 CI/CD 领域的技术；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三阶段：学习日志、监控和告警领域的技术。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;三个学习阶段&#34;&gt;三个学习阶段&lt;/h2&gt;
&lt;h3 id=&#34;第一阶段&#34;&gt;第一阶段&lt;/h3&gt;
&lt;p&gt;在第一阶段，你需要学习 Docker 和 K8s 的基础知识。其中，Docker 相关的知识包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;镜像是什么，有什么作用？&lt;/li&gt;
&lt;li&gt;怎么将业务代码构建为镜像？&lt;/li&gt;
&lt;li&gt;如何选择合适的基础镜像？&lt;/li&gt;
&lt;li&gt;Docker 的其他基本操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在学习了 Docker 相关知识后，接下来就要开始学习 K8s 相关知识，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是 K8s 的工作负载？&lt;/li&gt;
&lt;li&gt;Service 的作用是什么？&lt;/li&gt;
&lt;li&gt;应用配置如何迁移？&lt;/li&gt;
&lt;li&gt;如何对外暴露服务？&lt;/li&gt;
&lt;li&gt;如何配置 HPA 扩缩容？&lt;/li&gt;
&lt;li&gt;Kubectl 的基本操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个阶段学习完成后，在工作中使用 Docker 和 K8s 基本上就没太大问题了。&lt;/p&gt;
&lt;h3 id=&#34;第二阶段&#34;&gt;第二阶段&lt;/h3&gt;
&lt;p&gt;当具备了 Docker 和 K8s 的基础知识后，接下来就需要学习 CI/CD 领域的技术了。其中，CI 领域包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何使用 Jenkins 自动构建镜像？&lt;/li&gt;
&lt;li&gt;如何使用 GitHub Action 自动构建镜像？&lt;/li&gt;
&lt;li&gt;如何自建 Tekton 构建镜像？&lt;/li&gt;
&lt;li&gt;如何使用 Tekton 搭建私有镜像仓库？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，再深入学习 CD 领域的技术，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何定义应用，Helm 还是 Kustomize？&lt;/li&gt;
&lt;li&gt;如何使用 ArgoCD 搭建 GitOps 工作流？&lt;/li&gt;
&lt;li&gt;如何管理 GitOps 中的秘钥&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到了这个阶段，也就具备在实际项目中搭建完整的 GitOps 工作流的能力了。&lt;/p&gt;
&lt;h3 id=&#34;第三阶段&#34;&gt;第三阶段&lt;/h3&gt;
&lt;p&gt;为了让分布式系统具有更好的可观测性，在第三阶段我们需要学习日志、监控和告警的知识，他们包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何使用 Loki 搭建轻量级的日志系统？&lt;/li&gt;
&lt;li&gt;如何使用 EFK 搭建日志系统？&lt;/li&gt;
&lt;li&gt;如何使用 Grafana 和 Prometheus 搭建监控系统？&lt;/li&gt;
&lt;li&gt;如何使用 Prometheus AlertManager 搭建告警系统？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到了第三个阶段，你已经基本上掌握完整的云原生知识体系了。&lt;/p&gt;
&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;p&gt;这种学习方式适合有一定基础并且动手能力强的同学，它们缺少体系化的学习过程，当需要将不同领域的工具进行连接时缺少可参考的最佳实践的案例。&lt;/p&gt;
&lt;h2 id=&#34;选择体系化的课程&#34;&gt;选择体系化的课程&lt;/h2&gt;
&lt;p&gt;还有一种可行的学习方法是选择一门体系化的课程，这里我推荐王炜的极客时间新专栏《云原生架构与 GitOps 实战》。你可以从零上手，一步一步入门云原生，一次学习云原生的所有知识点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-扫码报名&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/post.jpeg&#34; alt=&#34;扫码报名&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      扫码报名
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;也可以&lt;a href=&#34;https://time.geekbang.org/column/intro/100312001?code=PlMU9ITPlnun1QAjTGtDtNxkTtgSRZZzLJlQZHrEKtI%3D&amp;amp;utm_term=SPoster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击这里&lt;/a&gt;查看课程介绍&lt;/p&gt;
&lt;p&gt;这里也分享一张课程的学习路径，跟着这条路径，就可以高效地解决“怎么学”的问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-课程学习路径&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/3.jpg&#34; alt=&#34;课程学习路径&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      课程学习路径
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;课程目录&#34;&gt;课程目录&lt;/h3&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-课程目录&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./images/4.jpeg&#34; alt=&#34;课程目录&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      课程目录
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;关于王炜&#34;&gt;关于王炜&lt;/h3&gt;
&lt;p&gt;王炜，现在深圳氦三科技的联合创始人，他之前就职于腾讯云 CODING 担任架构师，也是&lt;strong&gt;中国云原生社区深圳站的负责人&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;出版了 &lt;strong&gt;《Spinnaker 实战：云原生多云环境的持续部署方案》&lt;/strong&gt;，参与编写了 &lt;strong&gt;《深入理解 Istio：云原生服务网格进阶实战》&lt;/strong&gt; 以及 &lt;strong&gt;《软件研发效能权威指南》&lt;/strong&gt; 的云原生开发部分。&lt;/p&gt;
&lt;p&gt;同时，他也是云原生开发工具 &lt;strong&gt;Nocalhost&lt;/strong&gt; 项目的核心作者。&lt;/p&gt;
&lt;h3 id=&#34;课程售价&#34;&gt;课程售价&lt;/h3&gt;
&lt;p&gt;课程原价 ¥129&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;今日早鸟 6 折秒杀，到手 ￥ 79！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你是新用户，只需要 ￥ 59！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;a href=&#34;https://time.geekbang.org/column/intro/100312001?code=PlMU9ITPlnun1QAjTGtDtNxkTtgSRZZzLJlQZHrEKtI%3D&amp;amp;utm_term=SPoster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;，立享 6 折，跟着王炜学习云原生架构与 GitOps。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生初学者入门必读</title>
      <link>https://cloudnative.to/blog/must-read-for-cloud-native-beginner/</link>
      <pubDate>Fri, 23 Oct 2020 14:18:40 +0800</pubDate>
      <guid>https://cloudnative.to/blog/must-read-for-cloud-native-beginner/</guid>
      <description>&lt;h2 id=&#34;为什么写这篇文章&#34;&gt;为什么写这篇文章&lt;/h2&gt;
&lt;p&gt;看到这个标题后，大家可能会问“都已经 2020 年了，Kubernetes 开源有 6 年时间了，为什么还要写一篇 Kubernetes 入门的文章？”我想说的是，Kubernetes 还远远没有达到我们想象的那么普及。众多的开发者，平时忙于各自的业务开发，学习新技术的时间有限；还有大量的学生群体，可能还仅仅停留在“知道有这门技术”的阶段，远远没有入门。这篇文章将助于各位有志于从事云原生领域工作或需要了解该领域背景的人群快速入门 Kubernetes 和云原生。&lt;/p&gt;
&lt;p&gt;因为云原生的知识体系过于庞杂，本文主要讲解容器、Kubernetes 及服务网格的入门概念，关于云原生的更多细节将在后续文章中推出。另外大家也可以关注云原生社区推出的 &lt;a href=&#34;https://github.com/cloudnativeto/cloudnative-knowledge-map&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生知识图谱&lt;/a&gt; 项目，进一步了解云原生。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 一词来自希腊语，意思是“飞行员”或“舵手”。这个名字很贴切，Kubernetes 可以帮助你在波涛汹涌的容器海洋中航行。&lt;/p&gt;
&lt;p&gt;Kubernetes 是做什么的？什么是 Docker？什么是容器编排？Kubernetes 是如何工作和扩展的？你可能还有很多其他的问题，本文将一一为你解答。&lt;/p&gt;
&lt;p&gt;这篇文章适合初学者，尤其是那些工作忙碌，没有办法抽出太多时间来了解 Kubernetes 和云原生的开发者们，希望本文可以帮助你进入 Kubernetes 的世界。&lt;/p&gt;
&lt;p&gt;简而言之，Kubernetes 提供了一个平台或工具来帮助你快速协调或扩展容器化应用，特别是在 &lt;a href=&#34;https://docker.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker&lt;/a&gt; 容器。让我们深入了解一下这些概念。&lt;/p&gt;
&lt;h2 id=&#34;容器和容器化&#34;&gt;容器和容器化&lt;/h2&gt;
&lt;p&gt;那么什么是容器呢？&lt;/p&gt;
&lt;p&gt;要讨论容器化首先要谈到虚拟机 (VM)，顾名思义，虚拟机就是可以远程连接的虚拟服务器，比如 AWS 的 EC2 或阿里云的 ECS。&lt;/p&gt;
&lt;p&gt;接下来，假如你要在虚拟机上运行一个网络应用——包括一个 MySQL 数据库、一个 Vue 前端和一些 Java 库，在 Ubuntu 操作系统 (OS) 上运行。你不用熟悉其中的每一个技术——你只要记住，一个应用程序由各种组件、服务和库组成，它们运行在操作系统上。&lt;/p&gt;
&lt;p&gt;现在，将应用程序打包成一个虚拟机镜像，这个镜像中包括了 Ubuntu 操作系统。这使得虚拟机变得非常笨重——通常有几个 G 的大小。&lt;/p&gt;
&lt;p&gt;虚拟机镜像包含了整个操作系统及所有的库，对应用程序来说，这个镜像过于臃肿，其中大部分组件并没有被应用程序直接调用。如果你需要重新创建、备份或扩展这个应用程序，就需要复制整个环境（虚拟机镜像），在新环境中启动应用通常需要几十秒甚至几分钟时间。如果你想单独升级应用中的某个组件，比如说 Vue 应用，就需要重建整个虚拟机镜像。另外，如果你的两个应用依赖同一个底层镜像，升级底层镜像会同时影响这两个应用，而有时候，你只需要升级其中一个应用的依赖而已。这就是所谓的“依赖陷阱”。&lt;/p&gt;
&lt;p&gt;解决这个问题的办法就是容器。容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）。所以在上面的例子中，Ubuntu 操作系统就是一个单元（容器）。MySQL 数据库是另一个容器，Vue 环境和随之而来的库也是一个容器。&lt;/p&gt;
&lt;p&gt;但是，MySQL 数据库是如何自己“运行”的？数据库本身肯定也要在操作系统上运行吧？没错！&lt;/p&gt;
&lt;p&gt;更高层次的容器，比如 MySQL 容器，实际上会包含必要的库来与底层的操作系统容器通信和集成。所以你可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。&lt;/p&gt;
&lt;p&gt;与容器相关的一个重要概念是&lt;strong&gt;微服务&lt;/strong&gt;。将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。上面的例子中，我们会为 Vue 前端创建一个微服务，为 MySQL 数据库创建另一个微服务，为 Java 中间件部分创建另一个微服务，以此类推。很明显，微服务与容器化是相辅相成的。&lt;/p&gt;
&lt;h2 id=&#34;从-docker-开始&#34;&gt;从 Docker 开始&lt;/h2&gt;
&lt;p&gt;现在你已经对容器有一定了解了吧？Docker 是最常用的容器化工具，也是最流行的容器运行时。&lt;/p&gt;
&lt;p&gt;Docker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macOS 都支持 Docker。&lt;/p&gt;
&lt;p&gt;还有其他的容器化工具，如 &lt;a href=&#34;https://coreos.com/rkt/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CoreOS rkt&lt;/a&gt;、&lt;a href=&#34;http://mesos.apache.org/documentation/latest/mesos-containerizer/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mesos Containerizer&lt;/a&gt; 和 &lt;a href=&#34;https://linuxcontainers.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LXC&lt;/a&gt;。但是目前，绝大多数的容器化应用都是在 Docker 上运行的。&lt;/p&gt;
&lt;h2 id=&#34;再到-kubernetes&#34;&gt;再到 Kubernetes&lt;/h2&gt;
&lt;p&gt;首先，简单介绍一下历史。Kubernetes 是 Google 基于其内部容器调度平台 Borg 的经验开发的。2014 年开源，并作为 CNCF（云原生计算基金会）的核心发起项目。&lt;/p&gt;
&lt;p&gt;那么 Kubernetes 又跟容器是什么关系呢？让我们再回到上面的例子。假设我们的应用爆火，每天的注册用户越来越多。&lt;/p&gt;
&lt;p&gt;现在，我们需要增加后端资源，使浏览我们网站的用户在浏览页面时加载时间不会过长或者超时。最简单的方式就是增加容器的数量，然后使用负载均衡器将传入的负载（以用户请求的形式）分配给容器。&lt;/p&gt;
&lt;p&gt;这样做虽然行之有效，但也只能在用户规模有限的情况下使用。当用户请求达到几十万或几百万时，这种方法也是不可扩展的。你需要管理几十个也许是几百个负载均衡器，这本身就是另一个令人头疼的问题。如果我们想对网站或应用进行任何升级，也会遇到问题，因为负载均衡不会考虑到应用升级的问题。我们需要单独配置每个负载均衡器，然后升级该均衡器所服务的容器。想象一下，当你有 20 个负载均衡器和每周 5 或 6 个小的更新时，你将不得不进行大量的手工劳动。&lt;/p&gt;
&lt;p&gt;我们需要的是一种可以一次性将变更传递给所有受控容器的方法，同时也需要一种可以轻松地调度可用容器的方法，这个过程还必须要是自动化的，这正是 Kubernetes 所做的事情。&lt;/p&gt;
&lt;p&gt;接下来，我们将探讨 Kubernetes 究竟是如何工作的，它的各种组件和服务，以及更多关于如何使用 Kubernetes 来编排、管理和监控容器化环境。为了简单起见，假设我们使用的是 Docker 容器，尽管如前所述，Kubernetes 除了支持 Docker 之外，还支持其他几种容器平台。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-架构和组件&#34;&gt;Kubernetes 架构和组件&lt;/h2&gt;
&lt;p&gt;首先，最重要的是你需要认识到 Kubernetes 利用了“期望状态”原则。就是说，你定义了组件的期望状态，而 Kubernetes 要将它们始终调整到这个状态。&lt;/p&gt;
&lt;p&gt;例如，你想让你的 Web 服务器始终运行在 4 个容器中，以达到负载均衡的目的，你的数据库复制到 3 个不同的容器中，以达到冗余的目的。这就是你想要的状态。如果这 7 个容器中的任何一个出现故障，Kubernetes 引擎会检测到这一点，并自动创建出一个新的容器，以确保维持所需的状态。&lt;/p&gt;
&lt;p&gt;现在我们来定义一些 Kubernetes 的重要组件。&lt;/p&gt;
&lt;p&gt;当你第一次设置 Kubernetes 时，你会创建一个集群。所有其他组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间 (namespace)，它们是同一个物理集群的一部分。这与你可以在同一物理服务器上创建多个虚拟机的方式非常相似。如果你不需要，也没有明确定义的命名空间，那么你的集群将在始终存在的默认命名空间中创建。&lt;/p&gt;
&lt;p&gt;Kubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。&lt;/p&gt;
&lt;p&gt;主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。&lt;/p&gt;
&lt;p&gt;Master 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。&lt;/p&gt;
&lt;p&gt;Woker 节点是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的逻辑而非物理的工作单位称为 pod。一个 pod 类似于 Docker 中的容器。记得我们在前面讲到，容器可以让你创建独立、隔离的工作单元，可以独立运行。但是要创建复杂的应用程序，比如 Web 服务器，你经常需要结合多个容器，然后在一个 pod 中一起运行和管理。这就是 pod 的设计目的——一个 pod 允许你把多个容器，并指定它们如何组合在一起来创建应用程序。而这也进一步明确了 Docker 和 Kubernetes 之间的关系——一个 Kubernetes pod 通常包含一个或多个 Docker 容器，所有的容器都作为一个单元来管理。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的 service 是一组逻辑上的 pod。把一个 service 看成是一个 pod 的逻辑分组，它提供了一个单一的 IP 地址和 DNS 名称，你可以通过它访问服务内的所有 pod。有了服务，就可以非常容易地设置和管理负载均衡，当你需要扩展 Kubernetes pod 时，这对你有很大的帮助，我们很快就会看到。&lt;/p&gt;
&lt;p&gt;ReplicationController 或 ReplicaSet 是 Kubernetes 的另一个关键功能。它是负责实际管理 pod 生命周期的组件——当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubectl&#34;&gt;什么是 Kubectl？&lt;/h2&gt;
&lt;p&gt;kubectl 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-中的自动扩展&#34;&gt;Kubernetes 中的自动扩展&lt;/h2&gt;
&lt;p&gt;请记住，我们使用 Kubernetes 而不是直接使用 Docker 的原因之一，是因为 Kubernetes 能够自动扩展应用实例的数量以满足工作负载的需求。&lt;/p&gt;
&lt;p&gt;自动缩放是通过集群设置来实现的，当服务需求增加时，增加节点数量，当需求减少时，则减少节点数量。但也要记住，节点是“物理”结构——我们把“物理”放在引号里，因为要记住，很多时候，它们实际上是虚拟机。&lt;/p&gt;
&lt;p&gt;无论如何，节点是物理机器的事实意味着我们的云平台必须允许 Kubernetes 引擎创建新机器。各种云提供商对 Kubernetes 支持基本都满足这一点。&lt;/p&gt;
&lt;p&gt;我们再继续说一些概念，这次是和网络有关的。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubernetes-ingress-和-egress&#34;&gt;什么是 kubernetes Ingress 和 Egress？&lt;/h2&gt;
&lt;p&gt;外部用户或应用程序与 Kubernetes pod 交互，就像 pod 是一个真正的服务器一样。我们需要设置安全规则允许哪些流量可以进入和离开“服务器”，就像我们为托管应用程序的服务器定义安全规则一样。&lt;/p&gt;
&lt;p&gt;进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 egress。我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 / 流量的地方。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ingress-controller&#34;&gt;什么是 Ingress Controller？&lt;/h2&gt;
&lt;p&gt;但是在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。&lt;/p&gt;
&lt;h2 id=&#34;什么是-replica-和-replicaset&#34;&gt;什么是 Replica 和 ReplicaSet？&lt;/h2&gt;
&lt;p&gt;为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是“让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。&lt;/p&gt;
&lt;p&gt;所需状态是在 deployment 中定义的。Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。&lt;/p&gt;
&lt;p&gt;因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。&lt;/p&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://jimmysong.io/blog/what-is-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格 (Service Mesh)&lt;/a&gt; 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 &lt;a href=&#34;https://jimmysong.io/blog/post-kubernetes-era/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 次世代的云原生应用&lt;/a&gt; 的重要组成部分。&lt;/p&gt;
&lt;p&gt;服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）——就是 MySQL 数据库、Node.js 前端、负载均衡器等。&lt;/p&gt;
&lt;p&gt;所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更——这些变更对其他容器是完全透明的。&lt;/p&gt;
&lt;p&gt;如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。&lt;/p&gt;
&lt;p&gt;在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。关于服务网格的更多内容请参考 &lt;a href=&#34;https://www.servicemesher.com/istio-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio Handbook——Istio 服务网格进阶实战&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在下一部分中，我们将展开更多关于 Kubernetes 的话题：如何开始学习 Kubernetes，如何在本地安装和测试 Kubernetes，以及 Kubernetes 的一些优秀的监控工具。&lt;/p&gt;
&lt;h2 id=&#34;如何学习-kubernetes&#34;&gt;如何学习 Kubernetes？&lt;/h2&gt;
&lt;p&gt;自学 Kubernetes 知识基本上有三种不同的途径，我们在这里只提供了一个指导大纲。&lt;/p&gt;
&lt;h3 id=&#34;一从零开始学习和安装-kubernetes&#34;&gt;一、从零开始学习和安装 Kubernetes&lt;/h3&gt;
&lt;p&gt;要想真正掌握 Kubernetes，最好的办法莫过于自己从头开始安装 Kubernetes。不过要注意的是，从零开始安装 Kubernetes 并不是一件容易的事情。安装 Kubernetes 并不是简单的“下载文件 -&amp;gt; 点击安装”式的操作，Kubernetes 由多个组件组成，这些组件必须单独安装和配置。而在此之前，你也需要相当的技术储备来做安装前的准备，比如熟悉 Linux 操作系统。如果你决定使用这种方式学习的话，推荐你阅读 &lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。此外，请记住，尽管 Kubernetes 作为一个开源解决方案在技术上是免费的，但它确实有一些隐藏的成本，只不过对初学者来说可能并不明显。&lt;/p&gt;
&lt;h3 id=&#34;二kubernetes-自托管解决方案&#34;&gt;二、Kubernetes 自托管解决方案&lt;/h3&gt;
&lt;p&gt;这些解决方案样是一些工具和实用程序，大大简化了在本地计算机上安装和配置小型 Kubernetes 集群的任务。它们是学习 Kubernetes 的好方法，同时对于新手来说也不会太难，又足够小巧可以到安装在个人电脑上。最流行的自托管 Kubernetes 工具和环境是 &lt;a href=&#34;https://github.com/kubernetes/minikube&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Minikube&lt;/a&gt;、&lt;a href=&#34;https://github.com/ubuntu/microk8s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MicroK8s&lt;/a&gt;、&lt;a href=&#34;https://docs.docker.com/docker-for-windows/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Desktop&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/kubernetes-sigs/kind&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kind&lt;/a&gt;。这些解决方案往往有一些限制，例如，Minikube 只允许创建一个节点。尽管有这些缺点，但这些工具还是非常值得推荐，因为它们将易学性和成本效益结合起来，对于刚开始使用 Kubernetes 的初学者来说，是一个很好的选择。&lt;/p&gt;
&lt;h3 id=&#34;三云托管的解决方案&#34;&gt;三、云托管的解决方案&lt;/h3&gt;
&lt;p&gt;如今各大云供应商都提供了定制化的 Kubernetes 解决方案来。你也可以通过线上教学平台如 &lt;a href=&#34;https://katacoda.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Katacoda&lt;/a&gt; 上的免费课程来学习 Kubernetes，它们都是云托管的，你不需要自己安装，只不过你需要云供应商的集群需要付费。&lt;/p&gt;
&lt;h2 id=&#34;本地测试和调试-kubernetes&#34;&gt;本地测试和调试 Kubernetes&lt;/h2&gt;
&lt;p&gt;作为本地安装 Kubernetes 的一部分，你很可能还需要一些测试和调试能力，以确保一切都在顺利运行，特别是定义入口和出口策略等棘手的任务。此外，还有 Kubernetes 附加组件的生态系统，你可能想使用这些组件来扩展 Kubernetes 集群的功能。添加所有这些都需要进行更多的测试，以确保它们能与你的 Kubernetes 集群完美的集成。&lt;/p&gt;
&lt;p&gt;用于在本地开发和调试 Kubernetes 服务的工具有：&lt;a href=&#34;https://github.com/microsoft/mindaro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microsoft Bridge to Kubernetes&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/telepresenceio/telepresence&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;telepresence&lt;/a&gt;。这些工具可以让你在本地运行单个服务，同时将该服务连接到远程 Kubernetes 集群。这样你就可以让自己的本地机器作为 Kubernetes 集群中的一部分来运行——这对于在本地而不是在生产集群上开发服务非常有用。&lt;/p&gt;
&lt;p&gt;Kubernetes 项目也了解到了 Kubernetes 安装对端到端 (E2E) 测试的需求。为此，项目核心团队一直在确保在最近的版本中更恰当地支持 E2E 测试。这包括诸如允许测试重用和纳入更多附加组件和驱动程序的测试等。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-监控工具&#34;&gt;Kubernetes 监控工具&lt;/h2&gt;
&lt;p&gt;Kubernetes 提供了应用程序在集群的每个层次上的资源使用情况的详细信息——容器、pod、服务。这些详细信息使你能够评估应用程序的性能，确定哪些瓶颈可以解决以提高整体性能。&lt;/p&gt;
&lt;p&gt;毕竟，监控可以帮助你了解应用和集群运行情况的详细信息，这对于学习 Kubernetes 是十分有帮助的。&lt;/p&gt;
&lt;p&gt;Kubernetes 包含两个内置度量收集工具用于监控：&lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;资源管道和全度量管道&lt;/a&gt;。资源管道是一个较低级和较有限的工具，主要集中在与各种控制器相关的指标上。全指标管道，顾名思义，从几乎所有集群组件中获取并显示更丰富的指标。&lt;/p&gt;
&lt;p&gt;还有一些第三方工具可以安装并集成到 Kubernetes 集群中。对于 Kubernetes 来说，最普遍使用的两个工具是 Prometheus 和 Grafana。&lt;/p&gt;
&lt;h3 id=&#34;prometheus-监控&#34;&gt;Prometheus 监控&lt;/h3&gt;
&lt;p&gt;Prometheus 是一个功能丰富的开源监控和警报工具。Prometheus 包含一个内部数据存储用来收集指标，如生成的时间序列数据。Prometheus 还拥有众多插件，允许它将数据暴露给各种外部解决方案，并从其他数据源导入数据，包括所有主要公有云监控解决方案。&lt;/p&gt;
&lt;h3 id=&#34;grafana-仪表盘&#34;&gt;Grafana 仪表盘&lt;/h3&gt;
&lt;p&gt;Grafana 是一个优秀的仪表盘、分析和数据可视化工具。它没有 Prometheus 的全功能数据收集能力，但 Prometheus 又没有 Grafana 的数据呈现界面。事实上，他们最好是结合在一起使用——Prometheus 负责数据收集和汇总，Grafana 负责数据展示。它们共同创造了一个强大的组合，涵盖了数据收集、基本警报和可视化。&lt;/p&gt;
&lt;h3 id=&#34;高级警报&#34;&gt;高级警报&lt;/h3&gt;
&lt;p&gt;对于高级警报，你可以添加 &lt;a href=&#34;https://www.nagios.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nagios&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/prometheus/alertmanager&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus Alertmanager&lt;/a&gt; 等工具。这些警报工具通常有大量的集成。你可以为自定义值班团队，然后定义你想要监控的参数，例如“当任何 pod 不可用时”或“当任何节点无法访问时”、“当容量达到 90%”等，然后通过电子邮件、短信、手机应用提醒、电话呼叫等方式向值班人员发送自定义通知。你还可以创建升级策略，比如，如果一个被定义为“危急”的警报在 10 分钟内没有值班人员确认，那么就将警报升级（发送警报）到该人员的经理。&lt;/p&gt;
&lt;p&gt;现在，你应该已经对 Docker 和 Kubernetes 有了大体的认识。了解了 Kubernetes 的作用，知道它是如何进行容器化应用部署和管理的。&lt;/p&gt;
&lt;p&gt;调试和监控技术不仅仅是运维需要，你也可以把它当作学习方式。有什么比边做边学更好呢？&lt;/p&gt;
&lt;p&gt;请记住，如果你的应用规模太小，而且预计用户需求不会有太大变化或重大波动（比如一个只在公司内部使用的应用），那么 Kubernetes 对你来说可能没有必要，这种情况下，直接使用 Docker 就足够了。&lt;/p&gt;
&lt;h2 id=&#34;更多&#34;&gt;更多&lt;/h2&gt;
&lt;p&gt;云原生领域的开源项目众多（见 &lt;a href=&#34;https://jimmysong.io/awesome-cloud-native&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Awesome Cloud Native/云原生开源项目大全&lt;/a&gt;），其中有大量的优秀项目可供我们学习。此外，Kubernetes 开源已经多年时间，网上有大量的学习资料，业界出版过很多 &lt;a href=&#34;https://jimmysong.io/cloud-native/note/books/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;书籍&lt;/a&gt;，建议大家通过阅读 &lt;a href=&#34;https://kubernetes.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt; 和实践来学习，也可以参考我编写的 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;推荐大家加入我发起创办的 &lt;a href=&#34;https://cloudnative.to&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区&lt;/a&gt;，这是一个立足中国，放眼世界的云原生终端用户社区，致力于云原生技术的传播和应用。云原生社区主办的 &lt;a href=&#34;https://github.com/cloudnativeto/academy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生学院&lt;/a&gt; 定期邀请云原生和开源领域的大咖在 B 站上进行直播分享，成员自发组织了多个 SIG（特别兴趣小组）进行讨论学习。欢迎加入我们，共同学习和交流云原生技术。如果你想从事服务网格领域，加入一家由开源技术而构建的全球化公司，欢迎大家关注我所在的服务网格公司 &lt;a href=&#34;https://mp.weixin.qq.com/s/_da1ZgA9-wnT5t_bFuw6AQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么要选择 Service Mesh？</title>
      <link>https://cloudnative.to/blog/why-is-service-mesh/</link>
      <pubDate>Thu, 08 Nov 2018 15:20:46 +0800</pubDate>
      <guid>https://cloudnative.to/blog/why-is-service-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/@tak2siva/why-is-service-mesh-8ebcd6ed9eb5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;除非你长期与世隔绝，否则你应该听说过 Kubernetes，他已经称为高速发展的互联网公司的一条准则。最近又有一个热门话题&amp;ndash;Service Mesh（服务网格），它已经被这些高速发展公司用来解决一些特定的问题。所以如果你想了解什么是 Service Mesh，接下来我可以给你一个更好的解释。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0r3hzbzlj20zk0ilnmj_hud55b831f5582dfa7e138f15673b87449_76045_c5ca66a428b15fa912f9173ee94d89f9.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0r3hzbzlj20zk0ilnmj_hud55b831f5582dfa7e138f15673b87449_76045_f1b4d588fb6d2850fc70df103ac2d21e.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0r3hzbzlj20zk0ilnmj_hud55b831f5582dfa7e138f15673b87449_76045_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx0r3hzbzlj20zk0ilnmj_hud55b831f5582dfa7e138f15673b87449_76045_c5ca66a428b15fa912f9173ee94d89f9.webp&#34;
               width=&#34;690&#34;
               height=&#34;361&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;互联网应用的演进&#34;&gt;互联网应用的演进&lt;/h2&gt;
&lt;p&gt;为了理解 Sevice Mesh 的重要性，我们通过四个阶段来简短的回顾下互联网应用的发展历程。&lt;/p&gt;
&lt;h3 id=&#34;阶段-0单体应用&#34;&gt;阶段 0：单体应用&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0r9265r7j208s06omxs_hu9bdf3d0877323bc8d2349c5fd4e8abac_15558_522eef42506d8369496b2a6832c3dce5.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0r9265r7j208s06omxs_hu9bdf3d0877323bc8d2349c5fd4e8abac_15558_3f8e819a6fba56c3916d51912626faeb.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0r9265r7j208s06omxs_hu9bdf3d0877323bc8d2349c5fd4e8abac_15558_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx0r9265r7j208s06omxs_hu9bdf3d0877323bc8d2349c5fd4e8abac_15558_522eef42506d8369496b2a6832c3dce5.webp&#34;
               width=&#34;316&#34;
               height=&#34;240&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;还记得那些年吗？所有的代码库都打包成一个可执行和部署的软件包。当然，至今在某些使用场景下这个方式依然是很管用的。但是对于一些业务快速增长的互联网公司，在应用的可扩展性、快速部署和所有权等方面遇到了阻力。&lt;/p&gt;
&lt;h3 id=&#34;阶段-1微服务&#34;&gt;阶段 1：微服务&lt;/h3&gt;
&lt;p&gt;微服务的思思想很简单，依照 SLA（服务等级协议）将单体应用拆分成多个模块。这种方式运行效果显著，所以广泛为企业所接受。现在，每个团队都用他们喜爱的语言、框架等自由地设计他们的微服务。然后它开始看起来就像下面这样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0si4ef85j218g0n4tde_hu8205f46289cc7bd369f9ae5a5fcc7262_40992_debda5a4356328d2afebe038633a8373.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0si4ef85j218g0n4tde_hu8205f46289cc7bd369f9ae5a5fcc7262_40992_ea3ea21f793939e145cf863be6c75385.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0si4ef85j218g0n4tde_hu8205f46289cc7bd369f9ae5a5fcc7262_40992_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx0si4ef85j218g0n4tde_hu8205f46289cc7bd369f9ae5a5fcc7262_40992_debda5a4356328d2afebe038633a8373.webp&#34;
               width=&#34;690&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们曾经在我的一个项目中开玩笑说，那里有各种语言的微服务:)&lt;/p&gt;
&lt;p&gt;尽管微服务解决了单体应用的一些问题，但现在公司有一些严重问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为每个微服务定义 VM（虚拟机）规范&lt;/li&gt;
&lt;li&gt;维护系统级别依赖操作系统版本、自动化工具（如 chef）等&lt;/li&gt;
&lt;li&gt;监控每个服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对负责构建和部署的人来说这就是一个噩梦。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0vg3ks7aj20dc07iq53_hub770418f0944ad10207ebd1ea1616973_40544_c6091c2f62d145d24bb15ea94eea020e.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0vg3ks7aj20dc07iq53_hub770418f0944ad10207ebd1ea1616973_40544_a4112f33d9a3829c893660a369d3df6c.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0vg3ks7aj20dc07iq53_hub770418f0944ad10207ebd1ea1616973_40544_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx0vg3ks7aj20dc07iq53_hub770418f0944ad10207ebd1ea1616973_40544_c6091c2f62d145d24bb15ea94eea020e.webp&#34;
               width=&#34;480&#34;
               height=&#34;270&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而且这些服务在虚拟机中共享同一个 OS，但为了达到可移植性，服务之间需要隔离或者被封装到独立的 VM 镜像。微服务典型的架构设计如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0vt7d9woj218g0n4tc3_hu889809897dfe8ee74a65b98ccc3e0bdb_41261_b6940cf71bf597e751489545895d7eef.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0vt7d9woj218g0n4tc3_hu889809897dfe8ee74a65b98ccc3e0bdb_41261_a09c5e9a16b01aecacc5db4899cb32c7.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0vt7d9woj218g0n4tc3_hu889809897dfe8ee74a65b98ccc3e0bdb_41261_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx0vt7d9woj218g0n4tc3_hu889809897dfe8ee74a65b98ccc3e0bdb_41261_b6940cf71bf597e751489545895d7eef.webp&#34;
               width=&#34;690&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但为每个服务/副本安装在一台独立的虚拟机上，花费是非常高的。&lt;/p&gt;
&lt;h3 id=&#34;阶段-2容器化&#34;&gt;阶段 2：容器化&lt;/h3&gt;
&lt;p&gt;容器是利用 Linux 中的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Cgroups&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cgroups&lt;/a&gt; 和 &lt;a href=&#34;https://en.wikipedia.org/wiki/Linux_namespaces&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;namespace&lt;/a&gt; 的一种新的操作系统级别的虚拟化技术，通过共享主机的操作系统，实现为不同的应用隔离运行环境的。Docker 是目前最流行的容器运行时。&lt;/p&gt;
&lt;p&gt;所以我们会为每个微服务创建一个容器镜像并以容器形式发布成服务。这样不仅可以在一个操作系统上实现应用运行环境的隔离，而且启动新的容器相比于启动新的 VM 速度更快、成本也更低！使用容器技术之后的微服务设计看起来就像这样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0wzyguoej218g0n4ju8_hu9f1fea6c49976a86d8428c6979038e57_37436_3a2104da64a27d390481d0a73c2ae5ba.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0wzyguoej218g0n4ju8_hu9f1fea6c49976a86d8428c6979038e57_37436_10e3e2bc8b4a6080b40ff8c9e28c19e8.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0wzyguoej218g0n4ju8_hu9f1fea6c49976a86d8428c6979038e57_37436_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx0wzyguoej218g0n4ju8_hu9f1fea6c49976a86d8428c6979038e57_37436_3a2104da64a27d390481d0a73c2ae5ba.webp&#34;
               width=&#34;690&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;容器化解决了构建和部署的问题，但还没有完美的监控解决方案！那要怎么办？我们还有其他问题吗？管理容器！&lt;/p&gt;
&lt;p&gt;使用容器运行一个可靠的基础设施层需要注意以下几个重要的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器的可用性&lt;/li&gt;
&lt;li&gt;生成容器&lt;/li&gt;
&lt;li&gt;扩容/缩容&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;调度容器到多个主机&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;阶段-3容器编排&#34;&gt;阶段 3：容器编排&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx1kwi5nvpj205t05o74e_hu1abb2448305a3a83b7fe915c01cb3c68_19503_9add1d2db74dbc8378302949a1908878.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx1kwi5nvpj205t05o74e_hu1abb2448305a3a83b7fe915c01cb3c68_19503_1c91d81d782f8d0d7fdf24ff5bfdff72.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx1kwi5nvpj205t05o74e_hu1abb2448305a3a83b7fe915c01cb3c68_19503_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx1kwi5nvpj205t05o74e_hu1abb2448305a3a83b7fe915c01cb3c68_19503_9add1d2db74dbc8378302949a1908878.webp&#34;
               width=&#34;209&#34;
               height=&#34;204&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes 是当下最流行的容器编排工具，它彻底改变了我们对基础设施的看法。Kubernetes 侧重于健康检查，可用性，负载均衡，服务发现，扩展性，跨主机调度容器等等，很神奇！&lt;/p&gt;
&lt;p&gt;我们要的就是这样吗？&lt;/p&gt;
&lt;p&gt;并不完全是，仅仅这样还不能解决在微服务阶段提到的服务监控/观测的问题。这只是冰山一角。微服务是分布式的，所以管理微服务不是件容易的事。&lt;/p&gt;
&lt;p&gt;我们需要考虑一些最佳实践来便捷地运行微服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Metrics（延迟，成功率等）&lt;/li&gt;
&lt;li&gt;分布式链路追踪&lt;/li&gt;
&lt;li&gt;客户端负载均衡&lt;/li&gt;
&lt;li&gt;熔断&lt;/li&gt;
&lt;li&gt;流量迁移&lt;/li&gt;
&lt;li&gt;限速&lt;/li&gt;
&lt;li&gt;访问日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;像 Netflix 这样的公司已经推出了几种工具，并接受了那些运行微服务的做法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netflix Spectator（Metrics）&lt;/li&gt;
&lt;li&gt;Netflix Ribbon（客户端负载均衡/服务发现）&lt;/li&gt;
&lt;li&gt;Netflix Hystrix（熔断器）&lt;/li&gt;
&lt;li&gt;Netflix Zuul（边界路由）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，为了满足这些最佳实践的唯一方法是在每个微服务上使用一个客户端库来解决每个问题。所以每个服务的结构看起来就像这样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx1ojjkrfuj212g0fymz5_hu93446704dcc11e0cc328516462a5b191_29350_a48f8502b90866db6ac87f6078c90e8e.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx1ojjkrfuj212g0fymz5_hu93446704dcc11e0cc328516462a5b191_29350_1f826532cd3cd49666cb7fd0b9b34dd7.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx1ojjkrfuj212g0fymz5_hu93446704dcc11e0cc328516462a5b191_29350_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx1ojjkrfuj212g0fymz5_hu93446704dcc11e0cc328516462a5b191_29350_a48f8502b90866db6ac87f6078c90e8e.webp&#34;
               width=&#34;690&#34;
               height=&#34;286&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但这是针对像 Service A 这样的用 JAVA 写的服务，那其他的服务要怎么办？
如果我使用其他语言没有类似 java 的库要怎么办？
怎样才能让所有团队使用/维护/升级库版本？
我们公司有上百个服务，我要修改所有应用都使用上面的库吗？&lt;/p&gt;
&lt;p&gt;发现了吗？自微服务诞生以来，这些一直都是个问题（语言限制、应用代码改造）。&lt;/p&gt;
&lt;h3 id=&#34;阶段-4服务网格&#34;&gt;阶段 4：服务网格&lt;/h3&gt;
&lt;p&gt;目前有多种代理为 Service Mesh 提供解决方案，如：&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;、Linkerd 和 Nginx。本文只关注 Envoy 的 Service Mesh。&lt;/p&gt;
&lt;p&gt;Envoy 是针对微服务产生的这些问题设计出来的服务代理。&lt;/p&gt;
&lt;p&gt;Envoy 能够作为 &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SideCar&lt;/a&gt; 运行在每个应用的旁边，形成抽象的应用网络。当基础设施中的所有服务流量通过 Envoy 网格流动时，通过一致的可观察性来问题区域变得容易。&lt;/p&gt;
&lt;p&gt;如下图所示，当把 Envoy 作为 SideCar 添加到服务后，所有微服务的入站和出站流量都通过各自的 Envoy 代理&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx1t3tisq1j218g0n4q5x_hu0ed33f8c3ba108950be863d451e9db0c_37649_f7457799018f3aa9f6dc7658c3ed485f.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx1t3tisq1j218g0n4q5x_hu0ed33f8c3ba108950be863d451e9db0c_37649_deb8afe7642f544a0cd0c4a26124e55f.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx1t3tisq1j218g0n4q5x_hu0ed33f8c3ba108950be863d451e9db0c_37649_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx1t3tisq1j218g0n4q5x_hu0ed33f8c3ba108950be863d451e9db0c_37649_f7457799018f3aa9f6dc7658c3ed485f.webp&#34;
               width=&#34;690&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Envoy 拥有许多方便的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持 HTTP,HTTP/2 和 gRPC&lt;/li&gt;
&lt;li&gt;健康检查&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;Metrics&lt;/li&gt;
&lt;li&gt;追踪&lt;/li&gt;
&lt;li&gt;访问日志&lt;/li&gt;
&lt;li&gt;熔断&lt;/li&gt;
&lt;li&gt;重试策略&lt;/li&gt;
&lt;li&gt;超时配置&lt;/li&gt;
&lt;li&gt;限速&lt;/li&gt;
&lt;li&gt;支持 Statsd、Prometheus&lt;/li&gt;
&lt;li&gt;流量迁移&lt;/li&gt;
&lt;li&gt;通过发现服务来动态调整配置（XDS）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等……&lt;/p&gt;
&lt;p&gt;所以通过从服务中抽象出整个网络，使用 Envoy 作为 SideCar 形成网格组成数据平面，允许我们控制上面列出的能力。&lt;/p&gt;
&lt;p&gt;欢迎反馈，谢谢！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
