<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>microservices | 云原生社区（中国）</title>
    <link>https://cloudnative.to/tag/microservices/</link>
      <atom:link href="https://cloudnative.to/tag/microservices/index.xml" rel="self" type="application/rss+xml" />
    <description>microservices</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 28 May 2020 10:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>microservices</title>
      <link>https://cloudnative.to/tag/microservices/</link>
    </image>
    
    <item>
      <title>OAM 和 Crossplane: 构建现代应用的下一个阶段</title>
      <link>https://cloudnative.to/blog/oam-crossplane/</link>
      <pubDate>Thu, 28 May 2020 10:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/oam-crossplane/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;OAM 和 Crossplane 社区共同致力于建设一个聚焦在标准化的应用和基础设施上的开放社区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 2020 年三月份，在来自 Crossplane 社区的协作和巨大贡献下，开放应用模型（即 OAM）项目发布了其&lt;a href=&#34;https://github.com/oam-dev/spec/releases/tag/v1.0.0-alpha.2?spm=a2c65.11461447.0.0.72267a2flm3ivr&amp;amp;file=v1.0.0-alpha.2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;v1alpha2 规范&lt;/a&gt;，旨在为 OAM 本身和任何采用 OAM 的 Kubernetes 应用平台带来绝佳的可扩展性。在 2020 年 5 月份，随着 Crossplane 最新的 v0.11 版本发布，Crossplane 现在具备了 OAM 规范的标准实现。我们十分激动看到两个社区间的合作，合作将标准的应用和基础设施定义与实施一起带入了云原生社区。&lt;/p&gt;
&lt;h2 id=&#34;旅程的开始&#34;&gt;旅程的开始&lt;/h2&gt;
&lt;p&gt;从 Kubernetes 工程师的角度来说，我们很接受现在的 Kubernetes 抽象层级：容器和基础设施 API 资源。但是对于平台的终端用户而言还是太过底层。&lt;/p&gt;
&lt;p&gt;为了在一定程度上提高终端用户的体验，一些团队试图通过引入 PaaS 或者 GUI 来向终端用户隐藏 Kubernetes API。初看上去，这似乎是一个好主意。但事实上，这极大的限制了平台的能力。Kubernetes 资源模型强调系统的所有能力都要能够可以表达成&amp;quot;数据&amp;quot;，例如 API 对象。向终端用户隐藏这些对象本质上会使得你的 PaaS 缺乏可扩展性，因而无法利用在生态圈中数不胜数的插件的能力。&lt;/p&gt;
&lt;p&gt;带着我们必须使平台构建者能够定义应用级别的抽象而不引入对平台可扩展性限制的理念，我们开始探索这个领域。&lt;/p&gt;
&lt;h2 id=&#34;建模你的应用而不仅仅是描述&#34;&gt;建模你的应用，而不仅仅是描述&lt;/h2&gt;
&lt;p&gt;因为我们要定义应用级别的抽象，那么第一个问题就是：什么是应用？
















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://img.alicdn.com/tfs/TB13O2iIkT2gK0jSZFkXXcIQFXa-765-401.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;一个现代应用通常是若干部分的组合 (如上图所示)。这样的模式广泛存在于现实世界：多层应用，机器学习训练应用（参数服务器和工作节点），更不用提微服务架构。但是经常被遗忘的是，这些应用的组件经常需要绑定一系列的运行策略。另外，分组策略也是一个特殊类型的运行策略。例如，我们需要在一个组内设置多个组件的安全组。&lt;/p&gt;
&lt;p&gt;因此直观的方法是使用 CRD 作为描述应用的高级抽象。并且这样可以与应用运行所需的所有其他部分（如运行策略、基础设施）一起合并成一个 YAML 文件，如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://img.alicdn.com/tfs/TB1ZCriIeH2gK0jSZJnXXaT1FXa-480-287.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上面的这个例子其实就是阿里巴巴“应用”定义的 1.0 版本。可以想象，开发人员会抱怨这样的“应用”太过于复杂，尽管它的初衷是使他们的生活更加简单。同样的，我们发现维护这个对象十分的混乱，并且基本上不可能扩展。更糟糕的是，越来越多的能力被安装到我们的 Kubernetes 集群中，这些都需要加进这个对象——Kubernetes 社区发展的十分迅速！&lt;/p&gt;
&lt;p&gt;事实上，如果你仔细检查上述 YAML 文件，会发现开发者真正关心的只是运行他们应用的定义里的一些较小片段，如&amp;quot;commands&amp;quot;和&amp;quot;package&amp;quot;。&lt;/p&gt;
&lt;p&gt;因此为何我们不把这个 YAML 分解成多个片段呢？开发人员只需要根据他们自己掌握的部分定义&amp;quot;运行什么 (what to run)&amp;quot;，运维人员（或者系统管理员）定义运行策略，基础设施运维人员处理基础设施部分。&lt;/p&gt;
&lt;p&gt;在接触了社区中的各个公司之后，我们发现“关注点分离”的想法与微软的团队非常契合。在与微软经过了数周的合作之后，我们定义了如下的顶层草图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://img.alicdn.com/tfs/TB1RXHiIeL2gK0jSZFmXXc7iXXa-798-364.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;看到了吗？与 all-in-one 式的 CRD 把所有东西揉在一起不同的是，OAM 的核心思想本质上是一个&amp;quot;框架（frame）&amp;quot;。因此，开发人员和运维人员可以在整个应用表单的“空格”里填充他们自己片段的数据。这种灵活性保证了任何平台都可以采用这个定义而不会受限于特定的工作负载和能力类型，并且这个系统可以支持任何工作负载（容器、函数、甚至虚拟机）与运行能力（例如 autoscaling、ingress、security policy)。&lt;/p&gt;
&lt;p&gt;我们称这种方法为“应用模型”，因为当一个用户需要组合多个片段为一个应用时需要遵循这个规范，他们需要去思考哪些空白需要去填充，例如是否是描述“运行什么”？或者是否是运行策略？这个过程和数学建模十分类似，数学建模使用数学概念和语言来描述系统。我们现在使用 OAM 概念来描述应用的不同部分。好处是现在平台可以理解这些不同片段的类别，这样可以保证片段的拓扑，或是检查运行策略的兼容性——可发现性和可管理性是现代产品级应用平台的核心。&lt;/p&gt;
&lt;p&gt;我们最终将这个理念发布为&lt;a href=&#34;https://github.com/oam-dev/spec/releases/tag/v1.0.0-alpha.1?spm=a2c65.11461447.0.0.72267a2flm3ivr&amp;amp;file=v1.0.0-alpha.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM spec v1alpha1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;crossplane--oam构建-kubernetes-之上的现代应用&#34;&gt;Crossplane + OAM：构建 Kubernetes 之上的现代应用&lt;/h2&gt;
&lt;p&gt;OAM spec v1alpha1 在阿里云的&lt;a href=&#34;https://www.alibabacloud.com/zh/product/edas&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;企业级分布式应用服务（EDAS）&lt;/a&gt;以及内部平台上得到了快速采用。然而，我们同样发现了一个在&amp;quot;运行什么&amp;quot;片段中的问题 (之前称之为&lt;a href=&#34;https://github.com/oam-dev/spec/blob/v1.0.0-alpha.1/3.component_model.md?spm=a2c65.11461447.0.0.72267a2flm3ivr#component-schematics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ComponentSchematic&lt;/a&gt;)，我们需要发布新版本的 ComponentSchematic 来进行 YAML 中的任何修改。这是因为它被设计成了一个模式（schematic）对象，因此开发者可以定义他们需要部署的任何工作负载并与他人分享。一个类似的问题同样存在于运行策略部分（我们称之为&amp;quot;traits&amp;quot;）——它的模式同样将 schematic 暴露给了终端用户。&lt;/p&gt;
&lt;p&gt;在 12 月份举行的 KubeCon 北美大会上，我们会见了来自 Upbound.io 的 Crossplane 维护者。我们讨论了 OAM，以及如何通过利用 CRD 作为模式 (CRD as schemas) 的方法将 OAM 规范与 Crossplane 无缝集成。我们都认为这个方向是有希望的，在经过了数月的头脑风暴，提案以及无数次的激烈讨论之后，这个想法最终演进成为了如下的 OAM spec v1alpha2:&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://img.alicdn.com/tfs/TB1cPesaCRLWu4jSZKPXXb6BpXa-811-413.png&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/oam-dev/spec/releases/tag/v1.0.0-alpha.2?spm=a2c65.11461447.0.0.72267a2flm3ivr&amp;amp;file=v1.0.0-alpha.2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM spec v1alpha2&lt;/a&gt;采用了 Kubernetes 资源模型，因此 Kubernetes 中的任何数据片段都可以通过简单的定义一个 WorkloadDefinition 或者 TraitDefinition 来无缝引用为一个 OAM 中的工作负载或者特征 (trait)。一个关于 OAM spec v1alpha2 的更深入的博客即将发布，这里可以先看看一个&lt;a href=&#34;https://speakerdeck.com/ryanzhang/building-the-next-generation-of-cloud-native-applications?spm=a2c65.11461447.0.0.72267a2flm3ivr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;详细的说明&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在实现方面，我们开发了一个基于 Go 的实现版本，称之为&lt;a href=&#34;https://github.com/crossplane/oam-kubernetes-runtime?spm=a2c65.11461447.0.0.72267a2fUs9QIx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;oam-kubernetes-runtime&lt;/a&gt;，作为&lt;a href=&#34;https://github.com/crossplane/crossplane?spm=a2c65.11461447.0.0.72267a2fUs9QIx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Crossplane&lt;/a&gt;的一部分。现在我们有一个用于 OAM 的标准 Kubernetes 运行时。&lt;/p&gt;
&lt;h2 id=&#34;组合完成整个图景&#34;&gt;组合：完成整个图景&lt;/h2&gt;
&lt;p&gt;就像你可能看到的，我们仍然缺乏关于 OAM 的一个部分：我们如何定义组件依赖的基础设施片段，例如，一个来自阿里云 MySQL 数据库实例（RDS）？如何使这个定义适用于不同的云，就像 OAM 组件那样。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中定义这样应用中心的和可移植的基础设施绝非易事，社区中有一些 operator 和产品来做这个事情，但是没有像 Crossplane 中的 Composition 那样好。Composition 组合多个基础设施片段，然后将其发布到与平台无关的 CRD 中，例如组合 CRD 来将 VPC 与 RDS 描述为一个新的数据库 CRD。这个 CRD，可以在之后引用为一个 OAM 的 WorkloadDefinition 并且成为一个应用的一部分。搞定！&lt;/p&gt;
&lt;p&gt;组合的结果十分的有力，以团队为中心的平台，可以让基础设施运维人员为应用定义和组合供应商无关的基础设施，并且可以使应用开发人员和应用运维人员以 OAM 的方式定义，运行和管理可移植的应用，不用再关心基础设施的复杂性。基础设施运维人员现在可以管理运行这些应用的基础设施。OAM 和 Crossplane 一起提供了面向应用开发者和基础设施运维人员的优雅的解决方案。&lt;/p&gt;
&lt;h2 id=&#34;下一步&#34;&gt;下一步？&lt;/h2&gt;
&lt;p&gt;OAM 的核心理念是让开发人员描述自己的应用，使应用可以运行在一个无服务器平台，或者在一个本地的 Kubernetes 集群而无需修改应用的描述。这是阿里巴巴和微软一直在努力的云边协同（cloud/edge consistency）故事的一部分。很明显，与 Crossplane 的合作弥补了这个故事真正实现所缺失的重要部分，那就是在一个系统中同时涵盖统一的应用定义和基础设施定义。我们将继续努力使 Crossplane 成为 OAM 的标准 Kubernetes 实现，并且具有更好的工作负载/特征可移植性，互操作性，丰富的运行能力；构建一个聚焦于标准应用和基础设施的开放社区。&lt;/p&gt;
&lt;p&gt;（原文地址：&lt;a href=&#34;https://www.alibabacloud.com/blog/596240&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM and Crossplane: The Next Stage for Building Modern Application&lt;/a&gt;）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>混合微服务高可用在企业级生产中的实践</title>
      <link>https://cloudnative.to/blog/microservices-ha-practice/</link>
      <pubDate>Wed, 20 May 2020 06:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/microservices-ha-practice/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Service Mesh 在企业落地中有诸多挑战，当与传统微服务应用共同部署治理时可用性挑战更为严峻。本文将以 Service Mesh 与 Spring Cloud 应用互联互通共同治理为前提，着重介绍基于 Consul 的注册中心高可用方案，通过各种限流、熔断策略保证后端服务的高可用，以及通过智能路由策略（负载均衡、实例容错等）实现服务间调用的高可用。&lt;/p&gt;
&lt;h2 id=&#34;service-mesh-与-spring-cloud-应用的互通互联&#34;&gt;Service Mesh 与 Spring Cloud 应用的互通、互联&lt;/h2&gt;
&lt;p&gt;微服务是时下技术热点，大量互联网公司都在做微服务架构的推广和落地。同时，也有很多传统企业基于微服务和容器，在做互联网技术转型。而在这个技术转型中，国内有一个现象，以 Spring Cloud 与 Dubbo 为代表的微服务开发框架非常普及和受欢迎。近年来，新兴的 Service Mesh 技术也越来越火热，受到越来越多开发者的关注，大有后来居上的趋势。&lt;/p&gt;
&lt;p&gt;在听到社区里很多人谈到微服务技术选型时，注意到他们讨论一个非此即彼的问题：采用 Spring Cloud 还是以 Istio 为代表的 Service Mesh 技术？然而这个答案并非非黑即白、非你即我，一部分应用采用 Spring Cloud，另一部分采用 Service Mesh（Istio）是完全可能的。今天我就和大家一起来讨论这个问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexuwzhhgsj30qo0f0nmp_hudf8e74cf60e728c207d390e59d7d2424_139787_7d8ade6582fc9646f35bf2bcb33bf2b2.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexuwzhhgsj30qo0f0nmp_hudf8e74cf60e728c207d390e59d7d2424_139787_83e07e9b6d2c809b61828077e57b2f6d.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexuwzhhgsj30qo0f0nmp_hudf8e74cf60e728c207d390e59d7d2424_139787_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexuwzhhgsj30qo0f0nmp_hudf8e74cf60e728c207d390e59d7d2424_139787_7d8ade6582fc9646f35bf2bcb33bf2b2.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;首先，我们来看一下 Spring Cloud 这个传统侵入式微服务框架。它包含以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集大成者，Spring Cloud 包含了微服务架构的方方面面；选用目前各家公司开发的比较成熟的、经得住实践考验的服务框架；&lt;/li&gt;
&lt;li&gt;轻量级组件，Spring Cloud 整合的组件大多比较轻量级，且都是各自领域的佼佼者；&lt;/li&gt;
&lt;li&gt;开发简便，Spring Cloud 对各个组件进行了大量的封装，从而简化了开发；&lt;/li&gt;
&lt;li&gt;开发灵活，Spring Cloud 的组件都是解耦的，开发人员可以灵活按需选择组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特别感谢 Netflix，这家很早就成功实践微服务的公司，几年前把自家几乎整个微服务框架栈贡献给了社区，早期的 Spring Cloud 主要是对 Netflix 开源组件的进一步封装。不过近两年，Spring Cloud 社区开始自研了很多新的组件，也接入了其他一些互联网公司的优秀实践。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux7038qj30qo0f01ie_hu337d4dc82c8e74ec024a4df26e98c9af_143352_b2ca8163dfced11f0554ff1791917115.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux7038qj30qo0f01ie_hu337d4dc82c8e74ec024a4df26e98c9af_143352_da565817455dd7d5ed7998a605e81492.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux7038qj30qo0f01ie_hu337d4dc82c8e74ec024a4df26e98c9af_143352_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux7038qj30qo0f01ie_hu337d4dc82c8e74ec024a4df26e98c9af_143352_b2ca8163dfced11f0554ff1791917115.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;接下来，我们简单看一下 Service Mesh 框架。它带来了两大变革：微服务治理与业务逻辑的解耦，异构系统的统一治理。此外，服务网格相对于传统微服务框架，还拥有三大技术优势：可观察性、流量控制、安全。服务网格带来了巨大变革并且拥有其强大的技术优势，被称为第二代“微服务架构”。&lt;/p&gt;
&lt;p&gt;然而就像之前说的软件开发没有银弹，传统微服务架构有许多痛点，而服务网格也不例外，也有它的局限性。这些局限性包括：增加了链路与运维的复杂度、需要更专业的运维技能、带来了一定的延迟以及对平台的适配。&lt;/p&gt;
&lt;p&gt;更多关于 Spring Cloud 与 Service Mesh 的优缺点与比较，请阅读 Istio-Handbook [&lt;a href=&#34;https://www.servicemesher.com/istio-handbook/concepts/overview.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh 概述&lt;/a&gt;]。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux8sg9oj30qo0f0nn8_hu97cf6f6303cb2b8714c1b2bcddb3dcfa_142355_93dcfa78fbe5fb0e672043e4de4dda4e.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux8sg9oj30qo0f0nn8_hu97cf6f6303cb2b8714c1b2bcddb3dcfa_142355_3c6c3ba4bb11f7b6a19f98e704f341a1.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux8sg9oj30qo0f0nn8_hu97cf6f6303cb2b8714c1b2bcddb3dcfa_142355_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux8sg9oj30qo0f0nn8_hu97cf6f6303cb2b8714c1b2bcddb3dcfa_142355_93dcfa78fbe5fb0e672043e4de4dda4e.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;前面提到过，对于传统微服务框架 Spring Cloud 与新兴微服务框架 Service Mesh，并非是个非黑即白，非你即我，延伸到微服务与单体架构，它们也是可以共存的。&lt;/p&gt;
&lt;p&gt;也可以将其与混合云相类比，混合云中包含了公有云、私有云，可能还有其它的自有基础设施。目前来看，混合云是一种流行的实践方式；实际上，可能很难找到一个完全单一云模式的组织。对多数组织来说，将一个单体应用完全重构为微服务的过程中，对开发资源的调动是一个很严峻的问题；采用混合微服务策略是一个较好的方式，对开发团队来说，这种方式让微服务架构触手可及；否则的话，开发团队可能会因为时间、经验等方面的欠缺，无法接受对单体应用的重构工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构建混合微服务架构的最佳实践：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最大化收益的部分优先重构；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非 Java 应用优先采用 Service Mesh 框架。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;混合微服务出现的原因是为了更好的支持平滑迁移，最大限度的提升服务治理水平，降低运维通信成本等，并且可能会在一个较长的周期存在着。而实现这一架构的前提，就是各服务的“互联互通”。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux44f5nj30qo0f0hb0_hu0e7a863211ba8d26d82ba1ef97cd4c56_132708_7000a06d06946b46c1f3ec457f9d6b81.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux44f5nj30qo0f0hb0_hu0e7a863211ba8d26d82ba1ef97cd4c56_132708_956efc80b3cf631998d944b9fb50785f.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux44f5nj30qo0f0hb0_hu0e7a863211ba8d26d82ba1ef97cd4c56_132708_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux44f5nj30qo0f0hb0_hu0e7a863211ba8d26d82ba1ef97cd4c56_132708_7000a06d06946b46c1f3ec457f9d6b81.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;要想实现上述“混合微服务架构”，运行时支撑服务必不可少，它主要包括服务注册中心、服务网关和集中式配置中心三个产品。&lt;/p&gt;
&lt;p&gt;传统微服务和 Service Mesh 双剑合璧（双模微服务），即“基于 SDK 的传统微服务”可以和“基于 Sidecar 的 Service Mesh 微服务”实现下列目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互联互通：两个体系中的应用可以相互访问；&lt;/li&gt;
&lt;li&gt;平滑迁移：应用可以在两个体系中迁移，对于调用该应用的其他应用，做到透明无感知；&lt;/li&gt;
&lt;li&gt;灵活演进：在互联互通和平滑迁移实现之后，我们就可以根据实际情况进行灵活的应用改造和架构演进。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里还包括对应用运行平台的要求，即两个体系下的应用，既可以运行在虚拟机之上，也可以运行在容器 /K8s  之上。我们不希望把用户绑定在 K8s 上，因此 Service Mesh 没有采用 K8s 的 Service 机制来做服务注册与发现，这里就突出了注册中心的重要性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux89mk3j30qo0f04hm_huaaa09a9d432b58d05aabe43883ba12e0_119012_dcfcb79515e5b5272006f3cfa99ceb7c.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux89mk3j30qo0f04hm_huaaa09a9d432b58d05aabe43883ba12e0_119012_9f8c168e01f1f49e59c6516f1eab2b74.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux89mk3j30qo0f04hm_huaaa09a9d432b58d05aabe43883ba12e0_119012_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux89mk3j30qo0f04hm_huaaa09a9d432b58d05aabe43883ba12e0_119012_dcfcb79515e5b5272006f3cfa99ceb7c.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;百度智能云 CNAP 团队实现了上述混合微服务架构，即实现了两个微服务体系的应用互联互通、平滑迁移、灵活演进。上述混合微服务架构图包括以下几个组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API Server：前后端解耦，接口权限控制、请求转发、异常本地化处理等等；&lt;/li&gt;
&lt;li&gt;微服务控制中心：微服务治理的主要逻辑，包括服务注册的多租户处理、治理规则（路由、限流、熔断）的创建和转换、微服务配置的管理；&lt;/li&gt;
&lt;li&gt;监控数据存储、消息队列：主要是基于 Trace 的监控方案使用的组件；&lt;/li&gt;
&lt;li&gt;配置中心：微服务配置中心，最主要的功能是支持配置管理，包括治理规则、用户配置等所有微服务配置的存储和下发，微服务配置中心的特色是借助 SDK 可以实现配置/规则热更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来主要看一下注册中心的服务注册和发现机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring Cloud 应用通过 SDK、Service Mesh 应用实现 Sidecar 分别向注册中心注册，注册的请求先通过微服务控制中心进行认证处理与多租户隔离；&lt;/li&gt;
&lt;li&gt;Mesh 控制面直接对接注册中心获取服务实例、Spring Cloud 应用通过 SDK 获取服务实例；&lt;/li&gt;
&lt;li&gt;双模异构，支持容器与虚机两种模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;注册中心与高可用方案&#34;&gt;注册中心与高可用方案&lt;/h2&gt;
&lt;p&gt;前面提到过，要想实现实现混合微服务架构，注册中心很关键。谈到注册中心，目前主流的开源注册中心包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Zookeeper：Yahoo 公司开发的分布式协调系统，可用于注册中心，目前仍有很多公司使用其作为注册中心；&lt;/li&gt;
&lt;li&gt;Eureka：Netflix 开源组件，可用于服务注册发现组件，被广大 Spring Cloud 开发者熟知，遗憾的是目前已经不再维护，也不再被 Spring Cloud 生态推荐使用；&lt;/li&gt;
&lt;li&gt;Consul：HashiCorp 公司推出的产品，其可作为实现注册中心，也是本文介绍的重点；&lt;/li&gt;
&lt;li&gt;Etcd：Etcd 官方将其定义为可靠的分布式 KV 存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们注册中心选择了 Consul，Consul 包含了以下几个重要的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务发现：可以注册服务，也可以通过 Http 或 DNS 的方式发现已经注册的服务；&lt;/li&gt;
&lt;li&gt;丰富的健康检查机制；&lt;/li&gt;
&lt;li&gt;服务网格能力，最新版本已经支持 Envoy 作为数据面；&lt;/li&gt;
&lt;li&gt;KV 存储：可以基于 Consul KV 存储实现一个分布式配置中心；&lt;/li&gt;
&lt;li&gt;多数据中心：借助多数据中心，无需使用额外的抽象层，即可构建多地域的场景，支持多 DC 数据同步、异地容灾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux5nmosj30qo0f0kas_hu363a3756cea6d070de2f225662052fe6_115064_a4842773d34a2d488b5bc9677224843e.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux5nmosj30qo0f0kas_hu363a3756cea6d070de2f225662052fe6_115064_c50cc968434952772b4533e4d51e6032.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux5nmosj30qo0f0kas_hu363a3756cea6d070de2f225662052fe6_115064_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux5nmosj30qo0f0kas_hu363a3756cea6d070de2f225662052fe6_115064_a4842773d34a2d488b5bc9677224843e.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上图是 Consul 官网提供的架构图。Consul 架构中几个核心的概念如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Agent: Agent 是运行在 Consul 集群的每个节点上的 Daemon 进程，通过 Consul Agent 命令将其启动，Agent 可以运行在 Client 或者 Server 模式下；&lt;/li&gt;
&lt;li&gt;Client：Client 是一种 Agent，其将会重定向所有的 RPC 请求到 Server，Client 是无状态的，其主要参与 LAN Gossip 协议池，其占用很少的资源，并且消耗很少的网络带宽；&lt;/li&gt;
&lt;li&gt;Server：Server 是一种 Agent，其包含了一系列的责任包括：参与 Raft 协议写半数（Raft Quorum）、维护集群状态、响应 RPC 响应、和其他 Datacenter 通过 WAN gossip 交换信息和重定向查询请求至 Leader 或者远端 Datacenter；&lt;/li&gt;
&lt;li&gt;Datacenter: Datacenter 其是私有的、低延迟、高带宽的网络环境，去除了在公共网络上的网络交互。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注册中心作为基础组件，其自身的可用性显得尤为重要，高可用的设计需要对其进行分布式部署，同时因在分布式环境下的复杂性，节点因各种原因都有可能发生故障，因此在分布式集群部署中，希望在部分节点故障时，集群依然能够正常对外服务。注册中心作为微服务基础设施，因此对其容灾和其健壮性有一定的要求，主要体现在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册中心作为微服务基础设施，因此要求出现某些故障（如节点挂掉、网络分区）后注册中心仍然能够正常运行；&lt;/li&gt;
&lt;li&gt;当注册中心的发生故障时，不能影响服务间的正常调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux7c3c9j30qo0f0dun_hue0f70a5889ab523a695d2594a884db4f_97505_d66780cb6618b606e3df49fe7f63f23b.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux7c3c9j30qo0f0dun_hue0f70a5889ab523a695d2594a884db4f_97505_eff887a684d9854b61e881d671902149.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux7c3c9j30qo0f0dun_hue0f70a5889ab523a695d2594a884db4f_97505_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux7c3c9j30qo0f0dun_hue0f70a5889ab523a695d2594a884db4f_97505_d66780cb6618b606e3df49fe7f63f23b.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Consul 使用 Raft 协议作为其分布式一致性协议，本身对故障节点有一定的容忍性，在单个 DataCenter 中 Consul 集群中节点的数量控制在 2*n + 1 个节点，其中 n 为可容忍的宕机个数。Quorum size: Raft 协议选举需要半数以上节点写入成功。&lt;/p&gt;
&lt;p&gt;Q1:  节点的个数是否可以为偶数个？&lt;/p&gt;
&lt;p&gt;A2：答案是可以的，但是不建议部署偶数个节点。一方面如上表中偶数节点 4 和奇数节点 3 可容忍的故障数是一样的，另一方面，偶数个节点在选主节点的时候可能会出现瓜分选票的情形（虽然 Consul 通过重置 election timeout 来重新选举），所以还是建议选取奇数个节点。&lt;/p&gt;
&lt;p&gt;Q2:  是不是 Server 节点个数越多越好？&lt;/p&gt;
&lt;p&gt;A2：答案是否定的，虽然上表中显示 Server 数量越多可容忍的故障数越多，熟悉 Raft 协议的读者肯定熟悉 Log Replication（如上文介绍，日志复制时过半写成功才返回写成功），随着 Server 的数量越来越多，性能就会越低，所以结合实际场景一般建议 Server 部署 3 个节点。&lt;/p&gt;
&lt;p&gt;推荐采用三节点或五节点，最为有效，且能容错。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux00anvj30qo0f0wvy_hu89df04b5551c0e60b4eb20e1c6ceec31_102299_e2a6609b915470354c15619b019a2da9.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux00anvj30qo0f0wvy_hu89df04b5551c0e60b4eb20e1c6ceec31_102299_a556ab59eea929c8002aa87408971bff.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux00anvj30qo0f0wvy_hu89df04b5551c0e60b4eb20e1c6ceec31_102299_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux00anvj30qo0f0wvy_hu89df04b5551c0e60b4eb20e1c6ceec31_102299_e2a6609b915470354c15619b019a2da9.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;注册中心设计的一个重要前提是：注册中心不能因为自身的原因或故障影响服务之间的相互调用。因此在实践过程中，如果注册中心本身发生了宕机故障/不可用，绝对不能影响服务之间的调用。这要求对接注册中心的 SDK 针对这种特殊情况进行客户端容灾设计，『客户端缓存』就是一种行之有效的手段。当注册中心发生故障无法提供服务时，服务本身并不会更新本地客户端缓存，利用其已经缓存的服务列表信息，正常完成服务间调用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux6iipzj30qo0f0qk6_hue193c83ee8355e352eb573f98123d49c_100968_cee3096ca0b671592cc58f1b8008f339.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux6iipzj30qo0f0qk6_hue193c83ee8355e352eb573f98123d49c_100968_d07713716d6af18afb1d2c66e71d17e4.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux6iipzj30qo0f0qk6_hue193c83ee8355e352eb573f98123d49c_100968_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux6iipzj30qo0f0qk6_hue193c83ee8355e352eb573f98123d49c_100968_cee3096ca0b671592cc58f1b8008f339.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们在设计时采用同 Datacenter 集群内部部署 3 个 Server 节点，来保障高可用性，当集群中 1 个节点发生故障后，集群仍然能够正常运行，同时这 3 个节点部署在不同的机房，达到机房容灾的能力。&lt;/p&gt;
&lt;p&gt;在云上环境，涉及多 region 环境，因此在架构设计设计时，我们首先将 Consul 的一个 Datacenter 对应云上一个 region，这样更符合 Consul 对于 Datecenter 的定义（DataCenter 数据中心是私有性、低延迟、高带宽的网络环境）。中间代理层实现了服务鉴权、多租户隔离等功能；还可以通过中间代理层，对接多注册中心。&lt;/p&gt;
&lt;p&gt;云上环境存在多租户隔离的需求，即：A 租户的服务只能发现 A 租户服务的实例。针对此场景，需要在 『中间代理层』完成对多租户隔离功能的实现，其主要实践思路为使用 Consul  Api Feature 具备 Filtering 功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用 Filtering 功能实现租户隔离需求；&lt;/li&gt;
&lt;li&gt;减少查询注册中心接口时网络负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;通过治理策略保证服务高可用&#34;&gt;通过治理策略保证服务高可用&lt;/h2&gt;
&lt;p&gt;什么是高可用？维基百科这么定义：系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。我们通常用 N 个 9 来定义系统的可用性，如果能达到 4 个 9，则说明系统具备自动恢复能力；如果能达到 5 个 9，则说明系统极其健壮，具有极高可用性，而能达到这个指标则是非常难的。&lt;/p&gt;
&lt;p&gt;常见的系统不可用因素包括：程序和配置出 bug、机器故障、机房故障、容量不足、依赖服务出现响应超时等。高可用的抓手包括：研发质量、测试质量、变更管理、监控告警、故障预案、容量规划、放火盲测、值班巡检等。这里，将主要介绍通过借助治理策略采用高可用设计手段来保障高可用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux2paejj30qo0f0nje_hu839dab35cccd81830dea402a781b8097_127092_39986b2aec73477b15b1e14fb4898332.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux2paejj30qo0f0nje_hu839dab35cccd81830dea402a781b8097_127092_ff25ef5463d49d0c08456e8b0cae9689.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux2paejj30qo0f0nje_hu839dab35cccd81830dea402a781b8097_127092_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux2paejj30qo0f0nje_hu839dab35cccd81830dea402a781b8097_127092_39986b2aec73477b15b1e14fb4898332.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;高可用是一个比较复杂的命题，所以设计高可用方案也涉及到了方方面面。这中间将会出现的细节是多种多样的，所以我们需要对这样一个微服务高可用方案进行一个顶层的设计。&lt;/p&gt;
&lt;p&gt;比如服务冗余：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冗余策略：每个机器每个服务都可能出现问题，所以第一个考虑到的就是每个服务必须不止一份，而是多份。所谓多份一致的服务就是服务的冗余，这里说的服务泛指了机器的服务、容器的服务、还有微服务本身的服务。在机器服务层面需要考虑，各个机器间的冗余是否有在物理空间进行隔离冗余。&lt;/li&gt;
&lt;li&gt;无状态化：我们可以随时对服务进行扩容或者缩容，想要对服务进行随时随地的扩缩容，就要求我们的服务是一个无状态化，所谓无状态化就是每个服务的服务内容和数据都是一致的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如柔性化/异步化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所谓的柔性化，就是在我们业务允许的情况下，做不到给予用户百分百可用的，通过降级的手段给到用户尽可能多的服务，而不是非得每次都交出去要么 100 分或 0 分的答卷。柔性化更多是一种思维，需要对业务场景有深入的了解。&lt;/li&gt;
&lt;li&gt;异步化：在每一次调用，时间越长存在超时的风险就越大，逻辑越复杂执行的步骤越多，存在失败的风险也就越大。如果在业务允许的情况下，用户调用只给用户必须要的结果，不是需要同步的结果可以放在另外的地方异步去操作，这就减少了超时的风险也把复杂业务进行拆分减低复杂度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面讲到的几种提高服务高可用的手段，大多需要从业务以及部署运维的角度实现。而接下来会重点介绍，可以通过 SDK/Sidecar 手段提供服务高可用的治理策略，这些策略往往对业务是非侵入或者弱侵入的，能够让绝大多数服务轻松实现服务高可用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux37m1nj30qo0f01ih_hu0348be70c1e9b03fdc8013ef84b10ac8_136904_4887d1b2b3d7a1899f5c4d0b1ebf9ab8.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux37m1nj30qo0f01ih_hu0348be70c1e9b03fdc8013ef84b10ac8_136904_36ac4c6d2fbd39f710f120c8938fe2e8.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux37m1nj30qo0f01ih_hu0348be70c1e9b03fdc8013ef84b10ac8_136904_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux37m1nj30qo0f01ih_hu0348be70c1e9b03fdc8013ef84b10ac8_136904_4887d1b2b3d7a1899f5c4d0b1ebf9ab8.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务之间一旦建立起路由，就意味着会有数据在服务之间流通。由于不同服务可以提供的资源和对数据流量的承载能力不尽相同，为了防止单个 Consumer 占用 Provider 过多的资源，或者突发的大流量冲击导致 Provider 故障，需要服务限流来保证服务的高可用。&lt;/p&gt;
&lt;p&gt;在服务治理中，虽然我们可以通过限流规则尽量避免服务承受过高的流量，但是在实际生产中服务故障依然难以完全避免。当整个系统中某些服务产生故障时，如果不及时采取措施，这种故障就有可能因为服务之间的互相访问而被传播开来，最终导致故障规模的扩大，甚至导致整个系统奔溃，这种现象我们称之为“雪崩”。熔断降级其实不只是服务治理中，在金融行业也有很广泛的应用。比如当股指的波动幅度超过规定的熔断点时，交易所为了控制风险采取的暂停交易措施。&lt;/p&gt;
&lt;p&gt;负载均衡是高可用架构的一个关键组件，主要用来提高性能和可用性，通过负载均衡将流量分发到多个服务器，同时多服务器能够消除这部分的单点故障。&lt;/p&gt;
&lt;p&gt;以上治理规则在某种程度上可以在 Spring Cloud 与 Service Mesh 两个框架上进行对齐，即同一套治理配置，可以通过转换分发到 Spring Cloud 应用的 SDK 上以及 Service Mesh 的 Sidecar 上。可以由 Config-server 负责规则下发，也可以由 Service Mesh 的控制面负责下发，取决于具体的架构方案。&lt;/p&gt;
&lt;h3 id=&#34;服务限流&#34;&gt;服务限流&lt;/h3&gt;
&lt;p&gt;对于一个应用系统来说一定会有极限并发/请求数，即总有一个 TPS/QPS 阀值，如果超了阀值则系统就会不响应用户请求或响应的非常慢，因此我们最好进行过载保护，防止大量请求涌入击垮系统。限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务或进行流量整形。&lt;/p&gt;
&lt;p&gt;常用的微服务限流架构包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接入层（api-gateway）限流：
&lt;ul&gt;
&lt;li&gt;单实例；&lt;/li&gt;
&lt;li&gt;多实例：分布式限流算法；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用外部限流服务限流：
&lt;ul&gt;
&lt;li&gt;微服务收到请求后，通过限流服务暴露的 RPC 接口查询是否超过阈值；&lt;/li&gt;
&lt;li&gt;需单独部署限流服务；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;切面层限流（SDK）：
&lt;ul&gt;
&lt;li&gt;限流功能集成在微服务系统切面层，与业务解耦；&lt;/li&gt;
&lt;li&gt;可结合远程配置中心使用；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用的限流策略包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拒绝策略：
&lt;ul&gt;
&lt;li&gt;超过阈值直接返回错误；&lt;/li&gt;
&lt;li&gt;调用方可做熔断降级处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;延迟处理：
&lt;ul&gt;
&lt;li&gt;前端设置一个流量缓冲池，将所有的请求全部缓冲进这个池子，不立即处理。然后后端真正的业务处理程序从这个池子中取出请求依次处理，常见的可以用队列模式来实现（MQ：削峰填谷）；&lt;/li&gt;
&lt;li&gt;用异步的方式去减少了后端的处理压力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特权处理：
&lt;ul&gt;
&lt;li&gt;这个模式需要将用户进行分类，通过预设的分类，让系统优先处理需要高保障的用户群体，其它用户群的请求就会延迟处理或者直接不处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用的限流算法包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;固定时间窗口限流：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先需要选定一个时间起点，之后每次接口请求到来都累加计数器，如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 100 次接口请求），累加访问次数超过限流值，则限流熔断拒绝接口请求。当进入下一个时间窗口之后，计数器清零重新计数；&lt;/li&gt;
&lt;li&gt;缺点在于：限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;滑动时间窗口算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量经过滑动时间窗口算法整形之后，可以保证任意时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑，可以部分解决上面提到的临界突发流量问题，是对固定时间窗口算法的一种改进；&lt;/li&gt;
&lt;li&gt;缺点在于：需要记录在时间窗口内每个接口请求到达的时间点，对内存的占用会比较多。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;令牌桶算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口限制 t 秒内最大访问次数为 n，则每隔 t/n 秒会放一个 token 到桶中；&lt;/li&gt;
&lt;li&gt;桶中最多可以存放 b 个 token，如果 token 到达时令牌桶已经满了，那么这个 token 会被丢弃；&lt;/li&gt;
&lt;li&gt;接口请求会先从令牌桶中取 token，拿到 token 则处理接口请求，拿不到 token 就阻塞或者拒绝服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;漏桶算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于取令牌的频率也有限制，要按照 t/n 固定的速度来取令牌；&lt;/li&gt;
&lt;li&gt;实现往往依赖于队列，请求到达如果队列未满则直接放入队列，然后有一个处理器按照固定频率从队列头取出请求进行处理。如果请求量大，则会导致队列满，那么新来的请求就会被抛弃；&lt;/li&gt;
&lt;li&gt;令牌桶和漏桶算法的算法思想大体类似，漏桶算法作为令牌桶限流算法的改进版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;令牌桶算法和漏桶算法，在某些场景下（内存消耗、应对突发流量），这两种算法会优于时间窗口算法成为首选。&lt;/p&gt;
&lt;h3 id=&#34;熔断&#34;&gt;熔断&lt;/h3&gt;
&lt;p&gt;断路器模式是微服务架构中广泛采用的模式之一，旨在将故障的影响降到最低，防止级联故障和雪崩，并确保端到端性能。我们将比较使用两种不同方法实现它的优缺点：Hystrix 和 Istio。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-熔断png&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;熔断.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gey0mpg1u4j30qo0f0jyx_huf5366a78159e0ef9f686b9638a6a7dac_113735_265ae931f29973482fc88637c8d19db3.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gey0mpg1u4j30qo0f0jyx_huf5366a78159e0ef9f686b9638a6a7dac_113735_65ad0b3146338671b1019c0ae5a67e5b.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gey0mpg1u4j30qo0f0jyx_huf5366a78159e0ef9f686b9638a6a7dac_113735_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gey0mpg1u4j30qo0f0jyx_huf5366a78159e0ef9f686b9638a6a7dac_113735_265ae931f29973482fc88637c8d19db3.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      熔断.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在电路领域中，断路器是为保护电路而设计的一种自动操作的电气开关。它的基本功能是在检测到故障后中断电流，然后可以重置 (手动或自动)，以在故障解决后恢复正常操作。这看起来与我们的问题非常相似：为了保护应用程序不受过多请求的影响，最好在后端检测到重复出现的错误时立即中断前端和后端之间的通信。Michael Nygard 在他的《Release It》一书中使用了这个类比，并为应用于上述超时问题的设计模式提供了一个典型案例，可以用上图来总结。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux51ylej30qo0f0tqg_hu8c9f24ec3dd94b2d831168d8b58db982_112351_dcb64f0d391e09641a3b9ed9b491d452.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux51ylej30qo0f0tqg_hu8c9f24ec3dd94b2d831168d8b58db982_112351_deff12f4dc6400d6b377ddfe4359ddaa.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux51ylej30qo0f0tqg_hu8c9f24ec3dd94b2d831168d8b58db982_112351_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux51ylej30qo0f0tqg_hu8c9f24ec3dd94b2d831168d8b58db982_112351_dcb64f0d391e09641a3b9ed9b491d452.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Istio 通过 DestinationRule 实现断路器模式，或者更具体的路径 TrafficPolicy (原断路器) -&amp;gt;  OutlierDetection，根据上图模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;consecutiveErrors 断路器打开前的出错次数；&lt;/li&gt;
&lt;li&gt;interval 断路器检查分析的时间间隔；&lt;/li&gt;
&lt;li&gt;baseEjectionTime 最小的开放时间，该电路将保持一段时间等于最小弹射持续时间和电路已打开的次数的乘积；&lt;/li&gt;
&lt;li&gt;maxEjectionPercent 可以弹出的上游服务的负载平衡池中主机的最大百分比，如果驱逐的主机数量超过阈值，则主机不会被驱逐。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与上述公称断路器相比，有两个主要偏差：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有半开放的状态。然而，断路器持续打开的时间取决于被调用服务之前失败的次数，持续的故障服务将导致断路器的开路时间越来越长。&lt;/li&gt;
&lt;li&gt;在基本模式中，只有一个被调用的应用程序 (后端)。在更实际的生产环境中，负载均衡器后面可能部署同一个应用程序的多个实例。某些情况下有些实例可能会失败，而有些实例可能会工作。因为 Istio 也有负载均衡器的功能，能够追踪失败的实例，并把它们从负载均衡池中移除，在一定程度上：‘maxEjectionPercent’属性的作用是保持一小部分的实例池。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hystrix 提供了一个断路器实现，允许在电路打开时执行 fallback 机制。最关键的地方就在 HystrixCommand 的方法 run() 和 getFallback()：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;run() 是要实际执行的代码 e.g. 从报价服务中获取价格；&lt;/li&gt;
&lt;li&gt;getFallback() 获取当断路器打开时的 fallback 结果 e.g. 返回缓存的价格。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring Cloud 是建立在 Spring Boot 之上的框架，它提供了与 Spring 的良好集成。它让开发者在处理 Hystrix 命令对象的实例化时，只需注释所需的 fallback 方法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux4np4zj30qo0f01da_hu5d77b23c99eab362c5034689828e0942_119287_8ee1cce18f2b7016dae7d0f33f7ecc17.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux4np4zj30qo0f01da_hu5d77b23c99eab362c5034689828e0942_119287_34d183115b68233cc1cb6876b52d12a5.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux4np4zj30qo0f01da_hu5d77b23c99eab362c5034689828e0942_119287_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux4np4zj30qo0f01da_hu5d77b23c99eab362c5034689828e0942_119287_8ee1cce18f2b7016dae7d0f33f7ecc17.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;实现断路器的方法有两种，一种是黑盒方式，另一种是白盒方式。Istio 作为一种代理管理工具，使用了黑盒方式，它实现起来很简单，不依赖于底层技术栈，而且可以在事后配置。另一方面，Hystrix 库使用白盒方式，它允许所有不同类型的 fallback:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个默认值；&lt;/li&gt;
&lt;li&gt;一个缓存；&lt;/li&gt;
&lt;li&gt;调用其他服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它还提供了级联回退（cascading fallbacks）。这些额外的特性是有代价的：它需要在开发阶段就做出 fallback 的决策。&lt;/p&gt;
&lt;p&gt;这两种方法之间的最佳匹配可能会依靠自己的上下文：在某些情况下，如引用的服务，一个白盒战略后备可能是一个更好的选择，而对于其他情况下快速失败可能是完全可以接受的，如一个集中的远程登录服务。&lt;/p&gt;
&lt;p&gt;常用的熔断方法包括自动熔断与手动熔断。发生熔断时也可以选择 fail-fast 或者 fallback。这些用户都可以基于需求灵活使用。&lt;/p&gt;
&lt;h3 id=&#34;智能路由&#34;&gt;智能路由&lt;/h3&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-imagepng&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;image.png&#34; srcset=&#34;
               /blog/microservices-ha-practice/007S8ZIlly1gexux7waasj30qo0f04o0_hubc85594f010ddd612e8db7109d6c3790_135011_336df2cb178326609b85738c88d37e06.webp 400w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux7waasj30qo0f04o0_hubc85594f010ddd612e8db7109d6c3790_135011_0142367f1ababaaf36578cb3362315d0.webp 760w,
               /blog/microservices-ha-practice/007S8ZIlly1gexux7waasj30qo0f04o0_hubc85594f010ddd612e8db7109d6c3790_135011_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-ha-practice/007S8ZIlly1gexux7waasj30qo0f04o0_hubc85594f010ddd612e8db7109d6c3790_135011_336df2cb178326609b85738c88d37e06.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      image.png
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，我们来看一下智能路由带来的高可用。智能路由这里包括（客户端）负载均衡与实例容错策略。对于 Spring Cloud 框架来说，这部分能力由 Ribbon 来提供，Ribbon 支持随机、轮询、响应时间权重等负载均衡算法。而对于 Service Mesh 框架，这部分能力由 Envoy 提供，Envoy 支持随机、轮询（加权）、环哈希等算法。为了实现两套系统的规则统一对齐，可以采用其交集。&lt;/p&gt;
&lt;p&gt;而容错策略包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;failover：失败后自动切换其他服务器，支持配置重试次数；&lt;/li&gt;
&lt;li&gt;failfast：失败立即报错，不再重试；&lt;/li&gt;
&lt;li&gt;failresnd：将失败请求放入缓存队列、异步处理，搭配 failover 使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio 支持重试策略配置，而 fail-fast 即对应与重试次数为 0。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;微服务的高可用是一个复杂的问题，往往需要从多个角度去看，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从手段看高可用。主要使用的技术手段是服务和数据的冗余备份和失效转移，一组服务或一组数据都能在多节点上，之间相互备份。当一台机器宕机或出现问题的时候，可以从当前的服务切换到其他可用的服务，不影响系统的可用性，也不会导致数据丢失。&lt;/li&gt;
&lt;li&gt;从架构看高可用。保持简单的架构，目前多数网站采用的是比较经典的分层架构，应用层、服务层、数据层。应用层是处理一些业务逻辑，服务层提供一些数据和业务紧密相关服务，数据层负责对数据进行读写。简单的架构可以使应用层，服务层可以保持无状态化进行水平扩展，这个属于计算高可用。同时在做架构设计的时候，也应该考虑 CAP 理论。&lt;/li&gt;
&lt;li&gt;从硬件看高可用。首先得确认硬件总是可能坏的，网络总是不稳定的。解决它的方法也是一个服务器不够就来多几个，一个机柜不够就来几个，一个机房不够就来几个。&lt;/li&gt;
&lt;li&gt;从软件看高可用。软件的开发不严谨，发布不规范也是导致各种不可用出现，通过控制软件开发过程质量监控，通过测试，预发布，灰度发布等手段也是减少不可用的措施。&lt;/li&gt;
&lt;li&gt;从治理看高可用。将服务规范化，事前做好服务分割，做好服务监控，预判不可用的出现，在不可用出现之前发现问题，解决问题。比如在服务上线后，根据经验，配置服务限流规则以及自动熔断规则。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.servicemesher.com/istio-handbook/concepts/overview.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Mesh 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/zoS-5oyfh9EV6S5PLy54yg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Consul 作为注册中心在云环境的实践与应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/62237UuEEJiOP_b3xRrZog&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;有了这三个锦囊，再也不用担心微服务治理了&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/oky8g1Nisdr2T4kYG-DFhg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一文理解微服务高可用的常用手段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.servicemesher.com/blog/istio-vs-hystrix-circuit-breaker/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务断路器模式实现：Istio vs Hystrix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>选择 FaaS 还是微服务？</title>
      <link>https://cloudnative.to/blog/faas-vs-microservices/</link>
      <pubDate>Tue, 09 Apr 2019 22:42:29 +0800</pubDate>
      <guid>https://cloudnative.to/blog/faas-vs-microservices/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://dzone.com/articles/faas-vs-microservices&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在做项目的云原生改造时我们可以采用微服务架构。DevOps 和自动化构建两方面的成功经验对微服务的实践很有帮助。经过一段时间的实践，你可能会有将微服务架构推广到其他部门的想法。而你担心微服务本身的复杂性和分布式系统的高维护成本会让其他部门难以接受它。可能在我们想方设法解决微服务带来的问题时，总会有些人觉得这样做毫无意义。因为现在技术发展如此之快，总会出现更好的技术方案，你能保证自己在微服务领域所做的工作最后没有白费吗？&lt;/p&gt;
&lt;p&gt;我认为不会白费！&lt;/p&gt;
&lt;p&gt;现在“serverless”和“functions-as-a-service”（FAAS）还处于早期的炒作阶段。有些人觉得 serverless 就是下一代的微服务，所以我们应该跳过当前的微服务模式而直接采用 serverless。其实这种说法是有点夸大其词。作为架构师或开发者，我们通过学习新技术来提升自身能力让自己变得更&amp;quot;值钱&amp;quot;并没有错。但我们也要以务实态度来判断是否应该采用新技术。虽然持续跟进最新技术是我们作为架构师的职责所在，但掌握在之前的产品和 IT 部门引用新技术的时机也很重要。我们可以通过下面的模块来理解微服务架构和 serverless，从而让它们可以更好的融入我们的技术栈。&lt;/p&gt;
&lt;p&gt;首先，我们需要知道为什么我们需要微服务。选用微服务架构的主要原因就是避免项目的体量阻碍产品的迭代，所有微服务其他的优势都是基于这点。更快的迭代速度意味着可以更快的为客户交付新功能/修改，从而更快的验证这些改动能够带来的效果。我们需要快速的知道自己所做的努力是否能够带来好的效果，如果不能就要马上调整方向。快速迭代就是微服务架构的核心优势。&lt;/p&gt;
&lt;p&gt;对于大多数的团队而言，至少有一部分应用能从微服务的迭代过程中获益。因此作为架构师或开发者，我们不要因为采用微服务有门槛就对其失去信心。实践微服务的重要步骤就是确定和测量改进指标。改进指标一般可以为每天迭代应用的次数、保证迭代应用稳定性的方法等。&lt;/p&gt;
&lt;p&gt;另一方面，不是所有的应用都需要用这种松散而复杂的方式来保证服务的迭代速度。如果只想简单做个应用来验证自己创意的商业价值，那你完全可以选择更加适合的架构。这时采用 MVP 测试（最小可行性测试）就是个很好的方案。如果你因为商业价值很低而打算放弃的话，那也只是放弃了一个 MVP 应用。你可以非常快的迭代它并从潜在的用户中获得反馈。在这种情况下，你可能需要根据反馈反复修改 API、功能边界、组件等。所以过早就将组件功能做成分布式的服务也会拖慢产品的发布速度。你想修改分布式组件和它的 api 就必须在各个团队间进行协调。&lt;/p&gt;
&lt;p&gt;上述观点能够反映出微服务架构和单体架构适用不同的场景。而事实上并没有所谓&amp;quot;一招鲜吃遍天“的方案。当我们在微服务架构和单体架构之间纠结时，还需要考虑到所需服务是否已经存在以及它提供服务的方式（第三方服务/公司内部服务）。我们完全可以充分利用当前已有服务来构建我们的应用，不必重新购买硬件、安装和修补操作系统，以及优化服务从而达到最高吞吐量，而这也正是云及其服务存在的意义。云供应商和他们的合作伙伴能提供数据库、消息队列、缓存、CDN 和其他更高级的功能：例如语言翻译、地图/地理空间地图、天气等。我们可以组合各种按量付费的服务来构建自己的应用。如果在使用某个服务的时候无需关心安装、参数和容量等问题，其实我们就已经在采用 serverless 架构了。serverless 架构的特点就是可以重用已经存在的 service，而无需关心运行服务需要消耗些什么。&lt;/p&gt;
&lt;p&gt;函数即服务和 serverless 具有某种联系，因为它利用了缩小到单个应用程序函数的范围的计算模型，而这有助于将各种服务组合在一起构建应用。在这种模型下，功能按需分解，你只需为使用的功能付费。它特别适合对我们使用的服务进行按需计费和按量付费。这样一来我们能够构建弹性应用，而不需要考虑复杂的技术问题。将这些复杂的技术问题外包给别人可以让你更专注于为客户提供商业价值。&lt;/p&gt;
&lt;p&gt;但是将这部分能力外包不总是可行的。如果选择云服务，我们就丧失了对程序运行时、具体功能、bug 修复和接受监管的控制力。这也是需要考虑的一部分。&lt;/p&gt;
&lt;p&gt;serverless 不一定是完整的“公有云或无云”方案。如果以单个组织的角度来看，&amp;ldquo;serverless&amp;quot;可能只是代表整个体系的其他部分。例如：零售业务可以为组织内部其他服务或第三方提供“购买“服务以支持诸如分析、推荐以及其他使用“购买”服务的应用。利用定义良好的 API 和订阅并消费 API 的工作负载，你可以在自己的基础设施为微服务应用或单体应用提供 serverless 能力。在很多时候这其实就是服务向 SOA 架构进化的方向。但它们之间最大的不同就是在你将组织看作一个整体时，自己给自己的其他部分提供服务并不算 serverless。因为此时还是需要自己手动的去安装、管理和更新应用。&lt;/p&gt;
&lt;p&gt;最终采用哪种方案其实取决于很多因素，例如：业务、商业目标、软件部门对该技术的熟练度和历史遗留问题等。如果你觉得应该采用微服务架构，那就不要因为其他新技术而分心。我们可以持续跟进最新技术，从而保证适时的采用它们。总的来讲，不管是微服务架构、单体架构还是 serverless 架构，它们都有自己的应用场景。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Istio——企业级微服务解决方案</title>
      <link>https://cloudnative.to/blog/istio-kubernetes-service-mesh/</link>
      <pubDate>Wed, 20 Feb 2019 11:44:49 +0800</pubDate>
      <guid>https://cloudnative.to/blog/istio-kubernetes-service-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.aquasec.com/istio-kubernetes-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2017 年 5 月，谷歌面向大规模容器化应用管理的开源项目 Istio 正式发布了。此后经过快速的发展，于 2018 年 7 月发布了里程碑式的 1.0 版本。本文的主要内容包括：Istio 是什么、Istio 的工作原理以及落地方式。在本系列的后续文章中我们还会深入了解 Istio 的安全和流量管理功能。&lt;/p&gt;
&lt;h2 id=&#34;istio-是什么&#34;&gt;Istio 是什么？&lt;/h2&gt;
&lt;p&gt;从过去几年发布的大量开源项目中我们可以总结出谷歌内部构建、部署与管理大型分布式容器化应用的方案。而 Istio 就是这个方案的最后一步——管理应用程序。了解 Istio 在谷歌内部的起源可以帮你更好的理解它的设计思想和历史背景。&lt;/p&gt;
&lt;p&gt;Netflix 详细的介绍过混沌工程实践以及故障注入、熔断、限流和链路跟踪等概念。为了避免在每个新项目中都需要重新实现这些功能，开发者一般选择在底层网络实现它们。当前的两种嵌入方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把这些功能和公司用到的所有语言的网络库打包到一起，并为所有的服务和团队维护它们。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-kubernetes-service-mesh/005UD0i6ly1fzodfkzee3j30go09s3yt_hu6748c89fb5d3f2d31eba675f75d61bf5_27492_5f1ef6fb301ad45f04a835471379698a.webp 400w,
               /blog/istio-kubernetes-service-mesh/005UD0i6ly1fzodfkzee3j30go09s3yt_hu6748c89fb5d3f2d31eba675f75d61bf5_27492_5c9187f8e7c38941d4dad00bd4c2d4dc.webp 760w,
               /blog/istio-kubernetes-service-mesh/005UD0i6ly1fzodfkzee3j30go09s3yt_hu6748c89fb5d3f2d31eba675f75d61bf5_27492_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-kubernetes-service-mesh/005UD0i6ly1fzodfkzee3j30go09s3yt_hu6748c89fb5d3f2d31eba675f75d61bf5_27492_5f1ef6fb301ad45f04a835471379698a.webp&#34;
               width=&#34;600&#34;
               height=&#34;352&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;通过服务网格透明的提供这些功能。Istio 使用的就是这种方式。Istio 把&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 代理&lt;/a&gt;作为每个 pod 的 sidecar 运行并通过 Istio 的控制平面来动态的配置 Envoy 从而实现这些功能。具体如下图所示：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/istio-kubernetes-service-mesh/006tKfTcly1g0crgzxldoj30z10u0437_huda18d3bf2563e262d58f59eeb10044c7_79437_3da2dddc5299298c41599fe88ed44d2d.webp 400w,
               /blog/istio-kubernetes-service-mesh/006tKfTcly1g0crgzxldoj30z10u0437_huda18d3bf2563e262d58f59eeb10044c7_79437_5aa9d1d140b81d1edc91b13c4a3dd5d2.webp 760w,
               /blog/istio-kubernetes-service-mesh/006tKfTcly1g0crgzxldoj30z10u0437_huda18d3bf2563e262d58f59eeb10044c7_79437_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/istio-kubernetes-service-mesh/006tKfTcly1g0crgzxldoj30z10u0437_huda18d3bf2563e262d58f59eeb10044c7_79437_3da2dddc5299298c41599fe88ed44d2d.webp&#34;
               width=&#34;760&#34;
               height=&#34;651&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;利用基于 Envoy 的 sidecar 机制，Istio 无需修改应用代码就可以完成嵌入。Envoy 代理容器的所有网络流量，而 Istio 的控制平面可以动态配置 Envoy 的策略。因此 Istio 可以在对应用透明的前提下提供诸如 TLS 双向验证、限流和熔断等功能。&lt;/p&gt;
&lt;p&gt;Istio 不仅仅是服务网格的解决方案，它还包含另外一个关键概念：服务认证。就像系统通过用户认证来验证用户身份一样，服务也可以像用户一样做认证。我们可以在服务之间建立基于角色的访问控制（RBAC），还能更细粒度的规范服务在网络中的行为。&lt;/p&gt;
&lt;p&gt;虽然 Istio 可以在 VM 上运行，也可以在 Kubernetes 集群和 VM 上扩展，但我们还是主要讨论在 Kubernetes 环境下的 Istio。&lt;/p&gt;
&lt;h2 id=&#34;istio-的优势&#34;&gt;Istio 的优势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开箱即用的微服务遥测&lt;/strong&gt; 微服务能够通过 Istio 自动生成遥测平面，无需额外工具就能生成统一的应用指标数据和链路追踪数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双向 TLS&lt;/strong&gt; Istio 可以在不修改应用的前提下，为服务间调用配置双向 TLS 认证。集群内的 CA 能够为 Envoy 代理提供必要的证书以保护服务间的流量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;红黑部署&lt;/strong&gt; 通过在部署期间动态分配应用程序的新老版本之间的流量，我们可以一边观察集群的报错情况，一边将新版本应用逐渐部署到生产环境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;丰富的网络策略&lt;/strong&gt; 使用 Kubernetes 我们可以为它的 API 接口和服务间的网络策略提供 RBAC 认证。而 Istio 不仅可以做 RBAC 认证，它的认证粒度还能限制到 HTTP 协议的方法和资源路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用开发者能够专注于在 7 层网络的商业价值而不用浪费时间为基础设施编写重复的解决方案。&lt;/p&gt;
&lt;h2 id=&#34;istio-架构&#34;&gt;Istio 架构&lt;/h2&gt;
&lt;p&gt;Istio 由数个管理组件的控制平面和控制平面控制的与 Envoy sidecar 一起运行的服务集合构成。控制平面由以下几个组件组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pilot:&lt;/strong&gt; 管理和维护所有的 Envoy 代理中的各种路由规则和 RBAC 配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mixer:&lt;/strong&gt; 进行遥测数据采集和执行访问控制/使用策略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Citadel:&lt;/strong&gt; 负责颁发和更新 TLS 证书。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Galley:&lt;/strong&gt; 它和用户关系不大，主要负责收集和验证系统其他组件的用户配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Proxy:&lt;/strong&gt; Envoy 作为每个 Kubernetes pod 的 sidecar 代理运行可以提供动态服务发现，负载均衡，TLS 认证，RBAC，HTTP 和 gRPC 代理，熔断，健康检查，滚动更新，故障注入和遥测数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gateway:&lt;/strong&gt; 网关可以作为集群 ingress 或 egress 的负载均衡边缘代理。ingress 规则可以通过路由规则进行配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;落地-istio-过程中的经验&#34;&gt;落地 Istio 过程中的经验&lt;/h2&gt;
&lt;p&gt;虽然使用 Istio 能带来立竿见影的好效果，但要想将它的优势发挥到最大，还必须要有设计良好的微服务架构。好的微服务系统，应该是由多个团队维护的多个小服务。所以它需要团队和业务进行转型，而这点往往容易被忽略。&lt;/p&gt;
&lt;p&gt;如之前所说，不管您的应用程序的设计或成熟度如何，都能从 Istio 中获益。&lt;/p&gt;
&lt;p&gt;提高可观察性有助于解决微服务设计中的问题。在迁移、重构或整合项目时使用 Istio 是有好处的，而在设计良好的微服务项目环境中使用，会让 Istio 大放异彩。但请记住，增加任何组件都会增加系统的复杂度。&lt;/p&gt;
&lt;p&gt;安装 Istio 包括安装控制平面组件和配置 Kubernetes 的 pod 将所有流量由 Envoy 代理两步组成。Istio 的命令行工具&lt;em&gt;istioctl&lt;/em&gt;的&lt;a href=&#34;https://www.aquasec.com/about-us/careers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;kube-inject&lt;/em&gt;&lt;/a&gt;命令可以在部署时修改你的 YAML 配置来给 pod 增加 Envoy 代理。另一种使用 Istio 的方式就是&lt;a href=&#34;https://kubernetes.io/docs/admin/admission-controllers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;webhook admission controller&lt;/em&gt;&lt;/a&gt;，它可以在部署时自动的添加 Envoy 代理，你可以在应用完全无感知的情况下获得 Istio 的所有好处。&lt;/p&gt;
&lt;p&gt;我推荐先装不含任何功能的 Istio，然后将各个功能逐渐的用起来，一次做的太多调试起来会比较麻烦。就像 Istio 团队在推广时所说：&amp;ldquo;Istio 是个菜谱&amp;rdquo;，你不需要一下就把 Istio 全部用起来。据以往的经验，从默认的遥测功能开始使用 Istio 是个不错的选择。&lt;/p&gt;
&lt;h2 id=&#34;istio-安全性&#34;&gt;Istio 安全性&lt;/h2&gt;
&lt;p&gt;Istio 真正的亮点是服务认证，RBAC 认证和端到端的双向 TLS 认证。在本系列的后续文章会详细介绍这方面内容。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;Istio 区别于 Hystrix，它采用服务网格的设计方案。因此落地和运维都变得更加简单。Istio 为服务无感知的增加了流量控制和安全性，如果想发挥它的最大效益，还需要设计良好的微服务架构。即使是非常老旧的项目也能在 Istio 的遥测技术和安全性上获益。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>微服务生态从百家争鸣阶段演化到服务网格</title>
      <link>https://cloudnative.to/blog/from-fragmented-microservices-ecosystem-to-service-mesh/</link>
      <pubDate>Thu, 13 Dec 2018 19:23:09 +0800</pubDate>
      <guid>https://cloudnative.to/blog/from-fragmented-microservices-ecosystem-to-service-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://blog.avinetworks.com/from-fragmented-microservices-ecosystem-to-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在过去几年中，我们注意到应用程序架构正在迅速转变为分布式微服务架构——单体和庞大的应用程序被分解为更小的单个服务，其可被独立修改、构建、部署和管理。这种模式的主要优点就是简洁和快速，同时由于其对其他服务的依赖性很小或者完全没有依赖，更易于升级和独立扩展。这与敏捷和 DevOps 理念非常吻合，这种模式也已经被许多规模化的 Web 公司成功采用。过去的许多年中，这些公司中的大多数都能够很好地采用这种模式，但是近几年中成功将这种模式发扬光大的两大推手非 Docker 和 Kubernetes 莫属。Docker 简化了将微服务构建为 Linux 容器的过程，Kubernetes 则能够以资源优化的方式来部署、管理和扩展服务。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6290u94jj30p70cn763_hu3e27c70ab93cb39dce6d7cf1810018f2_53660_0e4bbc8c22c66da06829cc9d77d2f3f0.webp 400w,
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6290u94jj30p70cn763_hu3e27c70ab93cb39dce6d7cf1810018f2_53660_8c789a13696f6ff3a3163b678e6ac10e.webp 760w,
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6290u94jj30p70cn763_hu3e27c70ab93cb39dce6d7cf1810018f2_53660_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6290u94jj30p70cn763_hu3e27c70ab93cb39dce6d7cf1810018f2_53660_0e4bbc8c22c66da06829cc9d77d2f3f0.webp&#34;
               width=&#34;760&#34;
               height=&#34;381&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;应用架构演进&#34;&gt;应用架构演进&lt;/h2&gt;
&lt;p&gt;在这篇博客中，我们不会花太多时间讨论微服务架构的优缺点。相反，我们将专注于在向基于微服务构建的云原生架构的重大转变上。&lt;/p&gt;
&lt;p&gt;虽然微服务架构提供了灵活性，但其也带有复杂性。Kubernetes 在部署和管理微服务方面发挥了非常重要的作用，但我们需要的不仅仅是单一的运行在生产环境中的云原生应用程序——还需要在服务发现、安全性、流量管理等方面需要更加深入的了解。尤其是在相互通信的成千上百个服务经常被删除、生产、扩展和更新的复杂环境下，深入的了解更加有必要性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6296ogt3j30qf0b9wfx_hud390268c563d1245b05518e13aa83038_41499_dd85ba3a4d5cf6ffed14cea3d73fde27.webp 400w,
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6296ogt3j30qf0b9wfx_hud390268c563d1245b05518e13aa83038_41499_733d6a07e05ded91d7b1d773916daad2.webp 760w,
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6296ogt3j30qf0b9wfx_hud390268c563d1245b05518e13aa83038_41499_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy6296ogt3j30qf0b9wfx_hud390268c563d1245b05518e13aa83038_41499_dd85ba3a4d5cf6ffed14cea3d73fde27.webp&#34;
               width=&#34;760&#34;
               height=&#34;324&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;微服务架构面临的挑战&#34;&gt;微服务架构面临的挑战&lt;/h2&gt;
&lt;p&gt;这种规模化和动态化对于早期运行单体程序和管理应用程序的基础设施带来了具体的转变。为支持这种动态环境，新一代架构需要在生态系统中补充大量的新技术。为了交付所有的用户场景，我们需要在基础架构栈的每个级别上提供多个解决方案。根据需要，基础架构人员开始将这些技术集成到平台上，但这也意味着程序开发人员需要额外的负担来支持这些技术。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy629doo63j30rd0cedif_huae11be37c1436cd51b2ebb6d81ef3353_71967_406a707954d0aafbbae3a95338527b1f.webp 400w,
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy629doo63j30rd0cedif_huae11be37c1436cd51b2ebb6d81ef3353_71967_73eae574afbcf24fec1e6ac5042cc9ac.webp 760w,
               /blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy629doo63j30rd0cedif_huae11be37c1436cd51b2ebb6d81ef3353_71967_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/from-fragmented-microservices-ecosystem-to-service-mesh/006tNbRwly1fy629doo63j30rd0cedif_huae11be37c1436cd51b2ebb6d81ef3353_71967_406a707954d0aafbbae3a95338527b1f.webp&#34;
               width=&#34;760&#34;
               height=&#34;344&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;基础架构栈高层视图&#34;&gt;基础架构栈高层视图&lt;/h2&gt;
&lt;p&gt;这不是人们所期望的，并且也绝对不是微服务架构做出的的敏捷性、易于开发和部署的承诺。&lt;/p&gt;
&lt;p&gt;此后出现了服务网格的理念，这也是 Avi Networks 在此术语被创造之前一直专注于为客户提供的内容，并且由 Istio 和 Linkerd 等开源项目推动下形成了事实上的标准。我们很高兴看到社区热情拥抱了服务网格，而且我们也认为服务网格是微服务基础架构的必要组成部分。&lt;/p&gt;
&lt;p&gt;那么什么是“服务网格” ，其如何帮助解决这些问题的呢？服务网格实质上是提供了上面图中在基础架构中的多层服务，与此同时程序开发者无需集成或修改代码就可以利用这些服务。它不仅使服务之间的通信快速可靠，而且服务网络还提供细粒度的流量管理、故障恢复、安全（加密、授权和认证）和可观察性（如跟踪、日志和监控）。所有这些都是从使用某种架构的开发人员中抽象出来的，其中所有服务间的通信都流经 sidecar 代理，代理与每个服务一起部署，从而创建一个服务网格。Sidecar 由集中控制平面管理配置，用于流量路由和策略实施。尽管运行与应用程序容器一样多的 sidecar 容器一直是争论的焦点，但服务网格的优势和功能似乎超过了运维问题。&lt;/p&gt;
&lt;p&gt;在本博客系列的其余部分，我将深入探讨如何实现服务网格，并使用 Istio 的参考架构来完成旅程，因为 Istio 是当前最广泛使用和最知名的服务网格解决方案之一。但 Istio 是否解决了所有问题，并且在处理当今微服务世界中存在的重要场景方面是否完整？我们将深入探讨这一点，并在本系列的后续部分讨论所有内容。敬请关注！&lt;/p&gt;
&lt;p&gt;Manish Chugtu - CTO Cloud Infrastructure 和 Microservices@Avi Networks，是一位创新思想领军人物，在架构，设计和产品开发方面拥有 18 年以上的经验，在架构和开发高度可扩展的企业解决方案方面拥有丰富的经验。目前，他致力于推动 Avi 在容器和云基础架构领域的战略， &lt;a href=&#34;https://www.linkedin.com/in/manishchugtu/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;他的 LinkedIn&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么要选择 Service Mesh？</title>
      <link>https://cloudnative.to/blog/why-is-service-mesh/</link>
      <pubDate>Thu, 08 Nov 2018 15:20:46 +0800</pubDate>
      <guid>https://cloudnative.to/blog/why-is-service-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://medium.com/@tak2siva/why-is-service-mesh-8ebcd6ed9eb5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;除非你长期与世隔绝，否则你应该听说过 Kubernetes，他已经称为高速发展的互联网公司的一条准则。最近又有一个热门话题&amp;ndash;Service Mesh（服务网格），它已经被这些高速发展公司用来解决一些特定的问题。所以如果你想了解什么是 Service Mesh，接下来我可以给你一个更好的解释。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0r3hzbzlj20zk0ilnmj_hu11c28948973826fb8422e505661eb1ef_42818_da6ddedd1feb00f24d3428bbf594214d.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0r3hzbzlj20zk0ilnmj_hu11c28948973826fb8422e505661eb1ef_42818_952bdaad45036e2215beeee206f24948.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0r3hzbzlj20zk0ilnmj_hu11c28948973826fb8422e505661eb1ef_42818_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx0r3hzbzlj20zk0ilnmj_hu11c28948973826fb8422e505661eb1ef_42818_da6ddedd1feb00f24d3428bbf594214d.webp&#34;
               width=&#34;690&#34;
               height=&#34;361&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;互联网应用的演进&#34;&gt;互联网应用的演进&lt;/h2&gt;
&lt;p&gt;为了理解 Sevice Mesh 的重要性，我们通过四个阶段来简短的回顾下互联网应用的发展历程。&lt;/p&gt;
&lt;h3 id=&#34;阶段-0单体应用&#34;&gt;阶段 0：单体应用&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0r9265r7j208s06omxs_hu19ae9bdf9f7666dd0ed16f53afabd4eb_10377_4a46cdf3a90032499f0c8c413c6b67d2.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0r9265r7j208s06omxs_hu19ae9bdf9f7666dd0ed16f53afabd4eb_10377_1c065da390e36f9a9e1fe1c7a8ff5089.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0r9265r7j208s06omxs_hu19ae9bdf9f7666dd0ed16f53afabd4eb_10377_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx0r9265r7j208s06omxs_hu19ae9bdf9f7666dd0ed16f53afabd4eb_10377_4a46cdf3a90032499f0c8c413c6b67d2.webp&#34;
               width=&#34;316&#34;
               height=&#34;240&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;还记得那些年吗？所有的代码库都打包成一个可执行和部署的软件包。当然，至今在某些使用场景下这个方式依然是很管用的。但是对于一些业务快速增长的互联网公司，在应用的可扩展性、快速部署和所有权等方面遇到了阻力。&lt;/p&gt;
&lt;h3 id=&#34;阶段-1微服务&#34;&gt;阶段 1：微服务&lt;/h3&gt;
&lt;p&gt;微服务的思思想很简单，依照 SLA（服务等级协议）将单体应用拆分成多个模块。这种方式运行效果显著，所以广泛为企业所接受。现在，每个团队都用他们喜爱的语言、框架等自由地设计他们的微服务。然后它开始看起来就像下面这样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0si4ef85j218g0n4tde_hu04ce2ee5a954d26b965fb026420a95b9_27333_dd714173586e9c9832ce91b69a50167b.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0si4ef85j218g0n4tde_hu04ce2ee5a954d26b965fb026420a95b9_27333_b0add2c344a5695b5e5f5f1028c64758.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0si4ef85j218g0n4tde_hu04ce2ee5a954d26b965fb026420a95b9_27333_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx0si4ef85j218g0n4tde_hu04ce2ee5a954d26b965fb026420a95b9_27333_dd714173586e9c9832ce91b69a50167b.webp&#34;
               width=&#34;690&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们曾经在我的一个项目中开玩笑说，那里有各种语言的微服务:)&lt;/p&gt;
&lt;p&gt;尽管微服务解决了单体应用的一些问题，但现在公司有一些严重问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为每个微服务定义 VM（虚拟机）规范&lt;/li&gt;
&lt;li&gt;维护系统级别依赖操作系统版本、自动化工具（如 chef）等&lt;/li&gt;
&lt;li&gt;监控每个服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对负责构建和部署的人来说这就是一个噩梦。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0vg3ks7aj20dc07iq53_hu01fefa68e3f7c35d88e8bcddfe8b7aa4_24981_6ba1fef70544c8a3f6a6a78d5de76510.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0vg3ks7aj20dc07iq53_hu01fefa68e3f7c35d88e8bcddfe8b7aa4_24981_6dc2b9e73413707d85e3072ce0b45435.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0vg3ks7aj20dc07iq53_hu01fefa68e3f7c35d88e8bcddfe8b7aa4_24981_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx0vg3ks7aj20dc07iq53_hu01fefa68e3f7c35d88e8bcddfe8b7aa4_24981_6ba1fef70544c8a3f6a6a78d5de76510.webp&#34;
               width=&#34;480&#34;
               height=&#34;270&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而且这些服务在虚拟机中共享同一个 OS，但为了达到可移植性，服务之间需要隔离或者被封装到独立的 VM 镜像。微服务典型的架构设计如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0vt7d9woj218g0n4tc3_huba7e13a4d64c6d0a20b3275bf74a4062_28047_c24ac2a85cf6b777214caee7e3c38675.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0vt7d9woj218g0n4tc3_huba7e13a4d64c6d0a20b3275bf74a4062_28047_0d4a32bfda5b100a4971449ce8b1da29.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0vt7d9woj218g0n4tc3_huba7e13a4d64c6d0a20b3275bf74a4062_28047_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx0vt7d9woj218g0n4tc3_huba7e13a4d64c6d0a20b3275bf74a4062_28047_c24ac2a85cf6b777214caee7e3c38675.webp&#34;
               width=&#34;690&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但为每个服务/副本安装在一台独立的虚拟机上，花费是非常高的。&lt;/p&gt;
&lt;h3 id=&#34;阶段-2容器化&#34;&gt;阶段 2：容器化&lt;/h3&gt;
&lt;p&gt;容器是利用 Linux 中的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Cgroups&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cgroups&lt;/a&gt; 和 &lt;a href=&#34;https://en.wikipedia.org/wiki/Linux_namespaces&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;namespace&lt;/a&gt; 的一种新的操作系统级别的虚拟化技术，通过共享主机的操作系统，实现为不同的应用隔离运行环境的。Docker 是目前最流行的容器运行时。&lt;/p&gt;
&lt;p&gt;所以我们会为每个微服务创建一个容器镜像并以容器形式发布成服务。这样不仅可以在一个操作系统上实现应用运行环境的隔离，而且启动新的容器相比于启动新的 VM 速度更快、成本也更低！使用容器技术之后的微服务设计看起来就像这样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx0wzyguoej218g0n4ju8_hu69dfadd45d72b64fa8401a289cdd9048_25814_b60bac64ea69a53486656c01445f6611.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx0wzyguoej218g0n4ju8_hu69dfadd45d72b64fa8401a289cdd9048_25814_447b386884b0be26f811347ffb2aef56.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx0wzyguoej218g0n4ju8_hu69dfadd45d72b64fa8401a289cdd9048_25814_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx0wzyguoej218g0n4ju8_hu69dfadd45d72b64fa8401a289cdd9048_25814_b60bac64ea69a53486656c01445f6611.webp&#34;
               width=&#34;690&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;容器化解决了构建和部署的问题，但还没有完美的监控解决方案！那要怎么办？我们还有其他问题吗？管理容器！&lt;/p&gt;
&lt;p&gt;使用容器运行一个可靠的基础设施层需要注意以下几个重要的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器的可用性&lt;/li&gt;
&lt;li&gt;生成容器&lt;/li&gt;
&lt;li&gt;扩容/缩容&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;调度容器到多个主机&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;阶段-3容器编排&#34;&gt;阶段 3：容器编排&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx1kwi5nvpj205t05o74e_hub5cfe3bc1ea6011b16e9626f075998d8_12292_daa9a706502021c3ebe741c1fc53e91a.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx1kwi5nvpj205t05o74e_hub5cfe3bc1ea6011b16e9626f075998d8_12292_d3f0b11def36c2484da970ede507451e.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx1kwi5nvpj205t05o74e_hub5cfe3bc1ea6011b16e9626f075998d8_12292_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx1kwi5nvpj205t05o74e_hub5cfe3bc1ea6011b16e9626f075998d8_12292_daa9a706502021c3ebe741c1fc53e91a.webp&#34;
               width=&#34;209&#34;
               height=&#34;204&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Kubernetes 是当下最流行的容器编排工具，它彻底改变了我们对基础设施的看法。Kubernetes 侧重于健康检查，可用性，负载均衡，服务发现，扩展性，跨主机调度容器等等，很神奇！&lt;/p&gt;
&lt;p&gt;我们要的就是这样吗？&lt;/p&gt;
&lt;p&gt;并不完全是，仅仅这样还不能解决在微服务阶段提到的服务监控/观测的问题。这只是冰山一角。微服务是分布式的，所以管理微服务不是件容易的事。&lt;/p&gt;
&lt;p&gt;我们需要考虑一些最佳实践来便捷地运行微服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Metrics（延迟，成功率等）&lt;/li&gt;
&lt;li&gt;分布式链路追踪&lt;/li&gt;
&lt;li&gt;客户端负载均衡&lt;/li&gt;
&lt;li&gt;熔断&lt;/li&gt;
&lt;li&gt;流量迁移&lt;/li&gt;
&lt;li&gt;限速&lt;/li&gt;
&lt;li&gt;访问日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;像 Netflix 这样的公司已经推出了几种工具，并接受了那些运行微服务的做法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netflix Spectator（Metrics）&lt;/li&gt;
&lt;li&gt;Netflix Ribbon（客户端负载均衡/服务发现）&lt;/li&gt;
&lt;li&gt;Netflix Hystrix（熔断器）&lt;/li&gt;
&lt;li&gt;Netflix Zuul（边界路由）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，为了满足这些最佳实践的唯一方法是在每个微服务上使用一个客户端库来解决每个问题。所以每个服务的结构看起来就像这样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx1ojjkrfuj212g0fymz5_hudd9c3342bc9077d3a122aab93cd79147_20428_dfe7b785c3e317d8ff0f2cd680ea1e6c.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx1ojjkrfuj212g0fymz5_hudd9c3342bc9077d3a122aab93cd79147_20428_78435a5714458218718d6714bfc11120.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx1ojjkrfuj212g0fymz5_hudd9c3342bc9077d3a122aab93cd79147_20428_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx1ojjkrfuj212g0fymz5_hudd9c3342bc9077d3a122aab93cd79147_20428_dfe7b785c3e317d8ff0f2cd680ea1e6c.webp&#34;
               width=&#34;690&#34;
               height=&#34;286&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但这是针对像 Service A 这样的用 JAVA 写的服务，那其他的服务要怎么办？
如果我使用其他语言没有类似 java 的库要怎么办？
怎样才能让所有团队使用/维护/升级库版本？
我们公司有上百个服务，我要修改所有应用都使用上面的库吗？&lt;/p&gt;
&lt;p&gt;发现了吗？自微服务诞生以来，这些一直都是个问题（语言限制、应用代码改造）。&lt;/p&gt;
&lt;h3 id=&#34;阶段-4服务网格&#34;&gt;阶段 4：服务网格&lt;/h3&gt;
&lt;p&gt;目前有多种代理为 Service Mesh 提供解决方案，如：&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;、Linkerd 和 Nginx。本文只关注 Envoy 的 Service Mesh。&lt;/p&gt;
&lt;p&gt;Envoy 是针对微服务产生的这些问题设计出来的服务代理。&lt;/p&gt;
&lt;p&gt;Envoy 能够作为 &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SideCar&lt;/a&gt; 运行在每个应用的旁边，形成抽象的应用网络。当基础设施中的所有服务流量通过 Envoy 网格流动时，通过一致的可观察性来问题区域变得容易。&lt;/p&gt;
&lt;p&gt;如下图所示，当把 Envoy 作为 SideCar 添加到服务后，所有微服务的入站和出站流量都通过各自的 Envoy 代理&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-is-service-mesh/7267315bgy1fx1t3tisq1j218g0n4q5x_hu42be8b958c59438e038b330700875a81_25532_1730e114184b88538a311ac62e399d90.webp 400w,
               /blog/why-is-service-mesh/7267315bgy1fx1t3tisq1j218g0n4q5x_hu42be8b958c59438e038b330700875a81_25532_fe1d1dd723e05983b25198bb7a22fd5b.webp 760w,
               /blog/why-is-service-mesh/7267315bgy1fx1t3tisq1j218g0n4q5x_hu42be8b958c59438e038b330700875a81_25532_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/why-is-service-mesh/7267315bgy1fx1t3tisq1j218g0n4q5x_hu42be8b958c59438e038b330700875a81_25532_1730e114184b88538a311ac62e399d90.webp&#34;
               width=&#34;690&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Envoy 拥有许多方便的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持 HTTP,HTTP/2 和 gRPC&lt;/li&gt;
&lt;li&gt;健康检查&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;Metrics&lt;/li&gt;
&lt;li&gt;追踪&lt;/li&gt;
&lt;li&gt;访问日志&lt;/li&gt;
&lt;li&gt;熔断&lt;/li&gt;
&lt;li&gt;重试策略&lt;/li&gt;
&lt;li&gt;超时配置&lt;/li&gt;
&lt;li&gt;限速&lt;/li&gt;
&lt;li&gt;支持 Statsd、Prometheus&lt;/li&gt;
&lt;li&gt;流量迁移&lt;/li&gt;
&lt;li&gt;通过发现服务来动态调整配置（XDS）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等……&lt;/p&gt;
&lt;p&gt;所以通过从服务中抽象出整个网络，使用 Envoy 作为 SideCar 形成网格组成数据平面，允许我们控制上面列出的能力。&lt;/p&gt;
&lt;p&gt;欢迎反馈，谢谢！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在 Play with Kubernetes 平台上以测试驱动的方式部署 Istio</title>
      <link>https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/</link>
      <pubDate>Fri, 07 Sep 2018 12:33:30 +0800</pubDate>
      <guid>https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/</guid>
      <description>&lt;p&gt;















&lt;figure  id=&#34;figure-kubernetes-and-istio&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Kubernetes and Istio&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fux7dq9d14j20jg08cju2_hu2d0285b1ada3d20ff2915158b30e26fb_33356_77bce4fa9daf2f947cec32d369b4d765.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fux7dq9d14j20jg08cju2_hu2d0285b1ada3d20ff2915158b30e26fb_33356_e8c30d30010abe99a1a872293cd753da.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fux7dq9d14j20jg08cju2_hu2d0285b1ada3d20ff2915158b30e26fb_33356_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fux7dq9d14j20jg08cju2_hu2d0285b1ada3d20ff2915158b30e26fb_33356_77bce4fa9daf2f947cec32d369b4d765.webp&#34;
               width=&#34;700&#34;
               height=&#34;300&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Kubernetes and Istio
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://www.knowledgehut.com/blog/cloud-computing/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;作为一名全栈开发，假如最近花了不少时间开发应用，肯定已经理解了微服务架构下要面临的一系列全新挑战。尽管应用已经从庞大的单体应用转变成了开发更快、弹性更好、更小也更聚焦的微服务，但现实是，开发者需要开始操心将这些服务集成到分布式系统中的问题了，包括服务发现、负载均衡、注册、容错、监控、路由、兼容和安全等。&lt;/p&gt;
&lt;p&gt;让我们更详细的拆解微服务架构下开发和运维面临的挑战吧。先来看看第一代简单的 Service Mesh 场景，如下图所示，服务 A 要和 服务 B 通信，没有采用直接通信的方式，请求是通过 NGINX 路由的。NGINX 从 Consul（服务发现工具）查找路由，并在收到 HTTP 502 响应时，自动重试。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-10---一代-service-mesh&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1.0 - 一代 Service Mesh&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fux7wkxxawj20jg08cmz4_hu986e4ca836c26460b3b5ce9ca9ea8940_30458_7508c99b12f7e309c95b3560c25c7da6.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fux7wkxxawj20jg08cmz4_hu986e4ca836c26460b3b5ce9ca9ea8940_30458_1e63eeadaaab9148a321ceb92a5de387.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fux7wkxxawj20jg08cmz4_hu986e4ca836c26460b3b5ce9ca9ea8940_30458_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fux7wkxxawj20jg08cmz4_hu986e4ca836c26460b3b5ce9ca9ea8940_30458_7508c99b12f7e309c95b3560c25c7da6.webp&#34;
               width=&#34;700&#34;
               height=&#34;300&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1.0 - 一代 Service Mesh
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-11---服务增多时级联失败演示&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1.1 - 服务增多时，级联失败演示&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fux7ybax2rj20jg09pgpc_hu71e0af72e28043baa89d67c2a561e223_49105_003400c39b69aef68a3fa1521c7ef350.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fux7ybax2rj20jg09pgpc_hu71e0af72e28043baa89d67c2a561e223_49105_404a2aa1a06f5feb84562b87195d32f2.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fux7ybax2rj20jg09pgpc_hu71e0af72e28043baa89d67c2a561e223_49105_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fux7ybax2rj20jg09pgpc_hu71e0af72e28043baa89d67c2a561e223_49105_003400c39b69aef68a3fa1521c7ef350.webp&#34;
               width=&#34;700&#34;
               height=&#34;349&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1.1 - 服务增多时，级联失败演示
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;但随着微服务架构的到来，服务数量的增长一发不可收拾，下面列出的是开发和运维团队遇到的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何让日益增长的微服务们互联？&lt;/li&gt;
&lt;li&gt;如何为微服务提供负载均衡？&lt;/li&gt;
&lt;li&gt;为微服务提供基于角色的路由；&lt;/li&gt;
&lt;li&gt;如何控制微服务的出口流量，如何实现灰度发布？&lt;/li&gt;
&lt;li&gt;如何控制不断增长的微服务的复杂度？&lt;/li&gt;
&lt;li&gt;如何用富路由规则实现细粒度的流量控制？&lt;/li&gt;
&lt;li&gt;实现流量加密、服务到服务的鉴权和强身份声明的挑战&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简而言之，虽然你可以在应用和网络中间件中开启服务发现和重试机制，但实际上，想让服务发现正常工作是非常困难的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初试 Istio Service Mesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Service Mesh 是 2018 年度最火热的流行词之一，它是微服务的可配置基础架构层，负责微服务应用间的交互，service mesh 让微服务实例间的交互更灵活、可靠和快速。Mesh 层提供了服务发现、负载均衡、加密、鉴权和验证，支持熔断机制等其他能力。&lt;/p&gt;
&lt;p&gt;Istio 是完全开源的，可透明的部署在已有的分布式应用上。Istio 1.0 版本在上个月发布，已经生产环境可用。Istio 完全由 Go 语言编写，提供成熟的 API 接口可以接入到任何日志平台、遥测和策略系统中。Istio 在 GitHub 上发布，对系统的性能影响很小，丰富的特性让你可以顺利、高效的运行分布式微服务架构，并提供统一的保护、连接和监控方法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-12-istio-功能&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1.2 Istio 功能&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxw8v04rgj20jg09pmyw_hubdd7a3018c238960b6a44f8b8bbe75b8_33894_56505d9505391a88e744410a0ea74c4b.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxw8v04rgj20jg09pmyw_hubdd7a3018c238960b6a44f8b8bbe75b8_33894_b0327bd7770c8788c18a38fcaccbcbb3.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxw8v04rgj20jg09pmyw_hubdd7a3018c238960b6a44f8b8bbe75b8_33894_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxw8v04rgj20jg09pmyw_hubdd7a3018c238960b6a44f8b8bbe75b8_33894_56505d9505391a88e744410a0ea74c4b.webp&#34;
               width=&#34;700&#34;
               height=&#34;349&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1.2 Istio 功能
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Istio 对系统的影响很小，它在 GitHub 上发布，上个月，Istio 1.0 版本已经发布，并且生产环境可用。&lt;/p&gt;
&lt;p&gt;Istio 能带来什么好处呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Istio 提供服务的连接、保护、控制和观测能力。&lt;/li&gt;
&lt;li&gt;减少服务部署的复杂度，减轻部署团队的压力。&lt;/li&gt;
&lt;li&gt;在无需修改应用代码的前提下，为开发和开发运维提供了细粒度的流量可视化和控制。&lt;/li&gt;
&lt;li&gt;为 CIO 提供了帮助全企业安全实施和合规型需求的必要工具。&lt;/li&gt;
&lt;li&gt;在 service mesh 层提供了统一的行为监测和运营控制。&lt;/li&gt;
&lt;li&gt;Istio 让为服务网络提供 HTTP、gRPC、Web Socket 和 TCP 流量的自动负载均衡变的轻松。&lt;/li&gt;
&lt;li&gt;提供了细粒度的流量行为控制，包括：富路由规则、重试、故障转移和失败注入。&lt;/li&gt;
&lt;li&gt;支持插件化的策略控制层和配置 API，支持访问控制、流量限制和配额。&lt;/li&gt;
&lt;li&gt;Istio 为集群内的全部流量提供自动的度量、日志、追踪，包括进群的入口和出口。&lt;/li&gt;
&lt;li&gt;以强身份验证和鉴权的方式，提供了集群内安全的服务间通信。&lt;/li&gt;
&lt;li&gt;如何想深入 Istio 架构，我强烈推荐 Istio 官方网站（https://istio.io/zh）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwajuotmj20jg0dy0uz_hu5579d2de57ace8bffca0b18c2d00ac2d_38613_06d907edd5e4b35c9cfb37d96df10083.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwajuotmj20jg0dy0uz_hu5579d2de57ace8bffca0b18c2d00ac2d_38613_498077f91b775944b6943b73dce8f7dd.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwajuotmj20jg0dy0uz_hu5579d2de57ace8bffca0b18c2d00ac2d_38613_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwajuotmj20jg0dy0uz_hu5579d2de57ace8bffca0b18c2d00ac2d_38613_06d907edd5e4b35c9cfb37d96df10083.webp&#34;
               width=&#34;700&#34;
               height=&#34;502&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开始演示！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章中，我将展示如何在 Play with Kubernetes（PWK）中免费部署 Istio，这是个由 Docker 提供的实验网站，是让用户在几秒钟内跑起来 Kubernetes 集群的试验环境。PWK 提供了在浏览器中使用免费 CentOS Linux 虚拟机的体验，实际上是 Docker-in-Docker（DinD）技术模拟了多虚拟机/PC 的效果。&lt;/p&gt;
&lt;p&gt;打开 &lt;a href=&#34;https://labs.play-with-k8s.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://labs.play-with-k8s.com/&lt;/a&gt;，访问 Kubernetes Playground。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwcxpg13j20jg0dy76k_hub49cf1b90c695bb6d0811745de1e4586_35081_181993ef5ec6070e0848066afe9f3d86.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwcxpg13j20jg0dy76k_hub49cf1b90c695bb6d0811745de1e4586_35081_016070d1cb453b660503fea6519daa35.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwcxpg13j20jg0dy76k_hub49cf1b90c695bb6d0811745de1e4586_35081_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwcxpg13j20jg0dy76k_hub49cf1b90c695bb6d0811745de1e4586_35081_181993ef5ec6070e0848066afe9f3d86.webp&#34;
               width=&#34;700&#34;
               height=&#34;502&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;点击 &amp;ldquo;Login&amp;rdquo; 按钮，以 Docker Hub 或 GitHub ID 登陆。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwdv6kv0j20nq0byaa1_hu2aa8a2fd610d427dbc840f2b0b099b06_17090_6bdb934fd29a7fe8e6144193af79a94a.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwdv6kv0j20nq0byaa1_hu2aa8a2fd610d427dbc840f2b0b099b06_17090_1bf4687bd755fef8b597ae04fdabdad5.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwdv6kv0j20nq0byaa1_hu2aa8a2fd610d427dbc840f2b0b099b06_17090_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwdv6kv0j20nq0byaa1_hu2aa8a2fd610d427dbc840f2b0b099b06_17090_6bdb934fd29a7fe8e6144193af79a94a.webp&#34;
               width=&#34;760&#34;
               height=&#34;383&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;完成本教程，你将获得自己的实验环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加第一个 Kubernetes 节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点击左侧的 &amp;ldquo;Add New Instance&amp;rdquo; 来构建你的第一个 Kubernetes 集群节点，自动命名为 &amp;ldquo;node1&amp;rdquo;，每个节点都预装来 Docker 社区版（CE）和 Kubeadm。这个节点将成为集群的主节点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwf2adjdj211o0nq75d_hud12b4dc6baee5401b14aa183c7e05551_80097_be435c24343ee33b53a7415f4fa6f152.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwf2adjdj211o0nq75d_hud12b4dc6baee5401b14aa183c7e05551_80097_322e414fc842ed4fe929eb580ac4db1d.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwf2adjdj211o0nq75d_hud12b4dc6baee5401b14aa183c7e05551_80097_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwf2adjdj211o0nq75d_hud12b4dc6baee5401b14aa183c7e05551_80097_be435c24343ee33b53a7415f4fa6f152.webp&#34;
               width=&#34;760&#34;
               height=&#34;479&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启动主节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用如下脚本初始化主节点（node1）来启动 Kubernetes 集群，复制该脚本内容到文件 bootstrap.sh，并执行命令添加可执行权限：&lt;code&gt;chmod +x bootstrap.sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwgb83gkj20jg04p75i_hu5c095b90c027690fa7aa6aedfef83109_25271_277b058c5815c37202c2cd03d49d165a.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwgb83gkj20jg04p75i_hu5c095b90c027690fa7aa6aedfef83109_25271_6c212c9612d5270988cb1cc252e1d667.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwgb83gkj20jg04p75i_hu5c095b90c027690fa7aa6aedfef83109_25271_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwgb83gkj20jg04p75i_hu5c095b90c027690fa7aa6aedfef83109_25271_277b058c5815c37202c2cd03d49d165a.webp&#34;
               width=&#34;700&#34;
               height=&#34;169&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;执行脚本时，作为初始化的一部分，kubeadm 会写入几个必要的配置文件、设置 RBAC 并部署 Kubernetes 控制平面组件（例如 kube-apiserver、kube-dns、kube-proxy、etcd 等）。控制平面组件以 docker 容器形式部署。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1mbluj20y004ujrf_hu670deacad2e8485906b65f8c9d571eb1_27505_2066c64f62aeb87c3e3fd810740bcbe3.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1mbluj20y004ujrf_hu670deacad2e8485906b65f8c9d571eb1_27505_a847aa2bc86d7fda2013aea6223f8b66.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1mbluj20y004ujrf_hu670deacad2e8485906b65f8c9d571eb1_27505_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1mbluj20y004ujrf_hu670deacad2e8485906b65f8c9d571eb1_27505_2066c64f62aeb87c3e3fd810740bcbe3.webp&#34;
               width=&#34;760&#34;
               height=&#34;108&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;复制上面的 kubeadm join token 命令，留作下步使用，此命令用来在集群中加入其他节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加从节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点击 &amp;ldquo;Add New Node&amp;rdquo; 添加新的从节点&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ncf3j20sj0a3aam_hue994705c28a318b1fe6600d332679dad_98316_ed8e2f6f517a327f6c8c539b36f6f133.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ncf3j20sj0a3aam_hue994705c28a318b1fe6600d332679dad_98316_39be71f6f8544012b0bd653da9e7a014.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ncf3j20sj0a3aam_hue994705c28a318b1fe6600d332679dad_98316_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ncf3j20sj0a3aam_hue994705c28a318b1fe6600d332679dad_98316_ed8e2f6f517a327f6c8c539b36f6f133.webp&#34;
               width=&#34;760&#34;
               height=&#34;268&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证集群状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1moxsj20h304rmxc_hu62ac9467b4560cccef4be76b1893d9a0_27160_986de696393961cb763352aabf489bbf.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1moxsj20h304rmxc_hu62ac9467b4560cccef4be76b1893d9a0_27160_845200f755e929770236835fe6a6e4de.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1moxsj20h304rmxc_hu62ac9467b4560cccef4be76b1893d9a0_27160_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1moxsj20h304rmxc_hu62ac9467b4560cccef4be76b1893d9a0_27160_986de696393961cb763352aabf489bbf.webp&#34;
               width=&#34;615&#34;
               height=&#34;171&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证运行的 Pods&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1scslj20to0bfmyo_hud4d6ad7bffe62e2c8212999296762549_93935_9cccd03c83e20c7581e1542c1f3a6f5c.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1scslj20to0bfmyo_hud4d6ad7bffe62e2c8212999296762549_93935_dbfab46a8bf4367a2c9935bc71f9e08e.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1scslj20to0bfmyo_hud4d6ad7bffe62e2c8212999296762549_93935_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1scslj20to0bfmyo_hud4d6ad7bffe62e2c8212999296762549_93935_9cccd03c83e20c7581e1542c1f3a6f5c.webp&#34;
               width=&#34;760&#34;
               height=&#34;293&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装 Istio 1.0.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Istio 部署在单独的 Kubernetes 命名空间里：istio-system，我们过后再来验证。现在，复制如下内容到文件，命名为 install_istio.sh，并保存。添加可执行权限，运行以安装 Istio 和相关工具。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1oor0j20jg05mgn0_hu1667bcfd21fcfe7a2ed951fa03a6b718_29553_a72aed3de45e3324d8903187b03b7893.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1oor0j20jg05mgn0_hu1667bcfd21fcfe7a2ed951fa03a6b718_29553_9bebd5252ec30afc9e2a3118a8cff355.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1oor0j20jg05mgn0_hu1667bcfd21fcfe7a2ed951fa03a6b718_29553_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1oor0j20jg05mgn0_hu1667bcfd21fcfe7a2ed951fa03a6b718_29553_a72aed3de45e3324d8903187b03b7893.webp&#34;
               width=&#34;700&#34;
               height=&#34;202&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;屏幕上应显示如下内容：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ue42j20k70fb75x_hu159ec87e4aa6eea9bd4735b966e72ea7_116687_2367e1ff6ded24965ab493217303bdf5.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ue42j20k70fb75x_hu159ec87e4aa6eea9bd4735b966e72ea7_116687_099e5c12e23d5aa4108e5bc425248945.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ue42j20k70fb75x_hu159ec87e4aa6eea9bd4735b966e72ea7_116687_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ue42j20k70fb75x_hu159ec87e4aa6eea9bd4735b966e72ea7_116687_2367e1ff6ded24965ab493217303bdf5.webp&#34;
               width=&#34;727&#34;
               height=&#34;551&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如上所示，默认会安装 Prometheus、ServiceGraph、Jaeger、Grafana 和 Zipkin。&lt;/p&gt;
&lt;p&gt;请注意：运行该脚本时，可能会报如下错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;unable to recognize &lt;span class=&#34;s2&#34;&gt;&amp;#34;install/kubernetes/istio-demo.yaml&amp;#34;&lt;/span&gt;: no matches &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; admissionregistration.k8s.io/, &lt;span class=&#34;nv&#34;&gt;Kind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;MutatingWebhookConfiguration
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是正常的，命令一执行完，可在页面的中央看到一长串展示的端口。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1uh9aj20u40jkmz5_hu4326002a2cbed9240a3c87f5c6dd1676_125811_31c0ef15e90b8dbb9344c296a13bedc5.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1uh9aj20u40jkmz5_hu4326002a2cbed9240a3c87f5c6dd1676_125811_2e7062681320a00ca11025cee02cda0e.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1uh9aj20u40jkmz5_hu4326002a2cbed9240a3c87f5c6dd1676_125811_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1uh9aj20u40jkmz5_hu4326002a2cbed9240a3c87f5c6dd1676_125811_31c0ef15e90b8dbb9344c296a13bedc5.webp&#34;
               width=&#34;760&#34;
               height=&#34;493&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1wesej20u40jkmz5_hu4326002a2cbed9240a3c87f5c6dd1676_125811_16bd8926e826a4f904f1eb04c70bbbe4.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1wesej20u40jkmz5_hu4326002a2cbed9240a3c87f5c6dd1676_125811_372155a367ae1c3bf6b4a12486a59ba8.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1wesej20u40jkmz5_hu4326002a2cbed9240a3c87f5c6dd1676_125811_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1wesej20u40jkmz5_hu4326002a2cbed9240a3c87f5c6dd1676_125811_16bd8926e826a4f904f1eb04c70bbbe4.webp&#34;
               width=&#34;760&#34;
               height=&#34;493&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1wxc3j20x10f175z_hubf03ea41a9a5a1435e4d06559d234e4a_87416_c434a23647079564da8c0bc8208eedd6.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1wxc3j20x10f175z_hubf03ea41a9a5a1435e4d06559d234e4a_87416_d59d7bab69f943a242c6ea6a768ab454.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1wxc3j20x10f175z_hubf03ea41a9a5a1435e4d06559d234e4a_87416_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1wxc3j20x10f175z_hubf03ea41a9a5a1435e4d06559d234e4a_87416_c434a23647079564da8c0bc8208eedd6.webp&#34;
               width=&#34;760&#34;
               height=&#34;346&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;暴露服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要暴露 Prometheus、Grafana 和 服务图标服务，需要先删除已有的服务，用 NodePort 替换 ClusterIP，用实例页顶端展示的端口访问服务（如下所示）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1oduej210g07ywfj_hudeab987f30e90c933e21a9cc36be2332_53593_6fed682bbc925a955e8cfb093554a5a3.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1oduej210g07ywfj_hudeab987f30e90c933e21a9cc36be2332_53593_142f14c4820330ff44d274d7f5c87762.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1oduej210g07ywfj_hudeab987f30e90c933e21a9cc36be2332_53593_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1oduej210g07ywfj_hudeab987f30e90c933e21a9cc36be2332_53593_6fed682bbc925a955e8cfb093554a5a3.webp&#34;
               width=&#34;760&#34;
               height=&#34;166&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1x12ej20z80eogn8_hu2203381c9f145fad603b7a69bc8b4aea_103834_2bd8dd7559a7a66285bdc85f9860eb96.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1x12ej20z80eogn8_hu2203381c9f145fad603b7a69bc8b4aea_103834_ac74334aca80ff147c5116b92a1c517d.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1x12ej20z80eogn8_hu2203381c9f145fad603b7a69bc8b4aea_103834_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1x12ej20z80eogn8_hu2203381c9f145fad603b7a69bc8b4aea_103834_2bd8dd7559a7a66285bdc85f9860eb96.webp&#34;
               width=&#34;760&#34;
               height=&#34;316&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;点击 &amp;ldquo;30004&amp;rdquo; 访问 Grafana 页，点击 &amp;ldquo;30003&amp;rdquo; 访问 Prometheus 页。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ysfbj21350ofjsy_hu5c59c405abed83b654949323a016f9fc_95923_5933bb572e7058c573711771a4e1ed3d.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ysfbj21350ofjsy_hu5c59c405abed83b654949323a016f9fc_95923_3c43fa5b0f4a280d647fc525a785f56d.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ysfbj21350ofjsy_hu5c59c405abed83b654949323a016f9fc_95923_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ysfbj21350ofjsy_hu5c59c405abed83b654949323a016f9fc_95923_5933bb572e7058c573711771a4e1ed3d.webp&#34;
               width=&#34;760&#34;
               height=&#34;474&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1oe4rj213z0ivq3r_hu3977c7b2e0867d230d6d2a215f0342e6_33692_4945210f57a78230f9fccc90a8fcdc3d.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1oe4rj213z0ivq3r_hu3977c7b2e0867d230d6d2a215f0342e6_33692_4c9b773a15512c5d0c26f1e2a65c1f34.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1oe4rj213z0ivq3r_hu3977c7b2e0867d230d6d2a215f0342e6_33692_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1oe4rj213z0ivq3r_hu3977c7b2e0867d230d6d2a215f0342e6_33692_4945210f57a78230f9fccc90a8fcdc3d.webp&#34;
               width=&#34;760&#34;
               height=&#34;359&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可以如下图所示，选择必要配置查看 Prometheus 度量：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1olhxj20rp0fl3yr_hu5931d4cd1b137f87a6237d65794124ba_45891_302ce5bec44f7c37b7d8f44b92318d3c.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1olhxj20rp0fl3yr_hu5931d4cd1b137f87a6237d65794124ba_45891_62101737ce1cc76379bfaf46c0d86d02.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1olhxj20rp0fl3yr_hu5931d4cd1b137f87a6237d65794124ba_45891_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1olhxj20rp0fl3yr_hu5931d4cd1b137f87a6237d65794124ba_45891_302ce5bec44f7c37b7d8f44b92318d3c.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 Grafana 页，添加 Prometheus 数据源，并确认 Dashboard 已经运行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1pomvj20hs0ixdgh_hu2bfd5f8c2c1e5e378755474c4a1e6e37_51162_7d7c46e4ca35033cb83e6788ce3e3760.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1pomvj20hs0ixdgh_hu2bfd5f8c2c1e5e378755474c4a1e6e37_51162_b6003a2244c324e1fadf04cbb97833d1.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1pomvj20hs0ixdgh_hu2bfd5f8c2c1e5e378755474c4a1e6e37_51162_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1pomvj20hs0ixdgh_hu2bfd5f8c2c1e5e378755474c4a1e6e37_51162_7d7c46e4ca35033cb83e6788ce3e3760.webp&#34;
               width=&#34;640&#34;
               height=&#34;681&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;恭喜！你已经将 Istio 部署在 Kubernetes 集群上了，K8S playgroud 上已经安装的服务包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Istio Controllers，以及相关 RBAC 规则&lt;/li&gt;
&lt;li&gt;Istio 定制资源定义&lt;/li&gt;
&lt;li&gt;Prometheus 和 Grafana 监控系统&lt;/li&gt;
&lt;li&gt;Jeager 分布式追踪系统&lt;/li&gt;
&lt;li&gt;Istio Sidecar 注入程序（下一节我们再来仔细看看）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;安装 Istioctl&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Istioctl 是 Istio 的命令行配置工具，可以用来创建、查询、修改和删除 Istio 系统的配置资源。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1qvitj213v06it97_hu4694c48e1e44ab52003db05cbf57b28f_25280_0f36f7cf6f83d9e26244d6952982828f.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1qvitj213v06it97_hu4694c48e1e44ab52003db05cbf57b28f_25280_e9165a07d9191ec8d60ad5889346a44c.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1qvitj213v06it97_hu4694c48e1e44ab52003db05cbf57b28f_25280_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1qvitj213v06it97_hu4694c48e1e44ab52003db05cbf57b28f_25280_0f36f7cf6f83d9e26244d6952982828f.webp&#34;
               width=&#34;760&#34;
               height=&#34;124&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部署 BookInfo 应用示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Istio 已经安装并验证过了，可以在上面部署示例应用 BookInfo 了，这是一个简单的书店模拟应用，由四个服务组成：网站首页、书籍信息、评论（几个特定的版本有评论服务）和评分，全部由 Istio 管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部署 BookInfo 服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj247c0j20jg07gdhv_hu9405f3d311b5861d755bb2c39e44d87b_40257_fc80dee31301b2c687f2facee6c2d4f9.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj247c0j20jg07gdhv_hu9405f3d311b5861d755bb2c39e44d87b_40257_fee6d2aed967d19cd85d66e4e7345cf4.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj247c0j20jg07gdhv_hu9405f3d311b5861d755bb2c39e44d87b_40257_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj247c0j20jg07gdhv_hu9405f3d311b5861d755bb2c39e44d87b_40257_fc80dee31301b2c687f2facee6c2d4f9.webp&#34;
               width=&#34;700&#34;
               height=&#34;268&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义入口网关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1rru2j20jg03xdgu_hu7f92f73c25d47e3cd95f1f488f29c1e7_23523_d3655d713dc4dbf89a509d5f47baece2.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1rru2j20jg03xdgu_hu7f92f73c25d47e3cd95f1f488f29c1e7_23523_6fcab8375b48098d8d2c988952f30907.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1rru2j20jg03xdgu_hu7f92f73c25d47e3cd95f1f488f29c1e7_23523_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1rru2j20jg03xdgu_hu7f92f73c25d47e3cd95f1f488f29c1e7_23523_d3655d713dc4dbf89a509d5f47baece2.webp&#34;
               width=&#34;700&#34;
               height=&#34;141&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证 BookInfo 应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj280kwj20jg0d8aew_hue9c3c31ceb0a4772b8718f8269a0ab6e_84047_8c0ac90e52b0423d401304a501419549.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj280kwj20jg0d8aew_hue9c3c31ceb0a4772b8718f8269a0ab6e_84047_d387b97e84b2777cc1c2da1e3d8dc2b2.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj280kwj20jg0d8aew_hue9c3c31ceb0a4772b8718f8269a0ab6e_84047_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj280kwj20jg0d8aew_hue9c3c31ceb0a4772b8718f8269a0ab6e_84047_8c0ac90e52b0423d401304a501419549.webp&#34;
               width=&#34;700&#34;
               height=&#34;476&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj27k0kj20jg0k57b9_hue9a855b14b3311390336f95e1c54b604_126247_dba503204a83f16005d88829115b282a.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj27k0kj20jg0k57b9_hue9a855b14b3311390336f95e1c54b604_126247_293a7e1eecb9790f2a253a5f5df09f89.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj27k0kj20jg0k57b9_hue9a855b14b3311390336f95e1c54b604_126247_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj27k0kj20jg0k57b9_hue9a855b14b3311390336f95e1c54b604_126247_dba503204a83f16005d88829115b282a.webp&#34;
               width=&#34;700&#34;
               height=&#34;725&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过 URL 访问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj28b2bj20jg07rwhd_hueac79bbef050b2966b47067cbd0616f5_53599_7db9e7fc68752d555a53a4edceafee85.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj28b2bj20jg07rwhd_hueac79bbef050b2966b47067cbd0616f5_53599_fe4886e326a15d7749c09337902c12d6.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj28b2bj20jg07rwhd_hueac79bbef050b2966b47067cbd0616f5_53599_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj28b2bj20jg07rwhd_hueac79bbef050b2966b47067cbd0616f5_53599_7db9e7fc68752d555a53a4edceafee85.webp&#34;
               width=&#34;700&#34;
               height=&#34;279&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;现在应该可以看到 BookInfo 示例了：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ycp2j20jg07rjtf_hu93474c0a01ce512fb07b7545a9038785_33735_ab268eaf70de0787e340151b7f4d109c.webp 400w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ycp2j20jg07rjtf_hu93474c0a01ce512fb07b7545a9038785_33735_ad293810a6489c20d49c31df731437fa.webp 760w,
               /blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ycp2j20jg07rjtf_hu93474c0a01ce512fb07b7545a9038785_33735_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/test-drive-your-first-istio-deployment-using-play-with-kubernetes-platform-cloud-computing/6286a305ly1fuxwj1ycp2j20jg07rjtf_hu93474c0a01ce512fb07b7545a9038785_33735_ab268eaf70de0787e340151b7f4d109c.webp&#34;
               width=&#34;700&#34;
               height=&#34;279&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;希望本部程能帮你顺利的在 Kubernetes 上部署 Istio。下一篇博客，我将深入 Istio 的内部架构、流量控制、权限和遥测等细节。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>后 Kubernetes 时代的微服务</title>
      <link>https://cloudnative.to/blog/microservices-post-kubernetes/</link>
      <pubDate>Fri, 07 Sep 2018 12:27:58 +0800</pubDate>
      <guid>https://cloudnative.to/blog/microservices-post-kubernetes/</guid>
      <description>&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/microservices-post-kubernetes/006tNbRwgy1fuxayjq7oej30n30ammzp_hua7840311ccb6311909cac31223d2a931_74411_9fb5de56134c55b184ad9723c2e3b3de.webp 400w,
               /blog/microservices-post-kubernetes/006tNbRwgy1fuxayjq7oej30n30ammzp_hua7840311ccb6311909cac31223d2a931_74411_8aa54a433a77bc5957e1353efd532023.webp 760w,
               /blog/microservices-post-kubernetes/006tNbRwgy1fuxayjq7oej30n30ammzp_hua7840311ccb6311909cac31223d2a931_74411_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-post-kubernetes/006tNbRwgy1fuxayjq7oej30n30ammzp_hua7840311ccb6311909cac31223d2a931_74411_9fb5de56134c55b184ad9723c2e3b3de.webp&#34;
               width=&#34;760&#34;
               height=&#34;349&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;关键要点&#34;&gt;关键要点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;微服务架构仍然是分布式系统最流行的架构风格。但 Kubernetes 和云原生运动已经在很大程度上重新定义了应用程序的设计和开发。&lt;/li&gt;
&lt;li&gt;在云原生平台上，服务的可观察性是不够的。更基本的先决条件是通过实施健康检查，对信号做出反应，声明资源消耗等，使微服务自动化。&lt;/li&gt;
&lt;li&gt;在后 Kubernetes 时代，服务网格技术将完全取代使用库来实现操作网络问题（例如 Hystrix 断路器）。&lt;/li&gt;
&lt;li&gt;微服务现在必须通过从多个维度实现幂等性来设计用于“恢复”。&lt;/li&gt;
&lt;li&gt;现代开发人员必须精通编程语言以实现业务功能，并且同样精通云原生技术以满足非功能性基础架构级别要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;微服务炒作开始于一堆关于组织结构、团队规模、服务规模、重写和抛出服务而不是修复、避免单元测试等的极端想法。根据我的经验，大多数这些想法被证明是错误的，不实用的或者至少不通用。如今，大多数剩余的原则和实践都是如此通用和松散地定义，以至于它们可能在未来许多年内都会成立，而在实践中却没有多大意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 Kubernetes 诞生的前几年微服务还是分布式系统最流行的架构风格。但 Kubernetes 和云原生运动已经改变了应用程序设计和开发的方方面面。在本文中，我要质疑微服务的一些理念，指明它们在后 Kubernetes 时代不会再像以前那样强大。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;不仅可观察而且还有自动化服务&#34;&gt;不仅可观察，而且还有自动化服务&lt;/h2&gt;
&lt;p&gt;可观察性从一开始就是微服务的基本原则。虽然对于一般的分布式系统来说它是正确的，但今天（特别是在 Kubernetes 上），它的很大一部分是平台级别的开箱即用（例如进程运行状况检查、CPU 和内存消耗）。最低要求是应用程序以 JSON 格式登录控制台。从那时起，平台可以跟踪资源消耗、请求跟踪、收集所有类型的指标、错误率等，而无需太多的服务级别开发工作。&lt;/p&gt;
&lt;p&gt;在云原生平台上，可观察性是不够的。更基本的先决条件是通过实施健康检查，对信号做出反应，声明资源消耗等使微服务&lt;a href=&#34;https://www.redhat.com/en/resources/cloud-native-container-design-whitepaper&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;自动化&lt;/a&gt; 。可以将几乎任何应用程序放入容器中运行。但是要创建一个容器化的应用程序，可以通过云原生平台自动化和协调编排，需要遵循一定的规则。遵循这些 &lt;a href=&#34;https://leanpub.com/k8spatterns/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;原则和模式&lt;/a&gt; ，将确保生成的容器在大多数容器编排引擎中表现得像一个优秀的云原生公民，允许以自动方式对它们进行调度、扩展和监控。&lt;/p&gt;
&lt;p&gt;我们希望平台不必观察服务中发生的情况，而是希望平台检测异常情况并按照声明进行协调。无论是通过停止将流量导向服务实例、重启、向上和向下扩展，还是将服务迁移到另一个健康主机，重试失败的请求或其他，这都无关紧要。如果服务是自动化的，则所有纠正措施都会自动发生，我们只需要描述所需的状态，而不是观察和反应。服务应该是可观察的，但也可以在没有人为干预的情况下通过平台自动进行整改。&lt;/p&gt;
&lt;h2 id=&#34;智能平台和智能服务但有正确的责任&#34;&gt;智能平台和智能服务，但有正确的责任&lt;/h2&gt;
&lt;p&gt;在从 SOA 转向微服务世界的过程中， &lt;a href=&#34;https://martinfowler.com/articles/microservices.html#SmartEndpointsAndDumbPipes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;“智能端点和哑管”&lt;/a&gt;的概念是服务交互的另一个根本转变。在微服务领域，服务不依赖于集中式智能路由层的存在，而是依赖于拥有某些平台级功能的智能端点。这是通过在每个微服务中嵌入传统 ESB 的一些功能并转换到没有业务逻辑元素的轻量级协议来实现的。&lt;/p&gt;
&lt;p&gt;虽然这仍然是在不可靠的网络层（使用 &lt;a href=&#34;https://github.com/Netflix/Hystrix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hystrix&lt;/a&gt; 等库）实现服务交互的流行方式，但现在，在后 Kubernetes 时代，它已经完全被&lt;a href=&#34;https://www.cncf.io/blog/2017/04/26/service-mesh-critical-component-cloud-native-stack/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格&lt;/a&gt;技术所取代。有趣的是，服务网格甚至比传统的 ESB 更智能。网格可以执行动态路由、服务发现、基于延迟的负载平衡、响应类型、指标和分布式跟踪、重试、超时，你能想到的这里都有。&lt;/p&gt;
&lt;p&gt;与 ESB 的不同之处在于，与服务网格不同的是，只有一个集中路由层，每个微服务通常都有自己的路由器—— 一个带有附加中央管理层的代理逻辑的 sidecar 容器。更重要的是，管道（平台和服务网格）没有任何业务逻辑；它们完全专注于基础架构方面，使服务专注于业务逻辑。如图所示，这代表了 ESB 和微服务学习的演变，以适应云环境的动态和不可靠特性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/microservices-post-kubernetes/006tSBxtly1fuwq6pf4fyj30gn057gnd_huedb820b3ccf8f8bf07481e72aef53dfe_28632_6e3bbbde7f94573b9686a25baad13ce2.webp 400w,
               /blog/microservices-post-kubernetes/006tSBxtly1fuwq6pf4fyj30gn057gnd_huedb820b3ccf8f8bf07481e72aef53dfe_28632_380c39b6dfa26505c58a26c89d1b2fa8.webp 760w,
               /blog/microservices-post-kubernetes/006tSBxtly1fuwq6pf4fyj30gn057gnd_huedb820b3ccf8f8bf07481e72aef53dfe_28632_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-post-kubernetes/006tSBxtly1fuwq6pf4fyj30gn057gnd_huedb820b3ccf8f8bf07481e72aef53dfe_28632_6e3bbbde7f94573b9686a25baad13ce2.webp&#34;
               width=&#34;599&#34;
               height=&#34;187&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SOA vs MSA 与 CNA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看服务的其他方面，我们注意到云原生不仅影响端点和服务交互。Kubernetes 平台（包含所有其他技术）还负责资源管理、调度、部署、配置管理、扩展、服务交互等。而不是再次将其称为“智能代理和哑管”，我认为它更好地描述作为一个具有正确职责的智能平台和智能服务。这不仅仅是关于端点；它是一个完整的平台，可以自动化业务功能服务的所有基础架构方面。&lt;/p&gt;
&lt;h2 id=&#34;不要面向失败而设计要面向恢复设计&#34;&gt;不要面向失败而设计，要面向恢复设计&lt;/h2&gt;
&lt;p&gt;在基础架构和网络本身不可靠的云原生环境中运行的微服务必须针对故障进行设计。这毫无疑问。但是平台检测到并处理了越来越多的故障，并且从微服务中捕获故障的量较少。相反，考虑通过从多个维度实现幂等性来设计您的恢复服务。&lt;/p&gt;
&lt;p&gt;容器技术、容器编排器和服务网络可以检测并从许多故障中恢复：无限循环——CPU 分配、内存泄漏和 OOM——运行状况检查、磁盘占用——配额、fork 炸弹——进程限制、批量处理和进程隔离——内存限制、延迟和基于响应的服务发现、重试、超时、自动扩展等等。更不用说，过渡到无服务器模型，服务只需要在几毫秒内处理一个请求，而垃圾收集、线程池、资源泄漏也越来越不需要关心。&lt;/p&gt;
&lt;p&gt;通过平台处理所有这些以及更多内容，将您的服务视为一个密封的黑盒子，它将多次启动和停止，使服务能够重新启动。您的服务将按比例放大和缩小倍数，通过使其无状态，使其可以安全地进行扩展。假设许多传入请求最终会超时，使端点具有幂等性。假设许多传出请求将暂时失败，平台将为您重试它们，确保您使用幂等服务。&lt;/p&gt;
&lt;p&gt;为了适合云原生环境中的自动化，服务必须是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;幂等重启（服务可以被杀死并多次启动）。&lt;/li&gt;
&lt;li&gt;幂等扩展/缩小（服务可以自动扩展到多个实例）。&lt;/li&gt;
&lt;li&gt;幂等服务生产者（其他服务可能会重试调用）。&lt;/li&gt;
&lt;li&gt;幂等服务使用者（服务或网状网可以重试传出调用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果您执行上述操作一次或多次时服务的行为始终相同，那么平台将能够在没有人为干预的情况下从故障中恢复您的服务。&lt;/p&gt;
&lt;p&gt;最后，请记住，平台提供的所有恢复只是本地优化。&lt;a href=&#34;http://blog.christianposta.com/microservices/application-safety-and-correctness-cannot-be-offloaded-to-istio-or-any-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;正如 Christian Posta 所说的那样&lt;/a&gt; ，分布式系统中的应用程序安全性和正确性仍然是应用程序的责任。整个业务流程范围的思维模式（可能跨越多个服务）对于设计整体稳定的系统是必要的。&lt;/p&gt;
&lt;h2 id=&#34;混合开发职责&#34;&gt;混合开发职责&lt;/h2&gt;
&lt;p&gt;越来越多的微服务原则被 Kubernetes 及其补充项目实施和提供。因此，开发人员必须精通编程语言以实现业务功能，并且同样精通云原生技术以满足非功能性基础架构级别要求，同时完全实现功能。&lt;/p&gt;
&lt;p&gt;业务需求和基础架构（操作或跨功能需求或系统质量属性）之间的界限总是模糊不清，并且不可能采取一个方面并期望其他人做另一个方面。例如，如果在服务网格层中实现重试逻辑，则必须使服务中的业务逻辑或数据库层使用的服务具有幂等性。如果在服务网格级别使用超时，则必须同步服务中的服务使用者超时。如果必须实现服务的重复执行，则必须配置 Kubernetes 作业执行。&lt;/p&gt;
&lt;p&gt;展望未来，一些服务功能将作为业务逻辑在服务中实现，而其他服务功能则作为平台功能提供。虽然使用正确的工具来完成正确的任务是一个很好的责任分离，但技术的激增极大地增加了整体的复杂性。在业务逻辑方面实现简单的服务需要很好地理解分布式技术堆栈，因为责任分散在每一层。&lt;/p&gt;
&lt;p&gt;据 &lt;a href=&#34;https://kubernetes.io/blog/2016/03/1000-nodes-and-beyond-updates-to-kubernetes-performance-and-scalability-in-12/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;证实&lt;/a&gt; Kubernetes 是可以扩展到数千个节点、数万个 pod 和数百万的 TPS。您的应用程序大小、复杂性，或者说是引入“云原生”复杂性的关键性因素，我还不清楚。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;有趣的是，微服务运动如何为采用 Docker 和 Kubernetes 等容器技术提供了如此大的动力。虽然最初是推动这些技术发展的微服务实践，但现在 Kubernetes 定义了微服务架构的原则和实践。&lt;/p&gt;
&lt;p&gt;最近的一个例子，我们距离接受函数模型作为有效的微服务原语并不远，而不是将其视为纳米服务的反模式。我们并没有充分的理由质疑云原生技术对于中小型案例的实用性和适用性，而是因为兴奋而有些不经意地跳了起来。&lt;/p&gt;
&lt;p&gt;Kubernetes 拥有 ESB 和微服务的许多知识，因此，它是最终的分布式系统平台。它是架构风格的技术，而不是相反的方式。无论好坏，时间会证明一切。&lt;/p&gt;
&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/microservices-post-kubernetes/006tSBxtly1fuwq6p5tm2j302d02sq2y_hua08a9484b78171d94a00c1fbb20e5704_3627_da83ca96df338c2ad904f31ef8ef70fe.webp 400w,
               /blog/microservices-post-kubernetes/006tSBxtly1fuwq6p5tm2j302d02sq2y_hua08a9484b78171d94a00c1fbb20e5704_3627_dcd7453b9cfe1361cab941f1ccdc52da.webp 760w,
               /blog/microservices-post-kubernetes/006tSBxtly1fuwq6p5tm2j302d02sq2y_hua08a9484b78171d94a00c1fbb20e5704_3627_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/microservices-post-kubernetes/006tSBxtly1fuwq6p5tm2j302d02sq2y_hua08a9484b78171d94a00c1fbb20e5704_3627_da83ca96df338c2ad904f31ef8ef70fe.webp&#34;
               width=&#34;85&#34;
               height=&#34;100&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bilgin Ibryam&lt;/strong&gt;  （@bibryam）是 Red Hat 的首席架构师，提交者和 ASF 成员。他是一名开源传播者，博客作者，《Camel Design Patterns》和《Kubernetes Patterns》书籍的作者。在他的日常工作中，Bilgin 喜欢指导编码和领导开发人员成功构建云原生解决方案。他目前的工作重点是应用程序集成、分布式系统、消息传递、微服务、devops 和一般的云原生挑战。你可以在  &lt;a href=&#34;https://twitter.com/bibryam&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Twitter&lt;/a&gt;、&lt;a href=&#34;https://uk.linkedin.com/in/bibryam&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkedin&lt;/a&gt;  或他的  &lt;a href=&#34;http://www.ofbizian.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt; 上找到他。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>微服务中的 Sidecar 设计模式解析</title>
      <link>https://cloudnative.to/blog/sidecar-design-pattern-in-microservices-ecosystem/</link>
      <pubDate>Thu, 02 Aug 2018 15:32:40 +0800</pubDate>
      <guid>https://cloudnative.to/blog/sidecar-design-pattern-in-microservices-ecosystem/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://dotnetvibes.com/2018/07/23/sidecar-design-pattern-in-your-microservices-ecosystem/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Sidecar 设计模式已经越来越受欢迎，并在社区内得到更广泛的采用。构建具有高度可扩展性、弹性、安全性和可观察性的微服务架构具有挑战性。&lt;strong&gt;Service Mesh 架构&lt;/strong&gt;的发展已经改变了游戏规则。它降低了与微服务架构相关的复杂性，并提供了许多功能，如负载平衡、服务发现、流量管理、熔断、遥测、故障注入等。&lt;/p&gt;
&lt;p&gt;阅读我之前的博客能够了解 Service Mesh 的概念，为什么云原生应用需要它以及它受欢迎的原因——&lt;a href=&#34;https://dotnetvibes.com/2018/07/02/the-rise-of-service-mesh-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格架构的兴起&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;什么是-sidecar-模式&#34;&gt;什么是 Sidecar 模式&lt;/h2&gt;
&lt;p&gt;将应用程序的功能划分为单独的进程可以被视为 &lt;strong&gt;Sidecar 模式&lt;/strong&gt;。Sidecar 设计模式允许你为应用程序添加许多功能，而无需额外第三方组件的配置和代码。&lt;/p&gt;
&lt;p&gt;就如 Sidecar 连接着摩托车一样，类似地在软件架构中，Sidecar 应用是连接到父应用并且为其扩展或者增强功能。Sidecar 应用与主应用程序松散耦合。&lt;/p&gt;
&lt;p&gt;让我用一个例子解释一下。想象一下假如你有 6 个微服务相互通信以确定一个包裹的成本。&lt;/p&gt;
&lt;p&gt;每个微服务都需要具有可观察性、监控、日志记录、配置、断路器等功能。所有这些功能都是根据一些行业标准的第三方库在每个微服务中实现的。&lt;/p&gt;
&lt;p&gt;但再想一想，这不是多余吗？它不会增加应用程序的整体复杂性吗？如果你的应用程序是用不同的语言编写时会发生什么——如何合并那些特定用于 .Net、Java、Python 等语言的第三方库。&lt;/p&gt;
&lt;h2 id=&#34;使用-sidecar-模式的优势&#34;&gt;使用 Sidecar 模式的优势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过抽象出与功能相关的共同基础设施到一个不同层降低了微服务代码的复杂度。&lt;/li&gt;
&lt;li&gt;因为你不再需要编写相同的第三方组件配置文件和代码，所以能够降低微服务架构中的代码重复度。&lt;/li&gt;
&lt;li&gt;降低应用程序代码和底层平台的耦合度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sidecar-模式是如何工作的&#34;&gt;Sidecar 模式是如何工作的&lt;/h2&gt;
&lt;p&gt;服务网格层可以存在于与应用程序一起运行的 Sidecar 容器中。每个应用程序旁边都附有相同 Sidecar 的副本。&lt;/p&gt;
&lt;p&gt;来自单个服务的所有传入和传出网络流量都流经 Sidecar 代理。因此，Sidecar 能够管理微服务之间的流量，收集遥测数据并实施相关策略。从某种意义上说，该服务不了解整个网络，只知道附加的 Sidecar 代理。这实际上就是 Sidecar 模式如何工作的本质——将网络依赖性抽象为 Sidecar。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sidecar-design-pattern-in-microservices-ecosystem/855e972fly1ftphar3kl3j210c0imgom_hu1fffa326e90b8e9687da9625e9061b68_41902_71f3aa16ec869a495f49a26618269ae7.webp 400w,
               /blog/sidecar-design-pattern-in-microservices-ecosystem/855e972fly1ftphar3kl3j210c0imgom_hu1fffa326e90b8e9687da9625e9061b68_41902_4fe05477b711c74cc71f6fa2e81bf8d7.webp 760w,
               /blog/sidecar-design-pattern-in-microservices-ecosystem/855e972fly1ftphar3kl3j210c0imgom_hu1fffa326e90b8e9687da9625e9061b68_41902_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/sidecar-design-pattern-in-microservices-ecosystem/855e972fly1ftphar3kl3j210c0imgom_hu1fffa326e90b8e9687da9625e9061b68_41902_71f3aa16ec869a495f49a26618269ae7.webp&#34;
               width=&#34;760&#34;
               height=&#34;389&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在服务网格中有数据平面和控制平面的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据平面&lt;/strong&gt;的职责是处理网格内部服务之间的通信，并负责服务发现、负载均衡、流量管理、健康检查等功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制平面&lt;/strong&gt;的职责是管理和配置 Sidecar 代理以实施策略并收集遥测。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Kubernetes 和 Istio 世界中，你可以将 Sidecar 注入 Pod 内。&lt;strong&gt;Istio&lt;/strong&gt; 使用带有 &lt;strong&gt;Envoy&lt;/strong&gt; 的 Sidecar 模型作为代理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;来自 Lyft 的 Envoy&lt;/strong&gt; 是为云原生应用程序设计的最流行的开源代理。Envoy 依附着每项服务运行，并以平台无关的方式提供必要的功能。所有的服务流量都通过 Envoy 代理流动。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.envoyproxy.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.envoyproxy.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/sidecar-design-pattern-in-microservices-ecosystem/855e972fly1ftphh5l8plj210n06taau_hub06e8212e6ed6a34a041475fe3d5644e_14154_e24623cfcc6836dcea38dcff35101951.webp 400w,
               /blog/sidecar-design-pattern-in-microservices-ecosystem/855e972fly1ftphh5l8plj210n06taau_hub06e8212e6ed6a34a041475fe3d5644e_14154_08005793c4b44a4583f007c8d322dac0.webp 760w,
               /blog/sidecar-design-pattern-in-microservices-ecosystem/855e972fly1ftphh5l8plj210n06taau_hub06e8212e6ed6a34a041475fe3d5644e_14154_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/sidecar-design-pattern-in-microservices-ecosystem/855e972fly1ftphh5l8plj210n06taau_hub06e8212e6ed6a34a041475fe3d5644e_14154_e24623cfcc6836dcea38dcff35101951.webp&#34;
               width=&#34;760&#34;
               height=&#34;141&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从单体服务到微服务的转变使组织能够独立且大规模地部署应用程序。在 Container 和 Kubernetes 世界中，Sidecar 设计模式更适合。Sidecar 从应用程序中抽象出了复杂性，并处理服务发现、流量管理、负载均衡、断路器等功能。&lt;/p&gt;
&lt;p&gt;在此处了解有关 Sidecar 模式的更多信息：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh 如何解决微服务中的 3 个主要挑战</title>
      <link>https://cloudnative.to/blog/how-service-mesh-addresses-3-major-microservices/</link>
      <pubDate>Sat, 28 Jul 2018 17:11:16 +0800</pubDate>
      <guid>https://cloudnative.to/blog/how-service-mesh-addresses-3-major-microservices/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://dzone.com/articles/how-service-mesh-addresses-3-major-microservices-c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们都知道微服务会增加复杂性。了解服务网络如何解决这一问题和其他挑战。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我最近正在阅读 Dimensional Research 撰写的&lt;a href=&#34;https://go.lightstep.com/global-microservices-trends-report-2018&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;全球微服务趋势报告&lt;/a&gt;，在阅读的同时，我个人也认为“服务网络可以帮助解决这个问题。”所以我将阐述这 3 个挑战以及服务网格是如何解决它们。报告中引用的受访者表明微服务正在得到广泛采用。同样清楚的是，除了微服务带来的无数好处之外，同样也带来了一些严峻的挑战。报告显示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;91％的企业&lt;strong&gt;正在使用&lt;/strong&gt;微服务或有计划使用&lt;/li&gt;
&lt;li&gt;99％的用户认为在使用微服务时遇到了&lt;strong&gt;挑战&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;微服务主要的挑战&#34;&gt;微服务主要的挑战&lt;/h2&gt;
&lt;p&gt;该报告指出了公司面临的一系列挑战。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/how-service-mesh-addresses-3-major-microservices/855e972fly1fto3iki07wj20zh0d9404.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大量公司既面临着技术上的挑战，同时也面临着组织结构上的挑战。而我将专注于能够用服务网格解决的技术挑战，但值得注意的是，服务网格所做的一件事就是带来一致性，因此可以在团队之间实现相同的愿景，从而减少对某些技能的需求。&lt;/p&gt;
&lt;h2 id=&#34;每个额外的微服务都会增加运维的难度&#34;&gt;每个额外的微服务都会增加运维的难度&lt;/h2&gt;
&lt;p&gt;如果没有服务网格，这句话将成为现实！服务网格可以通过 API 提供监控，可伸缩性和高可用性，而不是通过分离设备。这种灵活的框架消除了与现代应用相关的操作复杂性。基础设施服务传统上是通过分离设备实现的，这意味着需要到达实际的设备来获得服务。因为每个设备的唯一性，导致为每个设备提供监控，扩展和高可用性有很高的难度。服务网格通过 API 在计算集群内部提供这些服务，不需要任何其他设备。实现服务网格意味着添加新的微服务不必增加复杂性。&lt;/p&gt;
&lt;h2 id=&#34;识别性能问题的根本原因更加困难&#34;&gt;识别性能问题的根本原因更加困难&lt;/h2&gt;
&lt;p&gt;服务网格工具箱为您提供了一些有助于解决此问题的方法：&lt;/p&gt;
&lt;h3 id=&#34;分布式跟踪&#34;&gt;分布式跟踪&lt;/h3&gt;
&lt;p&gt;跟踪为不同的微服务提供服务依赖性分析，并在请求穿梭于多个微服务时跟踪此请求。它也是识别性能瓶颈和放大特定请求以定义诸如哪些微服务导致请求延迟或哪些服务产生错误之类的事情的好方法。&lt;/p&gt;
&lt;h3 id=&#34;指标的集合&#34;&gt;指标的集合&lt;/h3&gt;
&lt;p&gt;通过服务网格能够获得的另一个有用的功能是收集指标的能力。指标是在各个时间维度上了解应用程序中发生了什么，以及何时它们是健康的或者不健康的关键。服务网格可以从网格中收集遥测数据，并为每一跳产生一致的指标。这样可以更轻松地快速解决问题，并在将来构建更具弹性的应用程序。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/how-service-mesh-addresses-3-major-microservices/855e972fly1ftobpzbxnzj20rl0b2mya.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;不同的开发语言和框架&#34;&gt;不同的开发语言和框架&lt;/h2&gt;
&lt;p&gt;报告受访者指出的另一个主要挑战是在多语言世界中维护分布式架构的挑战。当从单体服务到微服务的转变时，许多公司都面临着一个现实就是，他们必须使用不同的语言和工具来让系统工作起来。大型企业尤其受此影响，因为他们拥有许多大型分布式团队。服务网格通过提供编程语言不可知性来提供一致性，这解决了多语言世界中的不一致性，其中不同的团队（每个团队都有自己的微服务）可能使用不同的编程语言和框架。网格还提供了统一的、覆盖整个应用程序的观测点，用于将可见性和控制性引入应用程序，同时将服务间的通信从隐含的基础架构领域移出到一个可以轻松查看，监视，管理和控制的位置。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/how-service-mesh-addresses-3-major-microservices/855e972fly1ftobqt0wv7j20ry0ce0uc.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务很酷，但服务网格使得它更酷。如果您正处于微服务的路途中并且发现难以应付基础架构挑战，那么服务网格可能是正确的答案。如果您对如何充分利用服务网格有任何疑问，请告诉我们，我们的工程团队随时可以与您交流。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>速率限制 part1—分布式系统的一个实用工具</title>
      <link>https://cloudnative.to/blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/</link>
      <pubDate>Fri, 29 Jun 2018 15:51:19 +0800</pubDate>
      <guid>https://cloudnative.to/blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/</guid>
      <description>&lt;p&gt;在计算领域，速率限制通常用于控制服务发起或消耗的操作速率，或者是请求发送或接收的流量。如果你有一年以上的软件开发经验，那么你应该会遇到这个概念。但是，和很多软件架构所面临的挑战一样，比起实际出现的问题，需要思考的问题会更多。本文概述了现代分布式应用程序中的一些关于速率限制的实现方案、优势和挑战。&lt;/p&gt;
&lt;h2 id=&#34;为什么需要速率限制&#34;&gt;为什么需要速率限制？&lt;/h2&gt;
&lt;p&gt;实现速率限制主要是由于以下三个原因：通过资源节制防止（有意无意的）拒绝服务，限制（潜在的）级联故障的影响，以及限制或计量资源的使用情况。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.twitter.com/en/docs/basics/rate-limiting&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Twitter&lt;/a&gt; 或 &lt;a href=&#34;https://go.developer.ebay.com/api-call-limits&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ebay&lt;/a&gt; 这样的企业组织使用了一种类似的拒绝服务防治模式：在 SaaS API 之前放置一个速率限制器，以此来避免针对 API 后端的拒绝服务恶意攻击，同时也可以为所有消费者提供一致的服务。在那些支付 API（如 &lt;a href=&#34;https://stripe.com/blog/rate-limiters&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Stripe&lt;/a&gt; ）的减负策略中可以使用速率限制来防止级联故障（通过系统中的一些组件部分降级）。同样，当为外部信息源轮询健康检查这些新数据时，也会使用限制（或计量）模式。这样我们只需要定期获取数据，并可以为启动的每个请求付费。&lt;/p&gt;
&lt;h2 id=&#34;如何选择&#34;&gt;如何选择？&lt;/h2&gt;
&lt;p&gt;基于简化的原则，我们假设正在处理点对点通信模型中的速率限制。在这种场景下，你可以在数据发送的“发送端”或数据消费“接收端”中的任何地方实施速率限制，当然还有其他“中间件”选项：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-发送端和接收端&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;发送端和接收端&#34; srcset=&#34;
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq2gb6qhj20lp05wmx4_hud1c9d7e810d14ba7fd378f4b3d3fa352_13116_8704f8902076d1215bb254b6ec5397a7.webp 400w,
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq2gb6qhj20lp05wmx4_hud1c9d7e810d14ba7fd378f4b3d3fa352_13116_1efe89658a28bf2ddb6c831ea25cc713.webp 760w,
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq2gb6qhj20lp05wmx4_hud1c9d7e810d14ba7fd378f4b3d3fa352_13116_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq2gb6qhj20lp05wmx4_hud1c9d7e810d14ba7fd378f4b3d3fa352_13116_8704f8902076d1215bb254b6ec5397a7.webp&#34;
               width=&#34;760&#34;
               height=&#34;206&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      发送端和接收端
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可以控制发送端发送请求的速率：通过定义时间限制循环来定期发送 API 请求。&lt;/li&gt;
&lt;li&gt;你可以控制接收端接收请求的速率：在当前任务/线程处理完成之前拒绝新的入站 HTTP 连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-控制速率&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;控制速率&#34; srcset=&#34;
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq7eltt3j20rc06tdfv_hua95a442ddca69898b2a777dbeea58e15_20302_7a376d704b2dcb26e5c875ab6e852537.webp 400w,
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq7eltt3j20rc06tdfv_hua95a442ddca69898b2a777dbeea58e15_20302_50ab79915b3a0b51293dede48717becf.webp 760w,
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq7eltt3j20rc06tdfv_hua95a442ddca69898b2a777dbeea58e15_20302_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq7eltt3j20rc06tdfv_hua95a442ddca69898b2a777dbeea58e15_20302_7a376d704b2dcb26e5c875ab6e852537.webp&#34;
               width=&#34;760&#34;
               height=&#34;189&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      控制速率
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可以使用中间层来缓冲发送的请求：通过将请求放入队列（可以通过定义不同优先级，为请求提供不同级别的 SLA）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-请求缓冲&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;请求缓冲&#34; srcset=&#34;
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq8on7a0j20lr07eaa2_hu2383703908aa2b716d48bb44f695dec4_14061_3ed6bb986c80704eded93d904883b09d.webp 400w,
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq8on7a0j20lr07eaa2_hu2383703908aa2b716d48bb44f695dec4_14061_26b550869fcbbaa21c2f0a03f5716d9b.webp 760w,
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq8on7a0j20lr07eaa2_hu2383703908aa2b716d48bb44f695dec4_14061_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq8on7a0j20lr07eaa2_hu2383703908aa2b716d48bb44f695dec4_14061_3ed6bb986c80704eded93d904883b09d.webp&#34;
               width=&#34;760&#34;
               height=&#34;258&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      请求缓冲
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可以使用中间层来限制发送的请求：通过使用某种形式的代理或网关。这样当下游服务不再接受请求时，它会切换至断路器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-中间层&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;中间层&#34; srcset=&#34;
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq9qjzycj20jk06tdgn_hu9a55e17f793ed0c5833126b5d562d46a_18968_a6e555c470d15e421362e7a6fc75de8e.webp 400w,
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq9qjzycj20jk06tdgn_hu9a55e17f793ed0c5833126b5d562d46a_18968_33b282b13c729cacd3ba4ee4b9010ba3.webp 760w,
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq9qjzycj20jk06tdgn_hu9a55e17f793ed0c5833126b5d562d46a_18968_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmq9qjzycj20jk06tdgn_hu9a55e17f793ed0c5833126b5d562d46a_18968_a6e555c470d15e421362e7a6fc75de8e.webp&#34;
               width=&#34;704&#34;
               height=&#34;245&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      中间层
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;如何权衡&#34;&gt;如何权衡？&lt;/h2&gt;
&lt;p&gt;如果你正在开发一个需要解决上述问题的系统，可以参考如下方案，并清楚定义在哪些地方（及相应组件）需要实现速率限制。&lt;/p&gt;
&lt;p&gt;另一方面，如果你只控制其中一端（比如只控制接收端或只开放公用 API），那么你的选择余地就会受到限制，因为你不能依赖现有的设计指南或设计原则（即使系统不包含恶意使用者）。即使你同时控制了两端，你可能仍然想要实现“双保险”，实现同时包括两端的速率限制。&lt;/p&gt;
&lt;p&gt;其他需要权衡点包括：&lt;/p&gt;
&lt;h3 id=&#34;发送端和接收端的处理速率限制的能力&#34;&gt;发送端和接收端的处理速率限制的能力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有时由于开发模型或可用资源限制等原因，不可能在组件内实施有效的速率限制。&lt;/li&gt;
&lt;li&gt;在分布式系统中，单个组件的速率限制可能无法提供所需的功能（至少在一定程度上需要其他协调）。例如，如果你的速率限制了某个请求发送端进行连接，你需要横向扩展至两个发送端来满足需求，这样导致允许的发送端变为两个。&lt;/li&gt;
&lt;li&gt;你可能也不希望后端服务工程师开发速率限制功能，因为这样可能会由于定制开发而引起不同技术栈的差异。&lt;/li&gt;
&lt;li&gt;如果应用程序负载过重，可能需要将所有速率限制功能放到应用外，以避免在应用中执行速率限制功能导致其性能损失。&lt;/li&gt;
&lt;li&gt;我相信你听说过“单一职责”原则。因此在粗颗粒度架构级别，你可能会要求在应用外的组件里提供像速率限制这样的辅助功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;速率限制中间件的故障模式&#34;&gt;速率限制中间件的故障模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;你有必要知道速率限制服务崩溃（服务启动失败或被关闭）时会发生什么？如果服务能缓冲请求，你可能需要定义服务重启策略（期间的请求需要被缓冲至磁盘）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;速率限制中间件的算法灵活性&#34;&gt;速率限制中间件的算法灵活性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;自己实现基于发送端或接收端速率限制功能的主要优势在于是你可以完全控制速率限制算法的实现方式。例如，&lt;a href=&#34;https://en.wikipedia.org/wiki/Token_bucket&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;令牌桶&lt;/a&gt; 、 &lt;a href=&#34;https://blog.figma.com/an-alternative-approach-to-rate-limiting-f8a06cf7c94c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;固定窗口&lt;/a&gt; 、 &lt;a href=&#34;https://blog.figma.com/an-alternative-approach-to-rate-limiting-f8a06cf7c94c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;滑动窗口&lt;/a&gt; 以及通过请求（元）数据来进行算法决策。&lt;/li&gt;
&lt;li&gt;你需要经常评估哪些算法可以与外部速率限制服务一起“开箱即用”，同时确定是否需要其他外部数据（包括关联的元数据处理）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;案例&#34;&gt;案例&lt;/h2&gt;
&lt;p&gt;更具体一点，我们来看几个例子。&lt;/p&gt;
&lt;h3 id=&#34;运行一个任务来调用第三方-sdk每次调用都具有请求限制同时按计量收费即你控制发送端但无法控制接收端&#34;&gt;运行一个任务来调用第三方 SDK，每次调用都具有请求限制，同时按计量收费（即你控制发送端，但无法控制接收端）。&lt;/h3&gt;
&lt;p&gt;对于请求限制和按计量收费的方案，我希望实施本地（发送端）速率限制。假设请求超过了速率限制，那么可能会收到一个错误，或者可能被（暂时）阻止。我因此需要确认 SLA 或检查生产实施文档。无论发生什么，我都不会希望我的应用程序简单地在不断尝试循环连接，因为是这只会浪费我的资源。如果发送端没有基于计量收费的速率限制，我会付出很多钱，而且没有人愿意这样做！&lt;/p&gt;
&lt;p&gt;在 Java 语言中，我经常使用 Google 开源的 Guava RateLimiter 库来解决这类问题。我写的发送端的应用程序示例就像下面这样：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-guava-案例&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Guava 案例&#34; srcset=&#34;
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmqalcy5zj20kv03gglu_hu98388f137656d42f4cfa27a8bbb3c661_26655_6429da66ece8cf1bfffb43549bc25021.webp 400w,
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmqalcy5zj20kv03gglu_hu98388f137656d42f4cfa27a8bbb3c661_26655_295b1b4ef6b98e408e510039a4d606b8.webp 760w,
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmqalcy5zj20kv03gglu_hu98388f137656d42f4cfa27a8bbb3c661_26655_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmqalcy5zj20kv03gglu_hu98388f137656d42f4cfa27a8bbb3c661_26655_6429da66ece8cf1bfffb43549bc25021.webp&#34;
               width=&#34;751&#34;
               height=&#34;124&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Guava 案例
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是一个基于  &lt;a href=&#34;https://google.github.io/guava/releases/19.0/api/docs/index.html?com/google/common/util/concurrent/RateLimiter.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Guava RateLimiter JavaDoc&lt;/a&gt;  的简单示例，实际上我可能在任务执行逻辑中增加一些异常处理块。&lt;/p&gt;
&lt;h3 id=&#34;提供一个公共-api即你控制接收端但无法控制全部发送端&#34;&gt;提供一个公共 API（即你控制接收端，但无法控制（全部）发送端）&lt;/h3&gt;
&lt;p&gt;在这种场景下，可以防止 API 后端过载的唯一方法是通过对接收端进行速率限制，最好是将限制功能放到如 API 网关这类外部服务上。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-api-gateway&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;API Gateway&#34; srcset=&#34;
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmqcco3umj20h80bemxj_hu2a3766f1e4b0e2a3cfdc7242573887ba_23549_e513efdbd3be7e85e0139bdc83b7ed12.webp 400w,
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmqcco3umj20h80bemxj_hu2a3766f1e4b0e2a3cfdc7242573887ba_23549_2049796e649da019f66351f8ed3910ec.webp 760w,
               /blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmqcco3umj20h80bemxj_hu2a3766f1e4b0e2a3cfdc7242573887ba_23549_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/rate-limiting-a-useful-tool-with-distributed-systems-part1/78a165e1gy1fsmqcco3umj20h80bemxj_hu2a3766f1e4b0e2a3cfdc7242573887ba_23549_e513efdbd3be7e85e0139bdc83b7ed12.webp&#34;
               width=&#34;620&#34;
               height=&#34;410&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      API Gateway
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;通过这篇速率限制文章的三部分，我们了解了速率限制的动机、可以选择的方案和相关的权衡。在下一篇文章中，我将详细介绍如何实现 API 网关的速率限制算法！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Istio 服务网格的崛起</title>
      <link>https://cloudnative.to/blog/the-rise-of-the-istio-service-mesh/</link>
      <pubDate>Tue, 12 Jun 2018 15:06:25 +0800</pubDate>
      <guid>https://cloudnative.to/blog/the-rise-of-the-istio-service-mesh/</guid>
      <description>&lt;p&gt;本文为翻译文章，&lt;a href=&#34;https://www.infoworld.com/article/3273547/containers/the-rise-of-the-istio-service-mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;点击查看原文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如何确保微服务之间网络通信的可靠性、安全性和可管理性？使用服务网格吧！&lt;/p&gt;
&lt;p&gt;在过去一年中，&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;服务网格技术引发关注度和吸引力的持续提升，这是一件非常有趣的事情。事实上，在我写这篇文章时，Istio 仅为 0.8 版本，但对于最近两届&lt;a href=&#34;https://events.linuxfoundation.org/events/kubecon-cloudnativecon-europe-2018/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KubeCon/CloudNativeCon&lt;/a&gt;活动而言，它一直是&lt;a href=&#34;https://events.linuxfoundation.org/events/kubecon-cloudnativecon-europe-2018/program/schedule/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;热门话题&lt;/a&gt;，仅在丹麦的活动中就有超过十几个不同的活动议题。那么它为什么会这样受欢迎？&lt;/p&gt;
&lt;p&gt;在深入研究 Istio 受欢迎的原因之前，让我们先来介绍一下服务网格。这是一个通用术语，其早已被投入在多个不同场景中。例如定义不同无线设备之间的通信方法；或者定义一个系统，各个应用程序可以直接通过它与其他应用程序通信。&lt;a href=&#34;https://istio.io/docs/concepts/what-is-istio/overview.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最近&lt;/a&gt;，这个术语被用来表示应用或微服务的网络，以及它们之间的互相作用关系。后者是本文的重点。&lt;/p&gt;
&lt;p&gt;事实上红帽公司一直参与云原生和微服务领域建设，包括四年前决定将 OpenShift 向 Kubernetes 和 Docker 转变，这帮助我们理解了服务网格技术，尤其是 Istio 的重要性。本文将探讨为什么我会坚信 Istio 会很受欢迎的四个原因。&lt;/p&gt;
&lt;h2 id=&#34;微服务和转型&#34;&gt;微服务和转型&lt;/h2&gt;
&lt;p&gt;纵观你整个职业生涯，或者结合如今的工作，你可能已经发现从代码完成开发到部署至生产之间的时间不断被延长，以至于开发资源被转移到其他项目，同时也使你的产品反馈周期变得无效或无关紧要。为了缩短交付时间，一些公司决定以功能服务架构或微服务架构来将大型应用拆散，以此提高效率。即曾经具有多种功能的单个应用程序（包）被切分成可独立更新的单个程序包。&lt;/p&gt;
&lt;p&gt;这当然是有价值的，但同时也要承认，使用这种架构需要对单独的服务和它们之间的接口进行更多的开发治理。例如曾经定义在应用程序内部的一部分 API 调用关系现在上升在到网络层中。&lt;/p&gt;
&lt;p&gt;Christian Posta 的演讲“&lt;a href=&#34;https://www.slideshare.net/ceposta/the-hardest-part-of-microservices-calling-your-services&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务中最困难的部分：调用你的服务&lt;/a&gt;”谈到了一个重要问题。当调用 API 时，你可能会认为你在处理 A 和 B 之间的直接集成调用（下图 1）。然而计算机网络并不会针对直接通信进行优化（下图 2）。因此在某些情况，尤其当应用处于你正考虑或使用的云环境中时，你不可避免且不得不考虑这些不同的失控物理和虚拟网络设备。例如，就可能存在这样一种情况：其中一台设备的性能低于最佳性能，这将影响整个应用程序的响应时间（下图 3）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-a-和-b-之间的调用关系图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;A 和 B 之间的调用关系图&#34; srcset=&#34;
               /blog/the-rise-of-the-istio-service-mesh/78a165e1gy1fs7fmkvibwj20jf0dfq40_hu1d6e09309cb42ba318483e688e45f27d_31753_6199e3a7e33a2c983c5946d983b9ebcd.webp 400w,
               /blog/the-rise-of-the-istio-service-mesh/78a165e1gy1fs7fmkvibwj20jf0dfq40_hu1d6e09309cb42ba318483e688e45f27d_31753_b1dd8e9a8f924a0ca50ad25a9df75d18.webp 760w,
               /blog/the-rise-of-the-istio-service-mesh/78a165e1gy1fs7fmkvibwj20jf0dfq40_hu1d6e09309cb42ba318483e688e45f27d_31753_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/the-rise-of-the-istio-service-mesh/78a165e1gy1fs7fmkvibwj20jf0dfq40_hu1d6e09309cb42ba318483e688e45f27d_31753_6199e3a7e33a2c983c5946d983b9ebcd.webp&#34;
               width=&#34;699&#34;
               height=&#34;483&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      A 和 B 之间的调用关系图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;微服务先驱和-netflix-oss&#34;&gt;微服务先驱和 Netflix OSS&lt;/h2&gt;
&lt;p&gt;有些公司似乎是为了云计算而生的。为了在云中提供弹性服务，应用程序不得不保护自己免受环境异常影响。&lt;/p&gt;
&lt;p&gt;Netflix 构建并随后&lt;a href=&#34;https://netflix.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开源&lt;/a&gt;了一系列涉及诸如断路、边缘路由、服务发现和负载均衡等功能的 Java 技术解决方案。这些组件使应用能够更好地控制通信，从而提高整体可用性。为了测试并确保组件的弹性，Netflix 还使用了&lt;a href=&#34;http://principlesofchaos.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;混沌工程&lt;/a&gt;，通过将各种现实中可能存在的问题注入到应用程序的网络中，以便能在任何给定时间中断工作流。Netflix 开发的技术组合允许其应用程序投入到一个以应用程序为中心的网络中，这实际上就是服务网格。&lt;/p&gt;
&lt;p&gt;在构建 Netflix OSS 堆栈的时代，虚拟机是在云中运行应用程序的唯一方式。因此 Netflix 选择 Java 作为开发语言来构建服务网格功能。&lt;/p&gt;
&lt;p&gt;除了 Netflix OSS 堆栈的纯 Java 依赖，另一个挑战是为了实现服务网格功能，开发人员必须将 Java 库包含在其应用程序中，并在代码中引用来使用这些组件。但在当时，那些希望强制使用这些技术的公司无法在平台级进行如上工作。&lt;/p&gt;
&lt;p&gt;随着&lt;a href=&#34;https://www.infoworld.com/article/3268073/containers/what-is-kubernetes-container-orchestration-explained.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt;的来临，诸如服务发现和负载均衡等功能成为平台本身的一部分，并且平台允许用任何语言编写的应用程序都可以使用。通过声明式和活动状态管理，Kubernetes 还能够通过自动重启无响应的应用来提高整体应用的可用性。在当今世界，Kubernetes 和容器是运行微服务应用程序的标准。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中，你的应用程序以由一个或多个容器组成“pod”运行。在 pod 中运行多个容器的技术有时也被称为“sidecar”，其实质上是一种将你的应用程序拆散，将子模块运行在共享隔离空间（pod）的解决方案。&lt;/p&gt;
&lt;p&gt;Kubernetes 为 Istio 这样的技术的崛起创造了有利条件。出行共享公司 Lyft 已经开始通过智能代理&lt;a href=&#34;https://github.com/envoyproxy/envoy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt;来提供微服务部署所需的弹性和动态路由功能。sidecar 容器和 Envoy 这类架构允许为每个应用程序实例附加一个轻量级代理，以支持服务发现、负载均衡、断路器、链路跟踪以及服务网格的其他功能。将它与一个控制面板结合，并添加服务治理和 Envoy 实例配置管理功能，你就拥有了 Istio。&lt;/p&gt;
&lt;h2 id=&#34;拥抱分布式架构&#34;&gt;拥抱分布式架构&lt;/h2&gt;
&lt;p&gt;最后，Istio 和服务网格通常与“拥抱”&lt;a href=&#34;https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;分布式计算的谬论&lt;/a&gt;有关。换而言之，”&lt;strong&gt;Istio 允许应用程序假定网络是可靠的、快速的、安全的、不变的等等——这使得分布式计算的谬论不再是谬论&lt;/strong&gt; “。说 Istio 和 Kubernetes 可以解决所有这些问题，但忽视这些谬论可能导致企业犯大错误。企业必须接受这样一个事实：当你有多个微服务和功能服务互相交互时，你就处理分布式系统。&lt;/p&gt;
&lt;p&gt;请参阅下面的分布式计算谬论的完整列表以及 Istio 的解决方案：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;谬论&lt;/th&gt;
&lt;th&gt;Istio 的解决方案&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;可靠网络&lt;/td&gt;
&lt;td&gt;断路和负载均衡&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;延迟为零&lt;/td&gt;
&lt;td&gt;超时和重试&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;忽略带宽&lt;/td&gt;
&lt;td&gt;服务评级和限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;安全网络&lt;/td&gt;
&lt;td&gt;相互 TLS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;拓扑不可改&lt;/td&gt;
&lt;td&gt;服务发现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单一管理员&lt;/td&gt;
&lt;td&gt;基于角色的访问控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;零传输成本&lt;/td&gt;
&lt;td&gt;gRPC 和 Protobuf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;同质化网络&lt;/td&gt;
&lt;td&gt;动态路由，A/B 测试和金丝雀部署&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在我与 OpenShift 客户的沟通中，我经常发现他们由于自身需求，已经实现了类似 Netflix 模式的功能。我也对实现这些功能的团队很有兴趣，经常听到他们说“我们是断路小组”或“我们是服务发现小组”。&lt;/p&gt;
&lt;p&gt;创建自己的服务网格功能的公司现在有机会使用 Kubernetes 和 Istio。通过使用这些被标准化的开源技术，他们可以获得由大型社区开发的功能、整理知识和用例，并帮助他们实现更具弹性的应用程序，同时以更低的成本更快地将产品推向市场。&lt;/p&gt;
&lt;p&gt;作者 Diogenes Rettori 是&lt;a href=&#34;https://www.redhat.com/en/technologies/cloud-computing/openshift&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;红帽 OpenShift&lt;/a&gt;的主任产品经理。在加入 OpenShift 团队之前，他专注于红帽 JBoss 中间件的客户培训。Diogenes 拥有强大的工程背景，曾为爱立信和 IBM 等公司工作。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh：重塑微服务市场</title>
      <link>https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/</link>
      <pubDate>Mon, 21 May 2018 21:48:05 +0800</pubDate>
      <guid>https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/</guid>
      <description>&lt;p&gt;今天我们不谈技术，不谈架构，也不谈具体的产品，我们来聊一聊在未来一两年之内，Service Mesh 技术会在微服务相关的市场带来什么样的变化？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbyxih7bj31hc0u0whz_hu6e2ffe70b64458c4247c360de03b647b_37133_b7c4665ce9c76e7622800b9d01a83fb3.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbyxih7bj31hc0u0whz_hu6e2ffe70b64458c4247c360de03b647b_37133_17c1341938b8c72edf3200ad8ece65b8.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbyxih7bj31hc0u0whz_hu6e2ffe70b64458c4247c360de03b647b_37133_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbyxih7bj31hc0u0whz_hu6e2ffe70b64458c4247c360de03b647b_37133_b7c4665ce9c76e7622800b9d01a83fb3.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;大家好，我是敖小剑，今天给大家带来的这个主题叫做“Service Mesh：重塑微服务市场”。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzaaju6j31hc0u0n3r_hu5dd8fe0f36471ad8eb3ee43c987aea20_72546_8b8280c3a28c11f9e113dd099c0d18fa.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzaaju6j31hc0u0n3r_hu5dd8fe0f36471ad8eb3ee43c987aea20_72546_d13056b184e840b7d94d4e5b417bcb77.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzaaju6j31hc0u0n3r_hu5dd8fe0f36471ad8eb3ee43c987aea20_72546_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzaaju6j31hc0u0n3r_hu5dd8fe0f36471ad8eb3ee43c987aea20_72546_8b8280c3a28c11f9e113dd099c0d18fa.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;刚才主持人张亮提到说，过去一年 Service Mesh 成为一个热词。基本上，在国内的话，我差不多是 Service Mesh 最早的布道师。可能如果大家之前有看相关的资料的话，应该会看到一些我的资料。我先后做过几场的演讲，做过一些技术的分享，也写过很多文章。但在此之前，这些内容可能更多的都是集中在技术领域。那今天我们会特殊一点，我们今天不谈详细的技术，不谈具体的架构，我们也不谈具体的产品。后面的这些名词，Istio/Conduit/Envoy/Linkerd/Nginmesh，这些词可能听过，可能没听过，但没问题，今天这些我们统统都不讲。我们今天要讲另外一个东西：我们会聊一聊在未来一两年之内，Service Mesh 技术会在微服务相关的市场带来什么样的变化？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzn8375j31hc0u0dj5_hu43f6eb70296ea44daf9cca8bf6db6f6b_34171_e6fdc4017c482264e82e0f2939875b1a.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzn8375j31hc0u0dj5_hu43f6eb70296ea44daf9cca8bf6db6f6b_34171_d12bc88ff84ea3186a6390b5de15269a.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzn8375j31hc0u0dj5_hu43f6eb70296ea44daf9cca8bf6db6f6b_34171_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzn8375j31hc0u0dj5_hu43f6eb70296ea44daf9cca8bf6db6f6b_34171_e6fdc4017c482264e82e0f2939875b1a.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;主要内容会是三大块：首先我们会看一下目前微服务的市场的一些现状，然后接下来我们会探讨一下它的商业模式，在第三块，我们会重点讲一下 Service Mesh 对 PaaS 的意义。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzsa5poj31hc0u0mzc_hu2f029f2bb6402bb49a287d1855975ce4_21651_cd2c4206ac0ca18eb562893901e1b92e.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzsa5poj31hc0u0mzc_hu2f029f2bb6402bb49a287d1855975ce4_21651_c82266c5ad73ca0bbb4c100129e42ded.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzsa5poj31hc0u0mzc_hu2f029f2bb6402bb49a287d1855975ce4_21651_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzsa5poj31hc0u0mzc_hu2f029f2bb6402bb49a287d1855975ce4_21651_cd2c4206ac0ca18eb562893901e1b92e.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，第一块，微服务的现状。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzy0bbnj31hc0u0jxf_hua762d811114a4d01b04b48ae9fa0b8c6_65573_d36a61a1e3d02e326686bf958a0f2c87.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzy0bbnj31hc0u0jxf_hua762d811114a4d01b04b48ae9fa0b8c6_65573_2cf4e80d6cdcdfe398612a0e9b08bc2b.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzy0bbnj31hc0u0jxf_hua762d811114a4d01b04b48ae9fa0b8c6_65573_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwgy1fwbbzy0bbnj31hc0u0jxf_hua762d811114a4d01b04b48ae9fa0b8c6_65573_d36a61a1e3d02e326686bf958a0f2c87.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们快速过一下。&lt;/p&gt;
&lt;p&gt;目前微服务的背景是这样，首先目前在市场上是有这么一个潮流：传统企业会慢慢向互联网技术转型，其中微服务和容器是这个技术转型的核心。这个市场比较大，大家也都看好这样一个方向，这是大的时代背景。&lt;/p&gt;
&lt;p&gt;简单回顾一下，微服务在国内，基本上是在 2015 年开始兴起。2016/2017 这两年在国内的基本上就是大热了。我们能看到的是，未来这一两年之内，这个热潮应该继续延续。主要还是因为微服务这个技术是用于解决实际问题的，另外它也同样适用于各种企业。这样的大背景之下，我们来看现在使用微服务的客户现状。&lt;/p&gt;
&lt;p&gt;实际上，我们之前在谈到 Service Mesh 技术为什么演进的时候，我们有提到，在 Service Mesh 之前，第一代的侵入式微服务框架，它的门槛相对稍微高一点，典型的代表的是 Dubbo，Spring Cloud。对于传统企业来说，传统企业其实缺乏一些互联网的技术基因，这些包括技术，人才，经验，还有开发流程。在实际的市场当中，我们可以看到，大多数企业，虽然他们试图在微服务方面有一些转变，但实际上，在落地的时候还是会遇到一些问题。目前第二代的 Service Mesh 技术其实主要是冲着解决这个问题来的。他的思路在于要想办法用 Service Mesh 这样一个技术来降低微服务落地的门槛，最后帮助传统企业完成整个技术转型。这是目前大的背景和现状，我们下面来详细聊一下在这个背景当中一些具体的东西。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0abo78j31hc0u0q8m_hu4674e35c93b61d12d3b1e2a1c21d4224_55512_c01e9940f7ad350dc40419480e1aad51.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0abo78j31hc0u0q8m_hu4674e35c93b61d12d3b1e2a1c21d4224_55512_1b8ef9e97d095a3435919ac7150b4ad2.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0abo78j31hc0u0q8m_hu4674e35c93b61d12d3b1e2a1c21d4224_55512_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0abo78j31hc0u0q8m_hu4674e35c93b61d12d3b1e2a1c21d4224_55512_c01e9940f7ad350dc40419480e1aad51.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;微服务的一个痛点：落地很难。&lt;/p&gt;
&lt;p&gt;在这个地方我放了一个冰山图，左边的有一个坐标，就是说要实现好一个微服务，技术要求大概是一个什么样子，我这边简单的画了一下。&lt;/p&gt;
&lt;p&gt;实际上我们可以看到，就是说如果以 60 分为及格线的话，那很遗憾的是，虽然这个冰山我们看它的体积非常的巨大，这个市场规模是非常大的，但实际上到目前真正能够落地的，能够浮在水面上的，其实并不多。这个问题在哪里？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为它落地太难了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0e9sr0j31hc0u011b_hu0e39a1beca36fe11ffb2e3d3d0d27cb4_88342_df90bcd6271db095241d2659901d5675.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0e9sr0j31hc0u011b_hu0e39a1beca36fe11ffb2e3d3d0d27cb4_88342_d11a3c8209d7bfe614ffce623e132fa5.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0e9sr0j31hc0u011b_hu0e39a1beca36fe11ffb2e3d3d0d27cb4_88342_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc0e9sr0j31hc0u011b_hu0e39a1beca36fe11ffb2e3d3d0d27cb4_88342_df90bcd6271db095241d2659901d5675.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;落地难的原因是门槛比较高。我们简单的罗列了一下，比如说典型的 Spring Cloud，他的技术栈，我们看到的这些特性的列表。大家可以看到非常多的东西，左边这个地方 Spring Cloud 的各个组件。大家如果用过 Spring Cloud 的都会比较熟悉。当然两边并不是严格对称，这只是一个示意。&lt;/p&gt;
&lt;p&gt;实际上在这样的一个巨大的特性列表和组件列表当中，比较头疼的是：如果你是一个新人的话，你要第一时间掌握的东西其实是非常多的。Hello Would 都很简单，但是你真的要掌握，这些东西是要一个一个吃透的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc25rkv7j31hc0u07d4_hu9a937a2d182245c21cb1c887afefe9fd_90363_8b7a2a8b5d68733d31c71ac54eec6cd1.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc25rkv7j31hc0u07d4_hu9a937a2d182245c21cb1c887afefe9fd_90363_2ac1c0d1114907ec898496d6c7efbe7c.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc25rkv7j31hc0u07d4_hu9a937a2d182245c21cb1c887afefe9fd_90363_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc25rkv7j31hc0u07d4_hu9a937a2d182245c21cb1c887afefe9fd_90363_8b7a2a8b5d68733d31c71ac54eec6cd1.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为什么这个门槛会这么高？在这里面要指出一点，就是说：解决问题的思路有点不太对。&lt;/p&gt;
&lt;p&gt;我们先看左边这个图，我们现在如果是想要一辆汽车，那 OK，可以像左边这个图一样。我们看到一辆汽车分解之后是会有多少个零件？我们现在通过类库的方式，实际去组装辆汽车，我可以给你不同的组件，不同的类库，然后告诉你这个是发动机，这个是轮胎，这个是刹车……这确实会比自己从头到尾，从每一个螺丝钉开始制造，去组装整车要轻松的多，比如说至少有个成熟的发动机，至少方向盘可以不用自己做了。但是实际上，对用户而言，必须要对整体有非常深的认识：你知道每个组件能做什么，选择合适的组件，并把他们并拢起来。这样对一个系统的了解是需要比较深的。&lt;/p&gt;
&lt;p&gt;我们再看看右边：你组装出来的东西是什么样子？最上面这个跑车可能是所有人的梦想，对吧？但实际当中，不同的用户，他的能力是不一样的，他的投入也不一样。那他最终得到产出品，很有可能不是上面的这个让大家心动的跑车。很可能只是一个普通的大众，只能只一个 QQ，甚至，其实最后一张图非常凄惨：不知道出来的会是什么，很可能是接近无法使用的产品。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc62tu0aj31hc0u0111_hua5f8b0b49fd9571e8ec163c31c64395c_85983_8147e546a3eca974ed74d2c09f695e7a.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc62tu0aj31hc0u0111_hua5f8b0b49fd9571e8ec163c31c64395c_85983_2070640f6beb21c767a1d3d9ab43db13.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc62tu0aj31hc0u0111_hua5f8b0b49fd9571e8ec163c31c64395c_85983_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc62tu0aj31hc0u0111_hua5f8b0b49fd9571e8ec163c31c64395c_85983_8147e546a3eca974ed74d2c09f695e7a.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在下一代的 Service Mesh 当中，会用其他的方式来完成这个事情。&lt;/p&gt;
&lt;p&gt;首先通过智能代理的方式，屏蔽掉大家对底层各个组件的认知。Service Mesh 会通过直接使用 Sidecar 的方式来完成这些功能。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc69bcrwj31hc0u0gsm_hu63ed18aa92a2e269a24164f01217c93c_74015_1cf8686b50369a37a558e760f9599d8c.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc69bcrwj31hc0u0gsm_hu63ed18aa92a2e269a24164f01217c93c_74015_d13eae98bcf5903835bc649855920e19.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc69bcrwj31hc0u0gsm_hu63ed18aa92a2e269a24164f01217c93c_74015_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc69bcrwj31hc0u0gsm_hu63ed18aa92a2e269a24164f01217c93c_74015_1cf8686b50369a37a558e760f9599d8c.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从思路上说，在这个时候，最大的事情是&lt;strong&gt;调整战略&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们回到需求：客户用这些东西的需求是什么？它的目标是把这个车造出来，但造出这个车的下一步，是开着它上路，去该去的地方。造车，并不是他的最终的目标，对吧？我们回到现实的例子，大家学习 Spring Cloud 的目标是仅仅掌握 Spring Cloud 吗？我们说到，做微服务的实现，是把我们体系架构在微服务之上，然后让整个体系可以更快更好的运转。所以呢，客户真正的需求是用微服务做开发，做应用开发，应用是它的核心价值。这种情况下，对于微服务系统本身的掌握，要求其实不应该那么高。&lt;/p&gt;
&lt;p&gt;比如说我随便举个例子，我相信在座的各位，很多同学开过车对吧？你可能开车的驾驶技术很高，但是如果我们现在，举个例子说：我给你一堆组件给你组，你能不能组装成一辆车？我相信在坐的同学应该没有几个能办得到。&lt;/p&gt;
&lt;p&gt;所以，在这个地方，在 Service Mesh 里面，最重要的是：我们会做一个思路的转变。我们不再以组件的方式给客户提供服务，而且直接给客户成品，而且是精心打磨的成品。这个大家梦想中的跑车，开箱即用，直接呈现在客户面前。它非常的方便，可以非常快速地使用它。他的品质是经过打磨好之后的，然后客户只需要知道该怎么驾驶就好了。&lt;/p&gt;
&lt;p&gt;这是整个 Mesh 的思路。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6exb4jj31hc0u0gru_hu47db1ed44758dadeafc2fcb101e3df76_61160_7114b0331c714f691f48e9a2015d7ba2.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6exb4jj31hc0u0gru_hu47db1ed44758dadeafc2fcb101e3df76_61160_2571c082d5a97bb6508a56c1ee5cbae8.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6exb4jj31hc0u0gru_hu47db1ed44758dadeafc2fcb101e3df76_61160_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6exb4jj31hc0u0gru_hu47db1ed44758dadeafc2fcb101e3df76_61160_7114b0331c714f691f48e9a2015d7ba2.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个思路背后，代表了一个重要的核心理念。我们会看到，第一代的微服务将当时微服务开发的门槛降低了，在第一代微服务之前，你需要一切从零开始，你需要从每一行代码开始。换句话说，在你造整车的时候，你需要从每个螺丝钉开始，这必然是很难的。&lt;/p&gt;
&lt;p&gt;第一代微服务至少提供了一些成熟的组件，比如说发动机 OK 啦，这个门槛它降低了一部分。第二代微服务，我们是希望在这个基础上，将门槛进一步降低。60 分不再是及格线，我们希望将它降成 30 分。这个目标如果能够达成，对于期望用微服务来做技术革新的企业来说，他这个时候可以更容易地落地。大家可以想象，一场考试，及格线是 60 分和及格线是 30 分，这个时候及格率会发生质的变化，这个时候能释放出来的市场规模也会远远大于前者。&lt;/p&gt;
&lt;p&gt;OK，这个第一阶段我们讲好。&lt;/p&gt;
&lt;p&gt;嗯，在这个地方，我想问大家一个问题：在座的各位，有没有哪一位所在的企业是真正的将微服务落地在一线生产上的？张亮兄？OK，你这个没问题。还有没有哪一位？OK？好，这个属于冰山水面上的部分。后面还有没有其他同学？有没有同学做过尝试的？就是在你们的实际的生产当中，实际落地微服务的架构，OK，这边有些同学。&lt;/p&gt;
&lt;p&gt;好，实际上调查的和我们预期的还是有点像的。真正的大家能够把微服务落地的，就是冰山上面露出来的一小部分。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6nwbacj31hc0u0gnw_hua66ab7f58868ce002ef0053270acbdaa_22603_6066e85242e7e203c044f513bae827c0.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6nwbacj31hc0u0gnw_hua66ab7f58868ce002ef0053270acbdaa_22603_f908fee6004097aafe0f2911f9cf338d.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6nwbacj31hc0u0gnw_hua66ab7f58868ce002ef0053270acbdaa_22603_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6nwbacj31hc0u0gnw_hua66ab7f58868ce002ef0053270acbdaa_22603_6066e85242e7e203c044f513bae827c0.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，我们进行第二个探讨：Service Mesh 和微服务市场模式的探讨。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6w3auoj31hc0u0gor_hue4bc6ad56c179b564d2baa1fe166ad73_32924_d5b2463e2d89beb94e9788188be66195.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6w3auoj31hc0u0gor_hue4bc6ad56c179b564d2baa1fe166ad73_32924_15cc38033fcb0df18e1af620cc3e8dca.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6w3auoj31hc0u0gor_hue4bc6ad56c179b564d2baa1fe166ad73_32924_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc6w3auoj31hc0u0gor_hue4bc6ad56c179b564d2baa1fe166ad73_32924_d5b2463e2d89beb94e9788188be66195.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我先抛出一个问题：假设现在有一个公司，他要推微服务，但它确实之前没有这样的经验，它可能也缺乏这样的人才，所以在技术能力上它会有些欠缺。那这个时候怎么办？&lt;/p&gt;
&lt;p&gt;哪位同学能给我想一个办法？或者说如果现在你的领导和你说：我们要上微服务了，有什么办法？这个很现实的，领导明天就你定方案，然后你发现你的团队好像大家都没玩过，也都不会。请你告诉我怎么办？有没有哪个同学给我一个想法？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：现场互动，有同学回答说，需要领导重视。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯，非常重视，我们明天就上！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：现场互动，有同学继续说，招人，外包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;恩，招人和外包，还有别的吗？OK，好，这位同学至少已经找到了明天早上开始推行微服务的一些方案了。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc72nnp5j31hc0u0n1e_hu3678c2ee52d88b34199928e0e5b9a5de_43475_0a1f681ec4e51f1ef7d329809656c977.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc72nnp5j31hc0u0n1e_hu3678c2ee52d88b34199928e0e5b9a5de_43475_7cb1308c8ac7766554edc49d3750bb33.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc72nnp5j31hc0u0n1e_hu3678c2ee52d88b34199928e0e5b9a5de_43475_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc72nnp5j31hc0u0n1e_hu3678c2ee52d88b34199928e0e5b9a5de_43475_0a1f681ec4e51f1ef7d329809656c977.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，我们简单过一下，刚才这个同学这里有一个比较有意思的地方：招人。这个有个比较有意思的东西给大家轻松一下。&lt;/p&gt;
&lt;p&gt;这个是我个人的玩笑，用于区分互联网企业的一个简单方式：当发现有些事情自己不会做，也没有合适的人手，没能力的时候怎么办？一般互联网公司的习惯都是：挖！没人是吧，看一下业界谁会，挖！挖不过来是吧，薪水乘 2？OK，互联网公司一般习惯这么干。但是传统企业一般不喜欢这么干，这里还包括伪装成互联网，大家应该懂这个意思吧？嗯，他的业务有可能是互联网业务，但他的工作方式，整个运作可能是传统企业的方式。但它的业务模式可能是互联网产品。这种企业的通常情况下它的习惯是买！拿钱去买，但他能买到什么？&lt;/p&gt;
&lt;p&gt;当然这是个玩笑，但是有时候还是挺准确的，大家可以私底下去验证一下。&lt;/p&gt;
&lt;p&gt;那我们现在说说，能买什么？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc78y0hwj31hc0u0tcp_hu258c84d11e5aa8f8eab0ce97486ab765_42814_12077204047a614c20c1147673ae9686.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc78y0hwj31hc0u0tcp_hu258c84d11e5aa8f8eab0ce97486ab765_42814_307229ceaebf700d968d81545a761372.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc78y0hwj31hc0u0tcp_hu258c84d11e5aa8f8eab0ce97486ab765_42814_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc78y0hwj31hc0u0tcp_hu258c84d11e5aa8f8eab0ce97486ab765_42814_12077204047a614c20c1147673ae9686.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这个市场，能为微服务的开发提供什么样的产品，什么样的服务吗？刚才同学说了一个：外包。是的，这个很正常。确实有非常之多的外包，但还有两个，一个是咨询，教你怎么做；一个是培训，包括出书也是一种培训，现场培训是另一种。还有一种就是卖产品，微服务相关的各种产品。整个市场会提供这些产品，但我们会注意到：前三者是不一样的。咨询、培训、外包本质上是要提升客户的能力，就是让你的能力更强。如果大家记得前面的那条线的话，现在就是在你考试的时候，让你的考试能力更强。产品是帮你稍微降低一下门槛。比如我告诉你，第五道题的答案是 B，你填上就好了。最终达到大家及格的目标，至少起码及格。&lt;/p&gt;
&lt;p&gt;整个市场提供的产品，大概是这个样子。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc7ggf0vj31hc0u044g_hu1be815f89f328c6f9e63c171bc333167_60726_c7a97c17b53699e7fd8c2f8226f342ac.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc7ggf0vj31hc0u044g_hu1be815f89f328c6f9e63c171bc333167_60726_e9ff148b748632206fbf4dbdc633195a.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc7ggf0vj31hc0u044g_hu1be815f89f328c6f9e63c171bc333167_60726_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc7ggf0vj31hc0u044g_hu1be815f89f328c6f9e63c171bc333167_60726_c7a97c17b53699e7fd8c2f8226f342ac.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们聊另外一个话题，可能更有意思：为什么大家想用微服务？尤其在参加技术大会之后。平时大家苦日子过习惯了，后来某人参加了某个技术大会之后，回来就觉得：平时这苦日子过得有点惨。旁边的这个是麦粒，不知道大家有没有吃过？晒干之后脱皮直接煮着可以吃的，甚至也可以生吃。然后是非常难吃的，很难下咽，但古代，我们的祖先原来就是这么吃下来的。后来发现参加了一场大会之后，发现这个受不了，为什么呢？发现别人吃的是右边的东西。&lt;/p&gt;
&lt;p&gt;这个叫什么？不患贫而患不均，对吧？左边这个其实也不是过不下去，但是当你看到右边之后，通常一般人都受不了了。别人告诉你说要去皮，你要磨成粉，之后你要和面，发酵，蒸，然后就有这个吃了。大家一看，开完大会之后就发现，对啊，左边这个麦粒确实没必要这么吃，对不对？&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9igauij31hc0u0ag1_hu4ca271d8dfc3aa60b985f37a63095ae3_64827_dc7e9f69c613d2cb96553823594f82cc.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9igauij31hc0u0ag1_hu4ca271d8dfc3aa60b985f37a63095ae3_64827_ab6ef1f4d08b1beef9cddb122f05e105.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9igauij31hc0u0ag1_hu4ca271d8dfc3aa60b985f37a63095ae3_64827_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9igauij31hc0u0ag1_hu4ca271d8dfc3aa60b985f37a63095ae3_64827_dc7e9f69c613d2cb96553823594f82cc.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们现在回到刚才的这个话题：咨询、培训、外包的本质是什么？&lt;/p&gt;
&lt;p&gt;咨询是告诉你，看个例子，咨询告诉你什么品种的小麦口感好，或者说告诉你微服务 12 要素。嗯，然后告诉你，Spring Cloud 是个不错的选择。&lt;/p&gt;
&lt;p&gt;培训是什么？告诉你，这个小麦怎么种，这个馒头要怎么蒸，对吧？接下来告诉你，什么三个星期或者三天快速掌握 Spring Cloud。&lt;/p&gt;
&lt;p&gt;外包是什么？就是这些东西，做咨询了，给方案了，也做了一些培训了，但是还是搞不定。可能技术不够，也可能人力不足。那怎么办？上门帮你。对吧？我直接帮你蒸一屉馒头，客户就会问了：今天搞定了，明天怎么办，是吧？这个问题肯定是现成的，今年的这个目标搞定了，但是馒头明天还是想吃，不想明天再搞回去的，是吧？OK，好开心的告诉客户，二期合同，签二期合同，轻松帮你搞定。&lt;/p&gt;
&lt;p&gt;那我们可以看到说：这三个本质是什么？是客户变得更强大，对吧？咨询、培训是让你变得更强大的；外包，让你变得假装更强大：其实没这个能力，但是在别人帮助的情况下，可以在短时间之内达到这个能力。&lt;/p&gt;
&lt;p&gt;但是别忘了：整个事情还是在客户这边的，这个还是自己的事情，如果能力不够，明天的事情还是做不好。今天让别人帮忙蒸好了馒头，明天没人蒸的话，还是得回去啃麦粒。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9nspdhj31hc0u07ae_huf2cba0868f7866a0489fb7c84aa3d431_63128_6057953981fae3dea3d16a38d205c195.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9nspdhj31hc0u07ae_huf2cba0868f7866a0489fb7c84aa3d431_63128_704504f2d3efce27041ece8d7c0ee137.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9nspdhj31hc0u07ae_huf2cba0868f7866a0489fb7c84aa3d431_63128_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9nspdhj31hc0u07ae_huf2cba0868f7866a0489fb7c84aa3d431_63128_6057953981fae3dea3d16a38d205c195.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然后我们可以看到，买到的产品也是不同层次的。&lt;/p&gt;
&lt;p&gt;我们做个简单的类比，初级产品是提供一些原材料，不能直接达到目标。但是不管如何，它会给你基石。至少在有小麦的情况下，还有机会煮一煮，对吧？类比各种类库，给一些基本的类库，至少还有机会不要从零开始。当肚子饿的时候，你说我没有吃的，我现在今天开始种地，对吧？等到半年之后，开始有收成，这不现实。所以，不管如何，初期产品至少让你有一个比较好的起点。&lt;/p&gt;
&lt;p&gt;再往后，中级的产品，比如说面粉，这个时候离馒头已经不是很遥远了。但是你还是需要一些比较重要的工具，类比就是各种的框架。基本上有面粉之后，起码不会饿死对吧？不管做的有多难吃。但是呢，有多好吃就是另外一回事，后面还有很多工序需要自己去完成。&lt;/p&gt;
&lt;p&gt;相比之下，大部分同学可能还会选择：这个自己做的不太好，我们还是选最高级，开箱即用。直接下单，那边马上给你端上一笼馒头，马上就搞定。这肯定是比前面自己种地或者买面粉要快的多，类比的话就是 Service Mesh。在这里我加了一个问号，后面大家会了解这个问号是什么。&lt;/p&gt;
&lt;p&gt;实际上，在市场上能买到的产品，是不同层次的。市场的规律通常是这样，在满足需求的前提之下，最初期的产品都会在第一时间出现，然后逐渐的开始演变，开始向高级产品来演变。对于微服务市场来说，现在的高级产品就是 Service Mesh。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9w0q0oj31hc0u0q87_hu9e796e27c41ed2acc41f6e107d74bacb_56884_7adbefec422cf5610ea212c6994865a1.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9w0q0oj31hc0u0q87_hu9e796e27c41ed2acc41f6e107d74bacb_56884_a23954b1cea2bd1448508be8d72ccdad.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9w0q0oj31hc0u0q87_hu9e796e27c41ed2acc41f6e107d74bacb_56884_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbc9w0q0oj31hc0u0q87_hu9e796e27c41ed2acc41f6e107d74bacb_56884_7adbefec422cf5610ea212c6994865a1.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们回到第二个痛点。前面我们说微服务落地的重点在哪里，第一个是门槛，微服务的门槛高实在是有点高。这里我们看第二个痛点：微服务的市场模式是不太对的。&lt;/p&gt;
&lt;p&gt;我们现在细细看，就是说，咨询、培训、外包，对于市场来说，有能力提供微服务相关服务的这些公司，大多数是技术型的公司。不管是创业公司，还是大一点像阿里腾讯这种比较大的。这些公司有个问题：它其实不是太擅长咨询培训外包的，毕竟这个不是它的主业。同样在这几个领域当中，市场存在大量的竞争对手，比如咨询公司，大家熟悉的，培训公司，还有各种外包。这些对于做技术型的公司来说通常不擅长，而且即使他可以来做，也会占用大量的人手。一旦占用人手的话，就没有能力去开发产品。&lt;/p&gt;
&lt;p&gt;我们看第四个，会发现：这个产品麻烦了。客户的资金，他的预算，一般来说是有固定的。当他的预算大部分投入到咨询、培训和外包之后，还有多少钱来买产品？他不买产品，技术公司就没有办法得到利润，没有利润，就没有足够的财力去开发更好的产品。&lt;/p&gt;
&lt;p&gt;没有更好的产品，就不能靠产品解决问题。&lt;/p&gt;
&lt;p&gt;那客户就要回答说：产品不能解决我的问题，我就继续回到咨询、培训、外包的这个主流上来。这个地方形成一个很要命的恶性循坏。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca471y2j31hc0u0wk5_hua2cb5b37f8e9d32cd429d04bf289f3e4_60495_43cd63b689754ffeeca41bddfc45f613.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca471y2j31hc0u0wk5_hua2cb5b37f8e9d32cd429d04bf289f3e4_60495_d0905032b6327033729af2987ac87048.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca471y2j31hc0u0wk5_hua2cb5b37f8e9d32cd429d04bf289f3e4_60495_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca471y2j31hc0u0wk5_hua2cb5b37f8e9d32cd429d04bf289f3e4_60495_43cd63b689754ffeeca41bddfc45f613.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在我之前的经历当中，我是在这个市场的乙方公司做过事情。我们当时其实是面临一个比较难受的事情，就是说：如何在产品和项目之间平衡。我相信这对于所有在微服务市场提供服务的乙方公司来说，都是一个非常非常现实的话题。&lt;/p&gt;
&lt;p&gt;产品是个什么概念？大家最熟悉的，左边这个图，office 系列，或者说它背后的 windows 操作系统。差不多是过去十几年，软件行业我感觉应该是最成功的所谓”产品”。产品的概念：难度非常大。你看 windows、office 出了这么多年，有谁超过了？然后它的周期非常长，开发一个产品，好几年。几千个人，甚至更多的人堆在上面。它的风险非常大，一次投资就是几亿几十亿。然后来钱其实挺慢的，因为他要慢慢铺开。这个产品铺上去可能几年之后陆陆续续回本。但是，有个极大的优点：非常低成本的大规模复制。Office 2019，它的第一份拷贝成本可能高到几十亿美元，但它的第二份拷贝的成本是多少？第两千份拷贝的成本是多少？第 1000 万份，它的成本又是多少？&lt;/p&gt;
&lt;p&gt;所以我们就发现针对于技术公司而言，对于大部分技术公司而言，其实最理想的是做产品，对吧？产品做好了，然后再卖给更多的客户。&lt;/p&gt;
&lt;p&gt;但是很多时候，事情往往没这么简单。很多时候我们遇到一个事情：会有一个“项目”的概念。有个客户，他有一大堆的东西，这些东西无法形成一个通用的需求，也没办法由简单的产品去覆盖它。然后可能就会用咨询、培训加外包的方式帮他搞定。OK，好处是说有一单是一单，客户的需求是摆在面前的，风险很小，基本上技术上肯定可以搞定，半年一年之后就能把这个项目的钱结回来。但是它的缺点是：陷入卖人头的境地。因为项目的可重复性是比较差的，当你接到第二个项目的时候，你会发现它其实需要重头来过，很难把两个项目之间的东西去积累成产品。&lt;/p&gt;
&lt;p&gt;我相信在座的如果有做乙方的，包括做内部乙方的，给其他人提供服务、产品来解决问题时，应该都会遇到这两个问题。这个平衡是相当麻烦。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca9k9nuj31hc0u0ter_huaabcb64cb7f287aa6f85f717f2113ed1_63446_36e54eece9372b62cbbd111abed7fdf9.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca9k9nuj31hc0u0ter_huaabcb64cb7f287aa6f85f717f2113ed1_63446_61678a06caa1e995a7550f16f98275be.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca9k9nuj31hc0u0ter_huaabcb64cb7f287aa6f85f717f2113ed1_63446_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbca9k9nuj31hc0u0ter_huaabcb64cb7f287aa6f85f717f2113ed1_63446_36e54eece9372b62cbbd111abed7fdf9.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;路在哪里？Service Mesh 给出几个答案。&lt;/p&gt;
&lt;p&gt;左边这个是在之前曾经做过的分享，从技术上来说，因为我们今天没讲技术，所以没有提过。从技术上说，Service Mesh 提供了一个方案，就是说将整个服务间通讯的解决方式，整个技术栈全部下移。从应用当中下移到底层的基础设施，通过加强基础设施的方式提供一个统一的解决方案，这是从技术的角度。&lt;/p&gt;
&lt;p&gt;在前面我们提到，从理念的角度上说，Service Mesh 是希望将微服务市场的门槛降低，然后形成整个市场的规模增大。&lt;/p&gt;
&lt;p&gt;我们在前面也提供了一个产品的思路：解决问题的思路要发生变化。要实现产品的升级，不能卖初级产品，要想办法提供最终的成型的成熟的产品。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaj01bxj31hc0u0wiw_hu9f9e3f5d306e145549f0f0795561452b_47319_560359f7c5445afb18c6781635cc2c50.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaj01bxj31hc0u0wiw_hu9f9e3f5d306e145549f0f0795561452b_47319_9f2bb03be2939bea153d63f895b78b25.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaj01bxj31hc0u0wiw_hu9f9e3f5d306e145549f0f0795561452b_47319_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaj01bxj31hc0u0wiw_hu9f9e3f5d306e145549f0f0795561452b_47319_560359f7c5445afb18c6781635cc2c50.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，这是 Service Mesh 在这个时候非常重要的一件事情，就是：可以重建微服务市场的市场模式。&lt;/p&gt;
&lt;p&gt;将整个模式牵回到一个正统的&lt;strong&gt;重产品重技术&lt;/strong&gt;的途径，也就是说，我们会通过提供更好的产品，然后这个产品可以更多的更普遍地满足客户的需求，从而降低客户的门槛。当客户入门的门槛降低的时候，他对于咨询、培训、外包的需求就会降低。那他会有更多的资金预算投到产品的采购当中，这样会让提供产品的技术公司有更多的利润，然后继续加强产品，形成这样一个良性的循环。这是 Service Mesh 在整个微服务市场当中非常非常重要的一环，必须要让原来的恶性循环的场景开始向现在这样一个良性循环做转变。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaq8jkgj31hc0u0gr9_hu8d1020c4689be8b78b28a86bdd286758_59884_5299f66020d65902f357289bd3d19ef0.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaq8jkgj31hc0u0gr9_hu8d1020c4689be8b78b28a86bdd286758_59884_14e43e4d45e5204e34b6199d7177d2c1.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaq8jkgj31hc0u0gr9_hu8d1020c4689be8b78b28a86bdd286758_59884_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcaq8jkgj31hc0u0gr9_hu8d1020c4689be8b78b28a86bdd286758_59884_5299f66020d65902f357289bd3d19ef0.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们来详细的过一下，Service Mesh 对于微服务市场的核心价值，主要是四块：&lt;/p&gt;
&lt;p&gt;第一是对使用者更加的友好，体现在技术栈下移，降低了整个微服务入门的门槛。最终达到扩大市场规模的目标，这主要是体现它的易用性上。&lt;/p&gt;
&lt;p&gt;然后，第二个核心价值体现在标准。从类库，到框架，再到平台，整个生态是越来越大的。&lt;/p&gt;
&lt;p&gt;而一旦到了 Service Mesh 这个领域，就不会拘泥于细节，而是通盘考虑，考虑生态如何做。整个体系，所有组件，这些组件之间的交互是什么？这有个好处，它会自然而然的去统一，去集中化这些模块，然后在上面再制定一个标准。&lt;/p&gt;
&lt;p&gt;第三个价值在于 Service Mesh 提供专业化的解决方案。大家常说的，“专业的人做专业的事情”。在这个领域，微服务之间的通讯，这是一个专业度非常高的领域，这个领域应该出现工业级成熟度的制成品。而不应该让每一家公司都以小作坊的方式去各自完成。我们期待的是一个工业级的产品，它应该有非常非常高的完成度，功能齐全，以此来提升业界的整体水准。随便举个例子，今天大家能拿到的任何一个哪怕微不足道的小螺丝钉。你就想想，如果用人工的方式去做，他们开发成本会有多大？工业制成品的概念就是在这个地方，通过大量的标准化，通过工业制造，可以做到非常好的精度，同时成本降到极低。&lt;/p&gt;
&lt;p&gt;这在整个市场上体现为规模效应。为什么？如果一天的时间只做一个螺丝，这个成本非常的高，如果开一台机器，一天制造了 100 万个螺丝，成本在哪里？所以，在这个点上有个非常重要的事情，就是：一定要可以低成本的大面积的使用。&lt;/p&gt;
&lt;p&gt;如果你的螺丝不标准，你在某个地方一定要需要一个特殊的螺丝，这个螺丝的规格跟其他都不相同，一定要手工制作。那这种情况下，你是没有办法去降低成本。你只有通过前面的易用性，标准，专业来实现。这些事情最终的目标，都是让这个产品最终实现可以低成本的大面积使用。这个时候可以做到一个事情，就是说你最终总的利润可以增加，但是你的单价是降低的。&lt;/p&gt;
&lt;p&gt;Service Mesh 这样的一个技术，对于市场有一个比较好的事情，是说它适合&lt;strong&gt;把规模做大&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb1l92jj31hc0u0wgu_hu5c5f4beb6ed858f00a03e14924af7c0a_23438_6c08f99b20141f4dda386e9c2609cb70.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb1l92jj31hc0u0wgu_hu5c5f4beb6ed858f00a03e14924af7c0a_23438_11858f7c49f5db1946bed18bd1ef2c85.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb1l92jj31hc0u0wgu_hu5c5f4beb6ed858f00a03e14924af7c0a_23438_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb1l92jj31hc0u0wgu_hu5c5f4beb6ed858f00a03e14924af7c0a_23438_6c08f99b20141f4dda386e9c2609cb70.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，我们探讨了 service mesh 对微服务市场模式的重新塑造。我们现在进入第三段，Service Mesh 对于 PaaS 平台的价值和意义。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb7blbrj31hc0u0dlz_hube9df88c3057edb9fbed8d1f94a02f1c_65492_07fbad06585c1f0781c6f2d00b0d1f3e.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb7blbrj31hc0u0dlz_hube9df88c3057edb9fbed8d1f94a02f1c_65492_8aadb90f4d34a1585d6fc489ea88523c.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb7blbrj31hc0u0dlz_hube9df88c3057edb9fbed8d1f94a02f1c_65492_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcb7blbrj31hc0u0dlz_hube9df88c3057edb9fbed8d1f94a02f1c_65492_07fbad06585c1f0781c6f2d00b0d1f3e.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在开始这个话题之前，我们先简单过一下，PaaS 的核心价值是什么？它跟 Service Mesh 又有什么相通的地方？大家记得前面列了四个东西，第一个是易用，对使用者友好，大家会发现 PaaS 提供的价值也是如此，PaaS 也是让大家可以更轻易的更简单的实现整个平台。标准，这个不用说了。专业，大家会发现，其实现在 PaaS 平台会慢慢的向少数的解决方案集中。基本上已经很少有小公司自己再去做一个自己的 PaaS 平台了。大规模，大家都有联系到，目前 PaaS 市场上比较大的一些公有云，会发现这个规模其实是非常可怕。&lt;/p&gt;
&lt;p&gt;大部分公有云，如果体积规模发展比较迅速的话，每年乘 2 是很正常的。我们发现 PaaS 其实和我们之前谈到的 Service Mesh，几乎是一脉相承。为什么？殊路而同归。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbdvljfj31hc0u07ax_hu528abfd741f56cdcc97f414382c29dc0_71097_a89406a97aa8aa2880e45ddba6b149c7.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbdvljfj31hc0u07ax_hu528abfd741f56cdcc97f414382c29dc0_71097_c70fe76c7df934ff90ac179d7080c475.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbdvljfj31hc0u07ax_hu528abfd741f56cdcc97f414382c29dc0_71097_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbdvljfj31hc0u07ax_hu528abfd741f56cdcc97f414382c29dc0_71097_a89406a97aa8aa2880e45ddba6b149c7.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;PaaS 和 Service Mesh 成功的基础，其实就是在这几个关键的点上。&lt;/p&gt;
&lt;p&gt;一个是一定要简单易用。这个轮子大家有没有印象，有小朋友的就会知道，这个是自行车后轮的平衡轮。有这个平衡轮之后，没有任何基础的小朋友也可以骑上自行车了，就叫易用性：非常非常简单，让你的入门门槛瞬间降低，客户做的事情及其简单。&lt;/p&gt;
&lt;p&gt;第二个事情是一定要有规模效应，产品要好，价格要低，怎么做到？只能把规模做大。要把规模做大，还有一个事情，就是一定要想办法把蛋糕做大。因为就算你把市场百分百占了，如果这个市场本身不大，那这种情况下其实就算占了百分百，也就一小块。所以接下来一个事情就是一定要去把这个蛋糕做大。&lt;/p&gt;
&lt;p&gt;整个 PaaS 和 Service Mesh 的生存之道（大家如果有留意到，我们一路下来这个脉络）是说它做了一个重要的事情，就是它实际上是在帮客户做事情：这些事情是客户必须要做的，但是他又不太容易做好。我们的生存之道是帮助客户从这些细节里面解脱出来。客户大多数情况下是业务驱动的，我们要做的就是把所有的他要做又不好做的这些事情都下沉下来，我们帮他做好。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbjsz50j31hc0u00zq_hu30ba692b99d7135c1adeb765f4a0efe4_75395_2502d54dcabb3f00e563019685016d1b.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbjsz50j31hc0u00zq_hu30ba692b99d7135c1adeb765f4a0efe4_75395_be85682da54ef78e8016a79cae631724.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbjsz50j31hc0u00zq_hu30ba692b99d7135c1adeb765f4a0efe4_75395_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbjsz50j31hc0u00zq_hu30ba692b99d7135c1adeb765f4a0efe4_75395_2502d54dcabb3f00e563019685016d1b.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Service Mesh 和 PaaS 在理念上是相通的，Service Mesh 对 PaaS 的价值体现在下面的几个方面：&lt;/p&gt;
&lt;p&gt;第一个是标准化和规模化，那这个我们讲的挺多。&lt;/p&gt;
&lt;p&gt;第二个，会涉及到跟技术相关的一些内容，它可以让开发和运维分离。Service Mesh 会接管整个应用的部署、运维和对应用的管理，它独立于应用的开发和业务实现。这样的好处是可以将大家熟悉的一些比如说服务治理的各种功能，让它独立应用的开发之外，而这些功能通过 Service Mesh 来实现。当 Service Mesh 变成 PaaS 的一部分之后，PaaS 和业务之间的这个界限会变得特别的清晰。应用集中在业务语义，而剩下的所有的部署、运维、管理、监控通通放在 PaaS，这样两者之间的界限清晰。&lt;/p&gt;
&lt;p&gt;另外一个就是提高竞争力，因为 Service Mesh 代表着技术先进性，提供了一些非常强大的功能，同时它会降低客户的门槛和客户易于使用，这个对于客户而言吸引力是非常高的。&lt;/p&gt;
&lt;p&gt;然后可以帮助 PaaS 平台更好的去整合资源，因为 PaaS 天生是提供各种能力的。这些能力，原来是以单个单个的方式提供给客户，大家如果有注意到的话，所有 PaaS 平台都卖各种产品各种能力，然后可以自己选择去用。Mesh 有个好处是说它本身就可以天然地把这些能力组合起来，变成一个统一的全套方案，直接覆盖监控、告警、故障排查，变成整个基础能力的一部分，变成 PaaS 平台的一部分，通过这样的方式来发挥 PaaS 平台的威力。&lt;/p&gt;
&lt;p&gt;另外就是引入了可控性。因为 Service Mesh 的控制平面，是可以对整个服务间通讯、对服务治理做到集中式的管理。这些控制的能力，如果为 PaaS 所用，那 PaaS 就会平添一种能力，去对整个应用做统一的控制。在此之前 PaaS 平台对应用的控制更多是集中在非常粗的层面，比如说启动、关闭，但是内部其实没办法干预。可以给它分配资源，但是你实际上没有办法去管控，比如说一些服务治理的功能。那通过整合 Service Mesh 之后，PaaS 就开始有能力对服务进行管控，而且这个能力会变得非常强大。而强大的服务治理功能，会变成 PaaS 平台的重要的卖点。&lt;/p&gt;
&lt;p&gt;这是整个 Service Mesh 对于 PaaS 的帮助。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbrvq35j31hc0u0ad0_hub03261fab609c579dbd45e33c91363e2_28355_f67d30513ac17a913460d47b3cb8d153.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbrvq35j31hc0u0ad0_hub03261fab609c579dbd45e33c91363e2_28355_81401f8986e68341a6fbe3e13b32688f.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbrvq35j31hc0u0ad0_hub03261fab609c579dbd45e33c91363e2_28355_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcbrvq35j31hc0u0ad0_hub03261fab609c579dbd45e33c91363e2_28355_f67d30513ac17a913460d47b3cb8d153.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们简单总结一下：Service Mesh 技术为 PaaS 平台提供了一个非常好的应用落地方案。&lt;/p&gt;
&lt;p&gt;底层是 PaaS，PaaS 如果直接接业务的话，通常是比较累的。客户选择用微服务之后，就会选择 Spring Cloud 之类的东西，还是要自己做一层比较厚的框架层。有 Service Mesh 技术之后 PaaS 会更好的对接微服务，对接业务。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcby2p8mj31hc0u0jvg_hufed757a0c1cccbd368f2bb8ac9b3a898_42724_fb0b905748ca891a0c24d8594ec35b1f.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcby2p8mj31hc0u0jvg_hufed757a0c1cccbd368f2bb8ac9b3a898_42724_8986ac6b63abe6b11fd0b2940cd6cefb.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcby2p8mj31hc0u0jvg_hufed757a0c1cccbd368f2bb8ac9b3a898_42724_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcby2p8mj31hc0u0jvg_hufed757a0c1cccbd368f2bb8ac9b3a898_42724_fb0b905748ca891a0c24d8594ec35b1f.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后我们会提到，Service Mesh 和 PaaS，我们称之为&lt;strong&gt;绝配&lt;/strong&gt;。所谓绝配，是说这样一个搭档相互之间是非常的舒服：让彼此的能力互补，然后增强对方的优点。&lt;/p&gt;
&lt;p&gt;在最早的微服务时代，微服务和容器被认为是一对绝配。应该说这两个技术的互补性是非常强的。微服务已经进展到 Service Mesh 阶段了，而容器经过市场淘汰已经开始向 K8S 靠拢了。接下来，在这样一个基础上如果能再走一步，当 k8s 逐步向 PaaS 平台靠拢，也就说 PaaS 实际上是一个基于 K8S 的 PaaS。那它和 Service Mesh 之间的搭档会成为一个新的市场主流，成为一个更好的客户基础。当然现在还没有实现，目前市场上暂时还没有这样的产品，但我相信在未来一两年中这会成为市场的主流。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcc61wwhj31hc0u0q4i_hude891f7414c26fdfe36e183bb72d5338_13263_535081a619276261d3ef564a7f839c81.webp 400w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcc61wwhj31hc0u0q4i_hude891f7414c26fdfe36e183bb72d5338_13263_653667892a26e39bdce977e20ac8e87f.webp 760w,
               /blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcc61wwhj31hc0u0q4i_hude891f7414c26fdfe36e183bb72d5338_13263_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/service-mesh-rebuild-microservice-market/006tNbRwly1fwbcc61wwhj31hc0u0q4i_hude891f7414c26fdfe36e183bb72d5338_13263_535081a619276261d3ef564a7f839c81.webp&#34;
               width=&#34;760&#34;
               height=&#34;428&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OK，我们今天的内容到这里结束，非常感谢大家，谢谢。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
