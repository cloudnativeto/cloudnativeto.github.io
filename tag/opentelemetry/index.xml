<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OpenTelemetry | 云原生社区（中国）</title>
    <link>https://cloudnative.to/tag/opentelemetry/</link>
      <atom:link href="https://cloudnative.to/tag/opentelemetry/index.xml" rel="self" type="application/rss+xml" />
    <description>OpenTelemetry</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Fri, 12 Jan 2024 08:00:00 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>OpenTelemetry</title>
      <link>https://cloudnative.to/tag/opentelemetry/</link>
    </image>
    
    <item>
      <title>OpenTelemetry 的最新进展及其对可观测性的影响</title>
      <link>https://cloudnative.to/blog/why-the-latest-advances-in-opentelemetry-are-significant/</link>
      <pubDate>Fri, 12 Jan 2024 08:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/why-the-latest-advances-in-opentelemetry-are-significant/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://thenewstack.io/why-the-latest-advances-in-opentelemetry-are-significant/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Why the Latest Advances in OpenTelemetry Are Significant&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;摘要：OpenTelemetry 是一个标准化观测性和遥测数据格式的项目，支持多种工具的互操作。本文介绍了该项目的新特性，如新的转换语言、日志支持和自动化修复能力。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今年，在&lt;a href=&#34;https://cncf.io/?utm_content=inline-mention&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生计算基金会（Cloud Native Computing Foundation）&lt;/a&gt;中，一个备受关注的项目是&lt;a href=&#34;https://thenewstack.io/observability-in-2024-more-opentelemetry-less-confusion/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt;和&lt;a href=&#34;https://thenewstack.io/how-the-opentelemetry-collector-scales-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Collector&lt;/a&gt;。这个项目是观测领域的一个非常令人兴奋的运动，旨在跨行业合作，达成观测和遥测的标准数据格式。&lt;/p&gt;
&lt;p&gt;这本身就非常重要，因为它允许多个观测和分析工具进行互操作，而以前的团队如果想要一个工具与另一个工具进行互操作，就必须多次转换数据。随着观测领域围绕人工智能/机器学习的炒作，公司更有可能从一个系统中存储和查看数据，然后在另一个系统中进行机器学习模型的训练。&lt;/p&gt;
&lt;p&gt;更棒的是，由于行业供应商和个人在&lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Collector&lt;/a&gt;上合作，这个项目继续不断发展。它是一个标准化的代理和遥测收集器，提供高吞吐量的遥测数据收集和分析。该收集器已经支持跟踪和度量数据一段时间了，但直到去年的&lt;a href=&#34;https://thenewstack.io/kubeconcloudnativecon-2022-rolls-into-detroit/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KubeCon Detroit 2022&lt;/a&gt;，社区才吸纳了 OpenLogs 项目，并开始实施日志收集和分析功能。现在，日志支持已经完全成熟。&lt;/p&gt;
&lt;p&gt;在接下来的部分中，我将分享一些关于这个项目的新特性以及它们对社区的重要性。&lt;/p&gt;
&lt;h2 id=&#34;1-新的转换语言&#34;&gt;1. 新的转换语言&lt;/h2&gt;
&lt;p&gt;我发现许多代理的语法使得进行有意义的转换非常困难，需要使用一些奇怪的 YAML 或 TOML。Otel Collector 仍然依赖于 YAML 格式，但它的新转换语言允许使用基于函数的语句，执行起来非常快速，可以管理复杂性。查看一些&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/pkg/ottl/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;语法示例&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;2-日志正式发布&#34;&gt;2. 日志正式发布&lt;/h2&gt;
&lt;p&gt;在大约一年的开发时间内，日志收集和分析现在已经正式发布。该实施有一些收集日志的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，它作为一个独立的代理运行，并从文件系统收集日志。它可以直接发送到最终目的地，也可以转发到以收集器模式运行的 OpenTelemetry Collector，可以即时计算日志指标。&lt;/li&gt;
&lt;li&gt;其次，存在许多日志 SDK，可以直接在应用程序中实施，并将日志发送到中央收集器或直接发送到最终目的地，这有助于减少磁盘 IO 的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-自动仪器成熟度&#34;&gt;3. 自动仪器成熟度&lt;/h2&gt;
&lt;p&gt;自动仪器是自动将应用程序连接到发出跟踪和度量数据而无需或仅需进行最少代码更改的能力。Java 和.Net 得到了全面支持，其他语言正处于不同开发和发布阶段。这个功能是一些专有解决方案展示出来的特色，因为它通过减少开发人员的时间来降低部署复杂性，现在它将同样强大的功能带到了 OpenTelemetry 生态系统中。&lt;/p&gt;
&lt;h2 id=&#34;4-语义约定&#34;&gt;4. 语义约定&lt;/h2&gt;
&lt;p&gt;这一点非常重要，并且正在从 ElasticSearch 向 OpenTelemetry 项目捐赠 ECS（Elastic Common Schema）而受益。规范化日志和遥测结构具有挑战性，因为似乎几乎每个人都以稍微不同的格式生成遥测数据；但要能够分析、创建警报并以人性化的方式呈现数据，所有遥测字段都需要以某种方式映射。如果每个人和每个系统都略有不同，那么在创建可重用的仪表板和组件方面就会出现挑战。现在，软件供应商可以负责在多个平台上创建仪表板，合理地确保数据将以多个平台上的正确格式进行发送。与此同时，我们管理大量遥测数据的人可以通过使用众所周知的字段名称来提高摄取和查询效率，并且在大多数客户发送的内容依赖于这些字段名称时，可以提供更高级的功能，同时减少计算资源和内存开销。&lt;/p&gt;
&lt;p&gt;完整的架构仍然需要一段时间才能最终确定，但逐步正在批准这些约定。例如，在 KubeCon 上，他们宣布了 HTTP 架构的最终确定。&lt;/p&gt;
&lt;h2 id=&#34;5-插件框架和生态系统&#34;&gt;5. 插件框架和生态系统&lt;/h2&gt;
&lt;p&gt;生态系统正在不断成熟。可扩展性框架允许自定义任何摄取管道&lt;/p&gt;
&lt;p&gt;的任何阶段。有越来越多的接收器用于各种系统，处理器具有越来越先进的功能，目标也在增加。我特别对新版本的 OpenSearch 扩展感到兴奋，它可以发送预打包在简化的遥测或 ECS 格式中的日志数据。&lt;/p&gt;
&lt;p&gt;从开发者的角度来看，我发现模式和内部“p”消息模式的结构非常周到，内置了 protobuf。它在功能自由度和最小复杂度之间有一个良好的平衡。&lt;/p&gt;
&lt;h2 id=&#34;6-社区合作&#34;&gt;6. 社区合作&lt;/h2&gt;
&lt;p&gt;这对于 CNCF 社区来说并不是很新鲜，但这个项目的速度和影响体现了 CNCF 社区哲学的精神。竞争公司正在共同努力，使计算的一部分变得更好、更容易，以造福我们其他人。有些人可能担心去除供应商锁定会导致客户离开，或者共享代码可能泄漏专有 IP。&lt;/p&gt;
&lt;p&gt;然而，在遥测领域，代理和收集器的核心架构通常是已解决的问题。那么为什么不制作一些遵循惯例并在各个平台上运行的东西，以便公司不再必须维护代理代码，其中 80% 都是重复的呢？这使公司可以在互操作性和创新可以通过这个框架传递的专有处理器方面共同开发插件。好处也延伸到所有运营商和软件供应商。借助标准化的 Otel Collector SDK，供应商可以创建一个单一的集成来为其应用程序添加遥测，并极大简化了收集过程，试图让所有主要的观测提供商为你的应用程序实施支持。&lt;/p&gt;
&lt;p&gt;运营商也从“随处收集”和“随处发送”的理念中受益。通过标准的配置文件格式简化了设置，减少了新系统的引入复杂性。我还怀疑，许多日志系统的运营商在观测数据的语义约定项目减少了许多问题后，将大大减少字段映射的基数问题。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;向所有项目贡献者和社区成员表示衷心的“感谢”！这里有太多人要列出来了，但你可以在&lt;a href=&#34;https://github.com/open-telemetry/community/blob/main/community-members.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub 上的 OpenTelemetry 项目&lt;/a&gt;上找到他们。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 和 OpenTelemetry Collector 的功能和未来路径正在以极快的速度前进，过去一年是 CNCF 组合中贡献第二多的项目，仅次于 Kubernetes。有这么多贡献者保持组织和合作，成熟度将继续加速。这将有望通过增加互操作性并简化仪表系统的仪器化过程来促进观测领域的创新。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OpenTelemetry 与可观测性：展望未来</title>
      <link>https://cloudnative.to/blog/opentelemetry-and-observability-looking-forward/</link>
      <pubDate>Tue, 02 Jan 2024 08:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/opentelemetry-and-observability-looking-forward/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://thenewstack.io/opentelemetry-and-observability-looking-forward/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry and Observability: Looking Forward&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让我们探讨一些令人兴奋的趋势，考虑到我们期待 2024 年会有什么样的可观测性发展。&lt;/p&gt;
&lt;p&gt;随着年底的临近，现在是一个停下来思考的好时机。2023 年对于 OpenTelemetry 来说是一个里程碑，因为其三个基本信号，跟踪、度量和日志，都达到了稳定版本。这一成就标志着&lt;a href=&#34;https://thenewstack.io/opentelemetry-gaining-traction-from-companies-and-vendors/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt;最初愿景的实现，即提供一个基于标准的框架，用于仪器化和收集可观测性数据。&lt;/p&gt;
&lt;p&gt;让我们抓住这个机会，探讨一下我们所见证的一些令人兴奋的趋势，深入研究创新的产品和用例，并在期待 2024 年的到来时深思熟虑地考虑可观测性的不断演变。&lt;/p&gt;
&lt;h2 id=&#34;度量标准的崭露头角&#34;&gt;度量标准的崭露头角&lt;/h2&gt;
&lt;p&gt;尽管 OpenTelemetry 关于度量的规范在 2022 年 5 月被宣布为稳定版本，但今年看到了其被广泛采用。以下是一些从业者的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由 VMware 的 Matthew Kocher 和 Carson Long 撰写的文章，标题为“&lt;a href=&#34;https://opentelemetry.io/blog/2023/cloud-foundry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;体验报告：在 Cloud Foundry 中采用 OpenTelemetry 进行度量&lt;/a&gt;”。&lt;/li&gt;
&lt;li&gt;我们自己的 Matheus Nogueira 撰写的文章，标题为“&lt;a href=&#34;https://tracetest.io/blog/adding-opentelemetry-metrics-in-your-go-app&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在你的 Go 应用程序中添加 OpenTelemetry 度量&lt;/a&gt;”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;展望 2024 年，可以预期会看到类似的日志运动和采用。&lt;/p&gt;
&lt;h2 id=&#34;关注在负载测试中使用分布式跟踪&#34;&gt;关注在负载测试中使用分布式跟踪&lt;/h2&gt;
&lt;p&gt;2023 年，两个领先的负载测试工具，&lt;a href=&#34;https://k6.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana k6&lt;/a&gt;和&lt;a href=&#34;https://artillery.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Artillery.io&lt;/a&gt;，都添加了对 OpenTelemetry 的支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Grafana k6 &lt;a href=&#34;https://github.com/grafana/xk6-distributed-tracing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;引入了跟踪&lt;/a&gt;功能，使性能工程师能够在&lt;a href=&#34;https://thenewstack.io/trace-based-testing-the-next-step-in-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;负载测试&lt;/a&gt;期间识别系统瓶颈或故障。&lt;/li&gt;
&lt;li&gt;Artillery.io 随后也&lt;a href=&#34;https://www.artillery.io/blog/introducing-opentelemetry-support&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;添加了度量和分布式跟踪&lt;/a&gt;，提供了对系统性能更详细的分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tracetest 利用了 k6 测试中暴露的功能，以&lt;a href=&#34;https://docs.tracetest.io/tools-and-integrations/k6&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;启用基于跟踪的负载测试&lt;/a&gt;，在运行测试时进行深入的断言。我们已经看到许多客户广泛使用了这个功能，比如&lt;a href=&#34;https://tracetest.io/case-studies/how-sigma-software-built-load-testing-for-their-microservices-with-k6-tracetest&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sigma Software&lt;/a&gt;。在 2024 年，Tracetest 团队将考虑将这一能力添加到&lt;a href=&#34;http://artillery.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Artillery.io&lt;/a&gt;和其他负载测试工具中。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-的支持和用例扩展&#34;&gt;OpenTelemetry 的支持和用例扩展&lt;/h2&gt;
&lt;p&gt;越来越多的供应商正在采用 OpenTelemetry 标准，以支持典型但非常重要的遥测数据分析之外的行动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一些公司，比如&lt;a href=&#34;https://opentelemetry.io/blog/2023/tyk-api-gateway/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tyk 正在仪器化其 API 网关，以原生支持 OpenTelemetry&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;终端用户正在发现 OpenTelemetry 的新用例，比如&lt;a href=&#34;https://thenewstack.io/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用分布式跟踪来观察你的 CI/CD 流水线&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tracetest.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tracetest&lt;/a&gt;利用分布式跟踪数据进行集成和端到端测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;强调-opentelemetry-收集器&#34;&gt;强调 OpenTelemetry 收集器&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://thenewstack.io/how-adobe-uses-opentelemetry-collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 收集器&lt;/a&gt;位于 OpenTelemetry 世界的中心，接收来自应用程序的信号，处理和转换这些信号，然后将它们导出到任意数量的后端系统。随着对 OpenTelemetry 的集成和供应商支持的扩展，对这个集中式收集器的需求和要求也在增加。&lt;/p&gt;
&lt;p&gt;2023 年引入了 OpenTelemetry Transformation Language (OTTL)，增强了 OpenTelemetry 收集器处理和转换传入信号的能力。&lt;/p&gt;
&lt;p&gt;在 Tracetest 中，我们能够利用&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/processor/filterprocessor/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在过滤器处理器中使用 OTTL&lt;/a&gt;的能力，改进了我们从输出大量遥测数据的生产环境中收集跟踪数据的方式。这一变化对&lt;a href=&#34;https://tracetest.io/blog/opentelemetry-collectors-new-filter-processor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 收集器的过滤器处理器&lt;/a&gt;使 Tracetest 适用于在高负载环境中运行测试，包括生产环境。&lt;/p&gt;
&lt;h2 id=&#34;无处不在的可观测性&#34;&gt;无处不在的可观测性&lt;/h2&gt;
&lt;p&gt;在最近的讨论中，我们发现了一种客户中不断增长的趋势，即“无处不在的可观测性”方法。这些公司不仅限于由网站可靠性工程师和 DevOps 传统使用，还包括了每个人，包括开发人员和测试人员，参与到可观测性中。这种转变重新定义&lt;/p&gt;
&lt;p&gt;了可观测性，使其从生产问题的一种反应性工具变成了在开发和测试中都有益的一种主动工具。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.honeycomb.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Honeycomb&lt;/a&gt;强调了&lt;a href=&#34;https://www.honeycomb.io/blog/observability-driven-development&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在开发过程中使用可观测性&lt;/a&gt;，而像&lt;a href=&#34;http://digma.ai/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Digma.ai&lt;/a&gt;和 Tracetest 这样的工具正在推动这一前进。&lt;/p&gt;
&lt;h2 id=&#34;浏览器&#34;&gt;浏览器&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 的主要作用一直局限于仪器化后端系统，而基于开放标准的浏览器仪器化仍然是实验性的，进展缓慢。正在努力改进和标准化这种仪器化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tracetest.io/case-studies/how-uzufly-built-end-to-end-testing-serverless-web-app-with-distributed-traces&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Uzufly&lt;/a&gt;在这方面脱颖而出。它使用现有的客户端仪器化来构建测试。展望未来，它的雄心是扩展基于跟踪的测试，以覆盖浏览器内部发起的前端操作所进行的测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这将实现前端和后端的全面端到端测试。请关注 2024 年更多关于这个主题的信息！&lt;/p&gt;
&lt;h2 id=&#34;2023-已经过去&#34;&gt;2023 已经过去&lt;/h2&gt;
&lt;p&gt;告别 2023，我们怀着热情期待 2024 年的到来。OpenTelemetry 具有势头，得到了标准和广泛采用的支持，推动了其增长。新的一年承诺带来令人兴奋的发展，围绕 OpenTelemetry 出现了创新的产品和用例。我迫不及待地想看到 2024 年将揭示的进步和创新。愿 OpenTelemetry 长存！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OpenTelemetry 最佳实践：用户入门指南</title>
      <link>https://cloudnative.to/blog/opentelemetry-best-practices/</link>
      <pubDate>Fri, 22 Dec 2023 09:14:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/opentelemetry-best-practices/</guid>
      <description>&lt;h2 id=&#34;编者按&#34;&gt;编者按&lt;/h2&gt;
&lt;p&gt;本文译自：&lt;a href=&#34;https://grafana.com/blog/2023/12/18/opentelemetry-best-practices-a-users-guide-to-getting-started-with-opentelemetry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry best practices: A user&amp;rsquo;s guide to getting started with OpenTelemetry&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要：文章介绍了 OpenTelemetry 的概念和优势，以及如何使用 Grafana 的分发版进行自动和手动的仪表化、配置和导出数据。&lt;/p&gt;
&lt;p&gt;评论：这是一篇非常实用和有价值的文章，它为 OpenTelemetry 的新手和老手提供了一些最佳实践和技巧，帮助他们更好地利用这个强大的服务网格平台，实现应用程序的可观测性和安全性。文章不仅介绍了 OpenTelemetry 的基本概念和组件，还展示了如何使用 Grafana 的分发版，轻松地对 Java 和 .NET 应用程序进行仪表化，发送遥测数据到 Grafana Cloud，以及优化数据的质量和成本。文章还提供了一些有用的链接和资源，供读者进一步学习和探索。我认为这篇文章是 OpenTelemetry 的一个很好的入门指南，也是 Grafana 的一个很好的推广案例，值得云原生社区的关注和推荐。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;p&gt;如果你正在阅读这篇博客，你很可能要么考虑开始你的 OpenTelemetry 之旅，要么已经在路上。随着 OpenTelemetry 的采用不断增长，不仅在可观察性社区内，还在 Grafana Labs 内部以及我们的用户中，我们经常收到关于如何最佳实施 OpenTelemetry 策略的请求。&lt;/p&gt;
&lt;p&gt;Grafana Labs 全力支持 OpenTelemetry，在我们的开源项目和产品中构建了与之兼容性，并积极参与了 OTel 社区。在过去的一年中，我们在 OpenTelemetry 上的两个主要关注领域分别是&lt;a href=&#34;https://grafana.com/blog/2023/07/20/a-practical-guide-to-data-collection-with-opentelemetry-and-prometheus/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;与 Prometheus 的互操作性&lt;/a&gt;和&lt;a href=&#34;https://grafana.com/docs/opentelemetry/instrumentation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;仪表 SDK&lt;/a&gt;。我们还为 OTel Collector 贡献了对 Prometheus 本地直方图的支持。 （有趣的事实：Grafana Labs 是唯一一家在对 Prometheus &lt;em&gt;和&lt;/em&gt; OpenTelemetry 的贡献方面处于领先地位的公司。）&lt;/p&gt;
&lt;p&gt;以下是基于常见问题、经常讨论的主题和我们自己的经验的 OpenTelemetry 最佳实践汇编。我们希望你会在实施过程中记住一些有用的提示和技巧。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-仪表化&#34;&gt;OpenTelemetry 仪表化&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：使用自动仪表化开始。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;自动仪表化旨在涵盖各种用例，因此它不会始终提供专业信息（例如，你实施的任何专有 IP 或业务代码）。如果有疑问，可以从自动仪表化开始，如果缺少某些内容，然后考虑添加手动仪表化，在缺少细节的地方以及去掉你不需要的内容。&lt;/p&gt;
&lt;p&gt;你可以了解更多关于&lt;a href=&#34;https://grafana.com/blog/2023/11/16/the-grafana-opentelemetry-distribution-for-.net-optimized-for-application-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana .NET 的自动仪表化&lt;/a&gt;和&lt;a href=&#34;https://grafana.com/blog/2023/11/16/the-grafana-opentelemetry-distribution-for-java-optimized-for-application-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana Java 的自动仪表化&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;首先初始化-opentelemetry&#34;&gt;首先初始化 OpenTelemetry&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：确保你实际收集到你想要的一切。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在使用任何应该被仪表化的库之前，你应该始终初始化 OpenTelemetry 和应用程序前面定义的任何变量。否则，你将无法找到所需的跨度。&lt;/p&gt;
&lt;p&gt;对于自动仪表化，这意味着将相关的 OpenTelemetry 框架添加到你的代码中（例如，在 Java 中，这包括将 OpenTelemetry JAR 文件与你的应用程序一起使用）。&lt;/p&gt;
&lt;p&gt;在手动仪表化的情况下，这包括将 OpenTelemetry SDK 库导入你的代码中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：说到手动仪表化，不要忘记结束你的跨度！一个跨度始终应该有一个开始和一个结束。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;opentelemetry-属性生成&#34;&gt;OpenTelemetry 属性生成&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：确保你的数据一致且有意义。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;通常，你应该只包括与跨度代表的操作相关的属性。例如，如果你正在跟踪 HTTP 请求，你可以包括属性，如请求方法、URL 和响应状态代码。&lt;/p&gt;
&lt;p&gt;如果你不确定是否应该包括某个属性，最好谨慎行事，不要包括它。如果需要，你随时可以稍后添加更多属性！&lt;/p&gt;
&lt;h3 id=&#34;关于-opentelemetry-属性的做与不做&#34;&gt;关于 OpenTelemetry 属性的做与不做&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不要&lt;/strong&gt;将度量或日志作为属性放入你的跨度中。让每种遥测类型都尽其所能地完成其工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要&lt;/strong&gt;使用冗余属性。没有必要有五个不同的属性，都指定了服务名称。这只会让最终用户感到困惑，并增加跨度大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;要&lt;/strong&gt;考虑服务流程和在当前跨度上下文中发生的事情，只有在考虑要添加哪些属性时才这样做。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用-opentelemetry-语义&#34;&gt;使用 OpenTelemetry 语义&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;TL;DR：语义是方法。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;OpenTelemetry 的&lt;a href=&#34;https://github.com/open-telemetry/semantic-conventions/blob/main/docs/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;语义约定&lt;/a&gt;提供了描述不同类型实体（属性和资源）的通用词汇表，有助于确保你的数据一致且有意义。如果你刚开始使用 OpenTelemetry，这是一种早期实施的绝佳方法，以确保有一个共同的框架。&lt;/p&gt;
&lt;p&gt;说到框架，命名属性和资源时，优先选择描述性的名称，避免不熟悉的缩写或首字母缩写。确立一致的大写、格式（例如，后缀或前缀）和标点符号样式。&lt;/p&gt;
&lt;h2 id=&#34;关联-opentelemetry-数据&#34;&gt;关联 OpenTelemetry 数据&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：在度量、日志和跨度的用例方面要有战略意识和现实意识，并生成正确的遥测类型来回答问题。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;确保你能够无缝关联这些数据，以便无论存储在哪个后端，都可以跳转到正确的数据。例如，在你已经仪表化的应用程序的日志中记录 traceID，并利用元数据。阅读更多策略&lt;a href=&#34;https://grafana.com/blog/2020/03/31/how-to-successfully-correlate-metrics-logs-and-traces-in-grafana/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此处&lt;/a&gt;！&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-批处理&#34;&gt;OpenTelemetry 批处理&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：根据大小或时间批处理和压缩遥测数据，以便更快地查询数据。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;是否批处理？这又是一个因情况而异的答案。一般来说，批处理可能更受欢迎，因为它将减少你的网络开销，并允许你更好地规划资源消耗；但是，批处理处理器将为数据添加一些处理时间，增加生成和可查询之间的延迟。&lt;/p&gt;
&lt;p&gt;如果你的应用程序需要几乎实时的查询，最好为该应用程序使用简单的处理，并为其他应用程序批处理，但即使使用批处理，数据也会被非常快速地处理，因此这可能不会影响大多数情况！&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-采样&#34;&gt;OpenTelemetry 采样&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：找到适合你用例的采样策略。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;采样可能是一个好主意，但它取决于你的用例。尽管&lt;a href=&#34;https://grafana.com/oss/tempo/?pg=blog&amp;amp;plcmt=body-txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana Tempo&lt;/a&gt;能够存储完整的跟踪数据，但在某些时候，它可能会成为成本考虑因素，或者根据吞吐量和摄取量而定。&lt;/p&gt;
&lt;p&gt;你选择的最佳采样策略将取决于系统的具体要求。可能需要考虑的一些因素包括生成的数据量、系统的性能要求以及遥测数据使用者的具体需求。没有一种大小适合所有的解决方案，因此你需要进行实验，找到最适合你需求的最佳策略。&lt;/p&gt;
&lt;h3 id=&#34;opentelemetry-采样优点&#34;&gt;OpenTelemetry 采样：优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;减少收集的数据量，以节省存储和带宽成本&lt;/li&gt;
&lt;li&gt;提高性能，因为需要处理和传输的数据较少&lt;/li&gt;
&lt;li&gt;过滤噪声，专注于系统的特定部分&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;opentelemetry-采样缺点&#34;&gt;OpenTelemetry 采样：缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;引入偏差到数据中，因为没有收集所有数据&lt;/li&gt;
&lt;li&gt;可能更难排查问题，因为可能无法获得问题的完整上下文&lt;/li&gt;
&lt;li&gt;可能难以实施和管理，因为它需要仔细考虑系统的具体需求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在许多情况下，远程控制的头采样与概率尾采样配对在大多数用例中足够了。阅读我们的&lt;a href=&#34;https://grafana.com/blog/2022/05/11/an-introduction-to-trace-sampling-with-grafana-tempo-and-grafana-agent/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关于跟踪采样的介绍博文&lt;/a&gt;以了解不同策略。&lt;/p&gt;
&lt;h2 id=&#34;跨度事件&#34;&gt;跨度事件&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：充分利用你的跟踪数据。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;跨度事件用于记录在任何单一跨度期间发生的有趣和有意义的事件。跨度始终具有开始和结束，因此可以将用户单击“结账”视为开始（单击）到结束（页面加载）的记录。事件是时间的一个瞬间，例如错误消息或记录页面变得可交互的时间。自动仪表化将为你收集跨度事件中的相关信息。例如，在自动仪表化的 Java 应用程序中，所有异常将自动记录在跨度事件字段中。&lt;/p&gt;
&lt;h2 id=&#34;上下文传播&#34;&gt;上下文传播&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：确保在需要的时间和地点拥有正确的数据。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;虽然手动传播上下文是可能的，但让仪表化库为你处理是更好的实践。对于大多数 OpenTelemetry SDK，如果使用自动仪表化，HTTP 和 gRPC 通信都将包含传播器。除非你的环境中有独特的用例或系统需要，否则应使用&lt;a href=&#34;https://www.w3.org/TR/trace-context/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;W3C 跟踪上下文推荐&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;在适用的情况下使用-baggage&#34;&gt;在适用的情况下使用 Baggage&lt;/h3&gt;
&lt;p&gt;在跨度之间传播键值对时，Baggage 使用 HTTP 标头。以一个原始 IP 的示例。这些数据可能对事务中的第一个服务可用，&lt;/p&gt;
&lt;p&gt;但除非你指定要将其传播到其余跨度，否则后续服务无法访问该数据。使用 Baggage，你可以根据存储为 Baggage 的值将属性添加到未来的跨度中。&lt;/p&gt;
&lt;h2 id=&#34;跨度指标和服务图连接器&#34;&gt;跨度指标和服务图连接器&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：始终充分利用跨度指标以轻松分析 RED 数据！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;跨度指标使你能够查询、分析和基于请求速率、错误率和随时间变化的持续时间（RED 指标）的聚合构建自定义可视化。&lt;/p&gt;
&lt;p&gt;在完全托管的&lt;a href=&#34;https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana Cloud&lt;/a&gt;平台中，可以从你摄取的跟踪中自动生成跨度指标和服务图指标。这与 OpenTelemetry 提供的这些连接器相同的功能，如果喜欢，你可以在收集器侧或使用 Flow 模式中的 Grafana Agent 中实现生成。重要的是跨度指标在某个地方生成！&lt;/p&gt;
&lt;p&gt;你可以在 GitHub 中阅读有关如何配置&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/connector/spanmetricsconnector/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;跨度指标连接器&lt;/a&gt;和&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/connector/servicegraphconnector/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务图连接器&lt;/a&gt;的更多信息。&lt;/p&gt;
&lt;p&gt;你还可以参考我们的文档，了解有关在 Grafana Cloud 中如何配置&lt;a href=&#34;https://grafana.com/docs/tempo/latest/metrics-generator/service_graphs/#how-they-work&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;度量生成器&lt;/a&gt;和&lt;a href=&#34;https://grafana.com/docs/tempo/latest/metrics-generator/span_metrics/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;跨度指标&lt;/a&gt;生成的更多信息。你还可以查看我们关于&lt;a href=&#34;https://grafana.com/blog/2023/12/07/traces-to-metrics-ad-hoc-red-metrics-in-grafana-tempo-with-aggregate-by/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 Grafana Tempo 生成临时 RED 指标&lt;/a&gt;的博客文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;生成-red-指标的选项&#34;&gt;生成 RED 指标的选项&lt;/h3&gt;
&lt;p&gt;在 Grafana Cloud 中，基于摄取的跨度生成指标。如果在 Grafana Agent 或 OpenTelemetry Collector 中使用任何类型的尾采样器，那么那些未采样的跨度将在摄取之前被丢弃。如果使用 10% 的概率采样器，这意味着你只看到 10% 的跟踪范围的指标。显然，这会极大地影响观察到的生成指标，并且如果发生错误、延迟等采样，那么这些指标可能不会有用（尽管 Tempo 和 Grafana Cloud Traces 包括一个选项，可以粗略地将跨度值乘以以使其具有代表性）。&lt;/p&gt;
&lt;p&gt;Grafana Agent（如果管道配置正确）在尾采样发生之前从跨度生成指标。因此，仍然依赖这些收集器中可以发送到 Grafana 的本地指标生成将为所有跨度进行采样前提供准确的反映。即使采样也可以实现准确的指标活动系列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;opentelemetry-架构&#34;&gt;OpenTelemetry 架构&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：使用收集器！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;无论你选择 Grafana Agent 分发还是 OpenTelemetry Collector，都可以在存储之前对数据进行批处理、压缩、变异和转换。作为一个集中的代理，这种实现还提供了一个中央的单一位置来管理密钥。&lt;/p&gt;
&lt;p&gt;使用收集器提供的所有灵活性，你可以实现无限的用例。即使现在你没有任何想法，部署收集器在长期内几乎肯定会对你有益。通常情况下，我们建议你&lt;strong&gt;仅在测试或小规模开发场景下直接发送到 OTLP 端点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最终的架构可能如下所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-opentelemetry-collector-通用架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;OpenTelemetry Collector 通用架构图&#34; srcset=&#34;
               /blog/opentelemetry-best-practices/network-architecture-opentelemetry-grafana-cloud_hu1e9c21e999f8d3992c652a74096386db_98438_ae59c6d77bc8676ab8b8287b2a74ad17.webp 400w,
               /blog/opentelemetry-best-practices/network-architecture-opentelemetry-grafana-cloud_hu1e9c21e999f8d3992c652a74096386db_98438_53febc79e85d70cae3b744e621c5e67d.webp 760w,
               /blog/opentelemetry-best-practices/network-architecture-opentelemetry-grafana-cloud_hu1e9c21e999f8d3992c652a74096386db_98438_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/opentelemetry-best-practices/network-architecture-opentelemetry-grafana-cloud_hu1e9c21e999f8d3992c652a74096386db_98438_ae59c6d77bc8676ab8b8287b2a74ad17.webp&#34;
               width=&#34;760&#34;
               height=&#34;641&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      OpenTelemetry Collector 通用架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果你仍然对收集器有疑虑，请查看我们最近的&lt;a href=&#34;https://grafana.com/blog/2023/11/21/do-you-need-an-opentelemetry-collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;你是否需要 OpenTelemetry 收集器？&lt;/a&gt;博客文章。&lt;/p&gt;
&lt;h3 id=&#34;opentelemetry-collector-部署架构&#34;&gt;OpenTelemetry Collector 部署架构&lt;/h3&gt;
&lt;p&gt;在决定部署的生产架构时，需要考虑许多因素。有关不同部署选项的详细信息，请参阅我们的&lt;a href=&#34;https://grafana.com/docs/opentelemetry/collector/use-cases/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;用例&lt;/a&gt;文档。&lt;/p&gt;
&lt;h2 id=&#34;使用导出器&#34;&gt;使用导出器&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TL;DR：确保将数据发送到某个地方。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;所以你的收集器正在运行？在 Grafana Agent 或 OpenTelemetry Collector 中使用一个或多个导出器将数据发送到后端或记录到控制台以进行故障排除。如果你正在进行测试或积极开发，为什么不两者都使用呢？这两个选项都支持使用多个导出器，因此你可以在收集器中使用特定于供应商的组合和日志导出器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示：了解你的限制&lt;/strong&gt;
在 Grafana Tempo 中，围绕跟踪/跨度和属性大小设置了一些默认限制。&lt;/p&gt;
&lt;p&gt;最大属性值长度：2046
最大跟踪大小：50MB&lt;/p&gt;
&lt;p&gt;我们还实施了&lt;a href=&#34;https://opentelemetry.io/docs/specs/otel/common/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 规范&lt;/a&gt;中的默认限制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;充分利用-grafana-cloud-的-opentelemetry-数据&#34;&gt;充分利用 Grafana Cloud 的 OpenTelemetry 数据&lt;/h2&gt;
&lt;p&gt;Grafana Cloud 是开始有效可视化、查询和关联 OpenTelemetry 数据的最简单方法。通过启用&lt;a href=&#34;https://grafana.com/blog/2023/11/14/announcing-application-observability-in-grafana-cloud-with-native-support-for-opentelemetry-and-prometheus/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Observability&lt;/a&gt;，该功能与 OpenTelemetry 和 Prometheus 兼容，你将获得一组与 OpenTelemetry 数据本地集成的预构建 Grafana 仪表板。尽管开箱即用的仪表板总是不错的，但有时你可能希望构建自己的仪表板。以下是一个示例，演示了如何基于你的 OpenTelemetry 跟踪和跨度指标构建自定义仪表板。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-使用-opentelemetry-数据的-grafana-仪表板&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;使用 OpenTelemetry 数据的 Grafana 仪表板&#34; srcset=&#34;
               /blog/opentelemetry-best-practices/grafana-dashboard-opentelemetry-traces-metrics_hud7c53683209fbae1371f263d077d50a0_185239_a2fdac4b23de6fab36baef44a13b0c0f.webp 400w,
               /blog/opentelemetry-best-practices/grafana-dashboard-opentelemetry-traces-metrics_hud7c53683209fbae1371f263d077d50a0_185239_f35b7c50245a7b34496fdccb56e34e3b.webp 760w,
               /blog/opentelemetry-best-practices/grafana-dashboard-opentelemetry-traces-metrics_hud7c53683209fbae1371f263d077d50a0_185239_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/opentelemetry-best-practices/grafana-dashboard-opentelemetry-traces-metrics_hud7c53683209fbae1371f263d077d50a0_185239_a2fdac4b23de6fab36baef44a13b0c0f.webp&#34;
               width=&#34;613&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      使用 OpenTelemetry 数据的 Grafana 仪表板
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果你正在使用 Grafana Cloud，还可以考虑超越常规，将你的 OpenTelemetry 数据与其他功能集成。例如，如果你的应用程序在预期值之外看到请求的异常增加，是否可以使用&lt;a href=&#34;https://grafana.com/docs/grafana-cloud/alerting-and-irm/machine-learning/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana 机器学习&lt;/a&gt;来发现？&lt;/p&gt;
&lt;p&gt;要了解有关 OpenTelemetry 和 Grafana Cloud 的更多信息，请阅读我们的&lt;a href=&#34;https://grafana.com/docs/grafana-cloud/monitor-infrastructure/integrations/integration-reference/integration-opentelemetry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 OpenTelemetry 提升 CI/CD 管道的可观察性</title>
      <link>https://cloudnative.to/blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/</link>
      <pubDate>Tue, 12 Dec 2023 14:30:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://thenewstack.io/how-to-observe-your-ci-cd-pipelines-with-opentelemetry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://thenewstack.io/how-to-observe-your-ci-cd-pipelines-with-opentelemetry&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘要：这篇文章介绍了 OpenTelemetry 这个开源框架，它可以帮助你生成、收集换和导出 CI/CD 管道的遥测数据，以实现性能、可靠性、安全性等方面的度量、监控、告警、分析等功能。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如今的软件比 20 多年前的软件复杂得多，这带来了在故障排除代码时面临新挑战。幸运的是，通过将可观测性引入我们的系统，我们在理解应用程序的性能如何以及问题发生在何处方面取得了相当大的进展。&lt;/p&gt;
&lt;p&gt;然而，不仅软件发生了演变 - 创建和开发软件的过程也发生了变化。&lt;a href=&#34;https://roadmap.sh/devops&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DevOps&lt;/a&gt;引入了&lt;a href=&#34;https://thenewstack.io/a-primer-continuous-integration-and-continuous-delivery-ci-cd/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CI/CD的概念&lt;/a&gt;。随着交付周期从每月、每季度，到现在每周甚至一天多次，我们正在全面采用自动化来进行软件交付。&lt;/p&gt;
&lt;p&gt;不幸的是，与应用程序软件相比，&lt;a href=&#34;https://thenewstack.io/ci-cd/&#34; title=&#34;CI/CD pipelines&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CI/CD流水线&lt;/a&gt;的可观测性进展不大。考虑到这些流水线是软件交付流程的基础，这令人惊讶：如果你没有可见性，那么当出现问题且无法将软件投入生产时，你该如何排除问题？&lt;/p&gt;
&lt;p&gt;这正是本文将重点讨论的内容：CI/CD 流水线的可观测性。首先，我们将定义一些概念；然后，我们将深入探讨观察流水线的重要性以及如何使其可观测；最后，我们将讨论一些尚未解决的挑战。&lt;/p&gt;
&lt;h2 id=&#34;关键概念&#34;&gt;关键概念&lt;/h2&gt;
&lt;p&gt;以下是一些需要了解的定义：&lt;/p&gt;
&lt;h3 id=&#34;可观测性&#34;&gt;可观测性&lt;/h3&gt;
&lt;p&gt;有关&lt;a href=&#34;https://thenewstack.io/observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可观测性&lt;/a&gt;有多种定义，因此我们将其缩小为我们最喜欢的定义：&lt;/p&gt;
&lt;p&gt;可观测性，或简称 o11y（发音为“ollie”），允许你通过不了解系统内部运作方式就能从外部了解系统。有趣的是：“o11y”中的数字 11 代表了“可观测性”一词中的字母“o”和“y”之间的字符数。&lt;/p&gt;
&lt;p&gt;这意味着即使你不了解系统的所有细节业务逻辑，系统仍会发出足够的信息，使你能够通过跟踪线索来回答：“为什么会发生这种情况？”但是，如果你的系统不发出信息，那么你就无法进行观察。你如何获取这些信息呢？一种方式是使用 OpenTelemetry。&lt;/p&gt;
&lt;h3 id=&#34;opentelemetry&#34;&gt;OpenTelemetry&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://thenewstack.io/introducing-opentelemetry-in-your-organization-3-steps/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry（OTel）&lt;/a&gt;是一个用于生成、收集、转换和导出遥测数据的开源可观测性框架。它提供了一组 API、软件开发工具包（SDK）、仪器库和工具，帮助你完成这些任务。自 2019 年正式成立以来，它已成为应用程序仪器和遥测生成和收集的事实标准，被包括&lt;a href=&#34;https://innovation.ebayinc.com/tech/engineering/why-and-how-ebay-pivoted-to-opentelemetry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBay&lt;/a&gt;和&lt;a href=&#34;https://www.infoq.com/presentations/opentelemetry-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Skyscanner&lt;/a&gt;在内的公司使用。&lt;/p&gt;
&lt;p&gt;其最大的好处之一是不受供应商锁定的限制。你可以为应用程序添加遥测一次，并将遥测发送到最适合你的后端。它还提供一些非常酷的工具，例如 Collector。&lt;/p&gt;
&lt;p&gt;Collector 是一个供应商中立的服务，用于接收、转换和导出数据到一个或多个可观测性后端。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-otel-collector-组件的图示&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;OTel Collector 组件的图示&#34; srcset=&#34;
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/1_hub324021bb8008512e57337f27dac5f93_39000_7e054da520dcf8fbfadfe76b5f62f958.webp 400w,
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/1_hub324021bb8008512e57337f27dac5f93_39000_a71a87fc736a69596d4529a63c625ad8.webp 760w,
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/1_hub324021bb8008512e57337f27dac5f93_39000_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/1_hub324021bb8008512e57337f27dac5f93_39000_7e054da520dcf8fbfadfe76b5f62f958.webp&#34;
               width=&#34;760&#34;
               height=&#34;272&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      OTel Collector 组件的图示
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Collector 由四个主要组件组成，这些组件访问遥测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Receivers&lt;/strong&gt; 接收数据，无论是来自你的应用程序代码还是基础架构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Processors&lt;/strong&gt; 转换数据。处理器可以执行诸如模糊化数据、添加属性、删除属性或过滤数据等操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exporters&lt;/strong&gt; 将数据转换为与你选择的可观测性后端兼容的格式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Connectors&lt;/strong&gt; 允许你连接两个流水线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以将 OTel Collector 视为数据管道。&lt;/p&gt;
&lt;h3 id=&#34;cicd-流水线&#34;&gt;CI/CD 流水线&lt;/h3&gt;
&lt;p&gt;CI/CD 是一种自动化的软件交付方法，依赖于两个关键实践：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续集成（CI）是指在进行代码更改时构建、打包和测试软件。&lt;/li&gt;
&lt;li&gt;连续交付（CD）是指立即将该软件包部署到生产环境中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-cicd-流水线-gif其中有只猫在其中移动&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;CI/CD 流水线 GIF，其中有只猫在其中移动&#34;
           src=&#34;https://cloudnative.to/blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/2.gif&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      CI/CD 流水线 GIF，其中有只猫在其中移动
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;自动化的流水线通过允许你更快地向客户提供新功能、修复错误和一般更新来实现快速的产品迭代。它们消除了手动错误的风险，并标准化了对开发人员的反馈循环。&lt;/p&gt;
&lt;h2 id=&#34;为何-cicd-流水线的可观测性很重要&#34;&gt;为何 CI/CD 流水线的可观测性很重要&lt;/h2&gt;
&lt;p&gt;当你的流水线健康时，你的团队可以持续编写、构建、测试和部署代码和配置更改到生产环境。你还可以改进或实现开发敏捷性，这意味着你可以更改运营方式并最小化确定这些修改是否对应用程序的健康产生了积极或消极影响所需的时间。&lt;/p&gt;
&lt;p&gt;相反，当你的流水线不健康时，你可能会遇到以下一种或多种问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;部署缓慢&lt;/strong&gt;：修复错误可能不够快，以制止用户的不满，问题可能会变得严重。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试问题&lt;/strong&gt;：不得不等待测试完成，或没有足够的时间来测试不同的配置，可能会导致延迟的部署和难以在用户群中实现足够的应用程序性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术债务&lt;/strong&gt;：难以确定底层问题可能导致技术债务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-处于燃烧房间中的猫说一切正常&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;处于燃烧房间中的猫说：“一切正常。”&#34; srcset=&#34;
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/3_hucc598ff7983effda9403f72784f50a7e_342512_f81563b07d737636c0c5d022ee172e2b.webp 400w,
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/3_hucc598ff7983effda9403f72784f50a7e_342512_638c70f7bba482d7f806ec2ff825d8e2.webp 760w,
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/3_hucc598ff7983effda9403f72784f50a7e_342512_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/3_hucc598ff7983effda9403f72784f50a7e_342512_f81563b07d737636c0c5d022ee172e2b.webp&#34;
               width=&#34;760&#34;
               height=&#34;427&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      处于燃烧房间中的猫说：“一切正常。”
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;流水线是-devops-工程师的生产系统&#34;&gt;流水线是 DevOps 工程师的生产系统&lt;/h3&gt;
&lt;p&gt;虽然流水线可能不是外部用户与之互动的生产环境，但它们绝对是内部用户 - 例如，软件工程师和&lt;a href=&#34;https://thenewstack.io/our-2023-site-reliability-engineering-wish-list/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;站点可靠性工程师&lt;/a&gt;（SRE）- 与之互动的生产环境。能够观察你的生产环境意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免不必要的长周期时间或更改的引导时间，这会影响提交进入生产所需的时间。&lt;/li&gt;
&lt;li&gt;减少推出新功能和错误修复的等待时间。&lt;/li&gt;
&lt;li&gt;缩短用户等待时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;代码可能会失败&#34;&gt;代码可能会失败&lt;/h3&gt;
&lt;p&gt;CI/CD 流水线由定义其工作方式的代码运行，尽管你付出了最大的努力，代码仍然可能会失败。使应用程序代码可观测有助于你在遇到生产问题时理清头绪。同样，了解你的流水线可以帮助你了解它们失败时发生了什么。&lt;/p&gt;
&lt;h3 id=&#34;故障排除更容易&#34;&gt;故障排除更容易&lt;/h3&gt;
&lt;p&gt;具有可观测的流水线有助于回答以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么失败了？&lt;/li&gt;
&lt;li&gt;为什么失败了？&lt;/li&gt;
&lt;li&gt;是否曾经失败过？&lt;/li&gt;
&lt;li&gt;最常发生了什么失败？&lt;/li&gt;
&lt;li&gt;流水线的正常运行时间是多少？&lt;/li&gt;
&lt;li&gt;是否存在任何瓶颈？如果有，它们是什么？&lt;/li&gt;
&lt;li&gt;你能够缩短修复流水线问题的导向时间吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;想要收集什么样的数据&#34;&gt;想要收集什么样的数据？&lt;/h3&gt;
&lt;p&gt;要回答这些问题，你需要收集有关你的流水线的信息。但是这些信息应该是什么呢？捕获诸如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分支名称。&lt;/li&gt;
&lt;li&gt;提交的安全哈希算法（SHA）。&lt;/li&gt;
&lt;li&gt;机器 IP。&lt;/li&gt;
&lt;li&gt;运行类型（按计划执行，由合并/推送触发）。&lt;/li&gt;
&lt;li&gt;失败的步骤。&lt;/li&gt;
&lt;li&gt;步骤持续时间。&lt;/li&gt;
&lt;li&gt;构建编号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何观察流水线&#34;&gt;如何观察流水线&lt;/h2&gt;
&lt;p&gt;请记住，当系统发出足够的信息来回答问题：“为什么会发生这种情况？”时，系统就是可观测的。首先，你需要一种方法来发出这些信息；然后，你需要一个发送信息的地方；最后，你需要分析信息并找出需要修复的问题。&lt;/p&gt;
&lt;p&gt;这就是 OpenTelemetry 的用武之地。你可以在系统中实施 OpenTelemetry，以发出你需要实现系统可观测性的信息。与用于应用程序的方式一样，你也可以将其用于 CI/CD 流水线！仍然需要将生成的遥测数据发送到后端进行分析，但我们将专注于第一个部分，即仪器化。&lt;/p&gt;
&lt;h3 id=&#34;使用-opentelemetry&#34;&gt;使用 OpenTelemetry&lt;/h3&gt;
&lt;p&gt;对于仪器化 CI/CD 流水线来说，OpenTelemetry 是一个很合理的选择，因为许多人已经在应用程序中使用它进行仪器化；在过去的几年中，采用和实施逐渐增加。&lt;/p&gt;
&lt;h3 id=&#34;有哪些选项&#34;&gt;有哪些选项？&lt;/h3&gt;
&lt;p&gt;目前，情况有些复杂。存在以下选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商业 SaaS 监控解决方案，如&lt;a href=&#34;https://www.datadoghq.com/product/ci-cd-monitoring/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Datadog&lt;/a&gt;和&lt;a href=&#34;https://www.splunk.com/en_us/blog/learn/ci-cd-devops-analytics.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Splunk&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;供应商创建的工具，你可以将其插入现有的 CI/CD 工具中，以帮助实现 CI/CD 可观测性（例如，&lt;a href=&#34;https://github.com/honeycombio/buildevents&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Honeycomb buildevents&lt;/a&gt;、&lt;a href=&#34;https://docs.newrelic.com/docs/codestream/how-use-codestream/cicd/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;New Relic 的 Codestream 与 CircleCI 集成&lt;/a&gt;和&lt;a href=&#34;https://docs.newrelic.com/docs/change-tracking/ci-cd/change-tracking-github-actions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub Actions 的更改跟踪&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;自制的 GitHub actions（请参阅&lt;a href=&#34;https://github.com/inception-health/otel-export-trace-action&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;、&lt;a href=&#34;https://words.boten.ca/GitHub-Action-to-OTLP/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;和&lt;a href=&#34;https://cloud-native.slack.com/archives/C0598R66XAP/p1698393723861129&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;的示例），以在 CI/CD 流水线中启用可观测性。&lt;/li&gt;
&lt;li&gt;自制的 &lt;a href=&#34;https://github.com/DavidS/circleci-hook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CircleCI OTel webhook&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;自制的 &lt;a href=&#34;https://cloud-native.slack.com/archives/C0598R66XAP/p1698408390701199&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Drone CI OTel webhook&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;将 OpenTelemetry 原生集成到 &lt;a href=&#34;https://plugins.jenkins.io/opentelemetry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jenkins&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/tektoncd/community/blob/main/teps/0124-distributed-tracing-for-tasks-and-pipelines.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tekton&lt;/a&gt; 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你还可以将这些工具集成到你的 CI/CD 流水线中；它们会发出 OpenTelemetry 信号，从而帮助使你的流水线可观测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-java-contrib/blob/main/maven-extension/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maven 构建 OTel 扩展&lt;/a&gt;发出 Java 构建的分布式跟踪。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/collections/community/general/opentelemetry_callback.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ansible OpenTelemetry 回调&lt;/a&gt;跟踪 Ansible playbooks。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dynatrace-oss/junit-jupiter-open-telemetry-extension&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dynatrace 的 JUnit Jupiter OpenTelemetry 扩展&lt;/a&gt;是用于通过 OpenTelemetry 收集 JUnit 测试执行数据的 Gradle 插件。还有一个&lt;a href=&#34;https://github.com/dynatrace-oss/junit-jupiter-open-telemetry-extension/packages/1061205&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maven 版本&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pypi.org/project/pytest-otel/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pytest-otel&lt;/a&gt;记录执行的 Python 测试的分布式跟踪。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/equinix-labs/otel-cli&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;otel-cli&lt;/a&gt;是用 Go 编写的命令行界面（CLI）工具，可使 shell 脚本发出跟踪信号。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/filelogreceiver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Filelog 接收器&lt;/a&gt;（OTel Collector）从文件中读取和解析日志。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/gitproviderreceiver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Git 提供商接收器&lt;/a&gt;（OTel Collector）从 Git 供应商处获取数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;可观测的流水线示例&#34;&gt;可观测的流水线示例&lt;/h2&gt;
&lt;p&gt;以下图表显示了如何使用上述提到的一些工具实现流水线可观测性。假设你正在构建和部署一个 Java 应用程序。你正在使用 Jenkins 来编排构建和部署过程。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-启用了-otel-的-jenkins-cicd-流水线&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;启用了 OTel 的 Jenkins CI/CD 流水线&#34; srcset=&#34;
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/4_huc1771516b10019a0f9db7a99859b125f_108196_04bf2a16501e0d7fe30c9ce76e39afad.webp 400w,
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/4_huc1771516b10019a0f9db7a99859b125f_108196_a5d0354f3fb81ef664dca8f74520c5b4.webp 760w,
               /blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/4_huc1771516b10019a0f9db7a99859b125f_108196_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/how-to-observe-your-ci-cd-pipelines-with-opentelemetry/4_huc1771516b10019a0f9db7a99859b125f_108196_04bf2a16501e0d7fe30c9ce76e39afad.webp&#34;
               width=&#34;760&#34;
               height=&#34;333&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      启用了 OTel 的 Jenkins CI/CD 流水线
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Jenkins CI/CD 流水线可以通过&lt;a href=&#34;https://plugins.jenkins.io/opentelemetry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jenkins OTel 插件&lt;/a&gt;发出遥测信号。&lt;/li&gt;
&lt;li&gt;在构建阶段中：
&lt;ul&gt;
&lt;li&gt;你可以使用&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-java-contrib/blob/main/maven-extension/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maven OTel 扩展&lt;/a&gt;发出 Java 构建的分布式跟踪。&lt;/li&gt;
&lt;li&gt;如果你的构建包括 shell 脚&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本，你可以使用&lt;a href=&#34;https://github.com/equinix-labs/otel-cli&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;otel-cli&lt;/a&gt;工具来使你的 shell 脚本能够发出跟踪信号。
3. 在测试阶段中，&lt;a href=&#34;https://github.com/dynatrace-oss/junit-jupiter-open-telemetry-extension/packages/1061205&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maven 的 JUnit Jupiter 插件&lt;/a&gt;允许你通过 OpenTelemetry 收集 JUnit 测试执行数据。
4. 在打包阶段中，使用 Artifactory 来打包你的应用程序，你可以将其日志发送给 OTel Collector，通过&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/filelogreceiver/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Filelog 接收器&lt;/a&gt;进行解析，该接收器会从文件中读取和解析日志。
5. 在部署阶段，使用 Ansible 来编排你的部署，&lt;a href=&#34;https://docs.ansible.com/ansible/latest/collections/community/general/opentelemetry_callback.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ansible OpenTelemetry 回调&lt;/a&gt;会将跟踪添加到你的 Ansible playbooks 中。如果你的 Ansible playbook 还使用 shell 脚本，它可以利用&lt;a href=&#34;https://github.com/equinix-labs/otel-cli&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;otel-cli&lt;/a&gt;工具，使你的 shell 脚本发出额外的跟踪数据。
6. 各种插件发出的信号被 OTel Collector 捕获。可以使用标准的&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector/tree/main/receiver/otlpreceiver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OTLP 接收器&lt;/a&gt;来接收遥测数据，以及&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/gitproviderreceiver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Git 提供商接收器&lt;/a&gt;和&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/filelogreceiver/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Filelog 接收器&lt;/a&gt;。然后，Collector 将遥测信号发送到可观测性后端。
7. 一旦你的数据到达可观测性后端，你可以查看和查询数据，设置警报等等。&lt;/p&gt;
&lt;h2 id=&#34;实现可观测流水线的挑战&#34;&gt;实现可观测流水线的挑战&lt;/h2&gt;
&lt;p&gt;虽然使用 OpenTelemetry 实现 CI/CD 流水线可观测性是有道理的，但缺乏标准化，工具情况有点混乱。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 并未集成到大多数 CI/CD 工具中。虽然有人希望将观察能力添加到诸如 GitLab 和 GitHub Actions 等 CI/CD 工具中，但这些倡议进展缓慢。例如，尽管&lt;a href=&#34;https://gitlab.com/gitlab-org/gitlab/-/issues/338943&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitLab 有关使用 OTel 进行流水线可观测性的请求&lt;/a&gt;存在活动，但该请求已经开放了两年。&lt;a href=&#34;https://github.com/open-telemetry/oteps/pull/223&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;有关 CI/CD 流水线可观测性的 OTel 提案&lt;/a&gt;于 2023 年 1 月提出，但（截至 2023 年 11 月）自 7 月以来尚未有任何活动。&lt;/p&gt;
&lt;p&gt;因此，如果你想使用这些工具，你将取决于创建自己工具的个人和组织是否愿意维护这些工具。如果他们决定不再维护这些工具，会发生什么呢？&lt;/p&gt;
&lt;h2 id=&#34;了解更多&#34;&gt;了解更多&lt;/h2&gt;
&lt;p&gt;使你的 CI/CD 流水线可观测有助于更有效地排除问题，实现开发敏捷性，并深入了解其内部工作原理，以便你可以调整它们以使其运行更高效。&lt;/p&gt;
&lt;p&gt;健康的流水线意味着你可以连续编写、构建、测试和部署新代码。相反，不健康的流水线可能意味着部署较慢，测试问题和技术债务。&lt;/p&gt;
&lt;p&gt;你可以使用 OpenTelemetry 在流水线中添加可观测性；尽管当前选项有限，但事情正在朝着正确的方向发展，我们对 CI/CD 的未来充满期待！&lt;/p&gt;
&lt;p&gt;进一步阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://logz.io/learn/cicd-observability-jenkins&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;解决慢和不稳定的 CI/CD 流水线始于可观测性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/pulse/leveraging-opentelemetry-enhance-ansible-jaeger-tracing-infralovers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;利用 OpenTelemetry 增强 Ansible 的 Jaeger 跟踪&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.splunk.com/en_us/blog/learn/monitoring-ci-cd.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CI/CD 流水线监控：简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在&lt;a href=&#34;https://communityinviter.com/apps/cloud-native/cncf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Slack&lt;/a&gt;的&lt;a href=&#34;https://cloud-native.slack.com/archives/C0598R66XAP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cicd-o11y&lt;/a&gt;频道中查看更多信息。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>OpenTelemetry Protocol (OTLP) 1.0.0 发布</title>
      <link>https://cloudnative.to/blog/otlp-version-one-released/</link>
      <pubDate>Sun, 06 Aug 2023 13:05:42 +0800</pubDate>
      <guid>https://cloudnative.to/blog/otlp-version-one-released/</guid>
      <description>&lt;p&gt;摘要：OpenTelemetry Protocol (OTLP) 1.0.0 已发布，它是 OpenTelemetry 项目中的通用遥测数据传递协议。OpenTelemetry 是一个开源的可观测性框架，提供了一组 API、库、代理和收集器服务，用于捕获分布式跟踪和指标。OTLP 在客户端和服务器之间进行数据交换，定义了一个序列化模式，紧密遵循跟踪、指标和日志的数据模型。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&#34;https://www.infoq.com/news/2023/08/otlp-version-one-released/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.infoq.com/news/2023/08/otlp-version-one-released/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近，&lt;a href=&#34;https://opentelemetry.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt; Protocol (OTLP) 1.0.0 发布了。OTLP 规范描述了遥测数据在遥测源、收集器等中间节点和遥测后端之间的编码、传输和传递机制。它是 OpenTelemetry 项目中设计的通用遥测数据传递协议。&lt;/p&gt;
&lt;p&gt;OpenTelemetry (OTEL) 是一个由 OpenCensus 和 OpenTracing 项目合并形成的开源 Cloud Native Computing Foundation (CNCF) 项目。它是一个供仪表化、生成、收集和导出遥测数据（例如跟踪、指标和日志）使用的供应商中立的开源可观测性框架。该框架提供了一组 API、库、代理和收集器服务，用于捕获分布式跟踪和指标。此外，它的规范在 2021 年早些时候达到了 1.0.0 版本状态，并被 InfoQ 报道。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 通过使用 API 来仪表化应用程序代码，以生成遥测数据，并在不同的 SDK 实现之间无缝地引导收集指标。它提供了针对特定语言的集成和库，例如 Java、Golang、.NET 和 Python 的 OTel SDK，以使开发人员能够仪表化其代码并捕获遥测数据。这些库中的遥测数据被收集并传输到 OpenTelemetry Collector，利用 OTLP 在客户端和服务器之间进行数据交换。OTLP 定义了一个序列化模式，紧密遵循跟踪、指标和日志的数据模型。&lt;/p&gt;
&lt;p&gt;作为中央存储库，OpenTelemetry Collector 接收、处理和导出从各种源收集的遥测数据，既作为单个应用程序的本地代理，也作为多个应用程序的网关。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-opentelemetry-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;OpenTelemetry 架构图&#34;
           src=&#34;https://cloudnative.to/blog/otlp-version-one-released/otel-diagram.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      OpenTelemetry 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Open Telemetry Diagram（来源：&lt;a href=&#34;https://opentelemetry.io/docs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 文档&lt;/a&gt;）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;OTLP 在数据序列化、反序列化和网络服务之间的传输方面发挥着重要作用。该协议旨在指定一个序列化模式，紧密遵循数据模型并解决其他遥测协议的问题。&lt;/p&gt;
&lt;p&gt;Honeycomb 开发者倡导者 &lt;a href=&#34;https://twitter.com/MartinDotNet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Martin Thwaites&lt;/a&gt; 说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OTLP 是 OpenTelemetry 的生命力，使其比以往任何时候都更强大；转向 v1 将把这一点提升到一个新的水平。已经有大多数供应商适应了使用 OTLP 协议接收数据；通过 V1，这将给人们带来一些急需的信心，希望可以让最后几个顽固分子添加 OTLP 支持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外，他表示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这很重要，因为它开启了更多的互操作性，减少了添加专有协议库到我们堆栈中的需求，这对于希望更好地了解其应用程序的情况下获得更多可见性的人来说只能是一个胜利。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，OpenTelemetry 项目目前是 CNCF 的&lt;a href=&#34;https://www.cncf.io/projects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;孵化项目&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何利用 OpenTelemetry 监控和优化 Kubernetes 的性能</title>
      <link>https://cloudnative.to/blog/how-opentelemetry-works-with-kubernetes/</link>
      <pubDate>Tue, 09 May 2023 16:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/blog/how-opentelemetry-works-with-kubernetes/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;摘要：本文译自 &lt;a href=&#34;https://thenewstack.io/how-opentelemetry-works-with-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How OpenTelemetry Works with Kubernetes&lt;/a&gt;。本文介绍了如何将 OpenTelemetry 与 Kubernetes 配合使用。OpenTelemetry 可以作为 Prometheus 的替代品，也可以将数据导出到各种后端，包括 Prometheus。OpenTelemetry Operator 负责部署和管理 OpenTelemetry Collector，该组件是收集、处理和导出遥测数据的中央组件。OpenTelemetry 日志提供了一种标准化的方式来收集、处理和分析分布式系统中的日志。此外，本文还介绍了 OpenTelemetry 的下一步计划，包括 Web 服务器的自动化仪器化、OpenTelemetry Profile 和 Open Agent Management Protocol。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OpenTelemetry 的主要目标是提供一种标准的方式，使开发人员和最终用户能够从他们的应用程序和系统中创建、收集和导出遥测数据，并促进不同可观察性工具和平台之间的互操作性。&lt;/p&gt;
&lt;p&gt;OTEL 支持多种编程语言，包括 &lt;a href=&#34;https://thenewstack.io/getting-started-with-opentelemetry-for-java/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Java&lt;/a&gt;、&lt;a href=&#34;https://thenewstack.io/an-introduction-to-python-a-language-for-the-ages/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Python&lt;/a&gt;、&lt;a href=&#34;https://thenewstack.io/opentelemetry-in-go-its-all-about-context/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go&lt;/a&gt;、&lt;a href=&#34;https://thenewstack.io/why-were-sticking-with-ruby-on-rails-at-gitlab/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ruby&lt;/a&gt; 等，因此可以从不同类型的应用程序和系统中收集遥测数据，是一种多用途的解决方案。&lt;/p&gt;
&lt;p&gt;一旦 OpenTelemetry 组件收集到遥测数据，就可以将其导出到各种后端，如软件即服务解决方案、平台或存储系统，提供存储和查询功能。OpenTelemetry 提供与各种后端的集成，包括 &lt;a href=&#34;https://prometheus.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus&lt;/a&gt;、Jaeger、&lt;a href=&#34;https://zipkin.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zipkin&lt;/a&gt; 等，使导出遥测数据到不同系统变得更加容易。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中使用 OTEL 并不困难。实际上，安装 &lt;a href=&#34;https://thenewstack.io/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 的 OTEL Operator 是一个简单的过程，在本文中，您将学习如何执行此操作。&lt;/p&gt;
&lt;p&gt;通过此 Operator，您可以轻松地管理 Kubernetes 集群中的 OpenTelemetry 组件，并将其配置为导出遥测数据到您选择的后端。这简化了监视 Kubernetes 集群的过程，并使您能够对应用程序的健康和性能做出明智的决策。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-的基本组件&#34;&gt;OpenTelemetry 的基本组件&lt;/h2&gt;
&lt;p&gt;前四个组件用于仪器开发人员或可观察性公司创建可观察性产品。&lt;/p&gt;
&lt;h3 id=&#34;规范&#34;&gt;规范&lt;/h3&gt;
&lt;p&gt;规范提供了定义这些组件的行为和功能的标准化方式，确保在不同的 OpenTelemetry 实现之间保持一致性和兼容性。例如，规范定义了跟踪和指标数据的格式和语义，确保它们可以被系统中的其他组件正确解释。&lt;/p&gt;
&lt;h3 id=&#34;api&#34;&gt;API&lt;/h3&gt;
&lt;p&gt;OpenTelemetry API 为开发人员提供了一种标准的方式来使用跟踪、指标和其他遥测数据对其应用程序进行仪器化。该 API 是语言不可知的，并允许在不同的编程语言和框架之间进行一致的仪器化。&lt;/p&gt;
&lt;p&gt;API 为开发人员提供了一种标准的方式来使用跟踪和指标对其应用程序进行仪器化。&lt;/p&gt;
&lt;h3 id=&#34;sdk&#34;&gt;SDK&lt;/h3&gt;
&lt;p&gt;OpenTelemetry SDK 提供了 OpenTelemetry API 的语言特定实现。SDK 通过提供用于收集和导出遥测数据的库和实用程序，使开发人员更轻松地对其应用程序进行仪器化。&lt;/p&gt;
&lt;h3 id=&#34;数据模型---otlp&#34;&gt;数据模型 - OTLP&lt;/h3&gt;
&lt;p&gt;OpenTelemetry 数据模型提供了一种用于遥测数据的标准化格式，称为 OTLP（OpenTelemetry 协议）。OTLP 是一种供应商中立的格式，使将遥测数据导出到不同的后端和分析工具变得更加容易。&lt;/p&gt;
&lt;p&gt;最后两个组件，OpenTelemetry 自动仪器化和收集器，适用于希望从其应用程序收集和导出遥测数据到不同后端的开发人员，而无需编写自己的仪器化代码。&lt;/p&gt;
&lt;h3 id=&#34;自动仪器化&#34;&gt;自动仪器化&lt;/h3&gt;
&lt;p&gt;OpenTelemetry 包括一个自动仪器化代理，可以注入具有跟踪和指标的应用程序，而无需任何手动仪器化代码。这使得可以向现有应用程序添加可观察性，而无需进行重大代码更改。&lt;/p&gt;
&lt;p&gt;自动仪器化组件可以下载并安装为库或代理，具体取决于使用的编程语言或框架。自动仪器化库会自动将应用程序代码注入 OpenTelemetry API 调用，以捕获和导出遥测数据。&lt;/p&gt;
&lt;h3 id=&#34;收集器&#34;&gt;收集器&lt;/h3&gt;
&lt;p&gt;收集器组件负责从不同来源（如应用程序、服务器和基础架构组件）收集遥测数据，并将其导出到各种后端。&lt;/p&gt;
&lt;p&gt;收集器可以下载并配置以从不同来源收集数据，并可以执行聚合、采样和其他操作，以在导出到不同后端之前对遥测数据执行处理，具体取决于特定用例。&lt;/p&gt;
&lt;h2 id=&#34;telemetry-数据是如何创建的&#34;&gt;Telemetry 数据是如何创建的&lt;/h2&gt;
&lt;p&gt;我们以一个包含三个工作负载的电子商务应用程序为例——前端、驱动程序和客户端——它们通过 HTTP 相互通信。我们想要收集遥测数据以监视这些应用程序的性能和健康状况。&lt;/p&gt;
&lt;p&gt;为此，我们使用 OpenTelemetry API 为每个应用程序实现仪表化：&lt;code&gt;logger.log()&lt;/code&gt;、&lt;code&gt;meter.record()&lt;/code&gt; 和 &lt;code&gt;tracer.span().start()&lt;/code&gt;。这些 API 允许我们创建遥测信号，例如日志、度量和跟踪。&lt;/p&gt;
&lt;p&gt;创建这些信号后，它们被发送或者由 OpenTelemetry 收集器收集，后者充当集中式数据中心。&lt;/p&gt;
&lt;p&gt;收集器负责处理这些信号，其中包括批处理、重新标记、PII 过滤、数据丢弃和聚合等任务，以确保数据准确和有意义。一旦收集器对数据满意，它就将遥测信号发送到平台进行存储和分析。&lt;/p&gt;
&lt;p&gt;收集器可以配置为将这些处理后的信号发送到各种平台，例如 Prometheus、&lt;a href=&#34;https://github.com/grafana/loki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Loki&lt;/a&gt;、Jaeger 或供应商，例如 &lt;a href=&#34;https://www.dynatrace.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dynatrace&lt;/a&gt;、New Relic 等。&lt;/p&gt;
&lt;p&gt;例如，收集器可以将日志发送到类似 Loki 的日志聚合平台、将指标发送到类似 Prometheus 的监控平台、将跟踪发送到类似 Jaeger 的分布式跟踪平台。平台中存储的遥测数据可以用于深入了解系统的行为和性能，并识别需要解决的任何问题。&lt;/p&gt;
&lt;h2 id=&#34;定义-kubernetes-operator-的行为&#34;&gt;定义 Kubernetes Operator 的行为&lt;/h2&gt;
&lt;p&gt;您可以将 OpenTelemetry Operator 部署到 Kubernetes 集群中，并使其自动为应用程序仪表化和收集遥测数据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://opentelemetry.io/docs/k8s-operator/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Kubernetes Operator&lt;/a&gt; 提供了两个自定义资源定义（CRD），用于定义 Operator 的行为。这两个 CRD 共同允许您为应用程序定义 OpenTelemetry Operator 的完整行为。&lt;/p&gt;
&lt;p&gt;这两个 CRD 是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;otelinst&lt;/code&gt;&lt;/strong&gt; ：此 CRD 用于定义应用程序的仪表化。它指定要使用 OpenTelemetry API 的哪些组件、要收集哪些数据以及如何将该数据导出到后端。&lt;/p&gt;
&lt;p&gt;使用 otelinst CRD，您可以指定要仪表化的应用程序的名称、语言和运行时环境、跟踪的采样率以及要使用的导出器类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;otelcol&lt;/code&gt;&lt;/strong&gt;：此 CRD 用于定义 OpenTelemetry 收集器的行为。它指定收集器的配置，包括接收器（遥测数据源）、处理器（用于过滤和转换数据）和导出器（用于将数据发送到后端）。&lt;/p&gt;
&lt;p&gt;使用 otelcol CRD，您可以指定要用于通信的协议，例如 Google 远程过程调用（gRPC）或 HTTP，要使用哪些接收器和导出器，以及任何其他配置选项。&lt;/p&gt;
&lt;h2 id=&#34;安装-opentelemetry-kubernetes-operator&#34;&gt;安装 OpenTelemetry Kubernetes Operator&lt;/h2&gt;
&lt;p&gt;OpenTelemetry Kubernetes Operator 可以使用各种方法安装，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Operator 生命周期管理器 (OLM)。这是&lt;a href=&#34;https://olm.operatorframework.io/docs/tasks/install-operator-with-olm/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;推荐的方法&lt;/a&gt;，因为它提供了方便的安装、升级和管理 Operator 的方法。&lt;/li&gt;
&lt;li&gt;Helm charts。Helm 是 Kubernetes 的软件包管理器，提供了一种在 Kubernetes 上部署和管理应用程序的简单方法。OpenTelemetry operator 的 Helm charts &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-helm-charts/tree/main/charts/opentelemetry-operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可用&lt;/a&gt;，可用于部署 Operator。&lt;/li&gt;
&lt;li&gt;Kubernetes 清单。Operator 也可以使用 Kubernetes 清单进行安装，后者提供了一种声明性的方式来管理 Kubernetes 资源。Operator 清单可以根据特定要求进行定制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要收集遥测数据，我们需要使用创建遥测信号的代码仪表化我们的应用程序。有不同的方法来为遥测数据仪表化应用程序。&lt;/p&gt;
&lt;h3 id=&#34;显式手动方法&#34;&gt;显式/手动方法&lt;/h3&gt;
&lt;p&gt;在此方法中，开发人员明确向其应用程序添加仪表化代码，以创建日志、度量和跟踪等遥测信号。这种方法使开发人员对遥测数据更具控制力，但可能耗时且容易出错。&lt;/p&gt;
&lt;h3 id=&#34;直接集成在运行时&#34;&gt;直接集成在运行时&lt;/h3&gt;
&lt;p&gt;某些运行时，例如 &lt;a href=&#34;https://quarkus.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quarkus&lt;/a&gt; 和 &lt;a href=&#34;https://www.wildfly.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WildFly&lt;/a&gt; 框架，直接与 OpenTelemetry 集成。这意味着开发人员无需向其应用程序添加仪表化代码，运行时会自动为他们生成遥测数据。这种方法可能更易于使用，要求更少的维护工作，但比显式/手动方法灵活性可能较差。&lt;/p&gt;
&lt;p&gt;直接集成在运行时的主要缺点是，仪表化仅限于支持的框架。如果应用程序使用不受支持的框架，则可能无法有效捕获遥测数据或需要额外的自定义仪表化。&lt;/p&gt;
&lt;p&gt;如果所选运行时或框架仅与特定的可观察性供应商兼容，则此方法还可能导致供应商锁定。&lt;/p&gt;
&lt;p&gt;因此，此方法可能不适用于所有应用程序或组织，特别是如果他们需要在选择可观察性堆栈或需要仪器化各种框架和库时具有灵活性。&lt;/p&gt;
&lt;h3 id=&#34;自动仪表化代理方法&#34;&gt;自动仪表化/代理方法&lt;/h3&gt;
&lt;p&gt;在此方法中，向应用程序运行时添加 OpenTelemetry 代理或自动仪表化库。代理/库自动为应用程序代码创建仪表化并生成遥测数据，而无需开发人员添加仪表化代码。&lt;/p&gt;
&lt;p&gt;这种方法可能是最易于使用的，需要最少的维护工作，但可能不太灵活，并且可能无法捕获所有相关的遥测数据。&lt;/p&gt;
&lt;p&gt;虽然自动仪表化/代理方法具有许多优点，但主要缺点之一是它可能消耗更多的内存和 CPU 周期，因为它支持广泛的框架并为应用程序中几乎所有 API 进行仪表化。这种附加开销可能会影响应用程序的性能，尤其是如果应用程序已经消耗了资源。&lt;/p&gt;
&lt;p&gt;此外，此方法可能无法捕获所有必要的遥测数据，或可能会导致错误的正面或负面结果。例如，它可能无法捕获某些边缘情况，或者可能捕获过多的数据，使查找相关信息变得困难。&lt;/p&gt;
&lt;p&gt;但是，尽管存在这些缺点，自动仪表化/代理方法仍然强烈推荐给刚开始使用观察性的组织，因为它提供了一种快速且简单的方法来快速收集遥测数据。&lt;/p&gt;
&lt;h2 id=&#34;传送遥测数据的收集和导出&#34;&gt;传送遥测数据的收集和导出&lt;/h2&gt;
&lt;p&gt;收集器负责接收来自仪器代码的遥测数据，处理并将其导出到平台进行存储和分析。收集器可以配置各种组件，例如接收器、处理器和导出器，以满足特定需求。&lt;/p&gt;
&lt;p&gt;接收器负责从各种来源（例如代理、导出器或网络）接受数据，而处理器则可以转换、过滤或增强数据。最后，导出器将数据发送到存储或分析平台，例如 Prometheus 或 Jaeger。&lt;/p&gt;
&lt;p&gt;收集器有两个版本，Core 和 Contrib。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-releases/tree/main/distributions/otelcol&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Core&lt;/a&gt; 是官方版本，包含稳定和经过充分测试的组件，而 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Contrib&lt;/a&gt; 是社区驱动版本，包含额外的实验性&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-releases/tree/main/distributions/otelcol-contrib&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;组件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;您还可以通过选择所需的组件并根据您的要求进行配置来构建自己的收集器。收集器用 Go 编写，这使得它易于部署和维护。&lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 网站上的文档&lt;/a&gt;提供了详细的指南，介绍如何设置、配置和使用收集器。&lt;/p&gt;
&lt;p&gt;在某些情况下，OpenTelemetry 可以作为 Prometheus 的替代品，特别是在边缘设备上资源有限的情况下。Prometheus 更加专注于监控和警报，而 OpenTelemetry 则专为可观察性而设计，并提供超出指标以外的功能，包括跟踪和日志记录。&lt;/p&gt;
&lt;p&gt;此外，OpenTelemetry 可以用于将数据导出到各种后端，包括 Prometheus，因此如果您愿意，仍然可以使用 Prometheus 进行监控和警报。OpenTelemetry 的灵活性和可扩展性使您可以将可观察性解决方案定制为符合您的特定需求和资源限制。&lt;/p&gt;
&lt;p&gt;OpenTelemetry Operator 负责部署和管理 OpenTelemetry Collector，该组件是收集、处理和导出遥测数据的中央组件。它不部署其他边车，例如 Envoy，但可以与它们一起工作以收集额外的遥测数据。&lt;/p&gt;
&lt;p&gt;OpenTelemetry Collector 可以以不同的模式部署，例如边车、daemonset、deployment 或 statefulset，具体取决于特定用例和要求。&lt;/p&gt;
&lt;p&gt;但是，如果目标是从群集中的节点收集日志，则将收集器部署为 daemonset 可以是一个不错的选择，因为它确保在每个节点上运行一个收集器实例，从而实现高效且可靠的日志收集。&lt;/p&gt;
&lt;h3 id=&#34;otel-收集器配置&#34;&gt;OTEL 收集器配置&lt;/h3&gt;
&lt;p&gt;以下是使用 otelcol 自定义资源定义部署 OpenTelemetry 收集器的 Kubernetes 清单文件示例：&lt;/p&gt;
&lt;p&gt;在此示例中，我们定义了一个名为 &lt;code&gt;otel-collector&lt;/code&gt; 的收集器，它使用 OTLP 接收器接收跟踪数据，使用 Prometheus 导出器将指标导出到 Prometheus 服务器，并使用两个处理器（&lt;code&gt;batch&lt;/code&gt; 和 &lt;code&gt;queued_retry&lt;/code&gt;）处理数据。config 字段指定收集器的配置，其格式为 YAML。&lt;/p&gt;
&lt;p&gt;使用 OpenTelemetry 收集跟踪、指标和日志在几个方面都很重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;增加可观察性。&lt;/strong&gt; 通过收集和关联跟踪、指标和日志，您可以更好地了解应用程序和系统的性能。增强的可观察性使您能够在影响用户之前快速识别和解决问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;改进故障排除。&lt;/strong&gt; OpenTelemetry 提供了一种收集遥测数据的标准化方式，这使得在整个堆栈中进行故障排除变得更加容易。通过在单个位置访问所有相关遥测数据，您可以快速找到问题的根本原因。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更好的性能优化。&lt;/strong&gt; 有了详细的遥测数据，您可以做出有关如何优化应用程序和系统以实现更好的性能和可靠性的明智决策。例如，通过分析指标，您可以确定系统中未利用或过度利用的区域，并相应地调整资源分配。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨平台兼容性。&lt;/strong&gt; OpenTelemetry 设计用于跨多种编程语言、框架和平台工作，这使得从堆栈的不同部分收集遥测数据变得更加容易。这种互操作性对于使用多种技术并需要在整个堆栈中标准化可观察性实践的组织非常重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;opentelemetry-日志&#34;&gt;OpenTelemetry 日志&lt;/h3&gt;
&lt;p&gt;OpenTelemetry 日志提供了一种标准化的方式来收集、处理和分析分布式系统中的日志。通过使用 OpenTelemetry 收集日志，开发人员可以避免日志分布在多个系统和不同格式的问题，从而难以分析和排除问题。&lt;/p&gt;
&lt;p&gt;使用 OpenTelemetry 日志，开发人员可以从多个来源收集日志，包括传统的日志库，然后使用通用格式和 API 处理和分析它们。这允许更好地与可观察性堆栈的其他部分（例如指标和跟踪）集成，并提供更完整的系统行为视图。&lt;/p&gt;
&lt;p&gt;此外，OpenTelemetry 日志提供了一种将日志与其他上下文信息（例如有关请求、用户或环境的元数据）进行丰富的方法，这些信息可以用于使日志分析更有意义和有效。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-的下一步是什么&#34;&gt;OpenTelemetry 的下一步是什么？&lt;/h2&gt;
&lt;h3 id=&#34;web-服务器的自动化仪器化&#34;&gt;Web 服务器的自动化仪器化&lt;/h3&gt;
&lt;p&gt;OTEL &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-cpp-contrib/tree/main/instrumentation/otel-webserver-module#otel-webserver-module&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;webserver&lt;/a&gt; 模块包括 Apache 和 &lt;a href=&#34;https://www.nginx.com/?utm_content=inline-mention&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nginx&lt;/a&gt; 仪器化。Apache 模块负责在运行时将仪器化注入到 Apache 服务器中，以跟踪传入请求到服务器。它捕获参与传入请求的许多模块的响应时间，包括 mod_proxy。这使得可以捕获每个模块的分层时间消耗。&lt;/p&gt;
&lt;p&gt;类似地，Nginx web 服务器模块也可以通过在运行时将仪器化注入到 Nginx 服务器中来跟踪传入请求到服务器。它捕获涉及请求处理的各个模块的响应时间。&lt;/p&gt;
&lt;h3 id=&#34;opentelemetry-profile&#34;&gt;OpenTelemetry Profile&lt;/h3&gt;
&lt;p&gt;此 &lt;a href=&#34;https://github.com/open-telemetry/oteps/blob/main/text/profiles/0212-profiling-vision.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt; 概述了 OpenTelemetry 项目中的分析支持的长期愿景。该计划是 OpenTelemetry 社区成员之间的讨论和协作的结果，代表了各种行业和专业知识的多元化。&lt;/p&gt;
&lt;p&gt;该文档旨在指导 OpenTelemetry 中的分析支持开发，但并非要求清单。预计随着学习和反馈的增加，该愿景将随时间演化和完善。&lt;/p&gt;
&lt;h3 id=&#34;open-agent-management-protocol&#34;&gt;Open Agent Management Protocol&lt;/h3&gt;
&lt;p&gt;Open Agent Management Protocol (OpAMP) 是一种网络协议，可实现对大型数据收集代理群集的远程管理。它允许代理报告其状态并从服务器接收配置，并从服务器接收代理安装包更新。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/open-telemetry/opamp-spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpAMP&lt;/a&gt; 是供应商无关的，因此服务器可以远程监视和管理实现 OpAMP 的不同供应商的代理群集，包括来自不同供应商的混合代理群集。&lt;/p&gt;
&lt;p&gt;它支持代理的远程配置、状态报告、代理自身的遥测报告、可下载特定于代理的软件包的管理、安全自动更新功能和连接凭据管理。此功能允许管理大型混合代理群集的单个窗口视图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生社区 meetup 第二期北京站</title>
      <link>https://cloudnative.to/event/cloud-native-meetup-beijing-02/</link>
      <pubDate>Sun, 20 Dec 2020 13:00:00 +0800</pubDate>
      <guid>https://cloudnative.to/event/cloud-native-meetup-beijing-02/</guid>
      <description>&lt;h3 id=&#34;istio-18还是从前那个少年&#34;&gt;Istio 1.8——还是从前那个少年&lt;/h3&gt;
&lt;p&gt;讲师：宋净超（Tetrate 布道师、云原生社区创始人）&lt;/p&gt;
&lt;p&gt;个人介绍：Tetrate 布道师、CNCF Ambassador、云原生社区 创始人、电子工业出版社优秀译者、出品人。Kubernetes、Istio 等技术的早期使用及推广者。曾就职于科大讯飞、TalkingData 和蚂蚁集团。&lt;/p&gt;
&lt;p&gt;议题简介：带你回顾 Istio 的发展历程，看他是否还是从前那个少年，“没有一丝丝改变”，能够经历时间的考验。带你一起来了解 Istio 1.8 的新特性，看它是如何作为传统和现代应用的桥接器，成为云原生应用中的中流砥柱。同时也会为你分享云原生社区的规划，为了推行云原生，我们在行动。&lt;/p&gt;
&lt;h3 id=&#34;百度服务网格在金融行业的大规模落地实践&#34;&gt;百度服务网格在金融行业的大规模落地实践&lt;/h3&gt;
&lt;p&gt;讲师：孙召昌（百度高级研发工程师）&lt;/p&gt;
&lt;p&gt;个人介绍：百度高级研发工程师，现就职于百度基础架构部云原生团队，参与了服务网格产品的研发工作和大规模落地实践，对云原生、微服务、Service Mesh 等方向有深入的研究和实践经验。&lt;/p&gt;
&lt;p&gt;议题简介：百度服务网格技术在金融行业大规模落地过程的实践经验和思考，主要包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持传统微服务应用的平滑迁移，兼容 SpringCloud 和 Dubbo 应用；&lt;/li&gt;
&lt;li&gt;灵活对接多种注册中心，支持百万级别的服务注册和发现；&lt;/li&gt;
&lt;li&gt;提供丰富的流量治理策略，包括自定义路由、全链路灰度等；&lt;/li&gt;
&lt;li&gt;实现业务无侵入的指标统计和调用链展示，满足用户的可观测性需求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;apachedubbo-go-在云原生时代的实践与探索&#34;&gt;Apache/Dubbo-go 在云原生时代的实践与探索&lt;/h3&gt;
&lt;p&gt;讲师：赵新（于雨）&lt;/p&gt;
&lt;p&gt;个人介绍：于雨（GitHub ID AlexStocks），dubbogo 社区负责人，一个有十多年服务端基础架构研发经验的一线程序员，陆续改进过 Redis/Muduo/Pika/Dubbo/Dubbo-go/Sentinel-go 等知名项目，目前在蚂蚁集团可信原生部从事容器编排和 Service Mesh 工作。&lt;/p&gt;
&lt;p&gt;议题简介：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于 Kubernetes 的微服务通信能力&lt;/li&gt;
&lt;li&gt;基于 MOSN 的云原生 Service Mesh 能力&lt;/li&gt;
&lt;li&gt;基于应用级注册的服务自省能力&lt;/li&gt;
&lt;li&gt;dubbo-go 3.0 规划&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;合影中场休息签售&#34;&gt;合影、中场休息、签售&lt;/h3&gt;
&lt;p&gt;中场休息时会有《云原生操作系统 Kubernetes》作者之一张城为大家现场签售。&lt;/p&gt;
&lt;h3 id=&#34;云原生下的可观测性&#34;&gt;云原生下的可观测性&lt;/h3&gt;
&lt;p&gt;讲师：张城（元乙）&lt;/p&gt;
&lt;p&gt;个人介绍：阿里云技术专家，负责阿里巴巴集团、蚂蚁金服、阿里云等日志采集基础设施，服务数万内外部客户，日流量数十 PB。同时负责云原生相关的日志/监控解决方案，包括系统组件，负载均衡，审计，安全，Service Mesh，事件，应用等监控方案。目前主要关注可观测性、AIOps、大规模分析引擎等方向。&lt;/p&gt;
&lt;p&gt;议题简介：近年来随着云原生技术的普及，PaaS 和 SaaS 化的程度越来越高，传统的监控系统正在朝可观测性系统的方向演进。在这背景下 OpenTelemetry 诞生，OpenTelemetry 为我们带来了 Metric、Tracing、Logging 的统一标准，便于我们构建一个统一的可观测性平台。&lt;/p&gt;
&lt;h3 id=&#34;云原生分布式存储解决方案实践&#34;&gt;云原生分布式存储解决方案实践&lt;/h3&gt;
&lt;p&gt;讲师：刘硕然（OPPO）&lt;/p&gt;
&lt;p&gt;个人介绍：OPPO 互联网云平台分布式文件存储技术负责人，ChubaoFS 初创成员及项目维护者。&lt;/p&gt;
&lt;p&gt;议题简介：ChubaoFS 是云原生的分布式存储系统，目前已经在多家公司生产环境为大规模容器平台的云原生应用提供分布式存储解决方案。主要特点包括高可用，高可扩展，多租户，文件及对象双接口等。与云原生社区的生态也有非常紧密的结合，目前监控使用 Prometheus，部署支持 Helm，使用支持 CSI driver。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
