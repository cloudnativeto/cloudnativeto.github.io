<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cilium | 云原生社区</title>
    <link>https://cloudnative.to/tag/cilium/</link>
      <atom:link href="https://cloudnative.to/tag/cilium/index.xml" rel="self" type="application/rss+xml" />
    <description>Cilium</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Wed, 07 Nov 2018 14:14:01 +0800</lastBuildDate>
    <image>
      <url>https://cloudnative.to/media/sharing.png</url>
      <title>Cilium</title>
      <link>https://cloudnative.to/tag/cilium/</link>
    </image>
    
    <item>
      <title>Cilium——具备API感知的网络和安全性管理的开源软件</title>
      <link>https://cloudnative.to/blog/cilium-intro/</link>
      <pubDate>Wed, 07 Nov 2018 14:14:01 +0800</pubDate>
      <guid>https://cloudnative.to/blog/cilium-intro/</guid>
      <description>&lt;p&gt;Cilium是一个纯开源软件，没有哪家公司提供商业化支持，也不是由某一公司开源，该软件用于透明地保护使用Linux容器管理平台（如Docker和Kubernetes）部署的应用程序服务之间的网络连接。&lt;/p&gt;
&lt;p&gt;Cilium的基础是一种名为BPF的新Linux内核技术，它可以在Linux本身动态插入强大的安全可见性和控制逻辑。由于BPF在Linux内核中运行，因此可以应用和更新Cilium安全策略，而无需对应用程序代码或容器配置进行任何更改。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-cilium&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Cilium&#34; srcset=&#34;
               /blog/cilium-intro/006tNbRwly1fwqi98i51ij30sc0j80zn_hu3f661752bfb531b8d6f318106cbbbfe4_225375_aca94013f9fafede75bfd682b26260b9.webp 400w,
               /blog/cilium-intro/006tNbRwly1fwqi98i51ij30sc0j80zn_hu3f661752bfb531b8d6f318106cbbbfe4_225375_ec0a1dd2b1f5623495faf740cea27eae.webp 760w,
               /blog/cilium-intro/006tNbRwly1fwqi98i51ij30sc0j80zn_hu3f661752bfb531b8d6f318106cbbbfe4_225375_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://cloudnative.to/blog/cilium-intro/006tNbRwly1fwqi98i51ij30sc0j80zn_hu3f661752bfb531b8d6f318106cbbbfe4_225375_aca94013f9fafede75bfd682b26260b9.webp&#34;
               width=&#34;760&#34;
               height=&#34;516&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Cilium
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;基于微服务的应用程序分为小型独立服务，这些服务使用&lt;strong&gt;HTTP&lt;/strong&gt;、&lt;strong&gt;gRPC&lt;/strong&gt;、&lt;strong&gt;Kafka&lt;/strong&gt;等轻量级协议通过API相互通信。但是，现有的Linux网络安全机制（例如iptables）仅在网络和传输层（即IP地址和端口）上运行，并且缺乏对微服务层的可见性。&lt;/p&gt;
&lt;p&gt;Cilium为Linux容器框架（如&lt;a href=&#34;https://www.docker.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Docker&lt;/strong&gt;&lt;/a&gt;和&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Kubernetes）&lt;/strong&gt;&lt;/a&gt;带来了API感知网络安全过滤。使用名为&lt;strong&gt;BPF&lt;/strong&gt;的新Linux内核技术，Cilium提供了一种基于容器/容器标识定义和实施网络层和应用层安全策略的简单而有效的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：Cilium中文意思是“纤毛“，它十分细小而又无处不在。&lt;/p&gt;
&lt;h2 id=&#34;bpf&#34;&gt;BPF&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;柏克莱封包过滤器&lt;/strong&gt;（Berkeley Packet Filter，缩写 BPF），是&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%B1%BBUnix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;类Unix&lt;/a&gt;系统上&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据链路层&lt;/a&gt;的一种原始接口，提供原始链路层&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B0%81%E5%8C%85&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;封包&lt;/a&gt;的收发，除此之外，如果网卡驱动支持&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%B4%AA%E6%B3%9B&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;洪泛&lt;/a&gt;模式，那么它可以让网卡处于此种模式，这样可以收到&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络&lt;/a&gt;上的所有包，不管他们的目的地是不是所在&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%A9%9F&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;主机&lt;/a&gt;。参考&lt;a href=&#34;https://zh.wikipedia.org/wiki/BPF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;维基百科&lt;/a&gt;和&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF简史&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性&lt;/h2&gt;
&lt;p&gt;以下是Cilium的特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于身份的安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cilium可见性和安全策略基于容器编排系统的标识（例如，Kubernetes中的Label）。在编写安全策略、审计和故障排查时，再也不用担心网络子网或容器IP地址了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;卓越的性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BPF利用Linux底层的强大能力，通过提供Linux内核的沙盒可编程性来实现数据路径，从而提供卓越的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API协议可见性+安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传统防火墙仅根据IP地址和端口等网络标头查看和过滤数据包。Cilium也可以这样做，但也可以理解并过滤单个HTTP、gRPC和Kafka请求，这些请求将微服务拼接在一起。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专为扩展而设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cilium是为扩展而设计的，在部署新pod时不需要节点间交互，并且通过高度可扩展的键值存储进行所有协调。&lt;/p&gt;
&lt;h2 id=&#34;为什么选择cilium&#34;&gt;为什么选择Cilium？&lt;/h2&gt;
&lt;p&gt;现代数据中心应用程序的开发已经转向面向服务的体系结构（SOA），通常称为&lt;em&gt;微服务&lt;/em&gt;，其中大型应用程序被分成小型独立服务，这些服务使用HTTP等轻量级协议通过API相互通信。微服务应用程序往往是高度动态的，作为持续交付的一部分部署的滚动更新期间单个容器启动或销毁，应用程序扩展/缩小以适应负载变化。&lt;/p&gt;
&lt;p&gt;这种向高度动态的微服务的转变过程，给确保微服务之间的连接方面提出了挑战和机遇。传统的Linux网络安全方法（例如iptables）过滤IP地址和TCP/UDP端口，但IP地址经常在动态微服务环境中流失。容器的高度不稳定的生命周期导致这些方法难以与应用程序并排扩展，因为负载均衡表和访问控制列表要不断更新，可能增长成包含数十万条规则。出于安全目的，协议端口（例如，用于HTTP流量的TCP端口80）不能再用于区分应用流量，因为该端口用于跨服务的各种消息。&lt;/p&gt;
&lt;p&gt;另一个挑战是提供准确的可见性，因为传统系统使用IP地址作为主要识别工具，其在微服务架构中的寿命可能才仅仅几秒钟，被大大缩短。&lt;/p&gt;
&lt;p&gt;利用Linux BPF，Cilium保留了透明地插入安全可视性+强制执行的能力，但这种方式基于服务/pod/容器标识（与传统系统中的IP地址识别相反），并且可以根据应用层进行过滤 （例如HTTP）。因此，通过将安全性与寻址分离，Cilium不仅可以在高度动态的环境中应用安全策略，而且除了提供传统的第3层和第4层分割之外，还可以通过在HTTP层运行来提供更强的安全隔离。 。&lt;/p&gt;
&lt;p&gt;BPF的使用使得Cilium能够以高度可扩展的方式实现以上功能，即使对于大规模环境也不例外。&lt;/p&gt;
&lt;h2 id=&#34;功能概述&#34;&gt;功能概述&lt;/h2&gt;
&lt;h3 id=&#34;透明的保护api&#34;&gt;透明的保护API&lt;/h3&gt;
&lt;p&gt;能够保护现代应用程序协议，如REST/HTTP、gRPC和Kafka。传统防火墙在第3层和第4层运行，在特定端口上运行的协议要么完全受信任，要么完全被阻止。Cilium提供了过滤各个应用程序协议请求的功能，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许所有带有方法&lt;code&gt;GET&lt;/code&gt;和路径&lt;code&gt;/public/.*&lt;/code&gt;的HTTP请求。拒绝所有其他请求。&lt;/li&gt;
&lt;li&gt;允许&lt;code&gt;service1&lt;/code&gt;在Kafka topic上生成&lt;code&gt;topic1&lt;/code&gt;，&lt;code&gt;service2&lt;/code&gt;消费&lt;code&gt;topic1&lt;/code&gt;。拒绝所有其他Kafka消息。&lt;/li&gt;
&lt;li&gt;要求HTTP标头&lt;code&gt;X-Token: [0-9]+&lt;/code&gt;出现在所有REST调用中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详情请参考&lt;a href=&#34;http://docs.cilium.io/en/stable/policy/#layer-7&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;7层协议&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;基于身份来保护服务间通信&#34;&gt;基于身份来保护服务间通信&lt;/h3&gt;
&lt;p&gt;现代分布式应用程序依赖于诸如容器之类的技术来促进敏捷性并按需扩展。这将导致在短时间内启动大量应用容器。典型的容器防火墙通过过滤源IP地址和目标端口来保护工作负载。这就要求不论在集群中的哪个位置启动容器时都要操作所有服务器上的防火墙。&lt;/p&gt;
&lt;p&gt;为了避免受到规模限制，Cilium为共享相同安全策略的应用程序容器组分配安全标识。然后，该标识与应用程序容器发出的所有网络数据包相关联，从而允许验证接收节点处的身份。使用键值存储执行安全身份管理。&lt;/p&gt;
&lt;h3 id=&#34;安全访问外部服务&#34;&gt;安全访问外部服务&lt;/h3&gt;
&lt;p&gt;基于标签的安全性是集群内部访问控制的首选工具。为了保护对外部服务的访问，支持入口（ingress）和出口（egress）的传统基于CIDR的安全策略。这允许限制对应用程序容器的访问以及对特定IP范围的访问。&lt;/p&gt;
&lt;h3 id=&#34;简单网络&#34;&gt;简单网络&lt;/h3&gt;
&lt;p&gt;一个简单的扁平第3层网络能够跨越多个集群连接所有应用程序容器。使用主机范围分配器可以简化IP分配。这意味着每个主机可以在主机之间没有任何协调的情况下分配IP。&lt;/p&gt;
&lt;p&gt;支持以下多节点网络模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Overlay&lt;/strong&gt;：基于封装的虚拟网络产生所有主机。目前VXLAN和Geneve已经完成，但可以启用Linux支持的所有封装格式。&lt;/p&gt;
&lt;p&gt;何时使用此模式：此模式具有最小的基础架构和集成要求。它几乎适用于任何网络基础架构，唯一的要求是主机之间可以通过IP连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;本机路由&lt;/strong&gt;：使用Linux主机的常规路由表。网络必须能够路由应用程序容器的IP地址。&lt;/p&gt;
&lt;p&gt;何时使用此模式：此模式适用于高级用户，需要了解底层网络基础结构。此模式适用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地IPv6网络&lt;/li&gt;
&lt;li&gt;与云网络路由器配合使用&lt;/li&gt;
&lt;li&gt;如果您已经在运行路由守护进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h3&gt;
&lt;p&gt;应用程序容器和外部服务之间的流量的分布式负载均衡。负载均衡使用BPF实现，允许几乎无限的规模，并且如果未在源主机上执行负载均衡操作，则支持直接服务器返回（DSR）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：负载均衡需要启用连接跟踪。这是默认值。&lt;/p&gt;
&lt;h3 id=&#34;监控和故障排除&#34;&gt;监控和故障排除&lt;/h3&gt;
&lt;p&gt;可见性和故障排查是任何分布式系统运行的基础。虽然我们喜欢用&lt;code&gt;tcpdump&lt;/code&gt;和 &lt;code&gt;ping&lt;/code&gt;，它们很好用，但我们努力为故障排除提供更好的工具。包括以下工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用元数据进行事件监控：当数据包被丢弃时，该工具不仅仅报告数据包的源IP和目标IP，该工具还提供发送方和接收方的完整标签信息等。&lt;/li&gt;
&lt;li&gt;策略决策跟踪：为什么丢弃数据包或拒绝请求。策略跟踪框架允许跟踪运行工作负载和基于任意标签定义的策略决策过程。&lt;/li&gt;
&lt;li&gt;通过Prometheus导出指标：通过Prometheus导出关键指标，以便与现有仪表板集成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;集成&#34;&gt;集成&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网络插件集成：&lt;a href=&#34;https://github.com/containernetworking/cni&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNI&lt;/a&gt;、&lt;a href=&#34;https://github.com/docker/libnetwork&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libnetwork&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;容器运行时：&lt;a href=&#34;https://github.com/containerd/containerd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;containerd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kubernetes：&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/network-policies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NetworkPolicy&lt;/a&gt;、&lt;a href=&#34;https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Label&lt;/a&gt;、&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ingress&lt;/a&gt;、&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;日志记录：syslog、&lt;a href=&#34;http://www.fluentd.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fluentd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cilium.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium官方网站 - cilium.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF 简史 - ibm.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/25672552&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络层拦截可选项 - zhihu.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>探讨Service Mesh中一种更高效的代理模式</title>
      <link>https://cloudnative.to/blog/a-new-more-efficient-proxy-model/</link>
      <pubDate>Sun, 01 Jul 2018 12:33:23 +0800</pubDate>
      <guid>https://cloudnative.to/blog/a-new-more-efficient-proxy-model/</guid>
      <description>&lt;h2 id=&#34;背景和想法&#34;&gt;背景和想法&lt;/h2&gt;
&lt;p&gt;Service Mesh 提供了微服务化开发的新思路，核心思想是构建一个代理转发网络并结合控制和转发分离的做法来对成千上万个微服务间做流量、策略、安全等管理，而另一方面 Linux Kernel 提供一种运行时高效扩可编程的网络注入机制 eBPF，借此能实现 L47 层代理转发。假设借助 eBPF，作为 Service Mesh 的数据转发层，对接 Pilot、Mixer 等控制面，实现策略、流量和安全管理，是不是一种更高效的方式？这会比 Envoy 拥有更好的性能，虽然性能未必是 Mesh 首要考虑的问题，后搜索发现 Cilium 果然做了类似的尝试，详情见 &lt;a href=&#34;http://docs.cilium.io/en/latest/gettingstarted/istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://docs.cilium.io/en/latest/gettingstarted/istio/&lt;/a&gt;，但对接的方式很特别，并不像 Envoy 一样，为每一个 Pod 部署一个 Envoy 容器，而是在多个 Pod 外部署一个 Cilium，以 Kubernetes Daemon Set 模式部署，为多个 Pod 进行代理，对控制器层面的 Pilot 做了定制，部署配置如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sed -e &lt;span class=&#34;s1&#34;&gt;&amp;#39;s,docker\.io/istio/pilot:,docker.io/cilium/istio_pilot:,&amp;#39;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;      &amp;lt; &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;ISTIO_HOME&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;/install/kubernetes/istio.yaml &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;      kubectl create -f -
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Cilium 部署了一个“书店”集群服务为例子来说明，如下，在下发“路由策略”之前流量如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/a-new-more-efficient-proxy-model/00704eQkgy1fsu96134y9j30cj09rt93.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;正常流量从书页到详情页，到评论页面&lt;/p&gt;
&lt;p&gt;配置一条 istio 路由策略，把流量全部导向 reviews-v1，reviews-v2 没有流量&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;config.istio.io/v1alpha2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RouteRule&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reviews-default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;reviews&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;precedence&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;导流后如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/a-new-more-efficient-proxy-model/00704eQkgy1fsu96jwbo7j30jh0d8dgv.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;可见，Cilium 能识别 service-name 和 labels ，并进行导流。策略相当灵活。&lt;/p&gt;
&lt;p&gt;Cilium 还做了个性能测试，在 Pod - Proxy - Pod 场景下的请求延迟对比：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/a-new-more-efficient-proxy-model/00704eQkgy1fsu96qkxthj30jg0ay0um.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Cilium 的延迟全部小于当前的 Envoy、Nginx、Haproxy 代理。&lt;/p&gt;
&lt;h2 id=&#34;从服务化-springcloud-框架开始&#34;&gt;从服务化 SpringCloud 框架开始&lt;/h2&gt;
&lt;p&gt;我比较赞同微服务是一种 SOA 的衍生形态的观点，微服务并不完全是一种新的东西。SpringCloud 就是一种微服务化应用框架，目的在于帮助应用快速进行微服务化开发，官方定位如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提供了微服务所需的配置管理、服务发现、服务环路发现、智能路由、代理、全局锁、集群选主、分布式 Session、集群状态管理等基础能力。&lt;/p&gt;
&lt;h2 id=&#34;新服务化转折点-service-mesh&#34;&gt;新服务化转折点 Service Mesh&lt;/h2&gt;
&lt;p&gt;而 2016 年，两个不为人知的小项目 linked 和 Envoy 也许没有想到自己在两年后的今天承载了下一代微服务框架的使命：无侵入式微服务架构，这种架构目前有星星燎原之势取代 SpringCloud 模式成为转折点，新架构完全解耦微服务框架和应用，使应用节点不再关心服务注册、发现、调用等问题，应用只管把请求发送给与应用共部署的代理进程，这个代理进程对内外承接应用所有的请求，并自身组成一个网络，相互间调用，最终把请求返回给应用，这意味着应用只关心自身业务实现，不再关心请求是如何发送的，发送到哪里的，统一由代理进程进行转发。并且应用代码可以用任何语言实现，在代码层面和框架完全解耦，不像 SpringCloud 应用进程需要基于这个框架进行开发，而是彻底地从应用进程中分离，这种解耦似乎一下子使整体系统的复杂度下降了一个级别。框架从应用代码中完全下沉到了另一个代理进程中，应用和“代理”仅以标准的协议交互，换句话说，框架从函数级别的接口变成了进程间通讯接口。这种彻底的解耦让应用抛开“包袱”变得轻量，这在复杂系统和资源敏感型系统中非常有好处，比如应用可以使用相比 Java 占用资源的 golang 语言编写程序；比如改变业务代码更加容易，也不会因为框架改变导致业务代码改变。进而不妨再大胆想象一下，曾经我们使用的 database library 是否也可以从应用代码里剥离出来下沉到代理进程呢？&lt;/p&gt;
&lt;p&gt;2016年9月，Linked 背后的创业公司 Buoyant 第一次在 SF Microservices 提出了“Service Mesh” 概念，并随后在 2017 年 4月 William Morgan 给 Service Mesh 做了定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the service mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;are deployed alongside application code, without the application needing to be aware&lt;/strong&gt; 这句话道出了 mesh 的核心，即对应用无感知和无侵入。微服务框架从应用代码里剥离出来，从强依赖变成弱依赖，甚至无依赖，应用本身不再关心集群状态、调用路由、安全策略等等，甚至可以自由升级，框架升级不再影响应用自身，业务迭代变得更加迅速，解耦带来了巨大收益，架构变得更加优雅。&lt;/p&gt;
&lt;p&gt;Service Mesh 的两个核心组件为控制组件和数据组件，数据组件和应用一起部署，接管应用所有请求，应用只需访问类似 http://127.0.0.1/service 地址，剩下代理进程会转发请求到对应的对端服务，并实现服务发现注册、流量控制、安全控制等功能。所有代理进程相互连通，组成了像一个格子的网络，并整个网络被一个控制器管理，而这个网格就叫做 Mesh 。Service Mesh 的数据层组件的主要实现者是 Linked 和 Envoy。&lt;/p&gt;
&lt;p&gt;2017年5月24日，Google 和 IBM 高调发布了基于 Service Mesh 思想的服务化框架产品 Istio，出身名门的 Istio 一下子火了，并给当时出身草根的 Linked 产品承重一击，Linked 瞬间陷入了黑暗。Istio 数据层收编了 Envoy ，自己做了控制层，提供 Pilot、Mixer、Istio-Auth 三大组件，如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mixer：提供监控数据管理、路由、负载均衡、路由、调用追踪等流量管理，是控制器的核心，并提供后端对接平台，如k8s、Mesos等。&lt;/li&gt;
&lt;li&gt;Pilot（飞行员）: Mixer 的执行模块，负责对 Envoy 进行运行时配置。&lt;/li&gt;
&lt;li&gt;Istio-Auth：提供服务间 TLS 安全通信、角色鉴权、用户认证等 AAA 管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Envoy 与应用部署在一起，提供服务间请求高效转发，并提供扩展接口以实现不同的转发策略，同时上报流量监控数据，提供 HTTP、gRPC、TCP 转发能力。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/a-new-more-efficient-proxy-model/00704eQkgy1fsu97qrffkj31900oqwid.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;一开始 Linked 仅仅只有数据层面，是缺乏控制面的，而 Istio 一开始的定位就很清晰地包括了控制和数据面，后来 Buoyant 公司借鉴 Istio 的思想，开发了与 Istio 竞争的 Conduit，控制面用 Rust 开发，从这个角度讲， Google 似乎看得更远，Buoyant 挺有危机感。&lt;/p&gt;
&lt;p&gt;介绍完 Service Mesh，来看看能实现一个类似数据转发层的 eBPF 框架。&lt;/p&gt;
&lt;h2 id=&#34;新内核的网络利器-ebpf&#34;&gt;新内核的网络利器 eBPF&lt;/h2&gt;
&lt;p&gt;eBPF(Extended Berkeley Packet Filter)是 Kernel 3.18 之后的一个内核模块，提供了一种在网络栈的钩子节点处动态运行用户代码的能力，这种动态加载无需重启 Kernel ，用户使用 C 语言编写，由 llvm 编译成可执行文件，但因为是在内核态执行，eBPF 对用户代码非常严格，甚至提供了一个叫 verifier 的审核模块对用户代码进行检查，确保用户代码符合内核要求，并同时能在短时间内执行完毕，即便如此，只要设计巧妙，也能实现很高级的网络功能，Cilium 的能力和价值就在此了。&lt;/p&gt;
&lt;p&gt;编写 eBPF 的限制如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Kernel 4.16 和 LLVM 6.0 之前不支持普通函数调用，所有调用必须为内联函数&lt;/li&gt;
&lt;li&gt;最大只能执行 4096 个 BPF 指令&lt;/li&gt;
&lt;li&gt;不支持共享库调用（使用 bfp/lib 定义的库）&lt;/li&gt;
&lt;li&gt;不允许全局变量，但可以使用 &lt;code&gt;BPF_MAP_TYPE_PERCPU_ARRAY&lt;/code&gt; 作为全局 map 存储状态信息，并可以在多个 BPF 程序间共享数据&lt;/li&gt;
&lt;li&gt;不允许使用字符串常量和数组&lt;/li&gt;
&lt;li&gt;限制性的使用循环，BPF verifier 验证程序会检测代码是否有循环，使用 &lt;code&gt;#pragma unroll&lt;/code&gt; 和 &lt;code&gt;BPF_MAP_TYPE_PERCPU_ARRAY&lt;/code&gt; 最大只能支持 32 次迭代&lt;/li&gt;
&lt;li&gt;栈空间限制大小 512 bytes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了编写方便，内核也提供一些可以使用的组件如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Helper Func：提供一些从内核中读写数据流的函数集&lt;/li&gt;
&lt;li&gt;Maps：内核中存储 KV 的 Map 集，用于变相存储全局变量&lt;/li&gt;
&lt;li&gt;Tail Calls 和 BPF to BPF Calls：BPF 程序调用另一个 BPF 程序，这样就能使功能模块化了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他能力：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JIT：即时翻译执行代码能力&lt;/li&gt;
&lt;li&gt;Offloads：允许用户代码下沉到网卡中执行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总之，要编写一个高级 BPF 相对普通开发还是有难度的，下面介绍个简单的例子，主要实现对网卡上下行进出流量进行统计。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;开发环境准备&lt;/p&gt;
&lt;p&gt;当前 Ubuntu 17.04 以上版本，按照编译所依赖的包&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo apt-get install -y make gcc libssl-dev bc libelf-dev libcap-dev &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;clang gcc-multilib llvm libncurses5-dev git pkg-config libmnl bison flex &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;graphviz
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码代码 tc-example.c 实现对进出流量传输字节进行计数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#include &amp;lt;linux/pkt_cls.h&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#include &amp;lt;stdint.h&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#include &amp;lt;iproute2/bpf_elf.h&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#ifndef __section&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# define __section(NAME)                  \&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   __attribute__&lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;section&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;NAME&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;, used&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#endif&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#ifndef __inline&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# define __inline                         \&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   inline __attribute__&lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;always_inline&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#endif&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#ifndef lock_xadd&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# define lock_xadd(ptr, val)              \&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;void&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;__sync_fetch_and_add&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;ptr, val&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#endif&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#ifndef BPF_FUNC&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# define BPF_FUNC(NAME, ...)              \&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;*NAME&lt;span class=&#34;o&#34;&gt;)(&lt;/span&gt;__VA_ARGS__&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;void *&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;BPF_FUNC_##NAME
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#endif&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;static void *BPF_FUNC&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;map_lookup_elem, void *map, const void *key&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;struct bpf_elf_map acc_map __section&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;maps&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    .type           &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; BPF_MAP_TYPE_ARRAY,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    .size_key       &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sizeof&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;uint32_t&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    .size_value     &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; sizeof&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;uint32_t&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    .pinning        &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; PIN_GLOBAL_NS,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    .max_elem       &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; 2,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;static __inline int account_data&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;struct __sk_buff *skb, uint32_t dir&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    uint32_t *bytes&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nv&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; map_lookup_elem&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;acc_map, &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;dir&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;bytes&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            lock_xadd&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;bytes, skb-&amp;gt;len&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; TC_ACT_OK&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;__section&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;ingress&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int tc_ingress&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;struct __sk_buff *skb&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; account_data&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;skb, 0&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;__section&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;egress&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int tc_egress&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;struct __sk_buff *skb&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; account_data&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;skb, 1&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;char __license&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; __section&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;license&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;GPL&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/**
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	struct sk_buff - socket buffer, it&lt;span class=&#34;s1&#34;&gt;&amp;#39;s the primary struct for network.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *    See  https://elixir.bootlin.com/linux/latest/source/include/linux/skbuff.h)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@next: Next buffer in list
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@prev: Previous buffer in list
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@tstamp: Time we arrived/left
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@rbnode: RB tree node, alternative to next/prev for netem/tcp
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@sk: Socket we are owned by
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@dev: Device we arrived on/are leaving by
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@cb: Control buffer. Free for use by every layer. Put private vars here
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@_skb_refdst: destination entry (with norefcount bit)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@sp: the security path, used for xfrm
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@len: Length of actual data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@data_len: Data length
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@mac_len: Length of link layer header
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@hdr_len: writable header length of cloned skb
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@csum: Checksum (must include start/offset pair)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@csum_start: Offset from skb-&amp;gt;head where checksumming should start
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@csum_offset: Offset from csum_start where checksum should be stored
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@priority: Packet queueing priority
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@ignore_df: allow local fragmentation
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@cloned: Head may be cloned (check refcnt to be sure)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@ip_summed: Driver fed us an IP checksum
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@nohdr: Payload reference only, must not modify header
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@pkt_type: Packet class
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@fclone: skbuff clone status
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@ipvs_property: skbuff is owned by ipvs
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@tc_skip_classify: do not classify packet. set by IFB device
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@tc_at_ingress: used within tc_classify to distinguish in/egress
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@tc_redirected: packet was redirected by a tc action
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@tc_from_ingress: if tc_redirected, tc_at_ingress at time of redirect
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *	@peeked: this packet has been seen already, so stats have been
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt; *		done for it, don&amp;#39;&lt;/span&gt;t &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; them again
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@nf_trace: netfilter packet trace flag
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@protocol: Packet protocol from driver
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@destructor: Destruct &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@tcp_tsorted_anchor: list structure &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; TCP &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;tp-&amp;gt;tsorted_sent_queue&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@_nfct: Associated connection, &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; any &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;with nfctinfo bits&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@nf_bridge: Saved data about a bridged frame - see br_netfilter.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@skb_iif: ifindex of device we arrived on
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@tc_index: Traffic control index
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@hash: the packet &lt;span class=&#34;nb&#34;&gt;hash&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@queue_mapping: Queue mapping &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; multiqueue devices
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@xmit_more: More SKBs are pending &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; this queue
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@ndisc_nodetype: router &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;from link layer&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@ooo_okay: allow the mapping of a socket to a queue to be changed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@l4_hash: indicate &lt;span class=&#34;nb&#34;&gt;hash&lt;/span&gt; is a canonical 4-tuple &lt;span class=&#34;nb&#34;&gt;hash&lt;/span&gt; over transport
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *		ports.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@sw_hash: indicates &lt;span class=&#34;nb&#34;&gt;hash&lt;/span&gt; was computed in software stack
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@wifi_acked_valid: wifi_acked was &lt;span class=&#34;nb&#34;&gt;set&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@wifi_acked: whether frame was acked on wifi or not
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@no_fcs:  Request NIC to treat last &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; bytes as Ethernet FCS
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@csum_not_inet: use CRC32c to resolve CHECKSUM_PARTIAL
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@dst_pending_confirm: need to confirm neighbour
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  *	@napi_id: id of the NAPI struct this skb came from
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@secmark: security marking
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@mark: Generic packet mark
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@vlan_proto: vlan encapsulation protocol
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@vlan_tci: vlan tag control information
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@inner_protocol: Protocol &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;encapsulation&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@inner_transport_header: Inner transport layer header &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;encapsulation&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@inner_network_header: Network layer header &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;encapsulation&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@inner_mac_header: Link layer header &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;encapsulation&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@transport_header: Transport layer header
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@network_header: Network layer header
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@mac_header: Link layer header
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@tail: Tail pointer
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@end: End pointer
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@head: Head of buffer
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@data: Data head pointer
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@truesize: Buffer size
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; *	@users: User count - see &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;datagram,tcp&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;.c
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; */
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译成 BPF 可执行程序&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ clang -O2 -Wall -target bpf -c tc-example.c -o tc-example.o
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加载执行程序到网卡&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# tc qdisc add dev em1 clsact&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# tc filter add dev em1 ingress bpf da obj tc-example.o sec ingress&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# tc filter add dev em1 egress bpf da obj tc-example.o sec egress&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# tc filter show dev em1 ingress&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;filter protocol all pref &lt;span class=&#34;m&#34;&gt;49152&lt;/span&gt; bpf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;filter protocol all pref &lt;span class=&#34;m&#34;&gt;49152&lt;/span&gt; bpf handle 0x1 tc-example.o:&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;ingress&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; direct-action id &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; tag c5f7825e5dac396f
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# tc filter show dev em1 egress&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;filter protocol all pref &lt;span class=&#34;m&#34;&gt;49152&lt;/span&gt; bpf
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;filter protocol all pref &lt;span class=&#34;m&#34;&gt;49152&lt;/span&gt; bpf handle 0x1 tc-example.o:&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;egress&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; direct-action id &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; tag b2fd5adc0f262714
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# mount | grep bpf&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sysfs on /sys/fs/bpf &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; sysfs &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,seclabel&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bpf on /sys/fs/bpf &lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; bpf &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;rw,relatime,mode&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;0700&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# tree /sys/fs/bpf/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/sys/fs/bpf/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+-- ip -&amp;gt; /sys/fs/bpf/tc/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+-- tc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;   +-- globals
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;       +-- acc_map
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;+-- xdp -&amp;gt; /sys/fs/bpf/tc/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; directories, &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; file
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上展现了对当前网络数据包的操作，这种可编程的能力就给上层应用提供了无限的想象空间了，其中 Cilium 就是基于可编程 eBPF 之上开发了 L47 层网络管理框架。&lt;/p&gt;
&lt;h2 id=&#34;为服务化诞生的-cilium&#34;&gt;为服务化诞生的 Cilium&lt;/h2&gt;
&lt;p&gt;Cilium 是一个强大的以 eBPF 为基础的网络框架，能做到 L47 层的安全策略、流量控制，并且性能高、灵活性强，主要解决微服务的使用场景，能与 kubernetes 集成，官方解释如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cilium is open source software for transparently securing the network connectivity between application services deployed using Linux container management platforms like Docker and Kubernetes. The development of modern datacenter applications has shifted to a service-oriented architecture often referred to as microservices, wherein a large application is split into small independent services that communicate with each other via APIs using lightweight protocols like HTTP.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Cilium 就定位为微服务解决网络管理问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Microservices applications tend to be highly dynamic, with individual containers getting started or destroyed as the application scales out / in to adapt to load changes and during rolling updates that are deployed as part of continuous delivery. This shift toward highly dynamic microservices presents both a challenge and an opportunity in terms of securing connectivity between microservices.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要解决微服务架构下的网络问题的挑战和机会在于要适应微服务快速变化能力，因为微服务扩容和升级非常频繁，从而网络和安全管理也需要适应这种变革。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Traditional Linux network security approaches (e.g., iptables) filter on IP address and TCP/UDP ports, but IP addresses frequently churn in dynamic microservices environments. The highly volatile life cycle of containers causes these approaches to struggle to scale side by side with the application as load balancing tables and access control lists carrying hundreds of thousands of rules that need to be updated with a continuously growing frequency.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而使用传统的以 IP Base 的策略模型已经不再适应当今以微服务为模型的架构了，微服务的底层网络变化会非常灵活和迅速，如二层的网络 IP 地址可以迅速改变和销毁，传统安全策略如果基于 IP Policy 模型会产生成百上千条规则，并且这些规则会被频繁变更，变更的性能非常低下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By leveraging Linux BPF, Cilium retains the ability to transparently insert security visibility + enforcement, but does so in a way that is based on service / pod / container identity (in contrast to IP address identification in traditional systems) and can filter on application-layer (e.g. HTTP). As a result, Cilium not only makes it simple to apply security policies in a highly dynamic environment by decoupling security from addressing, but can also provide stronger security isolation by operating at the HTTP-layer in addition to providing traditional Layer 3 and Layer 4 segmentation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此 Cilium 利用 BPF 的能力，能以 service / pod / container 为对象进行动态地网络和安全策略管理，解耦控制面的策略管理和不断变化的网络环境，还做到 7 层能力。&lt;/p&gt;
&lt;p&gt;整体 Cilium 架构如下：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://raw.githubusercontent.com/servicemesher/website/master/content/blog/a-new-more-efficient-proxy-model/00704eQkgy1fsu98qo3jgj318z143gos.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;上层对接控制编排面，下层转换成 BPF 的程序注入到内核网络栈执行。&lt;/p&gt;
&lt;p&gt;已实现的功能如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持 HTTP 协议，支持 method、path、host、headers 匹配的策略&lt;/li&gt;
&lt;li&gt;支持 Kafka 的协议，支持 Role、topic 匹配的策略管理&lt;/li&gt;
&lt;li&gt;支持 IP/CIDR、Label、Service、Entities Base 的策略管理&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;监控和故障定位，支持对接 Prometheus 监控平台&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可见 Cilium 做得很高级，不仅仅支持了 HTTP，还支持 Kafka 协议，相信未来还会支持更多的协议，提供更强大的功能，虽然看上去目前只能做到转发层业务（主要以网络栈 HOOK 的方式），对需要新建网络连接的业务有限制，但结合上层应用实现，做到替换 Envoy 数据层还是有可能的，尽情期待。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文转载自：&lt;a href=&#34;http://yangjunsss.github.io/2018-05-12/%E6%8E%A2%E8%AE%A8%E4%B8%80%E7%A7%8D%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/?from=groupmessage&amp;amp;isappinstalled=0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;探讨一种更高效的代理模式&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
